
bootloader.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000e78c  08000000  08000000  00010000  2**8
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000164  20000000  0800e78c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002e8  20000164  0800e8f0  00020164  2**2
                  ALLOC
  3 .stack        00000804  2000044c  0800ebd8  00020164  2**0
                  ALLOC
  4 .debug_info   0002794d  00000000  00000000  00020164  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 00005406  00000000  00000000  00047ab1  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00010369  00000000  00000000  0004ceb7  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00001078  00000000  00000000  0005d220  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_ranges 000017e0  00000000  00000000  0005e298  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_macro  00031f2c  00000000  00000000  0005fa78  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   0001381e  00000000  00000000  000919a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0011bde8  00000000  00000000  000a51c2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000006e  00000000  00000000  001c0faa  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000037  00000000  00000000  001c1018  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00003464  00000000  00000000  001c1050  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000000 <_sfixed>:
 8000000:	20001c00 	.word	0x20001c00
 8000004:	080000b5 	.word	0x080000b5
 8000008:	0800001d 	.word	0x0800001d
 800000c:	0800001f 	.word	0x0800001f
 8000010:	08000021 	.word	0x08000021
 8000014:	08000023 	.word	0x08000023
 8000018:	08000025 	.word	0x08000025

0800001c <NMI_Handler>:
 800001c:	be01      	bkpt	0x0001

0800001e <HardFault_Handler>:
 800001e:	be02      	bkpt	0x0002

08000020 <MemManage_Handler>:
 8000020:	be03      	bkpt	0x0003

08000022 <BusFault_Handler>:
 8000022:	be04      	bkpt	0x0004

08000024 <UsageFault_Handler>:
 8000024:	be05      	bkpt	0x0005
 8000026:	e7fe      	b.n	8000026 <UsageFault_Handler+0x2>

08000028 <bootloader_info>:
	...
 8000040:	08000305 	.word	0x08000305

08000044 <my_version_code>:
 8000044:	00000100 	.word	0x00000100
	...
 8000060:	20296328 	.word	0x20296328
 8000064:	79706f43 	.word	0x79706f43
 8000068:	68676972 	.word	0x68676972
 800006c:	30322074 	.word	0x30322074
 8000070:	322d3831 	.word	0x322d3831
 8000074:	20323230 	.word	0x20323230
 8000078:	43207962 	.word	0x43207962
 800007c:	6b6e696f 	.word	0x6b6e696f
 8000080:	20657469 	.word	0x20657469
 8000084:	2e636e49 	.word	0x2e636e49
 8000088:	0a200a20 	.word	0x0a200a20
 800008c:	73696854 	.word	0x73696854
 8000090:	61707320 	.word	0x61707320
 8000094:	66206563 	.word	0x66206563
 8000098:	7220726f 	.word	0x7220726f
 800009c:	21746e65 	.word	0x21746e65
 80000a0:	73754a20 	.word	0x73754a20
 80000a4:	42312074 	.word	0x42312074
 80000a8:	792f4354 	.word	0x792f4354
 80000ac:	2e726165 	.word	0x2e726165
 80000b0:	0a200a20 	.word	0x0a200a20

080000b4 <reset_entry>:
 80000b4:	f000 f816 	bl	80000e4 <firewall_setup>
 80000b8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80000bc:	f04f 0100 	mov.w	r1, #0
 80000c0:	f04f 0200 	mov.w	r2, #0
 80000c4:	f04f 0300 	mov.w	r3, #0
 80000c8:	f000 f91c 	bl	8000304 <callgate_entry0>
 80000cc:	f248 0120 	movw	r1, #32800	; 0x8020
 80000d0:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80000d4:	6808      	ldr	r0, [r1, #0]
 80000d6:	4685      	mov	sp, r0
 80000d8:	f04f 0001 	mov.w	r0, #1
 80000dc:	f8d1 e004 	ldr.w	lr, [r1, #4]
 80000e0:	4770      	bx	lr
	...

080000e4 <firewall_setup>:
    void
firewall_setup(void)
{
    // This is critical: without the clock enabled to "SYSCFG" we
    // can't tell the FW is enabled or not! Enabling it would also not work
    __HAL_RCC_SYSCFG_CLK_ENABLE();
 80000e4:	4b23      	ldr	r3, [pc, #140]	; (8000174 <firewall_setup+0x90>)
// It's best if this is outside the firewall. After we return, we'll
// jump into setup code contained inside the firewall. Called from startup.S
//
    void
firewall_setup(void)
{
 80000e6:	b500      	push	{lr}
    // This is critical: without the clock enabled to "SYSCFG" we
    // can't tell the FW is enabled or not! Enabling it would also not work
    __HAL_RCC_SYSCFG_CLK_ENABLE();
 80000e8:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80000ea:	f042 0201 	orr.w	r2, r2, #1
 80000ee:	661a      	str	r2, [r3, #96]	; 0x60
 80000f0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
// It's best if this is outside the firewall. After we return, we'll
// jump into setup code contained inside the firewall. Called from startup.S
//
    void
firewall_setup(void)
{
 80000f2:	b08b      	sub	sp, #44	; 0x2c
    // This is critical: without the clock enabled to "SYSCFG" we
    // can't tell the FW is enabled or not! Enabling it would also not work
    __HAL_RCC_SYSCFG_CLK_ENABLE();
 80000f4:	f003 0301 	and.w	r3, r3, #1
 80000f8:	9300      	str	r3, [sp, #0]
 80000fa:	9b00      	ldr	r3, [sp, #0]

    if(__HAL_FIREWALL_IS_ENABLED()) {
 80000fc:	4b1e      	ldr	r3, [pc, #120]	; (8000178 <firewall_setup+0x94>)
 80000fe:	685b      	ldr	r3, [r3, #4]
 8000100:	07db      	lsls	r3, r3, #31
 8000102:	d533      	bpl.n	800016c <firewall_setup+0x88>
    // REMINDERS: 
    // - cannot debug anything in boot loader w/ firewall enabled (no readback, no bkpt)
    // - when RDP=2, this protection still important or else python can read pairing secret
    // - in factory mode (RDP!=2), it's nice to have this disabled so we can debug still
    // - could look at RDP level here, but it would be harder to completely reset the bag number!
    if(check_all_ones_raw(rom_secrets->bag_number, sizeof(rom_secrets->bag_number))) {
 8000104:	2120      	movs	r1, #32
 8000106:	481d      	ldr	r0, [pc, #116]	; (800017c <firewall_setup+0x98>)
 8000108:	f002 fa8e 	bl	8002628 <check_all_ones_raw>
 800010c:	2800      	cmp	r0, #0
 800010e:	d12d      	bne.n	800016c <firewall_setup+0x88>
    // for debug builds, never enable firewall
    return;
#endif

    extern int firewall_starts;       // see startup.S ... aligned@256 (0x08000300)
    uint32_t    start = (uint32_t)&firewall_starts;
 8000110:	491b      	ldr	r1, [pc, #108]	; (8000180 <firewall_setup+0x9c>)
    uint32_t    len = BL_FLASH_SIZE - (start - BL_FLASH_BASE);
 8000112:	f1c1 6300 	rsb	r3, r1, #134217728	; 0x8000000

#if 1
    ASSERT(start);
    ASSERT(!(start & 0xff));
 8000116:	f011 0fff 	tst.w	r1, #255	; 0xff
    return;
#endif

    extern int firewall_starts;       // see startup.S ... aligned@256 (0x08000300)
    uint32_t    start = (uint32_t)&firewall_starts;
    uint32_t    len = BL_FLASH_SIZE - (start - BL_FLASH_BASE);
 800011a:	f503 33f0 	add.w	r3, r3, #122880	; 0x1e000

#if 1
    ASSERT(start);
    ASSERT(!(start & 0xff));
 800011e:	d001      	beq.n	8000124 <firewall_setup+0x40>
 8000120:	4818      	ldr	r0, [pc, #96]	; (8000184 <firewall_setup+0xa0>)
 8000122:	e015      	b.n	8000150 <firewall_setup+0x6c>
    ASSERT(len>256);
 8000124:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8000128:	d9fa      	bls.n	8000120 <firewall_setup+0x3c>
    ASSERT(!(len & 0xff));
 800012a:	f013 02ff 	ands.w	r2, r3, #255	; 0xff
 800012e:	d1f7      	bne.n	8000120 <firewall_setup+0x3c>
    //   but sensitive stuff is still there (which would allow bypass)
    // - so it's important to enable option bytes to set write-protect on entire bootloader
    // - to disable debug and complete protection, must enable write-protect "level 2"
    //

    FIREWALL_InitTypeDef init = {
 8000130:	9303      	str	r3, [sp, #12]
 8000132:	4b15      	ldr	r3, [pc, #84]	; (8000188 <firewall_setup+0xa4>)
 8000134:	9304      	str	r3, [sp, #16]
        .VDataSegmentLength = 0,
        .VolatileDataExecution = 0,
        .VolatileDataShared = 0,
    };

    int rv = HAL_FIREWALL_Config((FIREWALL_InitTypeDef *)&init);
 8000136:	a802      	add	r0, sp, #8
    //   but sensitive stuff is still there (which would allow bypass)
    // - so it's important to enable option bytes to set write-protect on entire bootloader
    // - to disable debug and complete protection, must enable write-protect "level 2"
    //

    FIREWALL_InitTypeDef init = {
 8000138:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800013c:	9102      	str	r1, [sp, #8]
 800013e:	9305      	str	r3, [sp, #20]
 8000140:	9206      	str	r2, [sp, #24]
 8000142:	9207      	str	r2, [sp, #28]
 8000144:	9208      	str	r2, [sp, #32]
 8000146:	9209      	str	r2, [sp, #36]	; 0x24
        .VDataSegmentLength = 0,
        .VolatileDataExecution = 0,
        .VolatileDataShared = 0,
    };

    int rv = HAL_FIREWALL_Config((FIREWALL_InitTypeDef *)&init);
 8000148:	f000 f824 	bl	8000194 <HAL_FIREWALL_Config>
    if(rv) {
 800014c:	b110      	cbz	r0, 8000154 <firewall_setup+0x70>
        INCONSISTENT("fw");
 800014e:	480f      	ldr	r0, [pc, #60]	; (800018c <firewall_setup+0xa8>)
 8000150:	f000 fc44 	bl	80009dc <fatal_error>
    }

    __HAL_FIREWALL_PREARM_DISABLE();
 8000154:	4b0e      	ldr	r3, [pc, #56]	; (8000190 <firewall_setup+0xac>)
 8000156:	6a1a      	ldr	r2, [r3, #32]
 8000158:	f022 0201 	bic.w	r2, r2, #1
 800015c:	621a      	str	r2, [r3, #32]
 800015e:	6a1b      	ldr	r3, [r3, #32]
 8000160:	f003 0301 	and.w	r3, r3, #1
 8000164:	9301      	str	r3, [sp, #4]
 8000166:	9b01      	ldr	r3, [sp, #4]
    HAL_FIREWALL_EnableFirewall();
 8000168:	f000 f894 	bl	8000294 <HAL_FIREWALL_EnableFirewall>
}
 800016c:	b00b      	add	sp, #44	; 0x2c
 800016e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000172:	bf00      	nop
 8000174:	40021000 	.word	0x40021000
 8000178:	40010000 	.word	0x40010000
 800017c:	0801e050 	.word	0x0801e050
 8000180:	08000300 	.word	0x08000300
 8000184:	0800d558 	.word	0x0800d558
 8000188:	0801e000 	.word	0x0801e000
 800018c:	0800d55f 	.word	0x0800d55f
 8000190:	40011c00 	.word	0x40011c00

08000194 <HAL_FIREWALL_Config>:
  * @param fw_init: Firewall initialization structure
  * @note  The API returns HAL_ERROR if the Firewall is already enabled.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_FIREWALL_Config(FIREWALL_InitTypeDef * fw_init)
{
 8000194:	b513      	push	{r0, r1, r4, lr}
  /* Check the Firewall initialization structure allocation */
  if(fw_init == NULL)
 8000196:	b908      	cbnz	r0, 800019c <HAL_FIREWALL_Config+0x8>
  {
    return HAL_ERROR;
 8000198:	2001      	movs	r0, #1
 800019a:	e037      	b.n	800020c <HAL_FIREWALL_Config+0x78>
  }

  /* Enable Firewall clock */
  __HAL_RCC_FIREWALL_CLK_ENABLE();
 800019c:	4b1c      	ldr	r3, [pc, #112]	; (8000210 <HAL_FIREWALL_Config+0x7c>)
 800019e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80001a0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80001a4:	661a      	str	r2, [r3, #96]	; 0x60
 80001a6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80001a8:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80001ac:	9301      	str	r3, [sp, #4]
 80001ae:	9b01      	ldr	r3, [sp, #4]

  /* Make sure that Firewall is not enabled already */
  if (__HAL_FIREWALL_IS_ENABLED() != RESET)
 80001b0:	4b18      	ldr	r3, [pc, #96]	; (8000214 <HAL_FIREWALL_Config+0x80>)
 80001b2:	685b      	ldr	r3, [r3, #4]
 80001b4:	07db      	lsls	r3, r3, #31
 80001b6:	d5ef      	bpl.n	8000198 <HAL_FIREWALL_Config+0x4>
    return HAL_ERROR;
  }

  /* Check Firewall configuration addresses and lengths when segment is protected */
  /* Code segment */
  if (fw_init->CodeSegmentLength != 0U)
 80001b8:	6841      	ldr	r1, [r0, #4]
 80001ba:	b111      	cbz	r1, 80001c2 <HAL_FIREWALL_Config+0x2e>
  {
    assert_param(IS_FIREWALL_CODE_SEGMENT_ADDRESS(fw_init->CodeSegmentStartAddress));
    assert_param(IS_FIREWALL_CODE_SEGMENT_LENGTH(fw_init->CodeSegmentStartAddress, fw_init->CodeSegmentLength));
    /* Make sure that NonVDataSegmentLength is properly set to prevent code segment access */
    if (fw_init->NonVDataSegmentLength < 0x100U)
 80001bc:	68c3      	ldr	r3, [r0, #12]
 80001be:	2bff      	cmp	r3, #255	; 0xff
 80001c0:	d9ea      	bls.n	8000198 <HAL_FIREWALL_Config+0x4>


   /* Configuration */

  /* Protected code segment start address configuration */
  WRITE_REG(FIREWALL->CSSA, (FW_CSSA_ADD & fw_init->CodeSegmentStartAddress));
 80001c2:	6802      	ldr	r2, [r0, #0]
 80001c4:	4b14      	ldr	r3, [pc, #80]	; (8000218 <HAL_FIREWALL_Config+0x84>)
 80001c6:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 80001ca:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 80001ce:	601a      	str	r2, [r3, #0]
	/* Protected code segment length configuration */
  WRITE_REG(FIREWALL->CSL, (FW_CSL_LENG & fw_init->CodeSegmentLength));
 80001d0:	4a12      	ldr	r2, [pc, #72]	; (800021c <HAL_FIREWALL_Config+0x88>)
 80001d2:	400a      	ands	r2, r1
 80001d4:	605a      	str	r2, [r3, #4]

  /* Protected non volatile data segment start address configuration */
  WRITE_REG(FIREWALL->NVDSSA, (FW_NVDSSA_ADD & fw_init->NonVDataSegmentStartAddress));
 80001d6:	6882      	ldr	r2, [r0, #8]
 80001d8:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 80001dc:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 80001e0:	609a      	str	r2, [r3, #8]
	/* Protected non volatile data segment length configuration */
  WRITE_REG(FIREWALL->NVDSL, (FW_NVDSL_LENG & fw_init->NonVDataSegmentLength));
 80001e2:	68c1      	ldr	r1, [r0, #12]
 80001e4:	4a0d      	ldr	r2, [pc, #52]	; (800021c <HAL_FIREWALL_Config+0x88>)
 80001e6:	400a      	ands	r2, r1
 80001e8:	60da      	str	r2, [r3, #12]

  /* Protected volatile data segment start address configuration */
  WRITE_REG(FIREWALL->VDSSA, (FW_VDSSA_ADD & fw_init->VDataSegmentStartAddress));
 80001ea:	6901      	ldr	r1, [r0, #16]
 80001ec:	4a0c      	ldr	r2, [pc, #48]	; (8000220 <HAL_FIREWALL_Config+0x8c>)
 80001ee:	400a      	ands	r2, r1
 80001f0:	611a      	str	r2, [r3, #16]
	/* Protected volatile data segment length configuration */
  WRITE_REG(FIREWALL->VDSL, (FW_VDSL_LENG & fw_init->VDataSegmentLength));
 80001f2:	6941      	ldr	r1, [r0, #20]
 80001f4:	4a0a      	ldr	r2, [pc, #40]	; (8000220 <HAL_FIREWALL_Config+0x8c>)
 80001f6:	400a      	ands	r2, r1
 80001f8:	615a      	str	r2, [r3, #20]

  /* Set Firewall Configuration Register VDE and VDS bits
     (volatile data execution and shared configuration) */
  MODIFY_REG(FIREWALL->CR, FW_CR_VDS|FW_CR_VDE, fw_init->VolatileDataExecution|fw_init->VolatileDataShared);
 80001fa:	6984      	ldr	r4, [r0, #24]
 80001fc:	69c1      	ldr	r1, [r0, #28]
 80001fe:	6a1a      	ldr	r2, [r3, #32]
 8000200:	4321      	orrs	r1, r4
 8000202:	f022 0206 	bic.w	r2, r2, #6
 8000206:	430a      	orrs	r2, r1
 8000208:	621a      	str	r2, [r3, #32]

  return HAL_OK;
 800020a:	2000      	movs	r0, #0
}
 800020c:	b002      	add	sp, #8
 800020e:	bd10      	pop	{r4, pc}
 8000210:	40021000 	.word	0x40021000
 8000214:	40010000 	.word	0x40010000
 8000218:	40011c00 	.word	0x40011c00
 800021c:	003fff00 	.word	0x003fff00
 8000220:	0003ffc0 	.word	0x0003ffc0

08000224 <HAL_FIREWALL_GetConfig>:
void HAL_FIREWALL_GetConfig(FIREWALL_InitTypeDef * fw_config)
{

  /* Enable Firewall clock, in case no Firewall configuration has been carried
     out up to this point */
  __HAL_RCC_FIREWALL_CLK_ENABLE();
 8000224:	4b17      	ldr	r3, [pc, #92]	; (8000284 <HAL_FIREWALL_GetConfig+0x60>)

  /* Retrieve code segment protection setting */
  fw_config->CodeSegmentStartAddress = (READ_REG(FIREWALL->CSSA) & FW_CSSA_ADD);
  fw_config->CodeSegmentLength = (READ_REG(FIREWALL->CSL) & FW_CSL_LENG);
 8000226:	4918      	ldr	r1, [pc, #96]	; (8000288 <HAL_FIREWALL_GetConfig+0x64>)
void HAL_FIREWALL_GetConfig(FIREWALL_InitTypeDef * fw_config)
{

  /* Enable Firewall clock, in case no Firewall configuration has been carried
     out up to this point */
  __HAL_RCC_FIREWALL_CLK_ENABLE();
 8000228:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800022a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800022e:	661a      	str	r2, [r3, #96]	; 0x60
 8000230:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  *       is defined, this API can't be executed when the Firewall is enabled.
  * @note User should resort to __HAL_FIREWALL_GET_PREARM() macro to retrieve FPA bit status
  * @retval None
  */
void HAL_FIREWALL_GetConfig(FIREWALL_InitTypeDef * fw_config)
{
 8000232:	b082      	sub	sp, #8

  /* Enable Firewall clock, in case no Firewall configuration has been carried
     out up to this point */
  __HAL_RCC_FIREWALL_CLK_ENABLE();
 8000234:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000238:	9301      	str	r3, [sp, #4]
 800023a:	9b01      	ldr	r3, [sp, #4]

  /* Retrieve code segment protection setting */
  fw_config->CodeSegmentStartAddress = (READ_REG(FIREWALL->CSSA) & FW_CSSA_ADD);
 800023c:	4b13      	ldr	r3, [pc, #76]	; (800028c <HAL_FIREWALL_GetConfig+0x68>)
 800023e:	681a      	ldr	r2, [r3, #0]
 8000240:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8000244:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 8000248:	6002      	str	r2, [r0, #0]
  fw_config->CodeSegmentLength = (READ_REG(FIREWALL->CSL) & FW_CSL_LENG);
 800024a:	685a      	ldr	r2, [r3, #4]
 800024c:	400a      	ands	r2, r1
 800024e:	6042      	str	r2, [r0, #4]

  /* Retrieve non volatile data segment protection setting */
  fw_config->NonVDataSegmentStartAddress = (READ_REG(FIREWALL->NVDSSA) & FW_NVDSSA_ADD);
 8000250:	689a      	ldr	r2, [r3, #8]
 8000252:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8000256:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 800025a:	6082      	str	r2, [r0, #8]
  fw_config->NonVDataSegmentLength = (READ_REG(FIREWALL->NVDSL) & FW_NVDSL_LENG);
 800025c:	68da      	ldr	r2, [r3, #12]
 800025e:	4011      	ands	r1, r2
 8000260:	60c1      	str	r1, [r0, #12]

  /* Retrieve volatile data segment protection setting */
  fw_config->VDataSegmentStartAddress = (READ_REG(FIREWALL->VDSSA) & FW_VDSSA_ADD);
 8000262:	6919      	ldr	r1, [r3, #16]
 8000264:	4a0a      	ldr	r2, [pc, #40]	; (8000290 <HAL_FIREWALL_GetConfig+0x6c>)
 8000266:	4011      	ands	r1, r2
 8000268:	6101      	str	r1, [r0, #16]
  fw_config->VDataSegmentLength = (READ_REG(FIREWALL->VDSL) & FW_VDSL_LENG);
 800026a:	6959      	ldr	r1, [r3, #20]
 800026c:	400a      	ands	r2, r1
 800026e:	6142      	str	r2, [r0, #20]

  /* Retrieve volatile data execution setting */
  fw_config->VolatileDataExecution = (READ_REG(FIREWALL->CR) & FW_CR_VDE);
 8000270:	6a1a      	ldr	r2, [r3, #32]
 8000272:	f002 0204 	and.w	r2, r2, #4
 8000276:	6182      	str	r2, [r0, #24]

  /* Retrieve volatile data shared setting */
  fw_config->VolatileDataShared = (READ_REG(FIREWALL->CR) & FW_CR_VDS);
 8000278:	6a1b      	ldr	r3, [r3, #32]
 800027a:	f003 0302 	and.w	r3, r3, #2
 800027e:	61c3      	str	r3, [r0, #28]

  return;
}
 8000280:	b002      	add	sp, #8
 8000282:	4770      	bx	lr
 8000284:	40021000 	.word	0x40021000
 8000288:	003fff00 	.word	0x003fff00
 800028c:	40011c00 	.word	0x40011c00
 8000290:	0003ffc0 	.word	0x0003ffc0

08000294 <HAL_FIREWALL_EnableFirewall>:
  * @retval None
  */
void HAL_FIREWALL_EnableFirewall(void)
{
  /* Clears FWDIS bit of SYSCFG CFGR1 register */
  CLEAR_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_FWDIS);
 8000294:	4a02      	ldr	r2, [pc, #8]	; (80002a0 <HAL_FIREWALL_EnableFirewall+0xc>)
 8000296:	6853      	ldr	r3, [r2, #4]
 8000298:	f023 0301 	bic.w	r3, r3, #1
 800029c:	6053      	str	r3, [r2, #4]
 800029e:	4770      	bx	lr
 80002a0:	40010000 	.word	0x40010000

080002a4 <HAL_FIREWALL_EnablePreArmFlag>:
  * @retval None
  */
void HAL_FIREWALL_EnablePreArmFlag(void)
{
  /* Set FPA bit */
  SET_BIT(FIREWALL->CR, FW_CR_FPA);
 80002a4:	4a02      	ldr	r2, [pc, #8]	; (80002b0 <HAL_FIREWALL_EnablePreArmFlag+0xc>)
 80002a6:	6a13      	ldr	r3, [r2, #32]
 80002a8:	f043 0301 	orr.w	r3, r3, #1
 80002ac:	6213      	str	r3, [r2, #32]
 80002ae:	4770      	bx	lr
 80002b0:	40011c00 	.word	0x40011c00

080002b4 <HAL_FIREWALL_DisablePreArmFlag>:
  * @retval None
  */
void HAL_FIREWALL_DisablePreArmFlag(void)
{
  /* Clear FPA bit */
  CLEAR_BIT(FIREWALL->CR, FW_CR_FPA);
 80002b4:	4a02      	ldr	r2, [pc, #8]	; (80002c0 <HAL_FIREWALL_DisablePreArmFlag+0xc>)
 80002b6:	6a13      	ldr	r3, [r2, #32]
 80002b8:	f023 0301 	bic.w	r3, r3, #1
 80002bc:	6213      	str	r3, [r2, #32]
 80002be:	4770      	bx	lr
 80002c0:	40011c00 	.word	0x40011c00
	...

08000300 <_firewall_start>:
 8000300:	0f193a11 	.word	0x0f193a11

08000304 <callgate_entry0>:
 8000304:	f240 0900 	movw	r9, #0
 8000308:	f2c2 0900 	movt	r9, #8192	; 0x2000
 800030c:	f44f 5ae0 	mov.w	sl, #7168	; 0x1c00
 8000310:	44ca      	add	sl, r9

08000312 <wipe_loop1>:
 8000312:	f849 ab04 	str.w	sl, [r9], #4
 8000316:	45d1      	cmp	r9, sl
 8000318:	d1fb      	bne.n	8000312 <wipe_loop1>
 800031a:	46ea      	mov	sl, sp
 800031c:	46cd      	mov	sp, r9
 800031e:	e92d 4400 	stmdb	sp!, {sl, lr}

08000322 <dispatcher>:
 8000322:	f000 f843 	bl	80003ac <firewall_dispatch>
 8000326:	e8bd 4400 	ldmia.w	sp!, {sl, lr}
 800032a:	46d5      	mov	sp, sl
 800032c:	f240 0900 	movw	r9, #0
 8000330:	f2c2 0900 	movt	r9, #8192	; 0x2000
 8000334:	f44f 5ae0 	mov.w	sl, #7168	; 0x1c00
 8000338:	44ca      	add	sl, r9

0800033a <wipe_loop2>:
 800033a:	f849 0b04 	str.w	r0, [r9], #4
 800033e:	45d1      	cmp	r9, sl
 8000340:	d1fb      	bne.n	800033a <wipe_loop2>
 8000342:	4770      	bx	lr

08000344 <__NVIC_SystemReset>:
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8000344:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8000348:	4905      	ldr	r1, [pc, #20]	; (8000360 <__NVIC_SystemReset+0x1c>)
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800034a:	4b06      	ldr	r3, [pc, #24]	; (8000364 <__NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800034c:	68ca      	ldr	r2, [r1, #12]
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800034e:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8000352:	4313      	orrs	r3, r2
 8000354:	60cb      	str	r3, [r1, #12]
 8000356:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 800035a:	bf00      	nop
 800035c:	e7fd      	b.n	800035a <__NVIC_SystemReset+0x16>
 800035e:	bf00      	nop
 8000360:	e000ed00 	.word	0xe000ed00
 8000364:	05fa0004 	.word	0x05fa0004

08000368 <good_addr>:
    static int
good_addr(const uint8_t *b, int minlen, int len, bool readonly)
{
    uint32_t x = (uint32_t)b;

    if(minlen) {
 8000368:	b111      	cbz	r1, 8000370 <good_addr+0x8>
        if(!b) return EFAULT;               // gave no buffer
 800036a:	b198      	cbz	r0, 8000394 <good_addr+0x2c>
        if(len < minlen) return ERANGE;     // too small
 800036c:	4291      	cmp	r1, r2
 800036e:	dc13      	bgt.n	8000398 <good_addr+0x30>
    STATIC_ASSERT(SRAM1_BASE == BL_SRAM_BASE);

    const uint32_t sram_start = BL_SRAM_BASE + BL_SRAM_SIZE;
    const uint32_t sram_end = SRAM3_BASE + SRAM3_SIZE;

    if((x >= sram_start) && ((x+len) <= sram_end)) {
 8000370:	490c      	ldr	r1, [pc, #48]	; (80003a4 <good_addr+0x3c>)
 8000372:	4288      	cmp	r0, r1
 8000374:	d903      	bls.n	800037e <good_addr+0x16>
 8000376:	490c      	ldr	r1, [pc, #48]	; (80003a8 <good_addr+0x40>)
 8000378:	4402      	add	r2, r0
 800037a:	428a      	cmp	r2, r1
 800037c:	d90e      	bls.n	800039c <good_addr+0x34>
        // inside the 3 SRAM areas
        return 0;
    }

    if(!readonly) {
 800037e:	b17b      	cbz	r3, 80003a0 <good_addr+0x38>
        return EPERM;
    }

    if((x >= FIRMWARE_START) && (x - FIRMWARE_START) < FW_MAX_LENGTH) {
 8000380:	f100 4077 	add.w	r0, r0, #4143972352	; 0xf7000000
 8000384:	f500 007e 	add.w	r0, r0, #16646144	; 0xfe0000
        // inside flash of main firmware (happens for QSTR's)
        return 0;
    }

    return EACCES;
 8000388:	f5b0 2f78 	cmp.w	r0, #1015808	; 0xf8000
 800038c:	bf34      	ite	cc
 800038e:	2000      	movcc	r0, #0
 8000390:	200d      	movcs	r0, #13
 8000392:	4770      	bx	lr
good_addr(const uint8_t *b, int minlen, int len, bool readonly)
{
    uint32_t x = (uint32_t)b;

    if(minlen) {
        if(!b) return EFAULT;               // gave no buffer
 8000394:	200e      	movs	r0, #14
 8000396:	4770      	bx	lr
        if(len < minlen) return ERANGE;     // too small
 8000398:	2022      	movs	r0, #34	; 0x22
 800039a:	4770      	bx	lr
    const uint32_t sram_start = BL_SRAM_BASE + BL_SRAM_SIZE;
    const uint32_t sram_end = SRAM3_BASE + SRAM3_SIZE;

    if((x >= sram_start) && ((x+len) <= sram_end)) {
        // inside the 3 SRAM areas
        return 0;
 800039c:	2000      	movs	r0, #0
 800039e:	4770      	bx	lr
    }

    if(!readonly) {
        return EPERM;
 80003a0:	2001      	movs	r0, #1
        // inside flash of main firmware (happens for QSTR's)
        return 0;
    }

    return EACCES;
}
 80003a2:	4770      	bx	lr
 80003a4:	20001bff 	.word	0x20001bff
 80003a8:	200a0000 	.word	0x200a0000

080003ac <firewall_dispatch>:
//
    __attribute__ ((used))
    int
firewall_dispatch(int method_num, uint8_t *buf_io, int len_in,
                        uint32_t arg2, uint32_t incoming_sp, uint32_t incoming_lr)
{
 80003ac:	b570      	push	{r4, r5, r6, lr}
 80003ae:	b09e      	sub	sp, #120	; 0x78
 80003b0:	460d      	mov	r5, r1
 80003b2:	4616      	mov	r6, r2
 80003b4:	9301      	str	r3, [sp, #4]
 80003b6:	9923      	ldr	r1, [sp, #140]	; 0x8c
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80003b8:	b672      	cpsid	i
    __disable_irq();
#endif

    // "1=any code executed outside the protected segment will close the Firewall"
    // "0=.. will reset the processor"
    __HAL_FIREWALL_PREARM_DISABLE();
 80003ba:	4bb1      	ldr	r3, [pc, #708]	; (8000680 <firewall_dispatch+0x2d4>)
 80003bc:	6a1a      	ldr	r2, [r3, #32]
 80003be:	f022 0201 	bic.w	r2, r2, #1
 80003c2:	621a      	str	r2, [r3, #32]
 80003c4:	6a1b      	ldr	r3, [r3, #32]
 80003c6:	f003 0301 	and.w	r3, r3, #1
 80003ca:	9302      	str	r3, [sp, #8]
    //   using read/write in place.
    // - use arg2 use when a simple number is needed; never a pointer!
    // - mpy may provide a pointer to flash if we give it a qstr or small value, and if
    //   we're reading only, that's fine.

    if(len_in > 1024) {     // arbitrary max, increase as needed
 80003cc:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
    __disable_irq();
#endif

    // "1=any code executed outside the protected segment will close the Firewall"
    // "0=.. will reset the processor"
    __HAL_FIREWALL_PREARM_DISABLE();
 80003d0:	9b02      	ldr	r3, [sp, #8]
    //   using read/write in place.
    // - use arg2 use when a simple number is needed; never a pointer!
    // - mpy may provide a pointer to flash if we give it a qstr or small value, and if
    //   we're reading only, that's fine.

    if(len_in > 1024) {     // arbitrary max, increase as needed
 80003d2:	f300 829d 	bgt.w	8000910 <firewall_dispatch+0x564>

    // Use these macros
#define REQUIRE_IN_ONLY(x)   if((rv = good_addr(buf_io, (x), len_in, true))) { goto fail; }
#define REQUIRE_OUT(x)       if((rv = good_addr(buf_io, (x), len_in, false))) { goto fail; }

    switch(method_num) {
 80003d6:	3001      	adds	r0, #1
 80003d8:	281a      	cmp	r0, #26
 80003da:	f200 829b 	bhi.w	8000914 <firewall_dispatch+0x568>
 80003de:	e8df f010 	tbh	[pc, r0, lsl #1]
 80003e2:	028a      	.short	0x028a
 80003e4:	0033001b 	.word	0x0033001b
 80003e8:	008d0052 	.word	0x008d0052
 80003ec:	00c400a2 	.word	0x00c400a2
 80003f0:	02990295 	.word	0x02990295
 80003f4:	02990299 	.word	0x02990299
 80003f8:	02990299 	.word	0x02990299
 80003fc:	029900cc 	.word	0x029900cc
 8000400:	00d80299 	.word	0x00d80299
 8000404:	010700f3 	.word	0x010700f3
 8000408:	017a011b 	.word	0x017a011b
 800040c:	01c501b1 	.word	0x01c501b1
 8000410:	02610223 	.word	0x02610223
 8000414:	027d0275 	.word	0x027d0275
        case 0: {
            REQUIRE_OUT(64);
 8000418:	2300      	movs	r3, #0
 800041a:	4632      	mov	r2, r6
 800041c:	2140      	movs	r1, #64	; 0x40
 800041e:	4628      	mov	r0, r5
 8000420:	f7ff ffa2 	bl	8000368 <good_addr>
 8000424:	4604      	mov	r4, r0
 8000426:	2800      	cmp	r0, #0
 8000428:	f040 8279 	bne.w	800091e <firewall_dispatch+0x572>

            // Return my version string
            memset(buf_io, 0, len_in);
 800042c:	4632      	mov	r2, r6
 800042e:	4601      	mov	r1, r0
 8000430:	4628      	mov	r0, r5
 8000432:	f00d f84c 	bl	800d4ce <memset>
            strlcpy((char *)buf_io, version_string, len_in);
 8000436:	4632      	mov	r2, r6
 8000438:	4992      	ldr	r1, [pc, #584]	; (8000684 <firewall_dispatch+0x2d8>)
 800043a:	4628      	mov	r0, r5
 800043c:	f00d f85e 	bl	800d4fc <strlcpy>

            rv = strlen(version_string);
 8000440:	4890      	ldr	r0, [pc, #576]	; (8000684 <firewall_dispatch+0x2d8>)
 8000442:	f00d f870 	bl	800d526 <strlen>
 8000446:	e07b      	b.n	8000540 <firewall_dispatch+0x194>
        }

        case 1: {
            // Perform SHA256 over ourselves, with 32-bits of salt, to imply we 
            // haven't stored valid responses.
            REQUIRE_OUT(32);
 8000448:	2300      	movs	r3, #0
 800044a:	4632      	mov	r2, r6
 800044c:	2120      	movs	r1, #32
 800044e:	4628      	mov	r0, r5
 8000450:	f7ff ff8a 	bl	8000368 <good_addr>
 8000454:	4604      	mov	r4, r0
 8000456:	2800      	cmp	r0, #0
 8000458:	f040 8261 	bne.w	800091e <firewall_dispatch+0x572>

            SHA256_CTX  ctx;
            sha256_init(&ctx);
 800045c:	a80b      	add	r0, sp, #44	; 0x2c
 800045e:	f004 ff7b 	bl	8005358 <sha256_init>
            sha256_update(&ctx, (void *)&arg2, 4);
 8000462:	2204      	movs	r2, #4
 8000464:	eb0d 0102 	add.w	r1, sp, r2
 8000468:	a80b      	add	r0, sp, #44	; 0x2c
 800046a:	f004 ff85 	bl	8005378 <sha256_update>
            sha256_update(&ctx, (void *)BL_FLASH_BASE, BL_FLASH_SIZE);
 800046e:	a80b      	add	r0, sp, #44	; 0x2c
 8000470:	f44f 32f0 	mov.w	r2, #122880	; 0x1e000
 8000474:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
 8000478:	f004 ff7e 	bl	8005378 <sha256_update>
            sha256_final(&ctx, buf_io);
 800047c:	4629      	mov	r1, r5
 800047e:	a80b      	add	r0, sp, #44	; 0x2c
 8000480:	f004 ffc0 	bl	8005404 <sha256_final>
 8000484:	e24b      	b.n	800091e <firewall_dispatch+0x572>
// Write bag number (probably a string)
void flash_save_bag_number(const uint8_t new_number[32]);

// Are we operating in level2?
static inline bool flash_is_security_level2(void) {
    rng_delay();
 8000486:	f002 f95a 	bl	800273e <rng_delay>
    return ((FLASH->OPTR & FLASH_OPTR_RDP_Msk) == 0xCC);
 800048a:	4b7f      	ldr	r3, [pc, #508]	; (8000688 <firewall_dispatch+0x2dc>)
 800048c:	6a1b      	ldr	r3, [r3, #32]
 800048e:	b2db      	uxtb	r3, r3
 8000490:	f1a3 02cc 	sub.w	r2, r3, #204	; 0xcc
 8000494:	4255      	negs	r5, r2
 8000496:	4155      	adcs	r5, r2
            bool secure = flash_is_security_level2();

            // Go into DFU mode. It's a one-way trip.
            // Also used to show some "fatal" screens w/ memory wipe.

            switch(arg2) {
 8000498:	9a01      	ldr	r2, [sp, #4]
 800049a:	2a02      	cmp	r2, #2
 800049c:	d010      	beq.n	80004c0 <firewall_dispatch+0x114>
 800049e:	2a03      	cmp	r2, #3
 80004a0:	d013      	beq.n	80004ca <firewall_dispatch+0x11e>
 80004a2:	2a01      	cmp	r2, #1
 80004a4:	d007      	beq.n	80004b6 <firewall_dispatch+0x10a>
                default:
                case 0:
                    // enter DFU for firmware upgrades
                    if(secure) {
 80004a6:	2bcc      	cmp	r3, #204	; 0xcc
 80004a8:	f000 8238 	beq.w	800091c <firewall_dispatch+0x570>
                        // we cannot support DFU in secure mode anymore
                        rv = EPERM;
                        goto fail;
                    }
                    puts("Die: DFU");
 80004ac:	4877      	ldr	r0, [pc, #476]	; (800068c <firewall_dispatch+0x2e0>)
 80004ae:	f004 fc05 	bl	8004cbc <puts>
            break;
        }

        case 2: {
            const uint8_t   *scr;
            bool secure = flash_is_security_level2();
 80004b2:	2500      	movs	r5, #0
 80004b4:	e002      	b.n	80004bc <firewall_dispatch+0x110>
                    scr = screen_downgrade;         // was screen_dfu
                    break;
                case 1:
                    // in case some way for Micropython to detect it.
                    scr = screen_downgrade;
                    puts("Die: Downgrade");
 80004b6:	4876      	ldr	r0, [pc, #472]	; (8000690 <firewall_dispatch+0x2e4>)
 80004b8:	f004 fc00 	bl	8004cbc <puts>
                    puts("Die: DFU");
                    scr = screen_downgrade;         // was screen_dfu
                    break;
                case 1:
                    // in case some way for Micropython to detect it.
                    scr = screen_downgrade;
 80004bc:	4c75      	ldr	r4, [pc, #468]	; (8000694 <firewall_dispatch+0x2e8>)
                    puts("Die: Downgrade");
                    break;
 80004be:	e009      	b.n	80004d4 <firewall_dispatch+0x128>
                case 2:
                    scr = screen_blankish;
                    puts("Die: Blankish");
 80004c0:	4875      	ldr	r0, [pc, #468]	; (8000698 <firewall_dispatch+0x2ec>)
                    // in case some way for Micropython to detect it.
                    scr = screen_downgrade;
                    puts("Die: Downgrade");
                    break;
                case 2:
                    scr = screen_blankish;
 80004c2:	4c76      	ldr	r4, [pc, #472]	; (800069c <firewall_dispatch+0x2f0>)
                    puts("Die: Blankish");
 80004c4:	f004 fbfa 	bl	8004cbc <puts>
                    break;
 80004c8:	e004      	b.n	80004d4 <firewall_dispatch+0x128>
                case 3:
                    scr = screen_brick;
                    puts("Die: Brick");
 80004ca:	4875      	ldr	r0, [pc, #468]	; (80006a0 <firewall_dispatch+0x2f4>)
                case 2:
                    scr = screen_blankish;
                    puts("Die: Blankish");
                    break;
                case 3:
                    scr = screen_brick;
 80004cc:	4c75      	ldr	r4, [pc, #468]	; (80006a4 <firewall_dispatch+0x2f8>)
                    puts("Die: Brick");
 80004ce:	f004 fbf5 	bl	8004cbc <puts>
                    secure = true;      // no point going into DFU, if even possible
 80004d2:	2501      	movs	r5, #1
                    break;
            }

            oled_setup();
 80004d4:	f000 fbfe 	bl	8000cd4 <oled_setup>
            oled_show(scr);
 80004d8:	4620      	mov	r0, r4
 80004da:	f000 fc8b 	bl	8000df4 <oled_show>

            wipe_all_sram();
 80004de:	f000 fa5b 	bl	8000998 <wipe_all_sram>
            psram_wipe();
 80004e2:	f004 fd15 	bl	8004f10 <psram_wipe>

            if(secure) {
 80004e6:	b10d      	cbz	r5, 80004ec <firewall_dispatch+0x140>
                // just die with that message shown; can't start DFU
                LOCKUP_FOREVER();
 80004e8:	bf30      	wfi
 80004ea:	e7fd      	b.n	80004e8 <firewall_dispatch+0x13c>
            } else {
                // Cannot just call enter_dfu() because it doesn't work well
                // once Micropython has configured so much stuff in the chip.

                // Leave a reminder to ourselves
                memcpy(dfu_flag->magic, REBOOT_TO_DFU, sizeof(dfu_flag->magic));
 80004ec:	496e      	ldr	r1, [pc, #440]	; (80006a8 <firewall_dispatch+0x2fc>)
 80004ee:	4a6f      	ldr	r2, [pc, #444]	; (80006ac <firewall_dispatch+0x300>)
 80004f0:	6808      	ldr	r0, [r1, #0]
 80004f2:	6849      	ldr	r1, [r1, #4]
 80004f4:	4613      	mov	r3, r2
 80004f6:	c303      	stmia	r3!, {r0, r1}
                dfu_flag->screen = scr;
 80004f8:	6094      	str	r4, [r2, #8]
 80004fa:	e010      	b.n	800051e <firewall_dispatch+0x172>
            break;
        }

        case 3:
            // logout: wipe all of memory and lock up. Must powercycle to recover.
            switch(arg2) { 
 80004fc:	9b01      	ldr	r3, [sp, #4]
 80004fe:	b10b      	cbz	r3, 8000504 <firewall_dispatch+0x158>
 8000500:	2b02      	cmp	r3, #2
 8000502:	d102      	bne.n	800050a <firewall_dispatch+0x15e>
                case 0:
                case 2:
                    oled_show(screen_logout);
 8000504:	486a      	ldr	r0, [pc, #424]	; (80006b0 <firewall_dispatch+0x304>)
 8000506:	f000 fc75 	bl	8000df4 <oled_show>
                case 1:
                    // leave screen untouched
                    break;
            }

            wipe_all_sram();
 800050a:	f000 fa45 	bl	8000998 <wipe_all_sram>
            psram_wipe();
 800050e:	f004 fcff 	bl	8004f10 <psram_wipe>

            if(arg2 == 2) {
 8000512:	9b01      	ldr	r3, [sp, #4]
 8000514:	2b02      	cmp	r3, #2
 8000516:	d104      	bne.n	8000522 <firewall_dispatch+0x176>
                // need some time to show OLED contents
                delay_ms(100);
 8000518:	2064      	movs	r0, #100	; 0x64
 800051a:	f003 f9b9 	bl	8003890 <delay_ms>

                // reboot so we can "login" again
                NVIC_SystemReset();
 800051e:	f7ff ff11 	bl	8000344 <__NVIC_SystemReset>

                // NOT-REACHED (but ok if it does)
            }

            // wait for an interrupt which will never happen (ie. sleep)
            LOCKUP_FOREVER()
 8000522:	bf30      	wfi
 8000524:	e7fd      	b.n	8000522 <firewall_dispatch+0x176>
            break;

        case 4:
            // attempt to control the GPIO (won't work for 1)
            ae_setup();
 8000526:	f002 fa3f 	bl	80029a8 <ae_setup>
            ae_keep_alive();
 800052a:	f002 fa71 	bl	8002a10 <ae_keep_alive>
            switch(arg2) {
 800052e:	9b01      	ldr	r3, [sp, #4]
 8000530:	2b02      	cmp	r3, #2
 8000532:	d009      	beq.n	8000548 <firewall_dispatch+0x19c>
 8000534:	2b03      	cmp	r3, #3
 8000536:	d00b      	beq.n	8000550 <firewall_dispatch+0x1a4>
 8000538:	2b01      	cmp	r3, #1
 800053a:	d003      	beq.n	8000544 <firewall_dispatch+0x198>
                default:
                case 0:     // read state
                    rv = ae_get_gpio();
 800053c:	f002 ffbf 	bl	80034be <ae_get_gpio>
 8000540:	4604      	mov	r4, r0
                    break;
 8000542:	e1ec      	b.n	800091e <firewall_dispatch+0x572>
                case 1:     // clear it (can work anytime)
                    rv = ae_set_gpio(0);
 8000544:	2000      	movs	r0, #0
 8000546:	e000      	b.n	800054a <firewall_dispatch+0x19e>
                    break;
                case 2:     // set it (will always fail)
                    rv = ae_set_gpio(1);
 8000548:	2001      	movs	r0, #1
 800054a:	f002 ff89 	bl	8003460 <ae_set_gpio>
 800054e:	e7f7      	b.n	8000540 <firewall_dispatch+0x194>

                case 3: {     // do a verify and see if it maybe goes green
                    uint8_t fw_digest[32], world_digest[32];

                    // takes time, shows progress bar
                    checksum_flash(fw_digest, world_digest, 0);
 8000550:	2200      	movs	r2, #0
 8000552:	a90b      	add	r1, sp, #44	; 0x2c
 8000554:	a803      	add	r0, sp, #12
 8000556:	f001 fa8f 	bl	8001a78 <checksum_flash>

                    rv = ae_set_gpio_secure(world_digest);
 800055a:	a80b      	add	r0, sp, #44	; 0x2c
 800055c:	f002 ff97 	bl	800348e <ae_set_gpio_secure>
 8000560:	4604      	mov	r4, r0

                    oled_show(screen_blankish);
 8000562:	484e      	ldr	r0, [pc, #312]	; (800069c <firewall_dispatch+0x2f0>)
 8000564:	f000 fc46 	bl	8000df4 <oled_show>
 8000568:	e1d9      	b.n	800091e <firewall_dispatch+0x572>
        case 5:     
            // Are we a brick?
            // if the pairing secret doesn't work anymore, that
            // means we've been bricked.
            // TODO: also report hardware issue, and non-configured states
            ae_setup();
 800056a:	f002 fa1d 	bl	80029a8 <ae_setup>
            rv = (ae_pair_unlock() != 0);
 800056e:	f002 fc1b 	bl	8002da8 <ae_pair_unlock>
 8000572:	1c04      	adds	r4, r0, #0
 8000574:	bf18      	it	ne
 8000576:	2401      	movne	r4, #1
            break;
 8000578:	e1d1      	b.n	800091e <firewall_dispatch+0x572>
            #endif
            break;

        case 12:
            // read the DFU button (used for selftest at least)
            REQUIRE_OUT(1);
 800057a:	2300      	movs	r3, #0
 800057c:	4632      	mov	r2, r6
 800057e:	2101      	movs	r1, #1
 8000580:	4628      	mov	r0, r5
 8000582:	f7ff fef1 	bl	8000368 <good_addr>
 8000586:	4604      	mov	r4, r0
 8000588:	2800      	cmp	r0, #0
 800058a:	f040 81c8 	bne.w	800091e <firewall_dispatch+0x572>
            buf_io[0] = 0;          // NOT SUPPORTED on Mk4
 800058e:	7028      	strb	r0, [r5, #0]
            break;
 8000590:	e1c5      	b.n	800091e <firewall_dispatch+0x572>

        case 15: {
            // Read a dataslot directly. Will fail on 
            // encrypted slots.
            if(len_in != 4 && len_in != 32 && len_in != 72) {
 8000592:	2e04      	cmp	r6, #4
 8000594:	d004      	beq.n	80005a0 <firewall_dispatch+0x1f4>
 8000596:	2e20      	cmp	r6, #32
 8000598:	d002      	beq.n	80005a0 <firewall_dispatch+0x1f4>
 800059a:	2e48      	cmp	r6, #72	; 0x48
 800059c:	f040 81b8 	bne.w	8000910 <firewall_dispatch+0x564>
                rv = ERANGE;
            } else {
                REQUIRE_OUT(4);
 80005a0:	2300      	movs	r3, #0
 80005a2:	4632      	mov	r2, r6
 80005a4:	2104      	movs	r1, #4
 80005a6:	4628      	mov	r0, r5
 80005a8:	f7ff fede 	bl	8000368 <good_addr>
 80005ac:	4604      	mov	r4, r0
 80005ae:	2800      	cmp	r0, #0
 80005b0:	f040 81b5 	bne.w	800091e <firewall_dispatch+0x572>

                ae_setup();
 80005b4:	f002 f9f8 	bl	80029a8 <ae_setup>
                if(ae_read_data_slot(arg2 & 0xf, buf_io, len_in)) {
 80005b8:	9801      	ldr	r0, [sp, #4]
 80005ba:	4632      	mov	r2, r6
 80005bc:	4629      	mov	r1, r5
 80005be:	f000 000f 	and.w	r0, r0, #15
 80005c2:	f002 ff09 	bl	80033d8 <ae_read_data_slot>
 80005c6:	e0cc      	b.n	8000762 <firewall_dispatch+0x3b6>
            break;
        }

        case 16: {
            // Provide the 2 words for anti-phishing.
            REQUIRE_OUT(MAX_PIN_LEN);
 80005c8:	2300      	movs	r3, #0
 80005ca:	4632      	mov	r2, r6
 80005cc:	2120      	movs	r1, #32
 80005ce:	4628      	mov	r0, r5
 80005d0:	f7ff feca 	bl	8000368 <good_addr>
 80005d4:	4604      	mov	r4, r0
 80005d6:	2800      	cmp	r0, #0
 80005d8:	f040 81a1 	bne.w	800091e <firewall_dispatch+0x572>

            // arg2: length of pin.
            if((arg2 < 1) || (arg2 > MAX_PIN_LEN)) {
 80005dc:	9901      	ldr	r1, [sp, #4]
 80005de:	1e4b      	subs	r3, r1, #1
 80005e0:	2b1f      	cmp	r3, #31
 80005e2:	f200 8195 	bhi.w	8000910 <firewall_dispatch+0x564>
                rv = ERANGE;
            } else {
                if(pin_prefix_words((char *)buf_io, arg2, (uint32_t *)buf_io)) {
 80005e6:	462a      	mov	r2, r5
 80005e8:	4628      	mov	r0, r5
 80005ea:	f003 fc07 	bl	8003dfc <pin_prefix_words>
 80005ee:	e0b8      	b.n	8000762 <firewall_dispatch+0x3b6>
            break;
        }

        case 17:
            // test rng
            REQUIRE_OUT(32);
 80005f0:	2300      	movs	r3, #0
 80005f2:	4632      	mov	r2, r6
 80005f4:	2120      	movs	r1, #32
 80005f6:	4628      	mov	r0, r5
 80005f8:	f7ff feb6 	bl	8000368 <good_addr>
 80005fc:	4604      	mov	r4, r0
 80005fe:	2800      	cmp	r0, #0
 8000600:	f040 818d 	bne.w	800091e <firewall_dispatch+0x572>
            memset(buf_io, 0x55, 32);       // to help show errors
 8000604:	2220      	movs	r2, #32
 8000606:	2155      	movs	r1, #85	; 0x55
 8000608:	4628      	mov	r0, r5
 800060a:	f00c ff60 	bl	800d4ce <memset>
            rng_buffer(buf_io, 32);
 800060e:	2120      	movs	r1, #32
 8000610:	4628      	mov	r0, r5
 8000612:	f002 f87d 	bl	8002710 <rng_buffer>
            break;
 8000616:	e182      	b.n	800091e <firewall_dispatch+0x572>

        case 18: {
            // Try login w/ PIN.
            REQUIRE_OUT(PIN_ATTEMPT_SIZE_V2);
 8000618:	2300      	movs	r3, #0
 800061a:	4632      	mov	r2, r6
 800061c:	f44f 718c 	mov.w	r1, #280	; 0x118
 8000620:	4628      	mov	r0, r5
 8000622:	f7ff fea1 	bl	8000368 <good_addr>
 8000626:	4604      	mov	r4, r0
 8000628:	2800      	cmp	r0, #0
 800062a:	f040 8178 	bne.w	800091e <firewall_dispatch+0x572>
            pinAttempt_t *args = (pinAttempt_t *)buf_io;

            switch(arg2) {
 800062e:	9b01      	ldr	r3, [sp, #4]
 8000630:	2b08      	cmp	r3, #8
 8000632:	f200 816f 	bhi.w	8000914 <firewall_dispatch+0x568>
 8000636:	e8df f003 	tbb	[pc, r3]
 800063a:	0905      	.short	0x0905
 800063c:	1915110d 	.word	0x1915110d
 8000640:	1f1d      	.short	0x1f1d
 8000642:	3d          	.byte	0x3d
 8000643:	00          	.byte	0x00
                case 0:
                    rv = pin_setup_attempt(args);
 8000644:	4628      	mov	r0, r5
 8000646:	f003 fbf7 	bl	8003e38 <pin_setup_attempt>
 800064a:	e779      	b.n	8000540 <firewall_dispatch+0x194>
                    break;
                case 1:
                    rv = pin_delay(args);
 800064c:	4628      	mov	r0, r5
 800064e:	f003 fc65 	bl	8003f1c <pin_delay>
 8000652:	e775      	b.n	8000540 <firewall_dispatch+0x194>
                    break;
                case 2:
                    rv = pin_login_attempt(args);
 8000654:	4628      	mov	r0, r5
 8000656:	f003 fc63 	bl	8003f20 <pin_login_attempt>
 800065a:	e771      	b.n	8000540 <firewall_dispatch+0x194>
                    break;
                case 3:
                    rv = pin_change(args);
 800065c:	4628      	mov	r0, r5
 800065e:	f003 fd87 	bl	8004170 <pin_change>
 8000662:	e76d      	b.n	8000540 <firewall_dispatch+0x194>
                    break;
                case 4:
                    rv = pin_fetch_secret(args);
 8000664:	4628      	mov	r0, r5
 8000666:	f003 fe3d 	bl	80042e4 <pin_fetch_secret>
 800066a:	e769      	b.n	8000540 <firewall_dispatch+0x194>
                    break;

                case 5:
                    rv = pin_firmware_greenlight(args);
 800066c:	4628      	mov	r0, r5
 800066e:	f003 ffcf 	bl	8004610 <pin_firmware_greenlight>
 8000672:	e765      	b.n	8000540 <firewall_dispatch+0x194>
                    break;

                case 6:         // new for v2
                    rv = pin_long_secret(args, NULL);
 8000674:	2100      	movs	r1, #0
 8000676:	e02a      	b.n	80006ce <firewall_dispatch+0x322>
                    break;

                case 7:         // new for Mk4
                    rv = pin_firmware_upgrade(args);
 8000678:	4628      	mov	r0, r5
 800067a:	f004 f80b 	bl	8004694 <pin_firmware_upgrade>
 800067e:	e75f      	b.n	8000540 <firewall_dispatch+0x194>
 8000680:	40011c00 	.word	0x40011c00
 8000684:	0800e480 	.word	0x0800e480
 8000688:	40022000 	.word	0x40022000
 800068c:	0800d565 	.word	0x0800d565
 8000690:	0800d56e 	.word	0x0800d56e
 8000694:	0800d8c1 	.word	0x0800d8c1
 8000698:	0800d57d 	.word	0x0800d57d
 800069c:	0800dd09 	.word	0x0800dd09
 80006a0:	0800d58b 	.word	0x0800d58b
 80006a4:	0800de5b 	.word	0x0800de5b
 80006a8:	0800d596 	.word	0x0800d596
 80006ac:	20008000 	.word	0x20008000
 80006b0:	0800d987 	.word	0x0800d987
                    break;

                case 8:         // new for Mk4: faster for reading only tho
                    REQUIRE_OUT(PIN_ATTEMPT_SIZE_V2 + AE_LONG_SECRET_LEN);
 80006b4:	2300      	movs	r3, #0
 80006b6:	4632      	mov	r2, r6
 80006b8:	f44f 712e 	mov.w	r1, #696	; 0x2b8
 80006bc:	4628      	mov	r0, r5
 80006be:	f7ff fe53 	bl	8000368 <good_addr>
 80006c2:	4604      	mov	r4, r0
 80006c4:	2800      	cmp	r0, #0
 80006c6:	f040 812a 	bne.w	800091e <firewall_dispatch+0x572>
                    rv = pin_long_secret(args, &buf_io[PIN_ATTEMPT_SIZE_V2]);
 80006ca:	f505 718c 	add.w	r1, r5, #280	; 0x118
 80006ce:	4628      	mov	r0, r5
 80006d0:	f003 fee2 	bl	8004498 <pin_long_secret>
 80006d4:	e734      	b.n	8000540 <firewall_dispatch+0x194>
            break;
        }


        case 19: {   // bag number stuff
            switch(arg2) {
 80006d6:	9b01      	ldr	r3, [sp, #4]
 80006d8:	2b64      	cmp	r3, #100	; 0x64
 80006da:	d02d      	beq.n	8000738 <firewall_dispatch+0x38c>
 80006dc:	d803      	bhi.n	80006e6 <firewall_dispatch+0x33a>
 80006de:	b14b      	cbz	r3, 80006f4 <firewall_dispatch+0x348>
 80006e0:	2b01      	cmp	r3, #1
 80006e2:	d01c      	beq.n	800071e <firewall_dispatch+0x372>
 80006e4:	e116      	b.n	8000914 <firewall_dispatch+0x568>
 80006e6:	2b65      	cmp	r3, #101	; 0x65
 80006e8:	d028      	beq.n	800073c <firewall_dispatch+0x390>
 80006ea:	2b66      	cmp	r3, #102	; 0x66
 80006ec:	f040 8112 	bne.w	8000914 <firewall_dispatch+0x568>
                case 101:
                    flash_lockdown_hard(OB_RDP_LEVEL_1);        // Can only do 0->1 (experiments)
                    break;
                case 102:
                    // production units will be:
                    flash_lockdown_hard(OB_RDP_LEVEL_2);        // No change possible after this.
 80006f0:	20cc      	movs	r0, #204	; 0xcc
 80006f2:	e024      	b.n	800073e <firewall_dispatch+0x392>

        case 19: {   // bag number stuff
            switch(arg2) {
                case 0:
                    // read out number
                    REQUIRE_OUT(32);
 80006f4:	4632      	mov	r2, r6
 80006f6:	2120      	movs	r1, #32
 80006f8:	4628      	mov	r0, r5
 80006fa:	f7ff fe35 	bl	8000368 <good_addr>
 80006fe:	4604      	mov	r4, r0
 8000700:	2800      	cmp	r0, #0
 8000702:	f040 810c 	bne.w	800091e <firewall_dispatch+0x572>
                    memcpy(buf_io, rom_secrets->bag_number, 32);
 8000706:	4a9e      	ldr	r2, [pc, #632]	; (8000980 <firewall_dispatch+0x5d4>)
 8000708:	4e9e      	ldr	r6, [pc, #632]	; (8000984 <firewall_dispatch+0x5d8>)
 800070a:	4613      	mov	r3, r2
 800070c:	cb03      	ldmia	r3!, {r0, r1}
 800070e:	42b3      	cmp	r3, r6
 8000710:	6028      	str	r0, [r5, #0]
 8000712:	6069      	str	r1, [r5, #4]
 8000714:	461a      	mov	r2, r3
 8000716:	f105 0508 	add.w	r5, r5, #8
 800071a:	d1f6      	bne.n	800070a <firewall_dispatch+0x35e>
 800071c:	e0ff      	b.n	800091e <firewall_dispatch+0x572>
                    break;

                case 1:
                    // set the bag number, and (should) do lock down
                    REQUIRE_IN_ONLY(32);
 800071e:	4632      	mov	r2, r6
 8000720:	2120      	movs	r1, #32
 8000722:	4628      	mov	r0, r5
 8000724:	f7ff fe20 	bl	8000368 <good_addr>
 8000728:	4604      	mov	r4, r0
 800072a:	2800      	cmp	r0, #0
 800072c:	f040 80f7 	bne.w	800091e <firewall_dispatch+0x572>

                    flash_save_bag_number(buf_io);
 8000730:	4628      	mov	r0, r5
 8000732:	f001 fd3b 	bl	80021ac <flash_save_bag_number>
                    break;
 8000736:	e0f2      	b.n	800091e <firewall_dispatch+0x572>

                case 100:
                    flash_lockdown_hard(OB_RDP_LEVEL_0);        // wipes contents of flash (1->0)
 8000738:	20aa      	movs	r0, #170	; 0xaa
 800073a:	e000      	b.n	800073e <firewall_dispatch+0x392>
                    break;
                case 101:
                    flash_lockdown_hard(OB_RDP_LEVEL_1);        // Can only do 0->1 (experiments)
 800073c:	20bb      	movs	r0, #187	; 0xbb
                    break;
                case 102:
                    // production units will be:
                    flash_lockdown_hard(OB_RDP_LEVEL_2);        // No change possible after this.
 800073e:	f001 fe33 	bl	80023a8 <flash_lockdown_hard>
 8000742:	e0e3      	b.n	800090c <firewall_dispatch+0x560>
            break;
        }
            
        case 20:
            // Read out entire config dataspace
            REQUIRE_OUT(128);
 8000744:	2300      	movs	r3, #0
 8000746:	4632      	mov	r2, r6
 8000748:	2180      	movs	r1, #128	; 0x80
 800074a:	4628      	mov	r0, r5
 800074c:	f7ff fe0c 	bl	8000368 <good_addr>
 8000750:	4604      	mov	r4, r0
 8000752:	2800      	cmp	r0, #0
 8000754:	f040 80e3 	bne.w	800091e <firewall_dispatch+0x572>

            ae_setup();
 8000758:	f002 f926 	bl	80029a8 <ae_setup>
            rv = ae_config_read(buf_io);
 800075c:	4628      	mov	r0, r5
 800075e:	f002 ff02 	bl	8003566 <ae_config_read>
            if(rv) {
 8000762:	2800      	cmp	r0, #0
 8000764:	f000 80d2 	beq.w	800090c <firewall_dispatch+0x560>
                rv = EIO;
 8000768:	2405      	movs	r4, #5
 800076a:	e0d8      	b.n	800091e <firewall_dispatch+0x572>
            } 
            break;

        case 21:
            // read OTP / downgrade protection
            switch(arg2) {
 800076c:	9b01      	ldr	r3, [sp, #4]
 800076e:	2b03      	cmp	r3, #3
 8000770:	f200 80d0 	bhi.w	8000914 <firewall_dispatch+0x568>
 8000774:	e8df f003 	tbb	[pc, r3]
 8000778:	471f1002 	.word	0x471f1002
                case 0:
                    REQUIRE_OUT(8);
 800077c:	2300      	movs	r3, #0
 800077e:	4632      	mov	r2, r6
 8000780:	2108      	movs	r1, #8
 8000782:	4628      	mov	r0, r5
 8000784:	f7ff fdf0 	bl	8000368 <good_addr>
 8000788:	4604      	mov	r4, r0
 800078a:	2800      	cmp	r0, #0
 800078c:	f040 80c7 	bne.w	800091e <firewall_dispatch+0x572>
                    get_min_version(buf_io);
 8000790:	4628      	mov	r0, r5
 8000792:	f001 fa01 	bl	8001b98 <get_min_version>
                    break;
 8000796:	e0c2      	b.n	800091e <firewall_dispatch+0x572>

                case 1:
                    REQUIRE_IN_ONLY(8);
 8000798:	2301      	movs	r3, #1
 800079a:	4632      	mov	r2, r6
 800079c:	2108      	movs	r1, #8
 800079e:	4628      	mov	r0, r5
 80007a0:	f7ff fde2 	bl	8000368 <good_addr>
 80007a4:	4604      	mov	r4, r0
 80007a6:	2800      	cmp	r0, #0
 80007a8:	f040 80b9 	bne.w	800091e <firewall_dispatch+0x572>
                    rv = check_is_downgrade(buf_io, NULL);
 80007ac:	4601      	mov	r1, r0
 80007ae:	4628      	mov	r0, r5
 80007b0:	f001 fa12 	bl	8001bd8 <check_is_downgrade>
 80007b4:	e6c4      	b.n	8000540 <firewall_dispatch+0x194>
                    break;

                case 2:
                    REQUIRE_IN_ONLY(8);
 80007b6:	2301      	movs	r3, #1
 80007b8:	4632      	mov	r2, r6
 80007ba:	2108      	movs	r1, #8
 80007bc:	4628      	mov	r0, r5
 80007be:	f7ff fdd3 	bl	8000368 <good_addr>
 80007c2:	4604      	mov	r4, r0
 80007c4:	2800      	cmp	r0, #0
 80007c6:	f040 80aa 	bne.w	800091e <firewall_dispatch+0x572>

                    if(buf_io[0] < 0x10 || buf_io[0] >= 0x40) {
 80007ca:	782b      	ldrb	r3, [r5, #0]
 80007cc:	3b10      	subs	r3, #16
                        // bad data
                        rv = ERANGE;
 80007ce:	2b2f      	cmp	r3, #47	; 0x2f
                    } if(check_is_downgrade(buf_io, NULL)) {
 80007d0:	4601      	mov	r1, r0
 80007d2:	4628      	mov	r0, r5
                case 2:
                    REQUIRE_IN_ONLY(8);

                    if(buf_io[0] < 0x10 || buf_io[0] >= 0x40) {
                        // bad data
                        rv = ERANGE;
 80007d4:	bf88      	it	hi
 80007d6:	2422      	movhi	r4, #34	; 0x22
                    } if(check_is_downgrade(buf_io, NULL)) {
 80007d8:	f001 f9fe 	bl	8001bd8 <check_is_downgrade>
 80007dc:	2800      	cmp	r0, #0
 80007de:	f040 809b 	bne.w	8000918 <firewall_dispatch+0x56c>
                        // already at a higher version?
                        rv = EAGAIN;
                    } else {
                        uint8_t min[8];
                        get_min_version(min);
 80007e2:	a80b      	add	r0, sp, #44	; 0x2c
 80007e4:	f001 f9d8 	bl	8001b98 <get_min_version>

                        if(memcmp(min, buf_io, 8) == 0) {
 80007e8:	2208      	movs	r2, #8
 80007ea:	4629      	mov	r1, r5
 80007ec:	a80b      	add	r0, sp, #44	; 0x2c
 80007ee:	f00c fe39 	bl	800d464 <memcmp>
 80007f2:	2800      	cmp	r0, #0
 80007f4:	f000 8090 	beq.w	8000918 <firewall_dispatch+0x56c>
                            // dupe
                            rv = EAGAIN;
                        } else {
                            // save it, but might be "full" already
                            if(record_highwater_version(buf_io)) {
 80007f8:	4628      	mov	r0, r5
 80007fa:	f001 fdef 	bl	80023dc <record_highwater_version>
                                rv = ENOMEM;
 80007fe:	2800      	cmp	r0, #0
 8000800:	bf18      	it	ne
 8000802:	240c      	movne	r4, #12
 8000804:	e08b      	b.n	800091e <firewall_dispatch+0x572>
                    }
                    break;

                case 3:
                    // read raw counter0 value (max is 0x1fffff)
                    REQUIRE_OUT(4);
 8000806:	2300      	movs	r3, #0
 8000808:	4632      	mov	r2, r6
 800080a:	2104      	movs	r1, #4
 800080c:	4628      	mov	r0, r5
 800080e:	f7ff fdab 	bl	8000368 <good_addr>
 8000812:	4604      	mov	r4, r0
 8000814:	2800      	cmp	r0, #0
 8000816:	f040 8082 	bne.w	800091e <firewall_dispatch+0x572>
                    ae_setup();
 800081a:	f002 f8c5 	bl	80029a8 <ae_setup>
                    rv = ae_get_counter((uint32_t *)buf_io, 0) ? EIO: 0;
 800081e:	4621      	mov	r1, r4
 8000820:	4628      	mov	r0, r5
 8000822:	f002 fc96 	bl	8003152 <ae_get_counter>
 8000826:	e79c      	b.n	8000762 <firewall_dispatch+0x3b6>
            }
            break;

        case 22: {          // Mk4+ only
            // Trick pin managment: needs pin change args, plus slot data after that!
            REQUIRE_OUT(PIN_ATTEMPT_SIZE_V2 + sizeof(trick_slot_t));
 8000828:	2300      	movs	r3, #0
 800082a:	4632      	mov	r2, r6
 800082c:	f44f 71cc 	mov.w	r1, #408	; 0x198
 8000830:	4628      	mov	r0, r5
 8000832:	f7ff fd99 	bl	8000368 <good_addr>
 8000836:	4604      	mov	r4, r0
 8000838:	2800      	cmp	r0, #0
 800083a:	d170      	bne.n	800091e <firewall_dispatch+0x572>
            const pinAttempt_t *args = (pinAttempt_t *)buf_io;
            trick_slot_t *slot = (trick_slot_t *)(&buf_io[PIN_ATTEMPT_SIZE_V2]);

            // Verify we know the main PIN, but don't do anything
            bool trick_mode;
            rv = pin_check_logged_in(args, &trick_mode);
 800083c:	a90b      	add	r1, sp, #44	; 0x2c
 800083e:	4628      	mov	r0, r5
 8000840:	f003 fc60 	bl	8004104 <pin_check_logged_in>

        case 22: {          // Mk4+ only
            // Trick pin managment: needs pin change args, plus slot data after that!
            REQUIRE_OUT(PIN_ATTEMPT_SIZE_V2 + sizeof(trick_slot_t));
            const pinAttempt_t *args = (pinAttempt_t *)buf_io;
            trick_slot_t *slot = (trick_slot_t *)(&buf_io[PIN_ATTEMPT_SIZE_V2]);
 8000844:	f505 768c 	add.w	r6, r5, #280	; 0x118

            // Verify we know the main PIN, but don't do anything
            bool trick_mode;
            rv = pin_check_logged_in(args, &trick_mode);
            if(rv) goto fail;
 8000848:	4604      	mov	r4, r0
 800084a:	2800      	cmp	r0, #0
 800084c:	d167      	bne.n	800091e <firewall_dispatch+0x572>

            if(trick_mode) {
 800084e:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
 8000852:	b10b      	cbz	r3, 8000858 <firewall_dispatch+0x4ac>
                // Already logged in via a trick PIN, so clear the seed to protect 
                // it (we have a smart one here) and continue.
                mcu_key_clear(NULL);
 8000854:	f001 fe10 	bl	8002478 <mcu_key_clear>
            }

            switch(arg2) {
 8000858:	9b01      	ldr	r3, [sp, #4]
 800085a:	2b01      	cmp	r3, #1
 800085c:	d00a      	beq.n	8000874 <firewall_dispatch+0x4c8>
 800085e:	d302      	bcc.n	8000866 <firewall_dispatch+0x4ba>
 8000860:	2b02      	cmp	r3, #2
 8000862:	d017      	beq.n	8000894 <firewall_dispatch+0x4e8>
 8000864:	e056      	b.n	8000914 <firewall_dispatch+0x568>
                case 0:     // clear all
                    if(!trick_mode) {
 8000866:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
 800086a:	2b00      	cmp	r3, #0
 800086c:	d157      	bne.n	800091e <firewall_dispatch+0x572>
                        se2_clear_tricks();
 800086e:	f007 f9eb 	bl	8007c48 <se2_clear_tricks>
 8000872:	e054      	b.n	800091e <firewall_dispatch+0x572>
                    }
                    break;
                case 1:     // get by pin
                    if(trick_mode) {
 8000874:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
 8000878:	2a00      	cmp	r2, #0
 800087a:	d14b      	bne.n	8000914 <firewall_dispatch+0x568>
                        // never finds anything
                        rv = ENOENT;
                    } else {
                        // lookup and return value
                        if(slot->pin_len > 16) {
 800087c:	f8d5 1170 	ldr.w	r1, [r5, #368]	; 0x170
 8000880:	2910      	cmp	r1, #16
 8000882:	dc45      	bgt.n	8000910 <firewall_dispatch+0x564>
                            rv = ERANGE;
                            goto fail;
                        }
                        if(se2_test_trick_pin(slot->pin, slot->pin_len, slot, true)) {
 8000884:	4632      	mov	r2, r6
 8000886:	f505 70b0 	add.w	r0, r5, #352	; 0x160
 800088a:	f007 fa45 	bl	8007d18 <se2_test_trick_pin>
 800088e:	2800      	cmp	r0, #0
 8000890:	d040      	beq.n	8000914 <firewall_dispatch+0x568>
 8000892:	e044      	b.n	800091e <firewall_dispatch+0x572>
                            rv = ENOENT;
                        }
                    }
                    break;
                case 2:     // clear/update slot
                    if(!trick_mode) {
 8000894:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
 8000898:	2b00      	cmp	r3, #0
 800089a:	d140      	bne.n	800091e <firewall_dispatch+0x572>
                        rv = se2_save_trick(slot);
 800089c:	4630      	mov	r0, r6
 800089e:	f007 fb4b 	bl	8007f38 <se2_save_trick>
 80008a2:	e64d      	b.n	8000540 <firewall_dispatch+0x194>
            break;
        }

        case 23:
            // fast wipe -- does system reset, no UX
            if(arg2 == 0xBeef) {
 80008a4:	9b01      	ldr	r3, [sp, #4]
 80008a6:	f64b 62ef 	movw	r2, #48879	; 0xbeef
 80008aa:	4293      	cmp	r3, r2
 80008ac:	d102      	bne.n	80008b4 <firewall_dispatch+0x508>
                // silent version, but does reset system
                fast_wipe();
 80008ae:	f001 fea5 	bl	80025fc <fast_wipe>
 80008b2:	e033      	b.n	800091c <firewall_dispatch+0x570>
            } else if(arg2 == 0xDead) {
 80008b4:	f64d 62ad 	movw	r2, #57005	; 0xdead
 80008b8:	4293      	cmp	r3, r2
 80008ba:	d12f      	bne.n	800091c <firewall_dispatch+0x570>
                // noisy, shows screen, halts
                mcu_key_clear(NULL);
 80008bc:	2000      	movs	r0, #0
 80008be:	f001 fddb 	bl	8002478 <mcu_key_clear>
                oled_show(screen_wiped);
 80008c2:	4831      	ldr	r0, [pc, #196]	; (8000988 <firewall_dispatch+0x5dc>)
 80008c4:	f000 fa96 	bl	8000df4 <oled_show>

                LOCKUP_FOREVER();
 80008c8:	bf30      	wfi
 80008ca:	e7fd      	b.n	80008c8 <firewall_dispatch+0x51c>
            rv = EPERM;
            break;

        case 24:
            // fast brick -- locks up w/ message
            if(arg2 == 0xDead) fast_brick();
 80008cc:	9a01      	ldr	r2, [sp, #4]
 80008ce:	f64d 63ad 	movw	r3, #57005	; 0xdead
 80008d2:	429a      	cmp	r2, r3
 80008d4:	d122      	bne.n	800091c <firewall_dispatch+0x570>
 80008d6:	f001 fe6d 	bl	80025b4 <fast_brick>
 80008da:	e01f      	b.n	800091c <firewall_dispatch+0x570>
            rv = EPERM;
            break;

        case 25: {
            // mk4: usage of mcu key slots
            REQUIRE_OUT(8);
 80008dc:	2300      	movs	r3, #0
 80008de:	4632      	mov	r2, r6
 80008e0:	2108      	movs	r1, #8
 80008e2:	4628      	mov	r0, r5
 80008e4:	f7ff fd40 	bl	8000368 <good_addr>
 80008e8:	4604      	mov	r4, r0
 80008ea:	b9c0      	cbnz	r0, 800091e <firewall_dispatch+0x572>

            int *avail = (int *)(buf_io+0);
            int *consumed = (int *)(buf_io+4);

            mcu_key_usage(avail, consumed);
 80008ec:	1d29      	adds	r1, r5, #4
 80008ee:	4628      	mov	r0, r5
 80008f0:	f001 fdec 	bl	80024cc <mcu_key_usage>
            break;
 80008f4:	e013      	b.n	800091e <firewall_dispatch+0x572>


        case -1:
            // System startup code. Cannot be reached by any code (that hopes to run
            // again) except our reset stub.
            if(incoming_lr <= BL_FLASH_BASE || incoming_lr >= (uint32_t)&firewall_starts) {
 80008f6:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
 80008fa:	d902      	bls.n	8000902 <firewall_dispatch+0x556>
 80008fc:	4b23      	ldr	r3, [pc, #140]	; (800098c <firewall_dispatch+0x5e0>)
 80008fe:	4299      	cmp	r1, r3
 8000900:	d302      	bcc.n	8000908 <firewall_dispatch+0x55c>
                fatal_error("LR");
 8000902:	4823      	ldr	r0, [pc, #140]	; (8000990 <firewall_dispatch+0x5e4>)
 8000904:	f000 f86a 	bl	80009dc <fatal_error>
            } else {
                system_startup();
 8000908:	f000 f8c2 	bl	8000a90 <system_startup>

        case 6:
            // Do we have a ATECC608a and all that implies?
            // NOTE: this number was unused in V1 bootroms, so return ENOENT
            #if FOR_608
                rv = 0;
 800090c:	2400      	movs	r4, #0
 800090e:	e006      	b.n	800091e <firewall_dispatch+0x572>
    // - use arg2 use when a simple number is needed; never a pointer!
    // - mpy may provide a pointer to flash if we give it a qstr or small value, and if
    //   we're reading only, that's fine.

    if(len_in > 1024) {     // arbitrary max, increase as needed
        rv = ERANGE;
 8000910:	2422      	movs	r4, #34	; 0x22
 8000912:	e004      	b.n	800091e <firewall_dispatch+0x572>
                    ae_setup();
                    rv = ae_get_counter((uint32_t *)buf_io, 0) ? EIO: 0;
                    break;

                default:
                    rv = ENOENT;
 8000914:	2402      	movs	r4, #2
 8000916:	e002      	b.n	800091e <firewall_dispatch+0x572>
                    if(buf_io[0] < 0x10 || buf_io[0] >= 0x40) {
                        // bad data
                        rv = ERANGE;
                    } if(check_is_downgrade(buf_io, NULL)) {
                        // already at a higher version?
                        rv = EAGAIN;
 8000918:	240b      	movs	r4, #11
 800091a:	e000      	b.n	800091e <firewall_dispatch+0x572>
                mcu_key_clear(NULL);
                oled_show(screen_wiped);

                LOCKUP_FOREVER();
            }
            rv = EPERM;
 800091c:	2401      	movs	r4, #1

fail:

    // Precaution: we don't want to leave ATECC508A authorized for any specific keys,
    // perhaps due to an error path we didn't see. Always reset the chip.
    ae_reset_chip();
 800091e:	f002 f835 	bl	800298c <ae_reset_chip>

    // Unlikely it matters, but clear flash memory cache.
    __HAL_FLASH_DATA_CACHE_DISABLE();
 8000922:	4b1c      	ldr	r3, [pc, #112]	; (8000994 <firewall_dispatch+0x5e8>)
 8000924:	681a      	ldr	r2, [r3, #0]
 8000926:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800092a:	601a      	str	r2, [r3, #0]
    __HAL_FLASH_DATA_CACHE_RESET();
 800092c:	681a      	ldr	r2, [r3, #0]
 800092e:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8000932:	601a      	str	r2, [r3, #0]
 8000934:	681a      	ldr	r2, [r3, #0]
 8000936:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800093a:	601a      	str	r2, [r3, #0]
    __HAL_FLASH_DATA_CACHE_ENABLE();
 800093c:	681a      	ldr	r2, [r3, #0]
 800093e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000942:	601a      	str	r2, [r3, #0]

    // .. and instruction memory (flash cache too?)
    __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
 8000944:	681a      	ldr	r2, [r3, #0]
 8000946:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 800094a:	601a      	str	r2, [r3, #0]
    __HAL_FLASH_INSTRUCTION_CACHE_RESET();
 800094c:	681a      	ldr	r2, [r3, #0]
 800094e:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8000952:	601a      	str	r2, [r3, #0]
 8000954:	681a      	ldr	r2, [r3, #0]
 8000956:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 800095a:	601a      	str	r2, [r3, #0]
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 800095c:	681a      	ldr	r2, [r3, #0]
 800095e:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000962:	601a      	str	r2, [r3, #0]
    

    // authorize return from firewall into user's code
    __HAL_FIREWALL_PREARM_ENABLE();
 8000964:	f5a3 3382 	sub.w	r3, r3, #66560	; 0x10400

    return rv;
}
 8000968:	4620      	mov	r0, r4
    __HAL_FLASH_INSTRUCTION_CACHE_RESET();
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
    

    // authorize return from firewall into user's code
    __HAL_FIREWALL_PREARM_ENABLE();
 800096a:	6a1a      	ldr	r2, [r3, #32]
 800096c:	f042 0201 	orr.w	r2, r2, #1
 8000970:	621a      	str	r2, [r3, #32]
 8000972:	6a1b      	ldr	r3, [r3, #32]
 8000974:	f003 0301 	and.w	r3, r3, #1
 8000978:	930b      	str	r3, [sp, #44]	; 0x2c
 800097a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c

    return rv;
}
 800097c:	b01e      	add	sp, #120	; 0x78
 800097e:	bd70      	pop	{r4, r5, r6, pc}
 8000980:	0801e050 	.word	0x0801e050
 8000984:	0801e070 	.word	0x0801e070
 8000988:	0800dd36 	.word	0x0800dd36
 800098c:	08000300 	.word	0x08000300
 8000990:	0800d59f 	.word	0x0800d59f
 8000994:	40022000 	.word	0x40022000

08000998 <wipe_all_sram>:
//
    static inline void
memset4(uint32_t *dest, uint32_t value, uint32_t byte_len)
{
    for(; byte_len; byte_len-=4, dest++) {
        *dest = value;
 8000998:	480b      	ldr	r0, [pc, #44]	; (80009c8 <wipe_all_sram+0x30>)
// memset4()
//
    static inline void
memset4(uint32_t *dest, uint32_t value, uint32_t byte_len)
{
    for(; byte_len; byte_len-=4, dest++) {
 800099a:	490c      	ldr	r1, [pc, #48]	; (80009cc <wipe_all_sram+0x34>)

// wipe_all_sram()
//
    void
wipe_all_sram(void)
{
 800099c:	f04f 2320 	mov.w	r3, #536879104	; 0x20002000
        *dest = value;
 80009a0:	f843 0b04 	str.w	r0, [r3], #4
// memset4()
//
    static inline void
memset4(uint32_t *dest, uint32_t value, uint32_t byte_len)
{
    for(; byte_len; byte_len-=4, dest++) {
 80009a4:	428b      	cmp	r3, r1
 80009a6:	4a08      	ldr	r2, [pc, #32]	; (80009c8 <wipe_all_sram+0x30>)
 80009a8:	d1fa      	bne.n	80009a0 <wipe_all_sram+0x8>
 80009aa:	4909      	ldr	r1, [pc, #36]	; (80009d0 <wipe_all_sram+0x38>)
 80009ac:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
        *dest = value;
 80009b0:	f843 2b04 	str.w	r2, [r3], #4
// memset4()
//
    static inline void
memset4(uint32_t *dest, uint32_t value, uint32_t byte_len)
{
    for(; byte_len; byte_len-=4, dest++) {
 80009b4:	428b      	cmp	r3, r1
 80009b6:	d1fb      	bne.n	80009b0 <wipe_all_sram+0x18>
 80009b8:	4b06      	ldr	r3, [pc, #24]	; (80009d4 <wipe_all_sram+0x3c>)
 80009ba:	4907      	ldr	r1, [pc, #28]	; (80009d8 <wipe_all_sram+0x40>)
        *dest = value;
 80009bc:	f843 2b04 	str.w	r2, [r3], #4
// memset4()
//
    static inline void
memset4(uint32_t *dest, uint32_t value, uint32_t byte_len)
{
    for(; byte_len; byte_len-=4, dest++) {
 80009c0:	428b      	cmp	r3, r1
 80009c2:	d1fb      	bne.n	80009bc <wipe_all_sram+0x24>
    // wipe all of SRAM (except our own memory)
    const uint32_t s1start = SRAM1_BASE + BL_SRAM_SIZE + 0x400;
    memset4((void *)s1start, noise, SRAM1_BASE  + SRAM1_SIZE_MAX - s1start);
    memset4((void *)SRAM2_BASE, noise, SRAM2_SIZE);
    memset4((void *)SRAM3_BASE, noise, SRAM3_SIZE);
}
 80009c4:	4770      	bx	lr
 80009c6:	bf00      	nop
 80009c8:	deadbeef 	.word	0xdeadbeef
 80009cc:	20030000 	.word	0x20030000
 80009d0:	10010000 	.word	0x10010000
 80009d4:	20040000 	.word	0x20040000
 80009d8:	200a0000 	.word	0x200a0000

080009dc <fatal_error>:

// fatal_error(const char *msg)
//
    void __attribute__((noreturn))
fatal_error(const char *msgvoid)
{
 80009dc:	b508      	push	{r3, lr}
    oled_setup();
 80009de:	f000 f979 	bl	8000cd4 <oled_setup>
    oled_show(screen_fatal);
 80009e2:	4802      	ldr	r0, [pc, #8]	; (80009ec <fatal_error+0x10>)
 80009e4:	f000 fa06 	bl	8000df4 <oled_show>
    BREAKPOINT;
#endif

    // Maybe should do a reset after a delay, like with
    // the watchdog timer or something.
    LOCKUP_FOREVER();
 80009e8:	bf30      	wfi
 80009ea:	e7fd      	b.n	80009e8 <fatal_error+0xc>
 80009ec:	0800dcc5 	.word	0x0800dcc5

080009f0 <fatal_mitm>:

// fatal_mitm()
//
    void __attribute__((noreturn))
fatal_mitm(void)
{
 80009f0:	b508      	push	{r3, lr}
    oled_setup();
 80009f2:	f000 f96f 	bl	8000cd4 <oled_setup>
    oled_show(screen_mitm);
 80009f6:	4803      	ldr	r0, [pc, #12]	; (8000a04 <fatal_mitm+0x14>)
 80009f8:	f000 f9fc 	bl	8000df4 <oled_show>

#ifdef RELEASE
    wipe_all_sram();
 80009fc:	f7ff ffcc 	bl	8000998 <wipe_all_sram>
#endif

    LOCKUP_FOREVER();
 8000a00:	bf30      	wfi
 8000a02:	e7fd      	b.n	8000a00 <fatal_mitm+0x10>
 8000a04:	0800dfd3 	.word	0x0800dfd3

08000a08 <enter_dfu>:

// enter_dfu()
//
    void __attribute__((noreturn))
enter_dfu(void)
{
 8000a08:	b507      	push	{r0, r1, r2, lr}
    puts("enter_dfu()");
 8000a0a:	481d      	ldr	r0, [pc, #116]	; (8000a80 <enter_dfu+0x78>)
 8000a0c:	f004 f956 	bl	8004cbc <puts>

    // clear the green light, if set
    ae_setup();
 8000a10:	f001 ffca 	bl	80029a8 <ae_setup>
    ae_set_gpio(0);
 8000a14:	2000      	movs	r0, #0
 8000a16:	f002 fd23 	bl	8003460 <ae_set_gpio>

    // Reset huge parts of the chip
    __HAL_RCC_APB1_FORCE_RESET();
 8000a1a:	4b1a      	ldr	r3, [pc, #104]	; (8000a84 <enter_dfu+0x7c>)
 8000a1c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    __HAL_RCC_APB1_RELEASE_RESET();
 8000a20:	2200      	movs	r2, #0
    // clear the green light, if set
    ae_setup();
    ae_set_gpio(0);

    // Reset huge parts of the chip
    __HAL_RCC_APB1_FORCE_RESET();
 8000a22:	6399      	str	r1, [r3, #56]	; 0x38
 8000a24:	63d9      	str	r1, [r3, #60]	; 0x3c
    __HAL_RCC_APB1_RELEASE_RESET();
 8000a26:	639a      	str	r2, [r3, #56]	; 0x38
 8000a28:	63da      	str	r2, [r3, #60]	; 0x3c

    __HAL_RCC_APB2_FORCE_RESET();
 8000a2a:	6419      	str	r1, [r3, #64]	; 0x40
    __HAL_RCC_APB2_RELEASE_RESET();
 8000a2c:	641a      	str	r2, [r3, #64]	; 0x40

    __HAL_RCC_AHB1_FORCE_RESET();
 8000a2e:	6299      	str	r1, [r3, #40]	; 0x28
    __HAL_RCC_AHB1_RELEASE_RESET();
 8000a30:	629a      	str	r2, [r3, #40]	; 0x28
    // But not this; it borks things.
    __HAL_RCC_AHB2_FORCE_RESET();
    __HAL_RCC_AHB2_RELEASE_RESET();
#endif

    __HAL_RCC_AHB3_FORCE_RESET();
 8000a32:	6319      	str	r1, [r3, #48]	; 0x30
    __HAL_RCC_AHB3_RELEASE_RESET();
 8000a34:	631a      	str	r2, [r3, #48]	; 0x30

    __HAL_FIREWALL_PREARM_ENABLE();
 8000a36:	f5a3 4374 	sub.w	r3, r3, #62464	; 0xf400
 8000a3a:	6a1a      	ldr	r2, [r3, #32]
 8000a3c:	f042 0201 	orr.w	r2, r2, #1
 8000a40:	621a      	str	r2, [r3, #32]
 8000a42:	6a1b      	ldr	r3, [r3, #32]
 8000a44:	f003 0301 	and.w	r3, r3, #1
 8000a48:	9301      	str	r3, [sp, #4]
 8000a4a:	9b01      	ldr	r3, [sp, #4]

    // Wipe all of memory SRAM, just in case 
    // there is some way to trick us into DFU
    // after sensitive content in place.
    wipe_all_sram();
 8000a4c:	f7ff ffa4 	bl	8000998 <wipe_all_sram>
// Write bag number (probably a string)
void flash_save_bag_number(const uint8_t new_number[32]);

// Are we operating in level2?
static inline bool flash_is_security_level2(void) {
    rng_delay();
 8000a50:	f001 fe75 	bl	800273e <rng_delay>
    return ((FLASH->OPTR & FLASH_OPTR_RDP_Msk) == 0xCC);
 8000a54:	4b0c      	ldr	r3, [pc, #48]	; (8000a88 <enter_dfu+0x80>)
 8000a56:	6a1b      	ldr	r3, [r3, #32]

    if(flash_is_security_level2()) {
 8000a58:	b2db      	uxtb	r3, r3
 8000a5a:	2bcc      	cmp	r3, #204	; 0xcc
 8000a5c:	d101      	bne.n	8000a62 <enter_dfu+0x5a>
        // cannot do DFU in RDP=2, so just die. Helps to preserve screen
        LOCKUP_FOREVER();
 8000a5e:	bf30      	wfi
 8000a60:	e7fd      	b.n	8000a5e <enter_dfu+0x56>
    }

    // Reset clocks.
    HAL_RCC_DeInit();
 8000a62:	f007 fcd1 	bl	8008408 <HAL_RCC_DeInit>

    // move system ROM into 0x0
    __HAL_SYSCFG_REMAPMEMORY_SYSTEMFLASH();
 8000a66:	4a09      	ldr	r2, [pc, #36]	; (8000a8c <enter_dfu+0x84>)
 8000a68:	6813      	ldr	r3, [r2, #0]
 8000a6a:	f023 0307 	bic.w	r3, r3, #7
 8000a6e:	f043 0301 	orr.w	r3, r3, #1
 8000a72:	6013      	str	r3, [r2, #0]

    // simulate a reset vector
    __ASM volatile ("movs r0, #0\n"
 8000a74:	2000      	movs	r0, #0
 8000a76:	6803      	ldr	r3, [r0, #0]
 8000a78:	f383 8808 	msr	MSP, r3
 8000a7c:	6843      	ldr	r3, [r0, #4]
 8000a7e:	4798      	blx	r3
 8000a80:	0800d5a2 	.word	0x0800d5a2
 8000a84:	40021000 	.word	0x40021000
 8000a88:	40022000 	.word	0x40022000
 8000a8c:	40010000 	.word	0x40010000

08000a90 <system_startup>:
//
// Called only on system boot.
//
    void
system_startup(void)
{
 8000a90:	b510      	push	{r4, lr}
    // configure critical stuff
    system_init0();
 8000a92:	f001 f9c3 	bl	8001e1c <system_init0>
    clocks_setup();
 8000a96:	f001 f9e3 	bl	8001e60 <clocks_setup>
    rng_setup();            // needs to be super early
 8000a9a:	f001 fe0d 	bl	80026b8 <rng_setup>
    rng_delay();
 8000a9e:	f001 fe4e 	bl	800273e <rng_delay>

#if RELEASE
    // security check: should we be in protected mode? Was there some UV-C bitrot perhaps?
    if(!check_all_ones(rom_secrets->bag_number, sizeof(rom_secrets->bag_number))
 8000aa2:	2120      	movs	r1, #32
 8000aa4:	483c      	ldr	r0, [pc, #240]	; (8000b98 <system_startup+0x108>)
 8000aa6:	f001 fdcb 	bl	8002640 <check_all_ones>
 8000aaa:	b948      	cbnz	r0, 8000ac0 <system_startup+0x30>
// Write bag number (probably a string)
void flash_save_bag_number(const uint8_t new_number[32]);

// Are we operating in level2?
static inline bool flash_is_security_level2(void) {
    rng_delay();
 8000aac:	f001 fe47 	bl	800273e <rng_delay>
    return ((FLASH->OPTR & FLASH_OPTR_RDP_Msk) == 0xCC);
 8000ab0:	4b3a      	ldr	r3, [pc, #232]	; (8000b9c <system_startup+0x10c>)
 8000ab2:	6a1b      	ldr	r3, [r3, #32]
            && !flash_is_security_level2()
 8000ab4:	b2db      	uxtb	r3, r3
 8000ab6:	2bcc      	cmp	r3, #204	; 0xcc
 8000ab8:	d002      	beq.n	8000ac0 <system_startup+0x30>
    ) {
        // yikes. recovery: do lockdown... we should be/(thought we were) locked already
        flash_lockdown_hard(OB_RDP_LEVEL_2);
 8000aba:	20cc      	movs	r0, #204	; 0xcc
 8000abc:	f001 fc74 	bl	80023a8 <flash_lockdown_hard>
#else
# warning "Built for debug."
#endif

    // config pins
    gpio_setup();
 8000ac0:	f002 fef6 	bl	80038b0 <gpio_setup>

    // debug output and banner
    console_setup();
 8000ac4:	f004 f81c 	bl	8004b00 <console_setup>

    puts2("\r\n\nMk4 Bootloader: ");
 8000ac8:	4835      	ldr	r0, [pc, #212]	; (8000ba0 <system_startup+0x110>)
 8000aca:	f004 f869 	bl	8004ba0 <puts2>
    puts(version_string);
 8000ace:	4835      	ldr	r0, [pc, #212]	; (8000ba4 <system_startup+0x114>)
 8000ad0:	f004 f8f4 	bl	8004cbc <puts>

    // lots of manual memory alloc here...
    uint8_t            *reboot_seed = &reboot_seed_base[0];  // 32 bytes

    // populate seed w/ some noise
    ASSERT(((uint32_t)reboot_seed) == 0x20001c00);
 8000ad4:	4834      	ldr	r0, [pc, #208]	; (8000ba8 <system_startup+0x118>)
 8000ad6:	4b35      	ldr	r3, [pc, #212]	; (8000bac <system_startup+0x11c>)
 8000ad8:	4298      	cmp	r0, r3
 8000ada:	d002      	beq.n	8000ae2 <system_startup+0x52>
 8000adc:	4834      	ldr	r0, [pc, #208]	; (8000bb0 <system_startup+0x120>)
 8000ade:	f7ff ff7d 	bl	80009dc <fatal_error>
    rng_buffer(reboot_seed, 32);
 8000ae2:	2120      	movs	r1, #32
 8000ae4:	f001 fe14 	bl	8002710 <rng_buffer>

    ASSERT((uint32_t)&shared_bootflags == RAM_BOOT_FLAGS_MK4);
 8000ae8:	4c32      	ldr	r4, [pc, #200]	; (8000bb4 <system_startup+0x124>)
 8000aea:	4b33      	ldr	r3, [pc, #204]	; (8000bb8 <system_startup+0x128>)
 8000aec:	429c      	cmp	r4, r3
 8000aee:	d1f5      	bne.n	8000adc <system_startup+0x4c>

    // clear
    shared_bootflags = 0;
 8000af0:	2300      	movs	r3, #0
 8000af2:	6023      	str	r3, [r4, #0]
// Write bag number (probably a string)
void flash_save_bag_number(const uint8_t new_number[32]);

// Are we operating in level2?
static inline bool flash_is_security_level2(void) {
    rng_delay();
 8000af4:	f001 fe23 	bl	800273e <rng_delay>
    return ((FLASH->OPTR & FLASH_OPTR_RDP_Msk) == 0xCC);
 8000af8:	4b28      	ldr	r3, [pc, #160]	; (8000b9c <system_startup+0x10c>)
 8000afa:	6a1b      	ldr	r3, [r3, #32]

    // this value can also be checked at runtime, but historical
    if(!flash_is_security_level2()) {
 8000afc:	b2db      	uxtb	r3, r3
 8000afe:	2bcc      	cmp	r3, #204	; 0xcc
#if RELEASE
        shared_bootflags |= RBF_FACTORY_MODE;
 8000b00:	bf1e      	ittt	ne
 8000b02:	6823      	ldrne	r3, [r4, #0]
 8000b04:	f043 0302 	orrne.w	r3, r3, #2
 8000b08:	6023      	strne	r3, [r4, #0]
#endif
    rng_delay();

    // Workaround to get into DFU from micropython
    // LATER: none of this is useful with RDP=2, but okay in the office.
    if(memcmp(dfu_flag->magic, REBOOT_TO_DFU, sizeof(dfu_flag->magic)) == 0) {
 8000b0a:	4c2c      	ldr	r4, [pc, #176]	; (8000bbc <system_startup+0x12c>)
    puts2("\r\n\nMk4 Bootloader: ");
    puts(version_string);

    // setup some limited shared data space between mpy and ourselves
    reboot_seed_setup();
    rng_delay();
 8000b0c:	f001 fe17 	bl	800273e <rng_delay>

#ifndef RELEASE
    sha256_selftest();
    aes_selftest();
#endif
    rng_delay();
 8000b10:	f001 fe15 	bl	800273e <rng_delay>

    // Workaround to get into DFU from micropython
    // LATER: none of this is useful with RDP=2, but okay in the office.
    if(memcmp(dfu_flag->magic, REBOOT_TO_DFU, sizeof(dfu_flag->magic)) == 0) {
 8000b14:	2208      	movs	r2, #8
 8000b16:	492a      	ldr	r1, [pc, #168]	; (8000bc0 <system_startup+0x130>)
 8000b18:	4620      	mov	r0, r4
 8000b1a:	f00c fca3 	bl	800d464 <memcmp>
 8000b1e:	b938      	cbnz	r0, 8000b30 <system_startup+0xa0>
        dfu_flag->magic[0] = 0;
 8000b20:	7020      	strb	r0, [r4, #0]

        // still see a flash here, but that's proof it works.
        oled_setup();
 8000b22:	f000 f8d7 	bl	8000cd4 <oled_setup>
        oled_show(dfu_flag->screen);
 8000b26:	68a0      	ldr	r0, [r4, #8]
 8000b28:	f000 f964 	bl	8000df4 <oled_show>

        enter_dfu();
 8000b2c:	f7ff ff6c 	bl	8000a08 <enter_dfu>
        // NOT-REACHED
    }
    rng_delay();
 8000b30:	f001 fe05 	bl	800273e <rng_delay>

    // clear and setup OLED display
    oled_setup();
 8000b34:	f000 f8ce 	bl	8000cd4 <oled_setup>
    oled_show_progress(screen_verify, 0);
 8000b38:	2100      	movs	r1, #0
 8000b3a:	4822      	ldr	r0, [pc, #136]	; (8000bc4 <system_startup+0x134>)
 8000b3c:	f000 f99c 	bl	8000e78 <oled_show_progress>

    // wipe all of SRAM (except our own memory, which was already wiped)
    wipe_all_sram();
 8000b40:	f7ff ff2a 	bl	8000998 <wipe_all_sram>

    puts2("SE1 setup: ");
 8000b44:	4820      	ldr	r0, [pc, #128]	; (8000bc8 <system_startup+0x138>)
 8000b46:	f004 f82b 	bl	8004ba0 <puts2>

    // secure elements setup
    ae_setup();
 8000b4a:	f001 ff2d 	bl	80029a8 <ae_setup>
    ae_set_gpio(0);         // turn light red
 8000b4e:	2000      	movs	r0, #0
 8000b50:	f002 fc86 	bl	8003460 <ae_set_gpio>

    puts("done");
 8000b54:	481d      	ldr	r0, [pc, #116]	; (8000bcc <system_startup+0x13c>)
 8000b56:	f004 f8b1 	bl	8004cbc <puts>

    puts2("SE2 setup: ");
 8000b5a:	481d      	ldr	r0, [pc, #116]	; (8000bd0 <system_startup+0x140>)
 8000b5c:	f004 f820 	bl	8004ba0 <puts2>
    se2_setup();
 8000b60:	f007 f82c 	bl	8007bbc <se2_setup>
    se2_probe();
 8000b64:	f006 fdb8 	bl	80076d8 <se2_probe>
    puts("done");
 8000b68:	4818      	ldr	r0, [pc, #96]	; (8000bcc <system_startup+0x13c>)
 8000b6a:	f004 f8a7 	bl	8004cbc <puts>

    // protect our flash, and/or check it's protected 
    // - and pick pairing secret if we don't already have one
    // - may also do one-time setup of the secure elements
    // - note: ae_setup must already be called, since it can talk to that
    flash_setup();
 8000b6e:	f001 fb7b 	bl	8002268 <flash_setup>
    //puts("Flash: setup done");

    //puts("PSRAM setup");
    psram_setup();
 8000b72:	f004 f8d9 	bl	8004d28 <psram_setup>

    // Check firmware is legit; else enter DFU
    // - may die due to downgrade attack or badly signed image
    puts2("Verify: ");
 8000b76:	4817      	ldr	r0, [pc, #92]	; (8000bd4 <system_startup+0x144>)
 8000b78:	f004 f812 	bl	8004ba0 <puts2>
    bool main_ok = verify_firmware();
 8000b7c:	f001 f8ea 	bl	8001d54 <verify_firmware>

    if(main_ok) {
 8000b80:	b120      	cbz	r0, 8000b8c <system_startup+0xfc>
        // load a blank screen, so that if the firmware crashes, we are showing
        // something reasonable and not misleading.
        oled_show(screen_blankish);
 8000b82:	4815      	ldr	r0, [pc, #84]	; (8000bd8 <system_startup+0x148>)
    // .. will reboot if it works; only helps w/ reset pulses, not power downs.
    psram_recover_firmware();

    // use SDCard to recover
    while(1) sdcard_recovery();
}
 8000b84:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    bool main_ok = verify_firmware();

    if(main_ok) {
        // load a blank screen, so that if the firmware crashes, we are showing
        // something reasonable and not misleading.
        oled_show(screen_blankish);
 8000b88:	f000 b934 	b.w	8000df4 <oled_show>
    }


    // try to recover, from an image hanging around in PSRAM
    // .. will reboot if it works; only helps w/ reset pulses, not power downs.
    psram_recover_firmware();
 8000b8c:	f004 fa1c 	bl	8004fc8 <psram_recover_firmware>

    // use SDCard to recover
    while(1) sdcard_recovery();
 8000b90:	f004 fba8 	bl	80052e4 <sdcard_recovery>
 8000b94:	e7fc      	b.n	8000b90 <system_startup+0x100>
 8000b96:	bf00      	nop
 8000b98:	0801e050 	.word	0x0801e050
 8000b9c:	40022000 	.word	0x40022000
 8000ba0:	0800d5ae 	.word	0x0800d5ae
 8000ba4:	0800e480 	.word	0x0800e480
 8000ba8:	20001c00 	.word	0x20001c00
 8000bac:	20001c00 	.word	0x20001c00
 8000bb0:	0800d558 	.word	0x0800d558
 8000bb4:	20001c20 	.word	0x20001c20
 8000bb8:	20001c20 	.word	0x20001c20
 8000bbc:	20008000 	.word	0x20008000
 8000bc0:	0800d596 	.word	0x0800d596
 8000bc4:	0800d62a 	.word	0x0800d62a
 8000bc8:	0800d5c2 	.word	0x0800d5c2
 8000bcc:	0800d5ce 	.word	0x0800d5ce
 8000bd0:	0800d5d3 	.word	0x0800d5d3
 8000bd4:	0800d5df 	.word	0x0800d5df
 8000bd8:	0800dd09 	.word	0x0800dd09

08000bdc <write_bytes>:
    static inline void
write_bytes(int len, const uint8_t *buf)
{
#ifndef DISABLE_OLED
    // send via SPI(1)
    HAL_SPI_Transmit(&spi_port, (uint8_t *)buf, len, HAL_MAX_DELAY);
 8000bdc:	b282      	uxth	r2, r0
 8000bde:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8000be2:	4801      	ldr	r0, [pc, #4]	; (8000be8 <write_bytes+0xc>)
 8000be4:	f000 bc1a 	b.w	800141c <HAL_SPI_Transmit>
 8000be8:	20000168 	.word	0x20000168

08000bec <oled_write_cmd>:

// oled_write_cmd()
//
    void
oled_write_cmd(uint8_t cmd)
{
 8000bec:	b513      	push	{r0, r1, r4, lr}
 8000bee:	ac02      	add	r4, sp, #8
    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000bf0:	2201      	movs	r2, #1

// oled_write_cmd()
//
    void
oled_write_cmd(uint8_t cmd)
{
 8000bf2:	f804 0d01 	strb.w	r0, [r4, #-1]!
    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000bf6:	2110      	movs	r1, #16
 8000bf8:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000bfc:	f000 fb5c 	bl	80012b8 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOA, DC_PIN, 0);
 8000c00:	2200      	movs	r2, #0
 8000c02:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000c06:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000c0a:	f000 fb55 	bl	80012b8 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOA, CS_PIN, 0);
 8000c0e:	2200      	movs	r2, #0
 8000c10:	2110      	movs	r1, #16
 8000c12:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000c16:	f000 fb4f 	bl	80012b8 <HAL_GPIO_WritePin>

    write_bytes(1, &cmd);
 8000c1a:	4621      	mov	r1, r4
 8000c1c:	2001      	movs	r0, #1
 8000c1e:	f7ff ffdd 	bl	8000bdc <write_bytes>

    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000c22:	2201      	movs	r2, #1
 8000c24:	2110      	movs	r1, #16
 8000c26:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000c2a:	f000 fb45 	bl	80012b8 <HAL_GPIO_WritePin>
}
 8000c2e:	b002      	add	sp, #8
 8000c30:	bd10      	pop	{r4, pc}

08000c32 <oled_write_cmd_sequence>:

// oled_write_cmd_sequence()
//
    void
oled_write_cmd_sequence(int len, const uint8_t *cmds)
{
 8000c32:	b570      	push	{r4, r5, r6, lr}
 8000c34:	4606      	mov	r6, r0
 8000c36:	460d      	mov	r5, r1
    for(int i=0; i<len; i++) {
 8000c38:	460c      	mov	r4, r1
 8000c3a:	1b63      	subs	r3, r4, r5
 8000c3c:	429e      	cmp	r6, r3
 8000c3e:	dd04      	ble.n	8000c4a <oled_write_cmd_sequence+0x18>
        oled_write_cmd(cmds[i]);
 8000c40:	f814 0b01 	ldrb.w	r0, [r4], #1
 8000c44:	f7ff ffd2 	bl	8000bec <oled_write_cmd>
 8000c48:	e7f7      	b.n	8000c3a <oled_write_cmd_sequence+0x8>
    }
}
 8000c4a:	bd70      	pop	{r4, r5, r6, pc}

08000c4c <oled_write_data>:

// oled_write_data()
//
    void
oled_write_data(int len, const uint8_t *pixels)
{
 8000c4c:	b538      	push	{r3, r4, r5, lr}
    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000c4e:	2201      	movs	r2, #1

// oled_write_data()
//
    void
oled_write_data(int len, const uint8_t *pixels)
{
 8000c50:	4604      	mov	r4, r0
 8000c52:	460d      	mov	r5, r1
    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000c54:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000c58:	2110      	movs	r1, #16
 8000c5a:	f000 fb2d 	bl	80012b8 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOA, DC_PIN, 1);
 8000c5e:	2201      	movs	r2, #1
 8000c60:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000c64:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000c68:	f000 fb26 	bl	80012b8 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOA, CS_PIN, 0);
 8000c6c:	2200      	movs	r2, #0
 8000c6e:	2110      	movs	r1, #16
 8000c70:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000c74:	f000 fb20 	bl	80012b8 <HAL_GPIO_WritePin>

    write_bytes(len, pixels);
 8000c78:	4629      	mov	r1, r5
 8000c7a:	4620      	mov	r0, r4
 8000c7c:	f7ff ffae 	bl	8000bdc <write_bytes>

    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000c80:	2201      	movs	r2, #1
 8000c82:	2110      	movs	r1, #16
 8000c84:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
}
 8000c88:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    HAL_GPIO_WritePin(GPIOA, DC_PIN, 1);
    HAL_GPIO_WritePin(GPIOA, CS_PIN, 0);

    write_bytes(len, pixels);

    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000c8c:	f000 bb14 	b.w	80012b8 <HAL_GPIO_WritePin>

08000c90 <oled_spi_setup>:
//
// Just setup SPI, do not reset display, etc.
//
    void
oled_spi_setup(void)
{
 8000c90:	b538      	push	{r3, r4, r5, lr}
#ifndef DISABLE_OLED
    // might already be setup
    if(spi_port.Instance == SPI1) return;
 8000c92:	4c0e      	ldr	r4, [pc, #56]	; (8000ccc <oled_spi_setup+0x3c>)
 8000c94:	4d0e      	ldr	r5, [pc, #56]	; (8000cd0 <oled_spi_setup+0x40>)
 8000c96:	6823      	ldr	r3, [r4, #0]
 8000c98:	42ab      	cmp	r3, r5
 8000c9a:	d015      	beq.n	8000cc8 <oled_spi_setup+0x38>

    memset(&spi_port, 0, sizeof(spi_port));
 8000c9c:	4620      	mov	r0, r4
 8000c9e:	2264      	movs	r2, #100	; 0x64
 8000ca0:	2100      	movs	r1, #0
 8000ca2:	f00c fc14 	bl	800d4ce <memset>

    spi_port.Instance = SPI1;

    // see SPI_InitTypeDef
    spi_port.Init.Mode = SPI_MODE_MASTER;
 8000ca6:	f44f 7382 	mov.w	r3, #260	; 0x104
 8000caa:	6063      	str	r3, [r4, #4]
    spi_port.Init.Direction = SPI_DIRECTION_2LINES;
    spi_port.Init.DataSize = SPI_DATASIZE_8BIT;
 8000cac:	f44f 63e0 	mov.w	r3, #1792	; 0x700
 8000cb0:	60e3      	str	r3, [r4, #12]
    spi_port.Init.CLKPolarity = SPI_POLARITY_LOW;
    spi_port.Init.CLKPhase = SPI_PHASE_1EDGE;
    spi_port.Init.NSS = SPI_NSS_SOFT;
 8000cb2:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000cb6:	61a3      	str	r3, [r4, #24]
    spi_port.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;    // conservative
 8000cb8:	2318      	movs	r3, #24
    // might already be setup
    if(spi_port.Instance == SPI1) return;

    memset(&spi_port, 0, sizeof(spi_port));

    spi_port.Instance = SPI1;
 8000cba:	6025      	str	r5, [r4, #0]
    spi_port.Init.Direction = SPI_DIRECTION_2LINES;
    spi_port.Init.DataSize = SPI_DATASIZE_8BIT;
    spi_port.Init.CLKPolarity = SPI_POLARITY_LOW;
    spi_port.Init.CLKPhase = SPI_PHASE_1EDGE;
    spi_port.Init.NSS = SPI_NSS_SOFT;
    spi_port.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;    // conservative
 8000cbc:	61e3      	str	r3, [r4, #28]
    spi_port.Init.FirstBit = SPI_FIRSTBIT_MSB;
    spi_port.Init.TIMode = SPI_TIMODE_DISABLED;
    spi_port.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;

    HAL_SPI_Init(&spi_port);
 8000cbe:	4620      	mov	r0, r4
#endif
}
 8000cc0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    spi_port.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;    // conservative
    spi_port.Init.FirstBit = SPI_FIRSTBIT_MSB;
    spi_port.Init.TIMode = SPI_TIMODE_DISABLED;
    spi_port.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;

    HAL_SPI_Init(&spi_port);
 8000cc4:	f000 bb50 	b.w	8001368 <HAL_SPI_Init>
 8000cc8:	bd38      	pop	{r3, r4, r5, pc}
 8000cca:	bf00      	nop
 8000ccc:	20000168 	.word	0x20000168
 8000cd0:	40013000 	.word	0x40013000

08000cd4 <oled_setup>:
//
// Ok to call this lots.
//
    void
oled_setup(void)
{
 8000cd4:	b530      	push	{r4, r5, lr}
    puts("oled disabled");return;     // disable so I can use MCO
#endif

    static uint32_t inited;

    if(inited == 0x238a572F) {
 8000cd6:	4b2c      	ldr	r3, [pc, #176]	; (8000d88 <oled_setup+0xb4>)
 8000cd8:	4a2c      	ldr	r2, [pc, #176]	; (8000d8c <oled_setup+0xb8>)
 8000cda:	6819      	ldr	r1, [r3, #0]
 8000cdc:	4291      	cmp	r1, r2
//
// Ok to call this lots.
//
    void
oled_setup(void)
{
 8000cde:	b089      	sub	sp, #36	; 0x24
    puts("oled disabled");return;     // disable so I can use MCO
#endif

    static uint32_t inited;

    if(inited == 0x238a572F) {
 8000ce0:	d050      	beq.n	8000d84 <oled_setup+0xb0>
        return;
    }
    inited = 0x238a572F;
 8000ce2:	601a      	str	r2, [r3, #0]

    // enable some internal clocks
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000ce4:	4b2a      	ldr	r3, [pc, #168]	; (8000d90 <oled_setup+0xbc>)
    __HAL_RCC_SPI1_CLK_ENABLE();

    // simple pins
    GPIO_InitTypeDef setup = {
 8000ce6:	4d2b      	ldr	r5, [pc, #172]	; (8000d94 <oled_setup+0xc0>)
        return;
    }
    inited = 0x238a572F;

    // enable some internal clocks
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000ce8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000cea:	f042 0201 	orr.w	r2, r2, #1
 8000cee:	64da      	str	r2, [r3, #76]	; 0x4c
 8000cf0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000cf2:	f002 0201 	and.w	r2, r2, #1
 8000cf6:	9201      	str	r2, [sp, #4]
 8000cf8:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_SPI1_CLK_ENABLE();
 8000cfa:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8000cfc:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8000d00:	661a      	str	r2, [r3, #96]	; 0x60
 8000d02:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8000d04:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8000d08:	9302      	str	r3, [sp, #8]
 8000d0a:	9b02      	ldr	r3, [sp, #8]

    // simple pins
    GPIO_InitTypeDef setup = {
 8000d0c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000d0e:	ac03      	add	r4, sp, #12
 8000d10:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000d12:	682b      	ldr	r3, [r5, #0]
 8000d14:	6023      	str	r3, [r4, #0]
        .Mode = GPIO_MODE_OUTPUT_PP,
        .Pull = GPIO_NOPULL,
        .Speed = GPIO_SPEED_FREQ_MEDIUM,
        .Alternate = 0,
    };
    HAL_GPIO_Init(GPIOA, &setup);
 8000d16:	a903      	add	r1, sp, #12
 8000d18:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000d1c:	f000 f950 	bl	8000fc0 <HAL_GPIO_Init>

    // starting values
    HAL_GPIO_WritePin(GPIOA, RESET_PIN | CS_PIN | DC_PIN, 1);
 8000d20:	2201      	movs	r2, #1
 8000d22:	f44f 71a8 	mov.w	r1, #336	; 0x150
 8000d26:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000d2a:	f000 fac5 	bl	80012b8 <HAL_GPIO_WritePin>

    // SPI pins
    setup.Pin = SPI_SCK | SPI_MOSI;
 8000d2e:	23a0      	movs	r3, #160	; 0xa0
 8000d30:	9303      	str	r3, [sp, #12]
    setup.Mode = GPIO_MODE_AF_PP;
 8000d32:	2302      	movs	r3, #2
 8000d34:	9304      	str	r3, [sp, #16]
    setup.Alternate = GPIO_AF5_SPI1;
    HAL_GPIO_Init(GPIOA, &setup);
 8000d36:	a903      	add	r1, sp, #12
    HAL_GPIO_WritePin(GPIOA, RESET_PIN | CS_PIN | DC_PIN, 1);

    // SPI pins
    setup.Pin = SPI_SCK | SPI_MOSI;
    setup.Mode = GPIO_MODE_AF_PP;
    setup.Alternate = GPIO_AF5_SPI1;
 8000d38:	2305      	movs	r3, #5
    HAL_GPIO_Init(GPIOA, &setup);
 8000d3a:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    HAL_GPIO_WritePin(GPIOA, RESET_PIN | CS_PIN | DC_PIN, 1);

    // SPI pins
    setup.Pin = SPI_SCK | SPI_MOSI;
    setup.Mode = GPIO_MODE_AF_PP;
    setup.Alternate = GPIO_AF5_SPI1;
 8000d3e:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &setup);
 8000d40:	f000 f93e 	bl	8000fc0 <HAL_GPIO_Init>

    // lock the RESET pin so that St's DFU code doesn't clear screen
    // it might be trying to use it a MISO signal for SPI loading
    HAL_GPIO_LockPin(GPIOA, RESET_PIN | CS_PIN | DC_PIN);
 8000d44:	f44f 71a8 	mov.w	r1, #336	; 0x150
 8000d48:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000d4c:	f000 fabd 	bl	80012ca <HAL_GPIO_LockPin>

    // 10ms low-going pulse on reset pin
    delay_ms(1);
 8000d50:	2001      	movs	r0, #1
 8000d52:	f002 fd9d 	bl	8003890 <delay_ms>
    HAL_GPIO_WritePin(GPIOA, RESET_PIN, 0);
 8000d56:	2200      	movs	r2, #0
 8000d58:	2140      	movs	r1, #64	; 0x40
 8000d5a:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000d5e:	f000 faab 	bl	80012b8 <HAL_GPIO_WritePin>
    delay_ms(10);
 8000d62:	200a      	movs	r0, #10
 8000d64:	f002 fd94 	bl	8003890 <delay_ms>
    HAL_GPIO_WritePin(GPIOA, RESET_PIN, 1);
 8000d68:	2201      	movs	r2, #1
 8000d6a:	2140      	movs	r1, #64	; 0x40
 8000d6c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000d70:	f000 faa2 	bl	80012b8 <HAL_GPIO_WritePin>

    oled_spi_setup();
 8000d74:	f7ff ff8c 	bl	8000c90 <oled_spi_setup>
    // this code:
    //      '0x37c', '0x1700', '0x603'
    //SPI1->CR1 = 0x354;

    // write a sequence to reset things
    oled_write_cmd_sequence(sizeof(reset_commands), reset_commands);
 8000d78:	4907      	ldr	r1, [pc, #28]	; (8000d98 <oled_setup+0xc4>)
 8000d7a:	2019      	movs	r0, #25
 8000d7c:	f7ff ff59 	bl	8000c32 <oled_write_cmd_sequence>

    rng_delay();
 8000d80:	f001 fcdd 	bl	800273e <rng_delay>
}
 8000d84:	b009      	add	sp, #36	; 0x24
 8000d86:	bd30      	pop	{r4, r5, pc}
 8000d88:	20000164 	.word	0x20000164
 8000d8c:	238a572f 	.word	0x238a572f
 8000d90:	40021000 	.word	0x40021000
 8000d94:	0800d5e8 	.word	0x0800d5e8
 8000d98:	0800d611 	.word	0x0800d611

08000d9c <oled_show_raw>:
//
// No decompression.
//
    void
oled_show_raw(uint32_t len, const uint8_t *pixels)
{
 8000d9c:	b538      	push	{r3, r4, r5, lr}
 8000d9e:	4604      	mov	r4, r0
 8000da0:	460d      	mov	r5, r1
    oled_setup();
 8000da2:	f7ff ff97 	bl	8000cd4 <oled_setup>

    oled_write_cmd_sequence(sizeof(before_show), before_show);
 8000da6:	4912      	ldr	r1, [pc, #72]	; (8000df0 <oled_show_raw+0x54>)
 8000da8:	2006      	movs	r0, #6
 8000daa:	f7ff ff42 	bl	8000c32 <oled_write_cmd_sequence>

    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000dae:	2201      	movs	r2, #1
 8000db0:	2110      	movs	r1, #16
 8000db2:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000db6:	f000 fa7f 	bl	80012b8 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOA, DC_PIN, 1);
 8000dba:	2201      	movs	r2, #1
 8000dbc:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000dc0:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000dc4:	f000 fa78 	bl	80012b8 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOA, CS_PIN, 0);
 8000dc8:	2200      	movs	r2, #0
 8000dca:	2110      	movs	r1, #16
 8000dcc:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000dd0:	f000 fa72 	bl	80012b8 <HAL_GPIO_WritePin>

    write_bytes(len, pixels);
 8000dd4:	4629      	mov	r1, r5
 8000dd6:	4620      	mov	r0, r4
 8000dd8:	f7ff ff00 	bl	8000bdc <write_bytes>

    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000ddc:	2201      	movs	r2, #1
 8000dde:	2110      	movs	r1, #16
 8000de0:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000de4:	f000 fa68 	bl	80012b8 <HAL_GPIO_WritePin>
    rng_delay();
}
 8000de8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    HAL_GPIO_WritePin(GPIOA, CS_PIN, 0);

    write_bytes(len, pixels);

    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
    rng_delay();
 8000dec:	f001 bca7 	b.w	800273e <rng_delay>
 8000df0:	0800d5fc 	.word	0x0800d5fc

08000df4 <oled_show>:
//
// Perform simple RLE decompression.
//
    void
oled_show(const uint8_t *pixels)
{
 8000df4:	b530      	push	{r4, r5, lr}
 8000df6:	b0a1      	sub	sp, #132	; 0x84
 8000df8:	4604      	mov	r4, r0
    oled_setup();
 8000dfa:	f7ff ff6b 	bl	8000cd4 <oled_setup>

    oled_write_cmd_sequence(sizeof(before_show), before_show);
 8000dfe:	491d      	ldr	r1, [pc, #116]	; (8000e74 <oled_show+0x80>)
 8000e00:	2006      	movs	r0, #6
 8000e02:	f7ff ff16 	bl	8000c32 <oled_write_cmd_sequence>

    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000e06:	2201      	movs	r2, #1
 8000e08:	2110      	movs	r1, #16
 8000e0a:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000e0e:	f000 fa53 	bl	80012b8 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOA, DC_PIN, 1);
 8000e12:	2201      	movs	r2, #1
 8000e14:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000e18:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000e1c:	f000 fa4c 	bl	80012b8 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOA, CS_PIN, 0);
 8000e20:	2200      	movs	r2, #0
 8000e22:	2110      	movs	r1, #16
 8000e24:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000e28:	f000 fa46 	bl	80012b8 <HAL_GPIO_WritePin>
    uint8_t         buf[127];
    const uint8_t *p = pixels;

    // NOTE: must also update code in oled_show_progress, which dups this heavily.
    while(1) {
        uint8_t hdr = *(p++);
 8000e2c:	7823      	ldrb	r3, [r4, #0]
        if(!hdr) break;
 8000e2e:	b1b3      	cbz	r3, 8000e5e <oled_show+0x6a>

        uint8_t len = hdr & 0x7f;
 8000e30:	f003 057f 	and.w	r5, r3, #127	; 0x7f
        if(hdr & 0x80) {
 8000e34:	061b      	lsls	r3, r3, #24
 8000e36:	d507      	bpl.n	8000e48 <oled_show+0x54>
    uint8_t         buf[127];
    const uint8_t *p = pixels;

    // NOTE: must also update code in oled_show_progress, which dups this heavily.
    while(1) {
        uint8_t hdr = *(p++);
 8000e38:	3401      	adds	r4, #1
        if(!hdr) break;

        uint8_t len = hdr & 0x7f;
        if(hdr & 0x80) {
            // random bytes follow
            memcpy(buf, p, len);
 8000e3a:	4621      	mov	r1, r4
 8000e3c:	462a      	mov	r2, r5
 8000e3e:	4668      	mov	r0, sp
 8000e40:	f00c fb1f 	bl	800d482 <memcpy>
            p += len;
 8000e44:	442c      	add	r4, r5
 8000e46:	e005      	b.n	8000e54 <oled_show+0x60>
        } else {
            // repeat same byte
            memset(buf, *p, len);
 8000e48:	7861      	ldrb	r1, [r4, #1]
 8000e4a:	462a      	mov	r2, r5
 8000e4c:	4668      	mov	r0, sp
 8000e4e:	f00c fb3e 	bl	800d4ce <memset>
            p++;
 8000e52:	3402      	adds	r4, #2
        }

        write_bytes(len, buf);
 8000e54:	4669      	mov	r1, sp
 8000e56:	4628      	mov	r0, r5
 8000e58:	f7ff fec0 	bl	8000bdc <write_bytes>
    }
 8000e5c:	e7e6      	b.n	8000e2c <oled_show+0x38>

    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000e5e:	2201      	movs	r2, #1
 8000e60:	2110      	movs	r1, #16
 8000e62:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000e66:	f000 fa27 	bl	80012b8 <HAL_GPIO_WritePin>
    rng_delay();
 8000e6a:	f001 fc68 	bl	800273e <rng_delay>
}
 8000e6e:	b021      	add	sp, #132	; 0x84
 8000e70:	bd30      	pop	{r4, r5, pc}
 8000e72:	bf00      	nop
 8000e74:	0800d5fc 	.word	0x0800d5fc

08000e78 <oled_show_progress>:
//
// Perform simple RLE decompression, and add a bar on final screen line.
//
    void
oled_show_progress(const uint8_t *pixels, int progress)
{
 8000e78:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000e7c:	b0a0      	sub	sp, #128	; 0x80
 8000e7e:	460d      	mov	r5, r1
 8000e80:	4607      	mov	r7, r0
    oled_setup();
 8000e82:	f7ff ff27 	bl	8000cd4 <oled_setup>

    oled_write_cmd_sequence(sizeof(before_show), before_show);
 8000e86:	493c      	ldr	r1, [pc, #240]	; (8000f78 <oled_show_progress+0x100>)
 8000e88:	2006      	movs	r0, #6
 8000e8a:	f7ff fed2 	bl	8000c32 <oled_write_cmd_sequence>

    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000e8e:	2201      	movs	r2, #1
 8000e90:	2110      	movs	r1, #16
 8000e92:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000e96:	f000 fa0f 	bl	80012b8 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOA, DC_PIN, 1);
 8000e9a:	2201      	movs	r2, #1
 8000e9c:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000ea0:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000ea4:	f000 fa08 	bl	80012b8 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOA, CS_PIN, 0);
 8000ea8:	2110      	movs	r1, #16
 8000eaa:	2200      	movs	r2, #0
 8000eac:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000eb0:	f000 fa02 	bl	80012b8 <HAL_GPIO_WritePin>

    uint8_t         buf[127];
    const uint8_t *p = pixels;

    const uint16_t p_start = 896;
    uint32_t p_count = 1280 * progress / 1000;
 8000eb4:	f44f 61a0 	mov.w	r1, #1280	; 0x500
 8000eb8:	4369      	muls	r1, r5
 8000eba:	2600      	movs	r6, #0
 8000ebc:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8000ec0:	fb91 f5f5 	sdiv	r5, r1, r5
 8000ec4:	2d80      	cmp	r5, #128	; 0x80
 8000ec6:	bf28      	it	cs
 8000ec8:	2580      	movcs	r5, #128	; 0x80
 8000eca:	46b0      	mov	r8, r6

    bool last_line = false;

    uint16_t offset = 0;
    while(1) {
        uint8_t hdr = *(p++);
 8000ecc:	783b      	ldrb	r3, [r7, #0]
        if(hdr == 0) break;
 8000ece:	b3ab      	cbz	r3, 8000f3c <oled_show_progress+0xc4>

        uint8_t len = hdr & 0x7f;
 8000ed0:	f003 047f 	and.w	r4, r3, #127	; 0x7f
        if(hdr & 0x80) {
 8000ed4:	061b      	lsls	r3, r3, #24
 8000ed6:	d507      	bpl.n	8000ee8 <oled_show_progress+0x70>

    bool last_line = false;

    uint16_t offset = 0;
    while(1) {
        uint8_t hdr = *(p++);
 8000ed8:	3701      	adds	r7, #1
        if(hdr == 0) break;

        uint8_t len = hdr & 0x7f;
        if(hdr & 0x80) {
            // random bytes follow
            memcpy(buf, p, len);
 8000eda:	4639      	mov	r1, r7
 8000edc:	4622      	mov	r2, r4
 8000ede:	4668      	mov	r0, sp
 8000ee0:	f00c facf 	bl	800d482 <memcpy>
            p += len;
 8000ee4:	4427      	add	r7, r4
 8000ee6:	e005      	b.n	8000ef4 <oled_show_progress+0x7c>
        } else {
            // repeat same byte
            memset(buf, *p, len);
 8000ee8:	7879      	ldrb	r1, [r7, #1]
 8000eea:	4622      	mov	r2, r4
 8000eec:	4668      	mov	r0, sp
 8000eee:	f00c faee 	bl	800d4ce <memset>
            p++;
 8000ef2:	3702      	adds	r7, #2
        }

        if(!last_line && (offset+len) >= p_start) {
 8000ef4:	f1b8 0f00 	cmp.w	r8, #0
 8000ef8:	d12b      	bne.n	8000f52 <oled_show_progress+0xda>
 8000efa:	1933      	adds	r3, r6, r4
 8000efc:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
 8000f00:	db15      	blt.n	8000f2e <oled_show_progress+0xb6>
            last_line = true;

            // adjust so we're aligned w/ last line
            int h = p_start - offset;
            if(h) {
 8000f02:	f5d6 7860 	rsbs	r8, r6, #896	; 0x380
 8000f06:	d024      	beq.n	8000f52 <oled_show_progress+0xda>
                write_bytes(h, buf);
 8000f08:	4669      	mov	r1, sp
 8000f0a:	4640      	mov	r0, r8
                memmove(buf, buf+h, len-h);
 8000f0c:	ebc8 0404 	rsb	r4, r8, r4
            last_line = true;

            // adjust so we're aligned w/ last line
            int h = p_start - offset;
            if(h) {
                write_bytes(h, buf);
 8000f10:	f7ff fe64 	bl	8000bdc <write_bytes>
                memmove(buf, buf+h, len-h);
 8000f14:	4622      	mov	r2, r4
 8000f16:	eb0d 0108 	add.w	r1, sp, r8
 8000f1a:	4668      	mov	r0, sp
 8000f1c:	f00c fabc 	bl	800d498 <memmove>
                len -= h;
 8000f20:	b2e4      	uxtb	r4, r4
                offset += h;
 8000f22:	f44f 7660 	mov.w	r6, #896	; 0x380
 8000f26:	e014      	b.n	8000f52 <oled_show_progress+0xda>
 8000f28:	4615      	mov	r5, r2
 8000f2a:	f04f 0801 	mov.w	r8, #1
            for(int j=0; (p_count > 0) && (j<len); j++, p_count--) {
                buf[j] |= 0x80;
            }
        }

        write_bytes(len, buf);
 8000f2e:	4669      	mov	r1, sp
 8000f30:	4620      	mov	r0, r4
        offset += len;
 8000f32:	4426      	add	r6, r4
            for(int j=0; (p_count > 0) && (j<len); j++, p_count--) {
                buf[j] |= 0x80;
            }
        }

        write_bytes(len, buf);
 8000f34:	f7ff fe52 	bl	8000bdc <write_bytes>
        offset += len;
 8000f38:	b2b6      	uxth	r6, r6
    }
 8000f3a:	e7c7      	b.n	8000ecc <oled_show_progress+0x54>

    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000f3c:	2201      	movs	r2, #1
 8000f3e:	2110      	movs	r1, #16
 8000f40:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000f44:	f000 f9b8 	bl	80012b8 <HAL_GPIO_WritePin>
    rng_delay();
 8000f48:	f001 fbf9 	bl	800273e <rng_delay>
}
 8000f4c:	b020      	add	sp, #128	; 0x80
 8000f4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

    uint8_t         buf[127];
    const uint8_t *p = pixels;

    const uint16_t p_start = 896;
    uint32_t p_count = 1280 * progress / 1000;
 8000f52:	2300      	movs	r3, #0
                offset += h;
            }
        }

        if(last_line) {
            for(int j=0; (p_count > 0) && (j<len); j++, p_count--) {
 8000f54:	42ab      	cmp	r3, r5
 8000f56:	eba5 0203 	sub.w	r2, r5, r3
 8000f5a:	d009      	beq.n	8000f70 <oled_show_progress+0xf8>
 8000f5c:	42a3      	cmp	r3, r4
 8000f5e:	dae3      	bge.n	8000f28 <oled_show_progress+0xb0>
                buf[j] |= 0x80;
 8000f60:	f81d 2003 	ldrb.w	r2, [sp, r3]
 8000f64:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8000f68:	f80d 2003 	strb.w	r2, [sp, r3]
                offset += h;
            }
        }

        if(last_line) {
            for(int j=0; (p_count > 0) && (j<len); j++, p_count--) {
 8000f6c:	3301      	adds	r3, #1
 8000f6e:	e7f1      	b.n	8000f54 <oled_show_progress+0xdc>
 8000f70:	f04f 0801 	mov.w	r8, #1
 8000f74:	2500      	movs	r5, #0
 8000f76:	e7da      	b.n	8000f2e <oled_show_progress+0xb6>
 8000f78:	0800d5fc 	.word	0x0800d5fc

08000f7c <oled_factory_busy>:

// oled_factory_busy()
//
    void
oled_factory_busy(void)
{
 8000f7c:	b510      	push	{r4, lr}
    };
    uint8_t data[128];

    for(int x=0; x<128; x++) {
        // each byte here is a vertical column, 8 pixels tall, MSB at bottom
        data[x] = (1<<(7 - (x%8)));
 8000f7e:	2201      	movs	r2, #1

// oled_factory_busy()
//
    void
oled_factory_busy(void)
{
 8000f80:	b0a0      	sub	sp, #128	; 0x80
            0, 0xff,        // placeholders
        0x2f                // start
    };
    uint8_t data[128];

    for(int x=0; x<128; x++) {
 8000f82:	2400      	movs	r4, #0
        // each byte here is a vertical column, 8 pixels tall, MSB at bottom
        data[x] = (1<<(7 - (x%8)));
 8000f84:	f004 0307 	and.w	r3, r4, #7
 8000f88:	f1c3 0307 	rsb	r3, r3, #7
 8000f8c:	fa02 f303 	lsl.w	r3, r2, r3
 8000f90:	f80d 3004 	strb.w	r3, [sp, r4]
            0, 0xff,        // placeholders
        0x2f                // start
    };
    uint8_t data[128];

    for(int x=0; x<128; x++) {
 8000f94:	3401      	adds	r4, #1
 8000f96:	2c80      	cmp	r4, #128	; 0x80
 8000f98:	d1f4      	bne.n	8000f84 <oled_factory_busy+0x8>
        // each byte here is a vertical column, 8 pixels tall, MSB at bottom
        data[x] = (1<<(7 - (x%8)));
    }

    oled_write_cmd_sequence(sizeof(setup), setup);
 8000f9a:	4907      	ldr	r1, [pc, #28]	; (8000fb8 <oled_factory_busy+0x3c>)
 8000f9c:	2006      	movs	r0, #6
 8000f9e:	f7ff fe48 	bl	8000c32 <oled_write_cmd_sequence>
    oled_write_data(sizeof(data), data);
 8000fa2:	4669      	mov	r1, sp
 8000fa4:	4620      	mov	r0, r4
 8000fa6:	f7ff fe51 	bl	8000c4c <oled_write_data>
    oled_write_cmd_sequence(sizeof(animate), animate);
 8000faa:	4904      	ldr	r1, [pc, #16]	; (8000fbc <oled_factory_busy+0x40>)
 8000fac:	2009      	movs	r0, #9
 8000fae:	f7ff fe40 	bl	8000c32 <oled_write_cmd_sequence>
}
 8000fb2:	b020      	add	sp, #128	; 0x80
 8000fb4:	bd10      	pop	{r4, pc}
 8000fb6:	bf00      	nop
 8000fb8:	0800d602 	.word	0x0800d602
 8000fbc:	0800d608 	.word	0x0800d608

08000fc0 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000fc0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8000fc4:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 8001170 <HAL_GPIO_Init+0x1b0>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000fc8:	680b      	ldr	r3, [r1, #0]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000fca:	f8df c1a8 	ldr.w	ip, [pc, #424]	; 8001174 <HAL_GPIO_Init+0x1b4>
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000fce:	b085      	sub	sp, #20
 8000fd0:	4644      	mov	r4, r8
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000fd2:	9301      	str	r3, [sp, #4]
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
  uint32_t position = 0x00;
 8000fd4:	2300      	movs	r3, #0
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000fd6:	9a01      	ldr	r2, [sp, #4]
 8000fd8:	40da      	lsrs	r2, r3
 8000fda:	f000 80c3 	beq.w	8001164 <HAL_GPIO_Init+0x1a4>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 8000fde:	f04f 0e01 	mov.w	lr, #1

    if(iocurrent)
 8000fe2:	9a01      	ldr	r2, [sp, #4]

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 8000fe4:	fa0e fe03 	lsl.w	lr, lr, r3

    if(iocurrent)
 8000fe8:	ea12 060e 	ands.w	r6, r2, lr
 8000fec:	f000 80b8 	beq.w	8001160 <HAL_GPIO_Init+0x1a0>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000ff0:	684a      	ldr	r2, [r1, #4]
 8000ff2:	f022 0910 	bic.w	r9, r2, #16
 8000ff6:	f1b9 0f02 	cmp.w	r9, #2
 8000ffa:	d114      	bne.n	8001026 <HAL_GPIO_Init+0x66>
 8000ffc:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 8001000:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8001004:	f003 0b07 	and.w	fp, r3, #7
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 8001008:	f8da 7020 	ldr.w	r7, [sl, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 800100c:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 8001010:	250f      	movs	r5, #15
 8001012:	fa05 f50b 	lsl.w	r5, r5, fp
 8001016:	ea27 0505 	bic.w	r5, r7, r5
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 800101a:	690f      	ldr	r7, [r1, #16]
 800101c:	fa07 f70b 	lsl.w	r7, r7, fp
 8001020:	432f      	orrs	r7, r5
        GPIOx->AFR[position >> 3] = temp;
 8001022:	f8ca 7020 	str.w	r7, [sl, #32]
 8001026:	ea4f 0a43 	mov.w	sl, r3, lsl #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 800102a:	2503      	movs	r5, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800102c:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 800102e:	fa05 f50a 	lsl.w	r5, r5, sl
 8001032:	43ed      	mvns	r5, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8001034:	f002 0b03 	and.w	fp, r2, #3
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 8001038:	402f      	ands	r7, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 800103a:	fa0b fb0a 	lsl.w	fp, fp, sl
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800103e:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8001042:	ea4b 0707 	orr.w	r7, fp, r7
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001046:	f1b9 0f01 	cmp.w	r9, #1

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
      GPIOx->MODER = temp;
 800104a:	6007      	str	r7, [r0, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800104c:	d811      	bhi.n	8001072 <HAL_GPIO_Init+0xb2>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 800104e:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2));
 8001050:	ea05 0907 	and.w	r9, r5, r7
        temp |= (GPIO_Init->Speed << (position * 2));
 8001054:	68cf      	ldr	r7, [r1, #12]
 8001056:	fa07 f70a 	lsl.w	r7, r7, sl
 800105a:	ea47 0709 	orr.w	r7, r7, r9
        GPIOx->OSPEEDR = temp;
 800105e:	6087      	str	r7, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8001060:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8001062:	ea27 0e0e 	bic.w	lr, r7, lr
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8001066:	f3c2 1700 	ubfx	r7, r2, #4, #1
 800106a:	409f      	lsls	r7, r3
 800106c:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OTYPER = temp;
 8001070:	6047      	str	r7, [r0, #4]
      }

#endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx */

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8001072:	68c7      	ldr	r7, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2));
 8001074:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8001076:	688f      	ldr	r7, [r1, #8]
 8001078:	fa07 f70a 	lsl.w	r7, r7, sl
 800107c:	433d      	orrs	r5, r7
      GPIOx->PUPDR = temp;
 800107e:	60c5      	str	r5, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001080:	00d5      	lsls	r5, r2, #3
 8001082:	d56d      	bpl.n	8001160 <HAL_GPIO_Init+0x1a0>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001084:	f8dc 5060 	ldr.w	r5, [ip, #96]	; 0x60
 8001088:	f045 0501 	orr.w	r5, r5, #1
 800108c:	f8cc 5060 	str.w	r5, [ip, #96]	; 0x60
 8001090:	f8dc 5060 	ldr.w	r5, [ip, #96]	; 0x60
 8001094:	f023 0703 	bic.w	r7, r3, #3
 8001098:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 800109c:	f005 0501 	and.w	r5, r5, #1
 80010a0:	f507 3780 	add.w	r7, r7, #65536	; 0x10000
 80010a4:	9503      	str	r5, [sp, #12]

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80010a6:	f003 0903 	and.w	r9, r3, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80010aa:	9d03      	ldr	r5, [sp, #12]

        temp = SYSCFG->EXTICR[position >> 2];
 80010ac:	f8d7 a008 	ldr.w	sl, [r7, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80010b0:	f04f 0e0f 	mov.w	lr, #15
 80010b4:	ea4f 0989 	mov.w	r9, r9, lsl #2
 80010b8:	fa0e f509 	lsl.w	r5, lr, r9
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
 80010bc:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80010c0:	ea2a 0e05 	bic.w	lr, sl, r5
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
 80010c4:	d01d      	beq.n	8001102 <HAL_GPIO_Init+0x142>
 80010c6:	4d29      	ldr	r5, [pc, #164]	; (800116c <HAL_GPIO_Init+0x1ac>)
 80010c8:	42a8      	cmp	r0, r5
 80010ca:	d01c      	beq.n	8001106 <HAL_GPIO_Init+0x146>
 80010cc:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80010d0:	42a8      	cmp	r0, r5
 80010d2:	d01a      	beq.n	800110a <HAL_GPIO_Init+0x14a>
 80010d4:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80010d8:	42a8      	cmp	r0, r5
 80010da:	d018      	beq.n	800110e <HAL_GPIO_Init+0x14e>
 80010dc:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80010e0:	42a8      	cmp	r0, r5
 80010e2:	d016      	beq.n	8001112 <HAL_GPIO_Init+0x152>
 80010e4:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80010e8:	42a8      	cmp	r0, r5
 80010ea:	d014      	beq.n	8001116 <HAL_GPIO_Init+0x156>
 80010ec:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80010f0:	42a8      	cmp	r0, r5
 80010f2:	d012      	beq.n	800111a <HAL_GPIO_Init+0x15a>
 80010f4:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80010f8:	42a8      	cmp	r0, r5
 80010fa:	bf14      	ite	ne
 80010fc:	2508      	movne	r5, #8
 80010fe:	2507      	moveq	r5, #7
 8001100:	e00c      	b.n	800111c <HAL_GPIO_Init+0x15c>
 8001102:	2500      	movs	r5, #0
 8001104:	e00a      	b.n	800111c <HAL_GPIO_Init+0x15c>
 8001106:	2501      	movs	r5, #1
 8001108:	e008      	b.n	800111c <HAL_GPIO_Init+0x15c>
 800110a:	2502      	movs	r5, #2
 800110c:	e006      	b.n	800111c <HAL_GPIO_Init+0x15c>
 800110e:	2503      	movs	r5, #3
 8001110:	e004      	b.n	800111c <HAL_GPIO_Init+0x15c>
 8001112:	2504      	movs	r5, #4
 8001114:	e002      	b.n	800111c <HAL_GPIO_Init+0x15c>
 8001116:	2505      	movs	r5, #5
 8001118:	e000      	b.n	800111c <HAL_GPIO_Init+0x15c>
 800111a:	2506      	movs	r5, #6
 800111c:	fa05 f509 	lsl.w	r5, r5, r9
 8001120:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2] = temp;
 8001124:	60bd      	str	r5, [r7, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8001126:	f8d8 5000 	ldr.w	r5, [r8]
        temp &= ~((uint32_t)iocurrent);
 800112a:	43f7      	mvns	r7, r6
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800112c:	f412 3f80 	tst.w	r2, #65536	; 0x10000
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
        temp &= ~((uint32_t)iocurrent);
 8001130:	bf0c      	ite	eq
 8001132:	403d      	andeq	r5, r7
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
 8001134:	4335      	orrne	r5, r6
        }
        EXTI->IMR1 = temp;
 8001136:	6025      	str	r5, [r4, #0]

        temp = EXTI->EMR1;
 8001138:	6865      	ldr	r5, [r4, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800113a:	f412 3f00 	tst.w	r2, #131072	; 0x20000
          temp |= iocurrent;
        }
        EXTI->IMR1 = temp;

        temp = EXTI->EMR1;
        temp &= ~((uint32_t)iocurrent);
 800113e:	bf0c      	ite	eq
 8001140:	403d      	andeq	r5, r7
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
 8001142:	4335      	orrne	r5, r6
        }
        EXTI->EMR1 = temp;
 8001144:	6065      	str	r5, [r4, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8001146:	68a5      	ldr	r5, [r4, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001148:	f412 1f80 	tst.w	r2, #1048576	; 0x100000
        }
        EXTI->EMR1 = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
        temp &= ~((uint32_t)iocurrent);
 800114c:	bf0c      	ite	eq
 800114e:	403d      	andeq	r5, r7
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
 8001150:	4335      	orrne	r5, r6
        }
        EXTI->RTSR1 = temp;
 8001152:	60a5      	str	r5, [r4, #8]

        temp = EXTI->FTSR1;
 8001154:	68e5      	ldr	r5, [r4, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001156:	0292      	lsls	r2, r2, #10
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;

        temp = EXTI->FTSR1;
        temp &= ~((uint32_t)iocurrent);
 8001158:	bf54      	ite	pl
 800115a:	403d      	andpl	r5, r7
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
 800115c:	4335      	orrmi	r5, r6
        }
        EXTI->FTSR1 = temp;
 800115e:	60e5      	str	r5, [r4, #12]
      }
    }

    position++;
 8001160:	3301      	adds	r3, #1
 8001162:	e738      	b.n	8000fd6 <HAL_GPIO_Init+0x16>
  }
}
 8001164:	b005      	add	sp, #20
 8001166:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800116a:	bf00      	nop
 800116c:	48000400 	.word	0x48000400
 8001170:	40010400 	.word	0x40010400
 8001174:	40021000 	.word	0x40021000

08001178 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 8001178:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      {
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
        SYSCFG->EXTICR[position >> 2] &= ~tmp;

        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~((uint32_t)iocurrent);
 800117c:	4c47      	ldr	r4, [pc, #284]	; (800129c <HAL_GPIO_DeInit+0x124>)
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 800117e:	f8df a124 	ldr.w	sl, [pc, #292]	; 80012a4 <HAL_GPIO_DeInit+0x12c>
 8001182:	f8df b124 	ldr.w	fp, [pc, #292]	; 80012a8 <HAL_GPIO_DeInit+0x130>
  *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
  uint32_t position = 0x00;
 8001186:	2200      	movs	r2, #0

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & (1U << position);
 8001188:	f04f 0901 	mov.w	r9, #1
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
 800118c:	fa31 f302 	lsrs.w	r3, r1, r2
 8001190:	f000 8081 	beq.w	8001296 <HAL_GPIO_DeInit+0x11e>
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & (1U << position);
 8001194:	fa09 f802 	lsl.w	r8, r9, r2

    if (iocurrent)
 8001198:	ea11 0608 	ands.w	r6, r1, r8
 800119c:	d079      	beq.n	8001292 <HAL_GPIO_DeInit+0x11a>
    {
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2));
 800119e:	6807      	ldr	r7, [r0, #0]
 80011a0:	2303      	movs	r3, #3
 80011a2:	0055      	lsls	r5, r2, #1
 80011a4:	fa03 f505 	lsl.w	r5, r3, r5
 80011a8:	fa22 fc03 	lsr.w	ip, r2, r3
 80011ac:	432f      	orrs	r7, r5
 80011ae:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
 80011b2:	6007      	str	r7, [r0, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 80011b4:	f8dc 7020 	ldr.w	r7, [ip, #32]
 80011b8:	f002 0e07 	and.w	lr, r2, #7
 80011bc:	463b      	mov	r3, r7
 80011be:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 80011c2:	270f      	movs	r7, #15
 80011c4:	fa07 fe0e 	lsl.w	lr, r7, lr
 80011c8:	ea23 0e0e 	bic.w	lr, r3, lr
 80011cc:	f8cc e020 	str.w	lr, [ip, #32]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2));
 80011d0:	f8d0 e008 	ldr.w	lr, [r0, #8]
 80011d4:	43ed      	mvns	r5, r5
 80011d6:	ea0e 0e05 	and.w	lr, lr, r5
 80011da:	f8c0 e008 	str.w	lr, [r0, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
 80011de:	f8d0 e004 	ldr.w	lr, [r0, #4]
 80011e2:	ea2e 0808 	bic.w	r8, lr, r8
 80011e6:	f8c0 8004 	str.w	r8, [r0, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2));
 80011ea:	f8d0 e00c 	ldr.w	lr, [r0, #12]
 80011ee:	ea05 050e 	and.w	r5, r5, lr
 80011f2:	60c5      	str	r5, [r0, #12]
 80011f4:	f022 0503 	bic.w	r5, r2, #3
 80011f8:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 80011fc:	f505 3580 	add.w	r5, r5, #65536	; 0x10000

      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001200:	f002 0e03 	and.w	lr, r2, #3
#endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx */

      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = SYSCFG->EXTICR[position >> 2];
 8001204:	f8d5 c008 	ldr.w	ip, [r5, #8]
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001208:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 800120c:	fa07 f70e 	lsl.w	r7, r7, lr
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 8001210:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000

      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001214:	ea0c 0c07 	and.w	ip, ip, r7
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 8001218:	d019      	beq.n	800124e <HAL_GPIO_DeInit+0xd6>
 800121a:	4b21      	ldr	r3, [pc, #132]	; (80012a0 <HAL_GPIO_DeInit+0x128>)
 800121c:	4298      	cmp	r0, r3
 800121e:	d018      	beq.n	8001252 <HAL_GPIO_DeInit+0xda>
 8001220:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001224:	4298      	cmp	r0, r3
 8001226:	d016      	beq.n	8001256 <HAL_GPIO_DeInit+0xde>
 8001228:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800122c:	4298      	cmp	r0, r3
 800122e:	d014      	beq.n	800125a <HAL_GPIO_DeInit+0xe2>
 8001230:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001234:	4298      	cmp	r0, r3
 8001236:	d012      	beq.n	800125e <HAL_GPIO_DeInit+0xe6>
 8001238:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800123c:	4298      	cmp	r0, r3
 800123e:	d010      	beq.n	8001262 <HAL_GPIO_DeInit+0xea>
 8001240:	4550      	cmp	r0, sl
 8001242:	d010      	beq.n	8001266 <HAL_GPIO_DeInit+0xee>
 8001244:	4558      	cmp	r0, fp
 8001246:	bf0c      	ite	eq
 8001248:	2307      	moveq	r3, #7
 800124a:	2308      	movne	r3, #8
 800124c:	e00c      	b.n	8001268 <HAL_GPIO_DeInit+0xf0>
 800124e:	2300      	movs	r3, #0
 8001250:	e00a      	b.n	8001268 <HAL_GPIO_DeInit+0xf0>
 8001252:	2301      	movs	r3, #1
 8001254:	e008      	b.n	8001268 <HAL_GPIO_DeInit+0xf0>
 8001256:	2302      	movs	r3, #2
 8001258:	e006      	b.n	8001268 <HAL_GPIO_DeInit+0xf0>
 800125a:	2303      	movs	r3, #3
 800125c:	e004      	b.n	8001268 <HAL_GPIO_DeInit+0xf0>
 800125e:	2304      	movs	r3, #4
 8001260:	e002      	b.n	8001268 <HAL_GPIO_DeInit+0xf0>
 8001262:	2305      	movs	r3, #5
 8001264:	e000      	b.n	8001268 <HAL_GPIO_DeInit+0xf0>
 8001266:	2306      	movs	r3, #6
 8001268:	fa03 f30e 	lsl.w	r3, r3, lr
 800126c:	459c      	cmp	ip, r3
 800126e:	d110      	bne.n	8001292 <HAL_GPIO_DeInit+0x11a>
      {
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
        SYSCFG->EXTICR[position >> 2] &= ~tmp;
 8001270:	68ab      	ldr	r3, [r5, #8]
 8001272:	ea23 0707 	bic.w	r7, r3, r7
 8001276:	60af      	str	r7, [r5, #8]

        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~((uint32_t)iocurrent);
 8001278:	6823      	ldr	r3, [r4, #0]
 800127a:	43f6      	mvns	r6, r6
 800127c:	4033      	ands	r3, r6
 800127e:	6023      	str	r3, [r4, #0]
        EXTI->EMR1 &= ~((uint32_t)iocurrent);
 8001280:	6863      	ldr	r3, [r4, #4]
 8001282:	4033      	ands	r3, r6
 8001284:	6063      	str	r3, [r4, #4]

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR1 &= ~((uint32_t)iocurrent);
 8001286:	68a3      	ldr	r3, [r4, #8]
 8001288:	4033      	ands	r3, r6
 800128a:	60a3      	str	r3, [r4, #8]
        EXTI->FTSR1 &= ~((uint32_t)iocurrent);
 800128c:	68e3      	ldr	r3, [r4, #12]
 800128e:	401e      	ands	r6, r3
 8001290:	60e6      	str	r6, [r4, #12]
      }
    }

    position++;
 8001292:	3201      	adds	r2, #1
 8001294:	e77a      	b.n	800118c <HAL_GPIO_DeInit+0x14>
  }
}
 8001296:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800129a:	bf00      	nop
 800129c:	40010400 	.word	0x40010400
 80012a0:	48000400 	.word	0x48000400
 80012a4:	48001800 	.word	0x48001800
 80012a8:	48001c00 	.word	0x48001c00

080012ac <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 80012ac:	6903      	ldr	r3, [r0, #16]
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
 80012ae:	4219      	tst	r1, r3
}
 80012b0:	bf14      	ite	ne
 80012b2:	2001      	movne	r0, #1
 80012b4:	2000      	moveq	r0, #0
 80012b6:	4770      	bx	lr

080012b8 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 80012b8:	b10a      	cbz	r2, 80012be <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 80012ba:	6181      	str	r1, [r0, #24]
 80012bc:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 80012be:	6281      	str	r1, [r0, #40]	; 0x28
 80012c0:	4770      	bx	lr

080012c2 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 80012c2:	6943      	ldr	r3, [r0, #20]
 80012c4:	4059      	eors	r1, r3
 80012c6:	6141      	str	r1, [r0, #20]
 80012c8:	4770      	bx	lr

080012ca <HAL_GPIO_LockPin>:
  * @param  GPIO_Pin: specifies the port bits to be locked.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 80012ca:	b082      	sub	sp, #8
  __IO uint32_t tmp = GPIO_LCKR_LCKK;
 80012cc:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80012d0:	9301      	str	r3, [sp, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Apply lock key write sequence */
  tmp |= GPIO_Pin;
 80012d2:	9b01      	ldr	r3, [sp, #4]
 80012d4:	430b      	orrs	r3, r1
 80012d6:	9301      	str	r3, [sp, #4]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
 80012d8:	9b01      	ldr	r3, [sp, #4]
 80012da:	61c3      	str	r3, [r0, #28]
  /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
  GPIOx->LCKR = GPIO_Pin;
 80012dc:	61c1      	str	r1, [r0, #28]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
 80012de:	9b01      	ldr	r3, [sp, #4]
 80012e0:	61c3      	str	r3, [r0, #28]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 80012e2:	69c3      	ldr	r3, [r0, #28]
 80012e4:	9301      	str	r3, [sp, #4]

  if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)
 80012e6:	69c0      	ldr	r0, [r0, #28]
 80012e8:	f480 3080 	eor.w	r0, r0, #65536	; 0x10000
  }
  else
  {
    return HAL_ERROR;
  }
}
 80012ec:	f3c0 4000 	ubfx	r0, r0, #16, #1
 80012f0:	b002      	add	sp, #8
 80012f2:	4770      	bx	lr

080012f4 <HAL_GPIO_EXTI_Callback>:
  * @brief  EXTI line detection callback.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
 80012f4:	4770      	bx	lr
	...

080012f8 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 80012f8:	b508      	push	{r3, lr}
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
 80012fa:	4b04      	ldr	r3, [pc, #16]	; (800130c <HAL_GPIO_EXTI_IRQHandler+0x14>)
 80012fc:	6959      	ldr	r1, [r3, #20]
 80012fe:	4201      	tst	r1, r0
 8001300:	d002      	beq.n	8001308 <HAL_GPIO_EXTI_IRQHandler+0x10>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8001302:	6158      	str	r0, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8001304:	f7ff fff6 	bl	80012f4 <HAL_GPIO_EXTI_Callback>
 8001308:	bd08      	pop	{r3, pc}
 800130a:	bf00      	nop
 800130c:	40010400 	.word	0x40010400

08001310 <SPI_WaitFlagStateUntilTimeout.isra.1>:
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8001310:	6800      	ldr	r0, [r0, #0]
 8001312:	6883      	ldr	r3, [r0, #8]
 8001314:	ea31 0303 	bics.w	r3, r1, r3
 8001318:	bf0c      	ite	eq
 800131a:	2301      	moveq	r3, #1
 800131c:	2300      	movne	r3, #0
 800131e:	429a      	cmp	r2, r3
 8001320:	d1f7      	bne.n	8001312 <SPI_WaitFlagStateUntilTimeout.isra.1+0x2>
    }
#endif
  }

  return HAL_OK;
}
 8001322:	2000      	movs	r0, #0
 8001324:	4770      	bx	lr

08001326 <SPI_EndRxTxTransaction.isra.2>:
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
  __IO uint8_t tmpreg;

  while ((hspi->Instance->SR & Fifo) != State)
 8001326:	6803      	ldr	r3, [r0, #0]
  * @param  hspi: SPI handle
  * @param  Timeout: Timeout duration
  * @param  Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
 8001328:	b513      	push	{r0, r1, r4, lr}
 800132a:	4604      	mov	r4, r0
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
  __IO uint8_t tmpreg;

  while ((hspi->Instance->SR & Fifo) != State)
 800132c:	689a      	ldr	r2, [r3, #8]
 800132e:	f412 52c0 	ands.w	r2, r2, #6144	; 0x1800
 8001332:	d1fb      	bne.n	800132c <SPI_EndRxTxTransaction.isra.2+0x6>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }
  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8001334:	2180      	movs	r1, #128	; 0x80
 8001336:	4620      	mov	r0, r4
 8001338:	f7ff ffea 	bl	8001310 <SPI_WaitFlagStateUntilTimeout.isra.1>
 800133c:	b908      	cbnz	r0, 8001342 <SPI_EndRxTxTransaction.isra.2+0x1c>
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
  __IO uint8_t tmpreg;

  while ((hspi->Instance->SR & Fifo) != State)
 800133e:	6822      	ldr	r2, [r4, #0]
 8001340:	e005      	b.n	800134e <SPI_EndRxTxTransaction.isra.2+0x28>
    return HAL_TIMEOUT;
  }
  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8001342:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8001344:	f043 0320 	orr.w	r3, r3, #32
 8001348:	6623      	str	r3, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 800134a:	2003      	movs	r0, #3
 800134c:	e00a      	b.n	8001364 <SPI_EndRxTxTransaction.isra.2+0x3e>
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
  __IO uint8_t tmpreg;

  while ((hspi->Instance->SR & Fifo) != State)
 800134e:	6893      	ldr	r3, [r2, #8]
 8001350:	f413 6fc0 	tst.w	r3, #1536	; 0x600
 8001354:	d006      	beq.n	8001364 <SPI_EndRxTxTransaction.isra.2+0x3e>
  {
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
    {
      tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 8001356:	7b13      	ldrb	r3, [r2, #12]
 8001358:	b2db      	uxtb	r3, r3
 800135a:	f88d 3007 	strb.w	r3, [sp, #7]
      /* To avoid GCC warning */
      UNUSED(tmpreg);
 800135e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8001362:	e7f4      	b.n	800134e <SPI_EndRxTxTransaction.isra.2+0x28>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }
  return HAL_OK;
}
 8001364:	b002      	add	sp, #8
 8001366:	bd10      	pop	{r4, pc}

08001368 <HAL_SPI_Init>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 8001368:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
 800136a:	2800      	cmp	r0, #0
 800136c:	d054      	beq.n	8001418 <HAL_SPI_Init+0xb0>
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 800136e:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
 8001372:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001376:	b90b      	cbnz	r3, 800137c <HAL_SPI_Init+0x14>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 8001378:	f880 205c 	strb.w	r2, [r0, #92]	; 0x5c

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
//PDG//    HAL_SPI_MspInit(hspi);
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 800137c:	2302      	movs	r3, #2

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 800137e:	6801      	ldr	r1, [r0, #0]

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
//PDG//    HAL_SPI_MspInit(hspi);
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 8001380:	f880 305d 	strb.w	r3, [r0, #93]	; 0x5d

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001384:	680b      	ldr	r3, [r1, #0]

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8001386:	68c5      	ldr	r5, [r0, #12]
  }

  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001388:	f023 0340 	bic.w	r3, r3, #64	; 0x40

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800138c:	f5b5 6fe0 	cmp.w	r5, #1792	; 0x700
  }

  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001390:	600b      	str	r3, [r1, #0]
 8001392:	f04f 0300 	mov.w	r3, #0

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8001396:	d903      	bls.n	80013a0 <HAL_SPI_Init+0x38>
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 8001398:	461c      	mov	r4, r3
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
  }

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 800139a:	f5b5 6f70 	cmp.w	r5, #3840	; 0xf00
 800139e:	e001      	b.n	80013a4 <HAL_SPI_Init+0x3c>
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
  }
  else
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 80013a0:	f44f 5480 	mov.w	r4, #4096	; 0x1000

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
  {
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80013a4:	bf18      	it	ne
 80013a6:	6283      	strne	r3, [r0, #40]	; 0x28
  }

  /* Align the CRC Length on the data size */
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 80013a8:	6b03      	ldr	r3, [r0, #48]	; 0x30
 80013aa:	b92b      	cbnz	r3, 80013b8 <HAL_SPI_Init+0x50>
  {
    /* CRC Length aligned on the data size : value set by default */
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80013ac:	f5b5 6fe0 	cmp.w	r5, #1792	; 0x700
    {
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
 80013b0:	bf8c      	ite	hi
 80013b2:	2302      	movhi	r3, #2
    }
    else
    {
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 80013b4:	2301      	movls	r3, #1
 80013b6:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 80013b8:	6882      	ldr	r2, [r0, #8]
 80013ba:	6847      	ldr	r7, [r0, #4]
 80013bc:	6983      	ldr	r3, [r0, #24]
 80013be:	6a86      	ldr	r6, [r0, #40]	; 0x28
 80013c0:	4317      	orrs	r7, r2
 80013c2:	6902      	ldr	r2, [r0, #16]
 80013c4:	4317      	orrs	r7, r2
 80013c6:	6942      	ldr	r2, [r0, #20]
 80013c8:	4317      	orrs	r7, r2
 80013ca:	69c2      	ldr	r2, [r0, #28]
 80013cc:	4317      	orrs	r7, r2
 80013ce:	6a02      	ldr	r2, [r0, #32]
 80013d0:	433a      	orrs	r2, r7
 80013d2:	4332      	orrs	r2, r6
 80013d4:	f403 7700 	and.w	r7, r3, #512	; 0x200
 80013d8:	433a      	orrs	r2, r7
 80013da:	600a      	str	r2, [r1, #0]
                                  hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                                  hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation));
#if (USE_SPI_CRC != 0U)
  /* Configure : CRC Length */
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 80013dc:	6b02      	ldr	r2, [r0, #48]	; 0x30
 80013de:	2a02      	cmp	r2, #2
  {
    hspi->Instance->CR1 |= SPI_CR1_CRCL;
 80013e0:	bf02      	ittt	eq
 80013e2:	680a      	ldreq	r2, [r1, #0]
 80013e4:	f442 6200 	orreq.w	r2, r2, #2048	; 0x800
 80013e8:	600a      	streq	r2, [r1, #0]
  }
#endif /* USE_SPI_CRC */

  /* Configure : NSS management, TI Mode, NSS Pulse, Data size and Rx Fifo Threshold */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 80013ea:	6a42      	ldr	r2, [r0, #36]	; 0x24
 80013ec:	4315      	orrs	r5, r2
 80013ee:	6b42      	ldr	r2, [r0, #52]	; 0x34
 80013f0:	0c1b      	lsrs	r3, r3, #16
 80013f2:	4315      	orrs	r5, r2
 80013f4:	f003 0204 	and.w	r2, r3, #4
 80013f8:	ea45 0302 	orr.w	r3, r5, r2
 80013fc:	4323      	orrs	r3, r4
                                  hspi->Init.NSSPMode | hspi->Init.DataSize) | frxth);

#if (USE_SPI_CRC != 0U)
  /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
  /* Configure : CRC Polynomial */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80013fe:	f5b6 5f00 	cmp.w	r6, #8192	; 0x2000
    hspi->Instance->CR1 |= SPI_CR1_CRCL;
  }
#endif /* USE_SPI_CRC */

  /* Configure : NSS management, TI Mode, NSS Pulse, Data size and Rx Fifo Threshold */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8001402:	604b      	str	r3, [r1, #4]
#if (USE_SPI_CRC != 0U)
  /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
  /* Configure : CRC Polynomial */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    WRITE_REG(hspi->Instance->CRCPR, hspi->Init.CRCPolynomial);
 8001404:	bf04      	itt	eq
 8001406:	6ac3      	ldreq	r3, [r0, #44]	; 0x2c
 8001408:	610b      	streq	r3, [r1, #16]
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
  hspi->State     = HAL_SPI_STATE_READY;
 800140a:	2201      	movs	r2, #1
#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 800140c:	2300      	movs	r3, #0
 800140e:	6603      	str	r3, [r0, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 8001410:	f880 205d 	strb.w	r2, [r0, #93]	; 0x5d

  return HAL_OK;
 8001414:	4618      	mov	r0, r3
 8001416:	bdf0      	pop	{r4, r5, r6, r7, pc}
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
  {
    return HAL_ERROR;
 8001418:	2001      	movs	r0, #1

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
  hspi->State     = HAL_SPI_STATE_READY;

  return HAL_OK;
}
 800141a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800141c <HAL_SPI_Transmit>:
  * @param  Size: amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800141c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8001420:	461e      	mov	r6, r3

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8001422:	f890 305c 	ldrb.w	r3, [r0, #92]	; 0x5c
 8001426:	2b01      	cmp	r3, #1
  * @param  Size: amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8001428:	4604      	mov	r4, r0
 800142a:	460d      	mov	r5, r1
 800142c:	4690      	mov	r8, r2

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 800142e:	f000 80a1 	beq.w	8001574 <HAL_SPI_Transmit+0x158>
 8001432:	2301      	movs	r3, #1
 8001434:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 8001438:	f005 fdec 	bl	8007014 <HAL_GetTick>
 800143c:	4607      	mov	r7, r0

  if (hspi->State != HAL_SPI_STATE_READY)
 800143e:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
 8001442:	b2c0      	uxtb	r0, r0
 8001444:	2801      	cmp	r0, #1
 8001446:	f040 808d 	bne.w	8001564 <HAL_SPI_Transmit+0x148>
  {
    errorcode = HAL_BUSY;
    goto error;
  }

  if ((pData == NULL) || (Size == 0U))
 800144a:	2d00      	cmp	r5, #0
 800144c:	f000 808b 	beq.w	8001566 <HAL_SPI_Transmit+0x14a>
 8001450:	f1b8 0f00 	cmp.w	r8, #0
 8001454:	f000 8087 	beq.w	8001566 <HAL_SPI_Transmit+0x14a>
    errorcode = HAL_ERROR;
    goto error;
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8001458:	2303      	movs	r3, #3
 800145a:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  hspi->RxXferCount = 0U;
  hspi->TxISR       = NULL;
  hspi->RxISR       = NULL;

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800145e:	68a3      	ldr	r3, [r4, #8]
 8001460:	6822      	ldr	r2, [r4, #0]
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8001462:	63a5      	str	r5, [r4, #56]	; 0x38
    goto error;
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8001464:	2100      	movs	r1, #0
  hspi->RxXferCount = 0U;
  hspi->TxISR       = NULL;
  hspi->RxISR       = NULL;

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8001466:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    goto error;
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800146a:	6621      	str	r1, [r4, #96]	; 0x60
  hspi->pTxBuffPtr  = (uint8_t *)pData;
  hspi->TxXferSize  = Size;
  hspi->TxXferCount = Size;
 800146c:	f8a4 803e 	strh.w	r8, [r4, #62]	; 0x3e

  /*Init field not used in handle to zero */
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
  hspi->RxXferSize  = 0U;
  hspi->RxXferCount = 0U;
 8001470:	f8a4 1046 	strh.w	r1, [r4, #70]	; 0x46
  hspi->RxISR       = NULL;

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
  {
    SPI_1LINE_TX(hspi);
 8001474:	bf08      	it	eq
 8001476:	6813      	ldreq	r3, [r2, #0]

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pData;
  hspi->TxXferSize  = Size;
 8001478:	f8a4 803c 	strh.w	r8, [r4, #60]	; 0x3c
  hspi->RxISR       = NULL;

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
  {
    SPI_1LINE_TX(hspi);
 800147c:	bf08      	it	eq
 800147e:	f443 4380 	orreq.w	r3, r3, #16384	; 0x4000
  hspi->pTxBuffPtr  = (uint8_t *)pData;
  hspi->TxXferSize  = Size;
  hspi->TxXferCount = Size;

  /*Init field not used in handle to zero */
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8001482:	6421      	str	r1, [r4, #64]	; 0x40
  hspi->RxXferSize  = 0U;
 8001484:	f8a4 1044 	strh.w	r1, [r4, #68]	; 0x44
  hspi->RxXferCount = 0U;
  hspi->TxISR       = NULL;
 8001488:	6521      	str	r1, [r4, #80]	; 0x50
  hspi->RxISR       = NULL;
 800148a:	64e1      	str	r1, [r4, #76]	; 0x4c

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
  {
    SPI_1LINE_TX(hspi);
 800148c:	bf08      	it	eq
 800148e:	6013      	streq	r3, [r2, #0]
  }

#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8001490:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001492:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8001496:	d107      	bne.n	80014a8 <HAL_SPI_Transmit+0x8c>
  {
    SPI_RESET_CRC(hspi);
 8001498:	6813      	ldr	r3, [r2, #0]
 800149a:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800149e:	6013      	str	r3, [r2, #0]
 80014a0:	6813      	ldr	r3, [r2, #0]
 80014a2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80014a6:	6013      	str	r3, [r2, #0]
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80014a8:	6813      	ldr	r3, [r2, #0]
 80014aa:	0659      	lsls	r1, r3, #25
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 80014ac:	bf5e      	ittt	pl
 80014ae:	6813      	ldrpl	r3, [r2, #0]
 80014b0:	f043 0340 	orrpl.w	r3, r3, #64	; 0x40
 80014b4:	6013      	strpl	r3, [r2, #0]
  }
  /* Transmit data in 8 Bit mode */
  else
  {
#endif
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
 80014b6:	6863      	ldr	r3, [r4, #4]
 80014b8:	b11b      	cbz	r3, 80014c2 <HAL_SPI_Transmit+0xa6>
 80014ba:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80014bc:	b29b      	uxth	r3, r3
 80014be:	2b01      	cmp	r3, #1
 80014c0:	d115      	bne.n	80014ee <HAL_SPI_Transmit+0xd2>
    {
      if (hspi->TxXferCount > 1U)
 80014c2:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80014c4:	b29b      	uxth	r3, r3
 80014c6:	2b01      	cmp	r3, #1
 80014c8:	d903      	bls.n	80014d2 <HAL_SPI_Transmit+0xb6>
      {
        /* write on the data register in packing mode */
        hspi->Instance->DR = *((uint16_t *)pData);
 80014ca:	f835 3b02 	ldrh.w	r3, [r5], #2
 80014ce:	60d3      	str	r3, [r2, #12]
 80014d0:	e01b      	b.n	800150a <HAL_SPI_Transmit+0xee>
        pData += sizeof(uint16_t);
        hspi->TxXferCount -= 2U;
      }
      else
      {
        *((__IO uint8_t *)&hspi->Instance->DR) = (*pData++);
 80014d2:	782b      	ldrb	r3, [r5, #0]
 80014d4:	7313      	strb	r3, [r2, #12]
        hspi->TxXferCount--;
 80014d6:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80014d8:	3b01      	subs	r3, #1
 80014da:	b29b      	uxth	r3, r3
 80014dc:	87e3      	strh	r3, [r4, #62]	; 0x3e
 80014de:	e005      	b.n	80014ec <HAL_SPI_Transmit+0xd0>
          pData += sizeof(uint16_t);
          hspi->TxXferCount -= 2U;
        }
        else
        {
          *((__IO uint8_t *)&hspi->Instance->DR) = (*pData++);
 80014e0:	782a      	ldrb	r2, [r5, #0]
 80014e2:	731a      	strb	r2, [r3, #12]
          hspi->TxXferCount--;
 80014e4:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 80014e6:	3a01      	subs	r2, #1
 80014e8:	b292      	uxth	r2, r2
 80014ea:	87e2      	strh	r2, [r4, #62]	; 0x3e
          pData += sizeof(uint16_t);
          hspi->TxXferCount -= 2U;
        }
        else
        {
          *((__IO uint8_t *)&hspi->Instance->DR) = (*pData++);
 80014ec:	3501      	adds	r5, #1
      {
        *((__IO uint8_t *)&hspi->Instance->DR) = (*pData++);
        hspi->TxXferCount--;
      }
    }
    while (hspi->TxXferCount > 0U)
 80014ee:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80014f0:	b29b      	uxth	r3, r3
 80014f2:	b1d3      	cbz	r3, 800152a <HAL_SPI_Transmit+0x10e>
    {
      /* Wait until TXE flag is set to send data */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 80014f4:	6823      	ldr	r3, [r4, #0]
 80014f6:	689a      	ldr	r2, [r3, #8]
 80014f8:	0792      	lsls	r2, r2, #30
 80014fa:	d50b      	bpl.n	8001514 <HAL_SPI_Transmit+0xf8>
      {
        if (hspi->TxXferCount > 1U)
 80014fc:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 80014fe:	b292      	uxth	r2, r2
 8001500:	2a01      	cmp	r2, #1
 8001502:	d9ed      	bls.n	80014e0 <HAL_SPI_Transmit+0xc4>
        {
          /* write on the data register in packing mode */
          hspi->Instance->DR = *((uint16_t *)pData);
 8001504:	f835 2b02 	ldrh.w	r2, [r5], #2
 8001508:	60da      	str	r2, [r3, #12]
          pData += sizeof(uint16_t);
          hspi->TxXferCount -= 2U;
 800150a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800150c:	3b02      	subs	r3, #2
 800150e:	b29b      	uxth	r3, r3
 8001510:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8001512:	e7ec      	b.n	80014ee <HAL_SPI_Transmit+0xd2>
        }
      }
      else
      {
        /* Timeout management */
        if ((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout)))
 8001514:	b90e      	cbnz	r6, 800151a <HAL_SPI_Transmit+0xfe>
        {
          errorcode = HAL_TIMEOUT;
 8001516:	2003      	movs	r0, #3
 8001518:	e025      	b.n	8001566 <HAL_SPI_Transmit+0x14a>
        }
      }
      else
      {
        /* Timeout management */
        if ((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout)))
 800151a:	1c73      	adds	r3, r6, #1
 800151c:	d0e7      	beq.n	80014ee <HAL_SPI_Transmit+0xd2>
 800151e:	f005 fd79 	bl	8007014 <HAL_GetTick>
 8001522:	1bc0      	subs	r0, r0, r7
 8001524:	4286      	cmp	r6, r0
 8001526:	d8e2      	bhi.n	80014ee <HAL_SPI_Transmit+0xd2>
 8001528:	e7f5      	b.n	8001516 <HAL_SPI_Transmit+0xfa>
      }
    }
//  }
#if (USE_SPI_CRC != 0U)
  /* Enable CRC Transmission */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800152a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800152c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
  {
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 8001530:	bf01      	itttt	eq
 8001532:	6822      	ldreq	r2, [r4, #0]
 8001534:	6813      	ldreq	r3, [r2, #0]
 8001536:	f443 5380 	orreq.w	r3, r3, #4096	; 0x1000
 800153a:	6013      	streq	r3, [r2, #0]
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 800153c:	4620      	mov	r0, r4
 800153e:	f7ff fef2 	bl	8001326 <SPI_EndRxTxTransaction.isra.2>
 8001542:	b108      	cbz	r0, 8001548 <HAL_SPI_Transmit+0x12c>
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8001544:	2320      	movs	r3, #32
 8001546:	6623      	str	r3, [r4, #96]	; 0x60
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8001548:	68a3      	ldr	r3, [r4, #8]
 800154a:	b933      	cbnz	r3, 800155a <HAL_SPI_Transmit+0x13e>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 800154c:	9301      	str	r3, [sp, #4]
 800154e:	6823      	ldr	r3, [r4, #0]
 8001550:	68da      	ldr	r2, [r3, #12]
 8001552:	9201      	str	r2, [sp, #4]
 8001554:	689b      	ldr	r3, [r3, #8]
 8001556:	9301      	str	r3, [sp, #4]
 8001558:	9b01      	ldr	r3, [sp, #4]
  }

  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 800155a:	6e20      	ldr	r0, [r4, #96]	; 0x60
  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();

  if (hspi->State != HAL_SPI_STATE_READY)
  {
    errorcode = HAL_BUSY;
 800155c:	3000      	adds	r0, #0
 800155e:	bf18      	it	ne
 8001560:	2001      	movne	r0, #1
 8001562:	e000      	b.n	8001566 <HAL_SPI_Transmit+0x14a>
 8001564:	2002      	movs	r0, #2
  {
    errorcode = HAL_ERROR;
  }

error:
  hspi->State = HAL_SPI_STATE_READY;
 8001566:	2301      	movs	r3, #1
 8001568:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 800156c:	2300      	movs	r3, #0
 800156e:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  return errorcode;
 8001572:	e000      	b.n	8001576 <HAL_SPI_Transmit+0x15a>

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8001574:	2002      	movs	r0, #2
error:
  hspi->State = HAL_SPI_STATE_READY;
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 8001576:	b002      	add	sp, #8
 8001578:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800157c <HAL_SPI_TransmitReceive>:
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
                                          uint32_t Timeout)
{
 800157c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8001580:	461d      	mov	r5, r3
  uint32_t tmp = 0U, tmp1 = 0U;
#if (USE_SPI_CRC != 0U)
  __IO uint16_t tmpreg = 0U;
 8001582:	2300      	movs	r3, #0
 8001584:	f8ad 3006 	strh.w	r3, [sp, #6]

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8001588:	f890 305c 	ldrb.w	r3, [r0, #92]	; 0x5c
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
                                          uint32_t Timeout)
{
 800158c:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8001590:	2b01      	cmp	r3, #1
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
                                          uint32_t Timeout)
{
 8001592:	4604      	mov	r4, r0
 8001594:	460e      	mov	r6, r1
 8001596:	4617      	mov	r7, r2

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8001598:	f000 8132 	beq.w	8001800 <HAL_SPI_TransmitReceive+0x284>
 800159c:	2301      	movs	r3, #1
 800159e:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 80015a2:	f005 fd37 	bl	8007014 <HAL_GetTick>

  tmp  = hspi->State;
 80015a6:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
  tmp1 = hspi->Init.Mode;
 80015aa:	6861      	ldr	r1, [r4, #4]
  __HAL_LOCK(hspi);

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();

  tmp  = hspi->State;
 80015ac:	b2db      	uxtb	r3, r3
  tmp1 = hspi->Init.Mode;

  if (!((tmp == HAL_SPI_STATE_READY) || \
 80015ae:	2b01      	cmp	r3, #1

  /* Process Locked */
  __HAL_LOCK(hspi);

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 80015b0:	4681      	mov	r9, r0

  tmp  = hspi->State;
  tmp1 = hspi->Init.Mode;

  if (!((tmp == HAL_SPI_STATE_READY) || \
 80015b2:	d00a      	beq.n	80015ca <HAL_SPI_TransmitReceive+0x4e>
 80015b4:	f5b1 7f82 	cmp.w	r1, #260	; 0x104
 80015b8:	f040 8117 	bne.w	80017ea <HAL_SPI_TransmitReceive+0x26e>
        ((tmp1 == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp == HAL_SPI_STATE_BUSY_RX))))
 80015bc:	68a2      	ldr	r2, [r4, #8]
 80015be:	2a00      	cmp	r2, #0
 80015c0:	f040 8113 	bne.w	80017ea <HAL_SPI_TransmitReceive+0x26e>
 80015c4:	2b04      	cmp	r3, #4
 80015c6:	f040 8110 	bne.w	80017ea <HAL_SPI_TransmitReceive+0x26e>
  {
    errorcode = HAL_BUSY;
    goto error;
  }

  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 80015ca:	2e00      	cmp	r6, #0
 80015cc:	f000 810b 	beq.w	80017e6 <HAL_SPI_TransmitReceive+0x26a>
 80015d0:	2f00      	cmp	r7, #0
 80015d2:	f000 8108 	beq.w	80017e6 <HAL_SPI_TransmitReceive+0x26a>
 80015d6:	2d00      	cmp	r5, #0
 80015d8:	f000 8105 	beq.w	80017e6 <HAL_SPI_TransmitReceive+0x26a>
    errorcode = HAL_ERROR;
    goto error;
  }

  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 80015dc:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 80015e0:	6427      	str	r7, [r4, #64]	; 0x40
    errorcode = HAL_ERROR;
    goto error;
  }

  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 80015e2:	2b04      	cmp	r3, #4
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 80015e4:	bf1c      	itt	ne
 80015e6:	2305      	movne	r3, #5
 80015e8:	f884 305d 	strbne.w	r3, [r4, #93]	; 0x5d
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80015ec:	2300      	movs	r3, #0
 80015ee:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
  hspi->TxXferCount = Size;
  hspi->TxXferSize  = Size;

  /*Init field not used in handle to zero */
  hspi->RxISR       = NULL;
 80015f0:	64e3      	str	r3, [r4, #76]	; 0x4c
  hspi->TxISR       = NULL;
 80015f2:	6523      	str	r3, [r4, #80]	; 0x50

#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80015f4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
  hspi->RxXferCount = Size;
 80015f6:	f8a4 5046 	strh.w	r5, [r4, #70]	; 0x46
  hspi->RxISR       = NULL;
  hspi->TxISR       = NULL;

#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80015fa:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
  hspi->RxXferCount = Size;
  hspi->RxXferSize  = Size;
 80015fe:	f8a4 5044 	strh.w	r5, [r4, #68]	; 0x44
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 8001602:	63a6      	str	r6, [r4, #56]	; 0x38
  hspi->TxXferCount = Size;
 8001604:	87e5      	strh	r5, [r4, #62]	; 0x3e
  hspi->TxXferSize  = Size;
 8001606:	87a5      	strh	r5, [r4, #60]	; 0x3c
 8001608:	6823      	ldr	r3, [r4, #0]
  hspi->RxISR       = NULL;
  hspi->TxISR       = NULL;

#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800160a:	d107      	bne.n	800161c <HAL_SPI_TransmitReceive+0xa0>
  {
    SPI_RESET_CRC(hspi);
 800160c:	681a      	ldr	r2, [r3, #0]
 800160e:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8001612:	601a      	str	r2, [r3, #0]
 8001614:	681a      	ldr	r2, [r3, #0]
 8001616:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800161a:	601a      	str	r2, [r3, #0]
  }
#endif /* USE_SPI_CRC */

  /* Set the Rx Fifo threshold */
  if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (hspi->RxXferCount > 1U))
 800161c:	68e2      	ldr	r2, [r4, #12]
 800161e:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
 8001622:	d804      	bhi.n	800162e <HAL_SPI_TransmitReceive+0xb2>
 8001624:	f8b4 2046 	ldrh.w	r2, [r4, #70]	; 0x46
 8001628:	b292      	uxth	r2, r2
 800162a:	2a01      	cmp	r2, #1
 800162c:	d903      	bls.n	8001636 <HAL_SPI_TransmitReceive+0xba>
  {
    /* set fiforxthreshold according the reception data length: 16bit */
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800162e:	685a      	ldr	r2, [r3, #4]
 8001630:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8001634:	e002      	b.n	800163c <HAL_SPI_TransmitReceive+0xc0>
  }
  else
  {
    /* set fiforxthreshold according the reception data length: 8bit */
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8001636:	685a      	ldr	r2, [r3, #4]
 8001638:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800163c:	605a      	str	r2, [r3, #4]
  }

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 800163e:	681a      	ldr	r2, [r3, #0]
 8001640:	0655      	lsls	r5, r2, #25
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 8001642:	bf5e      	ittt	pl
 8001644:	681a      	ldrpl	r2, [r3, #0]
 8001646:	f042 0240 	orrpl.w	r2, r2, #64	; 0x40
 800164a:	601a      	strpl	r2, [r3, #0]
  }
  /* Transmit and Receive data in 8 Bit mode */
  else
  {
#endif
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
 800164c:	b119      	cbz	r1, 8001656 <HAL_SPI_TransmitReceive+0xda>
 800164e:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8001650:	b292      	uxth	r2, r2
 8001652:	2a01      	cmp	r2, #1
 8001654:	d112      	bne.n	800167c <HAL_SPI_TransmitReceive+0x100>
    {
      if (hspi->TxXferCount > 1U)
 8001656:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8001658:	b292      	uxth	r2, r2
 800165a:	2a01      	cmp	r2, #1
 800165c:	d907      	bls.n	800166e <HAL_SPI_TransmitReceive+0xf2>
      {
        hspi->Instance->DR = *((uint16_t *)pTxData);
 800165e:	f836 2b02 	ldrh.w	r2, [r6], #2
 8001662:	60da      	str	r2, [r3, #12]
        pTxData += sizeof(uint16_t);
        hspi->TxXferCount -= 2U;
 8001664:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8001666:	3b02      	subs	r3, #2
 8001668:	b29b      	uxth	r3, r3
 800166a:	87e3      	strh	r3, [r4, #62]	; 0x3e
 800166c:	e006      	b.n	800167c <HAL_SPI_TransmitReceive+0x100>
      }
      else
      {
        *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
 800166e:	7832      	ldrb	r2, [r6, #0]
 8001670:	731a      	strb	r2, [r3, #12]
        hspi->TxXferCount--;
 8001672:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8001674:	3b01      	subs	r3, #1
 8001676:	b29b      	uxth	r3, r3
 8001678:	87e3      	strh	r3, [r4, #62]	; 0x3e
        pTxData += sizeof(uint16_t);
        hspi->TxXferCount -= 2U;
      }
      else
      {
        *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
 800167a:	3601      	adds	r6, #1
        {
          (*(uint8_t *)pRxData++) = *(__IO uint8_t *)&hspi->Instance->DR;
          hspi->RxXferCount--;
        }
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
 800167c:	2501      	movs	r5, #1
      {
        *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
        hspi->TxXferCount--;
      }
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800167e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8001680:	b29b      	uxth	r3, r3
 8001682:	2b00      	cmp	r3, #0
 8001684:	d06a      	beq.n	800175c <HAL_SPI_TransmitReceive+0x1e0>
    {
      /* check TXE flag */
      if (txallowed && (hspi->TxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)))
 8001686:	2d00      	cmp	r5, #0
 8001688:	d034      	beq.n	80016f4 <HAL_SPI_TransmitReceive+0x178>
 800168a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800168c:	b29b      	uxth	r3, r3
 800168e:	2b00      	cmp	r3, #0
 8001690:	d02d      	beq.n	80016ee <HAL_SPI_TransmitReceive+0x172>
 8001692:	6823      	ldr	r3, [r4, #0]
 8001694:	689a      	ldr	r2, [r3, #8]
 8001696:	0790      	lsls	r0, r2, #30
 8001698:	d529      	bpl.n	80016ee <HAL_SPI_TransmitReceive+0x172>
      {
        if (hspi->TxXferCount > 1U)
 800169a:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 800169c:	b292      	uxth	r2, r2
 800169e:	2a01      	cmp	r2, #1
 80016a0:	d907      	bls.n	80016b2 <HAL_SPI_TransmitReceive+0x136>
        {
          hspi->Instance->DR = *((uint16_t *)pTxData);
 80016a2:	f836 2b02 	ldrh.w	r2, [r6], #2
 80016a6:	60da      	str	r2, [r3, #12]
          pTxData += sizeof(uint16_t);
          hspi->TxXferCount -= 2U;
 80016a8:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80016aa:	3b02      	subs	r3, #2
 80016ac:	b29b      	uxth	r3, r3
 80016ae:	87e3      	strh	r3, [r4, #62]	; 0x3e
 80016b0:	e006      	b.n	80016c0 <HAL_SPI_TransmitReceive+0x144>
        }
        else
        {
          *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
 80016b2:	7832      	ldrb	r2, [r6, #0]
 80016b4:	731a      	strb	r2, [r3, #12]
          hspi->TxXferCount--;
 80016b6:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80016b8:	3b01      	subs	r3, #1
 80016ba:	b29b      	uxth	r3, r3
 80016bc:	87e3      	strh	r3, [r4, #62]	; 0x3e
          pTxData += sizeof(uint16_t);
          hspi->TxXferCount -= 2U;
        }
        else
        {
          *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
 80016be:	3601      	adds	r6, #1
        /* Next Data is a reception (Rx). Tx not allowed */
        txallowed = 0U;

#if (USE_SPI_CRC != 0U)
        /* Enable CRC Transmission */
        if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 80016c0:	8fe5      	ldrh	r5, [r4, #62]	; 0x3e
 80016c2:	b2ad      	uxth	r5, r5
 80016c4:	b9ad      	cbnz	r5, 80016f2 <HAL_SPI_TransmitReceive+0x176>
 80016c6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80016c8:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80016cc:	d112      	bne.n	80016f4 <HAL_SPI_TransmitReceive+0x178>
        {
          /* Set NSS Soft to received correctly the CRC on slave mode with NSS pulse activated */
          if (((hspi->Instance->CR1 & SPI_CR1_MSTR) == 0U) && ((hspi->Instance->CR2 & SPI_CR2_NSSP) == SPI_CR2_NSSP))
 80016ce:	6823      	ldr	r3, [r4, #0]
 80016d0:	681a      	ldr	r2, [r3, #0]
 80016d2:	0751      	lsls	r1, r2, #29
 80016d4:	d406      	bmi.n	80016e4 <HAL_SPI_TransmitReceive+0x168>
 80016d6:	685a      	ldr	r2, [r3, #4]
 80016d8:	0712      	lsls	r2, r2, #28
          {
            SET_BIT(hspi->Instance->CR1, SPI_CR1_SSM);
 80016da:	bf42      	ittt	mi
 80016dc:	681a      	ldrmi	r2, [r3, #0]
 80016de:	f442 7200 	orrmi.w	r2, r2, #512	; 0x200
 80016e2:	601a      	strmi	r2, [r3, #0]
          }
          SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 80016e4:	681a      	ldr	r2, [r3, #0]
 80016e6:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80016ea:	601a      	str	r2, [r3, #0]
 80016ec:	e001      	b.n	80016f2 <HAL_SPI_TransmitReceive+0x176>
 80016ee:	2501      	movs	r5, #1
 80016f0:	e000      	b.n	80016f4 <HAL_SPI_TransmitReceive+0x178>
        {
          *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
          hspi->TxXferCount--;
        }
        /* Next Data is a reception (Rx). Tx not allowed */
        txallowed = 0U;
 80016f2:	2500      	movs	r5, #0
        }
#endif /* USE_SPI_CRC */
      }

      /* Wait until RXNE flag is reset */
      if ((hspi->RxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)))
 80016f4:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 80016f8:	b29b      	uxth	r3, r3
 80016fa:	b32b      	cbz	r3, 8001748 <HAL_SPI_TransmitReceive+0x1cc>
 80016fc:	6822      	ldr	r2, [r4, #0]
 80016fe:	6893      	ldr	r3, [r2, #8]
 8001700:	07db      	lsls	r3, r3, #31
 8001702:	d521      	bpl.n	8001748 <HAL_SPI_TransmitReceive+0x1cc>
      {
        if (hspi->RxXferCount > 1U)
 8001704:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8001708:	b29b      	uxth	r3, r3
 800170a:	2b01      	cmp	r3, #1
 800170c:	d912      	bls.n	8001734 <HAL_SPI_TransmitReceive+0x1b8>
        {
          *((uint16_t *)pRxData) = hspi->Instance->DR;
 800170e:	68d3      	ldr	r3, [r2, #12]
 8001710:	f827 3b02 	strh.w	r3, [r7], #2
          pRxData += sizeof(uint16_t);
          hspi->RxXferCount -= 2U;
 8001714:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8001718:	3b02      	subs	r3, #2
 800171a:	b29b      	uxth	r3, r3
 800171c:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
          if (hspi->RxXferCount <= 1U)
 8001720:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8001724:	b29b      	uxth	r3, r3
 8001726:	2b01      	cmp	r3, #1
 8001728:	d80d      	bhi.n	8001746 <HAL_SPI_TransmitReceive+0x1ca>
          {
            /* set fiforxthresold before to switch on 8 bit data size */
            SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800172a:	6853      	ldr	r3, [r2, #4]
 800172c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8001730:	6053      	str	r3, [r2, #4]
 8001732:	e008      	b.n	8001746 <HAL_SPI_TransmitReceive+0x1ca>
          }
        }
        else
        {
          (*(uint8_t *)pRxData++) = *(__IO uint8_t *)&hspi->Instance->DR;
 8001734:	7b13      	ldrb	r3, [r2, #12]
 8001736:	703b      	strb	r3, [r7, #0]
          hspi->RxXferCount--;
 8001738:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 800173c:	3b01      	subs	r3, #1
 800173e:	b29b      	uxth	r3, r3
 8001740:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
            SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
          }
        }
        else
        {
          (*(uint8_t *)pRxData++) = *(__IO uint8_t *)&hspi->Instance->DR;
 8001744:	3701      	adds	r7, #1
          hspi->RxXferCount--;
        }
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
 8001746:	2501      	movs	r5, #1
      }
      if ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout))
 8001748:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
 800174c:	d097      	beq.n	800167e <HAL_SPI_TransmitReceive+0x102>
 800174e:	f005 fc61 	bl	8007014 <HAL_GetTick>
 8001752:	ebc9 0000 	rsb	r0, r9, r0
 8001756:	4580      	cmp	r8, r0
 8001758:	d891      	bhi.n	800167e <HAL_SPI_TransmitReceive+0x102>
 800175a:	e048      	b.n	80017ee <HAL_SPI_TransmitReceive+0x272>
      {
        *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
        hspi->TxXferCount--;
      }
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800175c:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8001760:	b29b      	uxth	r3, r3
 8001762:	2b00      	cmp	r3, #0
 8001764:	d18f      	bne.n	8001686 <HAL_SPI_TransmitReceive+0x10a>
    }
//  }

#if (USE_SPI_CRC != 0U)
  /* Read CRC from DR to close CRC calculation process */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8001766:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001768:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800176c:	d126      	bne.n	80017bc <HAL_SPI_TransmitReceive+0x240>
  {
    /* Wait until TXE flag */
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
 800176e:	2201      	movs	r2, #1
 8001770:	4611      	mov	r1, r2
 8001772:	4620      	mov	r0, r4
 8001774:	f7ff fdcc 	bl	8001310 <SPI_WaitFlagStateUntilTimeout.isra.1>
 8001778:	b9a8      	cbnz	r0, 80017a6 <HAL_SPI_TransmitReceive+0x22a>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
      errorcode = HAL_TIMEOUT;
      goto error;
    }
    /* Read CRC */
    if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 800177a:	68e3      	ldr	r3, [r4, #12]
 800177c:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 8001780:	6823      	ldr	r3, [r4, #0]
 8001782:	d102      	bne.n	800178a <HAL_SPI_TransmitReceive+0x20e>
    {
      tmpreg = hspi->Instance->DR;
 8001784:	68db      	ldr	r3, [r3, #12]
 8001786:	b29b      	uxth	r3, r3
 8001788:	e014      	b.n	80017b4 <HAL_SPI_TransmitReceive+0x238>
      /* To avoid GCC warning */
      UNUSED(tmpreg);
    }
    else
    {
      tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 800178a:	7b1b      	ldrb	r3, [r3, #12]
 800178c:	f8ad 3006 	strh.w	r3, [sp, #6]
      /* To avoid GCC warning */
      UNUSED(tmpreg);
 8001790:	f8bd 3006 	ldrh.w	r3, [sp, #6]

      if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8001794:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001796:	2b02      	cmp	r3, #2
 8001798:	d110      	bne.n	80017bc <HAL_SPI_TransmitReceive+0x240>
      {
        if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
 800179a:	2201      	movs	r2, #1
 800179c:	4611      	mov	r1, r2
 800179e:	4620      	mov	r0, r4
 80017a0:	f7ff fdb6 	bl	8001310 <SPI_WaitFlagStateUntilTimeout.isra.1>
 80017a4:	b120      	cbz	r0, 80017b0 <HAL_SPI_TransmitReceive+0x234>
        {
          /* Error on the CRC reception */
          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 80017a6:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80017a8:	f043 0302 	orr.w	r3, r3, #2
 80017ac:	6623      	str	r3, [r4, #96]	; 0x60
 80017ae:	e01e      	b.n	80017ee <HAL_SPI_TransmitReceive+0x272>
          errorcode = HAL_TIMEOUT;
          goto error;
        }
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 80017b0:	6823      	ldr	r3, [r4, #0]
 80017b2:	7b1b      	ldrb	r3, [r3, #12]
 80017b4:	f8ad 3006 	strh.w	r3, [sp, #6]
        /* To avoid GCC warning */
        UNUSED(tmpreg);
 80017b8:	f8bd 3006 	ldrh.w	r3, [sp, #6]
      }
    }
  }

  /* Check if CRC error occurred */
  if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
 80017bc:	6822      	ldr	r2, [r4, #0]
 80017be:	6895      	ldr	r5, [r2, #8]
 80017c0:	f015 0510 	ands.w	r5, r5, #16
 80017c4:	d007      	beq.n	80017d6 <HAL_SPI_TransmitReceive+0x25a>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 80017c6:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80017c8:	f043 0302 	orr.w	r3, r3, #2
 80017cc:	6623      	str	r3, [r4, #96]	; 0x60
    /* Clear CRC Flag */
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 80017ce:	f64f 73ef 	movw	r3, #65519	; 0xffef
 80017d2:	6093      	str	r3, [r2, #8]

    errorcode = HAL_ERROR;
 80017d4:	2501      	movs	r5, #1
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 80017d6:	4620      	mov	r0, r4
 80017d8:	f7ff fda5 	bl	8001326 <SPI_EndRxTxTransaction.isra.2>
 80017dc:	b108      	cbz	r0, 80017e2 <HAL_SPI_TransmitReceive+0x266>
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 80017de:	2320      	movs	r3, #32
 80017e0:	6623      	str	r3, [r4, #96]	; 0x60
  }

  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 80017e2:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80017e4:	b123      	cbz	r3, 80017f0 <HAL_SPI_TransmitReceive+0x274>
  {
    errorcode = HAL_ERROR;
 80017e6:	2501      	movs	r5, #1
 80017e8:	e002      	b.n	80017f0 <HAL_SPI_TransmitReceive+0x274>
  tmp1 = hspi->Init.Mode;

  if (!((tmp == HAL_SPI_STATE_READY) || \
        ((tmp1 == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp == HAL_SPI_STATE_BUSY_RX))))
  {
    errorcode = HAL_BUSY;
 80017ea:	2502      	movs	r5, #2
 80017ec:	e000      	b.n	80017f0 <HAL_SPI_TransmitReceive+0x274>
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
      }
      if ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout))
      {
        errorcode = HAL_TIMEOUT;
 80017ee:	2503      	movs	r5, #3
  {
    errorcode = HAL_ERROR;
  }

error :
  hspi->State = HAL_SPI_STATE_READY;
 80017f0:	2301      	movs	r3, #1
 80017f2:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 80017f6:	2300      	movs	r3, #0
 80017f8:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  return errorcode;
 80017fc:	4628      	mov	r0, r5
 80017fe:	e000      	b.n	8001802 <HAL_SPI_TransmitReceive+0x286>

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8001800:	2002      	movs	r0, #2

error :
  hspi->State = HAL_SPI_STATE_READY;
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 8001802:	b003      	add	sp, #12
 8001804:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08001808 <HAL_SPI_Receive>:
  * @param  Size: amount of data to be received
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8001808:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 800180c:	461e      	mov	r6, r3
#if (USE_SPI_CRC != 0U)
  __IO uint16_t tmpreg = 0U;
 800180e:	2300      	movs	r3, #0
 8001810:	f8ad 300e 	strh.w	r3, [sp, #14]
#endif /* USE_SPI_CRC */
  uint32_t tickstart = 0U;
  HAL_StatusTypeDef errorcode = HAL_OK;


  if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 8001814:	6843      	ldr	r3, [r0, #4]
 8001816:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
  * @param  Size: amount of data to be received
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800181a:	4604      	mov	r4, r0
 800181c:	460d      	mov	r5, r1
 800181e:	4690      	mov	r8, r2
#endif /* USE_SPI_CRC */
  uint32_t tickstart = 0U;
  HAL_StatusTypeDef errorcode = HAL_OK;


  if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 8001820:	d10a      	bne.n	8001838 <HAL_SPI_Receive+0x30>
 8001822:	6883      	ldr	r3, [r0, #8]
 8001824:	b943      	cbnz	r3, 8001838 <HAL_SPI_Receive+0x30>
  {
    hspi->State = HAL_SPI_STATE_BUSY_RX;
 8001826:	2304      	movs	r3, #4
 8001828:	f880 305d 	strb.w	r3, [r0, #93]	; 0x5d
    /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
    return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
 800182c:	4613      	mov	r3, r2
 800182e:	9600      	str	r6, [sp, #0]
 8001830:	460a      	mov	r2, r1
 8001832:	f7ff fea3 	bl	800157c <HAL_SPI_TransmitReceive>
 8001836:	e100      	b.n	8001a3a <HAL_SPI_Receive+0x232>
  }

  /* Process Locked */
  __HAL_LOCK(hspi);
 8001838:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
 800183c:	2b01      	cmp	r3, #1
 800183e:	f000 80fb 	beq.w	8001a38 <HAL_SPI_Receive+0x230>
 8001842:	2301      	movs	r3, #1
 8001844:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 8001848:	f005 fbe4 	bl	8007014 <HAL_GetTick>
 800184c:	4607      	mov	r7, r0

  if (hspi->State != HAL_SPI_STATE_READY)
 800184e:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
 8001852:	b2c0      	uxtb	r0, r0
 8001854:	2801      	cmp	r0, #1
 8001856:	f040 80e7 	bne.w	8001a28 <HAL_SPI_Receive+0x220>
  {
    errorcode = HAL_BUSY;
    goto error;
  }

  if ((pData == NULL) || (Size == 0U))
 800185a:	2d00      	cmp	r5, #0
 800185c:	f000 80e5 	beq.w	8001a2a <HAL_SPI_Receive+0x222>
 8001860:	f1b8 0f00 	cmp.w	r8, #0
 8001864:	f000 80e1 	beq.w	8001a2a <HAL_SPI_Receive+0x222>
    errorcode = HAL_ERROR;
    goto error;
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 8001868:	2304      	movs	r3, #4
 800186a:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  hspi->RxISR       = NULL;
  hspi->TxISR       = NULL;

#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800186e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = (uint8_t *)pData;
 8001870:	6425      	str	r5, [r4, #64]	; 0x40
    goto error;
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8001872:	2100      	movs	r1, #0
  hspi->RxISR       = NULL;
  hspi->TxISR       = NULL;

#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8001874:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
    goto error;
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8001878:	6621      	str	r1, [r4, #96]	; 0x60
  hspi->pRxBuffPtr  = (uint8_t *)pData;
  hspi->RxXferSize  = Size;
 800187a:	f8a4 8044 	strh.w	r8, [r4, #68]	; 0x44
  hspi->RxXferCount = Size;
 800187e:	f8a4 8046 	strh.w	r8, [r4, #70]	; 0x46

  /*Init field not used in handle to zero */
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
 8001882:	63a1      	str	r1, [r4, #56]	; 0x38
  hspi->TxXferSize  = 0U;
 8001884:	87a1      	strh	r1, [r4, #60]	; 0x3c
  hspi->TxXferCount = 0U;
 8001886:	87e1      	strh	r1, [r4, #62]	; 0x3e
  hspi->RxISR       = NULL;
 8001888:	64e1      	str	r1, [r4, #76]	; 0x4c
  hspi->TxISR       = NULL;
 800188a:	6521      	str	r1, [r4, #80]	; 0x50
 800188c:	6822      	ldr	r2, [r4, #0]

#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800188e:	d10d      	bne.n	80018ac <HAL_SPI_Receive+0xa4>
  {
    SPI_RESET_CRC(hspi);
 8001890:	6813      	ldr	r3, [r2, #0]
 8001892:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8001896:	6013      	str	r3, [r2, #0]
 8001898:	6813      	ldr	r3, [r2, #0]
 800189a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800189e:	6013      	str	r3, [r2, #0]
    /* this is done to handle the CRCNEXT before the latest data */
    hspi->RxXferCount--;
 80018a0:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 80018a4:	3b01      	subs	r3, #1
 80018a6:	b29b      	uxth	r3, r3
 80018a8:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
  }
#endif /* USE_SPI_CRC */

  /* Set the Rx Fifo threshold */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80018ac:	68e3      	ldr	r3, [r4, #12]
 80018ae:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
  {
    /* set fiforxthresold according the reception data length: 16bit */
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80018b2:	6853      	ldr	r3, [r2, #4]
 80018b4:	bf8c      	ite	hi
 80018b6:	f423 5380 	bichi.w	r3, r3, #4096	; 0x1000
  }
  else
  {
    /* set fiforxthresold according the reception data length: 8bit */
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80018ba:	f443 5380 	orrls.w	r3, r3, #4096	; 0x1000
 80018be:	6053      	str	r3, [r2, #4]
  }

  /* Configure communication direction: 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80018c0:	68a3      	ldr	r3, [r4, #8]
 80018c2:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  {
    SPI_1LINE_RX(hspi);
 80018c6:	bf02      	ittt	eq
 80018c8:	6813      	ldreq	r3, [r2, #0]
 80018ca:	f423 4380 	biceq.w	r3, r3, #16384	; 0x4000
 80018ce:	6013      	streq	r3, [r2, #0]
  }

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80018d0:	6813      	ldr	r3, [r2, #0]
 80018d2:	065b      	lsls	r3, r3, #25
 80018d4:	d411      	bmi.n	80018fa <HAL_SPI_Receive+0xf2>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 80018d6:	6813      	ldr	r3, [r2, #0]
 80018d8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80018dc:	6013      	str	r3, [r2, #0]
 80018de:	e00c      	b.n	80018fa <HAL_SPI_Receive+0xf2>
#endif
    /* Transfer loop */
    while (hspi->RxXferCount > 0U)
    {
      /* Check the RXNE flag */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 80018e0:	6823      	ldr	r3, [r4, #0]
 80018e2:	689a      	ldr	r2, [r3, #8]
 80018e4:	07d0      	lsls	r0, r2, #31
 80018e6:	d50e      	bpl.n	8001906 <HAL_SPI_Receive+0xfe>
      {
        /* read the received data */
        (* (uint8_t *)pData) = *(__IO uint8_t *)&hspi->Instance->DR;
 80018e8:	7b1b      	ldrb	r3, [r3, #12]
 80018ea:	f805 3b01 	strb.w	r3, [r5], #1
        pData += sizeof(uint8_t);
        hspi->RxXferCount--;
 80018ee:	f8b4 2046 	ldrh.w	r2, [r4, #70]	; 0x46
 80018f2:	3a01      	subs	r2, #1
 80018f4:	b292      	uxth	r2, r2
 80018f6:	f8a4 2046 	strh.w	r2, [r4, #70]	; 0x46
#if 0
  if (hspi->Init.DataSize <= SPI_DATASIZE_8BIT)
  {
#endif
    /* Transfer loop */
    while (hspi->RxXferCount > 0U)
 80018fa:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 80018fe:	b29b      	uxth	r3, r3
 8001900:	2b00      	cmp	r3, #0
 8001902:	d1ed      	bne.n	80018e0 <HAL_SPI_Receive+0xd8>
 8001904:	e009      	b.n	800191a <HAL_SPI_Receive+0x112>
        hspi->RxXferCount--;
      }
      else
      {
        /* Timeout management */
        if ((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout)))
 8001906:	2e00      	cmp	r6, #0
 8001908:	d043      	beq.n	8001992 <HAL_SPI_Receive+0x18a>
 800190a:	1c71      	adds	r1, r6, #1
 800190c:	d0f5      	beq.n	80018fa <HAL_SPI_Receive+0xf2>
 800190e:	f005 fb81 	bl	8007014 <HAL_GetTick>
 8001912:	1bc0      	subs	r0, r0, r7
 8001914:	4286      	cmp	r6, r0
 8001916:	d8f0      	bhi.n	80018fa <HAL_SPI_Receive+0xf2>
 8001918:	e03b      	b.n	8001992 <HAL_SPI_Receive+0x18a>
  }
#endif

#if (USE_SPI_CRC != 0U)
  /* Handle the CRC Transmission */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800191a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800191c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8001920:	d13f      	bne.n	80019a2 <HAL_SPI_Receive+0x19a>
  {
    /* freeze the CRC before the latest data */
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 8001922:	6822      	ldr	r2, [r4, #0]
 8001924:	6813      	ldr	r3, [r2, #0]
 8001926:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800192a:	6013      	str	r3, [r2, #0]

    /* Read the latest data */
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
 800192c:	2201      	movs	r2, #1
 800192e:	4611      	mov	r1, r2
 8001930:	4620      	mov	r0, r4
 8001932:	f7ff fced 	bl	8001310 <SPI_WaitFlagStateUntilTimeout.isra.1>
 8001936:	bb60      	cbnz	r0, 8001992 <HAL_SPI_Receive+0x18a>
      errorcode = HAL_TIMEOUT;
      goto error;
    }

    /* Receive last data in 16 Bit mode */
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8001938:	68e3      	ldr	r3, [r4, #12]
 800193a:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 800193e:	6823      	ldr	r3, [r4, #0]
    {
      (*(uint8_t *)pData) = *(__IO uint8_t *)&hspi->Instance->DR;
    }

    /* Wait the CRC data */
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
 8001940:	f04f 0201 	mov.w	r2, #1
    }

    /* Receive last data in 16 Bit mode */
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
    {
      *((uint16_t *)pData) = hspi->Instance->DR;
 8001944:	bf8b      	itete	hi
 8001946:	68db      	ldrhi	r3, [r3, #12]
    }
    /* Receive last data in 8 Bit mode */
    else
    {
      (*(uint8_t *)pData) = *(__IO uint8_t *)&hspi->Instance->DR;
 8001948:	7b1b      	ldrbls	r3, [r3, #12]
    }

    /* Receive last data in 16 Bit mode */
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
    {
      *((uint16_t *)pData) = hspi->Instance->DR;
 800194a:	802b      	strhhi	r3, [r5, #0]
    }
    /* Receive last data in 8 Bit mode */
    else
    {
      (*(uint8_t *)pData) = *(__IO uint8_t *)&hspi->Instance->DR;
 800194c:	702b      	strbls	r3, [r5, #0]
    }

    /* Wait the CRC data */
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
 800194e:	4611      	mov	r1, r2
 8001950:	4620      	mov	r0, r4
 8001952:	f7ff fcdd 	bl	8001310 <SPI_WaitFlagStateUntilTimeout.isra.1>
 8001956:	b9c0      	cbnz	r0, 800198a <HAL_SPI_Receive+0x182>
      errorcode = HAL_TIMEOUT;
      goto error;
    }

    /* Read CRC to Flush DR and RXNE flag */
    if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 8001958:	68e2      	ldr	r2, [r4, #12]
 800195a:	6823      	ldr	r3, [r4, #0]
 800195c:	f5b2 6f70 	cmp.w	r2, #3840	; 0xf00
 8001960:	d102      	bne.n	8001968 <HAL_SPI_Receive+0x160>
    {
      tmpreg = hspi->Instance->DR;
 8001962:	68db      	ldr	r3, [r3, #12]
 8001964:	b29b      	uxth	r3, r3
 8001966:	e018      	b.n	800199a <HAL_SPI_Receive+0x192>
      /* To avoid GCC warning */
      UNUSED(tmpreg);
    }
    else
    {
      tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8001968:	7b1b      	ldrb	r3, [r3, #12]
 800196a:	f8ad 300e 	strh.w	r3, [sp, #14]
      /* To avoid GCC warning */
      UNUSED(tmpreg);

      if ((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
 800196e:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
    }
    else
    {
      tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
      /* To avoid GCC warning */
      UNUSED(tmpreg);
 8001972:	f8bd 300e 	ldrh.w	r3, [sp, #14]

      if ((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
 8001976:	d114      	bne.n	80019a2 <HAL_SPI_Receive+0x19a>
 8001978:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800197a:	2b02      	cmp	r3, #2
 800197c:	d111      	bne.n	80019a2 <HAL_SPI_Receive+0x19a>
      {
        if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout, tickstart) != HAL_OK)
 800197e:	2201      	movs	r2, #1
 8001980:	4611      	mov	r1, r2
 8001982:	4620      	mov	r0, r4
 8001984:	f7ff fcc4 	bl	8001310 <SPI_WaitFlagStateUntilTimeout.isra.1>
 8001988:	b128      	cbz	r0, 8001996 <HAL_SPI_Receive+0x18e>
        {
          /* Error on the CRC reception */
          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 800198a:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800198c:	f043 0302 	orr.w	r3, r3, #2
 8001990:	6623      	str	r3, [r4, #96]	; 0x60
          errorcode = HAL_TIMEOUT;
 8001992:	2003      	movs	r0, #3
          goto error;
 8001994:	e049      	b.n	8001a2a <HAL_SPI_Receive+0x222>
        }
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8001996:	6823      	ldr	r3, [r4, #0]
 8001998:	7b1b      	ldrb	r3, [r3, #12]
 800199a:	f8ad 300e 	strh.w	r3, [sp, #14]
        /* To avoid GCC warning */
        UNUSED(tmpreg);
 800199e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
  * @param  Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout, uint32_t Tickstart)
{
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80019a2:	6863      	ldr	r3, [r4, #4]
 80019a4:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 80019a8:	d10b      	bne.n	80019c2 <HAL_SPI_Receive+0x1ba>
 80019aa:	68a3      	ldr	r3, [r4, #8]
 80019ac:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80019b0:	d002      	beq.n	80019b8 <HAL_SPI_Receive+0x1b0>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 80019b2:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80019b6:	d104      	bne.n	80019c2 <HAL_SPI_Receive+0x1ba>
  {
    /* Disable SPI peripheral */
    __HAL_SPI_DISABLE(hspi);
 80019b8:	6822      	ldr	r2, [r4, #0]
 80019ba:	6813      	ldr	r3, [r2, #0]
 80019bc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80019c0:	6013      	str	r3, [r2, #0]
  }

  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 80019c2:	2200      	movs	r2, #0
 80019c4:	2180      	movs	r1, #128	; 0x80
 80019c6:	4620      	mov	r0, r4
 80019c8:	f7ff fca2 	bl	8001310 <SPI_WaitFlagStateUntilTimeout.isra.1>
 80019cc:	6823      	ldr	r3, [r4, #0]
 80019ce:	b130      	cbz	r0, 80019de <HAL_SPI_Receive+0x1d6>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80019d0:	6e22      	ldr	r2, [r4, #96]	; 0x60
 80019d2:	f042 0220 	orr.w	r2, r2, #32
 80019d6:	6622      	str	r2, [r4, #96]	; 0x60
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTransaction(hspi, Timeout, tickstart) != HAL_OK)
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 80019d8:	2220      	movs	r2, #32
 80019da:	6622      	str	r2, [r4, #96]	; 0x60
 80019dc:	e015      	b.n	8001a0a <HAL_SPI_Receive+0x202>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }

  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80019de:	6862      	ldr	r2, [r4, #4]
 80019e0:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
 80019e4:	d111      	bne.n	8001a0a <HAL_SPI_Receive+0x202>
 80019e6:	68a2      	ldr	r2, [r4, #8]
 80019e8:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 80019ec:	d002      	beq.n	80019f4 <HAL_SPI_Receive+0x1ec>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 80019ee:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 80019f2:	d10a      	bne.n	8001a0a <HAL_SPI_Receive+0x202>
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
  __IO uint8_t tmpreg;

  while ((hspi->Instance->SR & Fifo) != State)
 80019f4:	689a      	ldr	r2, [r3, #8]
 80019f6:	f412 6fc0 	tst.w	r2, #1536	; 0x600
 80019fa:	d006      	beq.n	8001a0a <HAL_SPI_Receive+0x202>
  {
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
    {
      tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 80019fc:	7b1a      	ldrb	r2, [r3, #12]
 80019fe:	b2d2      	uxtb	r2, r2
 8001a00:	f88d 200d 	strb.w	r2, [sp, #13]
      /* To avoid GCC warning */
      UNUSED(tmpreg);
 8001a04:	f89d 200d 	ldrb.w	r2, [sp, #13]
 8001a08:	e7f4      	b.n	80019f4 <HAL_SPI_Receive+0x1ec>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
  }

#if (USE_SPI_CRC != 0U)
  /* Check if CRC error occurred */
  if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
 8001a0a:	689a      	ldr	r2, [r3, #8]
 8001a0c:	06d2      	lsls	r2, r2, #27
 8001a0e:	d506      	bpl.n	8001a1e <HAL_SPI_Receive+0x216>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8001a10:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8001a12:	f042 0202 	orr.w	r2, r2, #2
 8001a16:	6622      	str	r2, [r4, #96]	; 0x60
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 8001a18:	f64f 72ef 	movw	r2, #65519	; 0xffef
 8001a1c:	609a      	str	r2, [r3, #8]
  }
#endif /* USE_SPI_CRC */

  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8001a1e:	6e20      	ldr	r0, [r4, #96]	; 0x60
  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();

  if (hspi->State != HAL_SPI_STATE_READY)
  {
    errorcode = HAL_BUSY;
 8001a20:	3000      	adds	r0, #0
 8001a22:	bf18      	it	ne
 8001a24:	2001      	movne	r0, #1
 8001a26:	e000      	b.n	8001a2a <HAL_SPI_Receive+0x222>
 8001a28:	2002      	movs	r0, #2
  {
    errorcode = HAL_ERROR;
  }

error :
  hspi->State = HAL_SPI_STATE_READY;
 8001a2a:	2301      	movs	r3, #1
 8001a2c:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 8001a30:	2300      	movs	r3, #0
 8001a32:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  return errorcode;
 8001a36:	e000      	b.n	8001a3a <HAL_SPI_Receive+0x232>
    /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
    return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
  }

  /* Process Locked */
  __HAL_LOCK(hspi);
 8001a38:	2002      	movs	r0, #2

error :
  hspi->State = HAL_SPI_STATE_READY;
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 8001a3a:	b004      	add	sp, #16
 8001a3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08001a40 <checksum_more>:

// checksum_more()
//
    static void
checksum_more(SHA256_CTX *ctx, uint32_t *total, const uint8_t *addr, int len)
{
 8001a40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001a42:	460d      	mov	r5, r1
    puts2("Verify %0x");
    puthex2(percent);
    putchar('\n');
#endif

    oled_show_progress(screen_verify, percent);
 8001a44:	6809      	ldr	r1, [r1, #0]

// checksum_more()
//
    static void
checksum_more(SHA256_CTX *ctx, uint32_t *total, const uint8_t *addr, int len)
{
 8001a46:	461c      	mov	r4, r3
    puts2("Verify %0x");
    puthex2(percent);
    putchar('\n');
#endif

    oled_show_progress(screen_verify, percent);
 8001a48:	2364      	movs	r3, #100	; 0x64
 8001a4a:	434b      	muls	r3, r1

// checksum_more()
//
    static void
checksum_more(SHA256_CTX *ctx, uint32_t *total, const uint8_t *addr, int len)
{
 8001a4c:	4617      	mov	r7, r2
 8001a4e:	4606      	mov	r6, r0
    puts2("Verify %0x");
    puthex2(percent);
    putchar('\n');
#endif

    oled_show_progress(screen_verify, percent);
 8001a50:	4907      	ldr	r1, [pc, #28]	; (8001a70 <checksum_more+0x30>)
 8001a52:	4808      	ldr	r0, [pc, #32]	; (8001a74 <checksum_more+0x34>)
 8001a54:	fbb3 f1f1 	udiv	r1, r3, r1
 8001a58:	f7ff fa0e 	bl	8000e78 <oled_show_progress>

    sha256_update(ctx, addr, len);
 8001a5c:	4622      	mov	r2, r4
 8001a5e:	4639      	mov	r1, r7
 8001a60:	4630      	mov	r0, r6
 8001a62:	f003 fc89 	bl	8005378 <sha256_update>
    *total += len;
 8001a66:	682b      	ldr	r3, [r5, #0]
 8001a68:	441c      	add	r4, r3
 8001a6a:	602c      	str	r4, [r5, #0]
 8001a6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001a6e:	bf00      	nop
 8001a70:	0018741c 	.word	0x0018741c
 8001a74:	0800d62a 	.word	0x0800d62a

08001a78 <checksum_flash>:

// checksum_flash()
//
    void
checksum_flash(uint8_t fw_digest[32], uint8_t world_digest[32], uint32_t fw_length)
{
 8001a78:	b570      	push	{r4, r5, r6, lr}
 8001a7a:	b09c      	sub	sp, #112	; 0x70
 8001a7c:	4606      	mov	r6, r0
 8001a7e:	460d      	mov	r5, r1
 8001a80:	4614      	mov	r4, r2
    const uint8_t *start = (const uint8_t *)FIRMWARE_START;

    rng_delay();
 8001a82:	f000 fe5c 	bl	800273e <rng_delay>

    SHA256_CTX  ctx;
    uint32_t    total_len = 0;
 8001a86:	2300      	movs	r3, #0
 8001a88:	9300      	str	r3, [sp, #0]

    if(fw_length == 0) {
 8001a8a:	b9e4      	cbnz	r4, 8001ac6 <checksum_flash+0x4e>
        uint8_t first[32];
        sha256_init(&ctx);
 8001a8c:	a809      	add	r0, sp, #36	; 0x24
 8001a8e:	f003 fc63 	bl	8005358 <sha256_init>

        // use length from header in flash
        fw_length = FW_HDR->firmware_length;
 8001a92:	4b37      	ldr	r3, [pc, #220]	; (8001b70 <checksum_flash+0xf8>)

        // start of firmware (just after we end) to header
        checksum_more(&ctx, &total_len, start, FW_HEADER_OFFSET + FW_HEADER_SIZE - 64);
 8001a94:	4a37      	ldr	r2, [pc, #220]	; (8001b74 <checksum_flash+0xfc>)
    if(fw_length == 0) {
        uint8_t first[32];
        sha256_init(&ctx);

        // use length from header in flash
        fw_length = FW_HDR->firmware_length;
 8001a96:	699c      	ldr	r4, [r3, #24]

        // start of firmware (just after we end) to header
        checksum_more(&ctx, &total_len, start, FW_HEADER_OFFSET + FW_HEADER_SIZE - 64);
 8001a98:	4669      	mov	r1, sp
 8001a9a:	a809      	add	r0, sp, #36	; 0x24
 8001a9c:	f44f 537f 	mov.w	r3, #16320	; 0x3fc0
 8001aa0:	f7ff ffce 	bl	8001a40 <checksum_more>

        // from after header to end
        checksum_more(&ctx, &total_len, start + FW_HEADER_OFFSET + FW_HEADER_SIZE, 
 8001aa4:	f5a4 4380 	sub.w	r3, r4, #16384	; 0x4000
 8001aa8:	4a33      	ldr	r2, [pc, #204]	; (8001b78 <checksum_flash+0x100>)
 8001aaa:	4669      	mov	r1, sp
 8001aac:	a809      	add	r0, sp, #36	; 0x24
 8001aae:	f7ff ffc7 	bl	8001a40 <checksum_more>
                                fw_length - (FW_HEADER_OFFSET + FW_HEADER_SIZE));

        sha256_final(&ctx, first);
 8001ab2:	a901      	add	r1, sp, #4
 8001ab4:	a809      	add	r0, sp, #36	; 0x24
 8001ab6:	f003 fca5 	bl	8005404 <sha256_final>

        // double SHA256
        sha256_single(first, sizeof(first), fw_digest);
 8001aba:	4632      	mov	r2, r6
 8001abc:	2120      	movs	r1, #32
 8001abe:	a801      	add	r0, sp, #4
 8001ac0:	f003 fcb4 	bl	800542c <sha256_single>
 8001ac4:	e002      	b.n	8001acc <checksum_flash+0x54>
    } else {
        // fw_digest should already be populated by caller
        total_len = fw_length - 64;
 8001ac6:	f1a4 0340 	sub.w	r3, r4, #64	; 0x40
 8001aca:	9300      	str	r3, [sp, #0]
    }

    // start over, and get the rest of flash. All of it.
    sha256_init(&ctx);
 8001acc:	a809      	add	r0, sp, #36	; 0x24
 8001ace:	f003 fc43 	bl	8005358 <sha256_init>

    // .. and chain in what we have so far
    sha256_update(&ctx, fw_digest, 32);
 8001ad2:	2220      	movs	r2, #32
 8001ad4:	4631      	mov	r1, r6
 8001ad6:	a809      	add	r0, sp, #36	; 0x24
 8001ad8:	f003 fc4e 	bl	8005378 <sha256_update>

    // bootloader, including pairing secret area.
    const uint8_t *base = (const uint8_t *)BL_FLASH_BASE;
    checksum_more(&ctx, &total_len, base, start-base);
 8001adc:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8001ae0:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8001ae4:	4669      	mov	r1, sp
 8001ae6:	a809      	add	r0, sp, #36	; 0x24
 8001ae8:	f7ff ffaa 	bl	8001a40 <checksum_more>

    // probably-blank area after firmware, and filesystem area
    const uint8_t *fs = start + fw_length;
 8001aec:	f104 6200 	add.w	r2, r4, #134217728	; 0x8000000
 8001af0:	f502 3200 	add.w	r2, r2, #131072	; 0x20000
    const uint8_t *last = base + MAIN_FLASH_SIZE;
    checksum_more(&ctx, &total_len, fs, last-fs);
 8001af4:	f1c2 6301 	rsb	r3, r2, #135266304	; 0x8100000
 8001af8:	f503 2300 	add.w	r3, r3, #524288	; 0x80000
 8001afc:	4669      	mov	r1, sp
 8001afe:	a809      	add	r0, sp, #36	; 0x24
 8001b00:	f7ff ff9e 	bl	8001a40 <checksum_more>

    rng_delay();
 8001b04:	f000 fe1b 	bl	800273e <rng_delay>

    // OTP area
    checksum_more(&ctx, &total_len, (void *)0x1fff7000, 0x400);
 8001b08:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001b0c:	4a1b      	ldr	r2, [pc, #108]	; (8001b7c <checksum_flash+0x104>)
 8001b0e:	4669      	mov	r1, sp
 8001b10:	a809      	add	r0, sp, #36	; 0x24
 8001b12:	f7ff ff95 	bl	8001a40 <checksum_more>

    // "just in case" ... the option bytes (2 banks)
    checksum_more(&ctx, &total_len, (void *)0x1fff7800, 0x28);
 8001b16:	2328      	movs	r3, #40	; 0x28
 8001b18:	4a19      	ldr	r2, [pc, #100]	; (8001b80 <checksum_flash+0x108>)
 8001b1a:	4669      	mov	r1, sp
 8001b1c:	a809      	add	r0, sp, #36	; 0x24
 8001b1e:	f7ff ff8f 	bl	8001a40 <checksum_more>
    checksum_more(&ctx, &total_len, (void *)0x1ffff800, 0x28);
 8001b22:	2328      	movs	r3, #40	; 0x28
 8001b24:	4a17      	ldr	r2, [pc, #92]	; (8001b84 <checksum_flash+0x10c>)
 8001b26:	4669      	mov	r1, sp
 8001b28:	a809      	add	r0, sp, #36	; 0x24
 8001b2a:	f7ff ff89 	bl	8001a40 <checksum_more>

    // System ROM (they say it can't change, but clearly
    // implemented as flash cells)
    checksum_more(&ctx, &total_len, (void *)0x1fff0000, 0x7000);
 8001b2e:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8001b32:	4a15      	ldr	r2, [pc, #84]	; (8001b88 <checksum_flash+0x110>)
 8001b34:	4669      	mov	r1, sp
 8001b36:	a809      	add	r0, sp, #36	; 0x24
 8001b38:	f7ff ff82 	bl	8001a40 <checksum_more>

    // device serial number, just for kicks
    checksum_more(&ctx, &total_len, (void *)0x1fff7590, 12);
 8001b3c:	230c      	movs	r3, #12
 8001b3e:	4a13      	ldr	r2, [pc, #76]	; (8001b8c <checksum_flash+0x114>)
 8001b40:	4669      	mov	r1, sp
 8001b42:	a809      	add	r0, sp, #36	; 0x24
 8001b44:	f7ff ff7c 	bl	8001a40 <checksum_more>

    ASSERT(total_len == TOTAL_CHECKSUM_LEN);
 8001b48:	9a00      	ldr	r2, [sp, #0]
 8001b4a:	4b11      	ldr	r3, [pc, #68]	; (8001b90 <checksum_flash+0x118>)
 8001b4c:	429a      	cmp	r2, r3
 8001b4e:	d002      	beq.n	8001b56 <checksum_flash+0xde>
 8001b50:	4810      	ldr	r0, [pc, #64]	; (8001b94 <checksum_flash+0x11c>)
 8001b52:	f7fe ff43 	bl	80009dc <fatal_error>
    
    sha256_final(&ctx, world_digest);
 8001b56:	4629      	mov	r1, r5
 8001b58:	a809      	add	r0, sp, #36	; 0x24
 8001b5a:	f003 fc53 	bl	8005404 <sha256_final>

    // double SHA256 (a bitcoin fetish)
    sha256_single(world_digest, 32, world_digest);
 8001b5e:	462a      	mov	r2, r5
 8001b60:	2120      	movs	r1, #32
 8001b62:	4628      	mov	r0, r5
 8001b64:	f003 fc62 	bl	800542c <sha256_single>

    rng_delay();
 8001b68:	f000 fde9 	bl	800273e <rng_delay>
}
 8001b6c:	b01c      	add	sp, #112	; 0x70
 8001b6e:	bd70      	pop	{r4, r5, r6, pc}
 8001b70:	08023f80 	.word	0x08023f80
 8001b74:	08020000 	.word	0x08020000
 8001b78:	08024000 	.word	0x08024000
 8001b7c:	1fff7000 	.word	0x1fff7000
 8001b80:	1fff7800 	.word	0x1fff7800
 8001b84:	1ffff800 	.word	0x1ffff800
 8001b88:	1fff0000 	.word	0x1fff0000
 8001b8c:	1fff7590 	.word	0x1fff7590
 8001b90:	0018741c 	.word	0x0018741c
 8001b94:	0800d558 	.word	0x0800d558

08001b98 <get_min_version>:
// Scan the OTP area and determine what the current min-version (timestamp)
// we can allow. All zeros if any if okay.
//
    void
get_min_version(uint8_t min_version[8])
{
 8001b98:	b570      	push	{r4, r5, r6, lr}
 8001b9a:	4605      	mov	r5, r0
    const uint8_t *otp = (const uint8_t *)OPT_FLASH_BASE;
 8001b9c:	4c0c      	ldr	r4, [pc, #48]	; (8001bd0 <get_min_version+0x38>)

    rng_delay();
    memset(min_version, 0, 8);

    for(int i=0; i<NUM_OPT_SLOTS; i++, otp+=8) {
 8001b9e:	4e0d      	ldr	r6, [pc, #52]	; (8001bd4 <get_min_version+0x3c>)
    void
get_min_version(uint8_t min_version[8])
{
    const uint8_t *otp = (const uint8_t *)OPT_FLASH_BASE;

    rng_delay();
 8001ba0:	f000 fdcd 	bl	800273e <rng_delay>
    memset(min_version, 0, 8);
 8001ba4:	2300      	movs	r3, #0
 8001ba6:	602b      	str	r3, [r5, #0]
 8001ba8:	606b      	str	r3, [r5, #4]
        // is it programmed?
        if(otp[0] == 0xff) continue;

        // is it a timestamp value?
        if(otp[0] >= 0x40) continue;
        if(otp[0] < 0x10) continue;
 8001baa:	7823      	ldrb	r3, [r4, #0]
 8001bac:	3b10      	subs	r3, #16
 8001bae:	2b2f      	cmp	r3, #47	; 0x2f
 8001bb0:	d80a      	bhi.n	8001bc8 <get_min_version+0x30>

        if(memcmp(otp, min_version, 8) > 0) {
 8001bb2:	4629      	mov	r1, r5
 8001bb4:	2208      	movs	r2, #8
 8001bb6:	4620      	mov	r0, r4
 8001bb8:	f00b fc54 	bl	800d464 <memcmp>
 8001bbc:	2800      	cmp	r0, #0
            memcpy(min_version, otp, 8);
 8001bbe:	bfc1      	itttt	gt
 8001bc0:	4623      	movgt	r3, r4
 8001bc2:	cb03      	ldmiagt	r3!, {r0, r1}
 8001bc4:	6028      	strgt	r0, [r5, #0]
 8001bc6:	6069      	strgt	r1, [r5, #4]
    const uint8_t *otp = (const uint8_t *)OPT_FLASH_BASE;

    rng_delay();
    memset(min_version, 0, 8);

    for(int i=0; i<NUM_OPT_SLOTS; i++, otp+=8) {
 8001bc8:	3408      	adds	r4, #8
 8001bca:	42b4      	cmp	r4, r6
 8001bcc:	d1ed      	bne.n	8001baa <get_min_version+0x12>

        if(memcmp(otp, min_version, 8) > 0) {
            memcpy(min_version, otp, 8);
        }
    }
}
 8001bce:	bd70      	pop	{r4, r5, r6, pc}
 8001bd0:	1fff7000 	.word	0x1fff7000
 8001bd4:	1fff7400 	.word	0x1fff7400

08001bd8 <check_is_downgrade>:

// check_is_downgrade()
//
    bool
check_is_downgrade(const uint8_t timestamp[8], const char *version)
{
 8001bd8:	b513      	push	{r0, r1, r4, lr}
 8001bda:	4604      	mov	r4, r0
    if(version) {
 8001bdc:	b129      	cbz	r1, 8001bea <check_is_downgrade+0x12>
        int major = (version[1] == '.') ? (version[0]-'0') : 10;
 8001bde:	784b      	ldrb	r3, [r1, #1]
 8001be0:	2b2e      	cmp	r3, #46	; 0x2e
 8001be2:	d102      	bne.n	8001bea <check_is_downgrade+0x12>
        if(major < 3) {
 8001be4:	780b      	ldrb	r3, [r1, #0]
 8001be6:	2b32      	cmp	r3, #50	; 0x32
 8001be8:	dd09      	ble.n	8001bfe <check_is_downgrade+0x26>
        }
    }

    // look at FW_HDR->timestamp and compare to a growing list in main flash OTP
    uint8_t min[8];
    get_min_version(min);
 8001bea:	4668      	mov	r0, sp
 8001bec:	f7ff ffd4 	bl	8001b98 <get_min_version>

    return (memcmp(timestamp, min, 8) < 0);
 8001bf0:	2208      	movs	r2, #8
 8001bf2:	4669      	mov	r1, sp
 8001bf4:	4620      	mov	r0, r4
 8001bf6:	f00b fc35 	bl	800d464 <memcmp>
 8001bfa:	0fc0      	lsrs	r0, r0, #31
 8001bfc:	e000      	b.n	8001c00 <check_is_downgrade+0x28>
{
    if(version) {
        int major = (version[1] == '.') ? (version[0]-'0') : 10;
        if(major < 3) {
            // we require major version 3.0.0 or later (for mark3 hardware)
            return true;
 8001bfe:	2001      	movs	r0, #1
    // look at FW_HDR->timestamp and compare to a growing list in main flash OTP
    uint8_t min[8];
    get_min_version(min);

    return (memcmp(timestamp, min, 8) < 0);
}
 8001c00:	b002      	add	sp, #8
 8001c02:	bd10      	pop	{r4, pc}

08001c04 <warn_fishy_firmware>:

// warn_fishy_firmware()
//
    void
warn_fishy_firmware(const uint8_t *pixels)
{
 8001c04:	b538      	push	{r3, r4, r5, lr}
 8001c06:	4605      	mov	r5, r0
    const int wait = 100;
#else
    const int wait = 10;
#endif
    
    for(int i=0; i < wait; i++) {
 8001c08:	2400      	movs	r4, #0
        oled_show_progress(pixels, (i*100)/wait);
 8001c0a:	4621      	mov	r1, r4
 8001c0c:	4628      	mov	r0, r5
 8001c0e:	f7ff f933 	bl	8000e78 <oled_show_progress>
    const int wait = 100;
#else
    const int wait = 10;
#endif
    
    for(int i=0; i < wait; i++) {
 8001c12:	3401      	adds	r4, #1
        oled_show_progress(pixels, (i*100)/wait);

        delay_ms(250);
 8001c14:	20fa      	movs	r0, #250	; 0xfa
 8001c16:	f001 fe3b 	bl	8003890 <delay_ms>
    const int wait = 100;
#else
    const int wait = 10;
#endif
    
    for(int i=0; i < wait; i++) {
 8001c1a:	2c64      	cmp	r4, #100	; 0x64
 8001c1c:	d1f5      	bne.n	8001c0a <warn_fishy_firmware+0x6>
        oled_show_progress(pixels, (i*100)/wait);

        delay_ms(250);
    }
}
 8001c1e:	bd38      	pop	{r3, r4, r5, pc}

08001c20 <verify_header>:

// verify_header()
//
    bool
verify_header(const coldcardFirmwareHeader_t *hdr)
{
 8001c20:	b510      	push	{r4, lr}
 8001c22:	4604      	mov	r4, r0
    rng_delay();
 8001c24:	f000 fd8b 	bl	800273e <rng_delay>

    if(hdr->magic_value != FW_HEADER_MAGIC) goto fail;
 8001c28:	6822      	ldr	r2, [r4, #0]
 8001c2a:	4b0c      	ldr	r3, [pc, #48]	; (8001c5c <verify_header+0x3c>)
 8001c2c:	429a      	cmp	r2, r3
 8001c2e:	d112      	bne.n	8001c56 <verify_header+0x36>
    if(hdr->version_string[0] == 0x0) goto fail;
 8001c30:	7b23      	ldrb	r3, [r4, #12]
 8001c32:	b173      	cbz	r3, 8001c52 <verify_header+0x32>
    if(hdr->timestamp[0] >= 0x40) goto fail;        // 22 yr product lifetime
 8001c34:	7923      	ldrb	r3, [r4, #4]
 8001c36:	2b3f      	cmp	r3, #63	; 0x3f
 8001c38:	d80d      	bhi.n	8001c56 <verify_header+0x36>
    if(hdr->firmware_length < FW_MIN_LENGTH) goto fail;
 8001c3a:	69a3      	ldr	r3, [r4, #24]
 8001c3c:	f5a3 2380 	sub.w	r3, r3, #262144	; 0x40000
 8001c40:	f5b3 2f38 	cmp.w	r3, #753664	; 0xb8000
 8001c44:	d807      	bhi.n	8001c56 <verify_header+0x36>
    if(hdr->firmware_length > FW_MAX_LENGTH) goto fail;
    if(hdr->pubkey_num >= NUM_KNOWN_PUBKEYS) goto fail;
 8001c46:	6960      	ldr	r0, [r4, #20]
 8001c48:	2805      	cmp	r0, #5
 8001c4a:	bf8c      	ite	hi
 8001c4c:	2000      	movhi	r0, #0
 8001c4e:	2001      	movls	r0, #1
 8001c50:	bd10      	pop	{r4, pc}

    return true;
fail:
    return false;
 8001c52:	4618      	mov	r0, r3
 8001c54:	bd10      	pop	{r4, pc}
 8001c56:	2000      	movs	r0, #0
}
 8001c58:	bd10      	pop	{r4, pc}
 8001c5a:	bf00      	nop
 8001c5c:	cc001234 	.word	0xcc001234

08001c60 <verify_signature>:
//
// Given double-sha256 over the firmware bytes, check the signature.
//
    bool
verify_signature(const coldcardFirmwareHeader_t *hdr, const uint8_t fw_check[32])
{
 8001c60:	b573      	push	{r0, r1, r4, r5, r6, lr}
    // this takes a few ms at least, not fast.
    int ok = uECC_verify(approved_pubkeys[hdr->pubkey_num], fw_check, 32,
 8001c62:	4a0c      	ldr	r2, [pc, #48]	; (8001c94 <verify_signature+0x34>)
 8001c64:	6944      	ldr	r4, [r0, #20]
//
// Given double-sha256 over the firmware bytes, check the signature.
//
    bool
verify_signature(const coldcardFirmwareHeader_t *hdr, const uint8_t fw_check[32])
{
 8001c66:	4605      	mov	r5, r0
    // this takes a few ms at least, not fast.
    int ok = uECC_verify(approved_pubkeys[hdr->pubkey_num], fw_check, 32,
 8001c68:	eb02 1484 	add.w	r4, r2, r4, lsl #6
//
// Given double-sha256 over the firmware bytes, check the signature.
//
    bool
verify_signature(const coldcardFirmwareHeader_t *hdr, const uint8_t fw_check[32])
{
 8001c6c:	460e      	mov	r6, r1
    // this takes a few ms at least, not fast.
    int ok = uECC_verify(approved_pubkeys[hdr->pubkey_num], fw_check, 32,
 8001c6e:	f004 fdb9 	bl	80067e4 <uECC_secp256k1>
 8001c72:	f105 0340 	add.w	r3, r5, #64	; 0x40
 8001c76:	9000      	str	r0, [sp, #0]
 8001c78:	2220      	movs	r2, #32
 8001c7a:	4631      	mov	r1, r6
 8001c7c:	4620      	mov	r0, r4
 8001c7e:	f005 f83f 	bl	8006d00 <uECC_verify>
 8001c82:	4604      	mov	r4, r0
                                    hdr->signature, uECC_secp256k1());

    //puts(ok ? "Sig ok" : "Sig fail");
    rng_delay();
 8001c84:	f000 fd5b 	bl	800273e <rng_delay>

    return ok;
}
 8001c88:	1c20      	adds	r0, r4, #0
 8001c8a:	bf18      	it	ne
 8001c8c:	2001      	movne	r0, #1
 8001c8e:	b002      	add	sp, #8
 8001c90:	bd70      	pop	{r4, r5, r6, pc}
 8001c92:	bf00      	nop
 8001c94:	0800e1e7 	.word	0x0800e1e7

08001c98 <verify_firmware_in_ram>:
// Check hdr, and even signature of protential new firmware in PSRAM.
// Returns checksum needed for 608
//
    bool
verify_firmware_in_ram(const uint8_t *start, uint32_t len, uint8_t world_check[32])
{
 8001c98:	b5f0      	push	{r4, r5, r6, r7, lr}
    const coldcardFirmwareHeader_t *hdr = (const coldcardFirmwareHeader_t *)
 8001c9a:	f500 547e 	add.w	r4, r0, #16256	; 0x3f80
// Check hdr, and even signature of protential new firmware in PSRAM.
// Returns checksum needed for 608
//
    bool
verify_firmware_in_ram(const uint8_t *start, uint32_t len, uint8_t world_check[32])
{
 8001c9e:	b09d      	sub	sp, #116	; 0x74
 8001ca0:	4606      	mov	r6, r0
    const coldcardFirmwareHeader_t *hdr = (const coldcardFirmwareHeader_t *)
                                                    (start + FW_HEADER_OFFSET);
    uint8_t fw_digest[32];

    // check basics like verison, hw compat, etc
    if(!verify_header(hdr)) goto fail;
 8001ca2:	4620      	mov	r0, r4
// Check hdr, and even signature of protential new firmware in PSRAM.
// Returns checksum needed for 608
//
    bool
verify_firmware_in_ram(const uint8_t *start, uint32_t len, uint8_t world_check[32])
{
 8001ca4:	4617      	mov	r7, r2
    const coldcardFirmwareHeader_t *hdr = (const coldcardFirmwareHeader_t *)
                                                    (start + FW_HEADER_OFFSET);
    uint8_t fw_digest[32];

    // check basics like verison, hw compat, etc
    if(!verify_header(hdr)) goto fail;
 8001ca6:	f7ff ffbb 	bl	8001c20 <verify_header>
 8001caa:	4605      	mov	r5, r0
 8001cac:	2800      	cmp	r0, #0
 8001cae:	d03b      	beq.n	8001d28 <verify_firmware_in_ram+0x90>

    if(check_is_downgrade(hdr->timestamp, (const char *)hdr->version_string)) {
 8001cb0:	f104 010c 	add.w	r1, r4, #12
 8001cb4:	1d20      	adds	r0, r4, #4
 8001cb6:	f7ff ff8f 	bl	8001bd8 <check_is_downgrade>
 8001cba:	4605      	mov	r5, r0
 8001cbc:	b120      	cbz	r0, 8001cc8 <verify_firmware_in_ram+0x30>
        puts("downgrade");
 8001cbe:	481c      	ldr	r0, [pc, #112]	; (8001d30 <verify_firmware_in_ram+0x98>)
 8001cc0:	f002 fffc 	bl	8004cbc <puts>

    checksum_flash(fw_digest, world_check, hdr->firmware_length);

    return true;
fail:
    return false;
 8001cc4:	2500      	movs	r5, #0
    // check basics like verison, hw compat, etc
    if(!verify_header(hdr)) goto fail;

    if(check_is_downgrade(hdr->timestamp, (const char *)hdr->version_string)) {
        puts("downgrade");
        goto fail;
 8001cc6:	e02f      	b.n	8001d28 <verify_firmware_in_ram+0x90>
    }

    rng_delay();
 8001cc8:	f000 fd39 	bl	800273e <rng_delay>

    SHA256_CTX  ctx;
    uint32_t    total_len = 0;

    sha256_init(&ctx);
 8001ccc:	a809      	add	r0, sp, #36	; 0x24
    }

    rng_delay();

    SHA256_CTX  ctx;
    uint32_t    total_len = 0;
 8001cce:	9500      	str	r5, [sp, #0]

    sha256_init(&ctx);
 8001cd0:	f003 fb42 	bl	8005358 <sha256_init>

    // start of firmware up to header's signature
    checksum_more(&ctx, &total_len, start, FW_HEADER_OFFSET + FW_HEADER_SIZE - 64);
 8001cd4:	f44f 537f 	mov.w	r3, #16320	; 0x3fc0
 8001cd8:	4632      	mov	r2, r6
 8001cda:	4669      	mov	r1, sp
 8001cdc:	a809      	add	r0, sp, #36	; 0x24
 8001cde:	f7ff feaf 	bl	8001a40 <checksum_more>

    // from after header to end
    checksum_more(&ctx, &total_len, start + FW_HEADER_OFFSET + FW_HEADER_SIZE, 
 8001ce2:	69a3      	ldr	r3, [r4, #24]
 8001ce4:	f506 4280 	add.w	r2, r6, #16384	; 0x4000
 8001ce8:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
 8001cec:	4669      	mov	r1, sp
 8001cee:	a809      	add	r0, sp, #36	; 0x24
 8001cf0:	f7ff fea6 	bl	8001a40 <checksum_more>
                            hdr->firmware_length - (FW_HEADER_OFFSET + FW_HEADER_SIZE));

    // double SHA256
    sha256_final(&ctx, fw_digest);
 8001cf4:	a901      	add	r1, sp, #4
 8001cf6:	a809      	add	r0, sp, #36	; 0x24
 8001cf8:	f003 fb84 	bl	8005404 <sha256_final>
    sha256_single(fw_digest, 32, fw_digest);
 8001cfc:	aa01      	add	r2, sp, #4
 8001cfe:	4610      	mov	r0, r2
 8001d00:	2120      	movs	r1, #32
 8001d02:	f003 fb93 	bl	800542c <sha256_single>

    rng_delay();
 8001d06:	f000 fd1a 	bl	800273e <rng_delay>

    if(!verify_signature(hdr, fw_digest)) {
 8001d0a:	a901      	add	r1, sp, #4
 8001d0c:	4620      	mov	r0, r4
 8001d0e:	f7ff ffa7 	bl	8001c60 <verify_signature>
 8001d12:	4605      	mov	r5, r0
 8001d14:	b918      	cbnz	r0, 8001d1e <verify_firmware_in_ram+0x86>
        puts("sig fail");
 8001d16:	4807      	ldr	r0, [pc, #28]	; (8001d34 <verify_firmware_in_ram+0x9c>)
 8001d18:	f002 ffd0 	bl	8004cbc <puts>
        goto fail;
 8001d1c:	e004      	b.n	8001d28 <verify_firmware_in_ram+0x90>
    }

    checksum_flash(fw_digest, world_check, hdr->firmware_length);
 8001d1e:	69a2      	ldr	r2, [r4, #24]
 8001d20:	4639      	mov	r1, r7
 8001d22:	a801      	add	r0, sp, #4
 8001d24:	f7ff fea8 	bl	8001a78 <checksum_flash>

    return true;
fail:
    return false;
}
 8001d28:	4628      	mov	r0, r5
 8001d2a:	b01d      	add	sp, #116	; 0x74
 8001d2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001d2e:	bf00      	nop
 8001d30:	0800e181 	.word	0x0800e181
 8001d34:	0800e18b 	.word	0x0800e18b

08001d38 <verify_world_checksum>:
// - don't set the light at this point.
// - requires bootloader to have been unchanged since world_check recorded (debug issue)
//
    bool
verify_world_checksum(const uint8_t world_check[32])
{
 8001d38:	b510      	push	{r4, lr}
 8001d3a:	4604      	mov	r4, r0
    ae_setup();
 8001d3c:	f000 fe34 	bl	80029a8 <ae_setup>
    ae_pair_unlock();
 8001d40:	f001 f832 	bl	8002da8 <ae_pair_unlock>

    return (ae_checkmac_hard(KEYNUM_firmware, world_check) == 0);
 8001d44:	4621      	mov	r1, r4
 8001d46:	200e      	movs	r0, #14
 8001d48:	f001 f998 	bl	800307c <ae_checkmac_hard>
}
 8001d4c:	fab0 f080 	clz	r0, r0
 8001d50:	0940      	lsrs	r0, r0, #5
 8001d52:	bd10      	pop	{r4, pc}

08001d54 <verify_firmware>:

// verify_firmware()
//
    bool
verify_firmware(void)
{
 8001d54:	b570      	push	{r4, r5, r6, lr}
    STATIC_ASSERT(sizeof(coldcardFirmwareHeader_t) == FW_HEADER_SIZE);

    rng_delay();

    // watch for unprogrammed header. and some 
    if(FW_HDR->version_string[0] == 0xff) goto blank;
 8001d56:	4d21      	ldr	r5, [pc, #132]	; (8001ddc <verify_firmware+0x88>)

// verify_firmware()
//
    bool
verify_firmware(void)
{
 8001d58:	b090      	sub	sp, #64	; 0x40
    STATIC_ASSERT(sizeof(coldcardFirmwareHeader_t) == FW_HEADER_SIZE);

    rng_delay();
 8001d5a:	f000 fcf0 	bl	800273e <rng_delay>

    // watch for unprogrammed header. and some 
    if(FW_HDR->version_string[0] == 0xff) goto blank;
 8001d5e:	7b2b      	ldrb	r3, [r5, #12]
 8001d60:	2bff      	cmp	r3, #255	; 0xff
 8001d62:	d031      	beq.n	8001dc8 <verify_firmware+0x74>
    if(!verify_header(FW_HDR)) goto fail;
 8001d64:	4628      	mov	r0, r5
 8001d66:	f7ff ff5b 	bl	8001c20 <verify_header>
 8001d6a:	b358      	cbz	r0, 8001dc4 <verify_firmware+0x70>

    rng_delay();
 8001d6c:	f000 fce7 	bl	800273e <rng_delay>

    // measure checksum
    uint8_t fw_check[32], world_check[32];
    checksum_flash(fw_check, world_check, 0);
 8001d70:	2200      	movs	r2, #0
 8001d72:	a908      	add	r1, sp, #32
 8001d74:	4668      	mov	r0, sp
 8001d76:	f7ff fe7f 	bl	8001a78 <checksum_flash>

    rng_delay();
 8001d7a:	f000 fce0 	bl	800273e <rng_delay>

    // Verify the signature
    // - use pubkey_num to pick a specific key
    if(!verify_signature(FW_HDR, fw_check)) goto fail;
 8001d7e:	4669      	mov	r1, sp
 8001d80:	4628      	mov	r0, r5
 8001d82:	f7ff ff6d 	bl	8001c60 <verify_signature>
 8001d86:	4604      	mov	r4, r0
 8001d88:	b1e0      	cbz	r0, 8001dc4 <verify_firmware+0x70>
 
    // Push the hash to the SE which might make the Genuine light green,
    // but only if we arrived at same hash before. It decides.
    int not_green = ae_set_gpio_secure(world_check);
 8001d8a:	a808      	add	r0, sp, #32
 8001d8c:	f001 fb7f 	bl	800348e <ae_set_gpio_secure>
 8001d90:	4606      	mov	r6, r0

    rng_delay();
 8001d92:	f000 fcd4 	bl	800273e <rng_delay>

    // show big/slow warning if light is not green
    if(not_green) {
 8001d96:	b126      	cbz	r6, 8001da2 <verify_firmware+0x4e>
        // When light is not green; some part of flash (not firmware area)
        // is changed. these are typically false-positives, unfortunately.
        puts("WARN: Red light");
 8001d98:	4811      	ldr	r0, [pc, #68]	; (8001de0 <verify_firmware+0x8c>)
 8001d9a:	f002 ff8f 	bl	8004cbc <puts>
        warn_fishy_firmware(screen_red_light);
 8001d9e:	4811      	ldr	r0, [pc, #68]	; (8001de4 <verify_firmware+0x90>)
 8001da0:	e005      	b.n	8001dae <verify_firmware+0x5a>
    } else if(FW_HDR->pubkey_num == 0) {
 8001da2:	696b      	ldr	r3, [r5, #20]
 8001da4:	b933      	cbnz	r3, 8001db4 <verify_firmware+0x60>
        // public signing key used; firmware not from Coinkite!
        puts("WARN: Unsigned firmware");
 8001da6:	4810      	ldr	r0, [pc, #64]	; (8001de8 <verify_firmware+0x94>)
 8001da8:	f002 ff88 	bl	8004cbc <puts>
        warn_fishy_firmware(screen_devmode);
 8001dac:	480f      	ldr	r0, [pc, #60]	; (8001dec <verify_firmware+0x98>)
 8001dae:	f7ff ff29 	bl	8001c04 <warn_fishy_firmware>
 8001db2:	e010      	b.n	8001dd6 <verify_firmware+0x82>
    } else {
        oled_show_progress(screen_verify, 100);
 8001db4:	2164      	movs	r1, #100	; 0x64
 8001db6:	480e      	ldr	r0, [pc, #56]	; (8001df0 <verify_firmware+0x9c>)
 8001db8:	f7ff f85e 	bl	8000e78 <oled_show_progress>
        puts("Good firmware");
 8001dbc:	480d      	ldr	r0, [pc, #52]	; (8001df4 <verify_firmware+0xa0>)
 8001dbe:	f002 ff7d 	bl	8004cbc <puts>
 8001dc2:	e008      	b.n	8001dd6 <verify_firmware+0x82>
    }

    return true;

fail:
    puts("corrupt firmware");
 8001dc4:	480c      	ldr	r0, [pc, #48]	; (8001df8 <verify_firmware+0xa4>)
 8001dc6:	e000      	b.n	8001dca <verify_firmware+0x76>
    oled_show(screen_corrupt);
    return false;

blank:
    puts("no firmware");
 8001dc8:	480c      	ldr	r0, [pc, #48]	; (8001dfc <verify_firmware+0xa8>)
 8001dca:	f002 ff77 	bl	8004cbc <puts>
    oled_show(screen_corrupt);
 8001dce:	480c      	ldr	r0, [pc, #48]	; (8001e00 <verify_firmware+0xac>)
 8001dd0:	f7ff f810 	bl	8000df4 <oled_show>
    //enter_dfu();

    return false;
 8001dd4:	2400      	movs	r4, #0
}
 8001dd6:	4620      	mov	r0, r4
 8001dd8:	b010      	add	sp, #64	; 0x40
 8001dda:	bd70      	pop	{r4, r5, r6, pc}
 8001ddc:	08023f80 	.word	0x08023f80
 8001de0:	0800e194 	.word	0x0800e194
 8001de4:	0800dad8 	.word	0x0800dad8
 8001de8:	0800e1a4 	.word	0x0800e1a4
 8001dec:	0800d79e 	.word	0x0800d79e
 8001df0:	0800d62a 	.word	0x0800d62a
 8001df4:	0800e1bc 	.word	0x0800e1bc
 8001df8:	0800e1ca 	.word	0x0800e1ca
 8001dfc:	0800e1db 	.word	0x0800e1db
 8001e00:	0800d6eb 	.word	0x0800d6eb

08001e04 <systick_setup>:
    void
systick_setup(void)
{
    const uint32_t ticks = HCLK_FREQUENCY/1000;

    SysTick->LOAD = (ticks - 1);
 8001e04:	4b03      	ldr	r3, [pc, #12]	; (8001e14 <systick_setup+0x10>)
 8001e06:	4a04      	ldr	r2, [pc, #16]	; (8001e18 <systick_setup+0x14>)
 8001e08:	605a      	str	r2, [r3, #4]
    SysTick->VAL = 0;
 8001e0a:	2200      	movs	r2, #0
 8001e0c:	609a      	str	r2, [r3, #8]
    SysTick->CTRL = SYSTICK_CLKSOURCE_HCLK | SysTick_CTRL_ENABLE_Msk;
 8001e0e:	2205      	movs	r2, #5
 8001e10:	601a      	str	r2, [r3, #0]
 8001e12:	4770      	bx	lr
 8001e14:	e000e010 	.word	0xe000e010
 8001e18:	0001d4bf 	.word	0x0001d4bf

08001e1c <system_init0>:
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#endif

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 8001e1c:	4a0e      	ldr	r2, [pc, #56]	; (8001e58 <system_init0+0x3c>)
 8001e1e:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8001e22:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8001e26:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
#endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8001e2a:	4b0c      	ldr	r3, [pc, #48]	; (8001e5c <system_init0+0x40>)
 8001e2c:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000U;
 8001e2e:	2100      	movs	r1, #0
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
#endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8001e30:	f042 0201 	orr.w	r2, r2, #1
 8001e34:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000U;
 8001e36:	6099      	str	r1, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= 0xEAF6FFFFU;
 8001e38:	681a      	ldr	r2, [r3, #0]
 8001e3a:	f022 52a8 	bic.w	r2, r2, #352321536	; 0x15000000
 8001e3e:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
 8001e42:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00001000U;
 8001e44:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8001e48:	60da      	str	r2, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8001e4a:	681a      	ldr	r2, [r3, #0]
 8001e4c:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8001e50:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000U;
 8001e52:	6199      	str	r1, [r3, #24]
 8001e54:	4770      	bx	lr
 8001e56:	bf00      	nop
 8001e58:	e000ed00 	.word	0xe000ed00
 8001e5c:	40021000 	.word	0x40021000

08001e60 <clocks_setup>:

// clocks_setup()
//
    void
clocks_setup(void)
{
 8001e60:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

    // setup power supplies
    HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);

    // Configure LSE Drive Capability
    __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
 8001e64:	4c42      	ldr	r4, [pc, #264]	; (8001f70 <clocks_setup+0x110>)

// clocks_setup()
//
    void
clocks_setup(void)
{
 8001e66:	b0c1      	sub	sp, #260	; 0x104
    RCC_ClkInitTypeDef RCC_ClkInitStruct;
    RCC_OscInitTypeDef RCC_OscInitStruct;

    // setup power supplies
    HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);
 8001e68:	2000      	movs	r0, #0
 8001e6a:	f005 f8e9 	bl	8007040 <HAL_PWREx_ControlVoltageScaling>

    // Configure LSE Drive Capability
    __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
 8001e6e:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 8001e72:	f023 0318 	bic.w	r3, r3, #24
 8001e76:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90

    // Enable HSE Oscillator and activate PLL with HSE as source
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8001e7a:	2301      	movs	r3, #1
 8001e7c:	930a      	str	r3, [sp, #40]	; 0x28

    RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8001e7e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8001e82:	930b      	str	r3, [sp, #44]	; 0x2c
    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;

    // Select PLL as system clock source and configure
    // the HCLK, PCLK1 and PCLK2 clocks dividers
    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK 
 8001e84:	230f      	movs	r3, #15

    // Enable HSE Oscillator and activate PLL with HSE as source
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;

    RCC_OscInitStruct.HSEState = RCC_HSE_ON;
    RCC_OscInitStruct.LSEState = RCC_LSE_OFF;
 8001e86:	2500      	movs	r5, #0
    RCC_OscInitStruct.MSIState = RCC_MSI_OFF;

    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8001e88:	2602      	movs	r6, #2

    RCC_OscInitStruct.HSEState = RCC_HSE_ON;
    RCC_OscInitStruct.LSEState = RCC_LSE_OFF;
    RCC_OscInitStruct.MSIState = RCC_MSI_OFF;

    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8001e8a:	2703      	movs	r7, #3
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;

    // Select PLL as system clock source and configure
    // the HCLK, PCLK1 and PCLK2 clocks dividers
    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK 
 8001e8c:	9305      	str	r3, [sp, #20]
                                    | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;

    RCC_OscInitStruct.PLL.PLLM = CKCC_CLK_PLLM;
    RCC_OscInitStruct.PLL.PLLN = CKCC_CLK_PLLN;
    RCC_OscInitStruct.PLL.PLLP = CKCC_CLK_PLLP;
 8001e8e:	f04f 0807 	mov.w	r8, #7
    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK 
                                    | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;

    RCC_OscInitStruct.PLL.PLLM = CKCC_CLK_PLLM;
    RCC_OscInitStruct.PLL.PLLN = CKCC_CLK_PLLN;
 8001e92:	233c      	movs	r3, #60	; 0x3c
    RCC_OscInitStruct.PLL.PLLP = CKCC_CLK_PLLP;
    RCC_OscInitStruct.PLL.PLLQ = CKCC_CLK_PLLQ;
 8001e94:	f04f 0905 	mov.w	r9, #5

    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

    HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8001e98:	a80a      	add	r0, sp, #40	; 0x28
    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK 
                                    | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;

    RCC_OscInitStruct.PLL.PLLM = CKCC_CLK_PLLM;
    RCC_OscInitStruct.PLL.PLLN = CKCC_CLK_PLLN;
 8001e9a:	9317      	str	r3, [sp, #92]	; 0x5c

    // Enable HSE Oscillator and activate PLL with HSE as source
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;

    RCC_OscInitStruct.HSEState = RCC_HSE_ON;
    RCC_OscInitStruct.LSEState = RCC_LSE_OFF;
 8001e9c:	950c      	str	r5, [sp, #48]	; 0x30
    RCC_OscInitStruct.MSIState = RCC_MSI_OFF;
 8001e9e:	9510      	str	r5, [sp, #64]	; 0x40

    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8001ea0:	9715      	str	r7, [sp, #84]	; 0x54
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8001ea2:	9614      	str	r6, [sp, #80]	; 0x50

    // Select PLL as system clock source and configure
    // the HCLK, PCLK1 and PCLK2 clocks dividers
    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK 
                                    | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8001ea4:	9706      	str	r7, [sp, #24]

    RCC_OscInitStruct.PLL.PLLM = CKCC_CLK_PLLM;
 8001ea6:	9616      	str	r6, [sp, #88]	; 0x58
    RCC_OscInitStruct.PLL.PLLN = CKCC_CLK_PLLN;
    RCC_OscInitStruct.PLL.PLLP = CKCC_CLK_PLLP;
 8001ea8:	f8cd 8060 	str.w	r8, [sp, #96]	; 0x60
    RCC_OscInitStruct.PLL.PLLQ = CKCC_CLK_PLLQ;
 8001eac:	f8cd 9064 	str.w	r9, [sp, #100]	; 0x64
    RCC_OscInitStruct.PLL.PLLR = CKCC_CLK_PLLR;
 8001eb0:	961a      	str	r6, [sp, #104]	; 0x68

    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8001eb2:	9507      	str	r5, [sp, #28]
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8001eb4:	9508      	str	r5, [sp, #32]
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8001eb6:	9509      	str	r5, [sp, #36]	; 0x24

    HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8001eb8:	f006 fb92 	bl	80085e0 <HAL_RCC_OscConfig>

    HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
 8001ebc:	4649      	mov	r1, r9
 8001ebe:	a805      	add	r0, sp, #20
 8001ec0:	f006 fe48 	bl	8008b54 <HAL_RCC_ClockConfig>

    // DIS-able MSI-Hardware auto calibration mode with LSE
    CLEAR_BIT(RCC->CR, RCC_CR_MSIPLLEN);
 8001ec4:	6823      	ldr	r3, [r4, #0]
 8001ec6:	f023 0304 	bic.w	r3, r3, #4
 8001eca:	6023      	str	r3, [r4, #0]

    RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SAI1|RCC_PERIPHCLK_I2C2
 8001ecc:	4b29      	ldr	r3, [pc, #164]	; (8001f74 <clocks_setup+0x114>)
 8001ece:	931b      	str	r3, [sp, #108]	; 0x6c

    // PLLSAI is used to clock USB, ADC, I2C1 and RNG. The frequency is
    // HSE(8MHz)/PLLM(2)*PLLSAI1N(24)/PLLSAIQ(2) = 48MHz.
    //
    PeriphClkInitStruct.Sai1ClockSelection = RCC_SAI1CLKSOURCE_PLLSAI1;
    PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
 8001ed0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8001ed4:	933b      	str	r3, [sp, #236]	; 0xec
    PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;
 8001ed6:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8001eda:	9338      	str	r3, [sp, #224]	; 0xe0
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;           // XXX wrong?
    PeriphClkInitStruct.RngClockSelection = RCC_RNGCLKSOURCE_PLLSAI1;
 8001edc:	933a      	str	r3, [sp, #232]	; 0xe8

    PeriphClkInitStruct.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_HSE;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1M = 2;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1N = 24;
 8001ede:	2318      	movs	r3, #24
    // HSE(8MHz)/PLLM(2)*PLLSAI1N(24)/PLLSAIQ(2) = 48MHz.
    //
    PeriphClkInitStruct.Sai1ClockSelection = RCC_SAI1CLKSOURCE_PLLSAI1;
    PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
    PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;           // XXX wrong?
 8001ee0:	f44f 7280 	mov.w	r2, #256	; 0x100
    PeriphClkInitStruct.RngClockSelection = RCC_RNGCLKSOURCE_PLLSAI1;

    PeriphClkInitStruct.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_HSE;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1M = 2;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1N = 24;
 8001ee4:	931e      	str	r3, [sp, #120]	; 0x78
    PeriphClkInitStruct.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_SAI1CLK
                                                 |RCC_PLLSAI1_48M2CLK
                                                 |RCC_PLLSAI1_ADC1CLK;

    HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
 8001ee6:	a81b      	add	r0, sp, #108	; 0x6c
    PeriphClkInitStruct.PLLSAI1.PLLSAI1M = 2;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1N = 24;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_SAI1CLK
 8001ee8:	4b23      	ldr	r3, [pc, #140]	; (8001f78 <clocks_setup+0x118>)
    // HSE(8MHz)/PLLM(2)*PLLSAI1N(24)/PLLSAIQ(2) = 48MHz.
    //
    PeriphClkInitStruct.Sai1ClockSelection = RCC_SAI1CLKSOURCE_PLLSAI1;
    PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
    PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;           // XXX wrong?
 8001eea:	923f      	str	r2, [sp, #252]	; 0xfc
    PeriphClkInitStruct.PLLSAI1.PLLSAI1M = 2;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1N = 24;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_SAI1CLK
 8001eec:	9322      	str	r3, [sp, #136]	; 0x88
    RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SAI1|RCC_PERIPHCLK_I2C2
                                              |RCC_PERIPHCLK_USB |RCC_PERIPHCLK_ADC
                                              |RCC_PERIPHCLK_RNG |RCC_PERIPHCLK_RTC;

    PeriphClkInitStruct.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
 8001eee:	9531      	str	r5, [sp, #196]	; 0xc4

    // PLLSAI is used to clock USB, ADC, I2C1 and RNG. The frequency is
    // HSE(8MHz)/PLLM(2)*PLLSAI1N(24)/PLLSAIQ(2) = 48MHz.
    //
    PeriphClkInitStruct.Sai1ClockSelection = RCC_SAI1CLKSOURCE_PLLSAI1;
 8001ef0:	9536      	str	r5, [sp, #216]	; 0xd8
    PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
    PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;           // XXX wrong?
    PeriphClkInitStruct.RngClockSelection = RCC_RNGCLKSOURCE_PLLSAI1;

    PeriphClkInitStruct.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_HSE;
 8001ef2:	971c      	str	r7, [sp, #112]	; 0x70
    PeriphClkInitStruct.PLLSAI1.PLLSAI1M = 2;
 8001ef4:	961d      	str	r6, [sp, #116]	; 0x74
    PeriphClkInitStruct.PLLSAI1.PLLSAI1N = 24;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
 8001ef6:	f8cd 807c 	str.w	r8, [sp, #124]	; 0x7c
    PeriphClkInitStruct.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
 8001efa:	9620      	str	r6, [sp, #128]	; 0x80
    PeriphClkInitStruct.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
 8001efc:	9621      	str	r6, [sp, #132]	; 0x84
    PeriphClkInitStruct.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_SAI1CLK
                                                 |RCC_PLLSAI1_48M2CLK
                                                 |RCC_PLLSAI1_ADC1CLK;

    HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
 8001efe:	f007 f96f 	bl	80091e0 <HAL_RCCEx_PeriphCLKConfig>

    __HAL_RCC_RTC_ENABLE();
 8001f02:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 8001f06:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001f0a:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
    __HAL_RCC_HASH_CLK_ENABLE();        // for SHA256
 8001f0e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8001f10:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001f14:	64e3      	str	r3, [r4, #76]	; 0x4c
 8001f16:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8001f18:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001f1c:	9301      	str	r3, [sp, #4]
 8001f1e:	9b01      	ldr	r3, [sp, #4]
    __HAL_RCC_SPI1_CLK_ENABLE();        // for OLED
 8001f20:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8001f22:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8001f26:	6623      	str	r3, [r4, #96]	; 0x60
 8001f28:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8001f2a:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8001f2e:	9302      	str	r3, [sp, #8]
 8001f30:	9b02      	ldr	r3, [sp, #8]
    //__HAL_RCC_SPI2_CLK_ENABLE();        // for SPI flash
    __HAL_RCC_DMAMUX1_CLK_ENABLE();     // (need this) because code missing in mpy?
 8001f32:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8001f34:	f043 0304 	orr.w	r3, r3, #4
 8001f38:	64a3      	str	r3, [r4, #72]	; 0x48
 8001f3a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8001f3c:	f003 0304 	and.w	r3, r3, #4
 8001f40:	9303      	str	r3, [sp, #12]
 8001f42:	9b03      	ldr	r3, [sp, #12]

    // for SE2
    __HAL_RCC_I2C2_CLK_ENABLE();
 8001f44:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8001f46:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8001f4a:	65a3      	str	r3, [r4, #88]	; 0x58
 8001f4c:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8001f4e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8001f52:	9304      	str	r3, [sp, #16]
 8001f54:	9b04      	ldr	r3, [sp, #16]
    __HAL_RCC_I2C2_FORCE_RESET();
 8001f56:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001f58:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8001f5c:	63a3      	str	r3, [r4, #56]	; 0x38
    __HAL_RCC_I2C2_RELEASE_RESET();
 8001f5e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001f60:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8001f64:	63a3      	str	r3, [r4, #56]	; 0x38

    // setup SYSTICK, but we don't have the irq hooked up and not using HAL
    // but we use it in polling mode for delay_ms()
    systick_setup();
 8001f66:	f7ff ff4d 	bl	8001e04 <systick_setup>

}
 8001f6a:	b041      	add	sp, #260	; 0x104
 8001f6c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8001f70:	40021000 	.word	0x40021000
 8001f74:	00066880 	.word	0x00066880
 8001f78:	01110000 	.word	0x01110000

08001f7c <flash_ob_lock.part.1>:
    } else {

        // write changes to OB flash bytes

        // Set OPTSTRT bit
        SET_BIT(FLASH->CR, FLASH_CR_OPTSTRT);
 8001f7c:	4b14      	ldr	r3, [pc, #80]	; (8001fd0 <flash_ob_lock.part.1+0x54>)
 8001f7e:	695a      	ldr	r2, [r3, #20]
 8001f80:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8001f84:	615a      	str	r2, [r3, #20]
    __attribute__((section(".ramfunc")))
    __attribute__((always_inline))
    static inline uint32_t
_flash_wait_done(void)
{
    while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) {
 8001f86:	6919      	ldr	r1, [r3, #16]
 8001f88:	4a11      	ldr	r2, [pc, #68]	; (8001fd0 <flash_ob_lock.part.1+0x54>)
 8001f8a:	03c9      	lsls	r1, r1, #15
 8001f8c:	d4fb      	bmi.n	8001f86 <flash_ob_lock.part.1+0xa>
        // busy wait
    }

    uint32_t error = (FLASH->SR & FLASH_FLAG_SR_ERRORS);
 8001f8e:	6911      	ldr	r1, [r2, #16]
    if(error) {
 8001f90:	4b10      	ldr	r3, [pc, #64]	; (8001fd4 <flash_ob_lock.part.1+0x58>)
 8001f92:	400b      	ands	r3, r1
 8001f94:	b923      	cbnz	r3, 8001fa0 <flash_ob_lock.part.1+0x24>
        // Save an error code; somewhat random, depends on chip details
        return error;
    }

    // Check FLASH End of Operation flag
    if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP)) {
 8001f96:	6913      	ldr	r3, [r2, #16]
 8001f98:	07d8      	lsls	r0, r3, #31
        // Clear FLASH End of Operation pending bit
        __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8001f9a:	bf44      	itt	mi
 8001f9c:	2301      	movmi	r3, #1
 8001f9e:	6113      	strmi	r3, [r2, #16]

        /// Wait for update to complete
        _flash_wait_done();

        // lock OB again.
        SET_BIT(FLASH->CR, FLASH_CR_OPTLOCK);
 8001fa0:	4b0b      	ldr	r3, [pc, #44]	; (8001fd0 <flash_ob_lock.part.1+0x54>)
 8001fa2:	695a      	ldr	r2, [r3, #20]
 8001fa4:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8001fa8:	615a      	str	r2, [r3, #20]

        // include "launch" to make them take effect NOW
        SET_BIT(FLASH->CR, FLASH_CR_OBL_LAUNCH);
 8001faa:	695a      	ldr	r2, [r3, #20]
 8001fac:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 8001fb0:	615a      	str	r2, [r3, #20]
    __attribute__((section(".ramfunc")))
    __attribute__((always_inline))
    static inline uint32_t
_flash_wait_done(void)
{
    while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) {
 8001fb2:	6919      	ldr	r1, [r3, #16]
 8001fb4:	4a06      	ldr	r2, [pc, #24]	; (8001fd0 <flash_ob_lock.part.1+0x54>)
 8001fb6:	03c9      	lsls	r1, r1, #15
 8001fb8:	d4fb      	bmi.n	8001fb2 <flash_ob_lock.part.1+0x36>
        // busy wait
    }

    uint32_t error = (FLASH->SR & FLASH_FLAG_SR_ERRORS);
 8001fba:	6911      	ldr	r1, [r2, #16]
    if(error) {
 8001fbc:	4b05      	ldr	r3, [pc, #20]	; (8001fd4 <flash_ob_lock.part.1+0x58>)
 8001fbe:	400b      	ands	r3, r1
 8001fc0:	b923      	cbnz	r3, 8001fcc <flash_ob_lock.part.1+0x50>
        // Save an error code; somewhat random, depends on chip details
        return error;
    }

    // Check FLASH End of Operation flag
    if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP)) {
 8001fc2:	6913      	ldr	r3, [r2, #16]
 8001fc4:	07db      	lsls	r3, r3, #31
        // Clear FLASH End of Operation pending bit
        __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8001fc6:	bf44      	itt	mi
 8001fc8:	2301      	movmi	r3, #1
 8001fca:	6113      	strmi	r3, [r2, #16]
 8001fcc:	4770      	bx	lr
 8001fce:	bf00      	nop
 8001fd0:	40022000 	.word	0x40022000
 8001fd4:	0002c3fa 	.word	0x0002c3fa

08001fd8 <flash_setup0>:

// flash_setup0()
//
    void
flash_setup0(void)
{
 8001fd8:	b507      	push	{r0, r1, r2, lr}
    // bits in the same bank. Cannot read bank while programming it.
    // Therefore, must have our programming code running in RAM.

    // put the ram-callable functions into place
    extern uint8_t _srelocate, _etext, _erelocate;
    memcpy(&_srelocate, &_etext, ((uint32_t)&_erelocate)-(uint32_t)&_srelocate);
 8001fda:	4809      	ldr	r0, [pc, #36]	; (8002000 <flash_setup0+0x28>)
 8001fdc:	4a09      	ldr	r2, [pc, #36]	; (8002004 <flash_setup0+0x2c>)
 8001fde:	490a      	ldr	r1, [pc, #40]	; (8002008 <flash_setup0+0x30>)
 8001fe0:	1a12      	subs	r2, r2, r0
 8001fe2:	f00b fa4e 	bl	800d482 <memcpy>

    // turn on clock to flash registers
    __HAL_RCC_FLASH_CLK_ENABLE();
 8001fe6:	4b09      	ldr	r3, [pc, #36]	; (800200c <flash_setup0+0x34>)
 8001fe8:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8001fea:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001fee:	649a      	str	r2, [r3, #72]	; 0x48
 8001ff0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8001ff2:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8001ff6:	9301      	str	r3, [sp, #4]
 8001ff8:	9b01      	ldr	r3, [sp, #4]
}
 8001ffa:	b003      	add	sp, #12
 8001ffc:	f85d fb04 	ldr.w	pc, [sp], #4
 8002000:	20000000 	.word	0x20000000
 8002004:	20000164 	.word	0x20000164
 8002008:	0800e78c 	.word	0x0800e78c
 800200c:	40021000 	.word	0x40021000

08002010 <flash_lock>:
//
    void
flash_lock(void)
{
    // see HAL_FLASH_Lock();
    SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 8002010:	4a02      	ldr	r2, [pc, #8]	; (800201c <flash_lock+0xc>)
 8002012:	6953      	ldr	r3, [r2, #20]
 8002014:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8002018:	6153      	str	r3, [r2, #20]
 800201a:	4770      	bx	lr
 800201c:	40022000 	.word	0x40022000

08002020 <flash_unlock>:
//
// Ok to run from flash.
//
    void
flash_unlock(void)
{
 8002020:	b508      	push	{r3, lr}
    // see HAL_FLASH_Unlock();
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK)) {
 8002022:	4b08      	ldr	r3, [pc, #32]	; (8002044 <flash_unlock+0x24>)
 8002024:	695a      	ldr	r2, [r3, #20]
 8002026:	2a00      	cmp	r2, #0
 8002028:	da0a      	bge.n	8002040 <flash_unlock+0x20>
        // Authorize the FLASH Registers access
        WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 800202a:	4a07      	ldr	r2, [pc, #28]	; (8002048 <flash_unlock+0x28>)
 800202c:	609a      	str	r2, [r3, #8]
        WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 800202e:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
 8002032:	609a      	str	r2, [r3, #8]

        if(READ_BIT(FLASH->CR, FLASH_CR_LOCK)) {
 8002034:	695b      	ldr	r3, [r3, #20]
 8002036:	2b00      	cmp	r3, #0
 8002038:	da02      	bge.n	8002040 <flash_unlock+0x20>
            INCONSISTENT("failed to unlock");
 800203a:	4804      	ldr	r0, [pc, #16]	; (800204c <flash_unlock+0x2c>)
 800203c:	f7fe fcce 	bl	80009dc <fatal_error>
 8002040:	bd08      	pop	{r3, pc}
 8002042:	bf00      	nop
 8002044:	40022000 	.word	0x40022000
 8002048:	45670123 	.word	0x45670123
 800204c:	0800d55f 	.word	0x0800d55f

08002050 <flash_ob_lock>:
// - also does "launch" when done
// - also locks/unlocks the main flash
//
    void
flash_ob_lock(bool lock)
{
 8002050:	b510      	push	{r4, lr}
    if(!lock) {
 8002052:	b980      	cbnz	r0, 8002076 <flash_ob_lock+0x26>
        // unlock sequence
        if(READ_BIT(FLASH->CR, FLASH_CR_OPTLOCK)) {
 8002054:	4c0a      	ldr	r4, [pc, #40]	; (8002080 <flash_ob_lock+0x30>)
 8002056:	6963      	ldr	r3, [r4, #20]
 8002058:	005a      	lsls	r2, r3, #1
 800205a:	d510      	bpl.n	800207e <flash_ob_lock+0x2e>
            flash_unlock();
 800205c:	f7ff ffe0 	bl	8002020 <flash_unlock>

            WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY1);
 8002060:	4b08      	ldr	r3, [pc, #32]	; (8002084 <flash_ob_lock+0x34>)
 8002062:	60e3      	str	r3, [r4, #12]
            WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY2);
 8002064:	f103 3344 	add.w	r3, r3, #1145324612	; 0x44444444
 8002068:	60e3      	str	r3, [r4, #12]

            if(READ_BIT(FLASH->CR, FLASH_CR_OPTLOCK)) {
 800206a:	6963      	ldr	r3, [r4, #20]
 800206c:	005b      	lsls	r3, r3, #1
 800206e:	d506      	bpl.n	800207e <flash_ob_lock+0x2e>
                INCONSISTENT("failed to OB unlock");
 8002070:	4805      	ldr	r0, [pc, #20]	; (8002088 <flash_ob_lock+0x38>)
 8002072:	f7fe fcb3 	bl	80009dc <fatal_error>
        // include "launch" to make them take effect NOW
        SET_BIT(FLASH->CR, FLASH_CR_OBL_LAUNCH);

        _flash_wait_done();
    }
}
 8002076:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800207a:	f7ff bf7f 	b.w	8001f7c <flash_ob_lock.part.1>
 800207e:	bd10      	pop	{r4, pc}
 8002080:	40022000 	.word	0x40022000
 8002084:	08192a3b 	.word	0x08192a3b
 8002088:	0800d55f 	.word	0x0800d55f

0800208c <pick_pairing_secret>:

// pick_pairing_secret()
//
    static void
pick_pairing_secret(void)
{
 800208c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002090:	f2ad 4d24 	subw	sp, sp, #1060	; 0x424
    // important the RNG works here. ok to call setup multiple times.
    rng_setup();
 8002094:	f000 fb10 	bl	80026b8 <rng_setup>
 8002098:	24c8      	movs	r4, #200	; 0xc8

    // Demo to anyone watching that the RNG is working, but likely only
    // to be seen by production team during initial powerup.
    uint8_t    tmp[1024];
    for(int i=0; i<200; i++) {
        rng_buffer(tmp, sizeof(tmp));
 800209a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800209e:	a808      	add	r0, sp, #32
 80020a0:	f000 fb36 	bl	8002710 <rng_buffer>

        oled_show_raw(sizeof(tmp), (void *)tmp);
 80020a4:	a908      	add	r1, sp, #32
 80020a6:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80020aa:	f7fe fe77 	bl	8000d9c <oled_show_raw>
    rng_setup();

    // Demo to anyone watching that the RNG is working, but likely only
    // to be seen by production team during initial powerup.
    uint8_t    tmp[1024];
    for(int i=0; i<200; i++) {
 80020ae:	3c01      	subs	r4, #1
 80020b0:	d1f3      	bne.n	800209a <pick_pairing_secret+0xe>
        rng_buffer(tmp, sizeof(tmp));

        oled_show_raw(sizeof(tmp), (void *)tmp);
    }

    oled_factory_busy();
 80020b2:	f7fe ff63 	bl	8000f7c <oled_factory_busy>

    // .. but don't use those numbers, because those are semi-public now.
    uint32_t secret[8];
    for(int i=0; i<8; i++) {
        secret[i] = rng_sample();
 80020b6:	f000 faeb 	bl	8002690 <rng_sample>
 80020ba:	f84d 0024 	str.w	r0, [sp, r4, lsl #2]

    oled_factory_busy();

    // .. but don't use those numbers, because those are semi-public now.
    uint32_t secret[8];
    for(int i=0; i<8; i++) {
 80020be:	3401      	adds	r4, #1
 80020c0:	2c08      	cmp	r4, #8
 80020c2:	d1f8      	bne.n	80020b6 <pick_pairing_secret+0x2a>
        secret[i] = rng_sample();
    }

    // enforce policy that first word is not all ones (so it never
    // looks like unprogrammed flash).
    while(secret[0] == ~0) {
 80020c4:	9b00      	ldr	r3, [sp, #0]
 80020c6:	3301      	adds	r3, #1
 80020c8:	d103      	bne.n	80020d2 <pick_pairing_secret+0x46>
        secret[0] = rng_sample();
 80020ca:	f000 fae1 	bl	8002690 <rng_sample>
 80020ce:	9000      	str	r0, [sp, #0]
 80020d0:	e7f8      	b.n	80020c4 <pick_pairing_secret+0x38>

    // Write pairing secret into flash
    {
        uint32_t dest = (uint32_t)&rom_secrets->pairing_secret;

        flash_unlock();
 80020d2:	f7ff ffa5 	bl	8002020 <flash_unlock>
 80020d6:	2400      	movs	r4, #0
        for(int i=0; i<8; i+=2, dest += 8) {
            uint64_t    val = (((uint64_t)secret[i]) << 32) | secret[i+1];
 80020d8:	eb0d 0304 	add.w	r3, sp, r4

            if(flash_burn(dest, val)) {
 80020dc:	f85d 9004 	ldr.w	r9, [sp, r4]
 80020e0:	685a      	ldr	r2, [r3, #4]
 80020e2:	f04f 0800 	mov.w	r8, #0
 80020e6:	4640      	mov	r0, r8
 80020e8:	4649      	mov	r1, r9
 80020ea:	ea40 0002 	orr.w	r0, r0, r2
 80020ee:	4602      	mov	r2, r0
 80020f0:	f104 6000 	add.w	r0, r4, #134217728	; 0x8000000
 80020f4:	460b      	mov	r3, r1
 80020f6:	f500 30f0 	add.w	r0, r0, #122880	; 0x1e000
 80020fa:	f00b fa1d 	bl	800d538 <__flash_burn_veneer>
 80020fe:	b110      	cbz	r0, 8002106 <pick_pairing_secret+0x7a>
                INCONSISTENT("flash fail");
 8002100:	4811      	ldr	r0, [pc, #68]	; (8002148 <pick_pairing_secret+0xbc>)
 8002102:	f7fe fc6b 	bl	80009dc <fatal_error>
 8002106:	3408      	adds	r4, #8
    // Write pairing secret into flash
    {
        uint32_t dest = (uint32_t)&rom_secrets->pairing_secret;

        flash_unlock();
        for(int i=0; i<8; i+=2, dest += 8) {
 8002108:	2c20      	cmp	r4, #32
 800210a:	d1e5      	bne.n	80020d8 <pick_pairing_secret+0x4c>

            if(flash_burn(dest, val)) {
                INCONSISTENT("flash fail");
            }
        }
        flash_lock();
 800210c:	f7ff ff80 	bl	8002010 <flash_lock>
                                + sizeof(rom_secrets->mcu_hmac_key);

        STATIC_ASSERT(offsetof(rom_secrets_t, hash_cache_secret) % 8 == 0);
        STATIC_ASSERT(blen % 8 == 0);

        flash_unlock();
 8002110:	f7ff ff86 	bl	8002020 <flash_unlock>
    }

    // Also at this point, pick some RNG noise to use as our non-changing
    // bits of various things.
    {
        uint32_t dest = (uint32_t)&rom_secrets->hash_cache_secret;
 8002114:	4c0d      	ldr	r4, [pc, #52]	; (800214c <pick_pairing_secret+0xc0>)

        STATIC_ASSERT(offsetof(rom_secrets_t, hash_cache_secret) % 8 == 0);
        STATIC_ASSERT(blen % 8 == 0);

        flash_unlock();
        for(int i=0; i<blen; i+=8, dest += 8) {
 8002116:	4d0e      	ldr	r5, [pc, #56]	; (8002150 <pick_pairing_secret+0xc4>)
            uint64_t    val = ((uint64_t)rng_sample() << 32) | rng_sample();
 8002118:	f000 faba 	bl	8002690 <rng_sample>
 800211c:	4680      	mov	r8, r0
 800211e:	f000 fab7 	bl	8002690 <rng_sample>

            if(flash_burn(dest, val)) {
 8002122:	2600      	movs	r6, #0
 8002124:	ea46 0200 	orr.w	r2, r6, r0
 8002128:	4643      	mov	r3, r8
 800212a:	4620      	mov	r0, r4
 800212c:	f00b fa04 	bl	800d538 <__flash_burn_veneer>
 8002130:	2800      	cmp	r0, #0
 8002132:	d1e5      	bne.n	8002100 <pick_pairing_secret+0x74>

        STATIC_ASSERT(offsetof(rom_secrets_t, hash_cache_secret) % 8 == 0);
        STATIC_ASSERT(blen % 8 == 0);

        flash_unlock();
        for(int i=0; i<blen; i+=8, dest += 8) {
 8002134:	3408      	adds	r4, #8
 8002136:	42ac      	cmp	r4, r5
 8002138:	d1ee      	bne.n	8002118 <pick_pairing_secret+0x8c>

            if(flash_burn(dest, val)) {
                INCONSISTENT("flash fail");
            }
        }
        flash_lock();
 800213a:	f7ff ff69 	bl	8002010 <flash_lock>
    }
    
}
 800213e:	f20d 4d24 	addw	sp, sp, #1060	; 0x424
 8002142:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8002146:	bf00      	nop
 8002148:	0800d55f 	.word	0x0800d55f
 800214c:	0801e070 	.word	0x0801e070
 8002150:	0801e0b0 	.word	0x0801e0b0

08002154 <flash_save_ae_serial>:
//
// Write the serial number of ATECC608 into flash forever.
//
    void
flash_save_ae_serial(const uint8_t serial[9])
{
 8002154:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8002156:	4604      	mov	r4, r0

    uint64_t    tmp[2];
    memset(&tmp, 0x0, sizeof(tmp));
 8002158:	2210      	movs	r2, #16
 800215a:	2100      	movs	r1, #0
 800215c:	4668      	mov	r0, sp
 800215e:	f00b f9b6 	bl	800d4ce <memset>
    memcpy(&tmp, serial, 9);
 8002162:	6820      	ldr	r0, [r4, #0]
 8002164:	6861      	ldr	r1, [r4, #4]
 8002166:	7a22      	ldrb	r2, [r4, #8]
 8002168:	466b      	mov	r3, sp
 800216a:	c303      	stmia	r3!, {r0, r1}
 800216c:	701a      	strb	r2, [r3, #0]

    flash_setup0();
 800216e:	f7ff ff33 	bl	8001fd8 <flash_setup0>
    flash_unlock();
 8002172:	f7ff ff55 	bl	8002020 <flash_unlock>

    if(flash_burn((uint32_t)&rom_secrets->ae_serial_number[0], tmp[0])) {
 8002176:	e9dd 2300 	ldrd	r2, r3, [sp]
 800217a:	4809      	ldr	r0, [pc, #36]	; (80021a0 <flash_save_ae_serial+0x4c>)
 800217c:	f00b f9dc 	bl	800d538 <__flash_burn_veneer>
 8002180:	b110      	cbz	r0, 8002188 <flash_save_ae_serial+0x34>
        INCONSISTENT("fail1");
 8002182:	4808      	ldr	r0, [pc, #32]	; (80021a4 <flash_save_ae_serial+0x50>)
 8002184:	f7fe fc2a 	bl	80009dc <fatal_error>
    }
    if(flash_burn((uint32_t)&rom_secrets->ae_serial_number[1], tmp[1])) {
 8002188:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800218c:	4806      	ldr	r0, [pc, #24]	; (80021a8 <flash_save_ae_serial+0x54>)
 800218e:	f00b f9d3 	bl	800d538 <__flash_burn_veneer>
 8002192:	2800      	cmp	r0, #0
 8002194:	d1f5      	bne.n	8002182 <flash_save_ae_serial+0x2e>
        INCONSISTENT("fail2");
    }

    flash_lock();
}
 8002196:	b004      	add	sp, #16
 8002198:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    }
    if(flash_burn((uint32_t)&rom_secrets->ae_serial_number[1], tmp[1])) {
        INCONSISTENT("fail2");
    }

    flash_lock();
 800219c:	f7ff bf38 	b.w	8002010 <flash_lock>
 80021a0:	0801e040 	.word	0x0801e040
 80021a4:	0800d55f 	.word	0x0800d55f
 80021a8:	0801e048 	.word	0x0801e048

080021ac <flash_save_bag_number>:
//
// Write bag number (probably a string)
//
    void
flash_save_bag_number(const uint8_t new_number[32])
{
 80021ac:	b570      	push	{r4, r5, r6, lr}
 80021ae:	4605      	mov	r5, r0

    uint32_t dest = (uint32_t)&rom_secrets->bag_number[0];
    uint64_t *src = (uint64_t *)new_number;

    flash_setup0();
 80021b0:	f7ff ff12 	bl	8001fd8 <flash_setup0>
    flash_unlock();
 80021b4:	f7ff ff34 	bl	8002020 <flash_unlock>
//
    void
flash_save_bag_number(const uint8_t new_number[32])
{

    uint32_t dest = (uint32_t)&rom_secrets->bag_number[0];
 80021b8:	4c09      	ldr	r4, [pc, #36]	; (80021e0 <flash_save_bag_number+0x34>)
    flash_setup0();
    flash_unlock();

    // NOTE: can only write once! No provision for read/check, and write
    // when non-ones will fail.
    for(int i=0; i<(32/8); i++, dest+=8, src++) {
 80021ba:	4e0a      	ldr	r6, [pc, #40]	; (80021e4 <flash_save_bag_number+0x38>)
 80021bc:	3d08      	subs	r5, #8
        if(flash_burn(dest, *src)) {
 80021be:	e9f5 2302 	ldrd	r2, r3, [r5, #8]!
 80021c2:	4620      	mov	r0, r4
 80021c4:	f00b f9b8 	bl	800d538 <__flash_burn_veneer>
 80021c8:	b110      	cbz	r0, 80021d0 <flash_save_bag_number+0x24>
            INCONSISTENT("fail write");
 80021ca:	4807      	ldr	r0, [pc, #28]	; (80021e8 <flash_save_bag_number+0x3c>)
 80021cc:	f7fe fc06 	bl	80009dc <fatal_error>
    flash_setup0();
    flash_unlock();

    // NOTE: can only write once! No provision for read/check, and write
    // when non-ones will fail.
    for(int i=0; i<(32/8); i++, dest+=8, src++) {
 80021d0:	3408      	adds	r4, #8
 80021d2:	42b4      	cmp	r4, r6
 80021d4:	d1f3      	bne.n	80021be <flash_save_bag_number+0x12>
            INCONSISTENT("fail write");
        }
    }

    flash_lock();
}
 80021d6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        if(flash_burn(dest, *src)) {
            INCONSISTENT("fail write");
        }
    }

    flash_lock();
 80021da:	f7ff bf19 	b.w	8002010 <flash_lock>
 80021de:	bf00      	nop
 80021e0:	0801e050 	.word	0x0801e050
 80021e4:	0801e070 	.word	0x0801e070
 80021e8:	0800d55f 	.word	0x0800d55f

080021ec <flash_save_se2_data>:
// Save bunch of stuff related to SE2. Allow updates to sections that are
// given as ones at this point.
//
    void
flash_save_se2_data(const se2_secrets_t *se2)
{
 80021ec:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 80021f0:	4605      	mov	r5, r0
    uint8_t *dest = (uint8_t *)&rom_secrets->se2;
    uint8_t *src = (uint8_t *)se2;

    STATIC_ASSERT(offsetof(rom_secrets_t, se2) % 8 == 0);

    flash_setup0();
 80021f2:	f7ff fef1 	bl	8001fd8 <flash_setup0>
    flash_unlock();
 80021f6:	f7ff ff13 	bl	8002020 <flash_unlock>
// given as ones at this point.
//
    void
flash_save_se2_data(const se2_secrets_t *se2)
{
    uint8_t *dest = (uint8_t *)&rom_secrets->se2;
 80021fa:	4c17      	ldr	r4, [pc, #92]	; (8002258 <flash_save_se2_data+0x6c>)
    STATIC_ASSERT(offsetof(rom_secrets_t, se2) % 8 == 0);

    flash_setup0();
    flash_unlock();

    for(int i=0; i<(sizeof(se2_secrets_t)/8); i++, dest+=8, src+=8) {
 80021fc:	f8df 8064 	ldr.w	r8, [pc, #100]	; 8002264 <flash_save_se2_data+0x78>
        uint64_t val;
        memcpy(&val, src, sizeof(val));
 8002200:	6828      	ldr	r0, [r5, #0]
 8002202:	6869      	ldr	r1, [r5, #4]
 8002204:	466b      	mov	r3, sp
 8002206:	c303      	stmia	r3!, {r0, r1}

        // don't write if all ones or already written correctly
        if(val == ~0) continue;
 8002208:	e9dd 6700 	ldrd	r6, r7, [sp]
 800220c:	1c7b      	adds	r3, r7, #1
 800220e:	bf08      	it	eq
 8002210:	f1b6 3fff 	cmpeq.w	r6, #4294967295	; 0xffffffff
 8002214:	d015      	beq.n	8002242 <flash_save_se2_data+0x56>
        if(check_equal(dest, src, 8)) continue;
 8002216:	2208      	movs	r2, #8
 8002218:	4629      	mov	r1, r5
 800221a:	4620      	mov	r0, r4
 800221c:	f000 fa27 	bl	800266e <check_equal>
 8002220:	b978      	cbnz	r0, 8002242 <flash_save_se2_data+0x56>

        // can't write if not ones already
        ASSERT(check_all_ones(dest, 8));
 8002222:	2108      	movs	r1, #8
 8002224:	4620      	mov	r0, r4
 8002226:	f000 fa0b 	bl	8002640 <check_all_ones>
 800222a:	b908      	cbnz	r0, 8002230 <flash_save_se2_data+0x44>
 800222c:	480b      	ldr	r0, [pc, #44]	; (800225c <flash_save_se2_data+0x70>)
 800222e:	e006      	b.n	800223e <flash_save_se2_data+0x52>

        if(flash_burn((uint32_t)dest, val)) {
 8002230:	4632      	mov	r2, r6
 8002232:	463b      	mov	r3, r7
 8002234:	4620      	mov	r0, r4
 8002236:	f00b f97f 	bl	800d538 <__flash_burn_veneer>
 800223a:	b110      	cbz	r0, 8002242 <flash_save_se2_data+0x56>
            INCONSISTENT("fail write");
 800223c:	4808      	ldr	r0, [pc, #32]	; (8002260 <flash_save_se2_data+0x74>)
 800223e:	f7fe fbcd 	bl	80009dc <fatal_error>
    STATIC_ASSERT(offsetof(rom_secrets_t, se2) % 8 == 0);

    flash_setup0();
    flash_unlock();

    for(int i=0; i<(sizeof(se2_secrets_t)/8); i++, dest+=8, src+=8) {
 8002242:	3408      	adds	r4, #8
 8002244:	4544      	cmp	r4, r8
 8002246:	f105 0508 	add.w	r5, r5, #8
 800224a:	d1d9      	bne.n	8002200 <flash_save_se2_data+0x14>
            INCONSISTENT("fail write");
        }
    }

    flash_lock();
}
 800224c:	b002      	add	sp, #8
 800224e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        if(flash_burn((uint32_t)dest, val)) {
            INCONSISTENT("fail write");
        }
    }

    flash_lock();
 8002252:	f7ff bedd 	b.w	8002010 <flash_lock>
 8002256:	bf00      	nop
 8002258:	0801e0b0 	.word	0x0801e0b0
 800225c:	0800d558 	.word	0x0800d558
 8002260:	0800d55f 	.word	0x0800d55f
 8002264:	0801e190 	.word	0x0801e190

08002268 <flash_setup>:
//
// This is really a state-machine, to recover boards that are booted w/ missing AE chip.
//
    void
flash_setup(void)
{
 8002268:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

    // see if we have picked a pairing secret yet.
    // NOTE: critical section for glitching (at least in past versions)
    //  - check_all.. functions have a rng_delay in them already
    rng_delay();
    bool blank_ps = check_all_ones(rom_secrets->pairing_secret, 32);
 800226c:	4c40      	ldr	r4, [pc, #256]	; (8002370 <flash_setup+0x108>)
//
// This is really a state-machine, to recover boards that are booted w/ missing AE chip.
//
    void
flash_setup(void)
{
 800226e:	b089      	sub	sp, #36	; 0x24
    flash_setup0();
 8002270:	f7ff feb2 	bl	8001fd8 <flash_setup0>
    STATIC_ASSERT(sizeof(rom_secrets_t) <= 0x2000);

    // see if we have picked a pairing secret yet.
    // NOTE: critical section for glitching (at least in past versions)
    //  - check_all.. functions have a rng_delay in them already
    rng_delay();
 8002274:	f000 fa63 	bl	800273e <rng_delay>
    bool blank_ps = check_all_ones(rom_secrets->pairing_secret, 32);
 8002278:	2120      	movs	r1, #32
 800227a:	4620      	mov	r0, r4
 800227c:	f000 f9e0 	bl	8002640 <check_all_ones>
    bool zeroed_ps = check_all_zeros(rom_secrets->pairing_secret, 32);
 8002280:	2120      	movs	r1, #32

    // see if we have picked a pairing secret yet.
    // NOTE: critical section for glitching (at least in past versions)
    //  - check_all.. functions have a rng_delay in them already
    rng_delay();
    bool blank_ps = check_all_ones(rom_secrets->pairing_secret, 32);
 8002282:	4680      	mov	r8, r0
    bool zeroed_ps = check_all_zeros(rom_secrets->pairing_secret, 32);
 8002284:	4620      	mov	r0, r4
 8002286:	f000 f9e3 	bl	8002650 <check_all_zeros>
    bool blank_xor = check_all_ones(rom_secrets->pairing_secret_xor, 32);
 800228a:	2120      	movs	r1, #32
    // see if we have picked a pairing secret yet.
    // NOTE: critical section for glitching (at least in past versions)
    //  - check_all.. functions have a rng_delay in them already
    rng_delay();
    bool blank_ps = check_all_ones(rom_secrets->pairing_secret, 32);
    bool zeroed_ps = check_all_zeros(rom_secrets->pairing_secret, 32);
 800228c:	4681      	mov	r9, r0
    bool blank_xor = check_all_ones(rom_secrets->pairing_secret_xor, 32);
 800228e:	4839      	ldr	r0, [pc, #228]	; (8002374 <flash_setup+0x10c>)
 8002290:	f000 f9d6 	bl	8002640 <check_all_ones>
    bool blank_ae = (~rom_secrets->ae_serial_number[0] == 0);
 8002294:	e9d4 6710 	ldrd	r6, r7, [r4, #64]	; 0x40
    // NOTE: critical section for glitching (at least in past versions)
    //  - check_all.. functions have a rng_delay in them already
    rng_delay();
    bool blank_ps = check_all_ones(rom_secrets->pairing_secret, 32);
    bool zeroed_ps = check_all_zeros(rom_secrets->pairing_secret, 32);
    bool blank_xor = check_all_ones(rom_secrets->pairing_secret_xor, 32);
 8002298:	4605      	mov	r5, r0
    bool blank_ae = (~rom_secrets->ae_serial_number[0] == 0);
    rng_delay();
 800229a:	f000 fa50 	bl	800273e <rng_delay>

    if(zeroed_ps) {
 800229e:	f1b9 0f00 	cmp.w	r9, #0
 80022a2:	d004      	beq.n	80022ae <flash_setup+0x46>
        // fast brick process leaves us w/ zero pairing secret
        oled_show(screen_brick);
 80022a4:	4834      	ldr	r0, [pc, #208]	; (8002378 <flash_setup+0x110>)
 80022a6:	f7fe fda5 	bl	8000df4 <oled_show>
        LOCKUP_FOREVER();
 80022aa:	bf30      	wfi
 80022ac:	e7fd      	b.n	80022aa <flash_setup+0x42>
    }

    if(blank_ps) {
 80022ae:	f1b8 0f00 	cmp.w	r8, #0
 80022b2:	d001      	beq.n	80022b8 <flash_setup+0x50>
        // get some good entropy, save it.
        pick_pairing_secret();
 80022b4:	f7ff feea 	bl	800208c <pick_pairing_secret>

        blank_ps = false;
    }

    if(blank_xor || blank_ae) {
 80022b8:	b925      	cbnz	r5, 80022c4 <flash_setup+0x5c>
 80022ba:	3701      	adds	r7, #1
 80022bc:	bf08      	it	eq
 80022be:	f1b6 3fff 	cmpeq.w	r6, #4294967295	; 0xffffffff
 80022c2:	d12e      	bne.n	8002322 <flash_setup+0xba>

        // setup the SE2 (mostly). handles failures by dying
        se2_setup_config();
 80022c4:	f005 fa78 	bl	80077b8 <se2_setup_config>

        // configure and lock-down the SE1
        int rv = ae_setup_config();
 80022c8:	f001 f962 	bl	8003590 <ae_setup_config>
 80022cc:	4604      	mov	r4, r0

        rng_delay();
 80022ce:	f000 fa36 	bl	800273e <rng_delay>
        if(rv) {
 80022d2:	b13c      	cbz	r4, 80022e4 <flash_setup+0x7c>
            // Hardware fail speaking to AE chip ... be careful not to brick here.
            // Do not continue!! We might fix the board, or add missing pullup, etc.
            oled_show(screen_se1_issue);
 80022d4:	4829      	ldr	r0, [pc, #164]	; (800237c <flash_setup+0x114>)
 80022d6:	f7fe fd8d 	bl	8000df4 <oled_show>
            puts("SE1 config fail");
 80022da:	4829      	ldr	r0, [pc, #164]	; (8002380 <flash_setup+0x118>)
 80022dc:	f002 fcee 	bl	8004cbc <puts>

            LOCKUP_FOREVER();
 80022e0:	bf30      	wfi
 80022e2:	e7fd      	b.n	80022e0 <flash_setup+0x78>
        }

        rng_delay();
 80022e4:	f000 fa2b 	bl	800273e <rng_delay>
        if(blank_xor) {
 80022e8:	b19d      	cbz	r5, 8002312 <flash_setup+0xaa>
    // BUT: so we are just using this to mark the 2nd half of a two-phase commit w.r.t SE1 setup

    uint64_t *src = (uint64_t *)&rom_secrets->pairing_secret;
    uint32_t dest = (uint32_t)&rom_secrets->pairing_secret_xor;

    flash_unlock();
 80022ea:	f7ff fe99 	bl	8002020 <flash_unlock>
 80022ee:	4c25      	ldr	r4, [pc, #148]	; (8002384 <flash_setup+0x11c>)
    for(int i=0; i<(32/8); i++, dest+=8, src++) {
 80022f0:	4d25      	ldr	r5, [pc, #148]	; (8002388 <flash_setup+0x120>)
 80022f2:	f104 0028 	add.w	r0, r4, #40	; 0x28
        uint64_t    val = ~(*src);

        if(flash_burn(dest, val)) {
 80022f6:	e9f4 2302 	ldrd	r2, r3, [r4, #8]!
 80022fa:	43d2      	mvns	r2, r2
 80022fc:	43db      	mvns	r3, r3
 80022fe:	f00b f91b 	bl	800d538 <__flash_burn_veneer>
 8002302:	b110      	cbz	r0, 800230a <flash_setup+0xa2>
            INCONSISTENT("flash xor fail");
 8002304:	4821      	ldr	r0, [pc, #132]	; (800238c <flash_setup+0x124>)
 8002306:	f7fe fb69 	bl	80009dc <fatal_error>

    uint64_t *src = (uint64_t *)&rom_secrets->pairing_secret;
    uint32_t dest = (uint32_t)&rom_secrets->pairing_secret_xor;

    flash_unlock();
    for(int i=0; i<(32/8); i++, dest+=8, src++) {
 800230a:	42ac      	cmp	r4, r5
 800230c:	d1f1      	bne.n	80022f2 <flash_setup+0x8a>

        if(flash_burn(dest, val)) {
            INCONSISTENT("flash xor fail");
        }
    }
    flash_lock();
 800230e:	f7ff fe7f 	bl	8002010 <flash_lock>
            // write secret again, complemented, to indicate successful AE programming
            confirm_pairing_secret();
        }

        // real power cycle required now.
        oled_show(screen_replug);
 8002312:	481f      	ldr	r0, [pc, #124]	; (8002390 <flash_setup+0x128>)
 8002314:	f7fe fd6e 	bl	8000df4 <oled_show>
        puts("replug required");
 8002318:	481e      	ldr	r0, [pc, #120]	; (8002394 <flash_setup+0x12c>)
 800231a:	f002 fccf 	bl	8004cbc <puts>

        LOCKUP_FOREVER();
 800231e:	bf30      	wfi
 8002320:	e7fd      	b.n	800231e <flash_setup+0xb6>

    rng_delay();
    if(!blank_ps && !blank_xor) {
        // check the XOR value also written: 2 phase commit
        uint8_t tmp[32];
        memcpy(tmp, rom_secrets->pairing_secret, 32);
 8002322:	4d13      	ldr	r5, [pc, #76]	; (8002370 <flash_setup+0x108>)
        puts("replug required");

        LOCKUP_FOREVER();
    }

    rng_delay();
 8002324:	f000 fa0b 	bl	800273e <rng_delay>
    if(!blank_ps && !blank_xor) {
        // check the XOR value also written: 2 phase commit
        uint8_t tmp[32];
        memcpy(tmp, rom_secrets->pairing_secret, 32);
 8002328:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800232a:	466c      	mov	r4, sp
 800232c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800232e:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8002332:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 8002336:	4a18      	ldr	r2, [pc, #96]	; (8002398 <flash_setup+0x130>)
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 8002338:	4c18      	ldr	r4, [pc, #96]	; (800239c <flash_setup+0x134>)
 800233a:	466b      	mov	r3, sp
 800233c:	4668      	mov	r0, sp
		*(acc) ^= *(more);
 800233e:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 8002342:	781d      	ldrb	r5, [r3, #0]
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 8002344:	42a2      	cmp	r2, r4
		*(acc) ^= *(more);
 8002346:	ea81 0105 	eor.w	r1, r1, r5
 800234a:	f803 1b01 	strb.w	r1, [r3], #1
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 800234e:	d1f6      	bne.n	800233e <flash_setup+0xd6>
        xor_mixin(tmp, rom_secrets->pairing_secret_xor, 32);

        if(!check_all_ones(tmp, 32)) {
 8002350:	2120      	movs	r1, #32
 8002352:	f000 f975 	bl	8002640 <check_all_ones>
 8002356:	b938      	cbnz	r0, 8002368 <flash_setup+0x100>
            oled_show(screen_corrupt);
 8002358:	4811      	ldr	r0, [pc, #68]	; (80023a0 <flash_setup+0x138>)
 800235a:	f7fe fd4b 	bl	8000df4 <oled_show>
            puts("corrupt pair sec");
 800235e:	4811      	ldr	r0, [pc, #68]	; (80023a4 <flash_setup+0x13c>)
 8002360:	f002 fcac 	bl	8004cbc <puts>

            // dfu won't save them here, so just die
            LOCKUP_FOREVER();
 8002364:	bf30      	wfi
 8002366:	e7fd      	b.n	8002364 <flash_setup+0xfc>
    // That's fine if we intend to ship units locked already.
    
    // Do NOT do write every boot, as it might wear-out
    // the flash bits in OB.

}
 8002368:	b009      	add	sp, #36	; 0x24
 800236a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800236e:	bf00      	nop
 8002370:	0801e000 	.word	0x0801e000
 8002374:	0801e020 	.word	0x0801e020
 8002378:	0800de5b 	.word	0x0800de5b
 800237c:	0800e0ef 	.word	0x0800e0ef
 8002380:	0800e367 	.word	0x0800e367
 8002384:	0801dff8 	.word	0x0801dff8
 8002388:	0801e018 	.word	0x0801e018
 800238c:	0800d55f 	.word	0x0800d55f
 8002390:	0800ddfa 	.word	0x0800ddfa
 8002394:	0800e377 	.word	0x0800e377
 8002398:	0801e01f 	.word	0x0801e01f
 800239c:	0801e03f 	.word	0x0801e03f
 80023a0:	0800d6eb 	.word	0x0800d6eb
 80023a4:	0800e387 	.word	0x0800e387

080023a8 <flash_lockdown_hard>:
// 
// This is a one-way trip. Might need power cycle to (fully?) take effect.
//
    void
flash_lockdown_hard(uint8_t rdp_level_code)
{
 80023a8:	b510      	push	{r4, lr}
 80023aa:	4604      	mov	r4, r0
    flash_setup0();
 80023ac:	f7ff fe14 	bl	8001fd8 <flash_setup0>

    // see FLASH_OB_WRPConfig()

    flash_ob_lock(false);
 80023b0:	2000      	movs	r0, #0
 80023b2:	f7ff fe4d 	bl	8002050 <flash_ob_lock>
        // lock first 32k against any writes
        FLASH->WRP1AR = (num_pages_locked << 16);
 80023b6:	4b08      	ldr	r3, [pc, #32]	; (80023d8 <flash_lockdown_hard+0x30>)
 80023b8:	f44f 12f8 	mov.w	r2, #2031616	; 0x1f0000
 80023bc:	62da      	str	r2, [r3, #44]	; 0x2c
        FLASH->WRP1BR = 0xff;      // unused.
 80023be:	22ff      	movs	r2, #255	; 0xff
 80023c0:	631a      	str	r2, [r3, #48]	; 0x30
        FLASH->WRP2AR = 0xff;      // unused.
 80023c2:	64da      	str	r2, [r3, #76]	; 0x4c
        FLASH->WRP2BR = 0xff;      // unused.
 80023c4:	651a      	str	r2, [r3, #80]	; 0x50
        //    the RDP level is decreased from Level 1 to Level 0)."
        // - D-bus access blocked, even for code running inside the PCROP area! (AN4758)
        //   So literal values and constant tables and such would need special linking.

        // set protection level
        uint32_t was = FLASH->OPTR & ~0xff;
 80023c6:	6a1a      	ldr	r2, [r3, #32]
        FLASH->OPTR = was | rdp_level_code;    // select level X, other values as observed
 80023c8:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 80023cc:	4314      	orrs	r4, r2
 80023ce:	621c      	str	r4, [r3, #32]

    flash_ob_lock(true);
}
 80023d0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80023d4:	f7ff bdd2 	b.w	8001f7c <flash_ob_lock.part.1>
 80023d8:	40022000 	.word	0x40022000

080023dc <record_highwater_version>:

// record_highwater_version()
//
    int
record_highwater_version(const uint8_t timestamp[8])
{
 80023dc:	b573      	push	{r0, r1, r4, r5, r6, lr}
    const uint8_t *otp = (const uint8_t *)OPT_FLASH_BASE;

    ASSERT(timestamp[0] < 0x40);
    ASSERT(timestamp[0] >= 0x10);
 80023de:	7803      	ldrb	r3, [r0, #0]
 80023e0:	3b10      	subs	r3, #16
 80023e2:	2b2f      	cmp	r3, #47	; 0x2f

// record_highwater_version()
//
    int
record_highwater_version(const uint8_t timestamp[8])
{
 80023e4:	4605      	mov	r5, r0
    const uint8_t *otp = (const uint8_t *)OPT_FLASH_BASE;

    ASSERT(timestamp[0] < 0x40);
    ASSERT(timestamp[0] >= 0x10);
 80023e6:	d902      	bls.n	80023ee <record_highwater_version+0x12>
    int
record_highwater_version(const uint8_t timestamp[8])
{
    const uint8_t *otp = (const uint8_t *)OPT_FLASH_BASE;

    ASSERT(timestamp[0] < 0x40);
 80023e8:	4810      	ldr	r0, [pc, #64]	; (800242c <record_highwater_version+0x50>)
 80023ea:	f7fe faf7 	bl	80009dc <fatal_error>
 80023ee:	4c10      	ldr	r4, [pc, #64]	; (8002430 <record_highwater_version+0x54>)
    ASSERT(timestamp[0] >= 0x10);

    // just write to first blank slot we can find.
    for(int i=0; i<NUM_OPT_SLOTS; i++, otp+=8) {
 80023f0:	4e10      	ldr	r6, [pc, #64]	; (8002434 <record_highwater_version+0x58>)
        if(check_all_ones(otp, 8)) {
 80023f2:	2108      	movs	r1, #8
 80023f4:	4620      	mov	r0, r4
 80023f6:	f000 f923 	bl	8002640 <check_all_ones>
 80023fa:	b180      	cbz	r0, 800241e <record_highwater_version+0x42>
            // here.
            uint64_t val = 0;
            memcpy(&val, timestamp, 8);
 80023fc:	6869      	ldr	r1, [r5, #4]
 80023fe:	6828      	ldr	r0, [r5, #0]
 8002400:	466b      	mov	r3, sp
 8002402:	c303      	stmia	r3!, {r0, r1}

            flash_setup0();
 8002404:	f7ff fde8 	bl	8001fd8 <flash_setup0>

            flash_unlock();
 8002408:	f7ff fe0a 	bl	8002020 <flash_unlock>
                flash_burn((uint32_t)otp, val);
 800240c:	e9dd 2300 	ldrd	r2, r3, [sp]
 8002410:	4620      	mov	r0, r4
 8002412:	f00b f891 	bl	800d538 <__flash_burn_veneer>
            flash_lock();
 8002416:	f7ff fdfb 	bl	8002010 <flash_lock>

            return 0;
 800241a:	2000      	movs	r0, #0
 800241c:	e003      	b.n	8002426 <record_highwater_version+0x4a>

    ASSERT(timestamp[0] < 0x40);
    ASSERT(timestamp[0] >= 0x10);

    // just write to first blank slot we can find.
    for(int i=0; i<NUM_OPT_SLOTS; i++, otp+=8) {
 800241e:	3408      	adds	r4, #8
 8002420:	42b4      	cmp	r4, r6
 8002422:	d1e6      	bne.n	80023f2 <record_highwater_version+0x16>
            return 0;
        }
    }

    // no space.
    return 1;
 8002424:	2001      	movs	r0, #1
}
 8002426:	b002      	add	sp, #8
 8002428:	bd70      	pop	{r4, r5, r6, pc}
 800242a:	bf00      	nop
 800242c:	0800d558 	.word	0x0800d558
 8002430:	1fff7000 	.word	0x1fff7000
 8002434:	1fff7400 	.word	0x1fff7400

08002438 <mcu_key_get>:

// mcu_key_get()
//
    const mcu_key_t *
mcu_key_get(bool *valid)
{
 8002438:	b570      	push	{r4, r5, r6, lr}
    // get current "mcu_key" value; first byte will never be 0x0 or 0xff
    // - except if no key set yet/recently wiped
    // - if none set, returns ptr to first available slot which will be all ones
    const mcu_key_t *ptr = rom_secrets->mcu_keys, *avail=NULL;

    for(int i=0; i<numberof(rom_secrets->mcu_keys); i++, ptr++) {
 800243a:	4a0d      	ldr	r2, [pc, #52]	; (8002470 <mcu_key_get+0x38>)
mcu_key_get(bool *valid)
{
    // get current "mcu_key" value; first byte will never be 0x0 or 0xff
    // - except if no key set yet/recently wiped
    // - if none set, returns ptr to first available slot which will be all ones
    const mcu_key_t *ptr = rom_secrets->mcu_keys, *avail=NULL;
 800243c:	4c0d      	ldr	r4, [pc, #52]	; (8002474 <mcu_key_get+0x3c>)

// mcu_key_get()
//
    const mcu_key_t *
mcu_key_get(bool *valid)
{
 800243e:	4606      	mov	r6, r0
    // get current "mcu_key" value; first byte will never be 0x0 or 0xff
    // - except if no key set yet/recently wiped
    // - if none set, returns ptr to first available slot which will be all ones
    const mcu_key_t *ptr = rom_secrets->mcu_keys, *avail=NULL;
 8002440:	2500      	movs	r5, #0

    for(int i=0; i<numberof(rom_secrets->mcu_keys); i++, ptr++) {
        if(ptr->value[0] == 0xff) {
 8002442:	7823      	ldrb	r3, [r4, #0]
 8002444:	2bff      	cmp	r3, #255	; 0xff
 8002446:	d103      	bne.n	8002450 <mcu_key_get+0x18>
            if(!avail) {
 8002448:	2d00      	cmp	r5, #0
 800244a:	bf08      	it	eq
 800244c:	4625      	moveq	r5, r4
 800244e:	e006      	b.n	800245e <mcu_key_get+0x26>
                avail = ptr;
            }
        } else if(ptr->value[0] != 0x00) {
 8002450:	b12b      	cbz	r3, 800245e <mcu_key_get+0x26>
            rng_delay();
 8002452:	f000 f974 	bl	800273e <rng_delay>
            *valid = true;
 8002456:	2301      	movs	r3, #1
 8002458:	7033      	strb	r3, [r6, #0]
            return ptr;
 800245a:	4625      	mov	r5, r4
 800245c:	e006      	b.n	800246c <mcu_key_get+0x34>
    // get current "mcu_key" value; first byte will never be 0x0 or 0xff
    // - except if no key set yet/recently wiped
    // - if none set, returns ptr to first available slot which will be all ones
    const mcu_key_t *ptr = rom_secrets->mcu_keys, *avail=NULL;

    for(int i=0; i<numberof(rom_secrets->mcu_keys); i++, ptr++) {
 800245e:	3420      	adds	r4, #32
 8002460:	4294      	cmp	r4, r2
 8002462:	d1ee      	bne.n	8002442 <mcu_key_get+0xa>
            *valid = true;
            return ptr;
        }
    }

    rng_delay();
 8002464:	f000 f96b 	bl	800273e <rng_delay>
    *valid = false;
 8002468:	2300      	movs	r3, #0
 800246a:	7033      	strb	r3, [r6, #0]
    return avail;
}
 800246c:	4628      	mov	r0, r5
 800246e:	bd70      	pop	{r4, r5, r6, pc}
 8002470:	0801f190 	.word	0x0801f190
 8002474:	0801e190 	.word	0x0801e190

08002478 <mcu_key_clear>:

// mcu_key_clear()
//
    void
mcu_key_clear(const mcu_key_t *cur)
{
 8002478:	b513      	push	{r0, r1, r4, lr}
    if(!cur) {
 800247a:	4604      	mov	r4, r0
 800247c:	b938      	cbnz	r0, 800248e <mcu_key_clear+0x16>
        bool valid;
        cur = mcu_key_get(&valid);
 800247e:	f10d 0007 	add.w	r0, sp, #7
 8002482:	f7ff ffd9 	bl	8002438 <mcu_key_get>

        if(!valid) return;
 8002486:	f89d 3007 	ldrb.w	r3, [sp, #7]
    void
mcu_key_clear(const mcu_key_t *cur)
{
    if(!cur) {
        bool valid;
        cur = mcu_key_get(&valid);
 800248a:	4604      	mov	r4, r0

        if(!valid) return;
 800248c:	b1e3      	cbz	r3, 80024c8 <mcu_key_clear+0x50>

    STATIC_ASSERT(offsetof(rom_secrets_t, mcu_keys) % 8 == 0);

    // no delays here since decision has been made, and don't 
    // want to give them more time to interrupt us
    flash_setup0();
 800248e:	f7ff fda3 	bl	8001fd8 <flash_setup0>
    flash_unlock();
 8002492:	f7ff fdc5 	bl	8002020 <flash_unlock>
        uint32_t  pos = (uint32_t)cur;
        flash_burn(pos, 0); pos += 8;
 8002496:	2200      	movs	r2, #0
 8002498:	2300      	movs	r3, #0
 800249a:	4620      	mov	r0, r4
 800249c:	f00b f84c 	bl	800d538 <__flash_burn_veneer>
        flash_burn(pos, 0); pos += 8;
 80024a0:	2200      	movs	r2, #0
 80024a2:	2300      	movs	r3, #0
 80024a4:	f104 0008 	add.w	r0, r4, #8
 80024a8:	f00b f846 	bl	800d538 <__flash_burn_veneer>
        flash_burn(pos, 0); pos += 8;
 80024ac:	2200      	movs	r2, #0
 80024ae:	2300      	movs	r3, #0
 80024b0:	f104 0010 	add.w	r0, r4, #16
 80024b4:	f00b f840 	bl	800d538 <__flash_burn_veneer>
        flash_burn(pos, 0);
 80024b8:	2200      	movs	r2, #0
 80024ba:	2300      	movs	r3, #0
 80024bc:	f104 0018 	add.w	r0, r4, #24
 80024c0:	f00b f83a 	bl	800d538 <__flash_burn_veneer>
    flash_lock();
 80024c4:	f7ff fda4 	bl	8002010 <flash_lock>
}
 80024c8:	b002      	add	sp, #8
 80024ca:	bd10      	pop	{r4, pc}

080024cc <mcu_key_usage>:

// mcu_key_usage()
//
    void
mcu_key_usage(int *avail_out, int *consumed_out)
{
 80024cc:	b570      	push	{r4, r5, r6, lr}
    const mcu_key_t *ptr = rom_secrets->mcu_keys;
    int avail = 0, used = 0;
 80024ce:	2300      	movs	r3, #0

// mcu_key_usage()
//
    void
mcu_key_usage(int *avail_out, int *consumed_out)
{
 80024d0:	4a08      	ldr	r2, [pc, #32]	; (80024f4 <mcu_key_usage+0x28>)
    const mcu_key_t *ptr = rom_secrets->mcu_keys;
    int avail = 0, used = 0;

    for(int i=0; i<numberof(rom_secrets->mcu_keys); i++, ptr++) {
 80024d2:	4e09      	ldr	r6, [pc, #36]	; (80024f8 <mcu_key_usage+0x2c>)
//
    void
mcu_key_usage(int *avail_out, int *consumed_out)
{
    const mcu_key_t *ptr = rom_secrets->mcu_keys;
    int avail = 0, used = 0;
 80024d4:	461c      	mov	r4, r3

    for(int i=0; i<numberof(rom_secrets->mcu_keys); i++, ptr++) {
        if(ptr->value[0] == 0xff) {
 80024d6:	f812 5c20 	ldrb.w	r5, [r2, #-32]
 80024da:	2dff      	cmp	r5, #255	; 0xff
 80024dc:	d101      	bne.n	80024e2 <mcu_key_usage+0x16>
            avail ++;
 80024de:	3401      	adds	r4, #1
 80024e0:	e001      	b.n	80024e6 <mcu_key_usage+0x1a>
        } else if(ptr->value[0] == 0x00) {
 80024e2:	b905      	cbnz	r5, 80024e6 <mcu_key_usage+0x1a>
            used ++;
 80024e4:	3301      	adds	r3, #1
 80024e6:	3220      	adds	r2, #32
mcu_key_usage(int *avail_out, int *consumed_out)
{
    const mcu_key_t *ptr = rom_secrets->mcu_keys;
    int avail = 0, used = 0;

    for(int i=0; i<numberof(rom_secrets->mcu_keys); i++, ptr++) {
 80024e8:	42b2      	cmp	r2, r6
 80024ea:	d1f4      	bne.n	80024d6 <mcu_key_usage+0xa>
        } else if(ptr->value[0] == 0x00) {
            used ++;
        }
    }

    *avail_out = avail;
 80024ec:	6004      	str	r4, [r0, #0]
    *consumed_out = used;
 80024ee:	600b      	str	r3, [r1, #0]
 80024f0:	bd70      	pop	{r4, r5, r6, pc}
 80024f2:	bf00      	nop
 80024f4:	0801e1b0 	.word	0x0801e1b0
 80024f8:	0801f1b0 	.word	0x0801f1b0

080024fc <mcu_key_pick>:

// mcu_key_pick()
//
    const mcu_key_t *
mcu_key_pick(void)
{
 80024fc:	b530      	push	{r4, r5, lr}
 80024fe:	b08d      	sub	sp, #52	; 0x34
    mcu_key_t       n;

    // get some good entropy, and whiten it just in case.
    do { 
        rng_buffer(n.value, 32);
 8002500:	2120      	movs	r1, #32
 8002502:	a804      	add	r0, sp, #16
 8002504:	f000 f904 	bl	8002710 <rng_buffer>
        sha256_single(n.value, 32, n.value);
 8002508:	aa04      	add	r2, sp, #16
 800250a:	4610      	mov	r0, r2
 800250c:	2120      	movs	r1, #32
 800250e:	f002 ff8d 	bl	800542c <sha256_single>
        sha256_single(n.value, 32, n.value);
 8002512:	aa04      	add	r2, sp, #16
 8002514:	2120      	movs	r1, #32
 8002516:	4610      	mov	r0, r2
 8002518:	f002 ff88 	bl	800542c <sha256_single>
    } while(n.value[0] == 0x0 || n.value[0] == 0xff);
 800251c:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8002520:	3b01      	subs	r3, #1
 8002522:	b2db      	uxtb	r3, r3
 8002524:	2bfd      	cmp	r3, #253	; 0xfd
 8002526:	d8eb      	bhi.n	8002500 <mcu_key_pick+0x4>

    const mcu_key_t *cur;

    do {
        bool valid = false; 
 8002528:	a80c      	add	r0, sp, #48	; 0x30
 800252a:	2300      	movs	r3, #0
 800252c:	f800 3d29 	strb.w	r3, [r0, #-41]!
        cur = mcu_key_get(&valid);
 8002530:	f7ff ff82 	bl	8002438 <mcu_key_get>

        if(!cur) {
 8002534:	4605      	mov	r5, r0
 8002536:	b938      	cbnz	r0, 8002548 <mcu_key_pick+0x4c>
            // no free slots. we are brick.
            puts("mk full");
 8002538:	481b      	ldr	r0, [pc, #108]	; (80025a8 <mcu_key_pick+0xac>)
 800253a:	f002 fbbf 	bl	8004cbc <puts>
            oled_show(screen_brick);
 800253e:	481b      	ldr	r0, [pc, #108]	; (80025ac <mcu_key_pick+0xb0>)
 8002540:	f7fe fc58 	bl	8000df4 <oled_show>

            LOCKUP_FOREVER();
 8002544:	bf30      	wfi
 8002546:	e7fd      	b.n	8002544 <mcu_key_pick+0x48>
        }

        if(valid) {
 8002548:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800254c:	b14b      	cbz	r3, 8002562 <mcu_key_pick+0x66>
            // clear existing key, if it's defined.
            ASSERT(cur->value[0] != 0x00);
 800254e:	7803      	ldrb	r3, [r0, #0]
 8002550:	3b01      	subs	r3, #1
 8002552:	b2db      	uxtb	r3, r3
 8002554:	2bfd      	cmp	r3, #253	; 0xfd
 8002556:	d902      	bls.n	800255e <mcu_key_pick+0x62>
 8002558:	4815      	ldr	r0, [pc, #84]	; (80025b0 <mcu_key_pick+0xb4>)
 800255a:	f7fe fa3f 	bl	80009dc <fatal_error>
            ASSERT(cur->value[0] != 0xff);

            mcu_key_clear(cur);
 800255e:	f7ff ff8b 	bl	8002478 <mcu_key_clear>
            continue;
        }
    } while(0);
    
    // burn it
    flash_setup0();
 8002562:	f7ff fd39 	bl	8001fd8 <flash_setup0>
    flash_unlock();
 8002566:	f7ff fd5b 	bl	8002020 <flash_unlock>
        uint32_t  pos = (uint32_t)cur;
        const uint8_t   *fr = n.value;

        for(int i=0; i<32; i+= 8, pos += 8, fr += 8) {
 800256a:	2400      	movs	r4, #0
            uint64_t v;
            memcpy(&v, fr, sizeof(v));
 800256c:	ab04      	add	r3, sp, #16
 800256e:	191a      	adds	r2, r3, r4
 8002570:	ab02      	add	r3, sp, #8
 8002572:	6810      	ldr	r0, [r2, #0]
 8002574:	6851      	ldr	r1, [r2, #4]
 8002576:	c303      	stmia	r3!, {r0, r1}

            flash_burn(pos, v);
 8002578:	1928      	adds	r0, r5, r4
 800257a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    flash_setup0();
    flash_unlock();
        uint32_t  pos = (uint32_t)cur;
        const uint8_t   *fr = n.value;

        for(int i=0; i<32; i+= 8, pos += 8, fr += 8) {
 800257e:	3408      	adds	r4, #8
            uint64_t v;
            memcpy(&v, fr, sizeof(v));

            flash_burn(pos, v);
 8002580:	f00a ffda 	bl	800d538 <__flash_burn_veneer>
    flash_setup0();
    flash_unlock();
        uint32_t  pos = (uint32_t)cur;
        const uint8_t   *fr = n.value;

        for(int i=0; i<32; i+= 8, pos += 8, fr += 8) {
 8002584:	2c20      	cmp	r4, #32
 8002586:	d1f1      	bne.n	800256c <mcu_key_pick+0x70>
            uint64_t v;
            memcpy(&v, fr, sizeof(v));

            flash_burn(pos, v);
        }
    flash_lock();
 8002588:	f7ff fd42 	bl	8002010 <flash_lock>

#if 1
    // check it
    bool valid = false; 
 800258c:	2300      	movs	r3, #0
    const mcu_key_t *after = mcu_key_get(&valid);
 800258e:	a802      	add	r0, sp, #8
        }
    flash_lock();

#if 1
    // check it
    bool valid = false; 
 8002590:	f88d 3008 	strb.w	r3, [sp, #8]
    const mcu_key_t *after = mcu_key_get(&valid);
 8002594:	f7ff ff50 	bl	8002438 <mcu_key_get>
    ASSERT(valid);
 8002598:	f89d 2008 	ldrb.w	r2, [sp, #8]
 800259c:	2a00      	cmp	r2, #0
 800259e:	d0db      	beq.n	8002558 <mcu_key_pick+0x5c>
    ASSERT(after == cur);
 80025a0:	4285      	cmp	r5, r0
 80025a2:	d1d9      	bne.n	8002558 <mcu_key_pick+0x5c>
#endif

    return cur;
}
 80025a4:	b00d      	add	sp, #52	; 0x34
 80025a6:	bd30      	pop	{r4, r5, pc}
 80025a8:	0800e398 	.word	0x0800e398
 80025ac:	0800de5b 	.word	0x0800de5b
 80025b0:	0800d558 	.word	0x0800d558

080025b4 <fast_brick>:

// fast_brick()
//
    void
fast_brick(void)
{
 80025b4:	b538      	push	{r3, r4, r5, lr}
    flash_setup0();
 80025b6:	f7ff fd0f 	bl	8001fd8 <flash_setup0>
    flash_unlock();
 80025ba:	f7ff fd31 	bl	8002020 <flash_unlock>
        // simply erase all the critical secrets
        flash_page_erase(BL_NVROM_BASE);
 80025be:	480b      	ldr	r0, [pc, #44]	; (80025ec <fast_brick+0x38>)

        // but then write zeros so it doesn't look like unprogrammed part
        for(uint32_t  pos = BL_NVROM_BASE, i=0; i<64/8; i++, pos += 8) {
 80025c0:	4c0a      	ldr	r4, [pc, #40]	; (80025ec <fast_brick+0x38>)
 80025c2:	4d0b      	ldr	r5, [pc, #44]	; (80025f0 <fast_brick+0x3c>)
fast_brick(void)
{
    flash_setup0();
    flash_unlock();
        // simply erase all the critical secrets
        flash_page_erase(BL_NVROM_BASE);
 80025c4:	f00a ffc0 	bl	800d548 <__flash_page_erase_veneer>

        // but then write zeros so it doesn't look like unprogrammed part
        for(uint32_t  pos = BL_NVROM_BASE, i=0; i<64/8; i++, pos += 8) {
            flash_burn(pos, 0);
 80025c8:	4620      	mov	r0, r4
 80025ca:	2200      	movs	r2, #0
 80025cc:	2300      	movs	r3, #0
    flash_unlock();
        // simply erase all the critical secrets
        flash_page_erase(BL_NVROM_BASE);

        // but then write zeros so it doesn't look like unprogrammed part
        for(uint32_t  pos = BL_NVROM_BASE, i=0; i<64/8; i++, pos += 8) {
 80025ce:	3408      	adds	r4, #8
            flash_burn(pos, 0);
 80025d0:	f00a ffb2 	bl	800d538 <__flash_burn_veneer>
    flash_unlock();
        // simply erase all the critical secrets
        flash_page_erase(BL_NVROM_BASE);

        // but then write zeros so it doesn't look like unprogrammed part
        for(uint32_t  pos = BL_NVROM_BASE, i=0; i<64/8; i++, pos += 8) {
 80025d4:	42ac      	cmp	r4, r5
 80025d6:	d1f7      	bne.n	80025c8 <fast_brick+0x14>
            flash_burn(pos, 0);
        }
    flash_lock();
 80025d8:	f7ff fd1a 	bl	8002010 <flash_lock>
    
    puts("fast brck");
 80025dc:	4805      	ldr	r0, [pc, #20]	; (80025f4 <fast_brick+0x40>)
 80025de:	f002 fb6d 	bl	8004cbc <puts>
    oled_show(screen_brick);
 80025e2:	4805      	ldr	r0, [pc, #20]	; (80025f8 <fast_brick+0x44>)
 80025e4:	f7fe fc06 	bl	8000df4 <oled_show>

    LOCKUP_FOREVER();
 80025e8:	bf30      	wfi
 80025ea:	e7fd      	b.n	80025e8 <fast_brick+0x34>
 80025ec:	0801e000 	.word	0x0801e000
 80025f0:	0801e040 	.word	0x0801e040
 80025f4:	0800e3a0 	.word	0x0800e3a0
 80025f8:	0800de5b 	.word	0x0800de5b

080025fc <fast_wipe>:

// fast_wipe()
//
    void
fast_wipe(void)
{
 80025fc:	b508      	push	{r3, lr}
    // dump (part of) the main seed key and become a new Coldcard
    // - lots of other code can and will detect a missing MCU key as "blank"
    // - and the check value on main seed will be garbage now
    mcu_key_clear(NULL);
 80025fe:	2000      	movs	r0, #0
 8002600:	f7ff ff3a 	bl	8002478 <mcu_key_clear>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8002604:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8002608:	4905      	ldr	r1, [pc, #20]	; (8002620 <fast_wipe+0x24>)
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800260a:	4b06      	ldr	r3, [pc, #24]	; (8002624 <fast_wipe+0x28>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800260c:	68ca      	ldr	r2, [r1, #12]
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800260e:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8002612:	4313      	orrs	r3, r2
 8002614:	60cb      	str	r3, [r1, #12]
 8002616:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 800261a:	bf00      	nop
 800261c:	e7fd      	b.n	800261a <fast_wipe+0x1e>
 800261e:	bf00      	nop
 8002620:	e000ed00 	.word	0xe000ed00
 8002624:	05fa0004 	.word	0x05fa0004

08002628 <check_all_ones_raw>:
//
// Lower-level version, needed before RNG ready.
//
	bool
check_all_ones_raw(const void *ptrV, int len)
{
 8002628:	4401      	add	r1, r0
	uint8_t rv = 0xff;
 800262a:	23ff      	movs	r3, #255	; 0xff
	const uint8_t *ptr = (const uint8_t *)ptrV;

	for(; len; len--, ptr++) {
 800262c:	4288      	cmp	r0, r1
 800262e:	d003      	beq.n	8002638 <check_all_ones_raw+0x10>
		rv &= *ptr;
 8002630:	f810 2b01 	ldrb.w	r2, [r0], #1
 8002634:	4013      	ands	r3, r2
 8002636:	e7f9      	b.n	800262c <check_all_ones_raw+0x4>
	}

	return (rv == 0xff);
}
 8002638:	3bff      	subs	r3, #255	; 0xff
 800263a:	4258      	negs	r0, r3
 800263c:	4158      	adcs	r0, r3
 800263e:	4770      	bx	lr

08002640 <check_all_ones>:
//
// Return T if all bytes are 0xFF
//
	bool
check_all_ones(const void *ptrV, int len)
{
 8002640:	b510      	push	{r4, lr}
	bool rv = check_all_ones_raw(ptrV, len);
 8002642:	f7ff fff1 	bl	8002628 <check_all_ones_raw>
 8002646:	4604      	mov	r4, r0

    rng_delay();
 8002648:	f000 f879 	bl	800273e <rng_delay>

	return rv;
}
 800264c:	4620      	mov	r0, r4
 800264e:	bd10      	pop	{r4, pc}

08002650 <check_all_zeros>:
//
// Return T if all bytes are 0x00
//
	bool
check_all_zeros(const void *ptrV, int len)
{
 8002650:	b510      	push	{r4, lr}
 8002652:	4401      	add	r1, r0
	uint8_t rv = 0x0;
 8002654:	2400      	movs	r4, #0
	const uint8_t *ptr = (const uint8_t *)ptrV;

	for(; len; len--, ptr++) {
 8002656:	4288      	cmp	r0, r1
 8002658:	d003      	beq.n	8002662 <check_all_zeros+0x12>
		rv |= *ptr;
 800265a:	f810 3b01 	ldrb.w	r3, [r0], #1
 800265e:	431c      	orrs	r4, r3
 8002660:	e7f9      	b.n	8002656 <check_all_zeros+0x6>
	}

    rng_delay();
 8002662:	f000 f86c 	bl	800273e <rng_delay>
	return (rv == 0x00);
}
 8002666:	fab4 f084 	clz	r0, r4
 800266a:	0940      	lsrs	r0, r0, #5
 800266c:	bd10      	pop	{r4, pc}

0800266e <check_equal>:
	const uint8_t *left = (const uint8_t *)aV;
	const uint8_t *right = (const uint8_t *)bV;
    uint8_t diff = 0;
    int i;

    for (i = 0; i < len; i++) {
 800266e:	2300      	movs	r3, #0
//
// Equality check.
//
	bool
check_equal(const void *aV, const void *bV, int len)
{
 8002670:	b570      	push	{r4, r5, r6, lr}
	const uint8_t *left = (const uint8_t *)aV;
	const uint8_t *right = (const uint8_t *)bV;
    uint8_t diff = 0;
 8002672:	461c      	mov	r4, r3
    int i;

    for (i = 0; i < len; i++) {
 8002674:	4293      	cmp	r3, r2
 8002676:	da05      	bge.n	8002684 <check_equal+0x16>
        diff |= (left[i] ^ right[i]);
 8002678:	5cc6      	ldrb	r6, [r0, r3]
 800267a:	5ccd      	ldrb	r5, [r1, r3]
 800267c:	4075      	eors	r5, r6
 800267e:	432c      	orrs	r4, r5
	const uint8_t *left = (const uint8_t *)aV;
	const uint8_t *right = (const uint8_t *)bV;
    uint8_t diff = 0;
    int i;

    for (i = 0; i < len; i++) {
 8002680:	3301      	adds	r3, #1
 8002682:	e7f7      	b.n	8002674 <check_equal+0x6>
        diff |= (left[i] ^ right[i]);
    }

    rng_delay();
 8002684:	f000 f85b 	bl	800273e <rng_delay>
    return (diff == 0);
}
 8002688:	fab4 f084 	clz	r0, r4
 800268c:	0940      	lsrs	r0, r0, #5
 800268e:	bd70      	pop	{r4, r5, r6, pc}

08002690 <rng_sample>:
        }

        // Get the new number
        uint32_t rv = RNG->DR;

        if(rv != last_rng_result && rv) {
 8002690:	4b07      	ldr	r3, [pc, #28]	; (80026b0 <rng_sample+0x20>)
{
    static uint32_t last_rng_result;

    while(1) {
        // Check if data register contains valid random data
        while(!(RNG->SR & RNG_FLAG_DRDY)) {
 8002692:	4a08      	ldr	r2, [pc, #32]	; (80026b4 <rng_sample+0x24>)
        }

        // Get the new number
        uint32_t rv = RNG->DR;

        if(rv != last_rng_result && rv) {
 8002694:	6819      	ldr	r1, [r3, #0]

// rng_sample()
//
    uint32_t
rng_sample(void)
{
 8002696:	b510      	push	{r4, lr}
    static uint32_t last_rng_result;

    while(1) {
        // Check if data register contains valid random data
        while(!(RNG->SR & RNG_FLAG_DRDY)) {
 8002698:	4614      	mov	r4, r2
 800269a:	6850      	ldr	r0, [r2, #4]
 800269c:	07c0      	lsls	r0, r0, #31
 800269e:	d5fc      	bpl.n	800269a <rng_sample+0xa>
            // busy wait; okay to get stuck here... better than failing.
        }

        // Get the new number
        uint32_t rv = RNG->DR;
 80026a0:	68a0      	ldr	r0, [r4, #8]

        if(rv != last_rng_result && rv) {
 80026a2:	4288      	cmp	r0, r1
 80026a4:	d0f9      	beq.n	800269a <rng_sample+0xa>
 80026a6:	2800      	cmp	r0, #0
 80026a8:	d0f7      	beq.n	800269a <rng_sample+0xa>
            last_rng_result = rv;
 80026aa:	6018      	str	r0, [r3, #0]

        // keep trying if not a new number
    }

    // NOT-REACHED
}
 80026ac:	bd10      	pop	{r4, pc}
 80026ae:	bf00      	nop
 80026b0:	200001cc 	.word	0x200001cc
 80026b4:	50060800 	.word	0x50060800

080026b8 <rng_setup>:
// rng_setup()
//
    void
rng_setup(void)
{
    if(RNG->CR & RNG_CR_RNGEN) {
 80026b8:	4b12      	ldr	r3, [pc, #72]	; (8002704 <rng_setup+0x4c>)
 80026ba:	681a      	ldr	r2, [r3, #0]
 80026bc:	0752      	lsls	r2, r2, #29

// rng_setup()
//
    void
rng_setup(void)
{
 80026be:	b513      	push	{r0, r1, r4, lr}
    if(RNG->CR & RNG_CR_RNGEN) {
 80026c0:	d41d      	bmi.n	80026fe <rng_setup+0x46>
        // already setup
        return;
    }

    // Enable the Peripheral
    __HAL_RCC_RNG_CLK_ENABLE();
 80026c2:	4a11      	ldr	r2, [pc, #68]	; (8002708 <rng_setup+0x50>)
 80026c4:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 80026c6:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
 80026ca:	64d1      	str	r1, [r2, #76]	; 0x4c
 80026cc:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 80026ce:	f402 2280 	and.w	r2, r2, #262144	; 0x40000
 80026d2:	9201      	str	r2, [sp, #4]
 80026d4:	9a01      	ldr	r2, [sp, #4]

    // Turn on feature.
    RNG->CR |=  RNG_CR_RNGEN;
 80026d6:	681a      	ldr	r2, [r3, #0]
 80026d8:	f042 0204 	orr.w	r2, r2, #4
 80026dc:	601a      	str	r2, [r3, #0]

    // Sample twice to be sure that we have a 
    // valid RNG result.
    uint32_t chk = rng_sample();
 80026de:	f7ff ffd7 	bl	8002690 <rng_sample>
 80026e2:	4604      	mov	r4, r0
    uint32_t chk2 = rng_sample();
 80026e4:	f7ff ffd4 	bl	8002690 <rng_sample>

    // die if we are clearly not getting random values
    if(chk == 0 || chk == ~0
 80026e8:	1e63      	subs	r3, r4, #1
 80026ea:	3303      	adds	r3, #3
 80026ec:	d804      	bhi.n	80026f8 <rng_setup+0x40>
        || chk2 == 0 || chk2 == ~0
 80026ee:	1e43      	subs	r3, r0, #1
 80026f0:	3303      	adds	r3, #3
 80026f2:	d801      	bhi.n	80026f8 <rng_setup+0x40>
        || chk == chk2
 80026f4:	4284      	cmp	r4, r0
 80026f6:	d102      	bne.n	80026fe <rng_setup+0x46>
    ) {
        INCONSISTENT("bad rng");
 80026f8:	4804      	ldr	r0, [pc, #16]	; (800270c <rng_setup+0x54>)
 80026fa:	f7fe f96f 	bl	80009dc <fatal_error>

        while(1) ;
    }
}
 80026fe:	b002      	add	sp, #8
 8002700:	bd10      	pop	{r4, pc}
 8002702:	bf00      	nop
 8002704:	50060800 	.word	0x50060800
 8002708:	40021000 	.word	0x40021000
 800270c:	0800d55f 	.word	0x0800d55f

08002710 <rng_buffer>:

// rng_buffer()
//
    void
rng_buffer(uint8_t *result, int len)
{
 8002710:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8002712:	4607      	mov	r7, r0
 8002714:	460e      	mov	r6, r1
    while(len > 0) {
 8002716:	460c      	mov	r4, r1
 8002718:	1b35      	subs	r5, r6, r4
 800271a:	2c00      	cmp	r4, #0
 800271c:	443d      	add	r5, r7
 800271e:	dd0c      	ble.n	800273a <rng_buffer+0x2a>
        uint32_t    t = rng_sample();
 8002720:	f7ff ffb6 	bl	8002690 <rng_sample>

        memcpy(result, &t, MIN(4, len));
 8002724:	2c04      	cmp	r4, #4
 8002726:	4622      	mov	r2, r4
//
    void
rng_buffer(uint8_t *result, int len)
{
    while(len > 0) {
        uint32_t    t = rng_sample();
 8002728:	9001      	str	r0, [sp, #4]

        memcpy(result, &t, MIN(4, len));
 800272a:	bfa8      	it	ge
 800272c:	2204      	movge	r2, #4
 800272e:	a901      	add	r1, sp, #4
 8002730:	4628      	mov	r0, r5
 8002732:	f00a fea6 	bl	800d482 <memcpy>

        len -= 4;
 8002736:	3c04      	subs	r4, #4
 8002738:	e7ee      	b.n	8002718 <rng_buffer+0x8>
        result += 4;
    }
}
 800273a:	b003      	add	sp, #12
 800273c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800273e <rng_delay>:
//
// Call anytime. Delays for a random time period to fustrate glitchers.
//
    void
rng_delay(void)
{
 800273e:	b508      	push	{r3, lr}
    uint32_t    r = rng_sample() % 20;
 8002740:	f7ff ffa6 	bl	8002690 <rng_sample>
    uint32_t    cnt = (1<<r);
 8002744:	2314      	movs	r3, #20
 8002746:	fbb0 f2f3 	udiv	r2, r0, r3
 800274a:	fb02 0013 	mls	r0, r2, r3, r0
 800274e:	2301      	movs	r3, #1
 8002750:	fa03 f000 	lsl.w	r0, r3, r0

    while(cnt) {
        asm("nop");         // need this to keep from being optimized away, check bootloader.lss
 8002754:	bf00      	nop
rng_delay(void)
{
    uint32_t    r = rng_sample() % 20;
    uint32_t    cnt = (1<<r);

    while(cnt) {
 8002756:	3801      	subs	r0, #1
 8002758:	d1fc      	bne.n	8002754 <rng_delay+0x16>
        asm("nop");         // need this to keep from being optimized away, check bootloader.lss
        cnt--;
    }
}
 800275a:	bd08      	pop	{r3, pc}

0800275c <_send_byte>:
    static inline void
_send_byte(uint8_t ch)
{
    // reset timeout timer (Systick)
    uint32_t    ticks = 0;
    SysTick->VAL = 0;
 800275c:	4b08      	ldr	r3, [pc, #32]	; (8002780 <_send_byte+0x24>)

// _send_byte()
//
    static inline void
_send_byte(uint8_t ch)
{
 800275e:	b510      	push	{r4, lr}
    // reset timeout timer (Systick)
    uint32_t    ticks = 0;
    SysTick->VAL = 0;
 8002760:	2200      	movs	r2, #0

    while(!(MY_UART->ISR & UART_FLAG_TXE)) {
 8002762:	4c08      	ldr	r4, [pc, #32]	; (8002784 <_send_byte+0x28>)
    static inline void
_send_byte(uint8_t ch)
{
    // reset timeout timer (Systick)
    uint32_t    ticks = 0;
    SysTick->VAL = 0;
 8002764:	609a      	str	r2, [r3, #8]

    while(!(MY_UART->ISR & UART_FLAG_TXE)) {
 8002766:	220b      	movs	r2, #11
 8002768:	69e1      	ldr	r1, [r4, #28]
 800276a:	0609      	lsls	r1, r1, #24
 800276c:	d404      	bmi.n	8002778 <_send_byte+0x1c>
        // busy-wait until able to send (no fifo?)
        if(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) {
 800276e:	6819      	ldr	r1, [r3, #0]
 8002770:	03c9      	lsls	r1, r1, #15
 8002772:	d5f9      	bpl.n	8002768 <_send_byte+0xc>
            // failsafe timeout
            ticks += 1;
            if(ticks > 10) break;
 8002774:	3a01      	subs	r2, #1
 8002776:	d1f7      	bne.n	8002768 <_send_byte+0xc>
        }
    }
    MY_UART->TDR = ch;
 8002778:	4b02      	ldr	r3, [pc, #8]	; (8002784 <_send_byte+0x28>)
 800277a:	b280      	uxth	r0, r0
 800277c:	8518      	strh	r0, [r3, #40]	; 0x28
 800277e:	bd10      	pop	{r4, pc}
 8002780:	e000e010 	.word	0xe000e010
 8002784:	40004c00 	.word	0x40004c00

08002788 <_send_bits>:

// _send_bits()
//
    static void
_send_bits(uint8_t tx)
{
 8002788:	b570      	push	{r4, r5, r6, lr}
 800278a:	4606      	mov	r6, r0
 800278c:	2508      	movs	r5, #8
    // serialize and send one byte
    uint8_t     mask = 0x1;
 800278e:	2401      	movs	r4, #1

    for(int i=0; i<8; i++, mask <<= 1) {
        uint8_t h = (tx & mask) ? BIT1 : BIT0;
 8002790:	4226      	tst	r6, r4

        _send_byte(h);
 8002792:	bf14      	ite	ne
 8002794:	207f      	movne	r0, #127	; 0x7f
 8002796:	207d      	moveq	r0, #125	; 0x7d
 8002798:	f7ff ffe0 	bl	800275c <_send_byte>
_send_bits(uint8_t tx)
{
    // serialize and send one byte
    uint8_t     mask = 0x1;

    for(int i=0; i<8; i++, mask <<= 1) {
 800279c:	0064      	lsls	r4, r4, #1
 800279e:	3d01      	subs	r5, #1
 80027a0:	b2e4      	uxtb	r4, r4
 80027a2:	d1f5      	bne.n	8002790 <_send_bits+0x8>
        uint8_t h = (tx & mask) ? BIT1 : BIT0;

        _send_byte(h);
    }
}
 80027a4:	bd70      	pop	{r4, r5, r6, pc}

080027a6 <_send_serialized>:

// _send_serialized()
//
    static void
_send_serialized(const uint8_t *buf, int len)
{
 80027a6:	b570      	push	{r4, r5, r6, lr}
 80027a8:	4605      	mov	r5, r0
 80027aa:	460e      	mov	r6, r1
    for(int i=0; i<len; i++) {
 80027ac:	4604      	mov	r4, r0
 80027ae:	1b63      	subs	r3, r4, r5
 80027b0:	429e      	cmp	r6, r3
 80027b2:	dd04      	ble.n	80027be <_send_serialized+0x18>
        _send_bits(buf[i]);
 80027b4:	f814 0b01 	ldrb.w	r0, [r4], #1
 80027b8:	f7ff ffe6 	bl	8002788 <_send_bits>
 80027bc:	e7f7      	b.n	80027ae <_send_serialized+0x8>
    }
}
 80027be:	bd70      	pop	{r4, r5, r6, pc}

080027c0 <_flush_rx>:
//
    static inline void
_flush_rx(void)
{
    // reset timeout timer (Systick)
    SysTick->VAL = 0;
 80027c0:	4b0c      	ldr	r3, [pc, #48]	; (80027f4 <_flush_rx+0x34>)

    while(!(MY_UART->ISR & UART_FLAG_TC)) {
 80027c2:	490d      	ldr	r1, [pc, #52]	; (80027f8 <_flush_rx+0x38>)
//
    static inline void
_flush_rx(void)
{
    // reset timeout timer (Systick)
    SysTick->VAL = 0;
 80027c4:	2200      	movs	r2, #0
 80027c6:	609a      	str	r2, [r3, #8]

    while(!(MY_UART->ISR & UART_FLAG_TC)) {
 80027c8:	69ca      	ldr	r2, [r1, #28]
 80027ca:	0652      	lsls	r2, r2, #25
 80027cc:	d402      	bmi.n	80027d4 <_flush_rx+0x14>
        // wait for last bit(byte) to be serialized and sent

        if(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) {
 80027ce:	681a      	ldr	r2, [r3, #0]
 80027d0:	03d0      	lsls	r0, r2, #15
 80027d2:	d5f9      	bpl.n	80027c8 <_flush_rx+0x8>
            break;
        }
    }

    // We actualy need this delay here!
    __NOP();
 80027d4:	bf00      	nop
    __NOP();
 80027d6:	bf00      	nop
    __NOP();
 80027d8:	bf00      	nop
    __NOP();
 80027da:	bf00      	nop
    __NOP();
 80027dc:	bf00      	nop
    __NOP();
 80027de:	bf00      	nop
    __NOP();
 80027e0:	bf00      	nop
    __NOP();
 80027e2:	bf00      	nop

    // clear junk in rx buffer
    MY_UART->RQR = USART_RQR_RXFRQ;
 80027e4:	4b04      	ldr	r3, [pc, #16]	; (80027f8 <_flush_rx+0x38>)
 80027e6:	2208      	movs	r2, #8
 80027e8:	831a      	strh	r2, [r3, #24]

    // clear overrun error
    // clear rx timeout flag
    // clear framing error
    MY_UART->ICR = USART_ICR_ORECF | USART_ICR_RTOCF | USART_ICR_FECF;
 80027ea:	f640 020a 	movw	r2, #2058	; 0x80a
 80027ee:	621a      	str	r2, [r3, #32]
 80027f0:	4770      	bx	lr
 80027f2:	bf00      	nop
 80027f4:	e000e010 	.word	0xe000e010
 80027f8:	40004c00 	.word	0x40004c00

080027fc <crc16_chain>:
 * \param[in] data pointer to data for which CRC should be calculated
 * \param[out] crc pointer to 16-bit CRC
 */ 
	static void
crc16_chain(uint8_t length, const uint8_t *data, uint8_t crc[2])
{
 80027fc:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16_t crc_register = 0;
    uint16_t polynom = 0x8005;
    uint8_t shift_register;
    uint8_t data_bit, crc_bit;
    
    crc_register = (((uint16_t) crc[0]) & 0x00FF) | (((uint16_t) crc[1]) << 8);
 80027fe:	7813      	ldrb	r3, [r2, #0]
 8002800:	7854      	ldrb	r4, [r2, #1]
    
    for (counter = 0; counter < length; counter++) {
 8002802:	460e      	mov	r6, r1
    uint16_t crc_register = 0;
    uint16_t polynom = 0x8005;
    uint8_t shift_register;
    uint8_t data_bit, crc_bit;
    
    crc_register = (((uint16_t) crc[0]) & 0x00FF) | (((uint16_t) crc[1]) << 8);
 8002804:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
    
    for (counter = 0; counter < length; counter++) {
 8002808:	1a74      	subs	r4, r6, r1
 800280a:	b2e4      	uxtb	r4, r4
 800280c:	42a0      	cmp	r0, r4
 800280e:	d91a      	bls.n	8002846 <crc16_chain+0x4a>
      for (shift_register = 0x01; shift_register > 0x00; shift_register <<= 1) {
         data_bit = (data[counter] & shift_register) ? 1 : 0;
 8002810:	f816 7b01 	ldrb.w	r7, [r6], #1
 8002814:	2508      	movs	r5, #8
 8002816:	2401      	movs	r4, #1
         crc_bit = crc_register >> 15;

         // Shift CRC to the left by 1.
         crc_register <<= 1; 

         if ((data_bit ^ crc_bit) != 0)
 8002818:	4227      	tst	r7, r4
    crc_register = (((uint16_t) crc[0]) & 0x00FF) | (((uint16_t) crc[1]) << 8);
    
    for (counter = 0; counter < length; counter++) {
      for (shift_register = 0x01; shift_register > 0x00; shift_register <<= 1) {
         data_bit = (data[counter] & shift_register) ? 1 : 0;
         crc_bit = crc_register >> 15;
 800281a:	ea4f 3ed3 	mov.w	lr, r3, lsr #15

         // Shift CRC to the left by 1.
         crc_register <<= 1; 

         if ((data_bit ^ crc_bit) != 0)
 800281e:	bf18      	it	ne
 8002820:	f04f 0c01 	movne.w	ip, #1
      for (shift_register = 0x01; shift_register > 0x00; shift_register <<= 1) {
         data_bit = (data[counter] & shift_register) ? 1 : 0;
         crc_bit = crc_register >> 15;

         // Shift CRC to the left by 1.
         crc_register <<= 1; 
 8002824:	ea4f 0343 	mov.w	r3, r3, lsl #1

         if ((data_bit ^ crc_bit) != 0)
 8002828:	bf08      	it	eq
 800282a:	f04f 0c00 	moveq.w	ip, #0
 800282e:	45f4      	cmp	ip, lr
      for (shift_register = 0x01; shift_register > 0x00; shift_register <<= 1) {
         data_bit = (data[counter] & shift_register) ? 1 : 0;
         crc_bit = crc_register >> 15;

         // Shift CRC to the left by 1.
         crc_register <<= 1; 
 8002830:	b29b      	uxth	r3, r3

         if ((data_bit ^ crc_bit) != 0)
            crc_register ^= polynom;
 8002832:	bf1c      	itt	ne
 8002834:	f483 4300 	eorne.w	r3, r3, #32768	; 0x8000
 8002838:	f083 0305 	eorne.w	r3, r3, #5
    uint8_t data_bit, crc_bit;
    
    crc_register = (((uint16_t) crc[0]) & 0x00FF) | (((uint16_t) crc[1]) << 8);
    
    for (counter = 0; counter < length; counter++) {
      for (shift_register = 0x01; shift_register > 0x00; shift_register <<= 1) {
 800283c:	0064      	lsls	r4, r4, #1
 800283e:	3d01      	subs	r5, #1
 8002840:	b2e4      	uxtb	r4, r4
 8002842:	d1e9      	bne.n	8002818 <crc16_chain+0x1c>
 8002844:	e7e0      	b.n	8002808 <crc16_chain+0xc>
         if ((data_bit ^ crc_bit) != 0)
            crc_register ^= polynom;
      }  
    }
        
    crc[0] = (uint8_t) (crc_register & 0x00FF);
 8002846:	7013      	strb	r3, [r2, #0]
    crc[1] = (uint8_t) (crc_register >> 8);
 8002848:	0a1b      	lsrs	r3, r3, #8
 800284a:	7053      	strb	r3, [r2, #1]
 800284c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800284e <ae_check_crc>:

// ae_check_crc()
//
	static bool
ae_check_crc(const uint8_t *data, uint8_t length)
{
 800284e:	b573      	push	{r0, r1, r4, r5, r6, lr}
	uint8_t obs[2] = { 0, 0 };

	if(data[0] != length) {
 8002850:	7805      	ldrb	r5, [r0, #0]
// ae_check_crc()
//
	static bool
ae_check_crc(const uint8_t *data, uint8_t length)
{
	uint8_t obs[2] = { 0, 0 };
 8002852:	2400      	movs	r4, #0

	if(data[0] != length) {
 8002854:	428d      	cmp	r5, r1

// ae_check_crc()
//
	static bool
ae_check_crc(const uint8_t *data, uint8_t length)
{
 8002856:	4606      	mov	r6, r0
	uint8_t obs[2] = { 0, 0 };
 8002858:	f88d 4004 	strb.w	r4, [sp, #4]
 800285c:	f88d 4005 	strb.w	r4, [sp, #5]

	if(data[0] != length) {
 8002860:	d113      	bne.n	800288a <ae_check_crc+0x3c>
		// length is wrong
        STATS(crc_len_error++);
		return false;
	}

	crc16_chain(length-2, data, obs);
 8002862:	1ea8      	subs	r0, r5, #2

	return (obs[0] == data[length-2] && obs[1] == data[length-1]);
 8002864:	4435      	add	r5, r6
		// length is wrong
        STATS(crc_len_error++);
		return false;
	}

	crc16_chain(length-2, data, obs);
 8002866:	aa01      	add	r2, sp, #4
 8002868:	4631      	mov	r1, r6
 800286a:	b2c0      	uxtb	r0, r0
 800286c:	f7ff ffc6 	bl	80027fc <crc16_chain>

	return (obs[0] == data[length-2] && obs[1] == data[length-1]);
 8002870:	f89d 2004 	ldrb.w	r2, [sp, #4]
 8002874:	f815 3c02 	ldrb.w	r3, [r5, #-2]
 8002878:	429a      	cmp	r2, r3
 800287a:	d106      	bne.n	800288a <ae_check_crc+0x3c>
 800287c:	f89d 4005 	ldrb.w	r4, [sp, #5]
 8002880:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 8002884:	1b1b      	subs	r3, r3, r4
 8002886:	425c      	negs	r4, r3
 8002888:	415c      	adcs	r4, r3
	uint8_t obs[2] = { 0, 0 };

	if(data[0] != length) {
		// length is wrong
        STATS(crc_len_error++);
		return false;
 800288a:	4620      	mov	r0, r4
	}

	crc16_chain(length-2, data, obs);

	return (obs[0] == data[length-2] && obs[1] == data[length-1]);
}
 800288c:	b002      	add	sp, #8
 800288e:	bd70      	pop	{r4, r5, r6, pc}

08002890 <ae_wake>:
// Prior to First Command) as an error to any on-going/attempted operation.
//
//
    static void
ae_wake(void)
{
 8002890:	b508      	push	{r3, lr}
    // send zero (all low), delay 2.5ms
    _send_byte(0x00);
 8002892:	2000      	movs	r0, #0
 8002894:	f7ff ff62 	bl	800275c <_send_byte>

    delay_ms(3);     // measured: ~2.9ms
 8002898:	2003      	movs	r0, #3
 800289a:	f000 fff9 	bl	8003890 <delay_ms>

    _flush_rx();
}
 800289e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    // send zero (all low), delay 2.5ms
    _send_byte(0x00);

    delay_ms(3);     // measured: ~2.9ms

    _flush_rx();
 80028a2:	f7ff bf8d 	b.w	80027c0 <_flush_rx>
	...

080028a8 <ae_read_response>:
// We ignore extra bytes not expected, and always read until a timeout.
// Cmds to chip can be up to 155 bytes, but not clear what max len for responses.
//
    static int
ae_read_response(uint8_t *buf, int max_len)
{
 80028a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    int max_expect = (max_len+1) * 8;
 80028ac:	1c4c      	adds	r4, r1, #1
 80028ae:	00e4      	lsls	r4, r4, #3
// We ignore extra bytes not expected, and always read until a timeout.
// Cmds to chip can be up to 155 bytes, but not clear what max len for responses.
//
    static int
ae_read_response(uint8_t *buf, int max_len)
{
 80028b0:	af00      	add	r7, sp, #0
 80028b2:	4605      	mov	r5, r0
    int max_expect = (max_len+1) * 8;
    uint8_t raw[max_expect];
 80028b4:	ebad 0d04 	sub.w	sp, sp, r4

    // tell chip to write stuff to bus
    _send_bits(IOFLAG_TX);
 80028b8:	2088      	movs	r0, #136	; 0x88
// We ignore extra bytes not expected, and always read until a timeout.
// Cmds to chip can be up to 155 bytes, but not clear what max len for responses.
//
    static int
ae_read_response(uint8_t *buf, int max_len)
{
 80028ba:	460e      	mov	r6, r1
    int max_expect = (max_len+1) * 8;
    uint8_t raw[max_expect];

    // tell chip to write stuff to bus
    _send_bits(IOFLAG_TX);
 80028bc:	f7ff ff64 	bl	8002788 <_send_bits>

    // kill first byte which we expect to be IOFLAG_TX echo (0x88)
    _flush_rx();
 80028c0:	f7ff ff7e 	bl	80027c0 <_flush_rx>
    uint32_t    ticks = 0;

    // reset timeout timer (Systick)
    SysTick->VAL = 0;

    while(!(MY_UART->ISR & UART_FLAG_RXNE) && !(MY_UART->ISR & UART_FLAG_RTOF)) {
 80028c4:	4b2e      	ldr	r3, [pc, #184]	; (8002980 <ae_read_response+0xd8>)
_read_byte(void)
{
    uint32_t    ticks = 0;

    // reset timeout timer (Systick)
    SysTick->VAL = 0;
 80028c6:	f8df e0c0 	ldr.w	lr, [pc, #192]	; 8002988 <ae_read_response+0xe0>

    // It takes between 64 and 131us (tTURNAROUND) for the chip to recover
    // and start sending bits to us. We're blocked on reading
    // them anyway, so no need to delay. Also a danger of overruns here.

    int actual = 0;
 80028ca:	2000      	movs	r0, #0
//
    static int
ae_read_response(uint8_t *buf, int max_len)
{
    int max_expect = (max_len+1) * 8;
    uint8_t raw[max_expect];
 80028cc:	46e8      	mov	r8, sp
    // It takes between 64 and 131us (tTURNAROUND) for the chip to recover
    // and start sending bits to us. We're blocked on reading
    // them anyway, so no need to delay. Also a danger of overruns here.

    int actual = 0;
    for(uint8_t *p = raw; ; actual++) {
 80028ce:	466a      	mov	r2, sp
_read_byte(void)
{
    uint32_t    ticks = 0;

    // reset timeout timer (Systick)
    SysTick->VAL = 0;
 80028d0:	4684      	mov	ip, r0
 80028d2:	4699      	mov	r9, r3
 80028d4:	f8ce c008 	str.w	ip, [lr, #8]
 80028d8:	2105      	movs	r1, #5

    while(!(MY_UART->ISR & UART_FLAG_RXNE) && !(MY_UART->ISR & UART_FLAG_RTOF)) {
 80028da:	f8d3 a01c 	ldr.w	sl, [r3, #28]
 80028de:	f01a 0f20 	tst.w	sl, #32
 80028e2:	d10c      	bne.n	80028fe <ae_read_response+0x56>
 80028e4:	f8d3 a01c 	ldr.w	sl, [r3, #28]
 80028e8:	f41a 6f00 	tst.w	sl, #2048	; 0x800
 80028ec:	d107      	bne.n	80028fe <ae_read_response+0x56>
        // busy-waiting

        if(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) {
 80028ee:	f8de a000 	ldr.w	sl, [lr]
 80028f2:	f41a 3f80 	tst.w	sl, #65536	; 0x10000
 80028f6:	d0f0      	beq.n	80028da <ae_read_response+0x32>
            ticks += 1;
            if(ticks >= 5) {
 80028f8:	3901      	subs	r1, #1
 80028fa:	d1ee      	bne.n	80028da <ae_read_response+0x32>
 80028fc:	e019      	b.n	8002932 <ae_read_response+0x8a>
                return -1;
            }
        }
    }

    if(MY_UART->ISR & UART_FLAG_RXNE) {
 80028fe:	f8d9 a01c 	ldr.w	sl, [r9, #28]
 8002902:	491f      	ldr	r1, [pc, #124]	; (8002980 <ae_read_response+0xd8>)
 8002904:	f01a 0f20 	tst.w	sl, #32
 8002908:	d007      	beq.n	800291a <ae_read_response+0x72>
        return MY_UART->RDR & 0x7f;
 800290a:	8c99      	ldrh	r1, [r3, #36]	; 0x24
        int ch = _read_byte();
        if(ch < 0) {
            break;
        }

        if(actual < max_expect) {
 800290c:	42a0      	cmp	r0, r4
 800290e:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8002912:	da0c      	bge.n	800292e <ae_read_response+0x86>
            *(p++) = ch;
 8002914:	7011      	strb	r1, [r2, #0]
 8002916:	3201      	adds	r2, #1
 8002918:	e009      	b.n	800292e <ae_read_response+0x86>
    }

    if(MY_UART->ISR & UART_FLAG_RXNE) {
        return MY_UART->RDR & 0x7f;
    }
    if(MY_UART->ISR & UART_FLAG_RTOF) {
 800291a:	69cb      	ldr	r3, [r1, #28]
 800291c:	051b      	lsls	r3, r3, #20
 800291e:	d503      	bpl.n	8002928 <ae_read_response+0x80>
        // "fast" timeout reached, clear flag
        MY_UART->ICR = USART_ICR_RTOCF;
 8002920:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8002924:	620b      	str	r3, [r1, #32]
 8002926:	e004      	b.n	8002932 <ae_read_response+0x8a>
        return -1;
    }
    INCONSISTENT("rxf");
 8002928:	4816      	ldr	r0, [pc, #88]	; (8002984 <ae_read_response+0xdc>)
 800292a:	f7fe f857 	bl	80009dc <fatal_error>
    // It takes between 64 and 131us (tTURNAROUND) for the chip to recover
    // and start sending bits to us. We're blocked on reading
    // them anyway, so no need to delay. Also a danger of overruns here.

    int actual = 0;
    for(uint8_t *p = raw; ; actual++) {
 800292e:	3001      	adds	r0, #1
        }

        if(actual < max_expect) {
            *(p++) = ch;
        }
    }
 8002930:	e7d0      	b.n	80028d4 <ae_read_response+0x2c>

    // Sometimes our framing is not perfect.
    // We might get a spurious bit at the leading edge (perhaps an echo
    // of part of the 0x88??) or junk at the end.
    actual &= ~7;
 8002932:	f020 0007 	bic.w	r0, r0, #7
 8002936:	1dc3      	adds	r3, r0, #7
 8002938:	f108 0207 	add.w	r2, r8, #7
 800293c:	eb08 0103 	add.w	r1, r8, r3
 8002940:	462c      	mov	r4, r5
// Return a deserialized byte, or -1 for timeout.
//
    static void
deserialize(const uint8_t *from, int from_len, uint8_t *into, int max_into)
{
    while(from_len > 0) {
 8002942:	428a      	cmp	r2, r1
 8002944:	d017      	beq.n	8002976 <ae_read_response+0xce>
 8002946:	f1a2 0c08 	sub.w	ip, r2, #8
 800294a:	2301      	movs	r3, #1
 800294c:	f04f 0e00 	mov.w	lr, #0
        uint8_t rv = 0, mask = 0x1;

        for(int i=0; i<8; i++, mask <<= 1) {
            if(from[i] == BIT1) {
 8002950:	f81c 8f01 	ldrb.w	r8, [ip, #1]!
 8002954:	f1b8 0f7f 	cmp.w	r8, #127	; 0x7f
                rv |= mask;
 8002958:	bf08      	it	eq
 800295a:	ea4e 0e03 	orreq.w	lr, lr, r3
deserialize(const uint8_t *from, int from_len, uint8_t *into, int max_into)
{
    while(from_len > 0) {
        uint8_t rv = 0, mask = 0x1;

        for(int i=0; i<8; i++, mask <<= 1) {
 800295e:	005b      	lsls	r3, r3, #1
 8002960:	4594      	cmp	ip, r2
 8002962:	b2db      	uxtb	r3, r3
 8002964:	d1f4      	bne.n	8002950 <ae_read_response+0xa8>
            if(from[i] == BIT1) {
                rv |= mask;
            }
        }

        *(into++) = rv;
 8002966:	f804 eb01 	strb.w	lr, [r4], #1
 800296a:	1b33      	subs	r3, r6, r4
 800296c:	442b      	add	r3, r5
        from += 8;
        from_len -= 8;

        max_into --;
        if(max_into <= 0) break;
 800296e:	2b00      	cmp	r3, #0
 8002970:	f102 0208 	add.w	r2, r2, #8
 8002974:	dce5      	bgt.n	8002942 <ae_read_response+0x9a>
    // We might get a spurious bit at the leading edge (perhaps an echo
    // of part of the 0x88??) or junk at the end.
    actual &= ~7;
    deserialize(raw, actual, buf, max_len);

    return actual / 8;
 8002976:	10c0      	asrs	r0, r0, #3
}
 8002978:	46bd      	mov	sp, r7
 800297a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800297e:	bf00      	nop
 8002980:	40004c00 	.word	0x40004c00
 8002984:	0800d55f 	.word	0x0800d55f
 8002988:	e000e010 	.word	0xe000e010

0800298c <ae_reset_chip>:
// ae_reset_chip()
//
    void
ae_reset_chip(void)
{
    if(ae_chip_is_setup == AE_CHIP_IS_SETUP) {
 800298c:	4b04      	ldr	r3, [pc, #16]	; (80029a0 <ae_reset_chip+0x14>)
 800298e:	681a      	ldr	r2, [r3, #0]
 8002990:	4b04      	ldr	r3, [pc, #16]	; (80029a4 <ae_reset_chip+0x18>)
 8002992:	429a      	cmp	r2, r3
 8002994:	d102      	bne.n	800299c <ae_reset_chip+0x10>
        // "The ATECC508A goes into the low power sleep mode and ignores all
        // subsequent I/O transitions until the next wake flag. The entire volatile
        // state of the device is reset"
        _send_bits(IOFLAG_SLEEP);
 8002996:	20cc      	movs	r0, #204	; 0xcc
 8002998:	f7ff bef6 	b.w	8002788 <_send_bits>
 800299c:	4770      	bx	lr
 800299e:	bf00      	nop
 80029a0:	200001d0 	.word	0x200001d0
 80029a4:	35d25d63 	.word	0x35d25d63

080029a8 <ae_setup>:
#ifdef DEV_STATS
    memset(&stats, 0, sizeof(stats));
#endif

    // enable clock to that part of chip
    __HAL_RCC_UART4_CLK_ENABLE();
 80029a8:	4b14      	ldr	r3, [pc, #80]	; (80029fc <ae_setup+0x54>)
//
// Configure pins. Do not attempt to talk to chip.
//
    void
ae_setup(void)
{
 80029aa:	b507      	push	{r0, r1, r2, lr}
#ifdef DEV_STATS
    memset(&stats, 0, sizeof(stats));
#endif

    // enable clock to that part of chip
    __HAL_RCC_UART4_CLK_ENABLE();
 80029ac:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80029ae:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 80029b2:	659a      	str	r2, [r3, #88]	; 0x58
 80029b4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80029b6:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 80029ba:	9301      	str	r3, [sp, #4]
 80029bc:	9b01      	ldr	r3, [sp, #4]
    //
    // For max clock error insensitivity:
    // OVER8==0, ONEBIT=1

    // disable UART so some other bits can be set (only while disabled)
    MY_UART->CR1 = 0;
 80029be:	4b10      	ldr	r3, [pc, #64]	; (8002a00 <ae_setup+0x58>)
 80029c0:	2200      	movs	r2, #0
 80029c2:	601a      	str	r2, [r3, #0]
    MY_UART->CR1 = 0x1000002d & ~(0
 80029c4:	4a0f      	ldr	r2, [pc, #60]	; (8002a04 <ae_setup+0x5c>)
 80029c6:	601a      	str	r2, [r3, #0]
#endif
                                    | USART_CR1_IDLEIE
                                    | USART_CR1_OVER8
                                    | USART_CR1_UE);

    MY_UART->RTOR = 24;                  // timeout in bit periods: 3 chars or so
 80029c8:	2218      	movs	r2, #24
 80029ca:	615a      	str	r2, [r3, #20]
    MY_UART->CR2 = USART_CR2_RTOEN;      // rx timeout enable
 80029cc:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 80029d0:	605a      	str	r2, [r3, #4]
    MY_UART->CR3 = USART_CR3_HDSEL | USART_CR3_ONEBIT;
 80029d2:	f640 0208 	movw	r2, #2056	; 0x808
 80029d6:	609a      	str	r2, [r3, #8]
#if HCLK_FREQUENCY == 80000000
    MY_UART->BRR = 0x0000015b;          // 230400 bps @ 80 Mhz SYSCLK
#elif HCLK_FREQUENCY == 120000000
    MY_UART->BRR = 521;                 // 230400 bps @ 120 Mhz SYSCLK
 80029d8:	f240 2209 	movw	r2, #521	; 0x209
 80029dc:	60da      	str	r2, [r3, #12]
#else
#   error "needs math"
#endif

    // clear rx timeout flag
    MY_UART->ICR = USART_ICR_RTOCF;
 80029de:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80029e2:	621a      	str	r2, [r3, #32]

    // finally enable UART
    MY_UART->CR1 |= USART_CR1_UE;
 80029e4:	681a      	ldr	r2, [r3, #0]
 80029e6:	f042 0201 	orr.w	r2, r2, #1
 80029ea:	601a      	str	r2, [r3, #0]
    
    // configure pin A0 to be AFx_UARTy, PULL_NONE
    // should already be done: gpio_setup();
    
    // mark it as ready
    ae_chip_is_setup = AE_CHIP_IS_SETUP;
 80029ec:	4b06      	ldr	r3, [pc, #24]	; (8002a08 <ae_setup+0x60>)
 80029ee:	4a07      	ldr	r2, [pc, #28]	; (8002a0c <ae_setup+0x64>)
 80029f0:	601a      	str	r2, [r3, #0]

    rng_delay();
 80029f2:	f7ff fea4 	bl	800273e <rng_delay>
}
 80029f6:	b003      	add	sp, #12
 80029f8:	f85d fb04 	ldr.w	pc, [sp], #4
 80029fc:	40021000 	.word	0x40021000
 8002a00:	40004c00 	.word	0x40004c00
 8002a04:	1000002c 	.word	0x1000002c
 8002a08:	200001d0 	.word	0x200001d0
 8002a0c:	35d25d63 	.word	0x35d25d63

08002a10 <ae_keep_alive>:

// ae_keep_alive()
//
	void
ae_keep_alive(void)
{
 8002a10:	b508      	push	{r3, lr}
ae_send_idle(void)
{
	// "The ATECC508A goes into the idle mode and ignores all subsequent
	// I/O transitions until the next wake flag. The contents of TempKey
	// and RNG Seed registers are retained."
    ae_wake();
 8002a12:	f7ff ff3d 	bl	8002890 <ae_wake>

    _send_bits(IOFLAG_IDLE);
 8002a16:	20bb      	movs	r0, #187	; 0xbb
 8002a18:	f7ff feb6 	bl	8002788 <_send_bits>
	ae_send_idle();

    // no need to wake: next transaction will do that 
	//ae_wake();
    rng_delay();
}
 8002a1c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	// To reset the watchdog, (1) put it into idle mode, then (2) wake it.
	ae_send_idle();

    // no need to wake: next transaction will do that 
	//ae_wake();
    rng_delay();
 8002a20:	f7ff be8d 	b.w	800273e <rng_delay>

08002a24 <ae_read1>:
// Read a one-byte status/error code response from chip. It's wrapped as 4 bytes: 
//	(len=4) (value) (crc16) (crc16)
//
	int
ae_read1(void)
{
 8002a24:	b513      	push	{r0, r1, r4, lr}
 8002a26:	2408      	movs	r4, #8
	uint8_t msg[4];

	for(int retry=7; retry >= 0; retry--) {
        // tell it we want to read a response, read it, and deserialize
        int rv = ae_read_response(msg, 4);
 8002a28:	2104      	movs	r1, #4
 8002a2a:	eb0d 0001 	add.w	r0, sp, r1
 8002a2e:	f7ff ff3b 	bl	80028a8 <ae_read_response>

        if(rv == 0) {
 8002a32:	4601      	mov	r1, r0
 8002a34:	b918      	cbnz	r0, 8002a3e <ae_read1+0x1a>
            // nothing heard, it's probably still processing
            ERR("not rdy");
            STATS(not_ready++);

            delay_ms(5);
 8002a36:	2005      	movs	r0, #5
 8002a38:	f000 ff2a 	bl	8003890 <delay_ms>
            goto try_again;
 8002a3c:	e008      	b.n	8002a50 <ae_read1+0x2c>
        }

        if(rv != 4) {
 8002a3e:	2804      	cmp	r0, #4
 8002a40:	d106      	bne.n	8002a50 <ae_read1+0x2c>
            goto try_again;
        }

		// Check length and CRC bytes. we will retry a few times
		// if they are wrong.
		if(!ae_check_crc(msg, 4)) {
 8002a42:	a801      	add	r0, sp, #4
 8002a44:	f7ff ff03 	bl	800284e <ae_check_crc>
 8002a48:	b110      	cbz	r0, 8002a50 <ae_read1+0x2c>
		}

        STATS(last_resp1 = msg[1]);

		// done, and it worked; return the one byte.
		return msg[1];
 8002a4a:	f89d 0005 	ldrb.w	r0, [sp, #5]
 8002a4e:	e003      	b.n	8002a58 <ae_read1+0x34>
	int
ae_read1(void)
{
	uint8_t msg[4];

	for(int retry=7; retry >= 0; retry--) {
 8002a50:	3c01      	subs	r4, #1
 8002a52:	d1e9      	bne.n	8002a28 <ae_read1+0x4>
	try_again:
        STATS(l1_retry++);
	}

	// fail.
	return -1;
 8002a54:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8002a58:	b002      	add	sp, #8
 8002a5a:	bd10      	pop	{r4, pc}

08002a5c <ae_read_n>:
// Read and check CRC over N bytes, wrapped in 3-bytes of framing overhead.
// Return -1 for timeout, zero for normal, and one-byte error code otherwise.
//
	int
ae_read_n(uint8_t len, uint8_t *body)
{
 8002a5c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    uint8_t tmp[1+len+2];
 8002a60:	1cc6      	adds	r6, r0, #3
 8002a62:	300a      	adds	r0, #10
 8002a64:	f020 0007 	bic.w	r0, r0, #7
// Read and check CRC over N bytes, wrapped in 3-bytes of framing overhead.
// Return -1 for timeout, zero for normal, and one-byte error code otherwise.
//
	int
ae_read_n(uint8_t len, uint8_t *body)
{
 8002a68:	af00      	add	r7, sp, #0
    uint8_t tmp[1+len+2];
 8002a6a:	ebad 0d00 	sub.w	sp, sp, r0
// Read and check CRC over N bytes, wrapped in 3-bytes of framing overhead.
// Return -1 for timeout, zero for normal, and one-byte error code otherwise.
//
	int
ae_read_n(uint8_t len, uint8_t *body)
{
 8002a6e:	4688      	mov	r8, r1
    uint8_t tmp[1+len+2];
 8002a70:	466c      	mov	r4, sp
 8002a72:	f04f 0908 	mov.w	r9, #8

	for(int retry=7; retry >= 0; retry--) {

        int actual = ae_read_response(tmp, len+3);
 8002a76:	4631      	mov	r1, r6
 8002a78:	4620      	mov	r0, r4
 8002a7a:	f7ff ff15 	bl	80028a8 <ae_read_response>
        if(actual < 4) {
 8002a7e:	2803      	cmp	r0, #3
{
    uint8_t tmp[1+len+2];

	for(int retry=7; retry >= 0; retry--) {

        int actual = ae_read_response(tmp, len+3);
 8002a80:	4605      	mov	r5, r0
        if(actual < 4) {
 8002a82:	dc04      	bgt.n	8002a8e <ae_read_n+0x32>

            if(actual == 0) {
 8002a84:	b9b0      	cbnz	r0, 8002ab4 <ae_read_n+0x58>
                // nothing heard, it's probably still processing
                delay_ms(5);
 8002a86:	2005      	movs	r0, #5
 8002a88:	f000 ff02 	bl	8003890 <delay_ms>
 8002a8c:	e012      	b.n	8002ab4 <ae_read_n+0x58>
                STATS(short_error++);
            }
            goto try_again;
        }

        uint8_t resp_len = tmp[0];
 8002a8e:	7823      	ldrb	r3, [r4, #0]
		if(resp_len != (len + 3)) {
 8002a90:	429e      	cmp	r6, r3
 8002a92:	d003      	beq.n	8002a9c <ae_read_n+0x40>
            STATS(len_error++);
            if(resp_len == 4) {
 8002a94:	2b04      	cmp	r3, #4
 8002a96:	d10d      	bne.n	8002ab4 <ae_read_n+0x58>
				// Probably an unexpected error. But no way to return a short read, so
				// just print out debug info.
                ERRV(tmp[1], "ae errcode");
                STATS(last_resp1 = tmp[1]);

                return tmp[1];
 8002a98:	7860      	ldrb	r0, [r4, #1]
 8002a9a:	e012      	b.n	8002ac2 <ae_read_n+0x66>
            }
			ERRV(tmp[0], "wr len");		 // wrong length
			goto try_again;
		}

		if(!ae_check_crc(tmp, actual)) {
 8002a9c:	b2c1      	uxtb	r1, r0
 8002a9e:	4620      	mov	r0, r4
 8002aa0:	f7ff fed5 	bl	800284e <ae_check_crc>
 8002aa4:	b130      	cbz	r0, 8002ab4 <ae_read_n+0x58>
            STATS(crc_error++);
			goto try_again;
		}

		// normal case: copy out body of message w/o framing
        memcpy(body, tmp+1, actual-3);
 8002aa6:	1eea      	subs	r2, r5, #3
 8002aa8:	1c61      	adds	r1, r4, #1
 8002aaa:	4640      	mov	r0, r8
 8002aac:	f00a fce9 	bl	800d482 <memcpy>
#ifdef DEV_STATS
        memcpy(stats.last_n_data, body, MIN(32, actual-3));
        stats.last_n_len =  actual-3;
#endif

		return 0;
 8002ab0:	2000      	movs	r0, #0
 8002ab2:	e006      	b.n	8002ac2 <ae_read_n+0x66>

	try_again:
        STATS(ln_retry++);
        ae_wake();
 8002ab4:	f7ff feec 	bl	8002890 <ae_wake>
	int
ae_read_n(uint8_t len, uint8_t *body)
{
    uint8_t tmp[1+len+2];

	for(int retry=7; retry >= 0; retry--) {
 8002ab8:	f1b9 0901 	subs.w	r9, r9, #1
 8002abc:	d1db      	bne.n	8002a76 <ae_read_n+0x1a>
	try_again:
        STATS(ln_retry++);
        ae_wake();
	}

	return -1;
 8002abe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8002ac2:	46bd      	mov	sp, r7
 8002ac4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08002ac8 <ae_send_n>:

// ae_send_n()
//
	void
ae_send_n(aeopcode_t opcode, uint8_t p1, uint16_t p2, const uint8_t *data, uint8_t data_len) 
{
 8002ac8:	b530      	push	{r4, r5, lr}
 8002aca:	b085      	sub	sp, #20
 8002acc:	461d      	mov	r5, r3
 8002ace:	f89d 4020 	ldrb.w	r4, [sp, #32]
		uint8_t	framed_len;
		uint8_t	op;
		uint8_t	p1;
		uint8_t	p2_lsb;
		uint8_t	p2_msb;
	} known = { 
 8002ad2:	f88d 200c 	strb.w	r2, [sp, #12]
 8002ad6:	2377      	movs	r3, #119	; 0x77
 8002ad8:	0a12      	lsrs	r2, r2, #8
 8002ada:	f88d 3008 	strb.w	r3, [sp, #8]
 8002ade:	1de3      	adds	r3, r4, #7
 8002ae0:	f88d 3009 	strb.w	r3, [sp, #9]
 8002ae4:	f88d 200d 	strb.w	r2, [sp, #13]
 8002ae8:	f88d 000a 	strb.w	r0, [sp, #10]
 8002aec:	f88d 100b 	strb.w	r1, [sp, #11]
    STATS(last_op = opcode);
    STATS(last_p1 = p1);
    STATS(last_p2 = p2);

    // important to wake chip at this point.
    ae_wake();
 8002af0:	f7ff fece 	bl	8002890 <ae_wake>

    _send_serialized((const uint8_t *)&known, sizeof(known));
 8002af4:	2106      	movs	r1, #6
 8002af6:	a802      	add	r0, sp, #8
 8002af8:	f7ff fe55 	bl	80027a6 <_send_serialized>

	// CRC will start from frame_len onwards
	uint8_t crc[2] = {0, 0};
 8002afc:	2300      	movs	r3, #0
	crc16_chain(sizeof(known)-1, &known.framed_len, crc);
 8002afe:	aa01      	add	r2, sp, #4
 8002b00:	f10d 0109 	add.w	r1, sp, #9
 8002b04:	2005      	movs	r0, #5
    ae_wake();

    _send_serialized((const uint8_t *)&known, sizeof(known));

	// CRC will start from frame_len onwards
	uint8_t crc[2] = {0, 0};
 8002b06:	f88d 3004 	strb.w	r3, [sp, #4]
 8002b0a:	f88d 3005 	strb.w	r3, [sp, #5]
	crc16_chain(sizeof(known)-1, &known.framed_len, crc);
 8002b0e:	f7ff fe75 	bl	80027fc <crc16_chain>

	// insert a variable-length body area (sometimes)
	if(data_len) {
 8002b12:	b144      	cbz	r4, 8002b26 <ae_send_n+0x5e>
        _send_serialized(data, data_len);
 8002b14:	4621      	mov	r1, r4
 8002b16:	4628      	mov	r0, r5
 8002b18:	f7ff fe45 	bl	80027a6 <_send_serialized>
		
		crc16_chain(data_len, data, crc);
 8002b1c:	aa01      	add	r2, sp, #4
 8002b1e:	4629      	mov	r1, r5
 8002b20:	4620      	mov	r0, r4
 8002b22:	f7ff fe6b 	bl	80027fc <crc16_chain>
	}

	// send final CRC bytes
    _send_serialized(crc, 2);
 8002b26:	2102      	movs	r1, #2
 8002b28:	a801      	add	r0, sp, #4
 8002b2a:	f7ff fe3c 	bl	80027a6 <_send_serialized>
}
 8002b2e:	b005      	add	sp, #20
 8002b30:	bd30      	pop	{r4, r5, pc}

08002b32 <ae_send>:

// ae_send()
//
	void
ae_send(aeopcode_t opcode, uint8_t p1, uint16_t p2) 
{
 8002b32:	b507      	push	{r0, r1, r2, lr}
	ae_send_n(opcode, p1, p2, NULL, 0);
 8002b34:	2300      	movs	r3, #0
 8002b36:	9300      	str	r3, [sp, #0]
 8002b38:	f7ff ffc6 	bl	8002ac8 <ae_send_n>
}
 8002b3c:	b003      	add	sp, #12
 8002b3e:	f85d fb04 	ldr.w	pc, [sp], #4

08002b42 <ae_get_info>:
//
// Do Info(p1=2) command, and return result.
//
	uint16_t
ae_get_info(void)
{
 8002b42:	b507      	push	{r0, r1, r2, lr}
	// not doing error checking here
	ae_send(OP_Info, 0x2, 0);
 8002b44:	2200      	movs	r2, #0
 8002b46:	2102      	movs	r1, #2
 8002b48:	2030      	movs	r0, #48	; 0x30
 8002b4a:	f7ff fff2 	bl	8002b32 <ae_send>

	// note: always returns 4 bytes, but most are garbage and unused.
	uint8_t tmp[4];
	ae_read_n(4, tmp);
 8002b4e:	a901      	add	r1, sp, #4
 8002b50:	2004      	movs	r0, #4
 8002b52:	f7ff ff83 	bl	8002a5c <ae_read_n>

	return (tmp[0] << 8) | tmp[1];
 8002b56:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8002b5a:	f89d 3005 	ldrb.w	r3, [sp, #5]
}
 8002b5e:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8002b62:	b003      	add	sp, #12
 8002b64:	f85d fb04 	ldr.w	pc, [sp], #4

08002b68 <ae_load_nonce>:
// Load Tempkey with a specific value. Resulting Tempkey cannot be
// used with many commands/keys, but is needed for signing.
//
	int
ae_load_nonce(const uint8_t nonce[32])
{
 8002b68:	b507      	push	{r0, r1, r2, lr}
    // p1=3
	ae_send_n(OP_Nonce, 3, 0, nonce, 32);          // 608a ok
 8002b6a:	2320      	movs	r3, #32
 8002b6c:	9300      	str	r3, [sp, #0]
 8002b6e:	2200      	movs	r2, #0
 8002b70:	4603      	mov	r3, r0
 8002b72:	2103      	movs	r1, #3
 8002b74:	2016      	movs	r0, #22
 8002b76:	f7ff ffa7 	bl	8002ac8 <ae_send_n>

    return ae_read1();
}
 8002b7a:	b003      	add	sp, #12
 8002b7c:	f85d eb04 	ldr.w	lr, [sp], #4
ae_load_nonce(const uint8_t nonce[32])
{
    // p1=3
	ae_send_n(OP_Nonce, 3, 0, nonce, 32);          // 608a ok

    return ae_read1();
 8002b80:	f7ff bf50 	b.w	8002a24 <ae_read1>

08002b84 <ae_load_msgdigest>:
// Load 32bytes of message digest  with a specific value.
// Needed for signing.
//
	int
ae_load_msgdigest(const uint8_t md[32])
{
 8002b84:	b507      	push	{r0, r1, r2, lr}
	ae_send_n(OP_Nonce, (1<<6) | 3, 0, md, 32);
 8002b86:	2320      	movs	r3, #32
 8002b88:	9300      	str	r3, [sp, #0]
 8002b8a:	2200      	movs	r2, #0
 8002b8c:	4603      	mov	r3, r0
 8002b8e:	2143      	movs	r1, #67	; 0x43
 8002b90:	2016      	movs	r0, #22
 8002b92:	f7ff ff99 	bl	8002ac8 <ae_send_n>

    return ae_read1();
}
 8002b96:	b003      	add	sp, #12
 8002b98:	f85d eb04 	ldr.w	lr, [sp], #4
	int
ae_load_msgdigest(const uint8_t md[32])
{
	ae_send_n(OP_Nonce, (1<<6) | 3, 0, md, 32);

    return ae_read1();
 8002b9c:	f7ff bf42 	b.w	8002a24 <ae_read1>

08002ba0 <ae_pick_nonce>:
// Load Tempkey with a nonce value that we both know, but
// is random and we both know is random! Tricky!
//
	int
ae_pick_nonce(const uint8_t num_in[20], uint8_t tempkey[32])
{
 8002ba0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002ba2:	b09f      	sub	sp, #124	; 0x7c
	// We provide some 20 bytes of randomness to chip
	// The chip must provide 32-bytes of random-ness,
	// so no choice in args to OP.Nonce here (due to ReqRandom).
	ae_send_n(OP_Nonce, 0, 0, num_in, 20);
 8002ba4:	2200      	movs	r2, #0
 8002ba6:	2614      	movs	r6, #20
 8002ba8:	4603      	mov	r3, r0
// Load Tempkey with a nonce value that we both know, but
// is random and we both know is random! Tricky!
//
	int
ae_pick_nonce(const uint8_t num_in[20], uint8_t tempkey[32])
{
 8002baa:	4605      	mov	r5, r0
 8002bac:	460f      	mov	r7, r1
	// We provide some 20 bytes of randomness to chip
	// The chip must provide 32-bytes of random-ness,
	// so no choice in args to OP.Nonce here (due to ReqRandom).
	ae_send_n(OP_Nonce, 0, 0, num_in, 20);
 8002bae:	2016      	movs	r0, #22
 8002bb0:	4611      	mov	r1, r2
 8002bb2:	9600      	str	r6, [sp, #0]
 8002bb4:	f7ff ff88 	bl	8002ac8 <ae_send_n>

    rng_delay();
 8002bb8:	f7ff fdc1 	bl	800273e <rng_delay>

	// Nonce command returns the RNG result, but not contents of TempKey
	uint8_t randout[32];
	int rv = ae_read_n(32, randout);
 8002bbc:	a903      	add	r1, sp, #12
 8002bbe:	2020      	movs	r0, #32
 8002bc0:	f7ff ff4c 	bl	8002a5c <ae_read_n>
	RET_IF_BAD(rv);
 8002bc4:	4604      	mov	r4, r0
 8002bc6:	b9f0      	cbnz	r0, 8002c06 <ae_pick_nonce+0x66>
	//
	//		return sha256(rndout + num_in + b'\x16\0\0').digest()
	//
	SHA256_CTX ctx;

    sha256_init(&ctx);
 8002bc8:	a80b      	add	r0, sp, #44	; 0x2c
 8002bca:	f002 fbc5 	bl	8005358 <sha256_init>
    sha256_update(&ctx, randout, 32);
 8002bce:	2220      	movs	r2, #32
 8002bd0:	a903      	add	r1, sp, #12
 8002bd2:	a80b      	add	r0, sp, #44	; 0x2c
 8002bd4:	f002 fbd0 	bl	8005378 <sha256_update>
    sha256_update(&ctx, num_in, 20);
 8002bd8:	4632      	mov	r2, r6
 8002bda:	4629      	mov	r1, r5
 8002bdc:	a80b      	add	r0, sp, #44	; 0x2c
 8002bde:	f002 fbcb 	bl	8005378 <sha256_update>
	const uint8_t fixed[3] = { 0x16, 0, 0 };
 8002be2:	2316      	movs	r3, #22
    sha256_update(&ctx, fixed, 3);
 8002be4:	2203      	movs	r2, #3
 8002be6:	a902      	add	r1, sp, #8
 8002be8:	a80b      	add	r0, sp, #44	; 0x2c
	SHA256_CTX ctx;

    sha256_init(&ctx);
    sha256_update(&ctx, randout, 32);
    sha256_update(&ctx, num_in, 20);
	const uint8_t fixed[3] = { 0x16, 0, 0 };
 8002bea:	f88d 3008 	strb.w	r3, [sp, #8]
 8002bee:	f88d 4009 	strb.w	r4, [sp, #9]
 8002bf2:	f88d 400a 	strb.w	r4, [sp, #10]
    sha256_update(&ctx, fixed, 3);
 8002bf6:	f002 fbbf 	bl	8005378 <sha256_update>

    sha256_final(&ctx, tempkey);
 8002bfa:	4639      	mov	r1, r7
 8002bfc:	a80b      	add	r0, sp, #44	; 0x2c
 8002bfe:	f002 fc01 	bl	8005404 <sha256_final>

    rng_delay();
 8002c02:	f7ff fd9c 	bl	800273e <rng_delay>

	return 0;
}
 8002c06:	4620      	mov	r0, r4
 8002c08:	b01f      	add	sp, #124	; 0x7c
 8002c0a:	bdf0      	pop	{r4, r5, r6, r7, pc}

08002c0c <ae_is_correct_tempkey>:
// Check that TempKey is holding what we think it does. Uses the MAC
// command over contents of Tempkey and our shared secret.
//
    bool
ae_is_correct_tempkey(const uint8_t expected_tempkey[32])
{
 8002c0c:	b570      	push	{r4, r5, r6, lr}
    const uint8_t mode =   (1<<6)     // include full serial number
                         | (0<<2)     // TempKey.SourceFlag == 0 == 'rand'
                         | (0<<1)     // first 32 bytes are the shared secret
                         | (1<<0);    // second 32 bytes are tempkey

	ae_send(OP_MAC, mode, KEYNUM_pairing);
 8002c0e:	2141      	movs	r1, #65	; 0x41
// Check that TempKey is holding what we think it does. Uses the MAC
// command over contents of Tempkey and our shared secret.
//
    bool
ae_is_correct_tempkey(const uint8_t expected_tempkey[32])
{
 8002c10:	b0a8      	sub	sp, #160	; 0xa0
 8002c12:	4604      	mov	r4, r0
    const uint8_t mode =   (1<<6)     // include full serial number
                         | (0<<2)     // TempKey.SourceFlag == 0 == 'rand'
                         | (0<<1)     // first 32 bytes are the shared secret
                         | (1<<0);    // second 32 bytes are tempkey

	ae_send(OP_MAC, mode, KEYNUM_pairing);
 8002c14:	2201      	movs	r2, #1
 8002c16:	2008      	movs	r0, #8
 8002c18:	f7ff ff8b 	bl	8002b32 <ae_send>

    // read chip's answer
	uint8_t resp[32];
	int rv = ae_read_n(32, resp);
 8002c1c:	a905      	add	r1, sp, #20
 8002c1e:	2020      	movs	r0, #32
 8002c20:	f7ff ff1c 	bl	8002a5c <ae_read_n>
    if(rv) return false;
 8002c24:	2800      	cmp	r0, #0
 8002c26:	d134      	bne.n	8002c92 <ae_is_correct_tempkey+0x86>

    ae_keep_alive();
 8002c28:	f7ff fef2 	bl	8002a10 <ae_keep_alive>

    // Duplicate the hash process, and then compare.
	SHA256_CTX ctx;

    sha256_init(&ctx);
 8002c2c:	a815      	add	r0, sp, #84	; 0x54
 8002c2e:	f002 fb93 	bl	8005358 <sha256_init>
    sha256_update(&ctx, rom_secrets->pairing_secret, 32);
 8002c32:	2220      	movs	r2, #32
 8002c34:	4918      	ldr	r1, [pc, #96]	; (8002c98 <ae_is_correct_tempkey+0x8c>)
 8002c36:	a815      	add	r0, sp, #84	; 0x54
 8002c38:	f002 fb9e 	bl	8005378 <sha256_update>
    sha256_update(&ctx, expected_tempkey, 32);
 8002c3c:	2220      	movs	r2, #32
 8002c3e:	4621      	mov	r1, r4
 8002c40:	a815      	add	r0, sp, #84	; 0x54
 8002c42:	f002 fb99 	bl	8005378 <sha256_update>

	const uint8_t fixed[16] = { OP_MAC, mode, KEYNUM_pairing, 0x0,
 8002c46:	4b15      	ldr	r3, [pc, #84]	; (8002c9c <ae_is_correct_tempkey+0x90>)
 8002c48:	aa01      	add	r2, sp, #4
 8002c4a:	f103 0610 	add.w	r6, r3, #16
 8002c4e:	4615      	mov	r5, r2
 8002c50:	6818      	ldr	r0, [r3, #0]
 8002c52:	6859      	ldr	r1, [r3, #4]
 8002c54:	4614      	mov	r4, r2
 8002c56:	c403      	stmia	r4!, {r0, r1}
 8002c58:	3308      	adds	r3, #8
 8002c5a:	42b3      	cmp	r3, r6
 8002c5c:	4622      	mov	r2, r4
 8002c5e:	d1f7      	bne.n	8002c50 <ae_is_correct_tempkey+0x44>
                                    0,0,0,0, 0,0,0,0,       // eight zeros
                                    0,0,0,                  // three zeros
                                    0xEE };
    sha256_update(&ctx, fixed, sizeof(fixed));
 8002c60:	4629      	mov	r1, r5
 8002c62:	a815      	add	r0, sp, #84	; 0x54
 8002c64:	2210      	movs	r2, #16
 8002c66:	f002 fb87 	bl	8005378 <sha256_update>

    sha256_update(&ctx, ((const uint8_t *)rom_secrets->ae_serial_number)+4, 4);
 8002c6a:	a815      	add	r0, sp, #84	; 0x54
 8002c6c:	2204      	movs	r2, #4
 8002c6e:	490c      	ldr	r1, [pc, #48]	; (8002ca0 <ae_is_correct_tempkey+0x94>)
 8002c70:	f002 fb82 	bl	8005378 <sha256_update>
    sha256_update(&ctx, ((const uint8_t *)rom_secrets->ae_serial_number)+0, 4);
 8002c74:	2204      	movs	r2, #4
 8002c76:	a815      	add	r0, sp, #84	; 0x54
 8002c78:	490a      	ldr	r1, [pc, #40]	; (8002ca4 <ae_is_correct_tempkey+0x98>)
 8002c7a:	f002 fb7d 	bl	8005378 <sha256_update>
	// this verifies no problem.
	ASSERT(ctx.datalen + (ctx.bitlen/8) == 32+32+1+1+2+8+3+1+4+2+2);        // == 88
#endif

    uint8_t         actual[32];
    sha256_final(&ctx, actual);
 8002c7e:	a90d      	add	r1, sp, #52	; 0x34
 8002c80:	a815      	add	r0, sp, #84	; 0x54
 8002c82:	f002 fbbf 	bl	8005404 <sha256_final>

    return check_equal(actual, resp, 32);
 8002c86:	2220      	movs	r2, #32
 8002c88:	a905      	add	r1, sp, #20
 8002c8a:	a80d      	add	r0, sp, #52	; 0x34
 8002c8c:	f7ff fcef 	bl	800266e <check_equal>
 8002c90:	e000      	b.n	8002c94 <ae_is_correct_tempkey+0x88>
	ae_send(OP_MAC, mode, KEYNUM_pairing);

    // read chip's answer
	uint8_t resp[32];
	int rv = ae_read_n(32, resp);
    if(rv) return false;
 8002c92:	2000      	movs	r0, #0

    uint8_t         actual[32];
    sha256_final(&ctx, actual);

    return check_equal(actual, resp, 32);
}
 8002c94:	b028      	add	sp, #160	; 0xa0
 8002c96:	bd70      	pop	{r4, r5, r6, pc}
 8002c98:	0801e000 	.word	0x0801e000
 8002c9c:	0800e3aa 	.word	0x0800e3aa
 8002ca0:	0801e044 	.word	0x0801e044
 8002ca4:	0801e040 	.word	0x0801e040

08002ca8 <ae_checkmac>:
// inside the 508a/608a, like use of a specific key, but not for us to
// authenticate the 508a/608a or its contents/state.
//
    int
ae_checkmac(uint8_t keynum, const uint8_t secret[32])
{
 8002ca8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002caa:	b0c3      	sub	sp, #268	; 0x10c

	// Since this is part of the hash, we want random bytes
	// for our "other data". Also a number for "numin" of nonce
	uint8_t od[32], numin[20];

	rng_buffer(od, sizeof(od));
 8002cac:	ad0b      	add	r5, sp, #44	; 0x2c
// inside the 508a/608a, like use of a specific key, but not for us to
// authenticate the 508a/608a or its contents/state.
//
    int
ae_checkmac(uint8_t keynum, const uint8_t secret[32])
{
 8002cae:	4606      	mov	r6, r0
 8002cb0:	460c      	mov	r4, r1

	// Since this is part of the hash, we want random bytes
	// for our "other data". Also a number for "numin" of nonce
	uint8_t od[32], numin[20];

	rng_buffer(od, sizeof(od));
 8002cb2:	4628      	mov	r0, r5
 8002cb4:	2120      	movs	r1, #32
 8002cb6:	f7ff fd2b 	bl	8002710 <rng_buffer>
	rng_buffer(numin, sizeof(numin));
 8002cba:	2114      	movs	r1, #20
 8002cbc:	a806      	add	r0, sp, #24
 8002cbe:	f7ff fd27 	bl	8002710 <rng_buffer>

    // need this one, want to reset watchdog to this point.
	ae_keep_alive();
 8002cc2:	f7ff fea5 	bl	8002a10 <ae_keep_alive>

	// - load tempkey with a known nonce value
	uint8_t zeros[8] = {0};
 8002cc6:	2300      	movs	r3, #0
	uint8_t tempkey[32];
	rv = ae_pick_nonce(numin, tempkey);
 8002cc8:	a913      	add	r1, sp, #76	; 0x4c
 8002cca:	a806      	add	r0, sp, #24

    // need this one, want to reset watchdog to this point.
	ae_keep_alive();

	// - load tempkey with a known nonce value
	uint8_t zeros[8] = {0};
 8002ccc:	9304      	str	r3, [sp, #16]
 8002cce:	9305      	str	r3, [sp, #20]
	uint8_t tempkey[32];
	rv = ae_pick_nonce(numin, tempkey);
 8002cd0:	f7ff ff66 	bl	8002ba0 <ae_pick_nonce>
	RET_IF_BAD(rv);
 8002cd4:	2800      	cmp	r0, #0
 8002cd6:	d160      	bne.n	8002d9a <ae_checkmac+0xf2>

	// - hash nonce and lots of other bits together
	SHA256_CTX ctx;
    sha256_init(&ctx);
 8002cd8:	a81b      	add	r0, sp, #108	; 0x6c
 8002cda:	f002 fb3d 	bl	8005358 <sha256_init>

    // shared secret is 32 bytes from flash
    sha256_update(&ctx, secret, 32);
 8002cde:	2220      	movs	r2, #32
 8002ce0:	4621      	mov	r1, r4
 8002ce2:	a81b      	add	r0, sp, #108	; 0x6c
 8002ce4:	f002 fb48 	bl	8005378 <sha256_update>

    sha256_update(&ctx, tempkey, 32);
 8002ce8:	2220      	movs	r2, #32
 8002cea:	a913      	add	r1, sp, #76	; 0x4c
 8002cec:	a81b      	add	r0, sp, #108	; 0x6c
 8002cee:	f002 fb43 	bl	8005378 <sha256_update>
    sha256_update(&ctx, &od[0], 4);
 8002cf2:	2204      	movs	r2, #4
 8002cf4:	4629      	mov	r1, r5
 8002cf6:	a81b      	add	r0, sp, #108	; 0x6c
 8002cf8:	f002 fb3e 	bl	8005378 <sha256_update>

    sha256_update(&ctx, zeros, 8);
 8002cfc:	2208      	movs	r2, #8
 8002cfe:	a904      	add	r1, sp, #16
 8002d00:	a81b      	add	r0, sp, #108	; 0x6c
 8002d02:	f002 fb39 	bl	8005378 <sha256_update>

    sha256_update(&ctx, &od[4], 3);
 8002d06:	2203      	movs	r2, #3
 8002d08:	a90c      	add	r1, sp, #48	; 0x30
 8002d0a:	a81b      	add	r0, sp, #108	; 0x6c
 8002d0c:	f002 fb34 	bl	8005378 <sha256_update>

	uint8_t ee = 0xEE;
 8002d10:	a942      	add	r1, sp, #264	; 0x108
 8002d12:	23ee      	movs	r3, #238	; 0xee
 8002d14:	f801 3dfd 	strb.w	r3, [r1, #-253]!
    sha256_update(&ctx, &ee, 1);
 8002d18:	2201      	movs	r2, #1
 8002d1a:	a81b      	add	r0, sp, #108	; 0x6c
 8002d1c:	f002 fb2c 	bl	8005378 <sha256_update>
    sha256_update(&ctx, &od[7], 4);
 8002d20:	2204      	movs	r2, #4
 8002d22:	f10d 0133 	add.w	r1, sp, #51	; 0x33
 8002d26:	a81b      	add	r0, sp, #108	; 0x6c
 8002d28:	f002 fb26 	bl	8005378 <sha256_update>

	uint8_t snp[2] = { 0x01, 0x23 };
 8002d2c:	4b1c      	ldr	r3, [pc, #112]	; (8002da0 <ae_checkmac+0xf8>)
    sha256_update(&ctx, snp, 2);
 8002d2e:	2202      	movs	r2, #2

	uint8_t ee = 0xEE;
    sha256_update(&ctx, &ee, 1);
    sha256_update(&ctx, &od[7], 4);

	uint8_t snp[2] = { 0x01, 0x23 };
 8002d30:	881b      	ldrh	r3, [r3, #0]
 8002d32:	f8ad 300c 	strh.w	r3, [sp, #12]
    sha256_update(&ctx, snp, 2);
 8002d36:	a903      	add	r1, sp, #12
 8002d38:	a81b      	add	r0, sp, #108	; 0x6c
 8002d3a:	f002 fb1d 	bl	8005378 <sha256_update>
    sha256_update(&ctx, &od[11], 2);
 8002d3e:	2202      	movs	r2, #2
 8002d40:	f10d 0137 	add.w	r1, sp, #55	; 0x37
 8002d44:	a81b      	add	r0, sp, #108	; 0x6c
 8002d46:	f002 fb17 	bl	8005378 <sha256_update>
		uint8_t		resp[32];
		uint8_t		od[13];
	} req;

    // content doesn't matter, but nice and visible:
    memcpy(req.ch3, copyright_msg, 32);
 8002d4a:	4b16      	ldr	r3, [pc, #88]	; (8002da4 <ae_checkmac+0xfc>)
 8002d4c:	aa2e      	add	r2, sp, #184	; 0xb8
 8002d4e:	f103 0e20 	add.w	lr, r3, #32
 8002d52:	4617      	mov	r7, r2
 8002d54:	6818      	ldr	r0, [r3, #0]
 8002d56:	6859      	ldr	r1, [r3, #4]
 8002d58:	4614      	mov	r4, r2
 8002d5a:	c403      	stmia	r4!, {r0, r1}
 8002d5c:	3308      	adds	r3, #8
 8002d5e:	4573      	cmp	r3, lr
 8002d60:	4622      	mov	r2, r4
 8002d62:	d1f7      	bne.n	8002d54 <ae_checkmac+0xac>
	// this verifies no problem.
	int l = (ctx.blocks * 64) + ctx.npartial;
	ASSERT(l == 32+32+4+8+3+1+4+2+2);			// == 88
#endif

    sha256_final(&ctx, req.resp);
 8002d64:	a936      	add	r1, sp, #216	; 0xd8
 8002d66:	a81b      	add	r0, sp, #108	; 0x6c
 8002d68:	f002 fb4c 	bl	8005404 <sha256_final>
	memcpy(req.od, od, 13);
 8002d6c:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8002d70:	ac3e      	add	r4, sp, #248	; 0xf8
 8002d72:	c407      	stmia	r4!, {r0, r1, r2}
 8002d74:	7023      	strb	r3, [r4, #0]

	STATIC_ASSERT(sizeof(req) == 32 + 32 + 13);

	// Give our answer to the chip.
	ae_send_n(OP_CheckMac, 0x01, keynum, (uint8_t *)&req, sizeof(req));
 8002d76:	234d      	movs	r3, #77	; 0x4d
 8002d78:	9300      	str	r3, [sp, #0]
 8002d7a:	4632      	mov	r2, r6
 8002d7c:	463b      	mov	r3, r7
 8002d7e:	2101      	movs	r1, #1
 8002d80:	2028      	movs	r0, #40	; 0x28
 8002d82:	f7ff fea1 	bl	8002ac8 <ae_send_n>

	rv = ae_read1();
 8002d86:	f7ff fe4d 	bl	8002a24 <ae_read1>
	if(rv != 0) {
 8002d8a:	4604      	mov	r4, r0
 8002d8c:	b918      	cbnz	r0, 8002d96 <ae_checkmac+0xee>
		return -1;
	}
#endif

	// just in case ... always restart watchdog timer.
	ae_keep_alive();
 8002d8e:	f7ff fe3f 	bl	8002a10 <ae_keep_alive>

	return 0;
 8002d92:	4620      	mov	r0, r4
 8002d94:	e001      	b.n	8002d9a <ae_checkmac+0xf2>
		if(rv == AE_CHECKMAC_FAIL) {
			ERR("CM fail");				// typical case: our hashs don't match
		} else {
			ERRV(rv, "CheckMac");
		}
		return -1;
 8002d96:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff

	// just in case ... always restart watchdog timer.
	ae_keep_alive();

	return 0;
}
 8002d9a:	b043      	add	sp, #268	; 0x10c
 8002d9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002d9e:	bf00      	nop
 8002da0:	0800e3ba 	.word	0x0800e3ba
 8002da4:	0800e3bc 	.word	0x0800e3bc

08002da8 <ae_pair_unlock>:
// Purpose is to show we are a pair of chips that belong together.
//
	int
ae_pair_unlock()
{
    return ae_checkmac(KEYNUM_pairing, rom_secrets->pairing_secret);
 8002da8:	4901      	ldr	r1, [pc, #4]	; (8002db0 <ae_pair_unlock+0x8>)
 8002daa:	2001      	movs	r0, #1
 8002dac:	f7ff bf7c 	b.w	8002ca8 <ae_checkmac>
 8002db0:	0801e000 	.word	0x0801e000

08002db4 <ae_sign_authed>:
// Sign a message (already digested)
//
	int
ae_sign_authed(uint8_t keynum, const uint8_t msg_hash[32],
                uint8_t signature[64], int auth_kn, const uint8_t auth_digest[32])
{
 8002db4:	b570      	push	{r4, r5, r6, lr}
 8002db6:	460e      	mov	r6, r1
 8002db8:	4604      	mov	r4, r0
 8002dba:	4615      	mov	r5, r2
    // indicate we know the PIN
    ae_pair_unlock();
 8002dbc:	f7ff fff4 	bl	8002da8 <ae_pair_unlock>
    int rv = ae_checkmac(KEYNUM_main_pin, auth_digest);
 8002dc0:	9904      	ldr	r1, [sp, #16]
 8002dc2:	2003      	movs	r0, #3
 8002dc4:	f7ff ff70 	bl	8002ca8 <ae_checkmac>
    RET_IF_BAD(rv);
 8002dc8:	b990      	cbnz	r0, 8002df0 <ae_sign_authed+0x3c>

    // send what we need signed
	rv = ae_load_msgdigest(msg_hash);
 8002dca:	4630      	mov	r0, r6
 8002dcc:	f7ff feda 	bl	8002b84 <ae_load_msgdigest>
	RET_IF_BAD(rv);
 8002dd0:	b970      	cbnz	r0, 8002df0 <ae_sign_authed+0x3c>

    do {
        ae_send(OP_Sign, (7<<5), keynum);
 8002dd2:	b2a4      	uxth	r4, r4
 8002dd4:	4622      	mov	r2, r4
 8002dd6:	21e0      	movs	r1, #224	; 0xe0
 8002dd8:	2041      	movs	r0, #65	; 0x41
 8002dda:	f7ff feaa 	bl	8002b32 <ae_send>

        delay_ms(60);     // min time for processing
 8002dde:	203c      	movs	r0, #60	; 0x3c
 8002de0:	f000 fd56 	bl	8003890 <delay_ms>

        rv = ae_read_n(64, signature);
 8002de4:	4629      	mov	r1, r5
 8002de6:	2040      	movs	r0, #64	; 0x40
 8002de8:	f7ff fe38 	bl	8002a5c <ae_read_n>
    } while(rv == AE_ECC_FAULT);
 8002dec:	2805      	cmp	r0, #5
 8002dee:	d0f1      	beq.n	8002dd4 <ae_sign_authed+0x20>

	return rv;
}
 8002df0:	bd70      	pop	{r4, r5, r6, pc}

08002df2 <ae_gen_ecc_key>:

// ae_gen_ecc_key()
//
    int
ae_gen_ecc_key(uint8_t keynum, uint8_t pubkey_out[64])
{
 8002df2:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    int rv;
    uint8_t junk[3] = { 0 };
 8002df4:	2300      	movs	r3, #0

// ae_gen_ecc_key()
//
    int
ae_gen_ecc_key(uint8_t keynum, uint8_t pubkey_out[64])
{
 8002df6:	460c      	mov	r4, r1
    int rv;
    uint8_t junk[3] = { 0 };
 8002df8:	f8ad 300c 	strh.w	r3, [sp, #12]
 8002dfc:	f88d 300e 	strb.w	r3, [sp, #14]

    do {
        ae_send_n(OP_GenKey, (1<<2), keynum, junk, 3);
 8002e00:	4605      	mov	r5, r0
 8002e02:	2603      	movs	r6, #3
 8002e04:	ab03      	add	r3, sp, #12
 8002e06:	462a      	mov	r2, r5
 8002e08:	2104      	movs	r1, #4
 8002e0a:	2040      	movs	r0, #64	; 0x40
 8002e0c:	9600      	str	r6, [sp, #0]
 8002e0e:	f7ff fe5b 	bl	8002ac8 <ae_send_n>

        delay_ms(100);     // to avoid timeouts
 8002e12:	2064      	movs	r0, #100	; 0x64
 8002e14:	f000 fd3c 	bl	8003890 <delay_ms>

        rv = ae_read_n(64, pubkey_out);
 8002e18:	4621      	mov	r1, r4
 8002e1a:	2040      	movs	r0, #64	; 0x40
 8002e1c:	f7ff fe1e 	bl	8002a5c <ae_read_n>
    } while(rv == AE_ECC_FAULT);
 8002e20:	2805      	cmp	r0, #5
 8002e22:	d0ef      	beq.n	8002e04 <ae_gen_ecc_key+0x12>

    return rv;
}
 8002e24:	b004      	add	sp, #16
 8002e26:	bd70      	pop	{r4, r5, r6, pc}

08002e28 <ae_hmac32>:
// 508a: Different opcode, OP_HMAC does exactly 32 bytes w/ less steps.
// 608a: Use old SHA256 command, but with new flags.
//
    int
ae_hmac32(uint8_t keynum, const uint8_t msg[32], uint8_t digest[32])
{
 8002e28:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8002e2a:	460e      	mov	r6, r1
 8002e2c:	4615      	mov	r5, r2
    return ae_read_n(32, digest);
#endif

#if FOR_608
    // Start SHA w/ HMAC setup
	ae_send(OP_SHA, 4, keynum);        // 4 = HMAC_Init
 8002e2e:	2104      	movs	r1, #4
 8002e30:	4602      	mov	r2, r0
 8002e32:	2047      	movs	r0, #71	; 0x47
 8002e34:	f7ff fe7d 	bl	8002b32 <ae_send>

    // expect zero, meaning "ready"
    int rv = ae_read1();
 8002e38:	f7ff fdf4 	bl	8002a24 <ae_read1>
    RET_IF_BAD(rv);
 8002e3c:	b970      	cbnz	r0, 8002e5c <ae_hmac32+0x34>

    // send the contents to be hashed
	ae_send_n(OP_SHA, (3<<6) | 2, 32, msg, 32); // 2 = Finalize, 3=Place output
 8002e3e:	2420      	movs	r4, #32
 8002e40:	9400      	str	r4, [sp, #0]
 8002e42:	4633      	mov	r3, r6
 8002e44:	4622      	mov	r2, r4
 8002e46:	21c2      	movs	r1, #194	; 0xc2
 8002e48:	2047      	movs	r0, #71	; 0x47
 8002e4a:	f7ff fe3d 	bl	8002ac8 <ae_send_n>
    
    // read result
    return ae_read_n(32, digest);
 8002e4e:	4629      	mov	r1, r5
 8002e50:	4620      	mov	r0, r4
#endif
}
 8002e52:	b002      	add	sp, #8
 8002e54:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

    // send the contents to be hashed
	ae_send_n(OP_SHA, (3<<6) | 2, 32, msg, 32); // 2 = Finalize, 3=Place output
    
    // read result
    return ae_read_n(32, digest);
 8002e58:	f7ff be00 	b.w	8002a5c <ae_read_n>
#endif
}
 8002e5c:	b002      	add	sp, #8
 8002e5e:	bd70      	pop	{r4, r5, r6, pc}

08002e60 <ae_get_serial>:
//
// Return the serial number: it's 9 bytes, altho 3 are fixed.
//
	int
ae_get_serial(uint8_t serial[6])
{
 8002e60:	b510      	push	{r4, lr}
	ae_send(OP_Read, 0x80, 0x0);
 8002e62:	2200      	movs	r2, #0
//
// Return the serial number: it's 9 bytes, altho 3 are fixed.
//
	int
ae_get_serial(uint8_t serial[6])
{
 8002e64:	b08c      	sub	sp, #48	; 0x30
	ae_send(OP_Read, 0x80, 0x0);
 8002e66:	2180      	movs	r1, #128	; 0x80
//
// Return the serial number: it's 9 bytes, altho 3 are fixed.
//
	int
ae_get_serial(uint8_t serial[6])
{
 8002e68:	4604      	mov	r4, r0
	ae_send(OP_Read, 0x80, 0x0);
 8002e6a:	2002      	movs	r0, #2
 8002e6c:	f7ff fe61 	bl	8002b32 <ae_send>

	uint8_t temp[32];
	int rv = ae_read_n(32, temp);
 8002e70:	a904      	add	r1, sp, #16
 8002e72:	2020      	movs	r0, #32
 8002e74:	f7ff fdf2 	bl	8002a5c <ae_read_n>
	RET_IF_BAD(rv);
 8002e78:	4602      	mov	r2, r0
 8002e7a:	b9b0      	cbnz	r0, 8002eaa <ae_get_serial+0x4a>

    // reformat to 9 bytes.
    uint8_t ts[9];
	memcpy(ts, &temp[0], 4);
	memcpy(&ts[4], &temp[8], 5);
 8002e7c:	a906      	add	r1, sp, #24
 8002e7e:	c903      	ldmia	r1, {r0, r1}
	int rv = ae_read_n(32, temp);
	RET_IF_BAD(rv);

    // reformat to 9 bytes.
    uint8_t ts[9];
	memcpy(ts, &temp[0], 4);
 8002e80:	9b04      	ldr	r3, [sp, #16]
	memcpy(&ts[4], &temp[8], 5);
 8002e82:	9002      	str	r0, [sp, #8]

    // check the hard-coded values
    if((ts[0] != 0x01) || (ts[1] != 0x23) || (ts[8] != 0xEE)) return 1;
 8002e84:	b2d8      	uxtb	r0, r3
 8002e86:	2801      	cmp	r0, #1
	int rv = ae_read_n(32, temp);
	RET_IF_BAD(rv);

    // reformat to 9 bytes.
    uint8_t ts[9];
	memcpy(ts, &temp[0], 4);
 8002e88:	9301      	str	r3, [sp, #4]
	memcpy(&ts[4], &temp[8], 5);
 8002e8a:	f88d 100c 	strb.w	r1, [sp, #12]

    // check the hard-coded values
    if((ts[0] != 0x01) || (ts[1] != 0x23) || (ts[8] != 0xEE)) return 1;
 8002e8e:	d10e      	bne.n	8002eae <ae_get_serial+0x4e>
 8002e90:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8002e94:	2b23      	cmp	r3, #35	; 0x23
 8002e96:	d10b      	bne.n	8002eb0 <ae_get_serial+0x50>
 8002e98:	b2cb      	uxtb	r3, r1
 8002e9a:	2bee      	cmp	r3, #238	; 0xee
 8002e9c:	d108      	bne.n	8002eb0 <ae_get_serial+0x50>

    // save only the unique bits.
    memcpy(serial, ts+2, 6);
 8002e9e:	ab0c      	add	r3, sp, #48	; 0x30
 8002ea0:	f853 1d2a 	ldr.w	r1, [r3, #-42]!
 8002ea4:	6021      	str	r1, [r4, #0]
 8002ea6:	889b      	ldrh	r3, [r3, #4]
 8002ea8:	80a3      	strh	r3, [r4, #4]
 8002eaa:	4610      	mov	r0, r2
 8002eac:	e000      	b.n	8002eb0 <ae_get_serial+0x50>
    uint8_t ts[9];
	memcpy(ts, &temp[0], 4);
	memcpy(&ts[4], &temp[8], 5);

    // check the hard-coded values
    if((ts[0] != 0x01) || (ts[1] != 0x23) || (ts[8] != 0xEE)) return 1;
 8002eae:	2001      	movs	r0, #1

    // save only the unique bits.
    memcpy(serial, ts+2, 6);

	return 0;
}
 8002eb0:	b00c      	add	sp, #48	; 0x30
 8002eb2:	bd10      	pop	{r4, pc}

08002eb4 <ae_probe>:

// ae_probe()
//
	const char *
ae_probe(void)
{
 8002eb4:	b513      	push	{r0, r1, r4, lr}
ae_send_sleep(void)
{
	// "The ATECC508A goes into the low power sleep mode and ignores all
	// subsequent I/O transitions until the next wake flag. The entire volatile
	// state of the device is reset"
    ae_wake();
 8002eb6:	f7ff fceb 	bl	8002890 <ae_wake>

    _send_bits(IOFLAG_SLEEP);
 8002eba:	20cc      	movs	r0, #204	; 0xcc
 8002ebc:	f7ff fc64 	bl	8002788 <_send_bits>
{
    // Make it sleep / wake it up.
	ae_send_sleep();

    // Wake it again (to reset state)
    ae_wake();
 8002ec0:	f7ff fce6 	bl	8002890 <ae_wake>

	// do a real read w/ CRC
	// with no command happening, expect 0x11: "After Wake, prior to first command"
    ae_read1();
 8002ec4:	f7ff fdae 	bl	8002a24 <ae_read1>

	uint8_t chk = ae_read1();
 8002ec8:	f7ff fdac 	bl	8002a24 <ae_read1>
	if(chk != AE_AFTER_WAKE) return "wk fl";
 8002ecc:	b2c0      	uxtb	r0, r0
 8002ece:	2811      	cmp	r0, #17
 8002ed0:	d10d      	bne.n	8002eee <ae_probe+0x3a>

    // read the serial number one time
    uint8_t serial[6];
	if(ae_get_serial(serial)) return "no ser";
 8002ed2:	4668      	mov	r0, sp
 8002ed4:	f7ff ffc4 	bl	8002e60 <ae_get_serial>
 8002ed8:	4604      	mov	r4, r0
 8002eda:	b930      	cbnz	r0, 8002eea <ae_probe+0x36>
ae_send_sleep(void)
{
	// "The ATECC508A goes into the low power sleep mode and ignores all
	// subsequent I/O transitions until the next wake flag. The entire volatile
	// state of the device is reset"
    ae_wake();
 8002edc:	f7ff fcd8 	bl	8002890 <ae_wake>

    _send_bits(IOFLAG_SLEEP);
 8002ee0:	20cc      	movs	r0, #204	; 0xcc
 8002ee2:	f7ff fc51 	bl	8002788 <_send_bits>
	if(ae_get_serial(serial)) return "no ser";

	// put into a low-power mode, might be a bit before we come back
	ae_send_sleep();

	return NULL;
 8002ee6:	4620      	mov	r0, r4
 8002ee8:	e002      	b.n	8002ef0 <ae_probe+0x3c>
	uint8_t chk = ae_read1();
	if(chk != AE_AFTER_WAKE) return "wk fl";

    // read the serial number one time
    uint8_t serial[6];
	if(ae_get_serial(serial)) return "no ser";
 8002eea:	4802      	ldr	r0, [pc, #8]	; (8002ef4 <ae_probe+0x40>)
 8002eec:	e000      	b.n	8002ef0 <ae_probe+0x3c>
	// do a real read w/ CRC
	// with no command happening, expect 0x11: "After Wake, prior to first command"
    ae_read1();

	uint8_t chk = ae_read1();
	if(chk != AE_AFTER_WAKE) return "wk fl";
 8002eee:	4802      	ldr	r0, [pc, #8]	; (8002ef8 <ae_probe+0x44>)

	// put into a low-power mode, might be a bit before we come back
	ae_send_sleep();

	return NULL;
}
 8002ef0:	b002      	add	sp, #8
 8002ef2:	bd10      	pop	{r4, pc}
 8002ef4:	0800e3dd 	.word	0x0800e3dd
 8002ef8:	0800e3e4 	.word	0x0800e3e4

08002efc <ae_write_data_slot>:
//
// -- can also lock it.
//
    int
ae_write_data_slot(int slot_num, const uint8_t *data, int len, bool lock_it)
{
 8002efc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002f00:	461c      	mov	r4, r3
    ASSERT(len >= 32);
 8002f02:	f1a2 0320 	sub.w	r3, r2, #32
//
// -- can also lock it.
//
    int
ae_write_data_slot(int slot_num, const uint8_t *data, int len, bool lock_it)
{
 8002f06:	b085      	sub	sp, #20
    ASSERT(len >= 32);
 8002f08:	f5b3 7fc0 	cmp.w	r3, #384	; 0x180
//
// -- can also lock it.
//
    int
ae_write_data_slot(int slot_num, const uint8_t *data, int len, bool lock_it)
{
 8002f0c:	4605      	mov	r5, r0
 8002f0e:	af02      	add	r7, sp, #8
 8002f10:	460e      	mov	r6, r1
 8002f12:	4691      	mov	r9, r2
    ASSERT(len >= 32);
 8002f14:	d902      	bls.n	8002f1c <ae_write_data_slot+0x20>
 8002f16:	4830      	ldr	r0, [pc, #192]	; (8002fd8 <ae_write_data_slot+0xdc>)
 8002f18:	f7fd fd60 	bl	80009dc <fatal_error>
 8002f1c:	1e53      	subs	r3, r2, #1
    ASSERT(len <= 416);

    for(int blk=0, xlen=len; xlen>0; blk++, xlen-=32) {
        // have to write each "block" of 32-bytes, separately
        // zone => data
        ae_send_n(OP_Write, 0x80|2, (blk<<8) | (slot_num<<3), data+(blk*32), 32);
 8002f1e:	ea4f 0ac0 	mov.w	sl, r0, lsl #3
 8002f22:	095b      	lsrs	r3, r3, #5
 8002f24:	fa1f fa8a 	uxth.w	sl, sl
 8002f28:	f103 0b01 	add.w	fp, r3, #1
 8002f2c:	f04f 0800 	mov.w	r8, #0
 8002f30:	2320      	movs	r3, #32
 8002f32:	ea4a 2208 	orr.w	r2, sl, r8, lsl #8
 8002f36:	b292      	uxth	r2, r2
 8002f38:	9300      	str	r3, [sp, #0]
 8002f3a:	2182      	movs	r1, #130	; 0x82
 8002f3c:	eb06 1348 	add.w	r3, r6, r8, lsl #5
 8002f40:	2012      	movs	r0, #18
 8002f42:	f7ff fdc1 	bl	8002ac8 <ae_send_n>

        int rv = ae_read1();
 8002f46:	f7ff fd6d 	bl	8002a24 <ae_read1>
        RET_IF_BAD(rv);
 8002f4a:	2800      	cmp	r0, #0
 8002f4c:	d13f      	bne.n	8002fce <ae_write_data_slot+0xd2>
ae_write_data_slot(int slot_num, const uint8_t *data, int len, bool lock_it)
{
    ASSERT(len >= 32);
    ASSERT(len <= 416);

    for(int blk=0, xlen=len; xlen>0; blk++, xlen-=32) {
 8002f4e:	f108 0801 	add.w	r8, r8, #1
 8002f52:	45c3      	cmp	fp, r8
 8002f54:	d1ec      	bne.n	8002f30 <ae_write_data_slot+0x34>

        int rv = ae_read1();
        RET_IF_BAD(rv);
    }

    if(lock_it) {
 8002f56:	b3cc      	cbz	r4, 8002fcc <ae_write_data_slot+0xd0>
        ASSERT(slot_num != 8);          // no support for mega slot 8
 8002f58:	2d08      	cmp	r5, #8

        int rv = ae_read1();
        RET_IF_BAD(rv);
    }

    if(lock_it) {
 8002f5a:	466c      	mov	r4, sp
        ASSERT(slot_num != 8);          // no support for mega slot 8
 8002f5c:	d0db      	beq.n	8002f16 <ae_write_data_slot+0x1a>
        ASSERT(len == 32);              // probably not a limitation here
 8002f5e:	f1b9 0f20 	cmp.w	r9, #32
 8002f62:	d1d8      	bne.n	8002f16 <ae_write_data_slot+0x1a>

        // Assume 36/72-byte long slot, which will be partially written, and rest
        // should be ones.
        const int slot_len = (slot_num <= 7) ? 36 : 72;
 8002f64:	2d08      	cmp	r5, #8
 8002f66:	bfb4      	ite	lt
 8002f68:	f04f 0824 	movlt.w	r8, #36	; 0x24
 8002f6c:	f04f 0848 	movge.w	r8, #72	; 0x48
        uint8_t copy[slot_len];
 8002f70:	f108 0307 	add.w	r3, r8, #7
 8002f74:	f023 0307 	bic.w	r3, r3, #7
 8002f78:	ebad 0d03 	sub.w	sp, sp, r3
 8002f7c:	ab02      	add	r3, sp, #8

        memset(copy, 0xff, slot_len);
 8002f7e:	4642      	mov	r2, r8
 8002f80:	21ff      	movs	r1, #255	; 0xff
 8002f82:	4618      	mov	r0, r3
 8002f84:	f00a faa3 	bl	800d4ce <memset>
        memcpy(copy, data, len);
 8002f88:	f106 0120 	add.w	r1, r6, #32
        // Assume 36/72-byte long slot, which will be partially written, and rest
        // should be ones.
        const int slot_len = (slot_num <= 7) ? 36 : 72;
        uint8_t copy[slot_len];

        memset(copy, 0xff, slot_len);
 8002f8c:	4603      	mov	r3, r0
        memcpy(copy, data, len);
 8002f8e:	4602      	mov	r2, r0
 8002f90:	f856 0b04 	ldr.w	r0, [r6], #4
 8002f94:	f842 0b04 	str.w	r0, [r2], #4
 8002f98:	428e      	cmp	r6, r1
 8002f9a:	d1f9      	bne.n	8002f90 <ae_write_data_slot+0x94>

        // calc expected CRC
        uint8_t crc[2] = {0, 0};
 8002f9c:	2200      	movs	r2, #0
        crc16_chain(slot_len, copy, crc);
 8002f9e:	4619      	mov	r1, r3

        memset(copy, 0xff, slot_len);
        memcpy(copy, data, len);

        // calc expected CRC
        uint8_t crc[2] = {0, 0};
 8002fa0:	713a      	strb	r2, [r7, #4]
 8002fa2:	717a      	strb	r2, [r7, #5]
        crc16_chain(slot_len, copy, crc);
 8002fa4:	4640      	mov	r0, r8
 8002fa6:	1d3a      	adds	r2, r7, #4
 8002fa8:	f7ff fc28 	bl	80027fc <crc16_chain>

        // do the lock
        ae_send(OP_Lock, 2 | (slot_num << 2), (crc[1]<<8) | crc[0]);
 8002fac:	793b      	ldrb	r3, [r7, #4]
 8002fae:	797a      	ldrb	r2, [r7, #5]
 8002fb0:	00a9      	lsls	r1, r5, #2
 8002fb2:	f041 0102 	orr.w	r1, r1, #2
 8002fb6:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
 8002fba:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
 8002fbe:	2017      	movs	r0, #23
 8002fc0:	f7ff fdb7 	bl	8002b32 <ae_send>

        int rv = ae_read1();
 8002fc4:	f7ff fd2e 	bl	8002a24 <ae_read1>
 8002fc8:	46a5      	mov	sp, r4
 8002fca:	e000      	b.n	8002fce <ae_write_data_slot+0xd2>
        RET_IF_BAD(rv);
    }

    return 0;
 8002fcc:	4620      	mov	r0, r4
}
 8002fce:	370c      	adds	r7, #12
 8002fd0:	46bd      	mov	sp, r7
 8002fd2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002fd6:	bf00      	nop
 8002fd8:	0800d558 	.word	0x0800d558

08002fdc <ae_gendig_slot>:

// ae_gendig_slot()
//
    int
ae_gendig_slot(int slot_num, const uint8_t slot_contents[32], uint8_t digest[32])
{
 8002fdc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002fde:	b0ab      	sub	sp, #172	; 0xac
 8002fe0:	4605      	mov	r5, r0
 8002fe2:	460f      	mov	r7, r1
    // Construct a digest on the device (and here) that depends on the secret
    // contents of a specific slot.
    uint8_t num_in[20], tempkey[32];

	rng_buffer(num_in, sizeof(num_in));
 8002fe4:	a803      	add	r0, sp, #12
 8002fe6:	2114      	movs	r1, #20

// ae_gendig_slot()
//
    int
ae_gendig_slot(int slot_num, const uint8_t slot_contents[32], uint8_t digest[32])
{
 8002fe8:	4616      	mov	r6, r2
    // Construct a digest on the device (and here) that depends on the secret
    // contents of a specific slot.
    uint8_t num_in[20], tempkey[32];

	rng_buffer(num_in, sizeof(num_in));
 8002fea:	f7ff fb91 	bl	8002710 <rng_buffer>
	int rv = ae_pick_nonce(num_in, tempkey);
 8002fee:	a90f      	add	r1, sp, #60	; 0x3c
 8002ff0:	a803      	add	r0, sp, #12
 8002ff2:	f7ff fdd5 	bl	8002ba0 <ae_pick_nonce>
    RET_IF_BAD(rv);
 8002ff6:	2800      	cmp	r0, #0
 8002ff8:	d13e      	bne.n	8003078 <ae_gendig_slot+0x9c>

    //using Zone=2="Data" => "KeyID specifies a slot in the Data zone"
    ae_send(OP_GenDig, 0x2, slot_num);
 8002ffa:	b2aa      	uxth	r2, r5
 8002ffc:	2102      	movs	r1, #2
 8002ffe:	2015      	movs	r0, #21
 8003000:	f7ff fd97 	bl	8002b32 <ae_send>

    rv = ae_read1();
 8003004:	f7ff fd0e 	bl	8002a24 <ae_read1>
    RET_IF_BAD(rv);
 8003008:	4604      	mov	r4, r0
 800300a:	bba0      	cbnz	r0, 8003076 <ae_gendig_slot+0x9a>

    ae_keep_alive();
 800300c:	f7ff fd00 	bl	8002a10 <ae_keep_alive>
    //   msg = hkey + b'\x15\x02' + ustruct.pack("<H", slot_num)
    //   msg += b'\xee\x01\x23' + (b'\0'*25) + challenge
    //   assert len(msg) == 32+1+1+2+1+2+25+32
    //
	SHA256_CTX ctx;
    sha256_init(&ctx);
 8003010:	a817      	add	r0, sp, #92	; 0x5c
 8003012:	f002 f9a1 	bl	8005358 <sha256_init>

	uint8_t args[7] = { OP_GenDig, 2, slot_num, 0, 0xEE, 0x01, 0x23 };
 8003016:	2315      	movs	r3, #21
 8003018:	f88d 3004 	strb.w	r3, [sp, #4]
 800301c:	2302      	movs	r3, #2
 800301e:	f88d 3005 	strb.w	r3, [sp, #5]
 8003022:	23ee      	movs	r3, #238	; 0xee
 8003024:	f88d 3008 	strb.w	r3, [sp, #8]
 8003028:	2301      	movs	r3, #1
 800302a:	f88d 3009 	strb.w	r3, [sp, #9]
    uint8_t zeros[25] = { 0 };
 800302e:	2219      	movs	r2, #25
    //   assert len(msg) == 32+1+1+2+1+2+25+32
    //
	SHA256_CTX ctx;
    sha256_init(&ctx);

	uint8_t args[7] = { OP_GenDig, 2, slot_num, 0, 0xEE, 0x01, 0x23 };
 8003030:	2323      	movs	r3, #35	; 0x23
    uint8_t zeros[25] = { 0 };
 8003032:	4621      	mov	r1, r4
 8003034:	a808      	add	r0, sp, #32
    //   assert len(msg) == 32+1+1+2+1+2+25+32
    //
	SHA256_CTX ctx;
    sha256_init(&ctx);

	uint8_t args[7] = { OP_GenDig, 2, slot_num, 0, 0xEE, 0x01, 0x23 };
 8003036:	f88d 300a 	strb.w	r3, [sp, #10]
 800303a:	f88d 5006 	strb.w	r5, [sp, #6]
 800303e:	f88d 4007 	strb.w	r4, [sp, #7]
    uint8_t zeros[25] = { 0 };
 8003042:	f00a fa44 	bl	800d4ce <memset>

    sha256_update(&ctx, slot_contents, 32);
 8003046:	2220      	movs	r2, #32
 8003048:	4639      	mov	r1, r7
 800304a:	a817      	add	r0, sp, #92	; 0x5c
 800304c:	f002 f994 	bl	8005378 <sha256_update>
    sha256_update(&ctx, args, sizeof(args));
 8003050:	2207      	movs	r2, #7
 8003052:	a901      	add	r1, sp, #4
 8003054:	a817      	add	r0, sp, #92	; 0x5c
 8003056:	f002 f98f 	bl	8005378 <sha256_update>
    sha256_update(&ctx, zeros, sizeof(zeros));
 800305a:	2219      	movs	r2, #25
 800305c:	a908      	add	r1, sp, #32
 800305e:	a817      	add	r0, sp, #92	; 0x5c
 8003060:	f002 f98a 	bl	8005378 <sha256_update>
    sha256_update(&ctx, tempkey, 32);
 8003064:	a90f      	add	r1, sp, #60	; 0x3c
 8003066:	a817      	add	r0, sp, #92	; 0x5c
 8003068:	2220      	movs	r2, #32
 800306a:	f002 f985 	bl	8005378 <sha256_update>

    sha256_final(&ctx, digest);
 800306e:	4631      	mov	r1, r6
 8003070:	a817      	add	r0, sp, #92	; 0x5c
 8003072:	f002 f9c7 	bl	8005404 <sha256_final>
 8003076:	4620      	mov	r0, r4

    return 0;
}
 8003078:	b02b      	add	sp, #172	; 0xac
 800307a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800307c <ae_checkmac_hard>:
// meaning that we both know the shared secret and the state of stuff in
// the 508a is what we expect.
//
    int
ae_checkmac_hard(uint8_t keynum, const uint8_t secret[32])
{
 800307c:	b500      	push	{lr}
 800307e:	b089      	sub	sp, #36	; 0x24
    uint8_t     digest[32];

    int rv = ae_gendig_slot(keynum, secret, digest);
 8003080:	466a      	mov	r2, sp
 8003082:	f7ff ffab 	bl	8002fdc <ae_gendig_slot>
    RET_IF_BAD(rv);
 8003086:	b938      	cbnz	r0, 8003098 <ae_checkmac_hard+0x1c>

    // NOTE: we use this sometimes when we know the value is wrong, like
    // checking for blank pin codes... so not a huge error/security issue
    // if wrong here.
    if(!ae_is_correct_tempkey(digest)) return -2;
 8003088:	4668      	mov	r0, sp
 800308a:	f7ff fdbf 	bl	8002c0c <ae_is_correct_tempkey>
 800308e:	2800      	cmp	r0, #0

    // worked.
    return 0;
 8003090:	bf0c      	ite	eq
 8003092:	f06f 0001 	mvneq.w	r0, #1
 8003096:	2000      	movne	r0, #0
}
 8003098:	b009      	add	sp, #36	; 0x24
 800309a:	f85d fb04 	ldr.w	pc, [sp], #4

0800309e <ae_gendig_counter>:
// the digest should be, and ask the chip to do the same. Verify we match
// using MAC command (done elsewhere).
//
    int
ae_gendig_counter(int counter_num, const uint32_t expected_value, uint8_t digest[32])
{
 800309e:	b5f0      	push	{r4, r5, r6, r7, lr}
 80030a0:	b0ad      	sub	sp, #180	; 0xb4
 80030a2:	4606      	mov	r6, r0
 80030a4:	9101      	str	r1, [sp, #4]
    uint8_t num_in[20], tempkey[32];

	rng_buffer(num_in, sizeof(num_in));
 80030a6:	a804      	add	r0, sp, #16
 80030a8:	2114      	movs	r1, #20
// the digest should be, and ask the chip to do the same. Verify we match
// using MAC command (done elsewhere).
//
    int
ae_gendig_counter(int counter_num, const uint32_t expected_value, uint8_t digest[32])
{
 80030aa:	4617      	mov	r7, r2
    uint8_t num_in[20], tempkey[32];

	rng_buffer(num_in, sizeof(num_in));
 80030ac:	f7ff fb30 	bl	8002710 <rng_buffer>
	int rv = ae_pick_nonce(num_in, tempkey);
 80030b0:	a909      	add	r1, sp, #36	; 0x24
 80030b2:	a804      	add	r0, sp, #16
 80030b4:	f7ff fd74 	bl	8002ba0 <ae_pick_nonce>
    RET_IF_BAD(rv);
 80030b8:	2800      	cmp	r0, #0
 80030ba:	d148      	bne.n	800314e <ae_gendig_counter+0xb0>

    //using Zone=4="Counter" => "KeyID specifies the monotonic counter ID"
    ae_send(OP_GenDig, 0x4, counter_num);
 80030bc:	b2b2      	uxth	r2, r6
 80030be:	2104      	movs	r1, #4
 80030c0:	2015      	movs	r0, #21
 80030c2:	f7ff fd36 	bl	8002b32 <ae_send>

    rv = ae_read1();
 80030c6:	f7ff fcad 	bl	8002a24 <ae_read1>
    RET_IF_BAD(rv);
 80030ca:	4604      	mov	r4, r0
 80030cc:	2800      	cmp	r0, #0
 80030ce:	d13d      	bne.n	800314c <ae_gendig_counter+0xae>

    ae_keep_alive();
 80030d0:	f7ff fc9e 	bl	8002a10 <ae_keep_alive>
    //   msg = hkey + b'\x15\x02' + ustruct.pack("<H", slot_num)
    //   msg += b'\xee\x01\x23' + (b'\0'*25) + challenge
    //   assert len(msg) == 32+1+1+2+1+2+25+32
    //
	SHA256_CTX ctx;
    sha256_init(&ctx);
 80030d4:	a819      	add	r0, sp, #100	; 0x64
 80030d6:	f002 f93f 	bl	8005358 <sha256_init>

    uint8_t zeros[32] = { 0 };
 80030da:	2220      	movs	r2, #32
 80030dc:	4621      	mov	r1, r4
 80030de:	a811      	add	r0, sp, #68	; 0x44
 80030e0:	f00a f9f5 	bl	800d4ce <memset>
	uint8_t args[8] = { OP_GenDig, 0x4, counter_num, 0,  0xEE, 0x01, 0x23, 0x0 };
 80030e4:	2315      	movs	r3, #21
 80030e6:	f88d 3008 	strb.w	r3, [sp, #8]
 80030ea:	23ee      	movs	r3, #238	; 0xee
 80030ec:	f88d 300c 	strb.w	r3, [sp, #12]
 80030f0:	2301      	movs	r3, #1
 80030f2:	2504      	movs	r5, #4
 80030f4:	f88d 300d 	strb.w	r3, [sp, #13]

    sha256_update(&ctx, zeros, 32);
 80030f8:	2220      	movs	r2, #32
    //
	SHA256_CTX ctx;
    sha256_init(&ctx);

    uint8_t zeros[32] = { 0 };
	uint8_t args[8] = { OP_GenDig, 0x4, counter_num, 0,  0xEE, 0x01, 0x23, 0x0 };
 80030fa:	2323      	movs	r3, #35	; 0x23

    sha256_update(&ctx, zeros, 32);
 80030fc:	a911      	add	r1, sp, #68	; 0x44
 80030fe:	a819      	add	r0, sp, #100	; 0x64
    //
	SHA256_CTX ctx;
    sha256_init(&ctx);

    uint8_t zeros[32] = { 0 };
	uint8_t args[8] = { OP_GenDig, 0x4, counter_num, 0,  0xEE, 0x01, 0x23, 0x0 };
 8003100:	f88d 300e 	strb.w	r3, [sp, #14]
 8003104:	f88d 5009 	strb.w	r5, [sp, #9]
 8003108:	f88d 600a 	strb.w	r6, [sp, #10]
 800310c:	f88d 400b 	strb.w	r4, [sp, #11]
 8003110:	f88d 400f 	strb.w	r4, [sp, #15]

    sha256_update(&ctx, zeros, 32);
 8003114:	f002 f930 	bl	8005378 <sha256_update>
    sha256_update(&ctx, args, sizeof(args));
 8003118:	2208      	movs	r2, #8
 800311a:	eb0d 0102 	add.w	r1, sp, r2
 800311e:	a819      	add	r0, sp, #100	; 0x64
 8003120:	f002 f92a 	bl	8005378 <sha256_update>
    sha256_update(&ctx, (const uint8_t *)&expected_value, 4);
 8003124:	462a      	mov	r2, r5
 8003126:	eb0d 0105 	add.w	r1, sp, r5
 800312a:	a819      	add	r0, sp, #100	; 0x64
 800312c:	f002 f924 	bl	8005378 <sha256_update>
    sha256_update(&ctx, zeros, 20);
 8003130:	2214      	movs	r2, #20
 8003132:	a911      	add	r1, sp, #68	; 0x44
 8003134:	a819      	add	r0, sp, #100	; 0x64
 8003136:	f002 f91f 	bl	8005378 <sha256_update>
    sha256_update(&ctx, tempkey, 32);
 800313a:	a909      	add	r1, sp, #36	; 0x24
 800313c:	a819      	add	r0, sp, #100	; 0x64
 800313e:	2220      	movs	r2, #32
 8003140:	f002 f91a 	bl	8005378 <sha256_update>

    sha256_final(&ctx, digest);
 8003144:	4639      	mov	r1, r7
 8003146:	a819      	add	r0, sp, #100	; 0x64
 8003148:	f002 f95c 	bl	8005404 <sha256_final>
 800314c:	4620      	mov	r0, r4

    return 0;
}
 800314e:	b02d      	add	sp, #180	; 0xb4
 8003150:	bdf0      	pop	{r4, r5, r6, r7, pc}

08003152 <ae_get_counter>:
//
// Just read a one-way counter.
//
	int
ae_get_counter(uint32_t *result, uint8_t counter_number)
{
 8003152:	b530      	push	{r4, r5, lr}
    ae_send(OP_Counter, 0x0, counter_number);
 8003154:	460a      	mov	r2, r1
//
// Just read a one-way counter.
//
	int
ae_get_counter(uint32_t *result, uint8_t counter_number)
{
 8003156:	b089      	sub	sp, #36	; 0x24
 8003158:	4605      	mov	r5, r0
 800315a:	460c      	mov	r4, r1
    ae_send(OP_Counter, 0x0, counter_number);
 800315c:	2024      	movs	r0, #36	; 0x24
 800315e:	2100      	movs	r1, #0
 8003160:	f7ff fce7 	bl	8002b32 <ae_send>

    int rv = ae_read_n(4, (uint8_t *)result);
 8003164:	4629      	mov	r1, r5
 8003166:	2004      	movs	r0, #4
 8003168:	f7ff fc78 	bl	8002a5c <ae_read_n>
    RET_IF_BAD(rv);
 800316c:	b968      	cbnz	r0, 800318a <ae_get_counter+0x38>
    // IMPORTANT: Always verify the counter's value because otherwise
    // nothing prevents an active MitM changing the value that we think
    // we just read.

    uint8_t     digest[32];
    rv = ae_gendig_counter(counter_number, *result, digest);
 800316e:	4620      	mov	r0, r4
 8003170:	466a      	mov	r2, sp
 8003172:	6829      	ldr	r1, [r5, #0]
 8003174:	f7ff ff93 	bl	800309e <ae_gendig_counter>
	RET_IF_BAD(rv);
 8003178:	4604      	mov	r4, r0
 800317a:	b928      	cbnz	r0, 8003188 <ae_get_counter+0x36>

    if(!ae_is_correct_tempkey(digest)) {
 800317c:	4668      	mov	r0, sp
 800317e:	f7ff fd45 	bl	8002c0c <ae_is_correct_tempkey>
 8003182:	b908      	cbnz	r0, 8003188 <ae_get_counter+0x36>
        // no legit way for this to happen, so just die.
        fatal_mitm();
 8003184:	f7fd fc34 	bl	80009f0 <fatal_mitm>
    }

    return 0;
 8003188:	4620      	mov	r0, r4
}
 800318a:	b009      	add	sp, #36	; 0x24
 800318c:	bd30      	pop	{r4, r5, pc}

0800318e <ae_add_counter>:
// Add-to and return a one-way counter's value. Have to go up in
// single-unit steps, but can we loop.
//
	int
ae_add_counter(uint32_t *result, uint8_t counter_number, int incr)
{
 800318e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003192:	4606      	mov	r6, r0
 8003194:	b088      	sub	sp, #32
 8003196:	460d      	mov	r5, r1
 8003198:	4617      	mov	r7, r2
    for(int i=0; i<incr; i++) {
 800319a:	2400      	movs	r4, #0
        ae_send(OP_Counter, 0x1, counter_number);
 800319c:	fa1f f881 	uxth.w	r8, r1
// single-unit steps, but can we loop.
//
	int
ae_add_counter(uint32_t *result, uint8_t counter_number, int incr)
{
    for(int i=0; i<incr; i++) {
 80031a0:	42bc      	cmp	r4, r7
 80031a2:	da0b      	bge.n	80031bc <ae_add_counter+0x2e>
        ae_send(OP_Counter, 0x1, counter_number);
 80031a4:	2101      	movs	r1, #1
 80031a6:	2024      	movs	r0, #36	; 0x24
 80031a8:	4642      	mov	r2, r8
 80031aa:	f7ff fcc2 	bl	8002b32 <ae_send>
        int rv = ae_read_n(4, (uint8_t *)result);
 80031ae:	4631      	mov	r1, r6
 80031b0:	2004      	movs	r0, #4
 80031b2:	f7ff fc53 	bl	8002a5c <ae_read_n>
        RET_IF_BAD(rv);
 80031b6:	b978      	cbnz	r0, 80031d8 <ae_add_counter+0x4a>
// single-unit steps, but can we loop.
//
	int
ae_add_counter(uint32_t *result, uint8_t counter_number, int incr)
{
    for(int i=0; i<incr; i++) {
 80031b8:	3401      	adds	r4, #1
 80031ba:	e7f1      	b.n	80031a0 <ae_add_counter+0x12>
    // IMPORTANT: Always verify the counter's value because otherwise
    // nothing prevents an active MitM changing the value that we think
    // we just read. They could also stop us increamenting the counter.

    uint8_t     digest[32];
    int rv = ae_gendig_counter(counter_number, *result, digest);
 80031bc:	466a      	mov	r2, sp
 80031be:	6831      	ldr	r1, [r6, #0]
 80031c0:	4628      	mov	r0, r5
 80031c2:	f7ff ff6c 	bl	800309e <ae_gendig_counter>
	RET_IF_BAD(rv);
 80031c6:	4604      	mov	r4, r0
 80031c8:	b928      	cbnz	r0, 80031d6 <ae_add_counter+0x48>

    if(!ae_is_correct_tempkey(digest)) {
 80031ca:	4668      	mov	r0, sp
 80031cc:	f7ff fd1e 	bl	8002c0c <ae_is_correct_tempkey>
 80031d0:	b908      	cbnz	r0, 80031d6 <ae_add_counter+0x48>
        // no legit way for this to happen, so just die.
        fatal_mitm();
 80031d2:	f7fd fc0d 	bl	80009f0 <fatal_mitm>
    }

    return 0;
 80031d6:	4620      	mov	r0, r4
}
 80031d8:	b008      	add	sp, #32
 80031da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080031de <ae_encrypted_read32>:
// ae_encrypted_read32()
//
    int
ae_encrypted_read32(int data_slot, int blk,
                    int read_kn, const uint8_t read_key[32], uint8_t data[32])
{
 80031de:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80031e2:	b088      	sub	sp, #32
 80031e4:	4617      	mov	r7, r2
 80031e6:	4698      	mov	r8, r3
 80031e8:	460e      	mov	r6, r1
 80031ea:	4604      	mov	r4, r0
 80031ec:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    uint8_t     digest[32];

    ae_pair_unlock();
 80031ee:	f7ff fddb 	bl	8002da8 <ae_pair_unlock>

    int rv = ae_gendig_slot(read_kn, read_key, digest);
 80031f2:	466a      	mov	r2, sp
 80031f4:	4641      	mov	r1, r8
 80031f6:	4638      	mov	r0, r7
 80031f8:	f7ff fef0 	bl	8002fdc <ae_gendig_slot>
    RET_IF_BAD(rv);
 80031fc:	b9b0      	cbnz	r0, 800322c <ae_encrypted_read32+0x4e>

    // read nth 32-byte "block"
    ae_send(OP_Read, 0x82, (blk << 8) | (data_slot<<3));
 80031fe:	00e2      	lsls	r2, r4, #3
 8003200:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
 8003204:	2182      	movs	r1, #130	; 0x82
 8003206:	2002      	movs	r0, #2
 8003208:	b292      	uxth	r2, r2
 800320a:	f7ff fc92 	bl	8002b32 <ae_send>

    rv = ae_read_n(32, data);
 800320e:	4629      	mov	r1, r5
 8003210:	2020      	movs	r0, #32
 8003212:	f7ff fc23 	bl	8002a5c <ae_read_n>
    RET_IF_BAD(rv);
 8003216:	b948      	cbnz	r0, 800322c <ae_encrypted_read32+0x4e>
		*(acc) ^= *(more);
 8003218:	782a      	ldrb	r2, [r5, #0]
 800321a:	f81d 3000 	ldrb.w	r3, [sp, r0]
 800321e:	3001      	adds	r0, #1
 8003220:	4053      	eors	r3, r2
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 8003222:	2820      	cmp	r0, #32
		*(acc) ^= *(more);
 8003224:	f805 3b01 	strb.w	r3, [r5], #1
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 8003228:	d1f6      	bne.n	8003218 <ae_encrypted_read32+0x3a>

    xor_mixin(data, digest, 32);

    return 0;
 800322a:	2000      	movs	r0, #0
}
 800322c:	b008      	add	sp, #32
 800322e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08003234 <ae_encrypted_read>:

// ae_encrypted_read()
//
    int
ae_encrypted_read(int data_slot, int read_kn, const uint8_t read_key[32], uint8_t *data, int len)
{
 8003234:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003238:	b08a      	sub	sp, #40	; 0x28
 800323a:	4606      	mov	r6, r0
 800323c:	9c10      	ldr	r4, [sp, #64]	; 0x40
    // not clear if chip supports 4-byte encrypted reads 
    ASSERT((len == 32) || (len == 72));
 800323e:	2c20      	cmp	r4, #32

// ae_encrypted_read()
//
    int
ae_encrypted_read(int data_slot, int read_kn, const uint8_t read_key[32], uint8_t *data, int len)
{
 8003240:	460f      	mov	r7, r1
 8003242:	4690      	mov	r8, r2
 8003244:	461d      	mov	r5, r3
    // not clear if chip supports 4-byte encrypted reads 
    ASSERT((len == 32) || (len == 72));
 8003246:	d004      	beq.n	8003252 <ae_encrypted_read+0x1e>
 8003248:	2c48      	cmp	r4, #72	; 0x48
 800324a:	d002      	beq.n	8003252 <ae_encrypted_read+0x1e>
 800324c:	4814      	ldr	r0, [pc, #80]	; (80032a0 <ae_encrypted_read+0x6c>)
 800324e:	f7fd fbc5 	bl	80009dc <fatal_error>

    int rv = ae_encrypted_read32(data_slot, 0, read_kn, read_key, data);
 8003252:	9500      	str	r5, [sp, #0]
 8003254:	4643      	mov	r3, r8
 8003256:	463a      	mov	r2, r7
 8003258:	2100      	movs	r1, #0
 800325a:	4630      	mov	r0, r6
 800325c:	f7ff ffbf 	bl	80031de <ae_encrypted_read32>
    RET_IF_BAD(rv);
 8003260:	b9d0      	cbnz	r0, 8003298 <ae_encrypted_read+0x64>

    if(len == 32) return 0;
 8003262:	2c20      	cmp	r4, #32
 8003264:	d018      	beq.n	8003298 <ae_encrypted_read+0x64>

    rv = ae_encrypted_read32(data_slot, 1, read_kn, read_key, data+32);
 8003266:	f105 0320 	add.w	r3, r5, #32
 800326a:	9300      	str	r3, [sp, #0]
 800326c:	463a      	mov	r2, r7
 800326e:	4643      	mov	r3, r8
 8003270:	2101      	movs	r1, #1
 8003272:	4630      	mov	r0, r6
 8003274:	f7ff ffb3 	bl	80031de <ae_encrypted_read32>
    RET_IF_BAD(rv);
 8003278:	b970      	cbnz	r0, 8003298 <ae_encrypted_read+0x64>

    uint8_t tmp[32];
    rv = ae_encrypted_read32(data_slot, 2, read_kn, read_key, tmp);
 800327a:	ac02      	add	r4, sp, #8
 800327c:	4643      	mov	r3, r8
 800327e:	9400      	str	r4, [sp, #0]
 8003280:	463a      	mov	r2, r7
 8003282:	2102      	movs	r1, #2
 8003284:	4630      	mov	r0, r6
 8003286:	f7ff ffaa 	bl	80031de <ae_encrypted_read32>
    RET_IF_BAD(rv);
 800328a:	4603      	mov	r3, r0
 800328c:	b918      	cbnz	r0, 8003296 <ae_encrypted_read+0x62>

    memcpy(data+64, tmp, 72-64);
 800328e:	4622      	mov	r2, r4
 8003290:	ca03      	ldmia	r2!, {r0, r1}
 8003292:	6428      	str	r0, [r5, #64]	; 0x40
 8003294:	6469      	str	r1, [r5, #68]	; 0x44
 8003296:	4618      	mov	r0, r3

    return 0;
}
 8003298:	b00a      	add	sp, #40	; 0x28
 800329a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800329e:	bf00      	nop
 80032a0:	0800d558 	.word	0x0800d558

080032a4 <ae_encrypted_write32>:
// ae_encrypted_write()
//
    int
ae_encrypted_write32(int data_slot, int blk, int write_kn,
                        const uint8_t write_key[32], const uint8_t data[32])
{
 80032a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80032a8:	b0b7      	sub	sp, #220	; 0xdc
 80032aa:	4614      	mov	r4, r2
 80032ac:	461f      	mov	r7, r3
    uint8_t digest[32];

    ae_pair_unlock();

    // generate a hash over shared secret and rng
    int rv = ae_gendig_slot(write_kn, write_key, digest);
 80032ae:	f10d 0b2c 	add.w	fp, sp, #44	; 0x2c
// ae_encrypted_write()
//
    int
ae_encrypted_write32(int data_slot, int blk, int write_kn,
                        const uint8_t write_key[32], const uint8_t data[32])
{
 80032b2:	460e      	mov	r6, r1
 80032b4:	4605      	mov	r5, r0
 80032b6:	f8dd a100 	ldr.w	sl, [sp, #256]	; 0x100
    uint8_t digest[32];

    ae_pair_unlock();
 80032ba:	f7ff fd75 	bl	8002da8 <ae_pair_unlock>

    // generate a hash over shared secret and rng
    int rv = ae_gendig_slot(write_kn, write_key, digest);
 80032be:	465a      	mov	r2, fp
 80032c0:	4639      	mov	r1, r7
 80032c2:	4620      	mov	r0, r4
 80032c4:	f7ff fe8a 	bl	8002fdc <ae_gendig_slot>
    RET_IF_BAD(rv);
 80032c8:	2800      	cmp	r0, #0
 80032ca:	d14f      	bne.n	800336c <ae_encrypted_write32+0xc8>
 80032cc:	4604      	mov	r4, r0

    // encrypt the data to be written, and append an authenticating MAC
    uint8_t body[32 + 32];

    for(int i=0; i<32; i++) {
        body[i] = data[i] ^ digest[i];
 80032ce:	f81a 2004 	ldrb.w	r2, [sl, r4]
 80032d2:	f81b 3004 	ldrb.w	r3, [fp, r4]
 80032d6:	f10d 094c 	add.w	r9, sp, #76	; 0x4c
 80032da:	4053      	eors	r3, r2
 80032dc:	f804 3009 	strb.w	r3, [r4, r9]
    RET_IF_BAD(rv);

    // encrypt the data to be written, and append an authenticating MAC
    uint8_t body[32 + 32];

    for(int i=0; i<32; i++) {
 80032e0:	3401      	adds	r4, #1
 80032e2:	2c20      	cmp	r4, #32
 80032e4:	d1f3      	bne.n	80032ce <ae_encrypted_write32+0x2a>
	//	    + (b'\0'*25)
	//	    + new_value)
	//	assert len(msg) == 32+1+1+2+1+2+25+32
	//		
	SHA256_CTX ctx;
    sha256_init(&ctx);
 80032e6:	a823      	add	r0, sp, #140	; 0x8c
 80032e8:	f002 f836 	bl	8005358 <sha256_init>

    uint8_t p1 = 0x80|2;        // 32 bytes into a data slot
    uint8_t p2_lsb = (data_slot << 3); 
    uint8_t p2_msb = blk;

	uint8_t args[7] = { OP_Write, p1, p2_lsb, p2_msb, 0xEE, 0x01, 0x23 };
 80032ec:	23ee      	movs	r3, #238	; 0xee
 80032ee:	f88d 300c 	strb.w	r3, [sp, #12]
	//		
	SHA256_CTX ctx;
    sha256_init(&ctx);

    uint8_t p1 = 0x80|2;        // 32 bytes into a data slot
    uint8_t p2_lsb = (data_slot << 3); 
 80032f2:	00ed      	lsls	r5, r5, #3
    uint8_t p2_msb = blk;

	uint8_t args[7] = { OP_Write, p1, p2_lsb, p2_msb, 0xEE, 0x01, 0x23 };
 80032f4:	2301      	movs	r3, #1
	//		
	SHA256_CTX ctx;
    sha256_init(&ctx);

    uint8_t p1 = 0x80|2;        // 32 bytes into a data slot
    uint8_t p2_lsb = (data_slot << 3); 
 80032f6:	b2ed      	uxtb	r5, r5
    uint8_t p2_msb = blk;

	uint8_t args[7] = { OP_Write, p1, p2_lsb, p2_msb, 0xEE, 0x01, 0x23 };
 80032f8:	2712      	movs	r7, #18
 80032fa:	f04f 0882 	mov.w	r8, #130	; 0x82
 80032fe:	f88d 300d 	strb.w	r3, [sp, #13]
    uint8_t zeros[25] = { 0 };
 8003302:	2219      	movs	r2, #25

    uint8_t p1 = 0x80|2;        // 32 bytes into a data slot
    uint8_t p2_lsb = (data_slot << 3); 
    uint8_t p2_msb = blk;

	uint8_t args[7] = { OP_Write, p1, p2_lsb, p2_msb, 0xEE, 0x01, 0x23 };
 8003304:	2323      	movs	r3, #35	; 0x23
    uint8_t zeros[25] = { 0 };
 8003306:	2100      	movs	r1, #0
 8003308:	a804      	add	r0, sp, #16

    uint8_t p1 = 0x80|2;        // 32 bytes into a data slot
    uint8_t p2_lsb = (data_slot << 3); 
    uint8_t p2_msb = blk;

	uint8_t args[7] = { OP_Write, p1, p2_lsb, p2_msb, 0xEE, 0x01, 0x23 };
 800330a:	f88d 300e 	strb.w	r3, [sp, #14]
 800330e:	f88d 7008 	strb.w	r7, [sp, #8]
 8003312:	f88d 8009 	strb.w	r8, [sp, #9]
 8003316:	f88d 500a 	strb.w	r5, [sp, #10]
 800331a:	f88d 600b 	strb.w	r6, [sp, #11]
    uint8_t zeros[25] = { 0 };
 800331e:	f00a f8d6 	bl	800d4ce <memset>

    sha256_update(&ctx, digest, 32);
 8003322:	4622      	mov	r2, r4
 8003324:	4659      	mov	r1, fp
 8003326:	a823      	add	r0, sp, #140	; 0x8c
 8003328:	f002 f826 	bl	8005378 <sha256_update>
    sha256_update(&ctx, args, sizeof(args));
 800332c:	2207      	movs	r2, #7
 800332e:	a902      	add	r1, sp, #8
 8003330:	a823      	add	r0, sp, #140	; 0x8c
 8003332:	f002 f821 	bl	8005378 <sha256_update>
    sha256_update(&ctx, zeros, sizeof(zeros));
 8003336:	2219      	movs	r2, #25
 8003338:	a904      	add	r1, sp, #16
 800333a:	a823      	add	r0, sp, #140	; 0x8c
 800333c:	f002 f81c 	bl	8005378 <sha256_update>
    sha256_update(&ctx, data, 32);
 8003340:	4622      	mov	r2, r4
 8003342:	4651      	mov	r1, sl
 8003344:	a823      	add	r0, sp, #140	; 0x8c
 8003346:	f002 f817 	bl	8005378 <sha256_update>

    sha256_final(&ctx, &body[32]);
 800334a:	a91b      	add	r1, sp, #108	; 0x6c
 800334c:	a823      	add	r0, sp, #140	; 0x8c
 800334e:	f002 f859 	bl	8005404 <sha256_final>

    ae_send_n(OP_Write, p1, (p2_msb << 8) | p2_lsb, body, sizeof(body));
 8003352:	0232      	lsls	r2, r6, #8
 8003354:	2340      	movs	r3, #64	; 0x40
 8003356:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 800335a:	9300      	str	r3, [sp, #0]
 800335c:	432a      	orrs	r2, r5
 800335e:	464b      	mov	r3, r9
 8003360:	4641      	mov	r1, r8
 8003362:	4638      	mov	r0, r7
 8003364:	f7ff fbb0 	bl	8002ac8 <ae_send_n>

    return ae_read1();
 8003368:	f7ff fb5c 	bl	8002a24 <ae_read1>
}
 800336c:	b037      	add	sp, #220	; 0xdc
 800336e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08003374 <ae_encrypted_write>:
// ae_encrypted_write()
//
    int
ae_encrypted_write(int data_slot, int write_kn, const uint8_t write_key[32],
                        const uint8_t *data, int len)
{
 8003374:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003378:	b08a      	sub	sp, #40	; 0x28
    ASSERT(data_slot >= 0);
    ASSERT(data_slot <= 15);
 800337a:	280f      	cmp	r0, #15
// ae_encrypted_write()
//
    int
ae_encrypted_write(int data_slot, int write_kn, const uint8_t write_key[32],
                        const uint8_t *data, int len)
{
 800337c:	4607      	mov	r7, r0
 800337e:	4688      	mov	r8, r1
 8003380:	4691      	mov	r9, r2
 8003382:	469a      	mov	sl, r3
 8003384:	9d12      	ldr	r5, [sp, #72]	; 0x48
    ASSERT(data_slot >= 0);
    ASSERT(data_slot <= 15);
 8003386:	d902      	bls.n	800338e <ae_encrypted_write+0x1a>
//
    int
ae_encrypted_write(int data_slot, int write_kn, const uint8_t write_key[32],
                        const uint8_t *data, int len)
{
    ASSERT(data_slot >= 0);
 8003388:	4812      	ldr	r0, [pc, #72]	; (80033d4 <ae_encrypted_write+0x60>)
 800338a:	f7fd fb27 	bl	80009dc <fatal_error>
 800338e:	2400      	movs	r4, #0

    for(int blk=0; blk<3 && len>0; blk++, len-=32) {
        int here = MIN(32, len);

        // be nice and don't read past end of input buffer
        uint8_t     tmp[32] = { 0 };
 8003390:	ae02      	add	r6, sp, #8
                        const uint8_t *data, int len)
{
    ASSERT(data_slot >= 0);
    ASSERT(data_slot <= 15);

    for(int blk=0; blk<3 && len>0; blk++, len-=32) {
 8003392:	2d00      	cmp	r5, #0
 8003394:	dd1a      	ble.n	80033cc <ae_encrypted_write+0x58>
        int here = MIN(32, len);

        // be nice and don't read past end of input buffer
        uint8_t     tmp[32] = { 0 };
 8003396:	2220      	movs	r2, #32
 8003398:	2100      	movs	r1, #0
 800339a:	4630      	mov	r0, r6
 800339c:	f00a f897 	bl	800d4ce <memset>
        memcpy(tmp, data+(32*blk), here);
 80033a0:	2d20      	cmp	r5, #32
 80033a2:	462a      	mov	r2, r5
 80033a4:	eb0a 1144 	add.w	r1, sl, r4, lsl #5
 80033a8:	bfa8      	it	ge
 80033aa:	2220      	movge	r2, #32
 80033ac:	4630      	mov	r0, r6
 80033ae:	f00a f868 	bl	800d482 <memcpy>

        int rv = ae_encrypted_write32(data_slot, blk, write_kn, write_key, tmp);
 80033b2:	9600      	str	r6, [sp, #0]
 80033b4:	464b      	mov	r3, r9
 80033b6:	4642      	mov	r2, r8
 80033b8:	4621      	mov	r1, r4
 80033ba:	4638      	mov	r0, r7
 80033bc:	f7ff ff72 	bl	80032a4 <ae_encrypted_write32>
        RET_IF_BAD(rv);
 80033c0:	b928      	cbnz	r0, 80033ce <ae_encrypted_write+0x5a>
                        const uint8_t *data, int len)
{
    ASSERT(data_slot >= 0);
    ASSERT(data_slot <= 15);

    for(int blk=0; blk<3 && len>0; blk++, len-=32) {
 80033c2:	3401      	adds	r4, #1
 80033c4:	2c03      	cmp	r4, #3
 80033c6:	f1a5 0520 	sub.w	r5, r5, #32
 80033ca:	d1e2      	bne.n	8003392 <ae_encrypted_write+0x1e>

        int rv = ae_encrypted_write32(data_slot, blk, write_kn, write_key, tmp);
        RET_IF_BAD(rv);
    }

    return 0;
 80033cc:	2000      	movs	r0, #0
}
 80033ce:	b00a      	add	sp, #40	; 0x28
 80033d0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80033d4:	0800d558 	.word	0x0800d558

080033d8 <ae_read_data_slot>:

// ae_read_data_slot()
//
    int
ae_read_data_slot(int slot_num, uint8_t *data, int len)
{
 80033d8:	b570      	push	{r4, r5, r6, lr}
    ASSERT((len == 4) || (len == 32) || (len == 72));
 80033da:	2a04      	cmp	r2, #4

// ae_read_data_slot()
//
    int
ae_read_data_slot(int slot_num, uint8_t *data, int len)
{
 80033dc:	b088      	sub	sp, #32
 80033de:	460d      	mov	r5, r1
 80033e0:	4616      	mov	r6, r2
    ASSERT((len == 4) || (len == 32) || (len == 72));
 80033e2:	d002      	beq.n	80033ea <ae_read_data_slot+0x12>
 80033e4:	2a20      	cmp	r2, #32
 80033e6:	d034      	beq.n	8003452 <ae_read_data_slot+0x7a>
 80033e8:	e02e      	b.n	8003448 <ae_read_data_slot+0x70>

    // zone => data
    // only reading first block of 32 bytes. ignore the rest
    ae_send(OP_Read, (len == 4 ? 0x00 : 0x80) | 2, (slot_num<<3));
 80033ea:	2102      	movs	r1, #2
 80033ec:	00c0      	lsls	r0, r0, #3
 80033ee:	b284      	uxth	r4, r0
 80033f0:	4622      	mov	r2, r4
 80033f2:	2002      	movs	r0, #2
 80033f4:	f7ff fb9d 	bl	8002b32 <ae_send>

    int rv = ae_read_n((len == 4) ? 4 : 32, data);
 80033f8:	2e04      	cmp	r6, #4
 80033fa:	bf0c      	ite	eq
 80033fc:	2004      	moveq	r0, #4
 80033fe:	2020      	movne	r0, #32
 8003400:	4629      	mov	r1, r5
 8003402:	f7ff fb2b 	bl	8002a5c <ae_read_n>
    RET_IF_BAD(rv);
 8003406:	bb30      	cbnz	r0, 8003456 <ae_read_data_slot+0x7e>

    if(len == 72) {
 8003408:	2e48      	cmp	r6, #72	; 0x48
 800340a:	d124      	bne.n	8003456 <ae_read_data_slot+0x7e>
        // read second block
        ae_send(OP_Read, 0x82, (1<<8) | (slot_num<<3));
 800340c:	2182      	movs	r1, #130	; 0x82
 800340e:	2002      	movs	r0, #2
 8003410:	f444 7280 	orr.w	r2, r4, #256	; 0x100
 8003414:	f7ff fb8d 	bl	8002b32 <ae_send>

        int rv = ae_read_n(32, data+32);
 8003418:	f105 0120 	add.w	r1, r5, #32
 800341c:	2020      	movs	r0, #32
 800341e:	f7ff fb1d 	bl	8002a5c <ae_read_n>
        RET_IF_BAD(rv);
 8003422:	b9c0      	cbnz	r0, 8003456 <ae_read_data_slot+0x7e>

        // read third block, but only using part of it
        uint8_t     tmp[32];
        ae_send(OP_Read, 0x82, (2<<8) | (slot_num<<3));
 8003424:	f444 7200 	orr.w	r2, r4, #512	; 0x200
 8003428:	2182      	movs	r1, #130	; 0x82
 800342a:	2002      	movs	r0, #2
 800342c:	f7ff fb81 	bl	8002b32 <ae_send>

        rv = ae_read_n(32, tmp);
 8003430:	4669      	mov	r1, sp
 8003432:	2020      	movs	r0, #32
 8003434:	f7ff fb12 	bl	8002a5c <ae_read_n>
        RET_IF_BAD(rv);
 8003438:	4603      	mov	r3, r0
 800343a:	b918      	cbnz	r0, 8003444 <ae_read_data_slot+0x6c>

        memcpy(data+64, tmp, 72-64);
 800343c:	466a      	mov	r2, sp
 800343e:	ca03      	ldmia	r2!, {r0, r1}
 8003440:	6428      	str	r0, [r5, #64]	; 0x40
 8003442:	6469      	str	r1, [r5, #68]	; 0x44
 8003444:	4618      	mov	r0, r3
 8003446:	e006      	b.n	8003456 <ae_read_data_slot+0x7e>
// ae_read_data_slot()
//
    int
ae_read_data_slot(int slot_num, uint8_t *data, int len)
{
    ASSERT((len == 4) || (len == 32) || (len == 72));
 8003448:	2a48      	cmp	r2, #72	; 0x48
 800344a:	d002      	beq.n	8003452 <ae_read_data_slot+0x7a>
 800344c:	4803      	ldr	r0, [pc, #12]	; (800345c <ae_read_data_slot+0x84>)
 800344e:	f7fd fac5 	bl	80009dc <fatal_error>

    // zone => data
    // only reading first block of 32 bytes. ignore the rest
    ae_send(OP_Read, (len == 4 ? 0x00 : 0x80) | 2, (slot_num<<3));
 8003452:	2182      	movs	r1, #130	; 0x82
 8003454:	e7ca      	b.n	80033ec <ae_read_data_slot+0x14>

        memcpy(data+64, tmp, 72-64);
    }

    return 0;
}
 8003456:	b008      	add	sp, #32
 8003458:	bd70      	pop	{r4, r5, r6, pc}
 800345a:	bf00      	nop
 800345c:	0800d558 	.word	0x0800d558

08003460 <ae_set_gpio>:

// ae_set_gpio()
//
    int
ae_set_gpio(int state)
{
 8003460:	b513      	push	{r0, r1, r4, lr}
    // 1=turn on green, 0=red light (if not yet configured to be secure)
    ae_send(OP_Info, 3, 2 | (!!state));
 8003462:	2800      	cmp	r0, #0
 8003464:	bf14      	ite	ne
 8003466:	2203      	movne	r2, #3
 8003468:	2202      	moveq	r2, #2
 800346a:	2103      	movs	r1, #3
 800346c:	4604      	mov	r4, r0
 800346e:	2030      	movs	r0, #48	; 0x30
 8003470:	f7ff fb5f 	bl	8002b32 <ae_send>

    // "Always return the current state in the first byte followed by three bytes of 0x00"
    // - simple 1/0, in LSB.
    uint8_t resp[4];

    int rv = ae_read_n(4, resp);
 8003474:	a901      	add	r1, sp, #4
 8003476:	2004      	movs	r0, #4
 8003478:	f7ff faf0 	bl	8002a5c <ae_read_n>
	RET_IF_BAD(rv);
 800347c:	b928      	cbnz	r0, 800348a <ae_set_gpio+0x2a>

    return (resp[0] != state) ? -1 : 0;
 800347e:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8003482:	1b00      	subs	r0, r0, r4
 8003484:	bf18      	it	ne
 8003486:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
}
 800348a:	b002      	add	sp, #8
 800348c:	bd10      	pop	{r4, pc}

0800348e <ae_set_gpio_secure>:
//
// Set the GPIO using secure hash generated somehow already.
//
    int
ae_set_gpio_secure(uint8_t digest[32])
{
 800348e:	b538      	push	{r3, r4, r5, lr}
 8003490:	4605      	mov	r5, r0
    ae_pair_unlock();
 8003492:	f7ff fc89 	bl	8002da8 <ae_pair_unlock>
    ae_checkmac(KEYNUM_firmware, digest);
 8003496:	4629      	mov	r1, r5
 8003498:	200e      	movs	r0, #14
 800349a:	f7ff fc05 	bl	8002ca8 <ae_checkmac>

    int rv = ae_set_gpio(1);
 800349e:	2001      	movs	r0, #1
 80034a0:	f7ff ffde 	bl	8003460 <ae_set_gpio>

    if(rv == 0) {
 80034a4:	4604      	mov	r4, r0
 80034a6:	b940      	cbnz	r0, 80034ba <ae_set_gpio_secure+0x2c>
        // trust that readback, and so do a verify that the chip has 
        // the digest we think it does. If MitM wanted to turn off the output,
        // they can do that anytime regardless. We just don't want them to be
        // able to fake it being set, and therefore bypass the
        // "unsigned firmware" delay and warning.
        ae_pair_unlock();
 80034a8:	f7ff fc7e 	bl	8002da8 <ae_pair_unlock>

        if(ae_checkmac_hard(KEYNUM_firmware, digest) != 0) {
 80034ac:	4629      	mov	r1, r5
 80034ae:	200e      	movs	r0, #14
 80034b0:	f7ff fde4 	bl	800307c <ae_checkmac_hard>
 80034b4:	b108      	cbz	r0, 80034ba <ae_set_gpio_secure+0x2c>
            fatal_mitm();
 80034b6:	f7fd fa9b 	bl	80009f0 <fatal_mitm>
        }
    }

    return rv;
}
 80034ba:	4620      	mov	r0, r4
 80034bc:	bd38      	pop	{r3, r4, r5, pc}

080034be <ae_get_gpio>:
//
// IMPORTANT: do not trust this result, could be MitM'ed.
//
	uint8_t
ae_get_gpio(void)
{
 80034be:	b507      	push	{r0, r1, r2, lr}
	// not doing error checking here
	ae_send(OP_Info, 0x3, 0);
 80034c0:	2200      	movs	r2, #0
 80034c2:	2103      	movs	r1, #3
 80034c4:	2030      	movs	r0, #48	; 0x30
 80034c6:	f7ff fb34 	bl	8002b32 <ae_send>

	// note: always returns 4 bytes, but most are garbage and unused.
	uint8_t tmp[4];
	ae_read_n(4, tmp);
 80034ca:	a901      	add	r1, sp, #4
 80034cc:	2004      	movs	r0, #4
 80034ce:	f7ff fac5 	bl	8002a5c <ae_read_n>

	return tmp[0];
}
 80034d2:	f89d 0004 	ldrb.w	r0, [sp, #4]
 80034d6:	b003      	add	sp, #12
 80034d8:	f85d fb04 	ldr.w	pc, [sp], #4

080034dc <ae_read_config_word>:
//
// Read a 4-byte area from config area, or -1 if fail.
//
    int
ae_read_config_word(int offset, uint8_t *dest)
{
 80034dc:	b510      	push	{r4, lr}
    offset &= 0x7f;

    // read 32 bits (aligned)
    ae_send(OP_Read, 0x00, offset/4);
 80034de:	f3c0 0284 	ubfx	r2, r0, #2, #5
//
// Read a 4-byte area from config area, or -1 if fail.
//
    int
ae_read_config_word(int offset, uint8_t *dest)
{
 80034e2:	460c      	mov	r4, r1
    offset &= 0x7f;

    // read 32 bits (aligned)
    ae_send(OP_Read, 0x00, offset/4);
 80034e4:	2002      	movs	r0, #2
 80034e6:	2100      	movs	r1, #0
 80034e8:	f7ff fb23 	bl	8002b32 <ae_send>

	int rv = ae_read_n(4, dest);
 80034ec:	4621      	mov	r1, r4
 80034ee:	2004      	movs	r0, #4
 80034f0:	f7ff fab4 	bl	8002a5c <ae_read_n>
 80034f4:	3000      	adds	r0, #0
 80034f6:	bf18      	it	ne
 80034f8:	2001      	movne	r0, #1
    if(rv) return -1;

    return 0;
}
 80034fa:	4240      	negs	r0, r0
 80034fc:	bd10      	pop	{r4, pc}
	...

08003500 <ae_read_config_byte>:
//
// Read a byte from config area.
//
    int
ae_read_config_byte(int offset)
{
 8003500:	b513      	push	{r0, r1, r4, lr}
	uint8_t tmp[4];

    ae_read_config_word(offset, tmp);
 8003502:	a901      	add	r1, sp, #4
//
// Read a byte from config area.
//
    int
ae_read_config_byte(int offset)
{
 8003504:	4604      	mov	r4, r0
	uint8_t tmp[4];

    ae_read_config_word(offset, tmp);
 8003506:	f7ff ffe9 	bl	80034dc <ae_read_config_word>

	return tmp[offset % 4];
 800350a:	4b07      	ldr	r3, [pc, #28]	; (8003528 <ae_read_config_byte+0x28>)
 800350c:	4023      	ands	r3, r4
 800350e:	2b00      	cmp	r3, #0
 8003510:	bfbe      	ittt	lt
 8003512:	f103 33ff 	addlt.w	r3, r3, #4294967295	; 0xffffffff
 8003516:	f063 0303 	ornlt	r3, r3, #3
 800351a:	3301      	addlt	r3, #1
 800351c:	aa02      	add	r2, sp, #8
 800351e:	4413      	add	r3, r2
}
 8003520:	f813 0c04 	ldrb.w	r0, [r3, #-4]
 8003524:	b002      	add	sp, #8
 8003526:	bd10      	pop	{r4, pc}
 8003528:	80000003 	.word	0x80000003

0800352c <ae_destroy_key>:

// ae_destroy_key()
//
    int
ae_destroy_key(int keynum)
{
 800352c:	b510      	push	{r4, lr}
 800352e:	b090      	sub	sp, #64	; 0x40
	uint8_t numin[20];

	// Load tempkey with a known (random) nonce value
	rng_buffer(numin, sizeof(numin));
 8003530:	2114      	movs	r1, #20

// ae_destroy_key()
//
    int
ae_destroy_key(int keynum)
{
 8003532:	4604      	mov	r4, r0
	uint8_t numin[20];

	// Load tempkey with a known (random) nonce value
	rng_buffer(numin, sizeof(numin));
 8003534:	a803      	add	r0, sp, #12
 8003536:	f7ff f8eb 	bl	8002710 <rng_buffer>
    ae_send_n(OP_Nonce, 0, 0, numin, 20);
 800353a:	2314      	movs	r3, #20
 800353c:	2200      	movs	r2, #0
 800353e:	9300      	str	r3, [sp, #0]
 8003540:	4611      	mov	r1, r2
 8003542:	2016      	movs	r0, #22
 8003544:	ab03      	add	r3, sp, #12
 8003546:	f7ff fabf 	bl	8002ac8 <ae_send_n>

	// Nonce command returns the RNG result, not contents of TempKey,
    // but since we are destroying, no need to calculate what it is.
	uint8_t randout[32];
	int rv = ae_read_n(32, randout);
 800354a:	a908      	add	r1, sp, #32
 800354c:	2020      	movs	r0, #32
 800354e:	f7ff fa85 	bl	8002a5c <ae_read_n>
	RET_IF_BAD(rv);
 8003552:	b930      	cbnz	r0, 8003562 <ae_destroy_key+0x36>

    // do a "DeriveKey" operation, based on that!
	ae_send(OP_DeriveKey, 0x00, keynum);
 8003554:	4601      	mov	r1, r0
 8003556:	b2a2      	uxth	r2, r4
 8003558:	201c      	movs	r0, #28
 800355a:	f7ff faea 	bl	8002b32 <ae_send>

    return ae_read1();
 800355e:	f7ff fa61 	bl	8002a24 <ae_read1>
}
 8003562:	b010      	add	sp, #64	; 0x40
 8003564:	bd10      	pop	{r4, pc}

08003566 <ae_config_read>:

// ae_config_read()
//
    int 
ae_config_read(uint8_t config[128])
{
 8003566:	b538      	push	{r3, r4, r5, lr}
 8003568:	4605      	mov	r5, r0
    for(int blk=0; blk<4; blk++) {
 800356a:	2400      	movs	r4, #0
        // read 32 bytes (aligned) from config "zone"
        ae_send(OP_Read, 0x80, blk<<3);
 800356c:	00e2      	lsls	r2, r4, #3
 800356e:	2180      	movs	r1, #128	; 0x80
 8003570:	2002      	movs	r0, #2
 8003572:	b292      	uxth	r2, r2
 8003574:	f7ff fadd 	bl	8002b32 <ae_send>

        int rv = ae_read_n(32, &config[32*blk]);
 8003578:	eb05 1144 	add.w	r1, r5, r4, lsl #5
 800357c:	2020      	movs	r0, #32
 800357e:	f7ff fa6d 	bl	8002a5c <ae_read_n>
        if(rv) return EIO;
 8003582:	b918      	cbnz	r0, 800358c <ae_config_read+0x26>
// ae_config_read()
//
    int 
ae_config_read(uint8_t config[128])
{
    for(int blk=0; blk<4; blk++) {
 8003584:	3401      	adds	r4, #1
 8003586:	2c04      	cmp	r4, #4
 8003588:	d1f0      	bne.n	800356c <ae_config_read+0x6>
 800358a:	bd38      	pop	{r3, r4, r5, pc}
        // read 32 bytes (aligned) from config "zone"
        ae_send(OP_Read, 0x80, blk<<3);

        int rv = ae_read_n(32, &config[32*blk]);
        if(rv) return EIO;
 800358c:	2005      	movs	r0, #5
    }

    return 0;
}
 800358e:	bd38      	pop	{r3, r4, r5, pc}

08003590 <ae_setup_config>:
// us to write the (existing) pairing secret into, they would see the pairing
// secret in cleartext. They could then restore original chip and access freely.
//
    int
ae_setup_config(void)
{
 8003590:	b570      	push	{r4, r5, r6, lr}
 8003592:	2405      	movs	r4, #5
 8003594:	f5ad 7d40 	sub.w	sp, sp, #768	; 0x300
    // Need to wake up AE, since many things happen before this point.
    for(int retry=0; retry<5; retry++) {
        if(!ae_probe()) break;
 8003598:	f7ff fc8c 	bl	8002eb4 <ae_probe>
 800359c:	b108      	cbz	r0, 80035a2 <ae_setup_config+0x12>
//
    int
ae_setup_config(void)
{
    // Need to wake up AE, since many things happen before this point.
    for(int retry=0; retry<5; retry++) {
 800359e:	3c01      	subs	r4, #1
 80035a0:	d1fa      	bne.n	8003598 <ae_setup_config+0x8>
    // Is data zone is locked?
    // Allow rest of function to happen if it's not.

#if 1
    //  0x55 = unlocked; 0x00 = locked
    bool data_locked = (ae_read_config_byte(86) != 0x55);
 80035a2:	2056      	movs	r0, #86	; 0x56
 80035a4:	f7ff ffac 	bl	8003500 <ae_read_config_byte>
    if(data_locked) return 0;       // basically success
 80035a8:	2855      	cmp	r0, #85	; 0x55
 80035aa:	f040 80f6 	bne.w	800379a <ae_setup_config+0x20a>

    // To lock, we need a CRC over whole thing, but we
    // only set a few values... plus the serial number is
    // in there, so start with some readout.
    uint8_t config[128];
    int rv = ae_config_read(config);
 80035ae:	a838      	add	r0, sp, #224	; 0xe0
 80035b0:	f7ff ffd9 	bl	8003566 <ae_config_read>
    if(rv) return rv;
 80035b4:	2800      	cmp	r0, #0
 80035b6:	f040 80f3 	bne.w	80037a0 <ae_setup_config+0x210>
    uint8_t config[128];
    while(ae_config_read(config)) ;
#endif

    // verify some fixed values
    ASSERT(config[0] == 0x01);
 80035ba:	f89d 30e0 	ldrb.w	r3, [sp, #224]	; 0xe0
 80035be:	2b01      	cmp	r3, #1
 80035c0:	d001      	beq.n	80035c6 <ae_setup_config+0x36>
 80035c2:	4879      	ldr	r0, [pc, #484]	; (80037a8 <ae_setup_config+0x218>)
 80035c4:	e050      	b.n	8003668 <ae_setup_config+0xd8>
    ASSERT(config[1] == 0x23);
 80035c6:	f89d 30e1 	ldrb.w	r3, [sp, #225]	; 0xe1
 80035ca:	2b23      	cmp	r3, #35	; 0x23
 80035cc:	d1f9      	bne.n	80035c2 <ae_setup_config+0x32>
    ASSERT(config[12] == 0xee);
 80035ce:	f89d 30ec 	ldrb.w	r3, [sp, #236]	; 0xec
 80035d2:	2bee      	cmp	r3, #238	; 0xee
 80035d4:	d1f5      	bne.n	80035c2 <ae_setup_config+0x32>

    // guess part number: must be 608
    int8_t partno = ((config[6]>>4)&0xf);
    ASSERT(partno == 6);
 80035d6:	f89d 30e6 	ldrb.w	r3, [sp, #230]	; 0xe6
 80035da:	091b      	lsrs	r3, r3, #4
 80035dc:	2b06      	cmp	r3, #6
 80035de:	d1f0      	bne.n	80035c2 <ae_setup_config+0x32>

    uint8_t serial[9];
	memcpy(serial, &config[0], 4);
 80035e0:	9b38      	ldr	r3, [sp, #224]	; 0xe0
 80035e2:	9303      	str	r3, [sp, #12]
	memcpy(&serial[4], &config[8], 5);
 80035e4:	ab3a      	add	r3, sp, #232	; 0xe8
 80035e6:	e893 0003 	ldmia.w	r3, {r0, r1}
 80035ea:	9004      	str	r0, [sp, #16]
 80035ec:	f88d 1014 	strb.w	r1, [sp, #20]

    if(check_all_ones(rom_secrets->ae_serial_number, 9)) {
 80035f0:	486e      	ldr	r0, [pc, #440]	; (80037ac <ae_setup_config+0x21c>)
 80035f2:	2109      	movs	r1, #9
 80035f4:	f7ff f824 	bl	8002640 <check_all_ones>
 80035f8:	b110      	cbz	r0, 8003600 <ae_setup_config+0x70>
        // flash is empty; remember this serial number
        flash_save_ae_serial(serial);
 80035fa:	a803      	add	r0, sp, #12
 80035fc:	f7fe fdaa 	bl	8002154 <flash_save_ae_serial>
    }

    if(!check_equal(rom_secrets->ae_serial_number, serial, 9)) {
 8003600:	2209      	movs	r2, #9
 8003602:	a903      	add	r1, sp, #12
 8003604:	4869      	ldr	r0, [pc, #420]	; (80037ac <ae_setup_config+0x21c>)
 8003606:	f7ff f832 	bl	800266e <check_equal>
 800360a:	2800      	cmp	r0, #0
 800360c:	f000 80c7 	beq.w	800379e <ae_setup_config+0x20e>
    // - pick RNG value for words secret (and forget it)
    // - set all PIN values to known value (zeros)
    // - set all money secrets to knonw value (zeros)
    // - lock the data zone

    if(config[87] == 0x55) {
 8003610:	f89d 3137 	ldrb.w	r3, [sp, #311]	; 0x137
 8003614:	2b55      	cmp	r3, #85	; 0x55
 8003616:	d143      	bne.n	80036a0 <ae_setup_config+0x110>
        static const uint8_t    config_2[] = AE_CHIP_CONFIG_2;

        STATIC_ASSERT(sizeof(config_1) == 84-16);
        STATIC_ASSERT(sizeof(config_2) == 128-90);

        memcpy(&config[16], config_1, sizeof(config_1));
 8003618:	2244      	movs	r2, #68	; 0x44
 800361a:	4965      	ldr	r1, [pc, #404]	; (80037b0 <ae_setup_config+0x220>)
 800361c:	a83c      	add	r0, sp, #240	; 0xf0
 800361e:	f009 ff30 	bl	800d482 <memcpy>
        memcpy(&config[90], config_2, sizeof(config_2));
 8003622:	4b64      	ldr	r3, [pc, #400]	; (80037b4 <ae_setup_config+0x224>)
 8003624:	f50d 729d 	add.w	r2, sp, #314	; 0x13a
 8003628:	f103 0124 	add.w	r1, r3, #36	; 0x24
 800362c:	f853 0b04 	ldr.w	r0, [r3], #4
 8003630:	f842 0b04 	str.w	r0, [r2], #4
 8003634:	428b      	cmp	r3, r1
 8003636:	d1f9      	bne.n	800362c <ae_setup_config+0x9c>
 8003638:	881b      	ldrh	r3, [r3, #0]
 800363a:	8013      	strh	r3, [r2, #0]
//
    static int
ae_config_write(const uint8_t config[128])
{
    // send all 128 bytes, less some that can't be written.
    for(int n=16; n<128; n+= 4) {
 800363c:	2410      	movs	r4, #16
        if(n == 84) continue;       // that word not writable

        // Must work on words, since can't write to most of the complete blocks.
        //  args = write_params(block=n//32, offset=n//4, is_config=True)
        //  p2 = (block << 3) | offset
        ae_send_n(OP_Write, 0, n/4, &config[n], 4);
 800363e:	2504      	movs	r5, #4
    static int
ae_config_write(const uint8_t config[128])
{
    // send all 128 bytes, less some that can't be written.
    for(int n=16; n<128; n+= 4) {
        if(n == 84) continue;       // that word not writable
 8003640:	2c54      	cmp	r4, #84	; 0x54
 8003642:	d103      	bne.n	800364c <ae_setup_config+0xbc>
//
    static int
ae_config_write(const uint8_t config[128])
{
    // send all 128 bytes, less some that can't be written.
    for(int n=16; n<128; n+= 4) {
 8003644:	3404      	adds	r4, #4
 8003646:	2c80      	cmp	r4, #128	; 0x80
 8003648:	d1fa      	bne.n	8003640 <ae_setup_config+0xb0>
 800364a:	e00f      	b.n	800366c <ae_setup_config+0xdc>
        if(n == 84) continue;       // that word not writable

        // Must work on words, since can't write to most of the complete blocks.
        //  args = write_params(block=n//32, offset=n//4, is_config=True)
        //  p2 = (block << 3) | offset
        ae_send_n(OP_Write, 0, n/4, &config[n], 4);
 800364c:	ab38      	add	r3, sp, #224	; 0xe0
 800364e:	4423      	add	r3, r4
 8003650:	f3c4 028f 	ubfx	r2, r4, #2, #16
 8003654:	2100      	movs	r1, #0
 8003656:	2012      	movs	r0, #18
 8003658:	9500      	str	r5, [sp, #0]
 800365a:	f7ff fa35 	bl	8002ac8 <ae_send_n>
    
		int rv = ae_read1();
 800365e:	f7ff f9e1 	bl	8002a24 <ae_read1>
        if(rv) return rv;
 8003662:	2800      	cmp	r0, #0
 8003664:	d0ee      	beq.n	8003644 <ae_setup_config+0xb4>

        ae_keep_alive();

        // lock config zone
        if(ae_lock_config_zone(config)) {
            INCONSISTENT("conf lock");
 8003666:	4854      	ldr	r0, [pc, #336]	; (80037b8 <ae_setup_config+0x228>)
 8003668:	f7fd f9b8 	bl	80009dc <fatal_error>
        // write it.
        if(ae_config_write(config)) {
            INCONSISTENT("conf wr");
        }

        ae_keep_alive();
 800366c:	f7ff f9d0 	bl	8002a10 <ae_keep_alive>
//
    static int
ae_lock_config_zone(const uint8_t config[128])
{
    // calc expected CRC
    uint8_t crc[2] = {0, 0};
 8003670:	2500      	movs	r5, #0

    crc16_chain(128, config, crc);
 8003672:	aa58      	add	r2, sp, #352	; 0x160
 8003674:	a938      	add	r1, sp, #224	; 0xe0
 8003676:	4620      	mov	r0, r4
//
    static int
ae_lock_config_zone(const uint8_t config[128])
{
    // calc expected CRC
    uint8_t crc[2] = {0, 0};
 8003678:	f88d 5160 	strb.w	r5, [sp, #352]	; 0x160
 800367c:	f88d 5161 	strb.w	r5, [sp, #353]	; 0x161

    crc16_chain(128, config, crc);
 8003680:	f7ff f8bc 	bl	80027fc <crc16_chain>

    // do the lock: mode=0
    ae_send(OP_Lock, 0x0, (crc[1]<<8) | crc[0]);
 8003684:	f89d 3160 	ldrb.w	r3, [sp, #352]	; 0x160
 8003688:	f89d 2161 	ldrb.w	r2, [sp, #353]	; 0x161
 800368c:	4629      	mov	r1, r5
 800368e:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
 8003692:	2017      	movs	r0, #23
 8003694:	f7ff fa4d 	bl	8002b32 <ae_send>

    return ae_read1();
 8003698:	f7ff f9c4 	bl	8002a24 <ae_read1>
        }

        ae_keep_alive();

        // lock config zone
        if(ae_lock_config_zone(config)) {
 800369c:	2800      	cmp	r0, #0
 800369e:	d1e2      	bne.n	8003666 <ae_setup_config+0xd6>
    // Load data zone with some known values.
    // The datazone still unlocked, so no encryption needed (nor possible).
    
    // will use zeros for all PIN codes, and customer-defined-secret starting values
    uint8_t     zeros[72];
    memset(zeros, 0, sizeof(zeros));
 80036a0:	2248      	movs	r2, #72	; 0x48
 80036a2:	2100      	movs	r1, #0
 80036a4:	a826      	add	r0, sp, #152	; 0x98
 80036a6:	f009 ff12 	bl	800d4ce <memset>

    // slots can already locked, if we re-run any of this code... can't overwrite in
    // that case.
    uint16_t unlocked = config[88] | (((uint8_t)config[89])<<8);
 80036aa:	f89d 5139 	ldrb.w	r5, [sp, #313]	; 0x139
 80036ae:	f89d 3138 	ldrb.w	r3, [sp, #312]	; 0x138

    for(int kn=0; kn<16; kn++) {
 80036b2:	2400      	movs	r4, #0
    uint8_t     zeros[72];
    memset(zeros, 0, sizeof(zeros));

    // slots can already locked, if we re-run any of this code... can't overwrite in
    // that case.
    uint16_t unlocked = config[88] | (((uint8_t)config[89])<<8);
 80036b4:	ea43 2505 	orr.w	r5, r3, r5, lsl #8

    for(int kn=0; kn<16; kn++) {
        ae_keep_alive();
 80036b8:	f7ff f9aa 	bl	8002a10 <ae_keep_alive>

        if(!(unlocked & (1<<kn))) {
 80036bc:	fa45 f304 	asr.w	r3, r5, r4
 80036c0:	f013 0f01 	tst.w	r3, #1
 80036c4:	f104 0601 	add.w	r6, r4, #1
 80036c8:	d058      	beq.n	800377c <ae_setup_config+0x1ec>
            STATS(was_locked |= (1<<kn));
            continue;
        }

        switch(kn) {
 80036ca:	2c0e      	cmp	r4, #14
 80036cc:	d856      	bhi.n	800377c <ae_setup_config+0x1ec>
 80036ce:	e8df f004 	tbb	[pc, r4]
 80036d2:	084a      	.short	0x084a
 80036d4:	150d150d 	.word	0x150d150d
 80036d8:	1a1d3a29 	.word	0x1a1d3a29
 80036dc:	1a1a1a1a 	.word	0x1a1a1a1a
 80036e0:	15          	.byte	0x15
 80036e1:	00          	.byte	0x00
            default:
            case 15: break;

            case KEYNUM_pairing:
                if(ae_write_data_slot(kn, rom_secrets->pairing_secret, 32, false)) {
 80036e2:	2300      	movs	r3, #0
 80036e4:	2220      	movs	r2, #32
 80036e6:	4935      	ldr	r1, [pc, #212]	; (80037bc <ae_setup_config+0x22c>)
 80036e8:	2001      	movs	r0, #1
 80036ea:	e040      	b.n	800376e <ae_setup_config+0x1de>
                    // - each pin attempt (limited by counter0)
                    // - stretching pin/words attempts (iterated may times)
                    // See mathcheck.py for details.
                    uint8_t     tmp[32];

                    rng_buffer(tmp, sizeof(tmp));
 80036ec:	2120      	movs	r1, #32
 80036ee:	a806      	add	r0, sp, #24
 80036f0:	f7ff f80e 	bl	8002710 <rng_buffer>
                    //#warning "fixed secrets"
                    //memset(tmp, 0x41+kn, 32);

                    if(ae_write_data_slot(kn, tmp, 32, true)) {
 80036f4:	2301      	movs	r3, #1
 80036f6:	2220      	movs	r2, #32
 80036f8:	a906      	add	r1, sp, #24
 80036fa:	e002      	b.n	8003702 <ae_setup_config+0x172>
                break;

            case KEYNUM_main_pin:
            case KEYNUM_lastgood:
            case KEYNUM_firmware:
                if(ae_write_data_slot(kn, zeros, 32, false)) {
 80036fc:	2300      	movs	r3, #0
 80036fe:	2220      	movs	r2, #32
 8003700:	a926      	add	r1, sp, #152	; 0x98
 8003702:	4620      	mov	r0, r4
 8003704:	e01b      	b.n	800373e <ae_setup_config+0x1ae>
            case KEYNUM_secret:
            case KEYNUM_check_secret:
            case KEYNUM_spare_1:
            case KEYNUM_spare_2:
            case KEYNUM_spare_3:
                if(ae_write_data_slot(kn, zeros, 72, false)) {
 8003706:	2300      	movs	r3, #0
 8003708:	2248      	movs	r2, #72	; 0x48
 800370a:	e7f9      	b.n	8003700 <ae_setup_config+0x170>
                    INCONSISTENT("wr blk 72");
                }
                break;

            case KEYNUM_long_secret: {            // 416 bytes
                uint8_t long_zeros[416] = {0};
 800370c:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
 8003710:	2100      	movs	r1, #0
 8003712:	a858      	add	r0, sp, #352	; 0x160
 8003714:	f009 fedb 	bl	800d4ce <memset>
                if(ae_write_data_slot(kn, long_zeros, 416, false)) {
 8003718:	2300      	movs	r3, #0
 800371a:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
 800371e:	a958      	add	r1, sp, #352	; 0x160
 8003720:	2008      	movs	r0, #8
 8003722:	e00c      	b.n	800373e <ae_setup_config+0x1ae>
                }
                break;
            }

            case KEYNUM_match_count: {
                uint32_t     buf[32/4] = { 1024, 1024 };
 8003724:	2220      	movs	r2, #32
 8003726:	2100      	movs	r1, #0
 8003728:	a80e      	add	r0, sp, #56	; 0x38
 800372a:	f009 fed0 	bl	800d4ce <memset>
 800372e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003732:	930e      	str	r3, [sp, #56]	; 0x38
 8003734:	930f      	str	r3, [sp, #60]	; 0x3c
                if(ae_write_data_slot(KEYNUM_match_count, (const uint8_t *)buf,sizeof(buf),false)) {
 8003736:	2220      	movs	r2, #32
 8003738:	2300      	movs	r3, #0
 800373a:	a90e      	add	r1, sp, #56	; 0x38
 800373c:	2006      	movs	r0, #6
 800373e:	f7ff fbdd 	bl	8002efc <ae_write_data_slot>
 8003742:	b1d8      	cbz	r0, 800377c <ae_setup_config+0x1ec>
 8003744:	e78f      	b.n	8003666 <ae_setup_config+0xd6>

            case KEYNUM_joiner_key: {
                uint8_t     pubkey[64];

                // ? must prove we know the auth key (which is zeros, but still)
                if(ae_checkmac_hard(KEYNUM_main_pin, zeros) != 0) {
 8003746:	a926      	add	r1, sp, #152	; 0x98
 8003748:	2003      	movs	r0, #3
 800374a:	f7ff fc97 	bl	800307c <ae_checkmac_hard>
 800374e:	2800      	cmp	r0, #0
 8003750:	d189      	bne.n	8003666 <ae_setup_config+0xd6>
                    INCONSISTENT("ak");
                }

                // pick ECC keypair, lock it down, capture pubkey part
                if(ae_gen_ecc_key(KEYNUM_joiner_key, pubkey)) {
 8003752:	a916      	add	r1, sp, #88	; 0x58
 8003754:	2007      	movs	r0, #7
 8003756:	f7ff fb4c 	bl	8002df2 <ae_gen_ecc_key>
 800375a:	2800      	cmp	r0, #0
 800375c:	d183      	bne.n	8003666 <ae_setup_config+0xd6>
                    INCONSISTENT("kp");
                }

                // tell the SE2 part about that key, and apply it as the AUTH key C
                se2_save_auth_pubkey(pubkey);
 800375e:	a816      	add	r0, sp, #88	; 0x58
 8003760:	f004 f8d4 	bl	800790c <se2_save_auth_pubkey>
 8003764:	e00a      	b.n	800377c <ae_setup_config+0x1ec>
                break;
            }

            case 0:
                if(ae_write_data_slot(kn, (const uint8_t *)copyright_msg, 32, true)) {
 8003766:	4916      	ldr	r1, [pc, #88]	; (80037c0 <ae_setup_config+0x230>)
 8003768:	2301      	movs	r3, #1
 800376a:	2220      	movs	r2, #32
 800376c:	2000      	movs	r0, #0
 800376e:	f7ff fbc5 	bl	8002efc <ae_write_data_slot>
 8003772:	2800      	cmp	r0, #0
 8003774:	f47f af77 	bne.w	8003666 <ae_setup_config+0xd6>

    // slots can already locked, if we re-run any of this code... can't overwrite in
    // that case.
    uint16_t unlocked = config[88] | (((uint8_t)config[89])<<8);

    for(int kn=0; kn<16; kn++) {
 8003778:	4634      	mov	r4, r6
 800377a:	e79d      	b.n	80036b8 <ae_setup_config+0x128>
 800377c:	2e10      	cmp	r6, #16
 800377e:	4634      	mov	r4, r6
 8003780:	d19a      	bne.n	80036b8 <ae_setup_config+0x128>
                break;
        }
    }

    // lock the data zone and effectively enter normal operation.
    ae_keep_alive();
 8003782:	f7ff f945 	bl	8002a10 <ae_keep_alive>
ae_lock_data_zone(void)
{
    // NOTE: I haven't been able to calc CRC right, so not using it.

    // do the lock: mode=1 (datazone) + 0x80 (no CRC check)
    ae_send(OP_Lock, 0x81, 0x0000);
 8003786:	2200      	movs	r2, #0
 8003788:	2181      	movs	r1, #129	; 0x81
 800378a:	2017      	movs	r0, #23
 800378c:	f7ff f9d1 	bl	8002b32 <ae_send>

    return ae_read1();
 8003790:	f7ff f948 	bl	8002a24 <ae_read1>
        }
    }

    // lock the data zone and effectively enter normal operation.
    ae_keep_alive();
    if(ae_lock_data_zone()) {
 8003794:	2800      	cmp	r0, #0
 8003796:	f47f af66 	bne.w	8003666 <ae_setup_config+0xd6>
    // Allow rest of function to happen if it's not.

#if 1
    //  0x55 = unlocked; 0x00 = locked
    bool data_locked = (ae_read_config_byte(86) != 0x55);
    if(data_locked) return 0;       // basically success
 800379a:	2000      	movs	r0, #0
 800379c:	e000      	b.n	80037a0 <ae_setup_config+0x210>
    }

    if(!check_equal(rom_secrets->ae_serial_number, serial, 9)) {
        // write failed?
        // we're already linked to a different chip? Write failed?
        return EPERM;
 800379e:	2001      	movs	r0, #1
    if(ae_lock_data_zone()) {
        INCONSISTENT("data lock");
    }

    return 0;
}
 80037a0:	f50d 7d40 	add.w	sp, sp, #768	; 0x300
 80037a4:	bd70      	pop	{r4, r5, r6, pc}
 80037a6:	bf00      	nop
 80037a8:	0800d558 	.word	0x0800d558
 80037ac:	0801e040 	.word	0x0801e040
 80037b0:	0800e410 	.word	0x0800e410
 80037b4:	0800e3ea 	.word	0x0800e3ea
 80037b8:	0800d55f 	.word	0x0800d55f
 80037bc:	0801e000 	.word	0x0801e000
 80037c0:	0800e3bc 	.word	0x0800e3bc

080037c4 <ae_stretch_iter>:
// - but our time to do each iteration is limited by software SHA256 in ae_pair_unlock
//
    int
ae_stretch_iter(const uint8_t start[32], uint8_t end[32], int iterations)
{
    ASSERT(start != end);           // we can't work inplace
 80037c4:	4288      	cmp	r0, r1
// - cost of each iteration, approximately: 8ms
// - but our time to do each iteration is limited by software SHA256 in ae_pair_unlock
//
    int
ae_stretch_iter(const uint8_t start[32], uint8_t end[32], int iterations)
{
 80037c6:	b570      	push	{r4, r5, r6, lr}
 80037c8:	460c      	mov	r4, r1
 80037ca:	4616      	mov	r6, r2
    ASSERT(start != end);           // we can't work inplace
 80037cc:	d102      	bne.n	80037d4 <ae_stretch_iter+0x10>
 80037ce:	480f      	ldr	r0, [pc, #60]	; (800380c <ae_stretch_iter+0x48>)
 80037d0:	f7fd f904 	bl	80009dc <fatal_error>
    memcpy(end, start, 32);
 80037d4:	460b      	mov	r3, r1
 80037d6:	f100 0220 	add.w	r2, r0, #32
 80037da:	f850 1b04 	ldr.w	r1, [r0], #4
 80037de:	f843 1b04 	str.w	r1, [r3], #4
 80037e2:	4290      	cmp	r0, r2
 80037e4:	d1f9      	bne.n	80037da <ae_stretch_iter+0x16>

    for(int i=0; i<iterations; i++) {
 80037e6:	2500      	movs	r5, #0
 80037e8:	42b5      	cmp	r5, r6
 80037ea:	da0a      	bge.n	8003802 <ae_stretch_iter+0x3e>
        // must unlock again, because pin_stretch is an auth'd key
        if(ae_pair_unlock()) return -2;
 80037ec:	f7ff fadc 	bl	8002da8 <ae_pair_unlock>
 80037f0:	b948      	cbnz	r0, 8003806 <ae_stretch_iter+0x42>

        int rv = ae_hmac32(KEYNUM_pin_stretch, end, end);
 80037f2:	4622      	mov	r2, r4
 80037f4:	4621      	mov	r1, r4
 80037f6:	2002      	movs	r0, #2
 80037f8:	f7ff fb16 	bl	8002e28 <ae_hmac32>
        RET_IF_BAD(rv);
 80037fc:	b928      	cbnz	r0, 800380a <ae_stretch_iter+0x46>
ae_stretch_iter(const uint8_t start[32], uint8_t end[32], int iterations)
{
    ASSERT(start != end);           // we can't work inplace
    memcpy(end, start, 32);

    for(int i=0; i<iterations; i++) {
 80037fe:	3501      	adds	r5, #1
 8003800:	e7f2      	b.n	80037e8 <ae_stretch_iter+0x24>

        int rv = ae_hmac32(KEYNUM_pin_stretch, end, end);
        RET_IF_BAD(rv);
    }

    return 0;
 8003802:	2000      	movs	r0, #0
 8003804:	bd70      	pop	{r4, r5, r6, pc}
    ASSERT(start != end);           // we can't work inplace
    memcpy(end, start, 32);

    for(int i=0; i<iterations; i++) {
        // must unlock again, because pin_stretch is an auth'd key
        if(ae_pair_unlock()) return -2;
 8003806:	f06f 0001 	mvn.w	r0, #1
        int rv = ae_hmac32(KEYNUM_pin_stretch, end, end);
        RET_IF_BAD(rv);
    }

    return 0;
}
 800380a:	bd70      	pop	{r4, r5, r6, pc}
 800380c:	0800d558 	.word	0x0800d558

08003810 <ae_mixin_key>:
// Apply HMAC using secret in chip as a HMAC key, then encrypt
// the result a little because read in clear over bus.
//
    int
ae_mixin_key(uint8_t keynum, const uint8_t start[32], uint8_t end[32])
{
 8003810:	b570      	push	{r4, r5, r6, lr}
 8003812:	b096      	sub	sp, #88	; 0x58
    ASSERT(start != end);           // we can't work inplace
 8003814:	4291      	cmp	r1, r2
// Apply HMAC using secret in chip as a HMAC key, then encrypt
// the result a little because read in clear over bus.
//
    int
ae_mixin_key(uint8_t keynum, const uint8_t start[32], uint8_t end[32])
{
 8003816:	460e      	mov	r6, r1
 8003818:	4615      	mov	r5, r2
 800381a:	f88d 0007 	strb.w	r0, [sp, #7]
    ASSERT(start != end);           // we can't work inplace
 800381e:	d102      	bne.n	8003826 <ae_mixin_key+0x16>
 8003820:	4819      	ldr	r0, [pc, #100]	; (8003888 <ae_mixin_key+0x78>)
 8003822:	f7fd f8db 	bl	80009dc <fatal_error>

    if(ae_pair_unlock()) return -1;
 8003826:	f7ff fabf 	bl	8002da8 <ae_pair_unlock>
 800382a:	bb30      	cbnz	r0, 800387a <ae_mixin_key+0x6a>

    ASSERT(keynum != 0);
 800382c:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8003830:	2800      	cmp	r0, #0
 8003832:	d0f5      	beq.n	8003820 <ae_mixin_key+0x10>
    int rv = ae_hmac32(keynum, start, end);
 8003834:	462a      	mov	r2, r5
 8003836:	4631      	mov	r1, r6
 8003838:	f7ff faf6 	bl	8002e28 <ae_hmac32>
    RET_IF_BAD(rv);
 800383c:	4604      	mov	r4, r0
 800383e:	b9f8      	cbnz	r0, 8003880 <ae_mixin_key+0x70>
    // use the value provided in cleartext[sic--it's not] write back shortly (to test it).
    // Solution: one more SHA256, and to be safe, mixin lots of values!

	SHA256_CTX ctx;

    sha256_init(&ctx);
 8003840:	a803      	add	r0, sp, #12
 8003842:	f001 fd89 	bl	8005358 <sha256_init>
    sha256_update(&ctx, rom_secrets->pairing_secret, 32);
 8003846:	a803      	add	r0, sp, #12
 8003848:	2220      	movs	r2, #32
 800384a:	4910      	ldr	r1, [pc, #64]	; (800388c <ae_mixin_key+0x7c>)
 800384c:	f001 fd94 	bl	8005378 <sha256_update>
    sha256_update(&ctx, start, 32);
 8003850:	4631      	mov	r1, r6
 8003852:	a803      	add	r0, sp, #12
 8003854:	2220      	movs	r2, #32
 8003856:	f001 fd8f 	bl	8005378 <sha256_update>
    sha256_update(&ctx, &keynum, 1);
 800385a:	f10d 0107 	add.w	r1, sp, #7
 800385e:	a803      	add	r0, sp, #12
 8003860:	2201      	movs	r2, #1
 8003862:	f001 fd89 	bl	8005378 <sha256_update>
    sha256_update(&ctx, end, 32);
 8003866:	4629      	mov	r1, r5
 8003868:	a803      	add	r0, sp, #12
 800386a:	2220      	movs	r2, #32
 800386c:	f001 fd84 	bl	8005378 <sha256_update>
    sha256_final(&ctx, end);
 8003870:	4629      	mov	r1, r5
 8003872:	a803      	add	r0, sp, #12
 8003874:	f001 fdc6 	bl	8005404 <sha256_final>
 8003878:	e002      	b.n	8003880 <ae_mixin_key+0x70>
    int
ae_mixin_key(uint8_t keynum, const uint8_t start[32], uint8_t end[32])
{
    ASSERT(start != end);           // we can't work inplace

    if(ae_pair_unlock()) return -1;
 800387a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800387e:	e000      	b.n	8003882 <ae_mixin_key+0x72>
 8003880:	4620      	mov	r0, r4
    sha256_update(&ctx, &keynum, 1);
    sha256_update(&ctx, end, 32);
    sha256_final(&ctx, end);

    return 0;
}
 8003882:	b016      	add	sp, #88	; 0x58
 8003884:	bd70      	pop	{r4, r5, r6, pc}
 8003886:	bf00      	nop
 8003888:	0800d558 	.word	0x0800d558
 800388c:	0801e000 	.word	0x0801e000

08003890 <delay_ms>:
//
    void
delay_ms(int ms)
{
    // Clear the COUNTFLAG and reset value to zero
    SysTick->VAL = 0;
 8003890:	4b05      	ldr	r3, [pc, #20]	; (80038a8 <delay_ms+0x18>)
 8003892:	2200      	movs	r2, #0
 8003894:	609a      	str	r2, [r3, #8]
    //SysTick->CTRL;  

    // Wait for ticks to happen
    while(ms > 0) {
 8003896:	2800      	cmp	r0, #0
 8003898:	dd05      	ble.n	80038a6 <delay_ms+0x16>
        if(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) {
 800389a:	681a      	ldr	r2, [r3, #0]
 800389c:	03d2      	lsls	r2, r2, #15
            ms--;
 800389e:	bf48      	it	mi
 80038a0:	f100 30ff 	addmi.w	r0, r0, #4294967295	; 0xffffffff
 80038a4:	e7f7      	b.n	8003896 <delay_ms+0x6>
        }
    }
}
 80038a6:	4770      	bx	lr
 80038a8:	e000e010 	.word	0xe000e010

080038ac <HAL_Delay>:
// Replace HAL version which needs interrupts
//
    void
HAL_Delay(uint32_t Delay)
{
    delay_ms(Delay);
 80038ac:	f7ff bff0 	b.w	8003890 <delay_ms>

080038b0 <gpio_setup>:
    // NOTES:
    // - try not to limit PCB changes for future revs; leave unused unchanged.
    // - oled_setup() uses pins on PA4 thru PA8

    // enable clock to GPIO's ... we will be using them all at some point
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80038b0:	4b3b      	ldr	r3, [pc, #236]	; (80039a0 <gpio_setup+0xf0>)
//
// set directions, lock critical ones, etc.
//
    void
gpio_setup(void)
{
 80038b2:	b570      	push	{r4, r5, r6, lr}
    // NOTES:
    // - try not to limit PCB changes for future revs; leave unused unchanged.
    // - oled_setup() uses pins on PA4 thru PA8

    // enable clock to GPIO's ... we will be using them all at some point
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80038b4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    __HAL_RCC_GPIOC_CLK_ENABLE();
    __HAL_RCC_GPIOD_CLK_ENABLE();
    __HAL_RCC_GPIOE_CLK_ENABLE();

    {   // Onewire bus pins used for ATECC608 comms
        GPIO_InitTypeDef setup = {
 80038b6:	4c3b      	ldr	r4, [pc, #236]	; (80039a4 <gpio_setup+0xf4>)
    // NOTES:
    // - try not to limit PCB changes for future revs; leave unused unchanged.
    // - oled_setup() uses pins on PA4 thru PA8

    // enable clock to GPIO's ... we will be using them all at some point
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80038b8:	f042 0201 	orr.w	r2, r2, #1
 80038bc:	64da      	str	r2, [r3, #76]	; 0x4c
 80038be:	6cda      	ldr	r2, [r3, #76]	; 0x4c
//
// set directions, lock critical ones, etc.
//
    void
gpio_setup(void)
{
 80038c0:	b08a      	sub	sp, #40	; 0x28
    // NOTES:
    // - try not to limit PCB changes for future revs; leave unused unchanged.
    // - oled_setup() uses pins on PA4 thru PA8

    // enable clock to GPIO's ... we will be using them all at some point
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80038c2:	f002 0201 	and.w	r2, r2, #1
 80038c6:	9200      	str	r2, [sp, #0]
 80038c8:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80038ca:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80038cc:	f042 0202 	orr.w	r2, r2, #2
 80038d0:	64da      	str	r2, [r3, #76]	; 0x4c
 80038d2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80038d4:	f002 0202 	and.w	r2, r2, #2
 80038d8:	9201      	str	r2, [sp, #4]
 80038da:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80038dc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80038de:	f042 0204 	orr.w	r2, r2, #4
 80038e2:	64da      	str	r2, [r3, #76]	; 0x4c
 80038e4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80038e6:	f002 0204 	and.w	r2, r2, #4
 80038ea:	9202      	str	r2, [sp, #8]
 80038ec:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80038ee:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80038f0:	f042 0208 	orr.w	r2, r2, #8
 80038f4:	64da      	str	r2, [r3, #76]	; 0x4c
 80038f6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80038f8:	f002 0208 	and.w	r2, r2, #8
 80038fc:	9203      	str	r2, [sp, #12]
 80038fe:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8003900:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8003902:	f042 0210 	orr.w	r2, r2, #16
 8003906:	64da      	str	r2, [r3, #76]	; 0x4c
 8003908:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800390a:	f003 0310 	and.w	r3, r3, #16
 800390e:	9304      	str	r3, [sp, #16]
 8003910:	9b04      	ldr	r3, [sp, #16]

    {   // Onewire bus pins used for ATECC608 comms
        GPIO_InitTypeDef setup = {
 8003912:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8003914:	ad05      	add	r5, sp, #20
 8003916:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8003918:	6823      	ldr	r3, [r4, #0]
 800391a:	602b      	str	r3, [r5, #0]
            .Mode = GPIO_MODE_AF_OD,
            .Pull = GPIO_NOPULL,
            .Speed = GPIO_SPEED_FREQ_MEDIUM,
            .Alternate = GPIO_AF8_UART4,
        };
        HAL_GPIO_Init(ONEWIRE_PORT, &setup);
 800391c:	a905      	add	r1, sp, #20
 800391e:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8003922:	f7fd fb4d 	bl	8000fc0 <HAL_GPIO_Init>
    }

    // Bugfix: re-init of console port pins seems to wreck
    // the mpy uart code, so avoid after first time.
    if(USART1->BRR == 0) {
 8003926:	4b20      	ldr	r3, [pc, #128]	; (80039a8 <gpio_setup+0xf8>)
 8003928:	68de      	ldr	r6, [r3, #12]
 800392a:	b9ae      	cbnz	r6, 8003958 <gpio_setup+0xa8>
        // debug console: USART1 = PA9=Tx & PA10=Rx
        GPIO_InitTypeDef setup = {
 800392c:	3404      	adds	r4, #4
 800392e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8003930:	ad05      	add	r5, sp, #20
 8003932:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8003934:	6823      	ldr	r3, [r4, #0]
 8003936:	602b      	str	r3, [r5, #0]
            .Mode = GPIO_MODE_AF_PP,
            .Pull = GPIO_NOPULL,
            .Speed = GPIO_SPEED_FREQ_MEDIUM,
            .Alternate = GPIO_AF7_USART1,
        };
        HAL_GPIO_Init(GPIOA, &setup);
 8003938:	a905      	add	r1, sp, #20
 800393a:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800393e:	f7fd fb3f 	bl	8000fc0 <HAL_GPIO_Init>

        setup.Pin = GPIO_PIN_10;
 8003942:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003946:	9305      	str	r3, [sp, #20]
        setup.Mode = GPIO_MODE_INPUT;
        setup.Pull = GPIO_PULLUP;
        HAL_GPIO_Init(GPIOA, &setup);
 8003948:	a905      	add	r1, sp, #20
        };
        HAL_GPIO_Init(GPIOA, &setup);

        setup.Pin = GPIO_PIN_10;
        setup.Mode = GPIO_MODE_INPUT;
        setup.Pull = GPIO_PULLUP;
 800394a:	2301      	movs	r3, #1
        HAL_GPIO_Init(GPIOA, &setup);
 800394c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
            .Alternate = GPIO_AF7_USART1,
        };
        HAL_GPIO_Init(GPIOA, &setup);

        setup.Pin = GPIO_PIN_10;
        setup.Mode = GPIO_MODE_INPUT;
 8003950:	9606      	str	r6, [sp, #24]
        setup.Pull = GPIO_PULLUP;
 8003952:	9307      	str	r3, [sp, #28]
        HAL_GPIO_Init(GPIOA, &setup);
 8003954:	f7fd fb34 	bl	8000fc0 <HAL_GPIO_Init>
    }

    // SD active LED: PC7
    // USB active LED: PC6
    {   GPIO_InitTypeDef setup = {
 8003958:	2214      	movs	r2, #20
 800395a:	eb0d 0002 	add.w	r0, sp, r2
 800395e:	2100      	movs	r1, #0
 8003960:	f009 fdb5 	bl	800d4ce <memset>
 8003964:	25c0      	movs	r5, #192	; 0xc0
 8003966:	2401      	movs	r4, #1
            .Pin = GPIO_PIN_7 | GPIO_PIN_6,
            .Mode = GPIO_MODE_OUTPUT_PP,
            .Pull = GPIO_NOPULL,
            .Speed = GPIO_SPEED_FREQ_LOW,
        };
        HAL_GPIO_Init(GPIOC, &setup);
 8003968:	a905      	add	r1, sp, #20
 800396a:	4810      	ldr	r0, [pc, #64]	; (80039ac <gpio_setup+0xfc>)
        HAL_GPIO_Init(GPIOA, &setup);
    }

    // SD active LED: PC7
    // USB active LED: PC6
    {   GPIO_InitTypeDef setup = {
 800396c:	9505      	str	r5, [sp, #20]
 800396e:	9406      	str	r4, [sp, #24]
            .Pin = GPIO_PIN_7 | GPIO_PIN_6,
            .Mode = GPIO_MODE_OUTPUT_PP,
            .Pull = GPIO_NOPULL,
            .Speed = GPIO_SPEED_FREQ_LOW,
        };
        HAL_GPIO_Init(GPIOC, &setup);
 8003970:	f7fd fb26 	bl	8000fc0 <HAL_GPIO_Init>

        HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7|GPIO_PIN_6, 0);    // turn LEDs off
 8003974:	4629      	mov	r1, r5
 8003976:	2200      	movs	r2, #0
 8003978:	480c      	ldr	r0, [pc, #48]	; (80039ac <gpio_setup+0xfc>)
 800397a:	f7fd fc9d 	bl	80012b8 <HAL_GPIO_WritePin>
    }

    // SD card detect switch: PC13
    {   GPIO_InitTypeDef setup = {
 800397e:	2214      	movs	r2, #20
 8003980:	eb0d 0002 	add.w	r0, sp, r2
 8003984:	2100      	movs	r1, #0
 8003986:	f009 fda2 	bl	800d4ce <memset>
 800398a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
            .Pin = GPIO_PIN_13,
            .Mode = GPIO_MODE_INPUT,
            .Pull = GPIO_PULLUP,
            .Speed = GPIO_SPEED_FREQ_LOW,
        };
        HAL_GPIO_Init(GPIOC, &setup);
 800398e:	a905      	add	r1, sp, #20
 8003990:	4806      	ldr	r0, [pc, #24]	; (80039ac <gpio_setup+0xfc>)

        HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7|GPIO_PIN_6, 0);    // turn LEDs off
    }

    // SD card detect switch: PC13
    {   GPIO_InitTypeDef setup = {
 8003992:	9305      	str	r3, [sp, #20]
 8003994:	9407      	str	r4, [sp, #28]
            .Pin = GPIO_PIN_13,
            .Mode = GPIO_MODE_INPUT,
            .Pull = GPIO_PULLUP,
            .Speed = GPIO_SPEED_FREQ_LOW,
        };
        HAL_GPIO_Init(GPIOC, &setup);
 8003996:	f7fd fb13 	bl	8000fc0 <HAL_GPIO_Init>

    // elsewhere...
    //HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, 1);
    //HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, 0);
#endif
}
 800399a:	b00a      	add	sp, #40	; 0x28
 800399c:	bd70      	pop	{r4, r5, r6, pc}
 800399e:	bf00      	nop
 80039a0:	40021000 	.word	0x40021000
 80039a4:	0800e454 	.word	0x0800e454
 80039a8:	40013800 	.word	0x40013800
 80039ac:	48000800 	.word	0x48000800

080039b0 <_hmac_attempt>:
//
// Maybe should be proper HMAC from fips std? Can be changed later.
//
    static void
_hmac_attempt(const pinAttempt_t *args, uint8_t result[32])
{
 80039b0:	b530      	push	{r4, r5, lr}
 80039b2:	b095      	sub	sp, #84	; 0x54
 80039b4:	4604      	mov	r4, r0
	SHA256_CTX ctx;

    sha256_init(&ctx);
 80039b6:	a801      	add	r0, sp, #4
//
// Maybe should be proper HMAC from fips std? Can be changed later.
//
    static void
_hmac_attempt(const pinAttempt_t *args, uint8_t result[32])
{
 80039b8:	460d      	mov	r5, r1
	SHA256_CTX ctx;

    sha256_init(&ctx);
 80039ba:	f001 fccd 	bl	8005358 <sha256_init>
    sha256_update(&ctx, rom_secrets->pairing_secret, 32);
 80039be:	2220      	movs	r2, #32
 80039c0:	4911      	ldr	r1, [pc, #68]	; (8003a08 <_hmac_attempt+0x58>)
 80039c2:	a801      	add	r0, sp, #4
 80039c4:	f001 fcd8 	bl	8005378 <sha256_update>
    sha256_update(&ctx, reboot_seed_base, 32);
 80039c8:	2220      	movs	r2, #32
 80039ca:	4910      	ldr	r1, [pc, #64]	; (8003a0c <_hmac_attempt+0x5c>)
 80039cc:	a801      	add	r0, sp, #4
 80039ce:	f001 fcd3 	bl	8005378 <sha256_update>
    sha256_update(&ctx, (uint8_t *)args, offsetof(pinAttempt_t, hmac));
 80039d2:	2244      	movs	r2, #68	; 0x44
 80039d4:	4621      	mov	r1, r4
 80039d6:	a801      	add	r0, sp, #4
 80039d8:	f001 fcce 	bl	8005378 <sha256_update>

    if(args->magic_value == PA_MAGIC_V2) {
 80039dc:	6822      	ldr	r2, [r4, #0]
 80039de:	4b0c      	ldr	r3, [pc, #48]	; (8003a10 <_hmac_attempt+0x60>)
 80039e0:	429a      	cmp	r2, r3
 80039e2:	d105      	bne.n	80039f0 <_hmac_attempt+0x40>
        sha256_update(&ctx, (uint8_t *)args->cached_main_pin,
 80039e4:	2220      	movs	r2, #32
 80039e6:	f104 01f8 	add.w	r1, r4, #248	; 0xf8
 80039ea:	a801      	add	r0, sp, #4
 80039ec:	f001 fcc4 	bl	8005378 <sha256_update>
                                msizeof(pinAttempt_t, cached_main_pin));
    }

    sha256_final(&ctx, result);
 80039f0:	4629      	mov	r1, r5
 80039f2:	a801      	add	r0, sp, #4
 80039f4:	f001 fd06 	bl	8005404 <sha256_final>

    // and a second-sha256 on that, just in case.
    sha256_single(result, 32, result);
 80039f8:	462a      	mov	r2, r5
 80039fa:	2120      	movs	r1, #32
 80039fc:	4628      	mov	r0, r5
 80039fe:	f001 fd15 	bl	800542c <sha256_single>
}
 8003a02:	b015      	add	sp, #84	; 0x54
 8003a04:	bd30      	pop	{r4, r5, pc}
 8003a06:	bf00      	nop
 8003a08:	0801e000 	.word	0x0801e000
 8003a0c:	20001c00 	.word	0x20001c00
 8003a10:	2eaf6312 	.word	0x2eaf6312

08003a14 <_validate_attempt>:

// _validate_attempt()
//
    static int
_validate_attempt(const pinAttempt_t *args, bool first_time)
{
 8003a14:	b510      	push	{r4, lr}
 8003a16:	4604      	mov	r4, r0
 8003a18:	b088      	sub	sp, #32
    if(first_time) {
 8003a1a:	b961      	cbnz	r1, 8003a36 <_validate_attempt+0x22>
        // no hmac needed for setup call
    } else {
        // if hmac is defined, better be right.
        uint8_t     actual[32];

        _hmac_attempt(args, actual);
 8003a1c:	4669      	mov	r1, sp
 8003a1e:	f7ff ffc7 	bl	80039b0 <_hmac_attempt>

        if(!check_equal(actual, args->hmac, 32)) {
 8003a22:	2220      	movs	r2, #32
 8003a24:	f104 0144 	add.w	r1, r4, #68	; 0x44
 8003a28:	4668      	mov	r0, sp
 8003a2a:	f7fe fe20 	bl	800266e <check_equal>
 8003a2e:	b910      	cbnz	r0, 8003a36 <_validate_attempt+0x22>
            // hmac is wrong?
            return EPIN_HMAC_FAIL;
 8003a30:	f06f 0063 	mvn.w	r0, #99	; 0x63
 8003a34:	e021      	b.n	8003a7a <_validate_attempt+0x66>
        }
    }

    // check fields.
    if(args->magic_value == PA_MAGIC_V2) {
 8003a36:	6822      	ldr	r2, [r4, #0]
 8003a38:	4b11      	ldr	r3, [pc, #68]	; (8003a80 <_validate_attempt+0x6c>)
 8003a3a:	429a      	cmp	r2, r3
 8003a3c:	d118      	bne.n	8003a70 <_validate_attempt+0x5c>
    } else {
        return EPIN_BAD_MAGIC;
    }

    // check fields
    if(args->pin_len > MAX_PIN_LEN) return EPIN_RANGE_ERR;
 8003a3e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003a40:	2b20      	cmp	r3, #32
 8003a42:	dc18      	bgt.n	8003a76 <_validate_attempt+0x62>
    if(args->old_pin_len > MAX_PIN_LEN) return EPIN_RANGE_ERR;
 8003a44:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 8003a48:	2b20      	cmp	r3, #32
 8003a4a:	dc14      	bgt.n	8003a76 <_validate_attempt+0x62>
    if(args->new_pin_len > MAX_PIN_LEN) return EPIN_RANGE_ERR;
 8003a4c:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 8003a50:	2b20      	cmp	r3, #32
 8003a52:	dc10      	bgt.n	8003a76 <_validate_attempt+0x62>
    if((args->change_flags & CHANGE__MASK) != args->change_flags) return EPIN_RANGE_ERR;
 8003a54:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8003a56:	f640 737f 	movw	r3, #3967	; 0xf7f
 8003a5a:	4013      	ands	r3, r2
 8003a5c:	429a      	cmp	r2, r3
 8003a5e:	d10a      	bne.n	8003a76 <_validate_attempt+0x62>

    if((args->is_secondary & 0x1) != args->is_secondary) return EPIN_RANGE_ERR;
 8003a60:	6863      	ldr	r3, [r4, #4]
 8003a62:	f033 0301 	bics.w	r3, r3, #1
        
    return 0;
 8003a66:	bf14      	ite	ne
 8003a68:	f06f 0066 	mvnne.w	r0, #102	; 0x66
 8003a6c:	2000      	moveq	r0, #0
 8003a6e:	e004      	b.n	8003a7a <_validate_attempt+0x66>

    // check fields.
    if(args->magic_value == PA_MAGIC_V2) {
        // ok
    } else {
        return EPIN_BAD_MAGIC;
 8003a70:	f06f 0065 	mvn.w	r0, #101	; 0x65
 8003a74:	e001      	b.n	8003a7a <_validate_attempt+0x66>
    }

    // check fields
    if(args->pin_len > MAX_PIN_LEN) return EPIN_RANGE_ERR;
 8003a76:	f06f 0066 	mvn.w	r0, #102	; 0x66
    if((args->change_flags & CHANGE__MASK) != args->change_flags) return EPIN_RANGE_ERR;

    if((args->is_secondary & 0x1) != args->is_secondary) return EPIN_RANGE_ERR;
        
    return 0;
}
 8003a7a:	b008      	add	sp, #32
 8003a7c:	bd10      	pop	{r4, pc}
 8003a7e:	bf00      	nop
 8003a80:	2eaf6312 	.word	0x2eaf6312

08003a84 <warmup_ae>:

// warmup_ae()
//
    static int
warmup_ae(void)
{
 8003a84:	b510      	push	{r4, lr}
    ae_setup();
 8003a86:	f7fe ff8f 	bl	80029a8 <ae_setup>
 8003a8a:	2405      	movs	r4, #5

    for(int retry=0; retry<5; retry++) {
        if(!ae_probe()) break;
 8003a8c:	f7ff fa12 	bl	8002eb4 <ae_probe>
 8003a90:	b108      	cbz	r0, 8003a96 <warmup_ae+0x12>
    static int
warmup_ae(void)
{
    ae_setup();

    for(int retry=0; retry<5; retry++) {
 8003a92:	3c01      	subs	r4, #1
 8003a94:	d1fa      	bne.n	8003a8c <warmup_ae+0x8>
        if(!ae_probe()) break;
    }

    if(ae_pair_unlock()) return -1;
 8003a96:	f7ff f987 	bl	8002da8 <ae_pair_unlock>
 8003a9a:	4604      	mov	r4, r0
 8003a9c:	b910      	cbnz	r0, 8003aa4 <warmup_ae+0x20>

    // reset watchdog timer
    ae_keep_alive();
 8003a9e:	f7fe ffb7 	bl	8002a10 <ae_keep_alive>

    return 0;
 8003aa2:	e001      	b.n	8003aa8 <warmup_ae+0x24>

    for(int retry=0; retry<5; retry++) {
        if(!ae_probe()) break;
    }

    if(ae_pair_unlock()) return -1;
 8003aa4:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff

    // reset watchdog timer
    ae_keep_alive();

    return 0;
}
 8003aa8:	4620      	mov	r0, r4
 8003aaa:	bd10      	pop	{r4, pc}

08003aac <_read_slot_as_counter>:

// _read_slot_as_counter()
//
    static int
_read_slot_as_counter(uint8_t slot, uint32_t *dest)
{
 8003aac:	b530      	push	{r4, r5, lr}
 8003aae:	b091      	sub	sp, #68	; 0x44
    // Important that this be authenticated.
    //
    // - using first 32-bits only, others will be zero/ignored
    // - but need to read whole thing for the digest check

    uint32_t padded[32/4] = { 0 };
 8003ab0:	2220      	movs	r2, #32

// _read_slot_as_counter()
//
    static int
_read_slot_as_counter(uint8_t slot, uint32_t *dest)
{
 8003ab2:	4604      	mov	r4, r0
 8003ab4:	460d      	mov	r5, r1
    // Important that this be authenticated.
    //
    // - using first 32-bits only, others will be zero/ignored
    // - but need to read whole thing for the digest check

    uint32_t padded[32/4] = { 0 };
 8003ab6:	4668      	mov	r0, sp
 8003ab8:	2100      	movs	r1, #0
 8003aba:	f009 fd08 	bl	800d4ce <memset>
    ae_pair_unlock();
 8003abe:	f7ff f973 	bl	8002da8 <ae_pair_unlock>
    if(ae_read_data_slot(slot, (uint8_t *)padded, 32)) return -1;
 8003ac2:	2220      	movs	r2, #32
 8003ac4:	4669      	mov	r1, sp
 8003ac6:	4620      	mov	r0, r4
 8003ac8:	f7ff fc86 	bl	80033d8 <ae_read_data_slot>
 8003acc:	b110      	cbz	r0, 8003ad4 <_read_slot_as_counter+0x28>
 8003ace:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 8003ad2:	e011      	b.n	8003af8 <_read_slot_as_counter+0x4c>

    uint8_t tempkey[32];
    ae_pair_unlock();
 8003ad4:	f7ff f968 	bl	8002da8 <ae_pair_unlock>
    if(ae_gendig_slot(slot, (const uint8_t *)padded, tempkey)) return -1;
 8003ad8:	4620      	mov	r0, r4
 8003ada:	aa08      	add	r2, sp, #32
 8003adc:	4669      	mov	r1, sp
 8003ade:	f7ff fa7d 	bl	8002fdc <ae_gendig_slot>
 8003ae2:	4604      	mov	r4, r0
 8003ae4:	2800      	cmp	r0, #0
 8003ae6:	d1f2      	bne.n	8003ace <_read_slot_as_counter+0x22>

    if(!ae_is_correct_tempkey(tempkey)) fatal_mitm();
 8003ae8:	a808      	add	r0, sp, #32
 8003aea:	f7ff f88f 	bl	8002c0c <ae_is_correct_tempkey>
 8003aee:	b908      	cbnz	r0, 8003af4 <_read_slot_as_counter+0x48>
 8003af0:	f7fc ff7e 	bl	80009f0 <fatal_mitm>

    *dest = padded[0];
 8003af4:	9b00      	ldr	r3, [sp, #0]
 8003af6:	602b      	str	r3, [r5, #0]

    return 0;
}
 8003af8:	4620      	mov	r0, r4
 8003afa:	b011      	add	sp, #68	; 0x44
 8003afc:	bd30      	pop	{r4, r5, pc}

08003afe <get_last_success>:
// not really so strong with the 608, since it's all enforced on that side, but
// we'll do it anyway.
//
    static int __attribute__ ((noinline))
get_last_success(pinAttempt_t *args)
{
 8003afe:	b530      	push	{r4, r5, lr}
 8003b00:	b095      	sub	sp, #84	; 0x54
 8003b02:	4604      	mov	r4, r0
    const int slot = KEYNUM_lastgood;

    ae_pair_unlock();
 8003b04:	f7ff f950 	bl	8002da8 <ae_pair_unlock>

    // Read counter value of last-good login. Important that this be authenticated.
    // - using first 32-bits only, others will be zero
    uint32_t padded[32/4] = { 0 };
 8003b08:	2220      	movs	r2, #32
 8003b0a:	2100      	movs	r1, #0
 8003b0c:	a804      	add	r0, sp, #16
 8003b0e:	f009 fcde 	bl	800d4ce <memset>
    if(ae_read_data_slot(slot, (uint8_t *)padded, 32)) return -1;
 8003b12:	2220      	movs	r2, #32
 8003b14:	a904      	add	r1, sp, #16
 8003b16:	2005      	movs	r0, #5
 8003b18:	f7ff fc5e 	bl	80033d8 <ae_read_data_slot>
 8003b1c:	b110      	cbz	r0, 8003b24 <get_last_success+0x26>
 8003b1e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003b22:	e033      	b.n	8003b8c <get_last_success+0x8e>

    uint8_t tempkey[32];
    ae_pair_unlock();
 8003b24:	f7ff f940 	bl	8002da8 <ae_pair_unlock>
    if(ae_gendig_slot(slot, (const uint8_t *)padded, tempkey)) return -1;
 8003b28:	aa0c      	add	r2, sp, #48	; 0x30
 8003b2a:	a904      	add	r1, sp, #16
 8003b2c:	2005      	movs	r0, #5
 8003b2e:	f7ff fa55 	bl	8002fdc <ae_gendig_slot>
 8003b32:	4605      	mov	r5, r0
 8003b34:	2800      	cmp	r0, #0
 8003b36:	d1f2      	bne.n	8003b1e <get_last_success+0x20>

    if(!ae_is_correct_tempkey(tempkey)) fatal_mitm();
 8003b38:	a80c      	add	r0, sp, #48	; 0x30
 8003b3a:	f7ff f867 	bl	8002c0c <ae_is_correct_tempkey>
 8003b3e:	b908      	cbnz	r0, 8003b44 <get_last_success+0x46>
 8003b40:	f7fc ff56 	bl	80009f0 <fatal_mitm>

    // Read two values from data slots
    uint32_t lastgood=0, match_count=0, counter=0;
    if(_read_slot_as_counter(KEYNUM_lastgood, &lastgood)) return -1;
 8003b44:	a901      	add	r1, sp, #4
 8003b46:	2005      	movs	r0, #5
    if(ae_gendig_slot(slot, (const uint8_t *)padded, tempkey)) return -1;

    if(!ae_is_correct_tempkey(tempkey)) fatal_mitm();

    // Read two values from data slots
    uint32_t lastgood=0, match_count=0, counter=0;
 8003b48:	9501      	str	r5, [sp, #4]
 8003b4a:	9502      	str	r5, [sp, #8]
 8003b4c:	9503      	str	r5, [sp, #12]
    if(_read_slot_as_counter(KEYNUM_lastgood, &lastgood)) return -1;
 8003b4e:	f7ff ffad 	bl	8003aac <_read_slot_as_counter>
 8003b52:	2800      	cmp	r0, #0
 8003b54:	d1e3      	bne.n	8003b1e <get_last_success+0x20>
    if(_read_slot_as_counter(KEYNUM_match_count, &match_count)) return -1;
 8003b56:	a902      	add	r1, sp, #8
 8003b58:	2006      	movs	r0, #6
 8003b5a:	f7ff ffa7 	bl	8003aac <_read_slot_as_counter>
 8003b5e:	4601      	mov	r1, r0
 8003b60:	2800      	cmp	r0, #0
 8003b62:	d1dc      	bne.n	8003b1e <get_last_success+0x20>

    // Read the monotonically-increasing counter
    if(ae_get_counter(&counter, 0)) return -1;
 8003b64:	a803      	add	r0, sp, #12
 8003b66:	f7ff faf4 	bl	8003152 <ae_get_counter>
 8003b6a:	2800      	cmp	r0, #0
 8003b6c:	d1d7      	bne.n	8003b1e <get_last_success+0x20>

    if(lastgood > counter) {
 8003b6e:	9b01      	ldr	r3, [sp, #4]
 8003b70:	9a03      	ldr	r2, [sp, #12]
 8003b72:	4293      	cmp	r3, r2
        // monkey business, but impossible, right?!
        args->num_fails = 99;
 8003b74:	bf8c      	ite	hi
 8003b76:	2363      	movhi	r3, #99	; 0x63
    } else {
        args->num_fails = counter - lastgood;
 8003b78:	1ad3      	subls	r3, r2, r3
 8003b7a:	6363      	str	r3, [r4, #52]	; 0x34
    }

    // NOTE: 5LSB of match_count should be stored as zero.
    match_count &= ~31;
 8003b7c:	9b02      	ldr	r3, [sp, #8]
 8003b7e:	f023 031f 	bic.w	r3, r3, #31
    if(counter < match_count) {
 8003b82:	429a      	cmp	r2, r3
        // typical case: some number of attempts left before death
        args->attempts_left = match_count - counter;
 8003b84:	bf34      	ite	cc
 8003b86:	1a9b      	subcc	r3, r3, r2
    } else if(counter >= match_count) {
        // we're a brick now, but maybe say that nicer to customer
        args->attempts_left = 0;
 8003b88:	2300      	movcs	r3, #0
 8003b8a:	63a3      	str	r3, [r4, #56]	; 0x38
    }

    return 0;
}
 8003b8c:	b015      	add	sp, #84	; 0x54
 8003b8e:	bd30      	pop	{r4, r5, pc}

08003b90 <updates_for_good_login>:

// updates_for_good_login()
//
    static int
updates_for_good_login(uint8_t digest[32])
{
 8003b90:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003b92:	b08d      	sub	sp, #52	; 0x34
    // User got the main PIN right: update the attempt counters,
    // to document this (lastgood) and also bump the match counter if needed

    uint32_t count;
    int rv = ae_get_counter(&count, 0);
 8003b94:	2100      	movs	r1, #0

// updates_for_good_login()
//
    static int
updates_for_good_login(uint8_t digest[32])
{
 8003b96:	4606      	mov	r6, r0
    // User got the main PIN right: update the attempt counters,
    // to document this (lastgood) and also bump the match counter if needed

    uint32_t count;
    int rv = ae_get_counter(&count, 0);
 8003b98:	a802      	add	r0, sp, #8
 8003b9a:	f7ff fada 	bl	8003152 <ae_get_counter>
    if(rv) goto fail;
 8003b9e:	4601      	mov	r1, r0
 8003ba0:	2800      	cmp	r0, #0
 8003ba2:	d13c      	bne.n	8003c1e <updates_for_good_login+0x8e>

    // Challenge: Have to update both the counter, and the target match value because
    // no other way to have exact value.

    uint32_t mc = (count + MAX_TARGET_ATTEMPTS + 32) & ~31;
 8003ba4:	9b02      	ldr	r3, [sp, #8]
 8003ba6:	f103 042d 	add.w	r4, r3, #45	; 0x2d
 8003baa:	f024 041f 	bic.w	r4, r4, #31
    ASSERT(mc >= count);
 8003bae:	42a3      	cmp	r3, r4
 8003bb0:	d902      	bls.n	8003bb8 <updates_for_good_login+0x28>
 8003bb2:	481e      	ldr	r0, [pc, #120]	; (8003c2c <updates_for_good_login+0x9c>)
 8003bb4:	f7fc ff12 	bl	80009dc <fatal_error>

    int bump = (mc - MAX_TARGET_ATTEMPTS) - count;
 8003bb8:	f06f 050c 	mvn.w	r5, #12
 8003bbc:	1aed      	subs	r5, r5, r3
 8003bbe:	4425      	add	r5, r4
    ASSERT(bump >= 1);
 8003bc0:	1e6b      	subs	r3, r5, #1
 8003bc2:	2b1f      	cmp	r3, #31
 8003bc4:	d8f5      	bhi.n	8003bb2 <updates_for_good_login+0x22>
    // Would rather update the counter first, so that a hostile interruption can't increase
    // attempts (altho the attacker knows the pin at that point?!) .. but chip won't
    // let the counter go past the match value, so that has to be first.

    // set the new "match count"
    {   uint32_t    tmp[32/4] = {mc, mc} ;
 8003bc6:	2720      	movs	r7, #32
 8003bc8:	463a      	mov	r2, r7
 8003bca:	a804      	add	r0, sp, #16
 8003bcc:	f009 fc7f 	bl	800d4ce <memset>
        rv = ae_encrypted_write(KEYNUM_match_count, KEYNUM_main_pin, digest, (void *)tmp, 32);
 8003bd0:	2103      	movs	r1, #3
 8003bd2:	9700      	str	r7, [sp, #0]
 8003bd4:	ab04      	add	r3, sp, #16
 8003bd6:	4632      	mov	r2, r6
 8003bd8:	2006      	movs	r0, #6
    // Would rather update the counter first, so that a hostile interruption can't increase
    // attempts (altho the attacker knows the pin at that point?!) .. but chip won't
    // let the counter go past the match value, so that has to be first.

    // set the new "match count"
    {   uint32_t    tmp[32/4] = {mc, mc} ;
 8003bda:	9404      	str	r4, [sp, #16]
 8003bdc:	9405      	str	r4, [sp, #20]
        rv = ae_encrypted_write(KEYNUM_match_count, KEYNUM_main_pin, digest, (void *)tmp, 32);
 8003bde:	f7ff fbc9 	bl	8003374 <ae_encrypted_write>
        if(rv) goto fail;
 8003be2:	4601      	mov	r1, r0
 8003be4:	b9d8      	cbnz	r0, 8003c1e <updates_for_good_login+0x8e>
    }

    // incr the counter a bunch to get to that-13
    uint32_t new_count = 0;
 8003be6:	a80c      	add	r0, sp, #48	; 0x30
    rv = ae_add_counter(&new_count, 0, bump);
 8003be8:	462a      	mov	r2, r5
        rv = ae_encrypted_write(KEYNUM_match_count, KEYNUM_main_pin, digest, (void *)tmp, 32);
        if(rv) goto fail;
    }

    // incr the counter a bunch to get to that-13
    uint32_t new_count = 0;
 8003bea:	f840 1d24 	str.w	r1, [r0, #-36]!
    rv = ae_add_counter(&new_count, 0, bump);
 8003bee:	f7ff face 	bl	800318e <ae_add_counter>
    if(rv) goto fail;
 8003bf2:	4601      	mov	r1, r0
 8003bf4:	b998      	cbnz	r0, 8003c1e <updates_for_good_login+0x8e>

    ASSERT(new_count == count + bump);
 8003bf6:	9b02      	ldr	r3, [sp, #8]
 8003bf8:	441d      	add	r5, r3
 8003bfa:	9b03      	ldr	r3, [sp, #12]
 8003bfc:	429d      	cmp	r5, r3
 8003bfe:	d1d8      	bne.n	8003bb2 <updates_for_good_login+0x22>
    ASSERT(mc > new_count);
 8003c00:	42ac      	cmp	r4, r5
 8003c02:	d9d6      	bls.n	8003bb2 <updates_for_good_login+0x22>

    // Update the "last good" counter
    {   uint32_t    tmp[32/4] = {new_count, 0 };
 8003c04:	463a      	mov	r2, r7
 8003c06:	a804      	add	r0, sp, #16
 8003c08:	f009 fc61 	bl	800d4ce <memset>
        rv = ae_encrypted_write(KEYNUM_lastgood, KEYNUM_main_pin, digest, (void *)tmp, 32);
 8003c0c:	9700      	str	r7, [sp, #0]
 8003c0e:	ab04      	add	r3, sp, #16
 8003c10:	4632      	mov	r2, r6
 8003c12:	2103      	movs	r1, #3
 8003c14:	2005      	movs	r0, #5

    ASSERT(new_count == count + bump);
    ASSERT(mc > new_count);

    // Update the "last good" counter
    {   uint32_t    tmp[32/4] = {new_count, 0 };
 8003c16:	9504      	str	r5, [sp, #16]
        rv = ae_encrypted_write(KEYNUM_lastgood, KEYNUM_main_pin, digest, (void *)tmp, 32);
 8003c18:	f7ff fbac 	bl	8003374 <ae_encrypted_write>
        if(rv) goto fail;
 8003c1c:	b118      	cbz	r0, 8003c26 <updates_for_good_login+0x96>
    // just be reducing attempts.

    return 0;

fail:
    ae_reset_chip();
 8003c1e:	f7fe feb5 	bl	800298c <ae_reset_chip>
    return EPIN_AE_FAIL;
 8003c22:	f06f 0069 	mvn.w	r0, #105	; 0x69
}
 8003c26:	b00d      	add	sp, #52	; 0x34
 8003c28:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003c2a:	bf00      	nop
 8003c2c:	0800d558 	.word	0x0800d558

08003c30 <pin_hash>:
//
// Hash up a string of digits into 32-bytes of goodness.
//
    static void
pin_hash(const char *pin, int pin_len, uint8_t result[32], uint32_t purpose)
{
 8003c30:	b570      	push	{r4, r5, r6, lr}
 8003c32:	b096      	sub	sp, #88	; 0x58
    ASSERT(pin_len <= MAX_PIN_LEN);
 8003c34:	2920      	cmp	r1, #32
//
// Hash up a string of digits into 32-bytes of goodness.
//
    static void
pin_hash(const char *pin, int pin_len, uint8_t result[32], uint32_t purpose)
{
 8003c36:	4606      	mov	r6, r0
 8003c38:	460d      	mov	r5, r1
 8003c3a:	4614      	mov	r4, r2
 8003c3c:	9301      	str	r3, [sp, #4]
    ASSERT(pin_len <= MAX_PIN_LEN);
 8003c3e:	dd02      	ble.n	8003c46 <pin_hash+0x16>
 8003c40:	4815      	ldr	r0, [pc, #84]	; (8003c98 <pin_hash+0x68>)
 8003c42:	f7fc fecb 	bl	80009dc <fatal_error>

    if(pin_len == 0) {
 8003c46:	b921      	cbnz	r1, 8003c52 <pin_hash+0x22>
        // zero-length PIN is considered the "blank" one: all zero
        memset(result, 0, 32);
 8003c48:	2220      	movs	r2, #32
 8003c4a:	4620      	mov	r0, r4
 8003c4c:	f009 fc3f 	bl	800d4ce <memset>
 8003c50:	e020      	b.n	8003c94 <pin_hash+0x64>

        return;
    }

	SHA256_CTX ctx;
    sha256_init(&ctx);
 8003c52:	a803      	add	r0, sp, #12
 8003c54:	f001 fb80 	bl	8005358 <sha256_init>

    sha256_update(&ctx, rom_secrets->pairing_secret, 32);
 8003c58:	2220      	movs	r2, #32
 8003c5a:	4910      	ldr	r1, [pc, #64]	; (8003c9c <pin_hash+0x6c>)
 8003c5c:	a803      	add	r0, sp, #12
 8003c5e:	f001 fb8b 	bl	8005378 <sha256_update>
    sha256_update(&ctx, (uint8_t *)&purpose, 4);
 8003c62:	2204      	movs	r2, #4
 8003c64:	eb0d 0102 	add.w	r1, sp, r2
 8003c68:	a803      	add	r0, sp, #12
 8003c6a:	f001 fb85 	bl	8005378 <sha256_update>
    sha256_update(&ctx, (uint8_t *)pin, pin_len);
 8003c6e:	462a      	mov	r2, r5
 8003c70:	4631      	mov	r1, r6
 8003c72:	a803      	add	r0, sp, #12
 8003c74:	f001 fb80 	bl	8005378 <sha256_update>
    sha256_update(&ctx, rom_secrets->pairing_secret, 32);
 8003c78:	2220      	movs	r2, #32
 8003c7a:	4908      	ldr	r1, [pc, #32]	; (8003c9c <pin_hash+0x6c>)
 8003c7c:	a803      	add	r0, sp, #12
 8003c7e:	f001 fb7b 	bl	8005378 <sha256_update>

    sha256_final(&ctx, result);
 8003c82:	4621      	mov	r1, r4
 8003c84:	a803      	add	r0, sp, #12
 8003c86:	f001 fbbd 	bl	8005404 <sha256_final>

    // and a second-sha256 on that, just in case.
    sha256_single(result, 32, result);
 8003c8a:	4622      	mov	r2, r4
 8003c8c:	2120      	movs	r1, #32
 8003c8e:	4620      	mov	r0, r4
 8003c90:	f001 fbcc 	bl	800542c <sha256_single>
}
 8003c94:	b016      	add	sp, #88	; 0x58
 8003c96:	bd70      	pop	{r4, r5, r6, pc}
 8003c98:	0800d558 	.word	0x0800d558
 8003c9c:	0801e000 	.word	0x0801e000

08003ca0 <pin_hash_attempt>:
//
// - call with target_kn == 0 to return a mid-state that can be used for both main and duress
//
    static int
pin_hash_attempt(const char *pin, int pin_len, uint8_t result[32])
{
 8003ca0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003ca2:	4617      	mov	r7, r2
 8003ca4:	b089      	sub	sp, #36	; 0x24
    uint8_t tmp[32]; 

    if(pin_len == 0) {
 8003ca6:	460c      	mov	r4, r1
 8003ca8:	b929      	cbnz	r1, 8003cb6 <pin_hash_attempt+0x16>
        // zero len PIN is the "blank" value: all zeros, no hashing
        memset(result, 0, 32);
 8003caa:	2220      	movs	r2, #32
 8003cac:	4638      	mov	r0, r7
 8003cae:	f009 fc0e 	bl	800d4ce <memset>
 8003cb2:	4620      	mov	r0, r4
 8003cb4:	e01b      	b.n	8003cee <pin_hash_attempt+0x4e>

        return 0;
    }

    // quick local hashing
    pin_hash(pin, pin_len, tmp, PIN_PURPOSE_NORMAL);
 8003cb6:	4b0f      	ldr	r3, [pc, #60]	; (8003cf4 <pin_hash_attempt+0x54>)
 8003cb8:	466a      	mov	r2, sp
 8003cba:	f7ff ffb9 	bl	8003c30 <pin_hash>

    // do mega hashing
    int rv = ae_stretch_iter(tmp, result, KDF_ITER_PIN);
 8003cbe:	2208      	movs	r2, #8
 8003cc0:	4639      	mov	r1, r7
 8003cc2:	4668      	mov	r0, sp
 8003cc4:	f7ff fd7e 	bl	80037c4 <ae_stretch_iter>
    if(rv) return EPIN_AE_FAIL;
 8003cc8:	4606      	mov	r6, r0
 8003cca:	b970      	cbnz	r0, 8003cea <pin_hash_attempt+0x4a>

    // CAUTION: at this point, we just read the value off the bus
    // in clear text. Don't use that value directly.
    memcpy(tmp, result, 32);
 8003ccc:	463d      	mov	r5, r7
 8003cce:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8003cd0:	466c      	mov	r4, sp
 8003cd2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8003cd4:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8003cd8:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    ae_mixin_key(KEYNUM_pin_attempt, tmp, result);
 8003cdc:	463a      	mov	r2, r7
 8003cde:	4669      	mov	r1, sp
 8003ce0:	2004      	movs	r0, #4
 8003ce2:	f7ff fd95 	bl	8003810 <ae_mixin_key>

    return 0;
 8003ce6:	4630      	mov	r0, r6
 8003ce8:	e001      	b.n	8003cee <pin_hash_attempt+0x4e>
    // quick local hashing
    pin_hash(pin, pin_len, tmp, PIN_PURPOSE_NORMAL);

    // do mega hashing
    int rv = ae_stretch_iter(tmp, result, KDF_ITER_PIN);
    if(rv) return EPIN_AE_FAIL;
 8003cea:	f06f 0069 	mvn.w	r0, #105	; 0x69
    // in clear text. Don't use that value directly.
    memcpy(tmp, result, 32);
    ae_mixin_key(KEYNUM_pin_attempt, tmp, result);

    return 0;
}
 8003cee:	b009      	add	sp, #36	; 0x24
 8003cf0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003cf2:	bf00      	nop
 8003cf4:	334d1858 	.word	0x334d1858

08003cf8 <pin_cache_get_key>:

// pin_cache_get_key()
//
    void
pin_cache_get_key(uint8_t key[32])
{
 8003cf8:	b510      	push	{r4, lr}
 8003cfa:	b094      	sub	sp, #80	; 0x50
 8003cfc:	4604      	mov	r4, r0
    // per-boot unique key.
	SHA256_CTX ctx;

    sha256_init(&ctx);
 8003cfe:	a801      	add	r0, sp, #4
 8003d00:	f001 fb2a 	bl	8005358 <sha256_init>
    sha256_update(&ctx, reboot_seed_base, 32);
 8003d04:	a801      	add	r0, sp, #4
 8003d06:	2220      	movs	r2, #32
 8003d08:	4906      	ldr	r1, [pc, #24]	; (8003d24 <pin_cache_get_key+0x2c>)
 8003d0a:	f001 fb35 	bl	8005378 <sha256_update>
    sha256_update(&ctx, rom_secrets->hash_cache_secret, 32);
 8003d0e:	2220      	movs	r2, #32
 8003d10:	a801      	add	r0, sp, #4
 8003d12:	4905      	ldr	r1, [pc, #20]	; (8003d28 <pin_cache_get_key+0x30>)
 8003d14:	f001 fb30 	bl	8005378 <sha256_update>

    sha256_final(&ctx, key);
 8003d18:	4621      	mov	r1, r4
 8003d1a:	a801      	add	r0, sp, #4
 8003d1c:	f001 fb72 	bl	8005404 <sha256_final>
}
 8003d20:	b014      	add	sp, #80	; 0x50
 8003d22:	bd10      	pop	{r4, pc}
 8003d24:	20001c00 	.word	0x20001c00
 8003d28:	0801e070 	.word	0x0801e070

08003d2c <pin_cache_save>:

// pin_cache_save()
//
    static void
pin_cache_save(pinAttempt_t *args, const uint8_t digest[32])
{
 8003d2c:	b530      	push	{r4, r5, lr}
 8003d2e:	460d      	mov	r5, r1
 8003d30:	b089      	sub	sp, #36	; 0x24
 8003d32:	4604      	mov	r4, r0
    // encrypt w/ rom secret + SRAM seed value
    uint8_t     value[32];

    if(!check_all_zeros(digest, 32)) {
 8003d34:	2120      	movs	r1, #32
 8003d36:	4628      	mov	r0, r5
 8003d38:	f7fe fc8a 	bl	8002650 <check_all_zeros>
 8003d3c:	b978      	cbnz	r0, 8003d5e <pin_cache_save+0x32>
        pin_cache_get_key(value);
 8003d3e:	4668      	mov	r0, sp
 8003d40:	f7ff ffda 	bl	8003cf8 <pin_cache_get_key>
 8003d44:	1e6b      	subs	r3, r5, #1
 8003d46:	f10d 32ff 	add.w	r2, sp, #4294967295	; 0xffffffff
 8003d4a:	351f      	adds	r5, #31
		*(acc) ^= *(more);
 8003d4c:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 8003d50:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 8003d54:	4041      	eors	r1, r0
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 8003d56:	42ab      	cmp	r3, r5
		*(acc) ^= *(more);
 8003d58:	7011      	strb	r1, [r2, #0]
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 8003d5a:	d1f7      	bne.n	8003d4c <pin_cache_save+0x20>
 8003d5c:	e004      	b.n	8003d68 <pin_cache_save+0x3c>
        xor_mixin(value, digest, 32);
    } else {
        memset(value, 0, 32);
 8003d5e:	2220      	movs	r2, #32
 8003d60:	2100      	movs	r1, #0
 8003d62:	4668      	mov	r0, sp
 8003d64:	f009 fbb3 	bl	800d4ce <memset>
    }

    ASSERT(args->magic_value == PA_MAGIC_V2);
 8003d68:	6822      	ldr	r2, [r4, #0]
 8003d6a:	4b0a      	ldr	r3, [pc, #40]	; (8003d94 <pin_cache_save+0x68>)
 8003d6c:	429a      	cmp	r2, r3
 8003d6e:	d002      	beq.n	8003d76 <pin_cache_save+0x4a>
 8003d70:	4809      	ldr	r0, [pc, #36]	; (8003d98 <pin_cache_save+0x6c>)
 8003d72:	f7fc fe33 	bl	80009dc <fatal_error>
    memcpy(args->cached_main_pin, value, 32);
 8003d76:	466a      	mov	r2, sp
 8003d78:	f104 03f8 	add.w	r3, r4, #248	; 0xf8
 8003d7c:	ad08      	add	r5, sp, #32
 8003d7e:	4614      	mov	r4, r2
 8003d80:	cc03      	ldmia	r4!, {r0, r1}
 8003d82:	42ac      	cmp	r4, r5
 8003d84:	6018      	str	r0, [r3, #0]
 8003d86:	6059      	str	r1, [r3, #4]
 8003d88:	4622      	mov	r2, r4
 8003d8a:	f103 0308 	add.w	r3, r3, #8
 8003d8e:	d1f6      	bne.n	8003d7e <pin_cache_save+0x52>
}
 8003d90:	b009      	add	sp, #36	; 0x24
 8003d92:	bd30      	pop	{r4, r5, pc}
 8003d94:	2eaf6312 	.word	0x2eaf6312
 8003d98:	0800d558 	.word	0x0800d558

08003d9c <pin_cache_restore>:

// pin_cache_restore()
//
    static void
pin_cache_restore(const pinAttempt_t *args, uint8_t digest[32])
{
 8003d9c:	b570      	push	{r4, r5, r6, lr}
    // decrypt w/ rom secret + SRAM seed value

    ASSERT(args->magic_value == PA_MAGIC_V2);
 8003d9e:	6802      	ldr	r2, [r0, #0]
 8003da0:	4b14      	ldr	r3, [pc, #80]	; (8003df4 <pin_cache_restore+0x58>)
 8003da2:	429a      	cmp	r2, r3

// pin_cache_restore()
//
    static void
pin_cache_restore(const pinAttempt_t *args, uint8_t digest[32])
{
 8003da4:	b088      	sub	sp, #32
 8003da6:	460d      	mov	r5, r1
    // decrypt w/ rom secret + SRAM seed value

    ASSERT(args->magic_value == PA_MAGIC_V2);
 8003da8:	d002      	beq.n	8003db0 <pin_cache_restore+0x14>
 8003daa:	4813      	ldr	r0, [pc, #76]	; (8003df8 <pin_cache_restore+0x5c>)
 8003dac:	f7fc fe16 	bl	80009dc <fatal_error>
    memcpy(digest, args->cached_main_pin, 32);
 8003db0:	f100 02f8 	add.w	r2, r0, #248	; 0xf8
 8003db4:	460e      	mov	r6, r1
 8003db6:	f500 738c 	add.w	r3, r0, #280	; 0x118
 8003dba:	6810      	ldr	r0, [r2, #0]
 8003dbc:	6851      	ldr	r1, [r2, #4]
 8003dbe:	4634      	mov	r4, r6
 8003dc0:	c403      	stmia	r4!, {r0, r1}
 8003dc2:	3208      	adds	r2, #8
 8003dc4:	429a      	cmp	r2, r3
 8003dc6:	4626      	mov	r6, r4
 8003dc8:	d1f7      	bne.n	8003dba <pin_cache_restore+0x1e>

    if(!check_all_zeros(digest, 32)) {
 8003dca:	2120      	movs	r1, #32
 8003dcc:	4628      	mov	r0, r5
 8003dce:	f7fe fc3f 	bl	8002650 <check_all_zeros>
 8003dd2:	4604      	mov	r4, r0
 8003dd4:	b960      	cbnz	r0, 8003df0 <pin_cache_restore+0x54>
        uint8_t     key[32];
        pin_cache_get_key(key);
 8003dd6:	4668      	mov	r0, sp
 8003dd8:	f7ff ff8e 	bl	8003cf8 <pin_cache_get_key>
 8003ddc:	4620      	mov	r0, r4
		*(acc) ^= *(more);
 8003dde:	782a      	ldrb	r2, [r5, #0]
 8003de0:	f81d 3000 	ldrb.w	r3, [sp, r0]
 8003de4:	3001      	adds	r0, #1
 8003de6:	4053      	eors	r3, r2
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 8003de8:	2820      	cmp	r0, #32
		*(acc) ^= *(more);
 8003dea:	f805 3b01 	strb.w	r3, [r5], #1
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 8003dee:	d1f6      	bne.n	8003dde <pin_cache_restore+0x42>

        xor_mixin(digest, key, 32);
    }
}
 8003df0:	b008      	add	sp, #32
 8003df2:	bd70      	pop	{r4, r5, r6, pc}
 8003df4:	2eaf6312 	.word	0x2eaf6312
 8003df8:	0800d558 	.word	0x0800d558

08003dfc <pin_prefix_words>:
// - rate-limited by the chip, since it takes many iterations of HMAC(key we dont have)
// - hash generated is shown on bus (but further hashing happens after that)
//
    int
pin_prefix_words(const char *pin_prefix, int prefix_len, uint32_t *result)
{
 8003dfc:	b530      	push	{r4, r5, lr}
 8003dfe:	b091      	sub	sp, #68	; 0x44
    uint8_t     tmp[32];
    uint8_t     digest[32];

    // hash it up, a little
    pin_hash(pin_prefix, prefix_len, tmp, PIN_PURPOSE_WORDS);
 8003e00:	4b0b      	ldr	r3, [pc, #44]	; (8003e30 <pin_prefix_words+0x34>)
// - rate-limited by the chip, since it takes many iterations of HMAC(key we dont have)
// - hash generated is shown on bus (but further hashing happens after that)
//
    int
pin_prefix_words(const char *pin_prefix, int prefix_len, uint32_t *result)
{
 8003e02:	4615      	mov	r5, r2
    uint8_t     tmp[32];
    uint8_t     digest[32];

    // hash it up, a little
    pin_hash(pin_prefix, prefix_len, tmp, PIN_PURPOSE_WORDS);
 8003e04:	466a      	mov	r2, sp
 8003e06:	f7ff ff13 	bl	8003c30 <pin_hash>

    // Using 608a, we can do key stretching to get good built-in delays
    ae_setup();
 8003e0a:	f7fe fdcd 	bl	80029a8 <ae_setup>

    int rv = ae_stretch_iter(tmp, digest, KDF_ITER_WORDS);
 8003e0e:	220c      	movs	r2, #12
 8003e10:	a908      	add	r1, sp, #32
 8003e12:	4668      	mov	r0, sp
 8003e14:	f7ff fcd6 	bl	80037c4 <ae_stretch_iter>
 8003e18:	4604      	mov	r4, r0

    ae_reset_chip();
 8003e1a:	f7fe fdb7 	bl	800298c <ae_reset_chip>
	if(rv) return -1;
 8003e1e:	b91c      	cbnz	r4, 8003e28 <pin_prefix_words+0x2c>

    // take just 32 bits of that (only 22 bits shown to user)
    memcpy(result, digest, 4);
 8003e20:	9808      	ldr	r0, [sp, #32]
 8003e22:	6028      	str	r0, [r5, #0]

    return 0;
 8003e24:	4620      	mov	r0, r4
 8003e26:	e001      	b.n	8003e2c <pin_prefix_words+0x30>
    ae_setup();

    int rv = ae_stretch_iter(tmp, digest, KDF_ITER_WORDS);

    ae_reset_chip();
	if(rv) return -1;
 8003e28:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff

    // take just 32 bits of that (only 22 bits shown to user)
    memcpy(result, digest, 4);

    return 0;
}
 8003e2c:	b011      	add	sp, #68	; 0x44
 8003e2e:	bd30      	pop	{r4, r5, pc}
 8003e30:	2e6d6773 	.word	0x2e6d6773

08003e34 <calc_delay_required>:
calc_delay_required(int num_fails)
{
    // With the 608a, we let the slow KDF and the auto counter incr
    // protect against rate limiting... no need to do our own.
    return 0;
}
 8003e34:	2000      	movs	r0, #0
 8003e36:	4770      	bx	lr

08003e38 <pin_setup_attempt>:
// Get number of failed attempts on a PIN, since last success. Calculate
// required delay, and setup initial struct for later attempts.
//
    int
pin_setup_attempt(pinAttempt_t *args)
{
 8003e38:	b5f0      	push	{r4, r5, r6, r7, lr}
    STATIC_ASSERT(sizeof(pinAttempt_t) == PIN_ATTEMPT_SIZE_V2);

    int rv = _validate_attempt(args, true);
 8003e3a:	2101      	movs	r1, #1
// Get number of failed attempts on a PIN, since last success. Calculate
// required delay, and setup initial struct for later attempts.
//
    int
pin_setup_attempt(pinAttempt_t *args)
{
 8003e3c:	b091      	sub	sp, #68	; 0x44
 8003e3e:	4604      	mov	r4, r0
    STATIC_ASSERT(sizeof(pinAttempt_t) == PIN_ATTEMPT_SIZE_V2);

    int rv = _validate_attempt(args, true);
 8003e40:	f7ff fde8 	bl	8003a14 <_validate_attempt>
    if(rv) return rv;
 8003e44:	2800      	cmp	r0, #0
 8003e46:	d15a      	bne.n	8003efe <pin_setup_attempt+0xc6>

    // NOTE: Can only attempt primary pin. If it happens to
    // match a trick PIN, then perhaps something happens.

    if(args->is_secondary) {
 8003e48:	6867      	ldr	r7, [r4, #4]
 8003e4a:	2f00      	cmp	r7, #0
 8003e4c:	d159      	bne.n	8003f02 <pin_setup_attempt+0xca>

    // wipe most of struct, keep only what we expect and want!
    // - old firmware wrote zero to magic before this point, and so we set it here

    char    pin_copy[MAX_PIN_LEN];
    int     pin_len = args->pin_len;
 8003e4e:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    memcpy(pin_copy, args->pin, pin_len);
 8003e50:	f104 0508 	add.w	r5, r4, #8
 8003e54:	4632      	mov	r2, r6
 8003e56:	4629      	mov	r1, r5
 8003e58:	4668      	mov	r0, sp
 8003e5a:	f009 fb12 	bl	800d482 <memcpy>

    memset(args, 0, PIN_ATTEMPT_SIZE_V2);
 8003e5e:	f44f 728c 	mov.w	r2, #280	; 0x118
 8003e62:	4639      	mov	r1, r7
 8003e64:	4620      	mov	r0, r4
 8003e66:	f009 fb32 	bl	800d4ce <memset>

    args->state_flags = 0;
    args->magic_value = PA_MAGIC_V2;
 8003e6a:	4b2a      	ldr	r3, [pc, #168]	; (8003f14 <pin_setup_attempt+0xdc>)
 8003e6c:	6023      	str	r3, [r4, #0]
    args->pin_len = pin_len;
    memcpy(args->pin, pin_copy, pin_len);
 8003e6e:	4632      	mov	r2, r6
 8003e70:	4669      	mov	r1, sp
    int     pin_len = args->pin_len;
    memcpy(pin_copy, args->pin, pin_len);

    memset(args, 0, PIN_ATTEMPT_SIZE_V2);

    args->state_flags = 0;
 8003e72:	63e7      	str	r7, [r4, #60]	; 0x3c
    args->magic_value = PA_MAGIC_V2;
    args->pin_len = pin_len;
 8003e74:	62a6      	str	r6, [r4, #40]	; 0x28
    memcpy(args->pin, pin_copy, pin_len);
 8003e76:	4628      	mov	r0, r5
 8003e78:	f009 fb03 	bl	800d482 <memcpy>

    // unlock the AE chip
    if(warmup_ae()) {
 8003e7c:	f7ff fe02 	bl	8003a84 <warmup_ae>
 8003e80:	2800      	cmp	r0, #0
 8003e82:	d141      	bne.n	8003f08 <pin_setup_attempt+0xd0>
        return EPIN_I_AM_BRICK;
    }

    // read counters, and calc number of PIN attempts left
    if(get_last_success(args)) {
 8003e84:	4620      	mov	r0, r4
 8003e86:	f7ff fe3a 	bl	8003afe <get_last_success>
 8003e8a:	4605      	mov	r5, r0
 8003e8c:	b120      	cbz	r0, 8003e98 <pin_setup_attempt+0x60>
        ae_reset_chip();
 8003e8e:	f7fe fd7d 	bl	800298c <ae_reset_chip>

        return EPIN_AE_FAIL;
 8003e92:	f06f 0569 	mvn.w	r5, #105	; 0x69
 8003e96:	e039      	b.n	8003f0c <pin_setup_attempt+0xd4>
// Is a specific PIN defined already? Not safe to expose this directly to callers!
//
    static bool
pin_is_blank(uint8_t keynum)
{
    uint8_t blank[32] = {0};
 8003e98:	2220      	movs	r2, #32
 8003e9a:	4601      	mov	r1, r0

        return EPIN_AE_FAIL;
    }

    // delays now handled by chip and our KDF process directly
    args->delay_required = 0;
 8003e9c:	6320      	str	r0, [r4, #48]	; 0x30
    args->delay_achieved = 0;
 8003e9e:	62e0      	str	r0, [r4, #44]	; 0x2c
// Is a specific PIN defined already? Not safe to expose this directly to callers!
//
    static bool
pin_is_blank(uint8_t keynum)
{
    uint8_t blank[32] = {0};
 8003ea0:	eb0d 0002 	add.w	r0, sp, r2
 8003ea4:	f009 fb13 	bl	800d4ce <memset>

    ae_reset_chip();
 8003ea8:	f7fe fd70 	bl	800298c <ae_reset_chip>
    ae_pair_unlock();
 8003eac:	f7fe ff7c 	bl	8002da8 <ae_pair_unlock>

    // Passing this check with zeros, means PIN was blank.
    // Failure here means nothing (except not blank).
    int is_blank = (ae_checkmac_hard(keynum, blank) == 0);
 8003eb0:	a908      	add	r1, sp, #32
 8003eb2:	2003      	movs	r0, #3
 8003eb4:	f7ff f8e2 	bl	800307c <ae_checkmac_hard>
 8003eb8:	4606      	mov	r6, r0

    // CAUTION? We've unlocked something maybe, but it's blank, so...
    ae_reset_chip();
 8003eba:	f7fe fd67 	bl	800298c <ae_reset_chip>
    // delays now handled by chip and our KDF process directly
    args->delay_required = 0;
    args->delay_achieved = 0;

    // need to know if we are blank/unused device
    if(pin_is_blank(KEYNUM_main_pin)) {
 8003ebe:	b9c6      	cbnz	r6, 8003ef2 <pin_setup_attempt+0xba>
        args->state_flags |= PA_SUCCESSFUL | PA_IS_BLANK;
 8003ec0:	6be3      	ldr	r3, [r4, #60]	; 0x3c

        // We need to save this 'zero' value because it's encrypted, and/or might be 
        // un-initialized memory. 
        const uint8_t zeros[32] = {0};
 8003ec2:	2220      	movs	r2, #32
    args->delay_required = 0;
    args->delay_achieved = 0;

    // need to know if we are blank/unused device
    if(pin_is_blank(KEYNUM_main_pin)) {
        args->state_flags |= PA_SUCCESSFUL | PA_IS_BLANK;
 8003ec4:	f043 0303 	orr.w	r3, r3, #3
 8003ec8:	63e3      	str	r3, [r4, #60]	; 0x3c

        // We need to save this 'zero' value because it's encrypted, and/or might be 
        // un-initialized memory. 
        const uint8_t zeros[32] = {0};
 8003eca:	eb0d 0002 	add.w	r0, sp, r2
 8003ece:	4629      	mov	r1, r5
 8003ed0:	f009 fafd 	bl	800d4ce <memset>
        pin_cache_save(args, zeros);
 8003ed4:	a908      	add	r1, sp, #32
 8003ed6:	4620      	mov	r0, r4
 8003ed8:	f7ff ff28 	bl	8003d2c <pin_cache_save>
set_is_trick(pinAttempt_t *args, const trick_slot_t *slot)
{
    // Set and "encrypt" our one flag bit
    bool is_trick_pin = !!slot;

    args->private_state = ((rng_sample() & ~1) | is_trick_pin) ^ rom_secrets->hash_cache_secret[0];
 8003edc:	f7fe fbd8 	bl	8002690 <rng_sample>
 8003ee0:	4b0d      	ldr	r3, [pc, #52]	; (8003f18 <pin_setup_attempt+0xe0>)
 8003ee2:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70

    if(!slot) {
        args->delay_required = 0;
 8003ee6:	6325      	str	r5, [r4, #48]	; 0x30
set_is_trick(pinAttempt_t *args, const trick_slot_t *slot)
{
    // Set and "encrypt" our one flag bit
    bool is_trick_pin = !!slot;

    args->private_state = ((rng_sample() & ~1) | is_trick_pin) ^ rom_secrets->hash_cache_secret[0];
 8003ee8:	f020 0001 	bic.w	r0, r0, #1
 8003eec:	4058      	eors	r0, r3
 8003eee:	6420      	str	r0, [r4, #64]	; 0x40

    if(!slot) {
        args->delay_required = 0;
        args->delay_achieved = 0;
 8003ef0:	62e5      	str	r5, [r4, #44]	; 0x2c
// Provide our "signature" validating struct contents as coming from us.
//
    static void
_sign_attempt(pinAttempt_t *args)
{
    _hmac_attempt(args, args->hmac);
 8003ef2:	f104 0144 	add.w	r1, r4, #68	; 0x44
 8003ef6:	4620      	mov	r0, r4
 8003ef8:	f7ff fd5a 	bl	80039b0 <_hmac_attempt>
 8003efc:	e006      	b.n	8003f0c <pin_setup_attempt+0xd4>
 8003efe:	4605      	mov	r5, r0
 8003f00:	e004      	b.n	8003f0c <pin_setup_attempt+0xd4>
    // NOTE: Can only attempt primary pin. If it happens to
    // match a trick PIN, then perhaps something happens.

    if(args->is_secondary) {
        // secondary PIN feature has been removed
        return EPIN_PRIMARY_ONLY;
 8003f02:	f06f 0571 	mvn.w	r5, #113	; 0x71
 8003f06:	e001      	b.n	8003f0c <pin_setup_attempt+0xd4>
    args->pin_len = pin_len;
    memcpy(args->pin, pin_copy, pin_len);

    // unlock the AE chip
    if(warmup_ae()) {
        return EPIN_I_AM_BRICK;
 8003f08:	f06f 0568 	mvn.w	r5, #104	; 0x68
    }

    _sign_attempt(args);

    return 0;
}
 8003f0c:	4628      	mov	r0, r5
 8003f0e:	b011      	add	sp, #68	; 0x44
 8003f10:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003f12:	bf00      	nop
 8003f14:	2eaf6312 	.word	0x2eaf6312
 8003f18:	0801e000 	.word	0x0801e000

08003f1c <pin_delay>:
    int
pin_delay(pinAttempt_t *args)
{
    // not required since Mk2
    return 0;
}
 8003f1c:	2000      	movs	r0, #0
 8003f1e:	4770      	bx	lr

08003f20 <pin_login_attempt>:
//
// Do the PIN check, and return a value. Or fail.
//
    int
pin_login_attempt(pinAttempt_t *args)
{
 8003f20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    bool deltamode = false;
    char tmp_pin[32];

    int rv = _validate_attempt(args, false);
 8003f24:	2100      	movs	r1, #0
//
// Do the PIN check, and return a value. Or fail.
//
    int
pin_login_attempt(pinAttempt_t *args)
{
 8003f26:	f5ad 7d34 	sub.w	sp, sp, #720	; 0x2d0
 8003f2a:	4604      	mov	r4, r0
    bool deltamode = false;
    char tmp_pin[32];

    int rv = _validate_attempt(args, false);
 8003f2c:	f7ff fd72 	bl	8003a14 <_validate_attempt>
    if(rv) return rv;
 8003f30:	2800      	cmp	r0, #0
 8003f32:	f040 80df 	bne.w	80040f4 <pin_login_attempt+0x1d4>

    if(args->state_flags & PA_SUCCESSFUL) {
 8003f36:	6be6      	ldr	r6, [r4, #60]	; 0x3c
 8003f38:	f016 0601 	ands.w	r6, r6, #1
 8003f3c:	f040 80d5 	bne.w	80040ea <pin_login_attempt+0x1ca>
    }

    // Mk4: Check SE2 first to see if this is a "trick" pin.
    // - this call may have side-effects, like wiping keys, bricking, etc.
    trick_slot_t    slot;
    bool is_trick = se2_test_trick_pin(args->pin, args->pin_len, &slot, false);
 8003f40:	f104 0708 	add.w	r7, r4, #8
 8003f44:	4633      	mov	r3, r6
 8003f46:	aa13      	add	r2, sp, #76	; 0x4c
 8003f48:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8003f4a:	4638      	mov	r0, r7
 8003f4c:	f003 fee4 	bl	8007d18 <se2_test_trick_pin>
    
    if(is_trick) {
 8003f50:	2800      	cmp	r0, #0
 8003f52:	f000 808b 	beq.w	800406c <pin_login_attempt+0x14c>
        // They gave a trick PIN. Implement it.

        // Mark as success
        args->state_flags = PA_SUCCESSFUL;
 8003f56:	2301      	movs	r3, #1
 8003f58:	63e3      	str	r3, [r4, #60]	; 0x3c
        args->num_fails = 0;
        args->attempts_left = MAX_TARGET_ATTEMPTS;
 8003f5a:	230d      	movs	r3, #13
    if(is_trick) {
        // They gave a trick PIN. Implement it.

        // Mark as success
        args->state_flags = PA_SUCCESSFUL;
        args->num_fails = 0;
 8003f5c:	6366      	str	r6, [r4, #52]	; 0x34
        args->attempts_left = MAX_TARGET_ATTEMPTS;
 8003f5e:	63a3      	str	r3, [r4, #56]	; 0x38

        if(check_all_zeros(slot.xdata, 32) || (slot.tc_flags & TC_WIPE)) {
 8003f60:	2120      	movs	r1, #32
 8003f62:	a815      	add	r0, sp, #84	; 0x54
 8003f64:	f7fe fb74 	bl	8002650 <check_all_zeros>
 8003f68:	b918      	cbnz	r0, 8003f72 <pin_login_attempt+0x52>
 8003f6a:	f9bd 3050 	ldrsh.w	r3, [sp, #80]	; 0x50
 8003f6e:	2b00      	cmp	r3, #0
 8003f70:	da03      	bge.n	8003f7a <pin_login_attempt+0x5a>
            args->state_flags |= PA_ZERO_SECRET;
 8003f72:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8003f74:	f043 0310 	orr.w	r3, r3, #16
 8003f78:	63e3      	str	r3, [r4, #60]	; 0x3c
set_is_trick(pinAttempt_t *args, const trick_slot_t *slot)
{
    // Set and "encrypt" our one flag bit
    bool is_trick_pin = !!slot;

    args->private_state = ((rng_sample() & ~1) | is_trick_pin) ^ rom_secrets->hash_cache_secret[0];
 8003f7a:	f7fe fb89 	bl	8002690 <rng_sample>
 8003f7e:	4b5f      	ldr	r3, [pc, #380]	; (80040fc <pin_login_attempt+0x1dc>)
 8003f80:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
 8003f84:	f040 0001 	orr.w	r0, r0, #1
 8003f88:	4058      	eors	r0, r3

    // Hints for other mpy firmware to implement more trick features
    // impt detail: 
    // - duress wallet case, and many others will still read as zero here.
    // - mpy does need to know about TC_DELTA_MODE case, but not direction & amount
    uint16_t masked = (slot->tc_flags & ~TC_HIDDEN_MASK);
 8003f8a:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
set_is_trick(pinAttempt_t *args, const trick_slot_t *slot)
{
    // Set and "encrypt" our one flag bit
    bool is_trick_pin = !!slot;

    args->private_state = ((rng_sample() & ~1) | is_trick_pin) ^ rom_secrets->hash_cache_secret[0];
 8003f8e:	6420      	str	r0, [r4, #64]	; 0x40
    // Hints for other mpy firmware to implement more trick features
    // impt detail: 
    // - duress wallet case, and many others will still read as zero here.
    // - mpy does need to know about TC_DELTA_MODE case, but not direction & amount
    uint16_t masked = (slot->tc_flags & ~TC_HIDDEN_MASK);
    args->delay_required = masked;
 8003f90:	f3c3 020a 	ubfx	r2, r3, #0, #11
 8003f94:	6322      	str	r2, [r4, #48]	; 0x30
    args->delay_achieved = (slot->tc_flags & TC_DELTA_MODE) ? 0 : slot->tc_arg;
 8003f96:	055a      	lsls	r2, r3, #21
 8003f98:	bf58      	it	pl
 8003f9a:	f8bd 6052 	ldrhpl.w	r6, [sp, #82]	; 0x52
 8003f9e:	62e6      	str	r6, [r4, #44]	; 0x2c
//
    static void
_make_trick_aes_key(const pinAttempt_t *args, uint8_t key[32])
{
    // key is args->private_state (4 bytes) + 28 bytes from hash_cache_secret
    memcpy(key, &args->private_state, sizeof(args->private_state));
 8003fa0:	6c20      	ldr	r0, [r4, #64]	; 0x40
    memcpy(key+4, rom_secrets->hash_cache_secret+4, sizeof(rom_secrets->hash_cache_secret)-4);
 8003fa2:	4e57      	ldr	r6, [pc, #348]	; (8004100 <pin_login_attempt+0x1e0>)
//
    static void
_make_trick_aes_key(const pinAttempt_t *args, uint8_t key[32])
{
    // key is args->private_state (4 bytes) + 28 bytes from hash_cache_secret
    memcpy(key, &args->private_state, sizeof(args->private_state));
 8003fa4:	900b      	str	r0, [sp, #44]	; 0x2c
    memcpy(key+4, rom_secrets->hash_cache_secret+4, sizeof(rom_secrets->hash_cache_secret)-4);
 8003fa6:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8003fa8:	ad0c      	add	r5, sp, #48	; 0x30
 8003faa:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8003fac:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 8003fb0:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    uint8_t     key[32];
    _make_trick_aes_key(args, key);

    // capture first 32 bytes of slot info
    AES_CTX ctx;
    aes_init(&ctx);
 8003fb4:	a833      	add	r0, sp, #204	; 0xcc
 8003fb6:	f004 f90f 	bl	80081d8 <aes_init>
    aes_add(&ctx, (uint8_t *)slot, 32);
    aes_done(&ctx, args->cached_main_pin, 32, key, NULL);
 8003fba:	f04f 0800 	mov.w	r8, #0
    _make_trick_aes_key(args, key);

    // capture first 32 bytes of slot info
    AES_CTX ctx;
    aes_init(&ctx);
    aes_add(&ctx, (uint8_t *)slot, 32);
 8003fbe:	2220      	movs	r2, #32
 8003fc0:	a913      	add	r1, sp, #76	; 0x4c
 8003fc2:	a833      	add	r0, sp, #204	; 0xcc
 8003fc4:	f004 f90e 	bl	80081e4 <aes_add>
    aes_done(&ctx, args->cached_main_pin, 32, key, NULL);
 8003fc8:	ab0b      	add	r3, sp, #44	; 0x2c
 8003fca:	f8cd 8000 	str.w	r8, [sp]
 8003fce:	2220      	movs	r2, #32
 8003fd0:	f104 01f8 	add.w	r1, r4, #248	; 0xf8
 8003fd4:	a833      	add	r0, sp, #204	; 0xcc
 8003fd6:	f004 f91b 	bl	8008210 <aes_done>
        // this encodes one bit, and picks a nonce; also saves hint to mpy if appropriate
        // - encrypts and saves slot# and tc_flags as well for duress wallet cases
        // - but only 32 byte there, so store just the slot number and tc_flags
        set_is_trick(args, &slot);

        if(slot.tc_flags & TC_DELTA_MODE) {
 8003fda:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
 8003fde:	055b      	lsls	r3, r3, #21
 8003fe0:	d53d      	bpl.n	800405e <pin_login_attempt+0x13e>
{
    // Starting with provided on pin as a string, change the last few digits
    // given to be replacement value which gives true pin.
    // - encoding: BCD with 0xf for unchanged
    
    memcpy(tmp_pin, pin, pin_len);
 8003fe2:	6aa5      	ldr	r5, [r4, #40]	; 0x28
            // Thug gave wrong PIN, but we are going to let them 
            // past (by calculating correct PIN, up to 4 digits different),
            // and the mpy firmware can do tricky stuff to protect funds
            // even though the private key is known at that point.
            deltamode = true;
            apply_pin_delta(args->pin, args->pin_len, slot.tc_arg, tmp_pin);
 8003fe4:	f8bd 6052 	ldrh.w	r6, [sp, #82]	; 0x52
{
    // Starting with provided on pin as a string, change the last few digits
    // given to be replacement value which gives true pin.
    // - encoding: BCD with 0xf for unchanged
    
    memcpy(tmp_pin, pin, pin_len);
 8003fe8:	ab03      	add	r3, sp, #12
 8003fea:	462a      	mov	r2, r5
 8003fec:	4618      	mov	r0, r3
 8003fee:	4639      	mov	r1, r7
 8003ff0:	f009 fa47 	bl	800d482 <memcpy>
 8003ff4:	4603      	mov	r3, r0
    tmp_pin[pin_len] = 0;
 8003ff6:	f800 8005 	strb.w	r8, [r0, r5]

    char *p = &tmp_pin[pin_len-1];
 8003ffa:	1e68      	subs	r0, r5, #1
 8003ffc:	4418      	add	r0, r3
 8003ffe:	2204      	movs	r2, #4

    for(int i=0; i<4; i++, p--) {
        if(*p == '-') p--;
 8004000:	7803      	ldrb	r3, [r0, #0]
 8004002:	2b2d      	cmp	r3, #45	; 0x2d
 8004004:	f006 030f 	and.w	r3, r6, #15
 8004008:	bf08      	it	eq
 800400a:	f100 30ff 	addeq.w	r0, r0, #4294967295	; 0xffffffff

        int here = replacement & 0xf;
        replacement >>= 4;

        if((here >= 0) && (here <= 9)) {
 800400e:	2b09      	cmp	r3, #9
            *p = '0' + here; 
 8004010:	bf9c      	itt	ls
 8004012:	3330      	addls	r3, #48	; 0x30
 8004014:	7003      	strbls	r3, [r0, #0]
    memcpy(tmp_pin, pin, pin_len);
    tmp_pin[pin_len] = 0;

    char *p = &tmp_pin[pin_len-1];

    for(int i=0; i<4; i++, p--) {
 8004016:	3a01      	subs	r2, #1
        if(*p == '-') p--;

        int here = replacement & 0xf;
        replacement >>= 4;
 8004018:	ea4f 1616 	mov.w	r6, r6, lsr #4
    memcpy(tmp_pin, pin, pin_len);
    tmp_pin[pin_len] = 0;

    char *p = &tmp_pin[pin_len-1];

    for(int i=0; i<4; i++, p--) {
 800401c:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
 8004020:	d1ee      	bne.n	8004000 <pin_login_attempt+0xe0>
        if(slot.tc_flags & TC_DELTA_MODE) {
            // Thug gave wrong PIN, but we are going to let them 
            // past (by calculating correct PIN, up to 4 digits different),
            // and the mpy firmware can do tricky stuff to protect funds
            // even though the private key is known at that point.
            deltamode = true;
 8004022:	2501      	movs	r5, #1
 8004024:	e023      	b.n	800406e <pin_login_attempt+0x14e>
        if(rv) {
            ae_reset_chip();

            return EPIN_AE_FAIL;
        }
        ae_reset_chip();
 8004026:	f7fe fcb1 	bl	800298c <ae_reset_chip>

        // if mcu_key empty, then that's also "zero"
        bool mcu_key_valid;
        mcu_key_get(&mcu_key_valid);
 800402a:	f10d 000b 	add.w	r0, sp, #11
 800402e:	f7fe fa03 	bl	8002438 <mcu_key_get>

        // new fresh system comes here comes w/ zeros (plaintext) in secret slot of SE1
        if(check_all_zeros(ts, AE_SECRET_LEN) || !mcu_key_valid) {
 8004032:	4631      	mov	r1, r6
 8004034:	a833      	add	r0, sp, #204	; 0xcc
 8004036:	f7fe fb0b 	bl	8002650 <check_all_zeros>
 800403a:	2800      	cmp	r0, #0
 800403c:	d150      	bne.n	80040e0 <pin_login_attempt+0x1c0>
 800403e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8004042:	2b00      	cmp	r3, #0
 8004044:	d04c      	beq.n	80040e0 <pin_login_attempt+0x1c0>

    // indicate what features already enabled/non-blank
    //      args->state_flags |= (PA_HAS_DURESS | PA_HAS_BRICKME);
    // - mk3 and earlier set these flags, but that's obsolete now
    // - mk4 requires knowledge of the specific trick PIN to know what it does
    if(!deltamode) {
 8004046:	b955      	cbnz	r5, 800405e <pin_login_attempt+0x13e>
set_is_trick(pinAttempt_t *args, const trick_slot_t *slot)
{
    // Set and "encrypt" our one flag bit
    bool is_trick_pin = !!slot;

    args->private_state = ((rng_sample() & ~1) | is_trick_pin) ^ rom_secrets->hash_cache_secret[0];
 8004048:	f7fe fb22 	bl	8002690 <rng_sample>
 800404c:	4b2b      	ldr	r3, [pc, #172]	; (80040fc <pin_login_attempt+0x1dc>)
 800404e:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70

    if(!slot) {
        args->delay_required = 0;
 8004052:	6325      	str	r5, [r4, #48]	; 0x30
set_is_trick(pinAttempt_t *args, const trick_slot_t *slot)
{
    // Set and "encrypt" our one flag bit
    bool is_trick_pin = !!slot;

    args->private_state = ((rng_sample() & ~1) | is_trick_pin) ^ rom_secrets->hash_cache_secret[0];
 8004054:	f020 0001 	bic.w	r0, r0, #1
 8004058:	4058      	eors	r0, r3
 800405a:	6420      	str	r0, [r4, #64]	; 0x40

    if(!slot) {
        args->delay_required = 0;
        args->delay_achieved = 0;
 800405c:	62e5      	str	r5, [r4, #44]	; 0x2c
// Provide our "signature" validating struct contents as coming from us.
//
    static void
_sign_attempt(pinAttempt_t *args)
{
    _hmac_attempt(args, args->hmac);
 800405e:	4620      	mov	r0, r4
 8004060:	f104 0144 	add.w	r1, r4, #68	; 0x44
 8004064:	f7ff fca4 	bl	80039b0 <_hmac_attempt>

            goto real_login;
        }
        _sign_attempt(args);

        return 0;
 8004068:	2000      	movs	r0, #0
 800406a:	e043      	b.n	80040f4 <pin_login_attempt+0x1d4>
// Do the PIN check, and return a value. Or fail.
//
    int
pin_login_attempt(pinAttempt_t *args)
{
    bool deltamode = false;
 800406c:	4605      	mov	r5, r0
        return 0;
    }

real_login:
    // unlock the AE chip
    if(warmup_ae()) return EPIN_I_AM_BRICK;
 800406e:	f7ff fd09 	bl	8003a84 <warmup_ae>
 8004072:	2800      	cmp	r0, #0
 8004074:	d13c      	bne.n	80040f0 <pin_login_attempt+0x1d0>

    // hash up the pin now, assuming we'll use it on main PIN
    uint8_t     digest[32];
    rv = pin_hash_attempt(deltamode ? tmp_pin : args->pin, args->pin_len, digest);
 8004076:	b105      	cbz	r5, 800407a <pin_login_attempt+0x15a>
 8004078:	af03      	add	r7, sp, #12
 800407a:	aa0b      	add	r2, sp, #44	; 0x2c
 800407c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800407e:	4638      	mov	r0, r7
 8004080:	f7ff fe0e 	bl	8003ca0 <pin_hash_attempt>
    if(rv) return EPIN_AE_FAIL;
 8004084:	bb48      	cbnz	r0, 80040da <pin_login_attempt+0x1ba>
// Do the checkmac thing using a PIN, and if it works, great.
//
    static bool
is_main_pin(const uint8_t digest[32])
{
    ae_reset_chip();
 8004086:	f7fe fc81 	bl	800298c <ae_reset_chip>
    ae_pair_unlock();
 800408a:	f7fe fe8d 	bl	8002da8 <ae_pair_unlock>

    return (ae_checkmac_hard(KEYNUM_main_pin, digest) == 0);
 800408e:	a90b      	add	r1, sp, #44	; 0x2c
 8004090:	2003      	movs	r0, #3
 8004092:	f7fe fff3 	bl	800307c <ae_checkmac_hard>
    rv = pin_hash_attempt(deltamode ? tmp_pin : args->pin, args->pin_len, digest);
    if(rv) return EPIN_AE_FAIL;

    // It is not a "trick pin", so assume it's the real PIN, and register
    // as an attempt on that.
    if(!is_main_pin(digest)) {
 8004096:	b130      	cbz	r0, 80040a6 <pin_login_attempt+0x186>
        // PIN code is just wrong.
        // - nothing to update, since the chip's done it already
        // - but maybe there are consequences to a wrong pin
        se2_handle_bad_pin(args->num_fails + 1);
 8004098:	6b60      	ldr	r0, [r4, #52]	; 0x34
 800409a:	3001      	adds	r0, #1
 800409c:	f003 ff20 	bl	8007ee0 <se2_handle_bad_pin>

        return EPIN_AUTH_FAIL;
 80040a0:	f06f 006f 	mvn.w	r0, #111	; 0x6f
 80040a4:	e026      	b.n	80040f4 <pin_login_attempt+0x1d4>
    }

    // change the various counters, since this worked
    rv = updates_for_good_login(digest);
 80040a6:	a80b      	add	r0, sp, #44	; 0x2c
 80040a8:	f7ff fd72 	bl	8003b90 <updates_for_good_login>
    if(rv) return EPIN_AE_FAIL;
 80040ac:	4606      	mov	r6, r0
 80040ae:	b9a0      	cbnz	r0, 80040da <pin_login_attempt+0x1ba>

    // SUCCESS! "digest" holds a working value. Save it.
    pin_cache_save(args, digest);
 80040b0:	a90b      	add	r1, sp, #44	; 0x2c
 80040b2:	4620      	mov	r0, r4
 80040b4:	f7ff fe3a 	bl	8003d2c <pin_cache_save>

    // ASIDE: even if the above was bypassed, the following code will
    // fail when it tries to read/update the corresponding slots in the SE

    // mark as success
    args->state_flags = PA_SUCCESSFUL;
 80040b8:	2301      	movs	r3, #1
 80040ba:	63e3      	str	r3, [r4, #60]	; 0x3c

    // these are constants, and user doesn't care because they got in... but consistency.
    args->num_fails = 0;
 80040bc:	6366      	str	r6, [r4, #52]	; 0x34
    args->attempts_left = MAX_TARGET_ATTEMPTS;
 80040be:	230d      	movs	r3, #13
    // I used to always read the secret, since it's so hard to get to this point,
    // but now just indicating if zero or non-zero so that we don't contaminate the
    // caller w/ sensitive data that they may not want yet.
    {   uint8_t ts[AE_SECRET_LEN];

        rv = ae_encrypted_read(KEYNUM_secret, KEYNUM_main_pin, digest, ts, AE_SECRET_LEN);
 80040c0:	2648      	movs	r6, #72	; 0x48
    // mark as success
    args->state_flags = PA_SUCCESSFUL;

    // these are constants, and user doesn't care because they got in... but consistency.
    args->num_fails = 0;
    args->attempts_left = MAX_TARGET_ATTEMPTS;
 80040c2:	63a3      	str	r3, [r4, #56]	; 0x38
    // I used to always read the secret, since it's so hard to get to this point,
    // but now just indicating if zero or non-zero so that we don't contaminate the
    // caller w/ sensitive data that they may not want yet.
    {   uint8_t ts[AE_SECRET_LEN];

        rv = ae_encrypted_read(KEYNUM_secret, KEYNUM_main_pin, digest, ts, AE_SECRET_LEN);
 80040c4:	9600      	str	r6, [sp, #0]
 80040c6:	ab33      	add	r3, sp, #204	; 0xcc
 80040c8:	aa0b      	add	r2, sp, #44	; 0x2c
 80040ca:	2103      	movs	r1, #3
 80040cc:	2009      	movs	r0, #9
 80040ce:	f7ff f8b1 	bl	8003234 <ae_encrypted_read>
        if(rv) {
 80040d2:	2800      	cmp	r0, #0
 80040d4:	d0a7      	beq.n	8004026 <pin_login_attempt+0x106>
            ae_reset_chip();
 80040d6:	f7fe fc59 	bl	800298c <ae_reset_chip>

            return EPIN_AE_FAIL;
 80040da:	f06f 0069 	mvn.w	r0, #105	; 0x69
 80040de:	e009      	b.n	80040f4 <pin_login_attempt+0x1d4>
        bool mcu_key_valid;
        mcu_key_get(&mcu_key_valid);

        // new fresh system comes here comes w/ zeros (plaintext) in secret slot of SE1
        if(check_all_zeros(ts, AE_SECRET_LEN) || !mcu_key_valid) {
            args->state_flags |= PA_ZERO_SECRET;
 80040e0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80040e2:	f043 0310 	orr.w	r3, r3, #16
 80040e6:	63e3      	str	r3, [r4, #60]	; 0x3c
 80040e8:	e7ad      	b.n	8004046 <pin_login_attempt+0x126>
    int rv = _validate_attempt(args, false);
    if(rv) return rv;

    if(args->state_flags & PA_SUCCESSFUL) {
        // already worked, or is blank
        return EPIN_WRONG_SUCCESS;
 80040ea:	f06f 006c 	mvn.w	r0, #108	; 0x6c
 80040ee:	e001      	b.n	80040f4 <pin_login_attempt+0x1d4>
        return 0;
    }

real_login:
    // unlock the AE chip
    if(warmup_ae()) return EPIN_I_AM_BRICK;
 80040f0:	f06f 0068 	mvn.w	r0, #104	; 0x68
    }

    _sign_attempt(args);

    return 0;
}
 80040f4:	f50d 7d34 	add.w	sp, sp, #720	; 0x2d0
 80040f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80040fc:	0801e000 	.word	0x0801e000
 8004100:	0801e074 	.word	0x0801e074

08004104 <pin_check_logged_in>:
//
// Verify we know the main PIN, but don't do anything with it.
//
    int
pin_check_logged_in(const pinAttempt_t *args, bool *is_trick)
{
 8004104:	b570      	push	{r4, r5, r6, lr}
 8004106:	460e      	mov	r6, r1
 8004108:	b088      	sub	sp, #32
    int rv = _validate_attempt(args, false);
 800410a:	2100      	movs	r1, #0
//
// Verify we know the main PIN, but don't do anything with it.
//
    int
pin_check_logged_in(const pinAttempt_t *args, bool *is_trick)
{
 800410c:	4605      	mov	r5, r0
    int rv = _validate_attempt(args, false);
 800410e:	f7ff fc81 	bl	8003a14 <_validate_attempt>
    if(rv) return rv;
 8004112:	4604      	mov	r4, r0
 8004114:	bb18      	cbnz	r0, 800415e <pin_check_logged_in+0x5a>

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
 8004116:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8004118:	07db      	lsls	r3, r3, #31
 800411a:	d522      	bpl.n	8004162 <pin_check_logged_in+0x5e>
    static bool
get_is_trick(const pinAttempt_t *args, trick_slot_t *slot)
{
    // read and "decrypt" our one flag bit
    // - optional: aes-decrypt some more details about the trick slot
    bool is_trick = ((args->private_state ^ rom_secrets->hash_cache_secret[0]) & 0x1);
 800411c:	4b13      	ldr	r3, [pc, #76]	; (800416c <pin_check_logged_in+0x68>)
    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
        // must come here with a successful PIN login (so it's rate limited nicely)
        return EPIN_WRONG_SUCCESS;
    }

    if(get_is_trick(args, NULL)) {
 800411e:	f893 2070 	ldrb.w	r2, [r3, #112]	; 0x70
 8004122:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 8004124:	4053      	eors	r3, r2
 8004126:	f013 0301 	ands.w	r3, r3, #1
 800412a:	d007      	beq.n	800413c <pin_check_logged_in+0x38>
        // they used a trick pin to get this far. Amuse them more.
        *is_trick = true;
 800412c:	2301      	movs	r3, #1
 800412e:	7033      	strb	r3, [r6, #0]

        // should calibrate this, but smart money will just look at the bus
        delay_ms(10);
 8004130:	200a      	movs	r0, #10
 8004132:	f7ff fbad 	bl	8003890 <delay_ms>
        rng_delay();
 8004136:	f7fe fb02 	bl	800273e <rng_delay>
 800413a:	e010      	b.n	800415e <pin_check_logged_in+0x5a>
    } else {
        *is_trick = false;
 800413c:	7033      	strb	r3, [r6, #0]

        // check we know the right PIN
        uint8_t auth_digest[32]; 
        pin_cache_restore(args, auth_digest);
 800413e:	4669      	mov	r1, sp
 8004140:	4628      	mov	r0, r5
 8004142:	f7ff fe2b 	bl	8003d9c <pin_cache_restore>

        ae_pair_unlock();
 8004146:	f7fe fe2f 	bl	8002da8 <ae_pair_unlock>
        int rv = ae_checkmac(KEYNUM_main_pin, auth_digest);
 800414a:	4669      	mov	r1, sp
 800414c:	2003      	movs	r0, #3
 800414e:	f7fe fdab 	bl	8002ca8 <ae_checkmac>
        if(rv) return EPIN_AUTH_FAIL;
 8004152:	2800      	cmp	r0, #0
 8004154:	bf0c      	ite	eq
 8004156:	2000      	moveq	r0, #0
 8004158:	f06f 006f 	mvnne.w	r0, #111	; 0x6f
 800415c:	e003      	b.n	8004166 <pin_check_logged_in+0x62>
 800415e:	4620      	mov	r0, r4
 8004160:	e001      	b.n	8004166 <pin_check_logged_in+0x62>
    int rv = _validate_attempt(args, false);
    if(rv) return rv;

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
        // must come here with a successful PIN login (so it's rate limited nicely)
        return EPIN_WRONG_SUCCESS;
 8004162:	f06f 006c 	mvn.w	r0, #108	; 0x6c
        int rv = ae_checkmac(KEYNUM_main_pin, auth_digest);
        if(rv) return EPIN_AUTH_FAIL;
    }

    return 0;
}
 8004166:	b008      	add	sp, #32
 8004168:	bd70      	pop	{r4, r5, r6, pc}
 800416a:	bf00      	nop
 800416c:	0801e000 	.word	0x0801e000

08004170 <pin_change>:
//
// Change the PIN and/or the secret. (Must also know the previous value, or it must be blank)
//
    int
pin_change(pinAttempt_t *args)
{
 8004170:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    // Validate args and signature
    int rv = _validate_attempt(args, false);
 8004174:	2100      	movs	r1, #0
//
// Change the PIN and/or the secret. (Must also know the previous value, or it must be blank)
//
    int
pin_change(pinAttempt_t *args)
{
 8004176:	b0ae      	sub	sp, #184	; 0xb8
 8004178:	4604      	mov	r4, r0
    // Validate args and signature
    int rv = _validate_attempt(args, false);
 800417a:	f7ff fc4b 	bl	8003a14 <_validate_attempt>
    if(rv) return rv;
 800417e:	2800      	cmp	r0, #0
 8004180:	f040 8099 	bne.w	80042b6 <pin_change+0x146>

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
 8004184:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8004186:	07d9      	lsls	r1, r3, #31
 8004188:	f140 8097 	bpl.w	80042ba <pin_change+0x14a>
        // must come here with a successful PIN login (so it's rate limited nicely)
        return EPIN_WRONG_SUCCESS;
    }

    if(args->state_flags & PA_IS_BLANK) {
 800418c:	079a      	lsls	r2, r3, #30
 800418e:	d503      	bpl.n	8004198 <pin_change+0x28>
        // if blank, must provide blank value
        if(args->pin_len) return EPIN_RANGE_ERR;
 8004190:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8004192:	2b00      	cmp	r3, #0
 8004194:	f040 8097 	bne.w	80042c6 <pin_change+0x156>
    }

    // Look at change flags.
    const uint32_t cf = args->change_flags;

    ASSERT(!args->is_secondary);
 8004198:	6863      	ldr	r3, [r4, #4]
        // if blank, must provide blank value
        if(args->pin_len) return EPIN_RANGE_ERR;
    }

    // Look at change flags.
    const uint32_t cf = args->change_flags;
 800419a:	f8d4 9064 	ldr.w	r9, [r4, #100]	; 0x64

    ASSERT(!args->is_secondary);
 800419e:	b113      	cbz	r3, 80041a6 <pin_change+0x36>
 80041a0:	484d      	ldr	r0, [pc, #308]	; (80042d8 <pin_change+0x168>)
 80041a2:	f7fc fc1b 	bl	80009dc <fatal_error>
    if(cf & CHANGE_SECONDARY_WALLET_PIN) {
        // obsolete secondary support, can't support.
        return EPIN_BAD_REQUEST;
    }
    if(cf & (CHANGE_DURESS_PIN | CHANGE_DURESS_SECRET | CHANGE_BRICKME_PIN)) {
 80041a6:	f019 0f36 	tst.w	r9, #54	; 0x36
 80041aa:	f040 8089 	bne.w	80042c0 <pin_change+0x150>
        // we need some new API for trick PIN lookup/changes. 
        return EPIN_BAD_REQUEST;
    }
    if(!(cf & (CHANGE_WALLET_PIN | CHANGE_SECRET))) {
 80041ae:	f019 0f09 	tst.w	r9, #9
 80041b2:	f000 8088 	beq.w	80042c6 <pin_change+0x156>
    static bool
get_is_trick(const pinAttempt_t *args, trick_slot_t *slot)
{
    // read and "decrypt" our one flag bit
    // - optional: aes-decrypt some more details about the trick slot
    bool is_trick = ((args->private_state ^ rom_secrets->hash_cache_secret[0]) & 0x1);
 80041b6:	4b49      	ldr	r3, [pc, #292]	; (80042dc <pin_change+0x16c>)
    // If they authorized w/ a trick PIN, new policy is to wipe ourselves if
    // they try to change PIN code or the secret.
    //  - it's hard to fake them out here, and they may be onto us.
    //  - this protects the seed, but does end the game somewhat
    //  - all trick PINs will still be in effect, and looks like random reset
    if(get_is_trick(args, NULL)) {
 80041b8:	f893 2070 	ldrb.w	r2, [r3, #112]	; 0x70
 80041bc:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80041be:	4053      	eors	r3, r2
 80041c0:	07db      	lsls	r3, r3, #31
 80041c2:	d502      	bpl.n	80041ca <pin_change+0x5a>
        // User is a thug.. kill secret and reboot w/o any notice
        fast_wipe();
 80041c4:	f7fe fa1a 	bl	80025fc <fast_wipe>
 80041c8:	e07a      	b.n	80042c0 <pin_change+0x150>
        // NOT-REACHED
        return EPIN_BAD_REQUEST;
    }

    // unlock the AE chip
    if(warmup_ae()) return EPIN_I_AM_BRICK;
 80041ca:	f7ff fc5b 	bl	8003a84 <warmup_ae>
 80041ce:	4605      	mov	r5, r0
 80041d0:	2800      	cmp	r0, #0
 80041d2:	d17b      	bne.n	80042cc <pin_change+0x15c>
    // If they tricked us to get to this point, doesn't matter as
    // below SE1 validates it all again.

    // Restore cached version of PIN digest: fast
    uint8_t required_digest[32]; 
    pin_cache_restore(args, required_digest);
 80041d4:	f10d 0808 	add.w	r8, sp, #8
 80041d8:	4641      	mov	r1, r8
 80041da:	4620      	mov	r0, r4
 80041dc:	f7ff fdde 	bl	8003d9c <pin_cache_restore>

    // Calculate new PIN hashed value: will be slow to do
    if(cf & CHANGE_WALLET_PIN) {
 80041e0:	f019 0f01 	tst.w	r9, #1
 80041e4:	d021      	beq.n	800422a <pin_change+0xba>
        uint8_t new_digest[32]; 
        rv = pin_hash_attempt(args->new_pin, args->new_pin_len, new_digest);
 80041e6:	aa1c      	add	r2, sp, #112	; 0x70
 80041e8:	f8d4 10ac 	ldr.w	r1, [r4, #172]	; 0xac
 80041ec:	f104 008c 	add.w	r0, r4, #140	; 0x8c
 80041f0:	f7ff fd56 	bl	8003ca0 <pin_hash_attempt>
        if(rv) goto ae_fail;
 80041f4:	2800      	cmp	r0, #0
 80041f6:	d159      	bne.n	80042ac <pin_change+0x13c>

        if(ae_encrypted_write(KEYNUM_main_pin, KEYNUM_main_pin, required_digest, new_digest, 32)) {
 80041f8:	2320      	movs	r3, #32
 80041fa:	2103      	movs	r1, #3
 80041fc:	9300      	str	r3, [sp, #0]
 80041fe:	4642      	mov	r2, r8
 8004200:	ab1c      	add	r3, sp, #112	; 0x70
 8004202:	4608      	mov	r0, r1
 8004204:	f7ff f8b6 	bl	8003374 <ae_encrypted_write>
 8004208:	2800      	cmp	r0, #0
 800420a:	d14f      	bne.n	80042ac <pin_change+0x13c>
            goto ae_fail;
        }

        memcpy(required_digest, new_digest, 32);
 800420c:	af1c      	add	r7, sp, #112	; 0x70
 800420e:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8004210:	4646      	mov	r6, r8
 8004212:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8004214:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
 8004218:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}

        // main pin is changing; reset counter to zero (good login) and our cache
        pin_cache_save(args, new_digest);
 800421c:	4620      	mov	r0, r4
 800421e:	a91c      	add	r1, sp, #112	; 0x70
 8004220:	f7ff fd84 	bl	8003d2c <pin_cache_save>

        updates_for_good_login(new_digest);
 8004224:	a81c      	add	r0, sp, #112	; 0x70
 8004226:	f7ff fcb3 	bl	8003b90 <updates_for_good_login>
    }

    // Recording new secret.
    // Note the required_digest might have just changed above.
    if(cf & CHANGE_SECRET) {
 800422a:	f019 0f08 	tst.w	r9, #8
 800422e:	d035      	beq.n	800429c <pin_change+0x12c>
// Mk4 support additional secret storage: spares. Map to key number, or -1 if range error
//
    static int
keynum_for_secret(const pinAttempt_t *args)
{
    int which = (args->change_flags >> 8) & 0xf;
 8004230:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8004232:	f3c3 2303 	ubfx	r3, r3, #8, #4
 8004236:	2b03      	cmp	r3, #3
 8004238:	dc45      	bgt.n	80042c6 <pin_change+0x156>
 800423a:	4a29      	ldr	r2, [pc, #164]	; (80042e0 <pin_change+0x170>)
 800423c:	f912 a003 	ldrsb.w	sl, [r2, r3]
        uint8_t     tmp[AE_SECRET_LEN];
        uint8_t     check[AE_SECRET_LEN];

        // what slot (key number) are updating? (probably: KEYNUM_secret)
        int         target_slot = keynum_for_secret(args);
        if(target_slot < 0) return EPIN_RANGE_ERR;
 8004240:	f1ba 0f00 	cmp.w	sl, #0
 8004244:	db3f      	blt.n	80042c6 <pin_change+0x156>

        se2_encrypt_secret(args->secret, AE_SECRET_LEN, 0, tmp, check, required_digest);
 8004246:	f104 07b0 	add.w	r7, r4, #176	; 0xb0
 800424a:	ae1c      	add	r6, sp, #112	; 0x70
 800424c:	ab0a      	add	r3, sp, #40	; 0x28
 800424e:	2200      	movs	r2, #0
 8004250:	2148      	movs	r1, #72	; 0x48
 8004252:	f8cd 8004 	str.w	r8, [sp, #4]
 8004256:	9600      	str	r6, [sp, #0]
 8004258:	4638      	mov	r0, r7

        // write into two slots
        if(ae_encrypted_write(target_slot, KEYNUM_main_pin,
 800425a:	f04f 0948 	mov.w	r9, #72	; 0x48

        // what slot (key number) are updating? (probably: KEYNUM_secret)
        int         target_slot = keynum_for_secret(args);
        if(target_slot < 0) return EPIN_RANGE_ERR;

        se2_encrypt_secret(args->secret, AE_SECRET_LEN, 0, tmp, check, required_digest);
 800425e:	f003 ff05 	bl	800806c <se2_encrypt_secret>

        // write into two slots
        if(ae_encrypted_write(target_slot, KEYNUM_main_pin,
 8004262:	2103      	movs	r1, #3
 8004264:	f8cd 9000 	str.w	r9, [sp]
 8004268:	ab0a      	add	r3, sp, #40	; 0x28
 800426a:	4642      	mov	r2, r8
 800426c:	4650      	mov	r0, sl
 800426e:	f7ff f881 	bl	8003374 <ae_encrypted_write>
 8004272:	4601      	mov	r1, r0
 8004274:	b9d0      	cbnz	r0, 80042ac <pin_change+0x13c>
                                        required_digest, tmp, AE_SECRET_LEN)){
            goto ae_fail;
        }
        if(ae_encrypted_write32(KEYNUM_check_secret, 0, KEYNUM_main_pin, required_digest, check)){
 8004276:	9600      	str	r6, [sp, #0]
 8004278:	4643      	mov	r3, r8
 800427a:	2203      	movs	r2, #3
 800427c:	200a      	movs	r0, #10
 800427e:	f7ff f811 	bl	80032a4 <ae_encrypted_write32>
 8004282:	b998      	cbnz	r0, 80042ac <pin_change+0x13c>
            goto ae_fail;
        }

        // update the zero-secret flag to be correct.
        if(cf & CHANGE_SECRET) {
            if(check_all_zeros(args->secret, AE_SECRET_LEN)) {
 8004284:	4649      	mov	r1, r9
 8004286:	4638      	mov	r0, r7
 8004288:	f7fe f9e2 	bl	8002650 <check_all_zeros>
 800428c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800428e:	b110      	cbz	r0, 8004296 <pin_change+0x126>
                args->state_flags |= PA_ZERO_SECRET;
 8004290:	f043 0310 	orr.w	r3, r3, #16
 8004294:	e001      	b.n	800429a <pin_change+0x12a>
            } else {
                args->state_flags &= ~PA_ZERO_SECRET;
 8004296:	f023 0310 	bic.w	r3, r3, #16
 800429a:	63e3      	str	r3, [r4, #60]	; 0x3c
            }
        }
    }

    ae_reset_chip();
 800429c:	f7fe fb76 	bl	800298c <ae_reset_chip>
// Provide our "signature" validating struct contents as coming from us.
//
    static void
_sign_attempt(pinAttempt_t *args)
{
    _hmac_attempt(args, args->hmac);
 80042a0:	f104 0144 	add.w	r1, r4, #68	; 0x44
 80042a4:	4620      	mov	r0, r4
 80042a6:	f7ff fb83 	bl	80039b0 <_hmac_attempt>
 80042aa:	e011      	b.n	80042d0 <pin_change+0x160>
    _sign_attempt(args);

    return 0;

ae_fail:
    ae_reset_chip();
 80042ac:	f7fe fb6e 	bl	800298c <ae_reset_chip>

    return EPIN_AE_FAIL;
 80042b0:	f06f 0569 	mvn.w	r5, #105	; 0x69
 80042b4:	e00c      	b.n	80042d0 <pin_change+0x160>
 80042b6:	4605      	mov	r5, r0
 80042b8:	e00a      	b.n	80042d0 <pin_change+0x160>
    int rv = _validate_attempt(args, false);
    if(rv) return rv;

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
        // must come here with a successful PIN login (so it's rate limited nicely)
        return EPIN_WRONG_SUCCESS;
 80042ba:	f06f 056c 	mvn.w	r5, #108	; 0x6c
 80042be:	e007      	b.n	80042d0 <pin_change+0x160>
        // obsolete secondary support, can't support.
        return EPIN_BAD_REQUEST;
    }
    if(cf & (CHANGE_DURESS_PIN | CHANGE_DURESS_SECRET | CHANGE_BRICKME_PIN)) {
        // we need some new API for trick PIN lookup/changes. 
        return EPIN_BAD_REQUEST;
 80042c0:	f06f 0567 	mvn.w	r5, #103	; 0x67
 80042c4:	e004      	b.n	80042d0 <pin_change+0x160>
        return EPIN_WRONG_SUCCESS;
    }

    if(args->state_flags & PA_IS_BLANK) {
        // if blank, must provide blank value
        if(args->pin_len) return EPIN_RANGE_ERR;
 80042c6:	f06f 0566 	mvn.w	r5, #102	; 0x66
 80042ca:	e001      	b.n	80042d0 <pin_change+0x160>
        // NOT-REACHED
        return EPIN_BAD_REQUEST;
    }

    // unlock the AE chip
    if(warmup_ae()) return EPIN_I_AM_BRICK;
 80042cc:	f06f 0568 	mvn.w	r5, #104	; 0x68

ae_fail:
    ae_reset_chip();

    return EPIN_AE_FAIL;
}
 80042d0:	4628      	mov	r0, r5
 80042d2:	b02e      	add	sp, #184	; 0xb8
 80042d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80042d8:	0800d558 	.word	0x0800d558
 80042dc:	0801e000 	.word	0x0801e000
 80042e0:	0800e47c 	.word	0x0800e47c

080042e4 <pin_fetch_secret>:
// To encourage not keeping the secret in memory, a way to fetch it after you've already
// proven you know the PIN.
//
    int
pin_fetch_secret(pinAttempt_t *args)
{
 80042e4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    // Validate args and signature
    int rv = _validate_attempt(args, false);
 80042e8:	2100      	movs	r1, #0
// To encourage not keeping the secret in memory, a way to fetch it after you've already
// proven you know the PIN.
//
    int
pin_fetch_secret(pinAttempt_t *args)
{
 80042ea:	f5ad 7d36 	sub.w	sp, sp, #728	; 0x2d8
 80042ee:	4604      	mov	r4, r0
    // Validate args and signature
    int rv = _validate_attempt(args, false);
 80042f0:	f7ff fb90 	bl	8003a14 <_validate_attempt>
    if(rv) return rv;
 80042f4:	2800      	cmp	r0, #0
 80042f6:	f040 8091 	bne.w	800441c <pin_fetch_secret+0x138>

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
 80042fa:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80042fc:	07db      	lsls	r3, r3, #31
 80042fe:	f140 808f 	bpl.w	8004420 <pin_fetch_secret+0x13c>
        // must come here with a successful PIN login (so it's rate limited nicely)
        return EPIN_WRONG_SUCCESS;
    }
    if(args->change_flags & CHANGE_DURESS_SECRET) {
 8004302:	6e65      	ldr	r5, [r4, #100]	; 0x64
 8004304:	f015 0510 	ands.w	r5, r5, #16
 8004308:	f040 808d 	bne.w	8004426 <pin_fetch_secret+0x142>

    // fetch the already-hashed pin
    // - no real need to re-prove PIN knowledge.
    // - if they tricked us, doesn't matter as below the SE validates it all again
    uint8_t     digest[32];
    pin_cache_restore(args, digest);
 800430c:	f10d 0814 	add.w	r8, sp, #20
 8004310:	4641      	mov	r1, r8
 8004312:	4620      	mov	r0, r4
 8004314:	f7ff fd42 	bl	8003d9c <pin_cache_restore>
    static bool
get_is_trick(const pinAttempt_t *args, trick_slot_t *slot)
{
    // read and "decrypt" our one flag bit
    // - optional: aes-decrypt some more details about the trick slot
    bool is_trick = ((args->private_state ^ rom_secrets->hash_cache_secret[0]) & 0x1);
 8004318:	4b5c      	ldr	r3, [pc, #368]	; (800448c <pin_fetch_secret+0x1a8>)
 800431a:	f893 2070 	ldrb.w	r2, [r3, #112]	; 0x70
 800431e:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8004320:	4053      	eors	r3, r2

    if(!slot || !is_trick) return is_trick;
 8004322:	07df      	lsls	r7, r3, #31
 8004324:	d537      	bpl.n	8004396 <pin_fetch_secret+0xb2>

    memset(slot, 0, sizeof(trick_slot_t));
 8004326:	2280      	movs	r2, #128	; 0x80
 8004328:	4629      	mov	r1, r5
 800432a:	a815      	add	r0, sp, #84	; 0x54
 800432c:	f009 f8cf 	bl	800d4ce <memset>

    if(args->delay_required & TC_DELTA_MODE) {
 8004330:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8004332:	055e      	lsls	r6, r3, #21
 8004334:	d505      	bpl.n	8004342 <pin_fetch_secret+0x5e>
        // in delta mode, we are using the cached_main_pin for real PIN (hashed)
        // so we cannot restore details
        slot->tc_flags = args->delay_required;
 8004336:	f8ad 3058 	strh.w	r3, [sp, #88]	; 0x58
        slot->tc_arg = 0;           // unknown
        slot->slot_num = -1;        // unknown
 800433a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800433e:	9315      	str	r3, [sp, #84]	; 0x54
 8004340:	e022      	b.n	8004388 <pin_fetch_secret+0xa4>
//
    static void
_make_trick_aes_key(const pinAttempt_t *args, uint8_t key[32])
{
    // key is args->private_state (4 bytes) + 28 bytes from hash_cache_secret
    memcpy(key, &args->private_state, sizeof(args->private_state));
 8004342:	6c20      	ldr	r0, [r4, #64]	; 0x40
    memcpy(key+4, rom_secrets->hash_cache_secret+4, sizeof(rom_secrets->hash_cache_secret)-4);
 8004344:	4f52      	ldr	r7, [pc, #328]	; (8004490 <pin_fetch_secret+0x1ac>)
//
    static void
_make_trick_aes_key(const pinAttempt_t *args, uint8_t key[32])
{
    // key is args->private_state (4 bytes) + 28 bytes from hash_cache_secret
    memcpy(key, &args->private_state, sizeof(args->private_state));
 8004346:	900d      	str	r0, [sp, #52]	; 0x34
    memcpy(key+4, rom_secrets->hash_cache_secret+4, sizeof(rom_secrets->hash_cache_secret)-4);
 8004348:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 800434a:	ae0e      	add	r6, sp, #56	; 0x38
 800434c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 800434e:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
 8004352:	e886 0007 	stmia.w	r6, {r0, r1, r2}
        STATIC_ASSERT(offsetof(trick_slot_t, tc_arg) < 32);
        STATIC_ASSERT(sizeof(trick_slot_t) >= 32);

        // decode first 32 bytes of trick slot info into place
        AES_CTX ctx;
        aes_init(&ctx);
 8004356:	a835      	add	r0, sp, #212	; 0xd4
 8004358:	f003 ff3e 	bl	80081d8 <aes_init>
        aes_add(&ctx, args->cached_main_pin, 32);
 800435c:	2220      	movs	r2, #32
 800435e:	f104 01f8 	add.w	r1, r4, #248	; 0xf8
 8004362:	a835      	add	r0, sp, #212	; 0xd4
 8004364:	f003 ff3e 	bl	80081e4 <aes_add>
        aes_done(&ctx, (uint8_t *)slot, 32, key, NULL);
 8004368:	a915      	add	r1, sp, #84	; 0x54
 800436a:	9500      	str	r5, [sp, #0]
 800436c:	ab0d      	add	r3, sp, #52	; 0x34
 800436e:	2220      	movs	r2, #32
 8004370:	a835      	add	r0, sp, #212	; 0xd4
 8004372:	f003 ff4d 	bl	8008210 <aes_done>

        if(slot->tc_flags & (TC_WORD_WALLET|TC_XPRV_WALLET)) {
 8004376:	f8bd 1058 	ldrh.w	r1, [sp, #88]	; 0x58
 800437a:	f411 5fc0 	tst.w	r1, #6144	; 0x1800
 800437e:	d003      	beq.n	8004388 <pin_fetch_secret+0xa4>
            // read 1 or 2 data slots that immediately follow a trick PIN slot
            se2_read_trick_data(slot->slot_num, slot->tc_flags, slot->xdata);
 8004380:	aa17      	add	r2, sp, #92	; 0x5c
 8004382:	9815      	ldr	r0, [sp, #84]	; 0x54
 8004384:	f003 fc8c 	bl	8007ca0 <se2_read_trick_data>

    // determine if we should proceed under duress
    trick_slot_t slot;
    bool is_trick = get_is_trick(args, &slot);

    if(is_trick && !(slot.tc_flags & TC_DELTA_MODE)) {
 8004388:	f8bd 6058 	ldrh.w	r6, [sp, #88]	; 0x58
 800438c:	f406 6180 	and.w	r1, r6, #1024	; 0x400
 8004390:	b289      	uxth	r1, r1
 8004392:	2900      	cmp	r1, #0
 8004394:	d04d      	beq.n	8004432 <pin_fetch_secret+0x14e>
// Mk4 support additional secret storage: spares. Map to key number, or -1 if range error
//
    static int
keynum_for_secret(const pinAttempt_t *args)
{
    int which = (args->change_flags >> 8) & 0xf;
 8004396:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8004398:	f3c3 2303 	ubfx	r3, r3, #8, #4
 800439c:	2b03      	cmp	r3, #3
 800439e:	dc45      	bgt.n	800442c <pin_fetch_secret+0x148>
 80043a0:	4a3c      	ldr	r2, [pc, #240]	; (8004494 <pin_fetch_secret+0x1b0>)
 80043a2:	56d0      	ldrsb	r0, [r2, r3]
    uint8_t    tmp[AE_SECRET_LEN];
    uint8_t    check[32];

    // default, zero: main secret, otherwise, the spares.
    int kn = keynum_for_secret(args);
    if(kn < 0) return EPIN_RANGE_ERR;
 80043a4:	2800      	cmp	r0, #0
 80043a6:	db41      	blt.n	800442c <pin_fetch_secret+0x148>

    // read out the secret that corresponds to pin
    rv = ae_encrypted_read(kn, KEYNUM_main_pin, digest, tmp, AE_SECRET_LEN);
 80043a8:	2748      	movs	r7, #72	; 0x48
 80043aa:	9700      	str	r7, [sp, #0]
 80043ac:	ab35      	add	r3, sp, #212	; 0xd4
 80043ae:	4642      	mov	r2, r8
 80043b0:	2103      	movs	r1, #3
 80043b2:	f7fe ff3f 	bl	8003234 <ae_encrypted_read>
    if(rv) goto fail;
 80043b6:	4605      	mov	r5, r0
 80043b8:	bb40      	cbnz	r0, 800440c <pin_fetch_secret+0x128>
    rv = ae_encrypted_read32(KEYNUM_check_secret, 0, KEYNUM_main_pin, digest, check);
 80043ba:	ae0d      	add	r6, sp, #52	; 0x34
 80043bc:	4601      	mov	r1, r0
 80043be:	9600      	str	r6, [sp, #0]
 80043c0:	4643      	mov	r3, r8
 80043c2:	2203      	movs	r2, #3
 80043c4:	200a      	movs	r0, #10
 80043c6:	f7fe ff0a 	bl	80031de <ae_encrypted_read32>
    if(rv) goto fail;
 80043ca:	4605      	mov	r5, r0
 80043cc:	b9f0      	cbnz	r0, 800440c <pin_fetch_secret+0x128>

    // decrypt via a complex process.
    bool is_valid;
    se2_decrypt_secret(args->secret, AE_SECRET_LEN, 0, tmp, check, digest, &is_valid);
 80043ce:	f10d 0a13 	add.w	sl, sp, #19
 80043d2:	f104 09b0 	add.w	r9, r4, #176	; 0xb0
 80043d6:	ab35      	add	r3, sp, #212	; 0xd4
 80043d8:	4602      	mov	r2, r0
 80043da:	e88d 0540 	stmia.w	sp, {r6, r8, sl}
 80043de:	4639      	mov	r1, r7
 80043e0:	4648      	mov	r0, r9
 80043e2:	f003 fe93 	bl	800810c <se2_decrypt_secret>

    if(!is_valid) {
 80043e6:	f89a 3000 	ldrb.w	r3, [sl]
 80043ea:	b97b      	cbnz	r3, 800440c <pin_fetch_secret+0x128>
        // means the MCU key has been wiped; so effectively our secret is zeros
        // - also happens in case of any corruption with SE1/SE2 contents
        rv = 0;
        memset(args->secret, 0, AE_SECRET_LEN);
 80043ec:	463a      	mov	r2, r7
 80043ee:	4629      	mov	r1, r5
 80043f0:	4648      	mov	r0, r9
 80043f2:	f009 f86c 	bl	800d4ce <memset>

        if(!(args->state_flags & PA_ZERO_SECRET)) {
 80043f6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80043f8:	06da      	lsls	r2, r3, #27
 80043fa:	d407      	bmi.n	800440c <pin_fetch_secret+0x128>
            // we didn't know yet that we are blank, update that
            args->state_flags |= PA_ZERO_SECRET;
 80043fc:	f043 0310 	orr.w	r3, r3, #16
 8004400:	63e3      	str	r3, [r4, #60]	; 0x3c
// Provide our "signature" validating struct contents as coming from us.
//
    static void
_sign_attempt(pinAttempt_t *args)
{
    _hmac_attempt(args, args->hmac);
 8004402:	f104 0144 	add.w	r1, r4, #68	; 0x44
 8004406:	4620      	mov	r0, r4
 8004408:	f7ff fad2 	bl	80039b0 <_hmac_attempt>
            _sign_attempt(args);
        }
    }

fail:
    ae_reset_chip();
 800440c:	f7fe fabe 	bl	800298c <ae_reset_chip>

    if(rv) return EPIN_AE_FAIL;
 8004410:	2d00      	cmp	r5, #0
 8004412:	bf0c      	ite	eq
 8004414:	2500      	moveq	r5, #0
 8004416:	f06f 0569 	mvnne.w	r5, #105	; 0x69
 800441a:	e032      	b.n	8004482 <pin_fetch_secret+0x19e>
 800441c:	4605      	mov	r5, r0
 800441e:	e030      	b.n	8004482 <pin_fetch_secret+0x19e>
    int rv = _validate_attempt(args, false);
    if(rv) return rv;

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
        // must come here with a successful PIN login (so it's rate limited nicely)
        return EPIN_WRONG_SUCCESS;
 8004420:	f06f 056c 	mvn.w	r5, #108	; 0x6c
 8004424:	e02d      	b.n	8004482 <pin_fetch_secret+0x19e>
    }
    if(args->change_flags & CHANGE_DURESS_SECRET) {
        // obsolete API: reading the duress secret from main PIN code (was never used)
        return EPIN_BAD_REQUEST;
 8004426:	f06f 0567 	mvn.w	r5, #103	; 0x67
 800442a:	e02a      	b.n	8004482 <pin_fetch_secret+0x19e>
    uint8_t    tmp[AE_SECRET_LEN];
    uint8_t    check[32];

    // default, zero: main secret, otherwise, the spares.
    int kn = keynum_for_secret(args);
    if(kn < 0) return EPIN_RANGE_ERR;
 800442c:	f06f 0566 	mvn.w	r5, #102	; 0x66
 8004430:	e027      	b.n	8004482 <pin_fetch_secret+0x19e>
    bool is_trick = get_is_trick(args, &slot);

    if(is_trick && !(slot.tc_flags & TC_DELTA_MODE)) {
        // emulate a 24-word wallet, or xprv based wallet
        // see stash.py for encoding details
        memset(args->secret, 0, AE_SECRET_LEN);
 8004432:	2248      	movs	r2, #72	; 0x48
 8004434:	f104 00b0 	add.w	r0, r4, #176	; 0xb0
 8004438:	f009 f849 	bl	800d4ce <memset>

        if(slot.tc_flags & TC_WORD_WALLET) {
 800443c:	04f0      	lsls	r0, r6, #19
 800443e:	d50f      	bpl.n	8004460 <pin_fetch_secret+0x17c>
            args->secret[0] = 0x82;         // 24 word phrase
 8004440:	2382      	movs	r3, #130	; 0x82
 8004442:	f884 30b0 	strb.w	r3, [r4, #176]	; 0xb0
            memcpy(&args->secret[1], slot.xdata, 32);
 8004446:	aa17      	add	r2, sp, #92	; 0x5c
 8004448:	34b1      	adds	r4, #177	; 0xb1
 800444a:	ae1f      	add	r6, sp, #124	; 0x7c
 800444c:	4613      	mov	r3, r2
 800444e:	cb03      	ldmia	r3!, {r0, r1}
 8004450:	42b3      	cmp	r3, r6
 8004452:	6020      	str	r0, [r4, #0]
 8004454:	6061      	str	r1, [r4, #4]
 8004456:	461a      	mov	r2, r3
 8004458:	f104 0408 	add.w	r4, r4, #8
 800445c:	d1f6      	bne.n	800444c <pin_fetch_secret+0x168>
 800445e:	e010      	b.n	8004482 <pin_fetch_secret+0x19e>
        } else if(slot.tc_flags & TC_XPRV_WALLET) {
 8004460:	0531      	lsls	r1, r6, #20
 8004462:	d50e      	bpl.n	8004482 <pin_fetch_secret+0x19e>
            args->secret[0] = 0x01;         // XPRV mode
 8004464:	2301      	movs	r3, #1
 8004466:	f884 30b0 	strb.w	r3, [r4, #176]	; 0xb0
            memcpy(&args->secret[1], slot.xdata, 64);
 800446a:	aa17      	add	r2, sp, #92	; 0x5c
 800446c:	34b1      	adds	r4, #177	; 0xb1
 800446e:	ae27      	add	r6, sp, #156	; 0x9c
 8004470:	4613      	mov	r3, r2
 8004472:	cb03      	ldmia	r3!, {r0, r1}
 8004474:	42b3      	cmp	r3, r6
 8004476:	6020      	str	r0, [r4, #0]
 8004478:	6061      	str	r1, [r4, #4]
 800447a:	461a      	mov	r2, r3
 800447c:	f104 0408 	add.w	r4, r4, #8
 8004480:	d1f6      	bne.n	8004470 <pin_fetch_secret+0x18c>
    ae_reset_chip();

    if(rv) return EPIN_AE_FAIL;

    return 0;
}
 8004482:	4628      	mov	r0, r5
 8004484:	f50d 7d36 	add.w	sp, sp, #728	; 0x2d8
 8004488:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800448c:	0801e000 	.word	0x0801e000
 8004490:	0801e074 	.word	0x0801e074
 8004494:	0800e47c 	.word	0x0800e47c

08004498 <pin_long_secret>:
// - new API so whole thing provided in one shot? encryption issues: provide
//   "dest" and all 416 bytes end up there (read case only).
//
    int
pin_long_secret(pinAttempt_t *args, uint8_t *dest)
{
 8004498:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800449c:	460e      	mov	r6, r1
 800449e:	b097      	sub	sp, #92	; 0x5c
    // Validate args and signature
    int rv = _validate_attempt(args, false);
 80044a0:	2100      	movs	r1, #0
// - new API so whole thing provided in one shot? encryption issues: provide
//   "dest" and all 416 bytes end up there (read case only).
//
    int
pin_long_secret(pinAttempt_t *args, uint8_t *dest)
{
 80044a2:	4605      	mov	r5, r0
    // Validate args and signature
    int rv = _validate_attempt(args, false);
 80044a4:	f7ff fab6 	bl	8003a14 <_validate_attempt>
    if(rv) return rv;
 80044a8:	4604      	mov	r4, r0
 80044aa:	2800      	cmp	r0, #0
 80044ac:	f040 809f 	bne.w	80045ee <pin_long_secret+0x156>

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
 80044b0:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 80044b2:	07db      	lsls	r3, r3, #31
 80044b4:	f140 809d 	bpl.w	80045f2 <pin_long_secret+0x15a>
    static bool
get_is_trick(const pinAttempt_t *args, trick_slot_t *slot)
{
    // read and "decrypt" our one flag bit
    // - optional: aes-decrypt some more details about the trick slot
    bool is_trick = ((args->private_state ^ rom_secrets->hash_cache_secret[0]) & 0x1);
 80044b8:	4b53      	ldr	r3, [pc, #332]	; (8004608 <pin_long_secret+0x170>)
    }

    // determine if we should proceed under duress/in some trick way
    bool is_trick = get_is_trick(args, NULL);

    if(is_trick) {
 80044ba:	f893 9070 	ldrb.w	r9, [r3, #112]	; 0x70
 80044be:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 80044c0:	ea89 0903 	eor.w	r9, r9, r3
 80044c4:	f019 0901 	ands.w	r9, r9, #1
 80044c8:	d00f      	beq.n	80044ea <pin_long_secret+0x52>
        // Not supported in trick mode. Pretend it's all zeros. Accept all writes.
        memset(args->secret, 0, 32);
 80044ca:	4601      	mov	r1, r0
 80044cc:	2220      	movs	r2, #32
 80044ce:	f105 00b0 	add.w	r0, r5, #176	; 0xb0
 80044d2:	f008 fffc 	bl	800d4ce <memset>
        if(dest) memset(dest, 0, AE_LONG_SECRET_LEN);
 80044d6:	2e00      	cmp	r6, #0
 80044d8:	f000 8087 	beq.w	80045ea <pin_long_secret+0x152>
 80044dc:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
 80044e0:	4621      	mov	r1, r4
 80044e2:	4630      	mov	r0, r6
 80044e4:	f008 fff3 	bl	800d4ce <memset>
 80044e8:	e081      	b.n	80045ee <pin_long_secret+0x156>
        return 0;
    }

    // which 32-byte section?
    STATIC_ASSERT(CHANGE_LS_OFFSET == 0xf00);
    int blk = (args->change_flags >> 8) & 0xf;
 80044ea:	6e6f      	ldr	r7, [r5, #100]	; 0x64
 80044ec:	f3c7 2703 	ubfx	r7, r7, #8, #4
    if(blk > 13) return EPIN_RANGE_ERR;
 80044f0:	2f0d      	cmp	r7, #13
 80044f2:	f300 8081 	bgt.w	80045f8 <pin_long_secret+0x160>

    // fetch the already-hashed pin
    // - no real need to re-prove PIN knowledge.
    // - if they tricked us, doesn't matter as below the SE validates it all again
    uint8_t     digest[32];
    pin_cache_restore(args, digest);
 80044f6:	f10d 0818 	add.w	r8, sp, #24
 80044fa:	4641      	mov	r1, r8
 80044fc:	4628      	mov	r0, r5
 80044fe:	f7ff fc4d 	bl	8003d9c <pin_cache_restore>

    // read/write exactly 32 bytes
    if(!(args->change_flags & CHANGE_SECRET)) {
 8004502:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8004504:	f013 0308 	ands.w	r3, r3, #8
 8004508:	d14c      	bne.n	80045a4 <pin_long_secret+0x10c>
        if(!dest) {
 800450a:	b9f6      	cbnz	r6, 800454a <pin_long_secret+0xb2>
            uint8_t     tmp[32];

            rv = ae_encrypted_read32(KEYNUM_long_secret, blk, KEYNUM_main_pin, digest, tmp);
 800450c:	ae0e      	add	r6, sp, #56	; 0x38
 800450e:	9600      	str	r6, [sp, #0]
 8004510:	4643      	mov	r3, r8
 8004512:	2203      	movs	r2, #3
 8004514:	4639      	mov	r1, r7
 8004516:	2008      	movs	r0, #8
 8004518:	f7fe fe61 	bl	80031de <ae_encrypted_read32>
            if(rv) goto fail;
 800451c:	4604      	mov	r4, r0
 800451e:	2800      	cmp	r0, #0
 8004520:	d160      	bne.n	80045e4 <pin_long_secret+0x14c>

            bool is_valid;
            se2_decrypt_secret(args->secret, 32, blk*32, tmp, NULL, digest, &is_valid);
 8004522:	f10d 0317 	add.w	r3, sp, #23
 8004526:	35b0      	adds	r5, #176	; 0xb0
 8004528:	9302      	str	r3, [sp, #8]
 800452a:	e88d 0110 	stmia.w	sp, {r4, r8}
 800452e:	4633      	mov	r3, r6
 8004530:	017a      	lsls	r2, r7, #5
 8004532:	2120      	movs	r1, #32
 8004534:	4628      	mov	r0, r5
 8004536:	f003 fde9 	bl	800810c <se2_decrypt_secret>
            if(!is_valid) {
 800453a:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800453e:	2b00      	cmp	r3, #0
 8004540:	d150      	bne.n	80045e4 <pin_long_secret+0x14c>
                // no encryption key yet, so assume blank
                memset(args->secret, 0, 32);
 8004542:	2220      	movs	r2, #32
 8004544:	4621      	mov	r1, r4
 8004546:	4628      	mov	r0, r5
 8004548:	e029      	b.n	800459e <pin_long_secret+0x106>
 800454a:	4637      	mov	r7, r6
 800454c:	461d      	mov	r5, r3
                rv = 0;
            }
        } else {
            uint8_t *p = dest;
            for(blk=0; blk<13; blk++, p += 32) {
                rv = ae_encrypted_read32(KEYNUM_long_secret, blk, KEYNUM_main_pin, digest, p);
 800454e:	9700      	str	r7, [sp, #0]
 8004550:	4643      	mov	r3, r8
 8004552:	2203      	movs	r2, #3
 8004554:	4629      	mov	r1, r5
 8004556:	2008      	movs	r0, #8
 8004558:	f7fe fe41 	bl	80031de <ae_encrypted_read32>
                if(rv) goto fail;
 800455c:	4604      	mov	r4, r0
 800455e:	2800      	cmp	r0, #0
 8004560:	d140      	bne.n	80045e4 <pin_long_secret+0x14c>
                memset(args->secret, 0, 32);
                rv = 0;
            }
        } else {
            uint8_t *p = dest;
            for(blk=0; blk<13; blk++, p += 32) {
 8004562:	3501      	adds	r5, #1
 8004564:	2d0d      	cmp	r5, #13
 8004566:	f107 0720 	add.w	r7, r7, #32
 800456a:	d1f0      	bne.n	800454e <pin_long_secret+0xb6>
                rv = ae_encrypted_read32(KEYNUM_long_secret, blk, KEYNUM_main_pin, digest, p);
                if(rv) goto fail;
            }
            ASSERT(p == dest+AE_LONG_SECRET_LEN);
 800456c:	f506 73d0 	add.w	r3, r6, #416	; 0x1a0
 8004570:	429f      	cmp	r7, r3
 8004572:	d002      	beq.n	800457a <pin_long_secret+0xe2>
 8004574:	4825      	ldr	r0, [pc, #148]	; (800460c <pin_long_secret+0x174>)
 8004576:	f7fc fa31 	bl	80009dc <fatal_error>

            // decrypt in one step (big time savings here)
            bool is_valid;
            se2_decrypt_secret(dest, AE_LONG_SECRET_LEN, 0, dest, NULL, digest, &is_valid);
 800457a:	ab0e      	add	r3, sp, #56	; 0x38
 800457c:	9302      	str	r3, [sp, #8]
 800457e:	4602      	mov	r2, r0
 8004580:	4633      	mov	r3, r6
 8004582:	e88d 0110 	stmia.w	sp, {r4, r8}
 8004586:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 800458a:	4630      	mov	r0, r6
 800458c:	f003 fdbe 	bl	800810c <se2_decrypt_secret>
            if(!is_valid) {
 8004590:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
 8004594:	bb33      	cbnz	r3, 80045e4 <pin_long_secret+0x14c>
                // no encryption key yet, so assume blank
                memset(dest, 0, AE_LONG_SECRET_LEN);
 8004596:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
 800459a:	4621      	mov	r1, r4
 800459c:	4630      	mov	r0, r6
 800459e:	f008 ff96 	bl	800d4ce <memset>
 80045a2:	e01f      	b.n	80045e4 <pin_long_secret+0x14c>
                rv = 0;
            }
        }
    } else {
        // write case, does not update check
        uint8_t tmp[32] = {0};
 80045a4:	ac0e      	add	r4, sp, #56	; 0x38
 80045a6:	2220      	movs	r2, #32
 80045a8:	4649      	mov	r1, r9
 80045aa:	4620      	mov	r0, r4
 80045ac:	f008 ff8f 	bl	800d4ce <memset>

        if(se2_encrypt_secret(args->secret, 32, blk*32, tmp, NULL, digest)) {
 80045b0:	f8cd 8004 	str.w	r8, [sp, #4]
 80045b4:	f8cd 9000 	str.w	r9, [sp]
 80045b8:	4623      	mov	r3, r4
 80045ba:	017a      	lsls	r2, r7, #5
 80045bc:	2120      	movs	r1, #32
 80045be:	f105 00b0 	add.w	r0, r5, #176	; 0xb0
 80045c2:	f003 fd53 	bl	800806c <se2_encrypt_secret>
 80045c6:	b940      	cbnz	r0, 80045da <pin_long_secret+0x142>
            // can happen if secret not set yet, can't work since we can't
            // write the check value.
            goto se2_fail;
        }

        rv = ae_encrypted_write32(KEYNUM_long_secret, blk, KEYNUM_main_pin, digest, tmp);
 80045c8:	9400      	str	r4, [sp, #0]
 80045ca:	4643      	mov	r3, r8
 80045cc:	2203      	movs	r2, #3
 80045ce:	4639      	mov	r1, r7
 80045d0:	2008      	movs	r0, #8
 80045d2:	f7fe fe67 	bl	80032a4 <ae_encrypted_write32>
 80045d6:	4604      	mov	r4, r0
 80045d8:	e004      	b.n	80045e4 <pin_long_secret+0x14c>
    if(rv) return EPIN_AE_FAIL;

    return 0;

se2_fail:
    ae_reset_chip();
 80045da:	f7fe f9d7 	bl	800298c <ae_reset_chip>

    return EPIN_SE2_FAIL;
 80045de:	f06f 0072 	mvn.w	r0, #114	; 0x72
 80045e2:	e00e      	b.n	8004602 <pin_long_secret+0x16a>

        rv = ae_encrypted_write32(KEYNUM_long_secret, blk, KEYNUM_main_pin, digest, tmp);
    }

fail:
    ae_reset_chip();
 80045e4:	f7fe f9d2 	bl	800298c <ae_reset_chip>

    if(rv) return EPIN_AE_FAIL;
 80045e8:	b94c      	cbnz	r4, 80045fe <pin_long_secret+0x166>

    return 0;
 80045ea:	2000      	movs	r0, #0
 80045ec:	e009      	b.n	8004602 <pin_long_secret+0x16a>
 80045ee:	4620      	mov	r0, r4
 80045f0:	e007      	b.n	8004602 <pin_long_secret+0x16a>
    int rv = _validate_attempt(args, false);
    if(rv) return rv;

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
        // must come here with a successful PIN login (so it's rate limited nicely)
        return EPIN_WRONG_SUCCESS;
 80045f2:	f06f 006c 	mvn.w	r0, #108	; 0x6c
 80045f6:	e004      	b.n	8004602 <pin_long_secret+0x16a>
    }

    // which 32-byte section?
    STATIC_ASSERT(CHANGE_LS_OFFSET == 0xf00);
    int blk = (args->change_flags >> 8) & 0xf;
    if(blk > 13) return EPIN_RANGE_ERR;
 80045f8:	f06f 0066 	mvn.w	r0, #102	; 0x66
 80045fc:	e001      	b.n	8004602 <pin_long_secret+0x16a>
    }

fail:
    ae_reset_chip();

    if(rv) return EPIN_AE_FAIL;
 80045fe:	f06f 0069 	mvn.w	r0, #105	; 0x69

se2_fail:
    ae_reset_chip();

    return EPIN_SE2_FAIL;
}
 8004602:	b017      	add	sp, #92	; 0x5c
 8004604:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8004608:	0801e000 	.word	0x0801e000
 800460c:	0800d558 	.word	0x0800d558

08004610 <pin_firmware_greenlight>:
//
// Record current flash checksum and make green light go on.
//
    int
pin_firmware_greenlight(pinAttempt_t *args)
{
 8004610:	b530      	push	{r4, r5, lr}
    // Validate args and signature
    int rv = _validate_attempt(args, false);
 8004612:	2100      	movs	r1, #0
//
// Record current flash checksum and make green light go on.
//
    int
pin_firmware_greenlight(pinAttempt_t *args)
{
 8004614:	b09b      	sub	sp, #108	; 0x6c
 8004616:	4605      	mov	r5, r0
    // Validate args and signature
    int rv = _validate_attempt(args, false);
 8004618:	f7ff f9fc 	bl	8003a14 <_validate_attempt>
    if(rv) return rv;
 800461c:	bb58      	cbnz	r0, 8004676 <pin_firmware_greenlight+0x66>

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
 800461e:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8004620:	07da      	lsls	r2, r3, #31
 8004622:	d52a      	bpl.n	800467a <pin_firmware_greenlight+0x6a>
        // must come here with a successful PIN login (so it's rate limited nicely)
        return EPIN_WRONG_SUCCESS;
    }

    if(args->is_secondary) {
 8004624:	686c      	ldr	r4, [r5, #4]
 8004626:	bb5c      	cbnz	r4, 8004680 <pin_firmware_greenlight+0x70>
        return EPIN_PRIMARY_ONLY;
    }

    // load existing PIN's hash
    uint8_t     digest[32];
    pin_cache_restore(args, digest);
 8004628:	a902      	add	r1, sp, #8
 800462a:	4628      	mov	r0, r5
 800462c:	f7ff fbb6 	bl	8003d9c <pin_cache_restore>

    // step 1: calc the value to use
    uint8_t fw_check[32], world_check[32];
    checksum_flash(fw_check, world_check, 0);
 8004630:	4622      	mov	r2, r4
 8004632:	a912      	add	r1, sp, #72	; 0x48
 8004634:	a80a      	add	r0, sp, #40	; 0x28
 8004636:	f7fd fa1f 	bl	8001a78 <checksum_flash>

    // step 2: write it out to chip.
    if(warmup_ae()) return EPIN_I_AM_BRICK;
 800463a:	f7ff fa23 	bl	8003a84 <warmup_ae>
 800463e:	4604      	mov	r4, r0
 8004640:	bb08      	cbnz	r0, 8004686 <pin_firmware_greenlight+0x76>
    static bool
get_is_trick(const pinAttempt_t *args, trick_slot_t *slot)
{
    // read and "decrypt" our one flag bit
    // - optional: aes-decrypt some more details about the trick slot
    bool is_trick = ((args->private_state ^ rom_secrets->hash_cache_secret[0]) & 0x1);
 8004642:	4b13      	ldr	r3, [pc, #76]	; (8004690 <pin_firmware_greenlight+0x80>)

    // step 2: write it out to chip.
    if(warmup_ae()) return EPIN_I_AM_BRICK;

    // under duress, we can't fake this, but we go through the motions anyway
    if(!get_is_trick(args, NULL)) {
 8004644:	f893 2070 	ldrb.w	r2, [r3, #112]	; 0x70
 8004648:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 800464a:	4053      	eors	r3, r2
 800464c:	07db      	lsls	r3, r3, #31
 800464e:	d40d      	bmi.n	800466c <pin_firmware_greenlight+0x5c>
        rv = ae_encrypted_write(KEYNUM_firmware, KEYNUM_main_pin, digest, world_check, 32);
 8004650:	2320      	movs	r3, #32
 8004652:	9300      	str	r3, [sp, #0]
 8004654:	aa02      	add	r2, sp, #8
 8004656:	ab12      	add	r3, sp, #72	; 0x48
 8004658:	2103      	movs	r1, #3
 800465a:	200e      	movs	r0, #14
 800465c:	f7fe fe8a 	bl	8003374 <ae_encrypted_write>

        if(rv) {
 8004660:	b120      	cbz	r0, 800466c <pin_firmware_greenlight+0x5c>
            ae_reset_chip();
 8004662:	f7fe f993 	bl	800298c <ae_reset_chip>

            return EPIN_AE_FAIL;
 8004666:	f06f 0469 	mvn.w	r4, #105	; 0x69
 800466a:	e00e      	b.n	800468a <pin_firmware_greenlight+0x7a>
        }
    }

    // turn on light
    rv = ae_set_gpio_secure(world_check);
 800466c:	a812      	add	r0, sp, #72	; 0x48
 800466e:	f7fe ff0e 	bl	800348e <ae_set_gpio_secure>
    if(rv) {
 8004672:	b150      	cbz	r0, 800468a <pin_firmware_greenlight+0x7a>
 8004674:	e7f5      	b.n	8004662 <pin_firmware_greenlight+0x52>
 8004676:	4604      	mov	r4, r0
 8004678:	e007      	b.n	800468a <pin_firmware_greenlight+0x7a>
    int rv = _validate_attempt(args, false);
    if(rv) return rv;

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
        // must come here with a successful PIN login (so it's rate limited nicely)
        return EPIN_WRONG_SUCCESS;
 800467a:	f06f 046c 	mvn.w	r4, #108	; 0x6c
 800467e:	e004      	b.n	800468a <pin_firmware_greenlight+0x7a>
    }

    if(args->is_secondary) {
        // only main PIN holder can do this
        return EPIN_PRIMARY_ONLY;
 8004680:	f06f 0471 	mvn.w	r4, #113	; 0x71
 8004684:	e001      	b.n	800468a <pin_firmware_greenlight+0x7a>
    // step 1: calc the value to use
    uint8_t fw_check[32], world_check[32];
    checksum_flash(fw_check, world_check, 0);

    // step 2: write it out to chip.
    if(warmup_ae()) return EPIN_I_AM_BRICK;
 8004686:	f06f 0468 	mvn.w	r4, #104	; 0x68

        return EPIN_AE_FAIL;
    }

    return 0;
}
 800468a:	4620      	mov	r0, r4
 800468c:	b01b      	add	sp, #108	; 0x6c
 800468e:	bd30      	pop	{r4, r5, pc}
 8004690:	0801e000 	.word	0x0801e000

08004694 <pin_firmware_upgrade>:
// Update the system firmware via file in PSRAM. Arrange for 
// light to stay green through out process.
//
    int
pin_firmware_upgrade(pinAttempt_t *args)
{
 8004694:	b570      	push	{r4, r5, r6, lr}
    // Validate args and signature
    int rv = _validate_attempt(args, false);
 8004696:	2100      	movs	r1, #0
// Update the system firmware via file in PSRAM. Arrange for 
// light to stay green through out process.
//
    int
pin_firmware_upgrade(pinAttempt_t *args)
{
 8004698:	b092      	sub	sp, #72	; 0x48
 800469a:	4604      	mov	r4, r0
    // Validate args and signature
    int rv = _validate_attempt(args, false);
 800469c:	f7ff f9ba 	bl	8003a14 <_validate_attempt>
    if(rv) return rv;
 80046a0:	2800      	cmp	r0, #0
 80046a2:	d15d      	bne.n	8004760 <pin_firmware_upgrade+0xcc>

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
 80046a4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80046a6:	07da      	lsls	r2, r3, #31
 80046a8:	d54c      	bpl.n	8004744 <pin_firmware_upgrade+0xb0>
        // must come here with a successful PIN login
        return EPIN_WRONG_SUCCESS;
    }

    if(args->change_flags != CHANGE_FIRMWARE) {
 80046aa:	6e63      	ldr	r3, [r4, #100]	; 0x64
 80046ac:	2b40      	cmp	r3, #64	; 0x40
 80046ae:	d14c      	bne.n	800474a <pin_firmware_upgrade+0xb6>
    }

    // expecting start/length relative to psram start
    uint32_t *about = (uint32_t *)args->secret;
    uint32_t start = about[0];
    uint32_t len = about[1];
 80046b0:	f8d4 60b4 	ldr.w	r6, [r4, #180]	; 0xb4
        return EPIN_BAD_REQUEST;
    }

    // expecting start/length relative to psram start
    uint32_t *about = (uint32_t *)args->secret;
    uint32_t start = about[0];
 80046b4:	f8d4 50b0 	ldr.w	r5, [r4, #176]	; 0xb0
    uint32_t len = about[1];

    if(len < 32768) return EPIN_RANGE_ERR;
 80046b8:	f5a6 4300 	sub.w	r3, r6, #32768	; 0x8000
 80046bc:	f5b3 1ffc 	cmp.w	r3, #2064384	; 0x1f8000
 80046c0:	d846      	bhi.n	8004750 <pin_firmware_upgrade+0xbc>
    if(len > 2<<20) return EPIN_RANGE_ERR;
    if(start+len > PSRAM_SIZE) return EPIN_RANGE_ERR;
 80046c2:	19ab      	adds	r3, r5, r6
 80046c4:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 80046c8:	d842      	bhi.n	8004750 <pin_firmware_upgrade+0xbc>

    const uint8_t *data = (const uint8_t *)PSRAM_BASE+start;
 80046ca:	f105 4510 	add.w	r5, r5, #2415919104	; 0x90000000

    // verify a firmware image that's in RAM, and calc its digest
    // - also applies watermark policy, etc
    uint8_t world_check[32];
    bool ok = verify_firmware_in_ram(data, len, world_check);
 80046ce:	aa02      	add	r2, sp, #8
 80046d0:	4631      	mov	r1, r6
 80046d2:	4628      	mov	r0, r5
 80046d4:	f7fd fae0 	bl	8001c98 <verify_firmware_in_ram>
    if(!ok) {
 80046d8:	2800      	cmp	r0, #0
 80046da:	d03c      	beq.n	8004756 <pin_firmware_upgrade+0xc2>
    static bool
get_is_trick(const pinAttempt_t *args, trick_slot_t *slot)
{
    // read and "decrypt" our one flag bit
    // - optional: aes-decrypt some more details about the trick slot
    bool is_trick = ((args->private_state ^ rom_secrets->hash_cache_secret[0]) & 0x1);
 80046dc:	4b21      	ldr	r3, [pc, #132]	; (8004764 <pin_firmware_upgrade+0xd0>)
    if(!ok) {
        return EPIN_AUTH_FAIL;
    }

    // under duress, we can't fake this, so kill ourselves.
    if(get_is_trick(args, NULL)) {
 80046de:	f893 2070 	ldrb.w	r2, [r3, #112]	; 0x70
 80046e2:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80046e4:	4053      	eors	r3, r2
 80046e6:	07db      	lsls	r3, r3, #31
 80046e8:	d502      	bpl.n	80046f0 <pin_firmware_upgrade+0x5c>
        // User is a thug.. kill secret and reboot w/o any notice
        fast_wipe();
 80046ea:	f7fd ff87 	bl	80025fc <fast_wipe>
 80046ee:	e02c      	b.n	800474a <pin_firmware_upgrade+0xb6>
        return EPIN_BAD_REQUEST;
    }

    // load existing PIN's hash
    uint8_t     digest[32];
    pin_cache_restore(args, digest);
 80046f0:	a90a      	add	r1, sp, #40	; 0x28
 80046f2:	4620      	mov	r0, r4
 80046f4:	f7ff fb52 	bl	8003d9c <pin_cache_restore>

    // step 1: calc the value to use, see above
    if(warmup_ae()) return EPIN_I_AM_BRICK;
 80046f8:	f7ff f9c4 	bl	8003a84 <warmup_ae>
 80046fc:	bb70      	cbnz	r0, 800475c <pin_firmware_upgrade+0xc8>

    // step 2: write it out to chip.
    rv = ae_encrypted_write(KEYNUM_firmware, KEYNUM_main_pin, digest, world_check, 32);
 80046fe:	2320      	movs	r3, #32
 8004700:	9300      	str	r3, [sp, #0]
 8004702:	aa0a      	add	r2, sp, #40	; 0x28
 8004704:	ab02      	add	r3, sp, #8
 8004706:	2103      	movs	r1, #3
 8004708:	200e      	movs	r0, #14
 800470a:	f7fe fe33 	bl	8003374 <ae_encrypted_write>
    if(rv) goto fail;
 800470e:	b9a0      	cbnz	r0, 800473a <pin_firmware_upgrade+0xa6>

    // turn on light? maybe not idk
    rv = ae_set_gpio_secure(world_check);
 8004710:	a802      	add	r0, sp, #8
 8004712:	f7fe febc 	bl	800348e <ae_set_gpio_secure>
    if(rv) goto fail;
 8004716:	b980      	cbnz	r0, 800473a <pin_firmware_upgrade+0xa6>

    // -- point of no return -- 

    // burn it, shows progress
    psram_do_upgrade(data, len);
 8004718:	4631      	mov	r1, r6
 800471a:	4628      	mov	r0, r5
 800471c:	f000 fc08 	bl	8004f30 <psram_do_upgrade>
 8004720:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8004724:	4910      	ldr	r1, [pc, #64]	; (8004768 <pin_firmware_upgrade+0xd4>)
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8004726:	4b11      	ldr	r3, [pc, #68]	; (800476c <pin_firmware_upgrade+0xd8>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8004728:	68ca      	ldr	r2, [r1, #12]
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800472a:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 800472e:	4313      	orrs	r3, r2
 8004730:	60cb      	str	r3, [r1, #12]
 8004732:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 8004736:	bf00      	nop
 8004738:	e7fd      	b.n	8004736 <pin_firmware_upgrade+0xa2>
    NVIC_SystemReset();

    return 0;

fail:
    ae_reset_chip();
 800473a:	f7fe f927 	bl	800298c <ae_reset_chip>

    return EPIN_AE_FAIL;
 800473e:	f06f 0069 	mvn.w	r0, #105	; 0x69
 8004742:	e00d      	b.n	8004760 <pin_firmware_upgrade+0xcc>
    int rv = _validate_attempt(args, false);
    if(rv) return rv;

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
        // must come here with a successful PIN login
        return EPIN_WRONG_SUCCESS;
 8004744:	f06f 006c 	mvn.w	r0, #108	; 0x6c
 8004748:	e00a      	b.n	8004760 <pin_firmware_upgrade+0xcc>
    }

    if(args->change_flags != CHANGE_FIRMWARE) {
        return EPIN_BAD_REQUEST;
 800474a:	f06f 0067 	mvn.w	r0, #103	; 0x67
 800474e:	e007      	b.n	8004760 <pin_firmware_upgrade+0xcc>
    // expecting start/length relative to psram start
    uint32_t *about = (uint32_t *)args->secret;
    uint32_t start = about[0];
    uint32_t len = about[1];

    if(len < 32768) return EPIN_RANGE_ERR;
 8004750:	f06f 0066 	mvn.w	r0, #102	; 0x66
 8004754:	e004      	b.n	8004760 <pin_firmware_upgrade+0xcc>
    // verify a firmware image that's in RAM, and calc its digest
    // - also applies watermark policy, etc
    uint8_t world_check[32];
    bool ok = verify_firmware_in_ram(data, len, world_check);
    if(!ok) {
        return EPIN_AUTH_FAIL;
 8004756:	f06f 006f 	mvn.w	r0, #111	; 0x6f
 800475a:	e001      	b.n	8004760 <pin_firmware_upgrade+0xcc>
    // load existing PIN's hash
    uint8_t     digest[32];
    pin_cache_restore(args, digest);

    // step 1: calc the value to use, see above
    if(warmup_ae()) return EPIN_I_AM_BRICK;
 800475c:	f06f 0068 	mvn.w	r0, #104	; 0x68

fail:
    ae_reset_chip();

    return EPIN_AE_FAIL;
}
 8004760:	b012      	add	sp, #72	; 0x48
 8004762:	bd70      	pop	{r4, r5, r6, pc}
 8004764:	0801e000 	.word	0x0801e000
 8004768:	e000ed00 	.word	0xe000ed00
 800476c:	05fa0004 	.word	0x05fa0004

08004770 <strcat_hex>:

// strcat_hex()
//
	void
strcat_hex(char *msg, const void *d, int len)
{
 8004770:	b570      	push	{r4, r5, r6, lr}
 8004772:	4605      	mov	r5, r0
 8004774:	4616      	mov	r6, r2
 8004776:	460c      	mov	r4, r1
	char *p = msg+strlen(msg);
 8004778:	f008 fed5 	bl	800d526 <strlen>
	const uint8_t *h = (const uint8_t *)d;

	for(; len; len--, h++) {
		*(p++) = hexmap[(*h>>4) & 0xf];
 800477c:	4a0c      	ldr	r2, [pc, #48]	; (80047b0 <strcat_hex+0x40>)
// strcat_hex()
//
	void
strcat_hex(char *msg, const void *d, int len)
{
	char *p = msg+strlen(msg);
 800477e:	4428      	add	r0, r5
 8004780:	4603      	mov	r3, r0
 8004782:	19a5      	adds	r5, r4, r6
	const uint8_t *h = (const uint8_t *)d;

	for(; len; len--, h++) {
 8004784:	42ac      	cmp	r4, r5
 8004786:	f103 0302 	add.w	r3, r3, #2
 800478a:	d00c      	beq.n	80047a6 <strcat_hex+0x36>
		*(p++) = hexmap[(*h>>4) & 0xf];
 800478c:	7821      	ldrb	r1, [r4, #0]
 800478e:	0909      	lsrs	r1, r1, #4
 8004790:	5c51      	ldrb	r1, [r2, r1]
 8004792:	f803 1c02 	strb.w	r1, [r3, #-2]
		*(p++) = hexmap[(*h>>0) & 0xf];
 8004796:	f814 1b01 	ldrb.w	r1, [r4], #1
 800479a:	f001 010f 	and.w	r1, r1, #15
 800479e:	5c51      	ldrb	r1, [r2, r1]
 80047a0:	f803 1c01 	strb.w	r1, [r3, #-1]
 80047a4:	e7ee      	b.n	8004784 <strcat_hex+0x14>
	}

	*(p++) = 0;
 80047a6:	2300      	movs	r3, #0
 80047a8:	f800 3016 	strb.w	r3, [r0, r6, lsl #1]
 80047ac:	bd70      	pop	{r4, r5, r6, pc}
 80047ae:	bf00      	nop
 80047b0:	0800e4ae 	.word	0x0800e4ae

080047b4 <HAL_USART_Init>:
  *         parameters in the USART_InitTypeDef and initialize the associated handle.
  * @param  husart USART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_USART_Init(USART_HandleTypeDef *husart)
{
 80047b4:	b538      	push	{r3, r4, r5, lr}
  /* Check the USART handle allocation */
  if (husart == NULL)
 80047b6:	4604      	mov	r4, r0
 80047b8:	b908      	cbnz	r0, 80047be <HAL_USART_Init+0xa>
  {
    return HAL_ERROR;
 80047ba:	2001      	movs	r0, #1
 80047bc:	bd38      	pop	{r3, r4, r5, pc}
  }

  /* Check the parameters */
  assert_param(IS_USART_INSTANCE(husart->Instance));

  if (husart->State == HAL_USART_STATE_RESET)
 80047be:	f890 3059 	ldrb.w	r3, [r0, #89]	; 0x59
 80047c2:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80047c6:	b90b      	cbnz	r3, 80047cc <HAL_USART_Init+0x18>
  {
    /* Allocate lock resource and initialize it */
    husart->Lock = HAL_UNLOCKED;
 80047c8:	f880 2058 	strb.w	r2, [r0, #88]	; 0x58
  }

  husart->State = HAL_USART_STATE_BUSY;

  /* Disable the Peripheral */
  __HAL_USART_DISABLE(husart);
 80047cc:	6822      	ldr	r2, [r4, #0]
  *  set the M bits according to husart->Init.WordLength value
  *  set PCE and PS bits according to husart->Init.Parity value
  *  set TE and RE bits according to husart->Init.Mode value
  *  force OVER8 to 1 to allow to reach the maximum speed (Fclock/8) */
  tmpreg = (uint32_t)husart->Init.WordLength | husart->Init.Parity | husart->Init.Mode | USART_CR1_OVER8;
  MODIFY_REG(husart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80047ce:	68a1      	ldr	r1, [r4, #8]
  {
    /* Allocate lock resource and initialize it */
    husart->Lock = HAL_UNLOCKED;
  }

  husart->State = HAL_USART_STATE_BUSY;
 80047d0:	2302      	movs	r3, #2
 80047d2:	f884 3059 	strb.w	r3, [r4, #89]	; 0x59

  /* Disable the Peripheral */
  __HAL_USART_DISABLE(husart);
 80047d6:	6813      	ldr	r3, [r2, #0]
 80047d8:	f023 0301 	bic.w	r3, r3, #1
 80047dc:	6013      	str	r3, [r2, #0]
  *  set the M bits according to husart->Init.WordLength value
  *  set PCE and PS bits according to husart->Init.Parity value
  *  set TE and RE bits according to husart->Init.Mode value
  *  force OVER8 to 1 to allow to reach the maximum speed (Fclock/8) */
  tmpreg = (uint32_t)husart->Init.WordLength | husart->Init.Parity | husart->Init.Mode | USART_CR1_OVER8;
  MODIFY_REG(husart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80047de:	6923      	ldr	r3, [r4, #16]
 80047e0:	6810      	ldr	r0, [r2, #0]
 80047e2:	430b      	orrs	r3, r1
 80047e4:	6961      	ldr	r1, [r4, #20]
 80047e6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80047ea:	4319      	orrs	r1, r3
 80047ec:	4b9d      	ldr	r3, [pc, #628]	; (8004a64 <HAL_USART_Init+0x2b0>)
 80047ee:	4003      	ands	r3, r0
 80047f0:	430b      	orrs	r3, r1
 80047f2:	6013      	str	r3, [r2, #0]
   * set CPHA bit according to husart->Init.CLKPhase value
   * set LBCL bit according to husart->Init.CLKLastBit value (used in SPI master mode only)
   * set STOP[13:12] bits according to husart->Init.StopBits value */
  tmpreg = (uint32_t)(USART_CLOCK_ENABLE);
  tmpreg |= (uint32_t)husart->Init.CLKLastBit;
  tmpreg |= ((uint32_t)husart->Init.CLKPolarity | (uint32_t)husart->Init.CLKPhase);
 80047f4:	6a21      	ldr	r1, [r4, #32]
 80047f6:	69a3      	ldr	r3, [r4, #24]
 80047f8:	69e0      	ldr	r0, [r4, #28]
 80047fa:	430b      	orrs	r3, r1
 80047fc:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  tmpreg |= (uint32_t)husart->Init.StopBits;
  MODIFY_REG(husart->Instance->CR2, USART_CR2_FIELDS, tmpreg);
 8004800:	6851      	ldr	r1, [r2, #4]
   * set CPHA bit according to husart->Init.CLKPhase value
   * set LBCL bit according to husart->Init.CLKLastBit value (used in SPI master mode only)
   * set STOP[13:12] bits according to husart->Init.StopBits value */
  tmpreg = (uint32_t)(USART_CLOCK_ENABLE);
  tmpreg |= (uint32_t)husart->Init.CLKLastBit;
  tmpreg |= ((uint32_t)husart->Init.CLKPolarity | (uint32_t)husart->Init.CLKPhase);
 8004802:	4303      	orrs	r3, r0
  tmpreg |= (uint32_t)husart->Init.StopBits;
  MODIFY_REG(husart->Instance->CR2, USART_CR2_FIELDS, tmpreg);
 8004804:	68e0      	ldr	r0, [r4, #12]
 8004806:	4318      	orrs	r0, r3
 8004808:	f421 537c 	bic.w	r3, r1, #16128	; 0x3f00
 800480c:	f023 0309 	bic.w	r3, r3, #9
 8004810:	4303      	orrs	r3, r0
 8004812:	6053      	str	r3, [r2, #4]

#if defined(USART_PRESC_PRESCALER)
  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
   * - USART Clock Prescaler : set PRESCALER according to husart->Init.ClockPrescaler value */
  MODIFY_REG(husart->Instance->PRESC, USART_PRESC_PRESCALER, husart->Init.ClockPrescaler);
 8004814:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 8004816:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004818:	f021 010f 	bic.w	r1, r1, #15
 800481c:	4319      	orrs	r1, r3
 800481e:	62d1      	str	r1, [r2, #44]	; 0x2c
#endif /* USART_PRESC_PRESCALER */

  /*-------------------------- USART BRR Configuration -----------------------*/
  /* BRR is filled-up according to OVER8 bit setting which is forced to 1     */
  USART_GETCLOCKSOURCE(husart, clocksource);
 8004820:	4991      	ldr	r1, [pc, #580]	; (8004a68 <HAL_USART_Init+0x2b4>)
 8004822:	428a      	cmp	r2, r1
 8004824:	d106      	bne.n	8004834 <HAL_USART_Init+0x80>
 8004826:	4a91      	ldr	r2, [pc, #580]	; (8004a6c <HAL_USART_Init+0x2b8>)
 8004828:	4991      	ldr	r1, [pc, #580]	; (8004a70 <HAL_USART_Init+0x2bc>)
 800482a:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 800482e:	f002 0203 	and.w	r2, r2, #3
 8004832:	e008      	b.n	8004846 <HAL_USART_Init+0x92>
 8004834:	498f      	ldr	r1, [pc, #572]	; (8004a74 <HAL_USART_Init+0x2c0>)
 8004836:	428a      	cmp	r2, r1
 8004838:	d110      	bne.n	800485c <HAL_USART_Init+0xa8>
 800483a:	4a8c      	ldr	r2, [pc, #560]	; (8004a6c <HAL_USART_Init+0x2b8>)
 800483c:	498e      	ldr	r1, [pc, #568]	; (8004a78 <HAL_USART_Init+0x2c4>)
 800483e:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 8004842:	f002 020c 	and.w	r2, r2, #12
 8004846:	5c8a      	ldrb	r2, [r1, r2]

  switch (clocksource)
 8004848:	2a08      	cmp	r2, #8
 800484a:	f200 80d5 	bhi.w	80049f8 <HAL_USART_Init+0x244>
 800484e:	e8df f002 	tbb	[pc, r2]
 8004852:	1b18      	.short	0x1b18
 8004854:	d354d31e 	.word	0xd354d31e
 8004858:	d3d3      	.short	0xd3d3
 800485a:	90          	.byte	0x90
 800485b:	00          	.byte	0x00
  MODIFY_REG(husart->Instance->PRESC, USART_PRESC_PRESCALER, husart->Init.ClockPrescaler);
#endif /* USART_PRESC_PRESCALER */

  /*-------------------------- USART BRR Configuration -----------------------*/
  /* BRR is filled-up according to OVER8 bit setting which is forced to 1     */
  USART_GETCLOCKSOURCE(husart, clocksource);
 800485c:	4987      	ldr	r1, [pc, #540]	; (8004a7c <HAL_USART_Init+0x2c8>)
 800485e:	428a      	cmp	r2, r1
 8004860:	f040 80ca 	bne.w	80049f8 <HAL_USART_Init+0x244>
 8004864:	4a81      	ldr	r2, [pc, #516]	; (8004a6c <HAL_USART_Init+0x2b8>)
 8004866:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 800486a:	f002 0230 	and.w	r2, r2, #48	; 0x30
 800486e:	2a10      	cmp	r2, #16
 8004870:	d043      	beq.n	80048fa <HAL_USART_Init+0x146>
 8004872:	d801      	bhi.n	8004878 <HAL_USART_Init+0xc4>
 8004874:	b12a      	cbz	r2, 8004882 <HAL_USART_Init+0xce>
 8004876:	e0bf      	b.n	80049f8 <HAL_USART_Init+0x244>
 8004878:	2a20      	cmp	r2, #32
 800487a:	d008      	beq.n	800488e <HAL_USART_Init+0xda>
 800487c:	2a30      	cmp	r2, #48	; 0x30
 800487e:	d078      	beq.n	8004972 <HAL_USART_Init+0x1be>
 8004880:	e0ba      	b.n	80049f8 <HAL_USART_Init+0x244>

  switch (clocksource)
  {
    case USART_CLOCKSOURCE_PCLK1:
      pclk = HAL_RCC_GetPCLK1Freq();
 8004882:	f004 fa6b 	bl	8008d5c <HAL_RCC_GetPCLK1Freq>
 8004886:	e03a      	b.n	80048fe <HAL_USART_Init+0x14a>
#else
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(pclk, husart->Init.BaudRate));
#endif /* USART_PRESC_PRESCALER */
      break;
    case USART_CLOCKSOURCE_PCLK2:
      pclk = HAL_RCC_GetPCLK2Freq();
 8004888:	f004 fa7a 	bl	8008d80 <HAL_RCC_GetPCLK2Freq>
 800488c:	e037      	b.n	80048fe <HAL_USART_Init+0x14a>
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(pclk, husart->Init.BaudRate));
#endif /* USART_PRESC_PRESCALER */
      break;
    case USART_CLOCKSOURCE_HSI:
#if defined(USART_PRESC_PRESCALER)
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(HSI_VALUE, husart->Init.BaudRate, husart->Init.ClockPrescaler));
 800488e:	b1cb      	cbz	r3, 80048c4 <HAL_USART_Init+0x110>
 8004890:	2b01      	cmp	r3, #1
 8004892:	d019      	beq.n	80048c8 <HAL_USART_Init+0x114>
 8004894:	2b02      	cmp	r3, #2
 8004896:	d019      	beq.n	80048cc <HAL_USART_Init+0x118>
 8004898:	2b03      	cmp	r3, #3
 800489a:	d019      	beq.n	80048d0 <HAL_USART_Init+0x11c>
 800489c:	2b04      	cmp	r3, #4
 800489e:	d019      	beq.n	80048d4 <HAL_USART_Init+0x120>
 80048a0:	2b05      	cmp	r3, #5
 80048a2:	d019      	beq.n	80048d8 <HAL_USART_Init+0x124>
 80048a4:	2b06      	cmp	r3, #6
 80048a6:	d019      	beq.n	80048dc <HAL_USART_Init+0x128>
 80048a8:	2b07      	cmp	r3, #7
 80048aa:	d019      	beq.n	80048e0 <HAL_USART_Init+0x12c>
 80048ac:	2b08      	cmp	r3, #8
 80048ae:	d019      	beq.n	80048e4 <HAL_USART_Init+0x130>
 80048b0:	2b09      	cmp	r3, #9
 80048b2:	d019      	beq.n	80048e8 <HAL_USART_Init+0x134>
 80048b4:	2b0a      	cmp	r3, #10
 80048b6:	d019      	beq.n	80048ec <HAL_USART_Init+0x138>
 80048b8:	4a71      	ldr	r2, [pc, #452]	; (8004a80 <HAL_USART_Init+0x2cc>)
 80048ba:	4972      	ldr	r1, [pc, #456]	; (8004a84 <HAL_USART_Init+0x2d0>)
 80048bc:	2b0b      	cmp	r3, #11
 80048be:	bf18      	it	ne
 80048c0:	460a      	movne	r2, r1
 80048c2:	e014      	b.n	80048ee <HAL_USART_Init+0x13a>
 80048c4:	4a6f      	ldr	r2, [pc, #444]	; (8004a84 <HAL_USART_Init+0x2d0>)
 80048c6:	e012      	b.n	80048ee <HAL_USART_Init+0x13a>
 80048c8:	4a6f      	ldr	r2, [pc, #444]	; (8004a88 <HAL_USART_Init+0x2d4>)
 80048ca:	e010      	b.n	80048ee <HAL_USART_Init+0x13a>
 80048cc:	4a6f      	ldr	r2, [pc, #444]	; (8004a8c <HAL_USART_Init+0x2d8>)
 80048ce:	e00e      	b.n	80048ee <HAL_USART_Init+0x13a>
 80048d0:	4a6f      	ldr	r2, [pc, #444]	; (8004a90 <HAL_USART_Init+0x2dc>)
 80048d2:	e00c      	b.n	80048ee <HAL_USART_Init+0x13a>
 80048d4:	4a6f      	ldr	r2, [pc, #444]	; (8004a94 <HAL_USART_Init+0x2e0>)
 80048d6:	e00a      	b.n	80048ee <HAL_USART_Init+0x13a>
 80048d8:	4a6f      	ldr	r2, [pc, #444]	; (8004a98 <HAL_USART_Init+0x2e4>)
 80048da:	e008      	b.n	80048ee <HAL_USART_Init+0x13a>
 80048dc:	4a6f      	ldr	r2, [pc, #444]	; (8004a9c <HAL_USART_Init+0x2e8>)
 80048de:	e006      	b.n	80048ee <HAL_USART_Init+0x13a>
 80048e0:	4a6f      	ldr	r2, [pc, #444]	; (8004aa0 <HAL_USART_Init+0x2ec>)
 80048e2:	e004      	b.n	80048ee <HAL_USART_Init+0x13a>
 80048e4:	4a6f      	ldr	r2, [pc, #444]	; (8004aa4 <HAL_USART_Init+0x2f0>)
 80048e6:	e002      	b.n	80048ee <HAL_USART_Init+0x13a>
 80048e8:	4a6f      	ldr	r2, [pc, #444]	; (8004aa8 <HAL_USART_Init+0x2f4>)
 80048ea:	e000      	b.n	80048ee <HAL_USART_Init+0x13a>
 80048ec:	4a6f      	ldr	r2, [pc, #444]	; (8004aac <HAL_USART_Init+0x2f8>)
 80048ee:	6863      	ldr	r3, [r4, #4]
 80048f0:	eb02 0253 	add.w	r2, r2, r3, lsr #1
 80048f4:	fbb2 f3f3 	udiv	r3, r2, r3
 80048f8:	e07c      	b.n	80049f4 <HAL_USART_Init+0x240>
#else
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(HSI_VALUE, husart->Init.BaudRate));
#endif /* USART_PRESC_PRESCALER */
      break;
    case USART_CLOCKSOURCE_SYSCLK:
      pclk = HAL_RCC_GetSysClockFreq();
 80048fa:	f003 fe1f 	bl	800853c <HAL_RCC_GetSysClockFreq>
#if defined(USART_PRESC_PRESCALER)
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(pclk, husart->Init.BaudRate, husart->Init.ClockPrescaler));
 80048fe:	6a65      	ldr	r5, [r4, #36]	; 0x24
 8004900:	b1cd      	cbz	r5, 8004936 <HAL_USART_Init+0x182>
 8004902:	2d01      	cmp	r5, #1
 8004904:	d019      	beq.n	800493a <HAL_USART_Init+0x186>
 8004906:	2d02      	cmp	r5, #2
 8004908:	d019      	beq.n	800493e <HAL_USART_Init+0x18a>
 800490a:	2d03      	cmp	r5, #3
 800490c:	d019      	beq.n	8004942 <HAL_USART_Init+0x18e>
 800490e:	2d04      	cmp	r5, #4
 8004910:	d019      	beq.n	8004946 <HAL_USART_Init+0x192>
 8004912:	2d05      	cmp	r5, #5
 8004914:	d019      	beq.n	800494a <HAL_USART_Init+0x196>
 8004916:	2d06      	cmp	r5, #6
 8004918:	d019      	beq.n	800494e <HAL_USART_Init+0x19a>
 800491a:	2d07      	cmp	r5, #7
 800491c:	d019      	beq.n	8004952 <HAL_USART_Init+0x19e>
 800491e:	2d08      	cmp	r5, #8
 8004920:	d019      	beq.n	8004956 <HAL_USART_Init+0x1a2>
 8004922:	2d09      	cmp	r5, #9
 8004924:	d019      	beq.n	800495a <HAL_USART_Init+0x1a6>
 8004926:	2d0a      	cmp	r5, #10
 8004928:	d019      	beq.n	800495e <HAL_USART_Init+0x1aa>
 800492a:	2d0b      	cmp	r5, #11
 800492c:	bf14      	ite	ne
 800492e:	2101      	movne	r1, #1
 8004930:	f44f 7180 	moveq.w	r1, #256	; 0x100
 8004934:	e014      	b.n	8004960 <HAL_USART_Init+0x1ac>
 8004936:	2101      	movs	r1, #1
 8004938:	e012      	b.n	8004960 <HAL_USART_Init+0x1ac>
 800493a:	2102      	movs	r1, #2
 800493c:	e010      	b.n	8004960 <HAL_USART_Init+0x1ac>
 800493e:	2104      	movs	r1, #4
 8004940:	e00e      	b.n	8004960 <HAL_USART_Init+0x1ac>
 8004942:	2106      	movs	r1, #6
 8004944:	e00c      	b.n	8004960 <HAL_USART_Init+0x1ac>
 8004946:	2108      	movs	r1, #8
 8004948:	e00a      	b.n	8004960 <HAL_USART_Init+0x1ac>
 800494a:	210a      	movs	r1, #10
 800494c:	e008      	b.n	8004960 <HAL_USART_Init+0x1ac>
 800494e:	210c      	movs	r1, #12
 8004950:	e006      	b.n	8004960 <HAL_USART_Init+0x1ac>
 8004952:	2110      	movs	r1, #16
 8004954:	e004      	b.n	8004960 <HAL_USART_Init+0x1ac>
 8004956:	2120      	movs	r1, #32
 8004958:	e002      	b.n	8004960 <HAL_USART_Init+0x1ac>
 800495a:	2140      	movs	r1, #64	; 0x40
 800495c:	e000      	b.n	8004960 <HAL_USART_Init+0x1ac>
 800495e:	2180      	movs	r1, #128	; 0x80
 8004960:	6863      	ldr	r3, [r4, #4]
 8004962:	fbb0 f0f1 	udiv	r0, r0, r1
 8004966:	0859      	lsrs	r1, r3, #1
 8004968:	eb01 0040 	add.w	r0, r1, r0, lsl #1
 800496c:	fbb0 f3f3 	udiv	r3, r0, r3
 8004970:	e040      	b.n	80049f4 <HAL_USART_Init+0x240>
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(pclk, husart->Init.BaudRate));
#endif /* USART_PRESC_PRESCALER */
      break;
    case USART_CLOCKSOURCE_LSE:
#if defined(USART_PRESC_PRESCALER)
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(LSE_VALUE, husart->Init.BaudRate, husart->Init.ClockPrescaler));
 8004972:	b1d3      	cbz	r3, 80049aa <HAL_USART_Init+0x1f6>
 8004974:	2b01      	cmp	r3, #1
 8004976:	d01b      	beq.n	80049b0 <HAL_USART_Init+0x1fc>
 8004978:	2b02      	cmp	r3, #2
 800497a:	d01c      	beq.n	80049b6 <HAL_USART_Init+0x202>
 800497c:	2b03      	cmp	r3, #3
 800497e:	d01d      	beq.n	80049bc <HAL_USART_Init+0x208>
 8004980:	2b04      	cmp	r3, #4
 8004982:	d01e      	beq.n	80049c2 <HAL_USART_Init+0x20e>
 8004984:	2b05      	cmp	r3, #5
 8004986:	d01f      	beq.n	80049c8 <HAL_USART_Init+0x214>
 8004988:	2b06      	cmp	r3, #6
 800498a:	d020      	beq.n	80049ce <HAL_USART_Init+0x21a>
 800498c:	2b07      	cmp	r3, #7
 800498e:	d021      	beq.n	80049d4 <HAL_USART_Init+0x220>
 8004990:	2b08      	cmp	r3, #8
 8004992:	d022      	beq.n	80049da <HAL_USART_Init+0x226>
 8004994:	2b09      	cmp	r3, #9
 8004996:	d023      	beq.n	80049e0 <HAL_USART_Init+0x22c>
 8004998:	2b0a      	cmp	r3, #10
 800499a:	d024      	beq.n	80049e6 <HAL_USART_Init+0x232>
 800499c:	2b0b      	cmp	r3, #11
 800499e:	bf14      	ite	ne
 80049a0:	f44f 3380 	movne.w	r3, #65536	; 0x10000
 80049a4:	f44f 7380 	moveq.w	r3, #256	; 0x100
 80049a8:	e01f      	b.n	80049ea <HAL_USART_Init+0x236>
 80049aa:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80049ae:	e01c      	b.n	80049ea <HAL_USART_Init+0x236>
 80049b0:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80049b4:	e019      	b.n	80049ea <HAL_USART_Init+0x236>
 80049b6:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80049ba:	e016      	b.n	80049ea <HAL_USART_Init+0x236>
 80049bc:	f642 23aa 	movw	r3, #10922	; 0x2aaa
 80049c0:	e013      	b.n	80049ea <HAL_USART_Init+0x236>
 80049c2:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80049c6:	e010      	b.n	80049ea <HAL_USART_Init+0x236>
 80049c8:	f641 1398 	movw	r3, #6552	; 0x1998
 80049cc:	e00d      	b.n	80049ea <HAL_USART_Init+0x236>
 80049ce:	f241 5354 	movw	r3, #5460	; 0x1554
 80049d2:	e00a      	b.n	80049ea <HAL_USART_Init+0x236>
 80049d4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80049d8:	e007      	b.n	80049ea <HAL_USART_Init+0x236>
 80049da:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80049de:	e004      	b.n	80049ea <HAL_USART_Init+0x236>
 80049e0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80049e4:	e001      	b.n	80049ea <HAL_USART_Init+0x236>
 80049e6:	f44f 7300 	mov.w	r3, #512	; 0x200
 80049ea:	6862      	ldr	r2, [r4, #4]
 80049ec:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 80049f0:	fbb3 f3f2 	udiv	r3, r3, r2
  */
static HAL_StatusTypeDef USART_SetConfig(USART_HandleTypeDef *husart)
{
  uint32_t tmpreg;
  USART_ClockSourceTypeDef clocksource;
  HAL_StatusTypeDef ret                = HAL_OK;
 80049f4:	2100      	movs	r1, #0
 80049f6:	e001      	b.n	80049fc <HAL_USART_Init+0x248>
  uint16_t brrtemp;
  uint32_t usartdiv                    = 0x00000000;
 80049f8:	2300      	movs	r3, #0
#else
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(LSE_VALUE, husart->Init.BaudRate));
#endif /* USART_PRESC_PRESCALER */
      break;
    default:
      ret = HAL_ERROR;
 80049fa:	2101      	movs	r1, #1
      break;
  }

  /* USARTDIV must be greater than or equal to 0d16 and smaller than or equal to ffff */
  if ((usartdiv >= USART_BRR_MIN) && (usartdiv <= USART_BRR_MAX))
 80049fc:	f1a3 0010 	sub.w	r0, r3, #16
 8004a00:	f64f 72ef 	movw	r2, #65519	; 0xffef
 8004a04:	4290      	cmp	r0, r2
  {
    brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8004a06:	bf9f      	itttt	ls
 8004a08:	f3c3 0242 	ubfxls	r2, r3, #1, #3
 8004a0c:	f023 030f 	bicls.w	r3, r3, #15
 8004a10:	4313      	orrls	r3, r2
 8004a12:	b29b      	uxthls	r3, r3
    husart->Instance->BRR = brrtemp;
 8004a14:	bf9d      	ittte	ls
 8004a16:	6822      	ldrls	r2, [r4, #0]
 8004a18:	b29b      	uxthls	r3, r3
 8004a1a:	60d3      	strls	r3, [r2, #12]
  }
  else
  {
    ret = HAL_ERROR;
 8004a1c:	2101      	movhi	r1, #1
  }

#if defined(USART_CR1_FIFOEN)
  /* Initialize the number of data to process during RX/TX ISR execution */
  husart->NbTxDataToProcess = 1U;
 8004a1e:	2301      	movs	r3, #1
  husart->NbRxDataToProcess = 1U;
#endif /* USART_CR1_FIFOEN */

  /* Clear ISR function pointers */
  husart->RxISR   = NULL;
 8004a20:	2200      	movs	r2, #0
    ret = HAL_ERROR;
  }

#if defined(USART_CR1_FIFOEN)
  /* Initialize the number of data to process during RX/TX ISR execution */
  husart->NbTxDataToProcess = 1U;
 8004a22:	87a3      	strh	r3, [r4, #60]	; 0x3c
  husart->NbRxDataToProcess = 1U;
 8004a24:	8763      	strh	r3, [r4, #58]	; 0x3a
#endif /* USART_CR1_FIFOEN */

  /* Clear ISR function pointers */
  husart->RxISR   = NULL;
 8004a26:	64a2      	str	r2, [r4, #72]	; 0x48
  husart->TxISR   = NULL;
 8004a28:	64e2      	str	r2, [r4, #76]	; 0x4c

  /* Disable the Peripheral */
  __HAL_USART_DISABLE(husart);

  /* Set the Usart Communication parameters */
  if (USART_SetConfig(husart) == HAL_ERROR)
 8004a2a:	2900      	cmp	r1, #0
 8004a2c:	f47f aec5 	bne.w	80047ba <HAL_USART_Init+0x6>
  }

  /* In Synchronous mode, the following bits must be kept cleared:
  - LINEN bit in the USART_CR2 register
  - HDSEL, SCEN and IREN bits in the USART_CR3 register.*/
  husart->Instance->CR2 &= ~USART_CR2_LINEN;
 8004a30:	6823      	ldr	r3, [r4, #0]
 8004a32:	6859      	ldr	r1, [r3, #4]
 8004a34:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
 8004a38:	6059      	str	r1, [r3, #4]
  husart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);
 8004a3a:	6899      	ldr	r1, [r3, #8]
 8004a3c:	f021 012a 	bic.w	r1, r1, #42	; 0x2a
 8004a40:	6099      	str	r1, [r3, #8]

  /* Enable the Peripheral */
  __HAL_USART_ENABLE(husart);
 8004a42:	6819      	ldr	r1, [r3, #0]
 8004a44:	f041 0101 	orr.w	r1, r1, #1
 8004a48:	6019      	str	r1, [r3, #0]
static HAL_StatusTypeDef USART_CheckIdleState(USART_HandleTypeDef *husart)
{
  uint32_t tickstart;

  /* Initialize the USART ErrorCode */
  husart->ErrorCode = HAL_USART_ERROR_NONE;
 8004a4a:	65e2      	str	r2, [r4, #92]	; 0x5c

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 8004a4c:	f002 fae2 	bl	8007014 <HAL_GetTick>

  /* Check if the Transmitter is enabled */
  if ((husart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8004a50:	6823      	ldr	r3, [r4, #0]
 8004a52:	681b      	ldr	r3, [r3, #0]
 8004a54:	071a      	lsls	r2, r3, #28

  /* Initialize the USART ErrorCode */
  husart->ErrorCode = HAL_USART_ERROR_NONE;

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 8004a56:	4605      	mov	r5, r0

  /* Check if the Transmitter is enabled */
  if ((husart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8004a58:	d430      	bmi.n	8004abc <HAL_USART_Init+0x308>
      /* Timeout occurred */
      return HAL_TIMEOUT;
    }
  }
  /* Check if the Receiver is enabled */
  if ((husart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8004a5a:	6823      	ldr	r3, [r4, #0]
 8004a5c:	681b      	ldr	r3, [r3, #0]
 8004a5e:	075b      	lsls	r3, r3, #29
 8004a60:	d53f      	bpl.n	8004ae2 <HAL_USART_Init+0x32e>
 8004a62:	e038      	b.n	8004ad6 <HAL_USART_Init+0x322>
 8004a64:	cfff69f3 	.word	0xcfff69f3
 8004a68:	40013800 	.word	0x40013800
 8004a6c:	40021000 	.word	0x40021000
 8004a70:	0800e4be 	.word	0x0800e4be
 8004a74:	40004400 	.word	0x40004400
 8004a78:	0800e4c2 	.word	0x0800e4c2
 8004a7c:	40004800 	.word	0x40004800
 8004a80:	0001e848 	.word	0x0001e848
 8004a84:	01e84800 	.word	0x01e84800
 8004a88:	00f42400 	.word	0x00f42400
 8004a8c:	007a1200 	.word	0x007a1200
 8004a90:	00516154 	.word	0x00516154
 8004a94:	003d0900 	.word	0x003d0900
 8004a98:	0030d400 	.word	0x0030d400
 8004a9c:	0028b0aa 	.word	0x0028b0aa
 8004aa0:	001e8480 	.word	0x001e8480
 8004aa4:	000f4240 	.word	0x000f4240
 8004aa8:	0007a120 	.word	0x0007a120
 8004aac:	0003d090 	.word	0x0003d090
  while ((__HAL_USART_GET_FLAG(husart, Flag) ? SET : RESET) == Status)
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8004ab0:	f002 fab0 	bl	8007014 <HAL_GetTick>
 8004ab4:	1b40      	subs	r0, r0, r5
 8004ab6:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8004aba:	d819      	bhi.n	8004af0 <HAL_USART_Init+0x33c>
  */
static HAL_StatusTypeDef USART_WaitOnFlagUntilTimeout(USART_HandleTypeDef *husart, uint32_t Flag, FlagStatus Status,
                                                      uint32_t Tickstart, uint32_t Timeout)
{
  /* Wait until flag is set */
  while ((__HAL_USART_GET_FLAG(husart, Flag) ? SET : RESET) == Status)
 8004abc:	6823      	ldr	r3, [r4, #0]
 8004abe:	69db      	ldr	r3, [r3, #28]
 8004ac0:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8004ac4:	2b00      	cmp	r3, #0
 8004ac6:	d0f3      	beq.n	8004ab0 <HAL_USART_Init+0x2fc>
 8004ac8:	e7c7      	b.n	8004a5a <HAL_USART_Init+0x2a6>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8004aca:	f002 faa3 	bl	8007014 <HAL_GetTick>
 8004ace:	1b40      	subs	r0, r0, r5
 8004ad0:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8004ad4:	d80c      	bhi.n	8004af0 <HAL_USART_Init+0x33c>
  */
static HAL_StatusTypeDef USART_WaitOnFlagUntilTimeout(USART_HandleTypeDef *husart, uint32_t Flag, FlagStatus Status,
                                                      uint32_t Tickstart, uint32_t Timeout)
{
  /* Wait until flag is set */
  while ((__HAL_USART_GET_FLAG(husart, Flag) ? SET : RESET) == Status)
 8004ad6:	6823      	ldr	r3, [r4, #0]
 8004ad8:	69db      	ldr	r3, [r3, #28]
 8004ada:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8004ade:	2b00      	cmp	r3, #0
 8004ae0:	d0f3      	beq.n	8004aca <HAL_USART_Init+0x316>
      return HAL_TIMEOUT;
    }
  }

  /* Initialize the USART state*/
  husart->State = HAL_USART_STATE_READY;
 8004ae2:	2301      	movs	r3, #1

  /* Process Unlocked */
  __HAL_UNLOCK(husart);
 8004ae4:	2000      	movs	r0, #0
      return HAL_TIMEOUT;
    }
  }

  /* Initialize the USART state*/
  husart->State = HAL_USART_STATE_READY;
 8004ae6:	f884 3059 	strb.w	r3, [r4, #89]	; 0x59

  /* Process Unlocked */
  __HAL_UNLOCK(husart);
 8004aea:	f884 0058 	strb.w	r0, [r4, #88]	; 0x58
 8004aee:	bd38      	pop	{r3, r4, r5, pc}
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
      {
        husart->State = HAL_USART_STATE_READY;
 8004af0:	2301      	movs	r3, #1
 8004af2:	f884 3059 	strb.w	r3, [r4, #89]	; 0x59

        /* Process Unlocked */
        __HAL_UNLOCK(husart);
 8004af6:	2300      	movs	r3, #0
 8004af8:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
  {
    /* Wait until REACK flag is set */
    if (USART_WaitOnFlagUntilTimeout(husart, USART_ISR_REACK, RESET, tickstart, USART_TEACK_REACK_TIMEOUT) != HAL_OK)
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 8004afc:	2003      	movs	r0, #3
 8004afe:	bd38      	pop	{r3, r4, r5, pc}

08004b00 <console_setup>:
static USART_HandleTypeDef con;

void console_setup(void)
{
    // enable clock to that part of chip
    __HAL_RCC_USART1_CONFIG(RCC_USART1CLKSOURCE_SYSCLK);
 8004b00:	4b14      	ldr	r3, [pc, #80]	; (8004b54 <console_setup+0x54>)
 8004b02:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8004b06:	f022 0203 	bic.w	r2, r2, #3
 8004b0a:	f042 0201 	orr.w	r2, r2, #1
static const char *CRLF = "\r\n";

static USART_HandleTypeDef con;

void console_setup(void)
{
 8004b0e:	b513      	push	{r0, r1, r4, lr}
    // enable clock to that part of chip
    __HAL_RCC_USART1_CONFIG(RCC_USART1CLKSOURCE_SYSCLK);
 8004b10:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    __HAL_RCC_USART1_CLK_ENABLE();
 8004b14:	6e1a      	ldr	r2, [r3, #96]	; 0x60

    // TODO: cleanup shit HAL code w/ barebones we need

    // config for 115200 8N1
    memset(&con, 0, sizeof(con));
 8004b16:	4c10      	ldr	r4, [pc, #64]	; (8004b58 <console_setup+0x58>)

void console_setup(void)
{
    // enable clock to that part of chip
    __HAL_RCC_USART1_CONFIG(RCC_USART1CLKSOURCE_SYSCLK);
    __HAL_RCC_USART1_CLK_ENABLE();
 8004b18:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8004b1c:	661a      	str	r2, [r3, #96]	; 0x60
 8004b1e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004b20:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8004b24:	9301      	str	r3, [sp, #4]

    // TODO: cleanup shit HAL code w/ barebones we need

    // config for 115200 8N1
    memset(&con, 0, sizeof(con));
 8004b26:	2260      	movs	r2, #96	; 0x60
 8004b28:	2100      	movs	r1, #0
 8004b2a:	4620      	mov	r0, r4

void console_setup(void)
{
    // enable clock to that part of chip
    __HAL_RCC_USART1_CONFIG(RCC_USART1CLKSOURCE_SYSCLK);
    __HAL_RCC_USART1_CLK_ENABLE();
 8004b2c:	9b01      	ldr	r3, [sp, #4]

    // TODO: cleanup shit HAL code w/ barebones we need

    // config for 115200 8N1
    memset(&con, 0, sizeof(con));
 8004b2e:	f008 fcce 	bl	800d4ce <memset>
    con.Instance = MY_UART;
    con.Init.BaudRate = 115200;
 8004b32:	4a0a      	ldr	r2, [pc, #40]	; (8004b5c <console_setup+0x5c>)
 8004b34:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 8004b38:	e884 000c 	stmia.w	r4, {r2, r3}
    con.Init.WordLength = USART_WORDLENGTH_8B;
    con.Init.Parity = USART_PARITY_NONE;
    con.Init.StopBits = USART_STOPBITS_1;
    con.Init.Mode = USART_MODE_TX_RX;

    HAL_StatusTypeDef rv = HAL_USART_Init(&con);
 8004b3c:	4620      	mov	r0, r4
    con.Instance = MY_UART;
    con.Init.BaudRate = 115200;
    con.Init.WordLength = USART_WORDLENGTH_8B;
    con.Init.Parity = USART_PARITY_NONE;
    con.Init.StopBits = USART_STOPBITS_1;
    con.Init.Mode = USART_MODE_TX_RX;
 8004b3e:	230c      	movs	r3, #12
 8004b40:	6163      	str	r3, [r4, #20]

    HAL_StatusTypeDef rv = HAL_USART_Init(&con);
 8004b42:	f7ff fe37 	bl	80047b4 <HAL_USART_Init>
    ASSERT(rv == HAL_OK);
 8004b46:	b110      	cbz	r0, 8004b4e <console_setup+0x4e>
 8004b48:	4805      	ldr	r0, [pc, #20]	; (8004b60 <console_setup+0x60>)
 8004b4a:	f7fb ff47 	bl	80009dc <fatal_error>
}
 8004b4e:	b002      	add	sp, #8
 8004b50:	bd10      	pop	{r4, pc}
 8004b52:	bf00      	nop
 8004b54:	40021000 	.word	0x40021000
 8004b58:	200001d4 	.word	0x200001d4
 8004b5c:	40013800 	.word	0x40013800
 8004b60:	0800d558 	.word	0x0800d558

08004b64 <HAL_USART_Transmit>:
  * @param  Size Amount of data elements (u8 or u16) to be sent.
  * @param  Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_USART_Transmit(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size, uint32_t Timeout)
{
 8004b64:	4b0d      	ldr	r3, [pc, #52]	; (8004b9c <HAL_USART_Transmit+0x38>)
 8004b66:	b510      	push	{r4, lr}
    while(Size > 0U) {
        while(!(MY_UART->ISR & UART_FLAG_TXE)) {
 8004b68:	461c      	mov	r4, r3
 8004b6a:	480c      	ldr	r0, [pc, #48]	; (8004b9c <HAL_USART_Transmit+0x38>)
  * @param  Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_USART_Transmit(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size, uint32_t Timeout)
{
    while(Size > 0U) {
 8004b6c:	b142      	cbz	r2, 8004b80 <HAL_USART_Transmit+0x1c>
        while(!(MY_UART->ISR & UART_FLAG_TXE)) {
 8004b6e:	69d8      	ldr	r0, [r3, #28]
 8004b70:	0600      	lsls	r0, r0, #24
 8004b72:	d5fc      	bpl.n	8004b6e <HAL_USART_Transmit+0xa>
            // wait to be able send
        }

        MY_UART->TDR = *pTxData;
 8004b74:	f811 0b01 	ldrb.w	r0, [r1], #1
 8004b78:	8520      	strh	r0, [r4, #40]	; 0x28
        pTxData++;
        Size --;
 8004b7a:	3a01      	subs	r2, #1
 8004b7c:	b292      	uxth	r2, r2
 8004b7e:	e7f4      	b.n	8004b6a <HAL_USART_Transmit+0x6>
    }

    while(!(MY_UART->ISR & UART_FLAG_TC)) {
 8004b80:	69c2      	ldr	r2, [r0, #28]
 8004b82:	4b06      	ldr	r3, [pc, #24]	; (8004b9c <HAL_USART_Transmit+0x38>)
 8004b84:	0652      	lsls	r2, r2, #25
 8004b86:	d5fb      	bpl.n	8004b80 <HAL_USART_Transmit+0x1c>
        // wait for final byte to be sent
    }

    // Clear Transmission Complete Flag
    MY_UART->ICR = USART_CLEAR_TCF;
 8004b88:	2240      	movs	r2, #64	; 0x40
 8004b8a:	621a      	str	r2, [r3, #32]

    // Clear overrun flag and discard the received data
    MY_UART->ICR = USART_CLEAR_OREF;
 8004b8c:	2208      	movs	r2, #8
 8004b8e:	621a      	str	r2, [r3, #32]
    MY_UART->RQR = USART_RXDATA_FLUSH_REQUEST;
 8004b90:	831a      	strh	r2, [r3, #24]
    MY_UART->RQR = USART_TXDATA_FLUSH_REQUEST;
 8004b92:	2210      	movs	r2, #16
 8004b94:	831a      	strh	r2, [r3, #24]

    return HAL_OK;
}
 8004b96:	2000      	movs	r0, #0
 8004b98:	bd10      	pop	{r4, pc}
 8004b9a:	bf00      	nop
 8004b9c:	40013800 	.word	0x40013800

08004ba0 <puts2>:

// puts2()
//
	void
puts2(const char *msg)
{
 8004ba0:	b510      	push	{r4, lr}
 8004ba2:	4604      	mov	r4, r0
	// output string with NO newline.
    rng_delay();
 8004ba4:	f7fd fdcb 	bl	800273e <rng_delay>
    HAL_USART_Transmit(&con, (uint8_t *)msg, strlen(msg), HAL_MAX_DELAY);
 8004ba8:	4620      	mov	r0, r4
 8004baa:	f008 fcbc 	bl	800d526 <strlen>
 8004bae:	4621      	mov	r1, r4
 8004bb0:	b282      	uxth	r2, r0
 8004bb2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004bb6:	4803      	ldr	r0, [pc, #12]	; (8004bc4 <puts2+0x24>)
 8004bb8:	f7ff ffd4 	bl	8004b64 <HAL_USART_Transmit>
    rng_delay();
}
 8004bbc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
puts2(const char *msg)
{
	// output string with NO newline.
    rng_delay();
    HAL_USART_Transmit(&con, (uint8_t *)msg, strlen(msg), HAL_MAX_DELAY);
    rng_delay();
 8004bc0:	f7fd bdbd 	b.w	800273e <rng_delay>
 8004bc4:	200001d4 	.word	0x200001d4

08004bc8 <putchar>:

// putchar()
//
	int
putchar(int c)
{
 8004bc8:	b513      	push	{r0, r1, r4, lr}
 8004bca:	4604      	mov	r4, r0
    uint8_t cb = c;
 8004bcc:	f88d 0007 	strb.w	r0, [sp, #7]

    rng_delay();
 8004bd0:	f7fd fdb5 	bl	800273e <rng_delay>
    if(cb != '\n') {
 8004bd4:	f89d 3007 	ldrb.w	r3, [sp, #7]
        HAL_USART_Transmit(&con, &cb, 1, HAL_MAX_DELAY);
    } else {
        HAL_USART_Transmit(&con, (uint8_t *)CRLF, 2, HAL_MAX_DELAY);
 8004bd8:	4808      	ldr	r0, [pc, #32]	; (8004bfc <putchar+0x34>)
putchar(int c)
{
    uint8_t cb = c;

    rng_delay();
    if(cb != '\n') {
 8004bda:	2b0a      	cmp	r3, #10
        HAL_USART_Transmit(&con, &cb, 1, HAL_MAX_DELAY);
 8004bdc:	bf18      	it	ne
 8004bde:	2201      	movne	r2, #1
 8004be0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004be4:	bf12      	itee	ne
 8004be6:	f10d 0107 	addne.w	r1, sp, #7
    } else {
        HAL_USART_Transmit(&con, (uint8_t *)CRLF, 2, HAL_MAX_DELAY);
 8004bea:	2202      	moveq	r2, #2
 8004bec:	4904      	ldreq	r1, [pc, #16]	; (8004c00 <putchar+0x38>)
 8004bee:	f7ff ffb9 	bl	8004b64 <HAL_USART_Transmit>
    }
    rng_delay();
 8004bf2:	f7fd fda4 	bl	800273e <rng_delay>

    return c;
}
 8004bf6:	4620      	mov	r0, r4
 8004bf8:	b002      	add	sp, #8
 8004bfa:	bd10      	pop	{r4, pc}
 8004bfc:	200001d4 	.word	0x200001d4
 8004c00:	0800e4ab 	.word	0x0800e4ab

08004c04 <puthex2>:

// puthex2()
//
	void
puthex2(uint8_t b)
{
 8004c04:	b538      	push	{r3, r4, r5, lr}
	putchar(hexmap[(b>>4) & 0xf]);
 8004c06:	4d06      	ldr	r5, [pc, #24]	; (8004c20 <puthex2+0x1c>)
 8004c08:	0903      	lsrs	r3, r0, #4

// puthex2()
//
	void
puthex2(uint8_t b)
{
 8004c0a:	4604      	mov	r4, r0
	putchar(hexmap[(b>>4) & 0xf]);
	putchar(hexmap[(b>>0) & 0xf]);
 8004c0c:	f004 040f 	and.w	r4, r4, #15
// puthex2()
//
	void
puthex2(uint8_t b)
{
	putchar(hexmap[(b>>4) & 0xf]);
 8004c10:	5ce8      	ldrb	r0, [r5, r3]
 8004c12:	f7ff ffd9 	bl	8004bc8 <putchar>
	putchar(hexmap[(b>>0) & 0xf]);
 8004c16:	5d28      	ldrb	r0, [r5, r4]
}
 8004c18:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
//
	void
puthex2(uint8_t b)
{
	putchar(hexmap[(b>>4) & 0xf]);
	putchar(hexmap[(b>>0) & 0xf]);
 8004c1c:	f7ff bfd4 	b.w	8004bc8 <putchar>
 8004c20:	0800e4ae 	.word	0x0800e4ae

08004c24 <puthex4>:

// puthex4()
//
	void
puthex4(uint16_t w)
{
 8004c24:	b538      	push	{r3, r4, r5, lr}
	putchar(hexmap[(w>>12) & 0xf]);
 8004c26:	4d0b      	ldr	r5, [pc, #44]	; (8004c54 <puthex4+0x30>)
 8004c28:	0b03      	lsrs	r3, r0, #12

// puthex4()
//
	void
puthex4(uint16_t w)
{
 8004c2a:	4604      	mov	r4, r0
	putchar(hexmap[(w>>12) & 0xf]);
 8004c2c:	5ce8      	ldrb	r0, [r5, r3]
 8004c2e:	f7ff ffcb 	bl	8004bc8 <putchar>
	putchar(hexmap[(w>>8) & 0xf]);
 8004c32:	f3c4 2303 	ubfx	r3, r4, #8, #4
 8004c36:	5ce8      	ldrb	r0, [r5, r3]
 8004c38:	f7ff ffc6 	bl	8004bc8 <putchar>
	putchar(hexmap[(w>>4) & 0xf]);
 8004c3c:	f3c4 1303 	ubfx	r3, r4, #4, #4
	putchar(hexmap[(w>>0) & 0xf]);
 8004c40:	f004 040f 	and.w	r4, r4, #15
	void
puthex4(uint16_t w)
{
	putchar(hexmap[(w>>12) & 0xf]);
	putchar(hexmap[(w>>8) & 0xf]);
	putchar(hexmap[(w>>4) & 0xf]);
 8004c44:	5ce8      	ldrb	r0, [r5, r3]
 8004c46:	f7ff ffbf 	bl	8004bc8 <putchar>
	putchar(hexmap[(w>>0) & 0xf]);
 8004c4a:	5d28      	ldrb	r0, [r5, r4]
}
 8004c4c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
puthex4(uint16_t w)
{
	putchar(hexmap[(w>>12) & 0xf]);
	putchar(hexmap[(w>>8) & 0xf]);
	putchar(hexmap[(w>>4) & 0xf]);
	putchar(hexmap[(w>>0) & 0xf]);
 8004c50:	f7ff bfba 	b.w	8004bc8 <putchar>
 8004c54:	0800e4ae 	.word	0x0800e4ae

08004c58 <puthex8>:

// puthex8()
//
	void
puthex8(uint32_t w)
{
 8004c58:	b510      	push	{r4, lr}
 8004c5a:	4604      	mov	r4, r0
    puthex4(w >> 16);
 8004c5c:	0c00      	lsrs	r0, r0, #16
 8004c5e:	f7ff ffe1 	bl	8004c24 <puthex4>
    puthex4(w & 0xffff);
 8004c62:	b2a0      	uxth	r0, r4
}
 8004c64:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
//
	void
puthex8(uint32_t w)
{
    puthex4(w >> 16);
    puthex4(w & 0xffff);
 8004c68:	f7ff bfdc 	b.w	8004c24 <puthex4>

08004c6c <putdec4>:

// putdec()
//
	void
putdec4(uint16_t w)
{
 8004c6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004c6e:	4607      	mov	r7, r0
 8004c70:	2504      	movs	r5, #4
    for(int m=1000; m; m /= 10) {
 8004c72:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
        if(w >= m) {
            char n = '0' + ((w / m) % 10);
            putchar(n);
 8004c76:	260a      	movs	r6, #10
//
	void
putdec4(uint16_t w)
{
    for(int m=1000; m; m /= 10) {
        if(w >= m) {
 8004c78:	42a7      	cmp	r7, r4
 8004c7a:	db09      	blt.n	8004c90 <putdec4+0x24>
            char n = '0' + ((w / m) % 10);
            putchar(n);
 8004c7c:	fb97 f0f4 	sdiv	r0, r7, r4
 8004c80:	fb90 f3f6 	sdiv	r3, r0, r6
 8004c84:	fb06 0013 	mls	r0, r6, r3, r0
 8004c88:	3030      	adds	r0, #48	; 0x30
 8004c8a:	b2c0      	uxtb	r0, r0
 8004c8c:	f7ff ff9c 	bl	8004bc8 <putchar>
// putdec()
//
	void
putdec4(uint16_t w)
{
    for(int m=1000; m; m /= 10) {
 8004c90:	fb94 f4f6 	sdiv	r4, r4, r6
 8004c94:	3d01      	subs	r5, #1
 8004c96:	d1ef      	bne.n	8004c78 <putdec4+0xc>
        if(w >= m) {
            char n = '0' + ((w / m) % 10);
            putchar(n);
        }
    }
}
 8004c98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08004c9a <hex_dump>:

// hex_dump()
//
    void
hex_dump(const void *d, int len)
{
 8004c9a:	b570      	push	{r4, r5, r6, lr}
 8004c9c:	4605      	mov	r5, r0
 8004c9e:	460e      	mov	r6, r1
	const uint8_t *data = (const uint8_t *)d;
#if 1
    for(int i=0; i<len; i++) {
 8004ca0:	4604      	mov	r4, r0
 8004ca2:	1b63      	subs	r3, r4, r5
 8004ca4:	429e      	cmp	r6, r3
 8004ca6:	dd04      	ble.n	8004cb2 <hex_dump+0x18>
        puthex2(data[i]);
 8004ca8:	f814 0b01 	ldrb.w	r0, [r4], #1
 8004cac:	f7ff ffaa 	bl	8004c04 <puthex2>
 8004cb0:	e7f7      	b.n	8004ca2 <hex_dump+0x8>
    }
    putchar('\n');
 8004cb2:	200a      	movs	r0, #10
        putchar('\n');
        i += j;
    }
#endif

}
 8004cb4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	const uint8_t *data = (const uint8_t *)d;
#if 1
    for(int i=0; i<len; i++) {
        puthex2(data[i]);
    }
    putchar('\n');
 8004cb8:	f7ff bf86 	b.w	8004bc8 <putchar>

08004cbc <puts>:

// puts()
//
    int
puts(const char *msg)
{
 8004cbc:	b538      	push	{r3, r4, r5, lr}
 8004cbe:	4605      	mov	r5, r0
    int ln = strlen(msg);
 8004cc0:	f008 fc31 	bl	800d526 <strlen>
 8004cc4:	4604      	mov	r4, r0

    rng_delay();
 8004cc6:	f7fd fd3a 	bl	800273e <rng_delay>

    if(ln) HAL_USART_Transmit(&con, (uint8_t *)msg, ln, HAL_MAX_DELAY);
 8004cca:	b134      	cbz	r4, 8004cda <puts+0x1e>
 8004ccc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004cd0:	b2a2      	uxth	r2, r4
 8004cd2:	4629      	mov	r1, r5
 8004cd4:	4806      	ldr	r0, [pc, #24]	; (8004cf0 <puts+0x34>)
 8004cd6:	f7ff ff45 	bl	8004b64 <HAL_USART_Transmit>
    HAL_USART_Transmit(&con, (uint8_t *)CRLF, 2, HAL_MAX_DELAY);
 8004cda:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004cde:	2202      	movs	r2, #2
 8004ce0:	4904      	ldr	r1, [pc, #16]	; (8004cf4 <puts+0x38>)
 8004ce2:	4803      	ldr	r0, [pc, #12]	; (8004cf0 <puts+0x34>)
 8004ce4:	f7ff ff3e 	bl	8004b64 <HAL_USART_Transmit>

    rng_delay();
 8004ce8:	f7fd fd29 	bl	800273e <rng_delay>

    return 1;
}
 8004cec:	2001      	movs	r0, #1
 8004cee:	bd38      	pop	{r3, r4, r5, pc}
 8004cf0:	200001d4 	.word	0x200001d4
 8004cf4:	0800e4ab 	.word	0x0800e4ab

08004cf8 <psram_send_byte>:

// psram_send_byte()
//
    void
psram_send_byte(OSPI_HandleTypeDef  *qh, uint8_t cmd_byte, bool is_quad)
{   
 8004cf8:	b570      	push	{r4, r5, r6, lr}
 8004cfa:	b094      	sub	sp, #80	; 0x50
 8004cfc:	4604      	mov	r4, r0
 8004cfe:	460e      	mov	r6, r1
 8004d00:	4615      	mov	r5, r2
    // Send single-byte commands to the PSRAM chip. Quad mode or normal SPI.

    OSPI_RegularCmdTypeDef cmd = {
 8004d02:	2100      	movs	r1, #0
 8004d04:	2250      	movs	r2, #80	; 0x50
 8004d06:	4668      	mov	r0, sp
 8004d08:	f008 fbe1 	bl	800d4ce <memset>
        .OperationType = HAL_OSPI_OPTYPE_COMMON_CFG,
        .Instruction = cmd_byte,                    // Exit Quad Mode
        .InstructionMode = is_quad ? HAL_OSPI_INSTRUCTION_4_LINES : HAL_OSPI_INSTRUCTION_1_LINE,
 8004d0c:	2d00      	cmp	r5, #0
 8004d0e:	bf14      	ite	ne
 8004d10:	2303      	movne	r3, #3
 8004d12:	2301      	moveq	r3, #1
        .DataMode = HAL_OSPI_DATA_NONE,
        .NbData = 0,                        // how much to read in bytes
    };

    // Start and finish a "Indirection functional mode" request
    HAL_OSPI_Command(qh, &cmd, HAL_MAX_DELAY);
 8004d14:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8004d18:	4669      	mov	r1, sp
 8004d1a:	4620      	mov	r0, r4
    void
psram_send_byte(OSPI_HandleTypeDef  *qh, uint8_t cmd_byte, bool is_quad)
{   
    // Send single-byte commands to the PSRAM chip. Quad mode or normal SPI.

    OSPI_RegularCmdTypeDef cmd = {
 8004d1c:	9602      	str	r6, [sp, #8]
 8004d1e:	9303      	str	r3, [sp, #12]
        .DataMode = HAL_OSPI_DATA_NONE,
        .NbData = 0,                        // how much to read in bytes
    };

    // Start and finish a "Indirection functional mode" request
    HAL_OSPI_Command(qh, &cmd, HAL_MAX_DELAY);
 8004d20:	f006 f820 	bl	800ad64 <HAL_OSPI_Command>
}
 8004d24:	b014      	add	sp, #80	; 0x50
 8004d26:	bd70      	pop	{r4, r5, r6, pc}

08004d28 <psram_setup>:

// psram_setup()
//
    void
psram_setup(void)
{
 8004d28:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004d2c:	b0c6      	sub	sp, #280	; 0x118
    // Using OSPI1 block
    OSPI_HandleTypeDef  qh = { 0 };
 8004d2e:	2250      	movs	r2, #80	; 0x50
 8004d30:	2100      	movs	r1, #0
 8004d32:	a80a      	add	r0, sp, #40	; 0x28
 8004d34:	f008 fbcb 	bl	800d4ce <memset>

    // enable clocks
    __HAL_RCC_OSPI1_CLK_ENABLE();
 8004d38:	4b6c      	ldr	r3, [pc, #432]	; (8004eec <psram_setup+0x1c4>)
    // reset module
    __HAL_RCC_OSPI1_FORCE_RESET();
    __HAL_RCC_OSPI1_RELEASE_RESET();

   // configure pins: Port E PE10-PE15
    GPIO_InitTypeDef setup = {
 8004d3a:	4c6d      	ldr	r4, [pc, #436]	; (8004ef0 <psram_setup+0x1c8>)
{
    // Using OSPI1 block
    OSPI_HandleTypeDef  qh = { 0 };

    // enable clocks
    __HAL_RCC_OSPI1_CLK_ENABLE();
 8004d3c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8004d3e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8004d42:	651a      	str	r2, [r3, #80]	; 0x50
 8004d44:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8004d46:	f402 7280 	and.w	r2, r2, #256	; 0x100
 8004d4a:	9201      	str	r2, [sp, #4]
 8004d4c:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8004d4e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004d50:	f042 0210 	orr.w	r2, r2, #16
 8004d54:	64da      	str	r2, [r3, #76]	; 0x4c
 8004d56:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004d58:	f002 0210 	and.w	r2, r2, #16
 8004d5c:	9202      	str	r2, [sp, #8]
 8004d5e:	9a02      	ldr	r2, [sp, #8]

    // reset module
    __HAL_RCC_OSPI1_FORCE_RESET();
 8004d60:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004d62:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8004d66:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_RCC_OSPI1_RELEASE_RESET();
 8004d68:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004d6a:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8004d6e:	631a      	str	r2, [r3, #48]	; 0x30

   // configure pins: Port E PE10-PE15
    GPIO_InitTypeDef setup = {
 8004d70:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8004d72:	ad05      	add	r5, sp, #20
 8004d74:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8004d76:	6823      	ldr	r3, [r4, #0]
        .Mode = GPIO_MODE_AF_PP,            // not sure
        .Pull = GPIO_NOPULL,                // not sure
        .Speed = GPIO_SPEED_FREQ_VERY_HIGH,
        .Alternate = GPIO_AF10_OCTOSPIM_P1,
    };
    HAL_GPIO_Init(GPIOE, &setup);
 8004d78:	485e      	ldr	r0, [pc, #376]	; (8004ef4 <psram_setup+0x1cc>)
    // reset module
    __HAL_RCC_OSPI1_FORCE_RESET();
    __HAL_RCC_OSPI1_RELEASE_RESET();

   // configure pins: Port E PE10-PE15
    GPIO_InitTypeDef setup = {
 8004d7a:	602b      	str	r3, [r5, #0]
        .Mode = GPIO_MODE_AF_PP,            // not sure
        .Pull = GPIO_NOPULL,                // not sure
        .Speed = GPIO_SPEED_FREQ_VERY_HIGH,
        .Alternate = GPIO_AF10_OCTOSPIM_P1,
    };
    HAL_GPIO_Init(GPIOE, &setup);
 8004d7c:	a905      	add	r1, sp, #20
 8004d7e:	f7fc f91f 	bl	8000fc0 <HAL_GPIO_Init>


    // Config operational values
    qh.Instance = OCTOSPI1;
 8004d82:	4b5d      	ldr	r3, [pc, #372]	; (8004ef8 <psram_setup+0x1d0>)
 8004d84:	930a      	str	r3, [sp, #40]	; 0x28
    qh.Init.FifoThreshold = 1;                          // ?? unused
    qh.Init.DualQuad = HAL_OSPI_DUALQUAD_DISABLE;
    qh.Init.MemoryType = HAL_OSPI_MEMTYPE_MICRON;       // want standard mode (but octo only?)
    qh.Init.DeviceSize = 24;                    // assume max size, actual is 8Mbyte
 8004d86:	2218      	movs	r2, #24


    // Config operational values
    qh.Instance = OCTOSPI1;
    qh.Init.FifoThreshold = 1;                          // ?? unused
    qh.Init.DualQuad = HAL_OSPI_DUALQUAD_DISABLE;
 8004d88:	2300      	movs	r3, #0
    HAL_GPIO_Init(GPIOE, &setup);


    // Config operational values
    qh.Instance = OCTOSPI1;
    qh.Init.FifoThreshold = 1;                          // ?? unused
 8004d8a:	2601      	movs	r6, #1
    qh.Init.DualQuad = HAL_OSPI_DUALQUAD_DISABLE;
    qh.Init.MemoryType = HAL_OSPI_MEMTYPE_MICRON;       // want standard mode (but octo only?)
    qh.Init.DeviceSize = 24;                    // assume max size, actual is 8Mbyte
 8004d8c:	920e      	str	r2, [sp, #56]	; 0x38
    qh.Init.FreeRunningClock = HAL_OSPI_FREERUNCLK_DISABLE;     // required!
    qh.Init.ClockMode = HAL_OSPI_CLOCK_MODE_0;  // low clock between ops (required, see errata)
#if HCLK_FREQUENCY == 80000000
    qh.Init.ClockPrescaler = 1;                 // prescaler (1=>80Mhz, 2=>40Mhz, etc)
#elif HCLK_FREQUENCY == 120000000
    qh.Init.ClockPrescaler = 2;                 // prescaler (1=>120Mhz, 2=>60Mhz, etc)
 8004d8e:	f04f 0802 	mov.w	r8, #2
    qh.Init.FifoThreshold = 1;                          // ?? unused
    qh.Init.DualQuad = HAL_OSPI_DUALQUAD_DISABLE;
    qh.Init.MemoryType = HAL_OSPI_MEMTYPE_MICRON;       // want standard mode (but octo only?)
    qh.Init.DeviceSize = 24;                    // assume max size, actual is 8Mbyte
    qh.Init.ChipSelectHighTime = 1;             // 1, maxed out, seems to work
    qh.Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_ENABLE;       // maybe?
 8004d92:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
#elif HCLK_FREQUENCY == 120000000
    qh.Init.ClockPrescaler = 2;                 // prescaler (1=>120Mhz, 2=>60Mhz, etc)
#else
#   error "testing needed"
#endif
    qh.Init.DelayBlockBypass = HAL_OSPI_DELAY_BLOCK_BYPASSED;        // dont need it?
 8004d96:	f04f 0908 	mov.w	r9, #8
    // - (during reads) 3 => 400ns  4 => 660ns   5+ => 1us 
    // - LATER: Errata 2.8.1 => says shall not use
    qh.Init.ChipSelectBoundary = 0;

    // module init 
    HAL_StatusTypeDef rv = HAL_OSPI_Init(&qh);
 8004d9a:	a80a      	add	r0, sp, #40	; 0x28
    HAL_GPIO_Init(GPIOE, &setup);


    // Config operational values
    qh.Instance = OCTOSPI1;
    qh.Init.FifoThreshold = 1;                          // ?? unused
 8004d9c:	960b      	str	r6, [sp, #44]	; 0x2c
    qh.Init.DualQuad = HAL_OSPI_DUALQUAD_DISABLE;
 8004d9e:	930c      	str	r3, [sp, #48]	; 0x30
    qh.Init.MemoryType = HAL_OSPI_MEMTYPE_MICRON;       // want standard mode (but octo only?)
 8004da0:	930d      	str	r3, [sp, #52]	; 0x34
    qh.Init.DeviceSize = 24;                    // assume max size, actual is 8Mbyte
    qh.Init.ChipSelectHighTime = 1;             // 1, maxed out, seems to work
 8004da2:	960f      	str	r6, [sp, #60]	; 0x3c
    qh.Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_ENABLE;       // maybe?
 8004da4:	9214      	str	r2, [sp, #80]	; 0x50
    qh.Init.FreeRunningClock = HAL_OSPI_FREERUNCLK_DISABLE;     // required!
 8004da6:	9310      	str	r3, [sp, #64]	; 0x40
    qh.Init.ClockMode = HAL_OSPI_CLOCK_MODE_0;  // low clock between ops (required, see errata)
 8004da8:	9311      	str	r3, [sp, #68]	; 0x44
#if HCLK_FREQUENCY == 80000000
    qh.Init.ClockPrescaler = 1;                 // prescaler (1=>80Mhz, 2=>40Mhz, etc)
#elif HCLK_FREQUENCY == 120000000
    qh.Init.ClockPrescaler = 2;                 // prescaler (1=>120Mhz, 2=>60Mhz, etc)
 8004daa:	f8cd 8048 	str.w	r8, [sp, #72]	; 0x48
#else
#   error "testing needed"
#endif
    qh.Init.DelayBlockBypass = HAL_OSPI_DELAY_BLOCK_BYPASSED;        // dont need it?
 8004dae:	f8cd 9058 	str.w	r9, [sp, #88]	; 0x58
    // ESP-PSRAM64H calls for max of 8us w/ CS low. Needs it for refresh time.
    // - stm32 datasheet says min 3 here; found 1-3 all work
    // - zero works, but CS is never released (but doesn't seem to affect operation?)
    // - (during reads) 3 => 400ns  4 => 660ns   5+ => 1us 
    // - LATER: Errata 2.8.1 => says shall not use
    qh.Init.ChipSelectBoundary = 0;
 8004db2:	9315      	str	r3, [sp, #84]	; 0x54

    // module init 
    HAL_StatusTypeDef rv = HAL_OSPI_Init(&qh);
 8004db4:	f005 ff6c 	bl	800ac90 <HAL_OSPI_Init>
    ASSERT(rv == HAL_OK);
 8004db8:	4607      	mov	r7, r0
 8004dba:	b110      	cbz	r0, 8004dc2 <psram_setup+0x9a>
 8004dbc:	484f      	ldr	r0, [pc, #316]	; (8004efc <psram_setup+0x1d4>)
 8004dbe:	f7fb fe0d 	bl	80009dc <fatal_error>

    // do some SPI commands first

    // Exit Quad mode, to get to a known state, after first power-up
    psram_send_byte(&qh, 0xf5, true);
 8004dc2:	4632      	mov	r2, r6
 8004dc4:	21f5      	movs	r1, #245	; 0xf5
 8004dc6:	a80a      	add	r0, sp, #40	; 0x28
 8004dc8:	f7ff ff96 	bl	8004cf8 <psram_send_byte>

    // Chip Reset sequence
    psram_send_byte(&qh, 0x66, false);      // reset enable
 8004dcc:	463a      	mov	r2, r7
 8004dce:	2166      	movs	r1, #102	; 0x66
 8004dd0:	a80a      	add	r0, sp, #40	; 0x28
 8004dd2:	f7ff ff91 	bl	8004cf8 <psram_send_byte>

    // Read Electronic ID
    // - length not clear from datasheet, but repeats after 8 bytes
    uint8_t psram_chip_eid[8];

    {   OSPI_RegularCmdTypeDef cmd = {
 8004dd6:	ad32      	add	r5, sp, #200	; 0xc8
    // Exit Quad mode, to get to a known state, after first power-up
    psram_send_byte(&qh, 0xf5, true);

    // Chip Reset sequence
    psram_send_byte(&qh, 0x66, false);      // reset enable
    psram_send_byte(&qh, 0x99, false);      // reset
 8004dd8:	463a      	mov	r2, r7
 8004dda:	2199      	movs	r1, #153	; 0x99
 8004ddc:	a80a      	add	r0, sp, #40	; 0x28
 8004dde:	f7ff ff8b 	bl	8004cf8 <psram_send_byte>

    // Read Electronic ID
    // - length not clear from datasheet, but repeats after 8 bytes
    uint8_t psram_chip_eid[8];

    {   OSPI_RegularCmdTypeDef cmd = {
 8004de2:	4639      	mov	r1, r7
 8004de4:	2250      	movs	r2, #80	; 0x50
 8004de6:	4628      	mov	r0, r5
 8004de8:	f008 fb71 	bl	800d4ce <memset>
 8004dec:	239f      	movs	r3, #159	; 0x9f
 8004dee:	9334      	str	r3, [sp, #208]	; 0xd0
 8004df0:	f44f 7380 	mov.w	r3, #256	; 0x100
 8004df4:	9339      	str	r3, [sp, #228]	; 0xe4
 8004df6:	f44f 5700 	mov.w	r7, #8192	; 0x2000
 8004dfa:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
            .DataMode = HAL_OSPI_DATA_1_LINE,
            .NbData = sizeof(psram_chip_eid),                        // how much to read in bytes
        };

        // Start a "Indirection functional mode" request
        rv = HAL_OSPI_Command(&qh, &cmd, HAL_MAX_DELAY);
 8004dfe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8004e02:	4629      	mov	r1, r5
 8004e04:	a80a      	add	r0, sp, #40	; 0x28

    // Read Electronic ID
    // - length not clear from datasheet, but repeats after 8 bytes
    uint8_t psram_chip_eid[8];

    {   OSPI_RegularCmdTypeDef cmd = {
 8004e06:	9635      	str	r6, [sp, #212]	; 0xd4
 8004e08:	973a      	str	r7, [sp, #232]	; 0xe8
 8004e0a:	9340      	str	r3, [sp, #256]	; 0x100
 8004e0c:	f8cd 9104 	str.w	r9, [sp, #260]	; 0x104
            .DataMode = HAL_OSPI_DATA_1_LINE,
            .NbData = sizeof(psram_chip_eid),                        // how much to read in bytes
        };

        // Start a "Indirection functional mode" request
        rv = HAL_OSPI_Command(&qh, &cmd, HAL_MAX_DELAY);
 8004e10:	f005 ffa8 	bl	800ad64 <HAL_OSPI_Command>
        if(rv != HAL_OK) goto fail;
 8004e14:	2800      	cmp	r0, #0
 8004e16:	d15f      	bne.n	8004ed8 <psram_setup+0x1b0>

        rv = HAL_OSPI_Receive(&qh, psram_chip_eid, HAL_MAX_DELAY);
 8004e18:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8004e1c:	a903      	add	r1, sp, #12
 8004e1e:	a80a      	add	r0, sp, #40	; 0x28
 8004e20:	f006 f8cc 	bl	800afbc <HAL_OSPI_Receive>
        if(rv != HAL_OK) goto fail;
 8004e24:	4681      	mov	r9, r0
 8004e26:	2800      	cmp	r0, #0
 8004e28:	d156      	bne.n	8004ed8 <psram_setup+0x1b0>
    }

    //puts2("PSRAM EID: "); 
    //hex_dump(psram_chip_eid, sizeof(psram_chip_eid));
    ASSERT(psram_chip_eid[0] == 0x0d);
 8004e2a:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8004e2e:	2b0d      	cmp	r3, #13
 8004e30:	d1c4      	bne.n	8004dbc <psram_setup+0x94>
    ASSERT(psram_chip_eid[1] == 0x5d);
 8004e32:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8004e36:	2b5d      	cmp	r3, #93	; 0x5d
 8004e38:	d1c0      	bne.n	8004dbc <psram_setup+0x94>
    // .. other bits seem pretty similar between devices, they don't claim they are UUID

    // Put into Quad mode
    psram_send_byte(&qh, 0x35, false);  // 0x35 = Enter Quad Mode
 8004e3a:	4602      	mov	r2, r0
 8004e3c:	2135      	movs	r1, #53	; 0x35
 8004e3e:	a80a      	add	r0, sp, #40	; 0x28
 8004e40:	f7ff ff5a 	bl	8004cf8 <psram_send_byte>

    // Configure read/write cycles for mem-mapped mode
    {   OSPI_RegularCmdTypeDef cmd = {
 8004e44:	4649      	mov	r1, r9
 8004e46:	2250      	movs	r2, #80	; 0x50
 8004e48:	a81e      	add	r0, sp, #120	; 0x78
 8004e4a:	f008 fb40 	bl	800d4ce <memset>
 8004e4e:	f04f 0a03 	mov.w	sl, #3
 8004e52:	f8cd 8078 	str.w	r8, [sp, #120]	; 0x78
 8004e56:	f8cd 8080 	str.w	r8, [sp, #128]	; 0x80
            .DataMode = HAL_OSPI_DATA_4_LINES,
            .NbData = 0,                        // don't care / TBD?
        };

        // Config for write
        rv = HAL_OSPI_Command(&qh, &cmd, HAL_MAX_DELAY);
 8004e5a:	a91e      	add	r1, sp, #120	; 0x78

    // Put into Quad mode
    psram_send_byte(&qh, 0x35, false);  // 0x35 = Enter Quad Mode

    // Configure read/write cycles for mem-mapped mode
    {   OSPI_RegularCmdTypeDef cmd = {
 8004e5c:	f44f 7940 	mov.w	r9, #768	; 0x300
 8004e60:	f04f 7840 	mov.w	r8, #50331648	; 0x3000000
            .DataMode = HAL_OSPI_DATA_4_LINES,
            .NbData = 0,                        // don't care / TBD?
        };

        // Config for write
        rv = HAL_OSPI_Command(&qh, &cmd, HAL_MAX_DELAY);
 8004e64:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8004e68:	a80a      	add	r0, sp, #40	; 0x28

    // Put into Quad mode
    psram_send_byte(&qh, 0x35, false);  // 0x35 = Enter Quad Mode

    // Configure read/write cycles for mem-mapped mode
    {   OSPI_RegularCmdTypeDef cmd = {
 8004e6a:	f8cd a084 	str.w	sl, [sp, #132]	; 0x84
 8004e6e:	f8cd 9094 	str.w	r9, [sp, #148]	; 0x94
 8004e72:	9726      	str	r7, [sp, #152]	; 0x98
 8004e74:	f8cd 80b0 	str.w	r8, [sp, #176]	; 0xb0
            .DataMode = HAL_OSPI_DATA_4_LINES,
            .NbData = 0,                        // don't care / TBD?
        };

        // Config for write
        rv = HAL_OSPI_Command(&qh, &cmd, HAL_MAX_DELAY);
 8004e78:	f005 ff74 	bl	800ad64 <HAL_OSPI_Command>
        if(rv != HAL_OK) goto fail;
 8004e7c:	4601      	mov	r1, r0
 8004e7e:	bb58      	cbnz	r0, 8004ed8 <psram_setup+0x1b0>

        // .. for read
        OSPI_RegularCmdTypeDef cmd2 = {
 8004e80:	2250      	movs	r2, #80	; 0x50
 8004e82:	4628      	mov	r0, r5
 8004e84:	f008 fb23 	bl	800d4ce <memset>
 8004e88:	23eb      	movs	r3, #235	; 0xeb
 8004e8a:	9334      	str	r3, [sp, #208]	; 0xd0
            .DataMode = HAL_OSPI_DATA_4_LINES,
            .NbData = 0,                        // don't care / TBD?
        };

        // Config for read
        rv = HAL_OSPI_Command(&qh, &cmd2, HAL_MAX_DELAY);
 8004e8c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
        // Config for write
        rv = HAL_OSPI_Command(&qh, &cmd, HAL_MAX_DELAY);
        if(rv != HAL_OK) goto fail;

        // .. for read
        OSPI_RegularCmdTypeDef cmd2 = {
 8004e90:	2306      	movs	r3, #6
            .DataMode = HAL_OSPI_DATA_4_LINES,
            .NbData = 0,                        // don't care / TBD?
        };

        // Config for read
        rv = HAL_OSPI_Command(&qh, &cmd2, HAL_MAX_DELAY);
 8004e92:	4629      	mov	r1, r5
 8004e94:	a80a      	add	r0, sp, #40	; 0x28
        // Config for write
        rv = HAL_OSPI_Command(&qh, &cmd, HAL_MAX_DELAY);
        if(rv != HAL_OK) goto fail;

        // .. for read
        OSPI_RegularCmdTypeDef cmd2 = {
 8004e96:	9632      	str	r6, [sp, #200]	; 0xc8
 8004e98:	f8cd a0d4 	str.w	sl, [sp, #212]	; 0xd4
 8004e9c:	f8cd 90e4 	str.w	r9, [sp, #228]	; 0xe4
 8004ea0:	973a      	str	r7, [sp, #232]	; 0xe8
 8004ea2:	f8cd 8100 	str.w	r8, [sp, #256]	; 0x100
 8004ea6:	9343      	str	r3, [sp, #268]	; 0x10c
            .DataMode = HAL_OSPI_DATA_4_LINES,
            .NbData = 0,                        // don't care / TBD?
        };

        // Config for read
        rv = HAL_OSPI_Command(&qh, &cmd2, HAL_MAX_DELAY);
 8004ea8:	f005 ff5c 	bl	800ad64 <HAL_OSPI_Command>
        if(rv != HAL_OK) goto fail;
 8004eac:	b9a0      	cbnz	r0, 8004ed8 <psram_setup+0x1b0>
    }

    // config for memmap
    {   OSPI_MemoryMappedTypeDef mmap = {
 8004eae:	3404      	adds	r4, #4
 8004eb0:	e894 0003 	ldmia.w	r4, {r0, r1}
 8004eb4:	e885 0003 	stmia.w	r5, {r0, r1}
           // Need this so that CS lines returns to inactive sometimes.
          .TimeOutActivation = HAL_OSPI_TIMEOUT_COUNTER_ENABLE,
          .TimeOutPeriod = 16,          // no idea, max value 0xffff
        };

        rv = HAL_OSPI_MemoryMapped(&qh, &mmap);
 8004eb8:	4629      	mov	r1, r5
 8004eba:	a80a      	add	r0, sp, #40	; 0x28
 8004ebc:	f006 f96e 	bl	800b19c <HAL_OSPI_MemoryMapped>
        if(rv != HAL_OK) goto fail;
 8004ec0:	b950      	cbnz	r0, 8004ed8 <psram_setup+0x1b0>
#else
    // Only a quick operational check only here. Non-destructive.
    {   __IO uint32_t    *ptr = (uint32_t *)(PSRAM_BASE+PSRAM_SIZE-4);
        uint32_t    tmp;

        tmp = *ptr;
 8004ec2:	4b0f      	ldr	r3, [pc, #60]	; (8004f00 <psram_setup+0x1d8>)
        *ptr = 0x55aa1234;
 8004ec4:	4a0f      	ldr	r2, [pc, #60]	; (8004f04 <psram_setup+0x1dc>)
#else
    // Only a quick operational check only here. Non-destructive.
    {   __IO uint32_t    *ptr = (uint32_t *)(PSRAM_BASE+PSRAM_SIZE-4);
        uint32_t    tmp;

        tmp = *ptr;
 8004ec6:	6819      	ldr	r1, [r3, #0]
        *ptr = 0x55aa1234;
 8004ec8:	601a      	str	r2, [r3, #0]
        if(*ptr != 0x55aa1234) goto fail;
 8004eca:	6818      	ldr	r0, [r3, #0]
 8004ecc:	4290      	cmp	r0, r2
 8004ece:	d103      	bne.n	8004ed8 <psram_setup+0x1b0>
        *ptr = tmp;
 8004ed0:	6019      	str	r1, [r3, #0]

    oled_setup();
    oled_show(screen_fatal);

    LOCKUP_FOREVER();
}
 8004ed2:	b046      	add	sp, #280	; 0x118
 8004ed4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
#endif

    return;

fail:
    puts("PSRAM fail");
 8004ed8:	480b      	ldr	r0, [pc, #44]	; (8004f08 <psram_setup+0x1e0>)
 8004eda:	f7ff feef 	bl	8004cbc <puts>

    oled_setup();
 8004ede:	f7fb fef9 	bl	8000cd4 <oled_setup>
    oled_show(screen_fatal);
 8004ee2:	480a      	ldr	r0, [pc, #40]	; (8004f0c <psram_setup+0x1e4>)
 8004ee4:	f7fb ff86 	bl	8000df4 <oled_show>

    LOCKUP_FOREVER();
 8004ee8:	bf30      	wfi
 8004eea:	e7fd      	b.n	8004ee8 <psram_setup+0x1c0>
 8004eec:	40021000 	.word	0x40021000
 8004ef0:	0800e4d0 	.word	0x0800e4d0
 8004ef4:	48001000 	.word	0x48001000
 8004ef8:	a0001000 	.word	0xa0001000
 8004efc:	0800d558 	.word	0x0800d558
 8004f00:	907ffffc 	.word	0x907ffffc
 8004f04:	55aa1234 	.word	0x55aa1234
 8004f08:	0800e4ec 	.word	0x0800e4ec
 8004f0c:	0800dcc5 	.word	0x0800dcc5

08004f10 <psram_wipe>:

// psram_wipe()
//
    void
psram_wipe(void)
{
 8004f10:	b508      	push	{r3, lr}
    if(OCTOSPI1->CR == 0) return;       // PSRAM not enabled (yet?)
 8004f12:	4b06      	ldr	r3, [pc, #24]	; (8004f2c <psram_wipe+0x1c>)
 8004f14:	681b      	ldr	r3, [r3, #0]
 8004f16:	b143      	cbz	r3, 8004f2a <psram_wipe+0x1a>

    // Fast! But real; maybe 150ms
    //puts2("PSRAM Wipe: ");
    memset4((uint32_t *)PSRAM_BASE, rng_sample(), PSRAM_SIZE);
 8004f18:	f7fd fbba 	bl	8002690 <rng_sample>
 8004f1c:	f04f 4310 	mov.w	r3, #2415919104	; 0x90000000
        *dest = value;
 8004f20:	f843 0b04 	str.w	r0, [r3], #4
// memset4()
//
    static inline void
memset4(uint32_t *dest, uint32_t value, uint32_t byte_len)
{
    for(; byte_len; byte_len-=4, dest++) {
 8004f24:	f113 4fdf 	cmn.w	r3, #1870659584	; 0x6f800000
 8004f28:	d1fa      	bne.n	8004f20 <psram_wipe+0x10>
 8004f2a:	bd08      	pop	{r3, pc}
 8004f2c:	a0001000 	.word	0xa0001000

08004f30 <psram_do_upgrade>:
// NOTE: incoming start address is typically not aligned.
//
    void
psram_do_upgrade(const uint8_t *start, uint32_t size)
{
    ASSERT(size >= FW_MIN_LENGTH);
 8004f30:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000
//
// NOTE: incoming start address is typically not aligned.
//
    void
psram_do_upgrade(const uint8_t *start, uint32_t size)
{
 8004f34:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8004f38:	4607      	mov	r7, r0
 8004f3a:	460e      	mov	r6, r1
    ASSERT(size >= FW_MIN_LENGTH);
 8004f3c:	d202      	bcs.n	8004f44 <psram_do_upgrade+0x14>
 8004f3e:	481d      	ldr	r0, [pc, #116]	; (8004fb4 <psram_do_upgrade+0x84>)
 8004f40:	f7fb fd4c 	bl	80009dc <fatal_error>

    // In case of reset/crash, we can recover, so save
    // what we need for that -- yes, we will re-verify signatures
    volatile recovery_header_t   *h = RECHDR_POS;
    h->start = start;
 8004f44:	4b1c      	ldr	r3, [pc, #112]	; (8004fb8 <psram_do_upgrade+0x88>)
    h->size = size;
    h->magic1 = RECHDR_MAGIC1;
 8004f46:	4a1d      	ldr	r2, [pc, #116]	; (8004fbc <psram_do_upgrade+0x8c>)
    ASSERT(size >= FW_MIN_LENGTH);

    // In case of reset/crash, we can recover, so save
    // what we need for that -- yes, we will re-verify signatures
    volatile recovery_header_t   *h = RECHDR_POS;
    h->start = start;
 8004f48:	6058      	str	r0, [r3, #4]
    h->size = size;
 8004f4a:	6099      	str	r1, [r3, #8]
    h->magic1 = RECHDR_MAGIC1;
 8004f4c:	601a      	str	r2, [r3, #0]
    h->magic2 = RECHDR_MAGIC2;
 8004f4e:	4a1c      	ldr	r2, [pc, #112]	; (8004fc0 <psram_do_upgrade+0x90>)
 8004f50:	60da      	str	r2, [r3, #12]

    flash_setup0();
 8004f52:	f7fd f841 	bl	8001fd8 <flash_setup0>
    flash_unlock();
 8004f56:	f7fd f863 	bl	8002020 <flash_unlock>

    int rv;

    // one uint64_t at a time = 8 bytes
    uint64_t tmp;
    for(uint32_t pos=0; pos < size; pos += 8) {
 8004f5a:	2400      	movs	r4, #0
        uint32_t dest = FIRMWARE_START+pos;

        if(dest % (4*FLASH_PAGE_SIZE) == 0) {
            // show some progress
            oled_show_progress(screen_upgrading, pos*100/size);
 8004f5c:	f04f 0864 	mov.w	r8, #100	; 0x64
 8004f60:	f104 6500 	add.w	r5, r4, #134217728	; 0x8000000
 8004f64:	f505 3500 	add.w	r5, r5, #131072	; 0x20000
    // one uint64_t at a time = 8 bytes
    uint64_t tmp;
    for(uint32_t pos=0; pos < size; pos += 8) {
        uint32_t dest = FIRMWARE_START+pos;

        if(dest % (4*FLASH_PAGE_SIZE) == 0) {
 8004f68:	f3c5 030d 	ubfx	r3, r5, #0, #14
 8004f6c:	b933      	cbnz	r3, 8004f7c <psram_do_upgrade+0x4c>
            // show some progress
            oled_show_progress(screen_upgrading, pos*100/size);
 8004f6e:	fb08 f104 	mul.w	r1, r8, r4
 8004f72:	4814      	ldr	r0, [pc, #80]	; (8004fc4 <psram_do_upgrade+0x94>)
 8004f74:	fbb1 f1f6 	udiv	r1, r1, r6
 8004f78:	f7fb ff7e 	bl	8000e78 <oled_show_progress>
        }

        if(dest % FLASH_PAGE_SIZE == 0) {
 8004f7c:	f3c5 030b 	ubfx	r3, r5, #0, #12
 8004f80:	b923      	cbnz	r3, 8004f8c <psram_do_upgrade+0x5c>
            // page erase as we go
            rv = flash_page_erase(dest);
 8004f82:	4628      	mov	r0, r5
 8004f84:	f008 fae0 	bl	800d548 <__flash_page_erase_veneer>
            ASSERT(rv == 0);
 8004f88:	2800      	cmp	r0, #0
 8004f8a:	d1d8      	bne.n	8004f3e <psram_do_upgrade+0xe>
        }

        memcpy(&tmp, start+pos, 8);
 8004f8c:	193a      	adds	r2, r7, r4
 8004f8e:	466b      	mov	r3, sp
 8004f90:	6810      	ldr	r0, [r2, #0]
 8004f92:	6851      	ldr	r1, [r2, #4]
 8004f94:	c303      	stmia	r3!, {r0, r1}
        rv = flash_burn(dest, tmp);
 8004f96:	4628      	mov	r0, r5
 8004f98:	e9dd 2300 	ldrd	r2, r3, [sp]
 8004f9c:	f008 facc 	bl	800d538 <__flash_burn_veneer>
        ASSERT(rv == 0);
 8004fa0:	2800      	cmp	r0, #0
 8004fa2:	d1cc      	bne.n	8004f3e <psram_do_upgrade+0xe>

    int rv;

    // one uint64_t at a time = 8 bytes
    uint64_t tmp;
    for(uint32_t pos=0; pos < size; pos += 8) {
 8004fa4:	3408      	adds	r4, #8
 8004fa6:	42a6      	cmp	r6, r4
 8004fa8:	d8da      	bhi.n	8004f60 <psram_do_upgrade+0x30>
        rv = flash_burn(dest, tmp);
        ASSERT(rv == 0);
    }

    flash_lock();
}
 8004faa:	b002      	add	sp, #8
 8004fac:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        memcpy(&tmp, start+pos, 8);
        rv = flash_burn(dest, tmp);
        ASSERT(rv == 0);
    }

    flash_lock();
 8004fb0:	f7fd b82e 	b.w	8002010 <flash_lock>
 8004fb4:	0800d558 	.word	0x0800d558
 8004fb8:	907ff800 	.word	0x907ff800
 8004fbc:	dbcc8350 	.word	0xdbcc8350
 8004fc0:	bafcfba3 	.word	0xbafcfba3
 8004fc4:	0800dc07 	.word	0x0800dc07

08004fc8 <psram_recover_firmware>:
//
// Try to recover from interrupt PSRAM-based firmware upgrade.
//
    bool
psram_recover_firmware(void)
{
 8004fc8:	b510      	push	{r4, lr}
    volatile recovery_header_t   *h = RECHDR_POS;

    // Check header is valid.
    if(    (h->magic1 != RECHDR_MAGIC1)
 8004fca:	4c1f      	ldr	r4, [pc, #124]	; (8005048 <psram_recover_firmware+0x80>)
 8004fcc:	4b1f      	ldr	r3, [pc, #124]	; (800504c <psram_recover_firmware+0x84>)
 8004fce:	6822      	ldr	r2, [r4, #0]
 8004fd0:	429a      	cmp	r2, r3
//
// Try to recover from interrupt PSRAM-based firmware upgrade.
//
    bool
psram_recover_firmware(void)
{
 8004fd2:	b088      	sub	sp, #32
    volatile recovery_header_t   *h = RECHDR_POS;

    // Check header is valid.
    if(    (h->magic1 != RECHDR_MAGIC1)
 8004fd4:	d113      	bne.n	8004ffe <psram_recover_firmware+0x36>
        || (h->magic2 != RECHDR_MAGIC2)
 8004fd6:	68e2      	ldr	r2, [r4, #12]
 8004fd8:	4b1d      	ldr	r3, [pc, #116]	; (8005050 <psram_recover_firmware+0x88>)
 8004fda:	429a      	cmp	r2, r3
 8004fdc:	d10f      	bne.n	8004ffe <psram_recover_firmware+0x36>
        || ((uint32_t)h->start < PSRAM_BASE) 
 8004fde:	6863      	ldr	r3, [r4, #4]
 8004fe0:	f1b3 4f10 	cmp.w	r3, #2415919104	; 0x90000000
 8004fe4:	d30b      	bcc.n	8004ffe <psram_recover_firmware+0x36>
        || ((uint32_t)h->start >= PSRAM_BASE+(PSRAM_SIZE/2)) 
 8004fe6:	6862      	ldr	r2, [r4, #4]
 8004fe8:	4b1a      	ldr	r3, [pc, #104]	; (8005054 <psram_recover_firmware+0x8c>)
 8004fea:	429a      	cmp	r2, r3
 8004fec:	d807      	bhi.n	8004ffe <psram_recover_firmware+0x36>
        || (h->size > FW_MAX_LENGTH_MK4) 
 8004fee:	68a3      	ldr	r3, [r4, #8]
 8004ff0:	f5b3 1ff0 	cmp.w	r3, #1966080	; 0x1e0000
 8004ff4:	d803      	bhi.n	8004ffe <psram_recover_firmware+0x36>
        || (h->size < FW_MIN_LENGTH)
 8004ff6:	68a3      	ldr	r3, [r4, #8]
 8004ff8:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8004ffc:	d201      	bcs.n	8005002 <psram_recover_firmware+0x3a>
    ) {
        puts("PSR: nada");
 8004ffe:	4816      	ldr	r0, [pc, #88]	; (8005058 <psram_recover_firmware+0x90>)
 8005000:	e00c      	b.n	800501c <psram_recover_firmware+0x54>
    }

    // Re-verify bytes and factory signature; will catch any bitrot in our 
    // PSRAM copy of firmware
    uint8_t     world_check[32];
    bool ok = verify_firmware_in_ram(h->start, h->size, world_check);
 8005002:	6860      	ldr	r0, [r4, #4]
 8005004:	68a1      	ldr	r1, [r4, #8]
 8005006:	466a      	mov	r2, sp
 8005008:	f7fc fe46 	bl	8001c98 <verify_firmware_in_ram>

    if(!ok) {
 800500c:	b908      	cbnz	r0, 8005012 <psram_recover_firmware+0x4a>
        puts("PSR: !check");
 800500e:	4813      	ldr	r0, [pc, #76]	; (800505c <psram_recover_firmware+0x94>)
 8005010:	e004      	b.n	800501c <psram_recover_firmware+0x54>
    }

    // Check we have the **right** firmware, based on the world check sum
    // but don't set the light at this point.
    // - this includes check over bootrom (ourselves)
    if(!verify_world_checksum(world_check)) {
 8005012:	4668      	mov	r0, sp
 8005014:	f7fc fe90 	bl	8001d38 <verify_world_checksum>
 8005018:	b928      	cbnz	r0, 8005026 <psram_recover_firmware+0x5e>
        puts("PSR: version");
 800501a:	4811      	ldr	r0, [pc, #68]	; (8005060 <psram_recover_firmware+0x98>)
 800501c:	f7ff fe4e 	bl	8004cbc <puts>
    // done
    NVIC_SystemReset();

    // not-reached
    return true;
}
 8005020:	2000      	movs	r0, #0
 8005022:	b008      	add	sp, #32
 8005024:	bd10      	pop	{r4, pc}
        puts("PSR: version");
        return false;
    }

    // Re-do the upgrade.
    psram_do_upgrade(h->start, h->size);
 8005026:	6860      	ldr	r0, [r4, #4]
 8005028:	68a1      	ldr	r1, [r4, #8]
 800502a:	f7ff ff81 	bl	8004f30 <psram_do_upgrade>
 800502e:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8005032:	490c      	ldr	r1, [pc, #48]	; (8005064 <psram_recover_firmware+0x9c>)
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8005034:	4b0c      	ldr	r3, [pc, #48]	; (8005068 <psram_recover_firmware+0xa0>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8005036:	68ca      	ldr	r2, [r1, #12]
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8005038:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 800503c:	4313      	orrs	r3, r2
 800503e:	60cb      	str	r3, [r1, #12]
 8005040:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 8005044:	bf00      	nop
 8005046:	e7fd      	b.n	8005044 <psram_recover_firmware+0x7c>
 8005048:	907ff800 	.word	0x907ff800
 800504c:	dbcc8350 	.word	0xdbcc8350
 8005050:	bafcfba3 	.word	0xbafcfba3
 8005054:	903fffff 	.word	0x903fffff
 8005058:	0800e4f7 	.word	0x0800e4f7
 800505c:	0800e501 	.word	0x0800e501
 8005060:	0800e50d 	.word	0x0800e50d
 8005064:	e000ed00 	.word	0xe000ed00
 8005068:	05fa0004 	.word	0x05fa0004

0800506c <sdcard_light>:
// sdcard_light()
//
    void inline
sdcard_light(bool on)
{
    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7, !!on);    // turn LED off
 800506c:	4602      	mov	r2, r0
 800506e:	2180      	movs	r1, #128	; 0x80
 8005070:	4801      	ldr	r0, [pc, #4]	; (8005078 <sdcard_light+0xc>)
 8005072:	f7fc b921 	b.w	80012b8 <HAL_GPIO_WritePin>
 8005076:	bf00      	nop
 8005078:	48000800 	.word	0x48000800

0800507c <sdcard_is_inserted>:

// sdcard_is_inserted()
//
    bool
sdcard_is_inserted(void)
{
 800507c:	b508      	push	{r3, lr}
    return !!HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13); 
 800507e:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8005082:	4803      	ldr	r0, [pc, #12]	; (8005090 <sdcard_is_inserted+0x14>)
 8005084:	f7fc f912 	bl	80012ac <HAL_GPIO_ReadPin>
}
 8005088:	3000      	adds	r0, #0
 800508a:	bf18      	it	ne
 800508c:	2001      	movne	r0, #1
 800508e:	bd08      	pop	{r3, pc}
 8005090:	48000800 	.word	0x48000800

08005094 <sdcard_try_file>:

// sdcard_try_file()
//
    void
sdcard_try_file(uint32_t blk_pos)
{
 8005094:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005096:	4604      	mov	r4, r0
 8005098:	b08b      	sub	sp, #44	; 0x2c
    oled_show(screen_verify);
 800509a:	4829      	ldr	r0, [pc, #164]	; (8005140 <sdcard_try_file+0xac>)
 800509c:	f7fb feaa 	bl	8000df4 <oled_show>

    // read full possible file into PSRAM, assume continguous, and big enough
    uint8_t *tmp = (uint8_t *)PSRAM_BASE;
    
    int rv = HAL_SD_ReadBlocks(&hsd, tmp, blk_pos, FW_MAX_LENGTH_MK4 / 512, 60000);
 80050a0:	f64e 2360 	movw	r3, #60000	; 0xea60
 80050a4:	9300      	str	r3, [sp, #0]
 80050a6:	4622      	mov	r2, r4
 80050a8:	f44f 6370 	mov.w	r3, #3840	; 0xf00
 80050ac:	f04f 4110 	mov.w	r1, #2415919104	; 0x90000000
 80050b0:	4824      	ldr	r0, [pc, #144]	; (8005144 <sdcard_try_file+0xb0>)
 80050b2:	f006 fde3 	bl	800bc7c <HAL_SD_ReadBlocks>
    if(rv != HAL_OK) return;
 80050b6:	2800      	cmp	r0, #0
 80050b8:	d140      	bne.n	800513c <sdcard_try_file+0xa8>
    } DFUElement_t;

    const DFUFile_t   *file = (const DFUFile_t *)ptr;
    ptr += sizeof(DFUFile_t);

    for(int idx=0; idx<file->targets; idx++) {
 80050ba:	f04f 4310 	mov.w	r3, #2415919104	; 0x90000000

        for(int ei=0; ei<target->elements; ei++) {
            const DFUElement_t   *elem = (const DFUElement_t *)ptr;
            ptr += sizeof(DFUElement_t);

            if(elem->addr == FIRMWARE_START) {
 80050be:	4d22      	ldr	r5, [pc, #136]	; (8005148 <sdcard_try_file+0xb4>)
    } DFUElement_t;

    const DFUFile_t   *file = (const DFUFile_t *)ptr;
    ptr += sizeof(DFUFile_t);

    for(int idx=0; idx<file->targets; idx++) {
 80050c0:	7a99      	ldrb	r1, [r3, #10]
 80050c2:	330b      	adds	r3, #11
 80050c4:	4288      	cmp	r0, r1
 80050c6:	da18      	bge.n	80050fa <sdcard_try_file+0x66>
        const DFUTarget_t   *target = (const DFUTarget_t *)ptr;
        ptr += sizeof(DFUTarget_t);

        for(int ei=0; ei<target->elements; ei++) {
 80050c8:	f8d3 610e 	ldr.w	r6, [r3, #270]	; 0x10e
 80050cc:	2200      	movs	r2, #0
    const DFUFile_t   *file = (const DFUFile_t *)ptr;
    ptr += sizeof(DFUFile_t);

    for(int idx=0; idx<file->targets; idx++) {
        const DFUTarget_t   *target = (const DFUTarget_t *)ptr;
        ptr += sizeof(DFUTarget_t);
 80050ce:	f503 7389 	add.w	r3, r3, #274	; 0x112

        for(int ei=0; ei<target->elements; ei++) {
 80050d2:	4296      	cmp	r6, r2
 80050d4:	d00f      	beq.n	80050f6 <sdcard_try_file+0x62>
            const DFUElement_t   *elem = (const DFUElement_t *)ptr;
            ptr += sizeof(DFUElement_t);

            if(elem->addr == FIRMWARE_START) {
 80050d6:	681f      	ldr	r7, [r3, #0]
 80050d8:	42af      	cmp	r7, r5
        const DFUTarget_t   *target = (const DFUTarget_t *)ptr;
        ptr += sizeof(DFUTarget_t);

        for(int ei=0; ei<target->elements; ei++) {
            const DFUElement_t   *elem = (const DFUElement_t *)ptr;
            ptr += sizeof(DFUElement_t);
 80050da:	f103 0408 	add.w	r4, r3, #8

            if(elem->addr == FIRMWARE_START) {
 80050de:	d107      	bne.n	80050f0 <sdcard_try_file+0x5c>
                *target_size = elem->size;
 80050e0:	685d      	ldr	r5, [r3, #4]
    uint32_t    len = 0;
    const uint8_t *start = dfu_hdr_parse(tmp, &len);
    if(!start) return;

    uint8_t world_check[32];
    bool ok = verify_firmware_in_ram(start, len, world_check);
 80050e2:	aa02      	add	r2, sp, #8
 80050e4:	4629      	mov	r1, r5
 80050e6:	4620      	mov	r0, r4
 80050e8:	f7fc fdd6 	bl	8001c98 <verify_firmware_in_ram>

    // msg already printed, if corrupt image
    if(!ok) return;
 80050ec:	b330      	cbz	r0, 800513c <sdcard_try_file+0xa8>
 80050ee:	e006      	b.n	80050fe <sdcard_try_file+0x6a>

    for(int idx=0; idx<file->targets; idx++) {
        const DFUTarget_t   *target = (const DFUTarget_t *)ptr;
        ptr += sizeof(DFUTarget_t);

        for(int ei=0; ei<target->elements; ei++) {
 80050f0:	3201      	adds	r2, #1
            const DFUElement_t   *elem = (const DFUElement_t *)ptr;
            ptr += sizeof(DFUElement_t);
 80050f2:	4623      	mov	r3, r4
 80050f4:	e7ed      	b.n	80050d2 <sdcard_try_file+0x3e>
    } DFUElement_t;

    const DFUFile_t   *file = (const DFUFile_t *)ptr;
    ptr += sizeof(DFUFile_t);

    for(int idx=0; idx<file->targets; idx++) {
 80050f6:	3001      	adds	r0, #1
 80050f8:	e7e4      	b.n	80050c4 <sdcard_try_file+0x30>
        }
    }

    // Mk3 and earlier firmwares will fail here because the load address is
    // different from Mk4 images.
    puts("DFU parse fail");
 80050fa:	4814      	ldr	r0, [pc, #80]	; (800514c <sdcard_try_file+0xb8>)
 80050fc:	e007      	b.n	800510e <sdcard_try_file+0x7a>

    // msg already printed, if corrupt image
    if(!ok) return;

    // it is a valid, signed image
    puts("good firmware");
 80050fe:	4814      	ldr	r0, [pc, #80]	; (8005150 <sdcard_try_file+0xbc>)
 8005100:	f7ff fddc 	bl	8004cbc <puts>

    // Check we have the **right** firmware, based on the world check sum
    // but don't set the light at this point.
    // - this includes check over bootrom (ourselves)
    if(!verify_world_checksum(world_check)) {
 8005104:	a802      	add	r0, sp, #8
 8005106:	f7fc fe17 	bl	8001d38 <verify_world_checksum>
 800510a:	b918      	cbnz	r0, 8005114 <sdcard_try_file+0x80>
        puts("wrong world");
 800510c:	4811      	ldr	r0, [pc, #68]	; (8005154 <sdcard_try_file+0xc0>)
 800510e:	f7ff fdd5 	bl	8004cbc <puts>
 8005112:	e013      	b.n	800513c <sdcard_try_file+0xa8>
        return;
    }

    sdcard_light(false);
 8005114:	2000      	movs	r0, #0
 8005116:	f7ff ffa9 	bl	800506c <sdcard_light>

    // Do the upgrade, using PSRAM data.
    psram_do_upgrade(start, len);
 800511a:	4629      	mov	r1, r5
 800511c:	4620      	mov	r0, r4
 800511e:	f7ff ff07 	bl	8004f30 <psram_do_upgrade>
 8005122:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8005126:	490c      	ldr	r1, [pc, #48]	; (8005158 <sdcard_try_file+0xc4>)
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8005128:	4b0c      	ldr	r3, [pc, #48]	; (800515c <sdcard_try_file+0xc8>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800512a:	68ca      	ldr	r2, [r1, #12]
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800512c:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8005130:	4313      	orrs	r3, r2
 8005132:	60cb      	str	r3, [r1, #12]
 8005134:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 8005138:	bf00      	nop
 800513a:	e7fd      	b.n	8005138 <sdcard_try_file+0xa4>

    // done
    NVIC_SystemReset();
}
 800513c:	b00b      	add	sp, #44	; 0x2c
 800513e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005140:	0800d62a 	.word	0x0800d62a
 8005144:	200003c4 	.word	0x200003c4
 8005148:	08020000 	.word	0x08020000
 800514c:	0800e544 	.word	0x0800e544
 8005150:	0800e553 	.word	0x0800e553
 8005154:	0800e561 	.word	0x0800e561
 8005158:	e000ed00 	.word	0xe000ed00
 800515c:	05fa0004 	.word	0x05fa0004

08005160 <sdcard_search>:

// sdcard_search()
//
    void
sdcard_search(void)
{
 8005160:	b5f0      	push	{r4, r5, r6, r7, lr}
    oled_show(screen_search);
 8005162:	4850      	ldr	r0, [pc, #320]	; (80052a4 <sdcard_search+0x144>)

// sdcard_search()
//
    void
sdcard_search(void)
{
 8005164:	f5ad 7d05 	sub.w	sp, sp, #532	; 0x214
    oled_show(screen_search);
 8005168:	f7fb fe44 	bl	8000df4 <oled_show>

    if(!sdcard_is_inserted()) return;
 800516c:	f7ff ff86 	bl	800507c <sdcard_is_inserted>
 8005170:	2800      	cmp	r0, #0
 8005172:	f000 8094 	beq.w	800529e <sdcard_search+0x13e>
    static void
sdcard_setup(void)
{
    // pinout setup

    __HAL_RCC_SDMMC1_CLK_ENABLE();
 8005176:	4e4c      	ldr	r6, [pc, #304]	; (80052a8 <sdcard_search+0x148>)
    if(!sdcard_is_inserted()) return;

    uint32_t num_blocks;

    // open card (power it) and get details, do setup
    puts2("SDCard: ");
 8005178:	484c      	ldr	r0, [pc, #304]	; (80052ac <sdcard_search+0x14c>)

    __HAL_RCC_SDMMC1_CLK_ENABLE();

    // Configure pins: Port C: C8-C13, PD2=CMD
    // - C7 (light), and C13 (detect) already setup in gpio_setup
    {   GPIO_InitTypeDef setup = {
 800517a:	4c4d      	ldr	r4, [pc, #308]	; (80052b0 <sdcard_search+0x150>)
    if(!sdcard_is_inserted()) return;

    uint32_t num_blocks;

    // open card (power it) and get details, do setup
    puts2("SDCard: ");
 800517c:	f7ff fd10 	bl	8004ba0 <puts2>
    static void
sdcard_setup(void)
{
    // pinout setup

    __HAL_RCC_SDMMC1_CLK_ENABLE();
 8005180:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
 8005182:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8005186:	64f3      	str	r3, [r6, #76]	; 0x4c
 8005188:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
 800518a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800518e:	9303      	str	r3, [sp, #12]
 8005190:	9b03      	ldr	r3, [sp, #12]

    // Configure pins: Port C: C8-C13, PD2=CMD
    // - C7 (light), and C13 (detect) already setup in gpio_setup
    {   GPIO_InitTypeDef setup = {
 8005192:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8005194:	ad04      	add	r5, sp, #16
 8005196:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8005198:	f854 3b04 	ldr.w	r3, [r4], #4
            .Mode = GPIO_MODE_AF_PP,            // not sure
            .Pull = GPIO_PULLUP,
            .Speed = GPIO_SPEED_FREQ_VERY_HIGH,
            .Alternate = GPIO_AF12_SDMMC1,
        };
        HAL_GPIO_Init(GPIOC, &setup);
 800519c:	4845      	ldr	r0, [pc, #276]	; (80052b4 <sdcard_search+0x154>)

    __HAL_RCC_SDMMC1_CLK_ENABLE();

    // Configure pins: Port C: C8-C13, PD2=CMD
    // - C7 (light), and C13 (detect) already setup in gpio_setup
    {   GPIO_InitTypeDef setup = {
 800519e:	602b      	str	r3, [r5, #0]
            .Mode = GPIO_MODE_AF_PP,            // not sure
            .Pull = GPIO_PULLUP,
            .Speed = GPIO_SPEED_FREQ_VERY_HIGH,
            .Alternate = GPIO_AF12_SDMMC1,
        };
        HAL_GPIO_Init(GPIOC, &setup);
 80051a0:	a904      	add	r1, sp, #16
 80051a2:	f7fb ff0d 	bl	8000fc0 <HAL_GPIO_Init>
    }

    // PD2 = CMD
    {   GPIO_InitTypeDef setup = {
 80051a6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80051a8:	af04      	add	r7, sp, #16
 80051aa:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 80051ac:	6823      	ldr	r3, [r4, #0]
            .Mode = GPIO_MODE_AF_PP,            // not sure
            .Pull = GPIO_PULLUP,
            .Speed = GPIO_SPEED_FREQ_VERY_HIGH,
            .Alternate = GPIO_AF12_SDMMC1,
        };
        HAL_GPIO_Init(GPIOD, &setup);
 80051ae:	4842      	ldr	r0, [pc, #264]	; (80052b8 <sdcard_search+0x158>)
        };
        HAL_GPIO_Init(GPIOC, &setup);
    }

    // PD2 = CMD
    {   GPIO_InitTypeDef setup = {
 80051b0:	602b      	str	r3, [r5, #0]
            .Mode = GPIO_MODE_AF_PP,            // not sure
            .Pull = GPIO_PULLUP,
            .Speed = GPIO_SPEED_FREQ_VERY_HIGH,
            .Alternate = GPIO_AF12_SDMMC1,
        };
        HAL_GPIO_Init(GPIOD, &setup);
 80051b2:	a904      	add	r1, sp, #16
 80051b4:	f7fb ff04 	bl	8000fc0 <HAL_GPIO_Init>
    }

    // reset module
    __HAL_RCC_SDMMC1_FORCE_RESET();
 80051b8:	6af3      	ldr	r3, [r6, #44]	; 0x2c
// sdcard_probe()
//
    static bool
sdcard_probe(uint32_t *num_blocks)
{
    memset(&hsd, 0, sizeof(SD_HandleTypeDef));
 80051ba:	4c40      	ldr	r4, [pc, #256]	; (80052bc <sdcard_search+0x15c>)
        };
        HAL_GPIO_Init(GPIOD, &setup);
    }

    // reset module
    __HAL_RCC_SDMMC1_FORCE_RESET();
 80051bc:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 80051c0:	62f3      	str	r3, [r6, #44]	; 0x2c
    __HAL_RCC_SDMMC1_RELEASE_RESET();
 80051c2:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 80051c4:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 80051c8:	62f3      	str	r3, [r6, #44]	; 0x2c
// sdcard_probe()
//
    static bool
sdcard_probe(uint32_t *num_blocks)
{
    memset(&hsd, 0, sizeof(SD_HandleTypeDef));
 80051ca:	2280      	movs	r2, #128	; 0x80
 80051cc:	2100      	movs	r1, #0
 80051ce:	4620      	mov	r0, r4
 80051d0:	f008 f97d 	bl	800d4ce <memset>

    puts2("SDCard: ");
 80051d4:	4835      	ldr	r0, [pc, #212]	; (80052ac <sdcard_search+0x14c>)
 80051d6:	f7ff fce3 	bl	8004ba0 <puts2>

    hsd.Instance = SDMMC1;
 80051da:	4b39      	ldr	r3, [pc, #228]	; (80052c0 <sdcard_search+0x160>)
 80051dc:	6023      	str	r3, [r4, #0]
    hsd.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
 80051de:	2300      	movs	r3, #0
 80051e0:	6063      	str	r3, [r4, #4]
    hsd.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_ENABLE;
 80051e2:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    hsd.Init.BusWide = SDMMC_BUS_WIDE_1B;
 80051e6:	60e3      	str	r3, [r4, #12]
    hsd.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
 80051e8:	6123      	str	r3, [r4, #16]
    hsd.Init.ClockDiv = SDMMC_TRANSFER_CLK_DIV;

    int rv = HAL_SD_Init(&hsd);
 80051ea:	4620      	mov	r0, r4
    hsd.Instance = SDMMC1;
    hsd.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
    hsd.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_ENABLE;
    hsd.Init.BusWide = SDMMC_BUS_WIDE_1B;
    hsd.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
    hsd.Init.ClockDiv = SDMMC_TRANSFER_CLK_DIV;
 80051ec:	2303      	movs	r3, #3

    puts2("SDCard: ");

    hsd.Instance = SDMMC1;
    hsd.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
    hsd.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_ENABLE;
 80051ee:	60a2      	str	r2, [r4, #8]
    hsd.Init.BusWide = SDMMC_BUS_WIDE_1B;
    hsd.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
    hsd.Init.ClockDiv = SDMMC_TRANSFER_CLK_DIV;
 80051f0:	6163      	str	r3, [r4, #20]

    int rv = HAL_SD_Init(&hsd);
 80051f2:	f007 fad3 	bl	800c79c <HAL_SD_Init>
    if(rv != HAL_OK) {
 80051f6:	4605      	mov	r5, r0
 80051f8:	b108      	cbz	r0, 80051fe <sdcard_search+0x9e>
        puts("init fail");
 80051fa:	4832      	ldr	r0, [pc, #200]	; (80052c4 <sdcard_search+0x164>)
 80051fc:	e02e      	b.n	800525c <sdcard_search+0xfc>
        return false;
    }

    sdcard_light(true);
 80051fe:	2001      	movs	r0, #1
 8005200:	f7ff ff34 	bl	800506c <sdcard_light>

    rv = HAL_SD_ConfigSpeedBusOperation(&hsd, SDMMC_SPEED_MODE_AUTO);
 8005204:	4629      	mov	r1, r5
 8005206:	4620      	mov	r0, r4
 8005208:	f007 fb9a 	bl	800c940 <HAL_SD_ConfigSpeedBusOperation>
    if(rv != HAL_OK) {
 800520c:	b108      	cbz	r0, 8005212 <sdcard_search+0xb2>
        puts("speed");
 800520e:	482e      	ldr	r0, [pc, #184]	; (80052c8 <sdcard_search+0x168>)
 8005210:	e024      	b.n	800525c <sdcard_search+0xfc>
        return false;
    }

    // configure the SD bus width for 4-bit wide operation
    rv = HAL_SD_ConfigWideBusOperation(&hsd, SDMMC_BUS_WIDE_4B);
 8005212:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8005216:	4620      	mov	r0, r4
 8005218:	f007 f9ee 	bl	800c5f8 <HAL_SD_ConfigWideBusOperation>
    if(rv != HAL_OK) {
 800521c:	4605      	mov	r5, r0
 800521e:	b108      	cbz	r0, 8005224 <sdcard_search+0xc4>
        puts("wide");
 8005220:	482a      	ldr	r0, [pc, #168]	; (80052cc <sdcard_search+0x16c>)
 8005222:	e01b      	b.n	800525c <sdcard_search+0xfc>
        return false;
    }

    if(hsd.SdCard.BlockSize != 512) {
 8005224:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8005226:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800522a:	d001      	beq.n	8005230 <sdcard_search+0xd0>
        puts("bsize?");
 800522c:	4828      	ldr	r0, [pc, #160]	; (80052d0 <sdcard_search+0x170>)
 800522e:	e015      	b.n	800525c <sdcard_search+0xfc>
        return false;
    }

    *num_blocks = hsd.SdCard.BlockNbr;

    puts("ok");
 8005230:	4828      	ldr	r0, [pc, #160]	; (80052d4 <sdcard_search+0x174>)
    if(hsd.SdCard.BlockSize != 512) {
        puts("bsize?");
        return false;
    }

    *num_blocks = hsd.SdCard.BlockNbr;
 8005232:	6ce6      	ldr	r6, [r4, #76]	; 0x4c

    puts("ok");
 8005234:	f7ff fd42 	bl	8004cbc <puts>
 8005238:	462c      	mov	r4, r5
 800523a:	e002      	b.n	8005242 <sdcard_search+0xe2>
            sdcard_try_file(pos);

            goto redraw;
        }

        if(pos % 128 == 0) {
 800523c:	0663      	lsls	r3, r4, #25
 800523e:	d023      	beq.n	8005288 <sdcard_search+0x128>
    puts2("SDCard: ");
    sdcard_setup();
    if(!sdcard_probe(&num_blocks)) return;

    uint8_t     blk[512];
    for(int pos=0; pos<num_blocks; pos += 1) {
 8005240:	3401      	adds	r4, #1
 8005242:	42b4      	cmp	r4, r6
 8005244:	d02b      	beq.n	800529e <sdcard_search+0x13e>
        // read a single block
        int rv = HAL_SD_ReadBlocks(&hsd, blk, pos, 1, 60000);
 8005246:	f64e 2360 	movw	r3, #60000	; 0xea60
 800524a:	9300      	str	r3, [sp, #0]
 800524c:	4622      	mov	r2, r4
 800524e:	2301      	movs	r3, #1
 8005250:	a904      	add	r1, sp, #16
 8005252:	481a      	ldr	r0, [pc, #104]	; (80052bc <sdcard_search+0x15c>)
 8005254:	f006 fd12 	bl	800bc7c <HAL_SD_ReadBlocks>
        if(rv != HAL_OK) {
 8005258:	b118      	cbz	r0, 8005262 <sdcard_search+0x102>
            puts("fail read");
 800525a:	481f      	ldr	r0, [pc, #124]	; (80052d8 <sdcard_search+0x178>)
 800525c:	f7ff fd2e 	bl	8004cbc <puts>

            return;
 8005260:	e01d      	b.n	800529e <sdcard_search+0x13e>
        }

        if(memcmp(blk, "DfuSe", 5) == 0) {
 8005262:	2205      	movs	r2, #5
 8005264:	491d      	ldr	r1, [pc, #116]	; (80052dc <sdcard_search+0x17c>)
 8005266:	a804      	add	r0, sp, #16
 8005268:	f008 f8fc 	bl	800d464 <memcmp>
 800526c:	2800      	cmp	r0, #0
 800526e:	d1e5      	bne.n	800523c <sdcard_search+0xdc>
            // candidate file found
            puts2("found @ ");
 8005270:	481b      	ldr	r0, [pc, #108]	; (80052e0 <sdcard_search+0x180>)
 8005272:	f7ff fc95 	bl	8004ba0 <puts2>
            puthex8(pos);
 8005276:	4620      	mov	r0, r4
 8005278:	f7ff fcee 	bl	8004c58 <puthex8>
            putchar('\n');
 800527c:	200a      	movs	r0, #10
 800527e:	f7ff fca3 	bl	8004bc8 <putchar>

            sdcard_try_file(pos);
 8005282:	4620      	mov	r0, r4
 8005284:	f7ff ff06 	bl	8005094 <sdcard_try_file>
            goto redraw;
        }

        if(pos % 128 == 0) {
        redraw:
            oled_show_progress(screen_search, pos*100 / num_blocks);
 8005288:	2164      	movs	r1, #100	; 0x64
 800528a:	4361      	muls	r1, r4
 800528c:	4805      	ldr	r0, [pc, #20]	; (80052a4 <sdcard_search+0x144>)
 800528e:	fbb1 f1f6 	udiv	r1, r1, r6
 8005292:	f7fb fdf1 	bl	8000e78 <oled_show_progress>
            sdcard_light(true);
 8005296:	2001      	movs	r0, #1
 8005298:	f7ff fee8 	bl	800506c <sdcard_light>
 800529c:	e7d0      	b.n	8005240 <sdcard_search+0xe0>
        }
    }

}
 800529e:	f50d 7d05 	add.w	sp, sp, #532	; 0x214
 80052a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80052a4:	0800dec5 	.word	0x0800dec5
 80052a8:	40021000 	.word	0x40021000
 80052ac:	0800e56d 	.word	0x0800e56d
 80052b0:	0800e51c 	.word	0x0800e51c
 80052b4:	48000800 	.word	0x48000800
 80052b8:	48000c00 	.word	0x48000c00
 80052bc:	200003c4 	.word	0x200003c4
 80052c0:	50062400 	.word	0x50062400
 80052c4:	0800e576 	.word	0x0800e576
 80052c8:	0800e580 	.word	0x0800e580
 80052cc:	0800e586 	.word	0x0800e586
 80052d0:	0800e58b 	.word	0x0800e58b
 80052d4:	0800e592 	.word	0x0800e592
 80052d8:	0800e595 	.word	0x0800e595
 80052dc:	0800e59f 	.word	0x0800e59f
 80052e0:	0800e5a5 	.word	0x0800e5a5

080052e4 <sdcard_recovery>:

// sdcard_recovery()
//
    void
sdcard_recovery(void)
{
 80052e4:	b508      	push	{r3, lr}
    // Use SDCard to recover. Must be precise version they tried to
    // install before, and will be slow AF.

    puts("Recovery mode.");
 80052e6:	480b      	ldr	r0, [pc, #44]	; (8005314 <sdcard_recovery+0x30>)
 80052e8:	f7ff fce8 	bl	8004cbc <puts>

    while(1) {
        // .. need them to insert a card
        
        sdcard_light(false);
 80052ec:	2000      	movs	r0, #0
 80052ee:	f7ff febd 	bl	800506c <sdcard_light>
        while(!sdcard_is_inserted()) {
 80052f2:	f7ff fec3 	bl	800507c <sdcard_is_inserted>
 80052f6:	b930      	cbnz	r0, 8005306 <sdcard_recovery+0x22>
            oled_show(screen_recovery);
 80052f8:	4807      	ldr	r0, [pc, #28]	; (8005318 <sdcard_recovery+0x34>)
 80052fa:	f7fb fd7b 	bl	8000df4 <oled_show>
            delay_ms(200);
 80052fe:	20c8      	movs	r0, #200	; 0xc8
 8005300:	f7fe fac6 	bl	8003890 <delay_ms>
 8005304:	e7f5      	b.n	80052f2 <sdcard_recovery+0xe>
        }
            
        // look for binary, will reset system if successful
        sdcard_light(true);
 8005306:	2001      	movs	r0, #1
 8005308:	f7ff feb0 	bl	800506c <sdcard_light>
        sdcard_search();
 800530c:	f7ff ff28 	bl	8005160 <sdcard_search>
    }
 8005310:	e7ec      	b.n	80052ec <sdcard_recovery+0x8>
 8005312:	bf00      	nop
 8005314:	0800e5ae 	.word	0x0800e5ae
 8005318:	0800dff5 	.word	0x0800dff5

0800531c <HAL_HASHEx_SHA256_Accmlt>:
#include <string.h>

// so we don't need stm32l4xx_hal_hash_ex.c
HAL_StatusTypeDef HAL_HASHEx_SHA256_Accmlt(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
  return HASH_Accumulate(hhash, pInBuffer, Size,HASH_ALGOSELECTION_SHA256);
 800531c:	4b01      	ldr	r3, [pc, #4]	; (8005324 <HAL_HASHEx_SHA256_Accmlt+0x8>)
 800531e:	f005 b9e3 	b.w	800a6e8 <HASH_Accumulate>
 8005322:	bf00      	nop
 8005324:	00040080 	.word	0x00040080

08005328 <HAL_HASHEx_SHA256_Start>:
}

HAL_StatusTypeDef HAL_HASHEx_SHA256_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout)
{
 8005328:	b513      	push	{r0, r1, r4, lr}
  return HASH_Start(hhash, pInBuffer, Size, pOutBuffer, Timeout, HASH_ALGOSELECTION_SHA256);
 800532a:	4c04      	ldr	r4, [pc, #16]	; (800533c <HAL_HASHEx_SHA256_Start+0x14>)
 800532c:	9401      	str	r4, [sp, #4]
 800532e:	9c04      	ldr	r4, [sp, #16]
 8005330:	9400      	str	r4, [sp, #0]
 8005332:	f005 f933 	bl	800a59c <HASH_Start>
}
 8005336:	b002      	add	sp, #8
 8005338:	bd10      	pop	{r4, pc}
 800533a:	bf00      	nop
 800533c:	00040080 	.word	0x00040080

08005340 <HAL_HMACEx_SHA256_Start>:

HAL_StatusTypeDef HAL_HMACEx_SHA256_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout)
{
 8005340:	b513      	push	{r0, r1, r4, lr}
  return HMAC_Start(hhash, pInBuffer, Size, pOutBuffer, Timeout, HASH_ALGOSELECTION_SHA256);
 8005342:	4c04      	ldr	r4, [pc, #16]	; (8005354 <HAL_HMACEx_SHA256_Start+0x14>)
 8005344:	9401      	str	r4, [sp, #4]
 8005346:	9c04      	ldr	r4, [sp, #16]
 8005348:	9400      	str	r4, [sp, #0]
 800534a:	f005 fb79 	bl	800aa40 <HMAC_Start>
}
 800534e:	b002      	add	sp, #8
 8005350:	bd10      	pop	{r4, pc}
 8005352:	bf00      	nop
 8005354:	00040080 	.word	0x00040080

08005358 <sha256_init>:

void sha256_init(SHA256_CTX *ctx)
{
 8005358:	b510      	push	{r4, lr}
    memset(ctx, 0, sizeof(SHA256_CTX));
 800535a:	224c      	movs	r2, #76	; 0x4c
{
  return HMAC_Start(hhash, pInBuffer, Size, pOutBuffer, Timeout, HASH_ALGOSELECTION_SHA256);
}

void sha256_init(SHA256_CTX *ctx)
{
 800535c:	4604      	mov	r4, r0
    memset(ctx, 0, sizeof(SHA256_CTX));
 800535e:	2100      	movs	r1, #0
 8005360:	f008 f8b5 	bl	800d4ce <memset>

#if 1
    ctx->num_pending = 0;
 8005364:	2300      	movs	r3, #0
 8005366:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
    ctx->hh.Init.DataType = HASH_DATATYPE_8B;
 800536a:	2320      	movs	r3, #32
 800536c:	6023      	str	r3, [r4, #0]
    HAL_HASH_Init(&ctx->hh);
 800536e:	4620      	mov	r0, r4
    __HAL_HASH_RESET_MDMAT();

    MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT,
            HASH_ALGOSELECTION_SHA256 | HASH_CR_INIT);
#endif
}
 8005370:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    memset(ctx, 0, sizeof(SHA256_CTX));

#if 1
    ctx->num_pending = 0;
    ctx->hh.Init.DataType = HASH_DATATYPE_8B;
    HAL_HASH_Init(&ctx->hh);
 8005374:	f004 bf9c 	b.w	800a2b0 <HAL_HASH_Init>

08005378 <sha256_update>:
            HASH_ALGOSELECTION_SHA256 | HASH_CR_INIT);
#endif
}

void sha256_update(SHA256_CTX *ctx, const uint8_t data[], uint32_t len)
{
 8005378:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    HAL_StatusTypeDef rv;

    // clear out any pending bytes
    if(ctx->num_pending + len >= 4) {
 800537a:	f890 3048 	ldrb.w	r3, [r0, #72]	; 0x48
 800537e:	4413      	add	r3, r2
 8005380:	2b03      	cmp	r3, #3
            HASH_ALGOSELECTION_SHA256 | HASH_CR_INIT);
#endif
}

void sha256_update(SHA256_CTX *ctx, const uint8_t data[], uint32_t len)
{
 8005382:	4605      	mov	r5, r0
 8005384:	460e      	mov	r6, r1
 8005386:	4614      	mov	r4, r2
    HAL_StatusTypeDef rv;

    // clear out any pending bytes
    if(ctx->num_pending + len >= 4) {
 8005388:	d91c      	bls.n	80053c4 <sha256_update+0x4c>
        while(ctx->num_pending != 4) {
 800538a:	f895 3048 	ldrb.w	r3, [r5, #72]	; 0x48
 800538e:	2b04      	cmp	r3, #4
 8005390:	d009      	beq.n	80053a6 <sha256_update+0x2e>
            ctx->pending[ctx->num_pending++] = *data;
 8005392:	1c5a      	adds	r2, r3, #1
 8005394:	f885 2048 	strb.w	r2, [r5, #72]	; 0x48
 8005398:	442b      	add	r3, r5
 800539a:	f816 2b01 	ldrb.w	r2, [r6], #1
 800539e:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
            data += 1;
            len -= 1;
            if(!len) break;
 80053a2:	3c01      	subs	r4, #1
 80053a4:	d1f1      	bne.n	800538a <sha256_update+0x12>
        }
        if(ctx->num_pending == 4) {
 80053a6:	f895 2048 	ldrb.w	r2, [r5, #72]	; 0x48
 80053aa:	2a04      	cmp	r2, #4
 80053ac:	d10a      	bne.n	80053c4 <sha256_update+0x4c>
#if 1
            rv = HAL_HASHEx_SHA256_Accumulate(&ctx->hh, ctx->pending, 4);
 80053ae:	f105 0144 	add.w	r1, r5, #68	; 0x44
 80053b2:	4628      	mov	r0, r5
 80053b4:	f7ff ffb2 	bl	800531c <HAL_HASHEx_SHA256_Accmlt>
            ASSERT(rv == HAL_OK);
 80053b8:	b110      	cbz	r0, 80053c0 <sha256_update+0x48>
 80053ba:	4811      	ldr	r0, [pc, #68]	; (8005400 <sha256_update+0x88>)
 80053bc:	f7fb fb0e 	bl	80009dc <fatal_error>
#else
            HASH->DIN = *(uint32_t*)&ctx->pending;
#endif
            ctx->num_pending = 0;
 80053c0:	f885 0048 	strb.w	r0, [r5, #72]	; 0x48
        }
    }

    // write full blocks
    uint32_t blocks = len / 4;
    if(blocks) {
 80053c4:	08a7      	lsrs	r7, r4, #2
 80053c6:	d00b      	beq.n	80053e0 <sha256_update+0x68>
#if 1
        rv = HAL_HASHEx_SHA256_Accumulate(&ctx->hh, (uint8_t *)data, blocks*4);
 80053c8:	00bf      	lsls	r7, r7, #2
 80053ca:	463a      	mov	r2, r7
 80053cc:	4631      	mov	r1, r6
 80053ce:	4628      	mov	r0, r5
 80053d0:	f7ff ffa4 	bl	800531c <HAL_HASHEx_SHA256_Accmlt>
        ASSERT(rv == HAL_OK);
 80053d4:	2800      	cmp	r0, #0
 80053d6:	d1f0      	bne.n	80053ba <sha256_update+0x42>
            uint32_t    tmp;
            memcpy(&tmp, data, 4);
            HASH->DIN = tmp;
        }
#endif
        len -= blocks*4;
 80053d8:	1be4      	subs	r4, r4, r7
        data += blocks*4;
    }

    // save runt for later
    ASSERT(len <= 3);
 80053da:	2c03      	cmp	r4, #3
            memcpy(&tmp, data, 4);
            HASH->DIN = tmp;
        }
#endif
        len -= blocks*4;
        data += blocks*4;
 80053dc:	443e      	add	r6, r7
    }

    // save runt for later
    ASSERT(len <= 3);
 80053de:	d8ec      	bhi.n	80053ba <sha256_update+0x42>
 80053e0:	4434      	add	r4, r6
    while(len) {
 80053e2:	42a6      	cmp	r6, r4
 80053e4:	d00a      	beq.n	80053fc <sha256_update+0x84>
        ctx->pending[ctx->num_pending++] = *data;
 80053e6:	f895 3048 	ldrb.w	r3, [r5, #72]	; 0x48
 80053ea:	1c5a      	adds	r2, r3, #1
 80053ec:	f885 2048 	strb.w	r2, [r5, #72]	; 0x48
 80053f0:	442b      	add	r3, r5
 80053f2:	f816 2b01 	ldrb.w	r2, [r6], #1
 80053f6:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 80053fa:	e7f2      	b.n	80053e2 <sha256_update+0x6a>
        data++;
        len--;
    }
}
 80053fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80053fe:	bf00      	nop
 8005400:	0800d558 	.word	0x0800d558

08005404 <sha256_final>:

void sha256_final(SHA256_CTX *ctx, uint8_t digest[32])
{
 8005404:	b513      	push	{r0, r1, r4, lr}
    // Do final 0-3 bytes, pad and return digest.
#if 1
    HAL_StatusTypeDef rv = HAL_HASHEx_SHA256_Start(&ctx->hh,
 8005406:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800540a:	f890 2048 	ldrb.w	r2, [r0, #72]	; 0x48
 800540e:	9300      	str	r3, [sp, #0]
 8005410:	460b      	mov	r3, r1
 8005412:	f100 0144 	add.w	r1, r0, #68	; 0x44
 8005416:	f7ff ff87 	bl	8005328 <HAL_HASHEx_SHA256_Start>
                                ctx->pending, ctx->num_pending, digest, HAL_MAX_DELAY);
    ASSERT(rv == HAL_OK);
 800541a:	b110      	cbz	r0, 8005422 <sha256_final+0x1e>
 800541c:	4802      	ldr	r0, [pc, #8]	; (8005428 <sha256_final+0x24>)
 800541e:	f7fb fadd 	bl	80009dc <fatal_error>
    tmp = __REV(HASH_DIGEST->HR[6]);
    memcpy(out, &tmp, 4); out += 4;
    tmp = __REV(HASH_DIGEST->HR[7]);
    memcpy(out, &tmp, 4);
#endif
}
 8005422:	b002      	add	sp, #8
 8005424:	bd10      	pop	{r4, pc}
 8005426:	bf00      	nop
 8005428:	0800d558 	.word	0x0800d558

0800542c <sha256_single>:
//
// single-shot version (best)
//
    void
sha256_single(const uint8_t data[], uint32_t len, uint8_t digest[32])
{
 800542c:	b570      	push	{r4, r5, r6, lr}
 800542e:	b094      	sub	sp, #80	; 0x50
 8005430:	4604      	mov	r4, r0
 8005432:	460d      	mov	r5, r1
 8005434:	4616      	mov	r6, r2
    HASH_HandleTypeDef  hh = {0};
 8005436:	2100      	movs	r1, #0
 8005438:	2244      	movs	r2, #68	; 0x44
 800543a:	a803      	add	r0, sp, #12
 800543c:	f008 f847 	bl	800d4ce <memset>

    hh.Init.DataType = HASH_DATATYPE_8B;
 8005440:	2320      	movs	r3, #32

    HAL_HASH_Init(&hh);
 8005442:	a803      	add	r0, sp, #12
    void
sha256_single(const uint8_t data[], uint32_t len, uint8_t digest[32])
{
    HASH_HandleTypeDef  hh = {0};

    hh.Init.DataType = HASH_DATATYPE_8B;
 8005444:	9303      	str	r3, [sp, #12]

    HAL_HASH_Init(&hh);
 8005446:	f004 ff33 	bl	800a2b0 <HAL_HASH_Init>

    // It's called "Start" but it handles the runt packet, so really can only
    // be used once at end of message, or for whole message.
    HAL_StatusTypeDef rv = HAL_HASHEx_SHA256_Start(&hh, (uint8_t *)data, len,
 800544a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800544e:	9300      	str	r3, [sp, #0]
 8005450:	462a      	mov	r2, r5
 8005452:	4633      	mov	r3, r6
 8005454:	4621      	mov	r1, r4
 8005456:	a803      	add	r0, sp, #12
 8005458:	f7ff ff66 	bl	8005328 <HAL_HASHEx_SHA256_Start>
                                                    digest, HAL_MAX_DELAY);
    ASSERT(rv == HAL_OK);
 800545c:	b110      	cbz	r0, 8005464 <sha256_single+0x38>
 800545e:	4802      	ldr	r0, [pc, #8]	; (8005468 <sha256_single+0x3c>)
 8005460:	f7fb fabc 	bl	80009dc <fatal_error>
}
 8005464:	b014      	add	sp, #80	; 0x50
 8005466:	bd70      	pop	{r4, r5, r6, pc}
 8005468:	0800d558 	.word	0x0800d558

0800546c <hmac_sha256_init>:
// hmac_sha256_init()
//
    void
hmac_sha256_init(HMAC_CTX *ctx)
{
    memset(ctx, 0, sizeof(HMAC_CTX));
 800546c:	f44f 7282 	mov.w	r2, #260	; 0x104
 8005470:	2100      	movs	r1, #0
 8005472:	f008 b82c 	b.w	800d4ce <memset>
	...

08005478 <hmac_sha256_update>:

// hmac_sha256_update()
//
    void
hmac_sha256_update(HMAC_CTX *ctx, const uint8_t data[], uint32_t len)
{
 8005478:	b538      	push	{r3, r4, r5, lr}
 800547a:	4604      	mov	r4, r0
    // simple append
    ASSERT(ctx->num_pending + len < sizeof(ctx->pending));
 800547c:	f8d0 0100 	ldr.w	r0, [r0, #256]	; 0x100
 8005480:	1883      	adds	r3, r0, r2
 8005482:	2bff      	cmp	r3, #255	; 0xff

// hmac_sha256_update()
//
    void
hmac_sha256_update(HMAC_CTX *ctx, const uint8_t data[], uint32_t len)
{
 8005484:	4615      	mov	r5, r2
    // simple append
    ASSERT(ctx->num_pending + len < sizeof(ctx->pending));
 8005486:	d902      	bls.n	800548e <hmac_sha256_update+0x16>
 8005488:	4805      	ldr	r0, [pc, #20]	; (80054a0 <hmac_sha256_update+0x28>)
 800548a:	f7fb faa7 	bl	80009dc <fatal_error>

    memcpy(ctx->pending+ctx->num_pending, data, len);
 800548e:	4420      	add	r0, r4
 8005490:	f007 fff7 	bl	800d482 <memcpy>

    ctx->num_pending += len;
 8005494:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
 8005498:	441d      	add	r5, r3
 800549a:	f8c4 5100 	str.w	r5, [r4, #256]	; 0x100
 800549e:	bd38      	pop	{r3, r4, r5, pc}
 80054a0:	0800d558 	.word	0x0800d558

080054a4 <hmac_sha256_final>:

// hmac_sha256_final()
//
    void
hmac_sha256_final(HMAC_CTX *ctx, const uint8_t key[32], uint8_t digest[32])
{
 80054a4:	b570      	push	{r4, r5, r6, lr}
 80054a6:	b094      	sub	sp, #80	; 0x50
 80054a8:	4604      	mov	r4, r0
 80054aa:	460e      	mov	r6, r1
 80054ac:	4615      	mov	r5, r2
    HASH_HandleTypeDef  hh = {0};
 80054ae:	2100      	movs	r1, #0
 80054b0:	2244      	movs	r2, #68	; 0x44
 80054b2:	a803      	add	r0, sp, #12
 80054b4:	f008 f80b 	bl	800d4ce <memset>

    hh.Init.DataType = HASH_DATATYPE_8B;
 80054b8:	2220      	movs	r2, #32
    hh.Init.pKey = (uint8_t *)key;      // const viol due to API dumbness
    hh.Init.KeySize = 32;

    HAL_HASH_Init(&hh);
 80054ba:	a803      	add	r0, sp, #12
    void
hmac_sha256_final(HMAC_CTX *ctx, const uint8_t key[32], uint8_t digest[32])
{
    HASH_HandleTypeDef  hh = {0};

    hh.Init.DataType = HASH_DATATYPE_8B;
 80054bc:	9203      	str	r2, [sp, #12]
    hh.Init.pKey = (uint8_t *)key;      // const viol due to API dumbness
    hh.Init.KeySize = 32;
 80054be:	9204      	str	r2, [sp, #16]
hmac_sha256_final(HMAC_CTX *ctx, const uint8_t key[32], uint8_t digest[32])
{
    HASH_HandleTypeDef  hh = {0};

    hh.Init.DataType = HASH_DATATYPE_8B;
    hh.Init.pKey = (uint8_t *)key;      // const viol due to API dumbness
 80054c0:	9605      	str	r6, [sp, #20]
    hh.Init.KeySize = 32;

    HAL_HASH_Init(&hh);
 80054c2:	f004 fef5 	bl	800a2b0 <HAL_HASH_Init>

    HAL_StatusTypeDef rv = HAL_HMACEx_SHA256_Start(&hh,
 80054c6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80054ca:	9300      	str	r3, [sp, #0]
 80054cc:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
 80054d0:	462b      	mov	r3, r5
 80054d2:	4621      	mov	r1, r4
 80054d4:	a803      	add	r0, sp, #12
 80054d6:	f7ff ff33 	bl	8005340 <HAL_HMACEx_SHA256_Start>
                                ctx->pending, ctx->num_pending, digest, HAL_MAX_DELAY);
    ASSERT(rv == HAL_OK);
 80054da:	b110      	cbz	r0, 80054e2 <hmac_sha256_final+0x3e>
 80054dc:	4802      	ldr	r0, [pc, #8]	; (80054e8 <hmac_sha256_final+0x44>)
 80054de:	f7fb fa7d 	bl	80009dc <fatal_error>
}
 80054e2:	b014      	add	sp, #80	; 0x50
 80054e4:	bd70      	pop	{r4, r5, r6, pc}
 80054e6:	bf00      	nop
 80054e8:	0800d558 	.word	0x0800d558

080054ec <uECC_vli_mult>:

#if !asm_mult
uECC_VLI_API void uECC_vli_mult(uECC_word_t *result,
                                const uECC_word_t *left,
                                const uECC_word_t *right,
                                wordcount_t num_words) {
 80054ec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    );
    
#else /* Thumb-1 */
    uint32_t r4, r5, r6, r7;

    __asm__ volatile (
 80054f0:	3b01      	subs	r3, #1
 80054f2:	009b      	lsls	r3, r3, #2
 80054f4:	4698      	mov	r8, r3
 80054f6:	005b      	lsls	r3, r3, #1
 80054f8:	4699      	mov	r9, r3
 80054fa:	2300      	movs	r3, #0
 80054fc:	2400      	movs	r4, #0
 80054fe:	2500      	movs	r5, #0
 8005500:	2600      	movs	r6, #0
 8005502:	b401      	push	{r0}
 8005504:	2700      	movs	r7, #0
 8005506:	e002      	b.n	800550e <uECC_vli_mult+0x22>
 8005508:	0037      	movs	r7, r6
 800550a:	4640      	mov	r0, r8
 800550c:	1a3f      	subs	r7, r7, r0
 800550e:	b478      	push	{r3, r4, r5, r6}
 8005510:	1bf0      	subs	r0, r6, r7
 8005512:	5814      	ldr	r4, [r2, r0]
 8005514:	59c8      	ldr	r0, [r1, r7]
 8005516:	0c03      	lsrs	r3, r0, #16
 8005518:	b280      	uxth	r0, r0
 800551a:	0c25      	lsrs	r5, r4, #16
 800551c:	b2a4      	uxth	r4, r4
 800551e:	001e      	movs	r6, r3
 8005520:	436e      	muls	r6, r5
 8005522:	4363      	muls	r3, r4
 8005524:	4345      	muls	r5, r0
 8005526:	4360      	muls	r0, r4
 8005528:	2400      	movs	r4, #0
 800552a:	195b      	adds	r3, r3, r5
 800552c:	4164      	adcs	r4, r4
 800552e:	0424      	lsls	r4, r4, #16
 8005530:	1936      	adds	r6, r6, r4
 8005532:	041c      	lsls	r4, r3, #16
 8005534:	0c1b      	lsrs	r3, r3, #16
 8005536:	1900      	adds	r0, r0, r4
 8005538:	415e      	adcs	r6, r3
 800553a:	bc38      	pop	{r3, r4, r5}
 800553c:	181b      	adds	r3, r3, r0
 800553e:	4174      	adcs	r4, r6
 8005540:	2000      	movs	r0, #0
 8005542:	4145      	adcs	r5, r0
 8005544:	bc40      	pop	{r6}
 8005546:	3704      	adds	r7, #4
 8005548:	4547      	cmp	r7, r8
 800554a:	dc01      	bgt.n	8005550 <uECC_vli_mult+0x64>
 800554c:	42b7      	cmp	r7, r6
 800554e:	ddde      	ble.n	800550e <uECC_vli_mult+0x22>
 8005550:	9800      	ldr	r0, [sp, #0]
 8005552:	5183      	str	r3, [r0, r6]
 8005554:	4623      	mov	r3, r4
 8005556:	462c      	mov	r4, r5
 8005558:	2500      	movs	r5, #0
 800555a:	3604      	adds	r6, #4
 800555c:	4546      	cmp	r6, r8
 800555e:	ddd1      	ble.n	8005504 <uECC_vli_mult+0x18>
 8005560:	454e      	cmp	r6, r9
 8005562:	ddd1      	ble.n	8005508 <uECC_vli_mult+0x1c>
 8005564:	5183      	str	r3, [r0, r6]
 8005566:	bc01      	pop	{r0}
 8005568:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800556c <uECC_vli_clear>:
}

#if !asm_clear
uECC_VLI_API void uECC_vli_clear(uECC_word_t *vli, wordcount_t num_words) {
    wordcount_t i;
    for (i = 0; i < num_words; ++i) {
 800556c:	2200      	movs	r2, #0
void uECC_set_rng(uECC_RNG_Function rng_function) {
    g_rng_function = rng_function;
}

#if !asm_clear
uECC_VLI_API void uECC_vli_clear(uECC_word_t *vli, wordcount_t num_words) {
 800556e:	b510      	push	{r4, lr}
    wordcount_t i;
    for (i = 0; i < num_words; ++i) {
        vli[i] = 0;
 8005570:	4614      	mov	r4, r2
}

#if !asm_clear
uECC_VLI_API void uECC_vli_clear(uECC_word_t *vli, wordcount_t num_words) {
    wordcount_t i;
    for (i = 0; i < num_words; ++i) {
 8005572:	b253      	sxtb	r3, r2
 8005574:	428b      	cmp	r3, r1
 8005576:	da04      	bge.n	8005582 <uECC_vli_clear+0x16>
        vli[i] = 0;
 8005578:	b21b      	sxth	r3, r3
 800557a:	3201      	adds	r2, #1
 800557c:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
 8005580:	e7f7      	b.n	8005572 <uECC_vli_clear+0x6>
    }
}
 8005582:	bd10      	pop	{r4, pc}

08005584 <uECC_vli_isZero>:
#endif /* !asm_clear */

/* Constant-time comparison to zero - secure way to compare long integers */
/* Returns 1 if vli == 0, 0 otherwise. */
uECC_VLI_API uECC_word_t uECC_vli_isZero(const uECC_word_t *vli, wordcount_t num_words) {
 8005584:	b510      	push	{r4, lr}
    uECC_word_t bits = 0;
    wordcount_t i;
    for (i = 0; i < num_words; ++i) {
 8005586:	2300      	movs	r3, #0
#endif /* !asm_clear */

/* Constant-time comparison to zero - secure way to compare long integers */
/* Returns 1 if vli == 0, 0 otherwise. */
uECC_VLI_API uECC_word_t uECC_vli_isZero(const uECC_word_t *vli, wordcount_t num_words) {
    uECC_word_t bits = 0;
 8005588:	461a      	mov	r2, r3
    wordcount_t i;
    for (i = 0; i < num_words; ++i) {
 800558a:	b25c      	sxtb	r4, r3
 800558c:	428c      	cmp	r4, r1
 800558e:	da04      	bge.n	800559a <uECC_vli_isZero+0x16>
        bits |= vli[i];
 8005590:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
 8005594:	3301      	adds	r3, #1
 8005596:	4322      	orrs	r2, r4
 8005598:	e7f7      	b.n	800558a <uECC_vli_isZero+0x6>
    }
    return (bits == 0);
}
 800559a:	fab2 f082 	clz	r0, r2
 800559e:	0940      	lsrs	r0, r0, #5
 80055a0:	bd10      	pop	{r4, pc}

080055a2 <uECC_vli_testBit>:

/* Returns nonzero if bit 'bit' of vli is set. */
uECC_VLI_API uECC_word_t uECC_vli_testBit(const uECC_word_t *vli, bitcount_t bit) {
    return (vli[bit >> uECC_WORD_BITS_SHIFT] & ((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
 80055a2:	114a      	asrs	r2, r1, #5
 80055a4:	2301      	movs	r3, #1
 80055a6:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
 80055aa:	f001 011f 	and.w	r1, r1, #31
 80055ae:	fa03 f101 	lsl.w	r1, r3, r1
}
 80055b2:	4008      	ands	r0, r1
 80055b4:	4770      	bx	lr

080055b6 <uECC_vli_numBits>:

    return (i + 1);
}

/* Counts the number of bits required to represent vli. */
uECC_VLI_API bitcount_t uECC_vli_numBits(const uECC_word_t *vli, const wordcount_t max_words) {
 80055b6:	3901      	subs	r1, #1
 80055b8:	b2c9      	uxtb	r1, r1
/* Counts the number of words in vli. */
static wordcount_t vli_numDigits(const uECC_word_t *vli, const wordcount_t max_words) {
    wordcount_t i;
    /* Search from the end until we find a non-zero digit.
       We do it in reverse because we expect that most digits will be nonzero. */
    for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
 80055ba:	b24b      	sxtb	r3, r1
 80055bc:	2b00      	cmp	r3, #0
 80055be:	da0b      	bge.n	80055d8 <uECC_vli_numBits+0x22>
    }

    return (i + 1);
 80055c0:	3101      	adds	r1, #1
uECC_VLI_API bitcount_t uECC_vli_numBits(const uECC_word_t *vli, const wordcount_t max_words) {
    uECC_word_t i;
    uECC_word_t digit;

    wordcount_t num_digits = vli_numDigits(vli, max_words);
    if (num_digits == 0) {
 80055c2:	f011 03ff 	ands.w	r3, r1, #255	; 0xff
 80055c6:	d015      	beq.n	80055f4 <uECC_vli_numBits+0x3e>
        return 0;
    }

    digit = vli[num_digits - 1];
 80055c8:	b259      	sxtb	r1, r3
 80055ca:	f101 4380 	add.w	r3, r1, #1073741824	; 0x40000000
 80055ce:	3b01      	subs	r3, #1
 80055d0:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
    for (i = 0; digit; ++i) {
 80055d4:	2300      	movs	r3, #0
 80055d6:	e004      	b.n	80055e2 <uECC_vli_numBits+0x2c>
/* Counts the number of words in vli. */
static wordcount_t vli_numDigits(const uECC_word_t *vli, const wordcount_t max_words) {
    wordcount_t i;
    /* Search from the end until we find a non-zero digit.
       We do it in reverse because we expect that most digits will be nonzero. */
    for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
 80055d8:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80055dc:	2b00      	cmp	r3, #0
 80055de:	d0ea      	beq.n	80055b6 <uECC_vli_numBits>
 80055e0:	e7ee      	b.n	80055c0 <uECC_vli_numBits+0xa>
    if (num_digits == 0) {
        return 0;
    }

    digit = vli[num_digits - 1];
    for (i = 0; digit; ++i) {
 80055e2:	b112      	cbz	r2, 80055ea <uECC_vli_numBits+0x34>
        digit >>= 1;
 80055e4:	0852      	lsrs	r2, r2, #1
    if (num_digits == 0) {
        return 0;
    }

    digit = vli[num_digits - 1];
    for (i = 0; digit; ++i) {
 80055e6:	3301      	adds	r3, #1
 80055e8:	e7fb      	b.n	80055e2 <uECC_vli_numBits+0x2c>
        digit >>= 1;
    }

    return (((bitcount_t)(num_digits - 1) << uECC_WORD_BITS_SHIFT) + i);
 80055ea:	1e48      	subs	r0, r1, #1
 80055ec:	eb03 1040 	add.w	r0, r3, r0, lsl #5
 80055f0:	b280      	uxth	r0, r0
 80055f2:	e000      	b.n	80055f6 <uECC_vli_numBits+0x40>
    uECC_word_t i;
    uECC_word_t digit;

    wordcount_t num_digits = vli_numDigits(vli, max_words);
    if (num_digits == 0) {
        return 0;
 80055f4:	4618      	mov	r0, r3
    for (i = 0; digit; ++i) {
        digit >>= 1;
    }

    return (((bitcount_t)(num_digits - 1) << uECC_WORD_BITS_SHIFT) + i);
}
 80055f6:	b200      	sxth	r0, r0
 80055f8:	4770      	bx	lr

080055fa <uECC_vli_set>:

/* Sets dest = src. */
#if !asm_set
uECC_VLI_API void uECC_vli_set(uECC_word_t *dest, const uECC_word_t *src, wordcount_t num_words) {
 80055fa:	b530      	push	{r4, r5, lr}
    wordcount_t i;
    for (i = 0; i < num_words; ++i) {
 80055fc:	2400      	movs	r4, #0
 80055fe:	b263      	sxtb	r3, r4
 8005600:	4293      	cmp	r3, r2
 8005602:	da06      	bge.n	8005612 <uECC_vli_set+0x18>
        dest[i] = src[i];
 8005604:	b21b      	sxth	r3, r3
 8005606:	3401      	adds	r4, #1
 8005608:	f851 5023 	ldr.w	r5, [r1, r3, lsl #2]
 800560c:	f840 5023 	str.w	r5, [r0, r3, lsl #2]
 8005610:	e7f5      	b.n	80055fe <uECC_vli_set+0x4>
    }
}
 8005612:	bd30      	pop	{r4, r5, pc}

08005614 <uECC_vli_cmp_unsafe>:
#endif /* !asm_set */

/* Returns sign of left - right. */
static cmpresult_t uECC_vli_cmp_unsafe(const uECC_word_t *left,
                                       const uECC_word_t *right,
                                       wordcount_t num_words) {
 8005614:	b510      	push	{r4, lr}
 8005616:	3a01      	subs	r2, #1
 8005618:	b2d2      	uxtb	r2, r2
    wordcount_t i;
    for (i = num_words - 1; i >= 0; --i) {
 800561a:	b253      	sxtb	r3, r2
 800561c:	2b00      	cmp	r3, #0
 800561e:	db09      	blt.n	8005634 <uECC_vli_cmp_unsafe+0x20>
        if (left[i] > right[i]) {
 8005620:	b21b      	sxth	r3, r3
 8005622:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
 8005626:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800562a:	429c      	cmp	r4, r3
 800562c:	d804      	bhi.n	8005638 <uECC_vli_cmp_unsafe+0x24>
            return 1;
        } else if (left[i] < right[i]) {
 800562e:	d2f2      	bcs.n	8005616 <uECC_vli_cmp_unsafe+0x2>
            return -1;
 8005630:	20ff      	movs	r0, #255	; 0xff
 8005632:	e002      	b.n	800563a <uECC_vli_cmp_unsafe+0x26>
        }
    }
    return 0;
 8005634:	2000      	movs	r0, #0
 8005636:	e000      	b.n	800563a <uECC_vli_cmp_unsafe+0x26>
                                       const uECC_word_t *right,
                                       wordcount_t num_words) {
    wordcount_t i;
    for (i = num_words - 1; i >= 0; --i) {
        if (left[i] > right[i]) {
            return 1;
 8005638:	2001      	movs	r0, #1
        } else if (left[i] < right[i]) {
            return -1;
        }
    }
    return 0;
}
 800563a:	b240      	sxtb	r0, r0
 800563c:	bd10      	pop	{r4, pc}

0800563e <uECC_vli_rshift1>:
}
#endif

/* Computes vli = vli >> 1. */
#if !asm_rshift1
uECC_VLI_API void uECC_vli_rshift1(uECC_word_t *vli, wordcount_t num_words) {
 800563e:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    uECC_word_t *end = vli;
    uECC_word_t carry = 0;
 8005642:	2300      	movs	r3, #0
    
    vli += num_words;
    while (vli-- > end) {
 8005644:	4288      	cmp	r0, r1
 8005646:	d206      	bcs.n	8005656 <uECC_vli_rshift1+0x18>
        uECC_word_t temp = *vli;
 8005648:	f851 2d04 	ldr.w	r2, [r1, #-4]!
        *vli = (temp >> 1) | carry;
 800564c:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
 8005650:	600b      	str	r3, [r1, #0]
        carry = temp << (uECC_WORD_BITS - 1);
 8005652:	07d3      	lsls	r3, r2, #31
 8005654:	e7f6      	b.n	8005644 <uECC_vli_rshift1+0x6>
    }
}
 8005656:	4770      	bx	lr

08005658 <uECC_vli_modMult>:
/* Computes result = (left * right) % mod. */
uECC_VLI_API void uECC_vli_modMult(uECC_word_t *result,
                                   const uECC_word_t *left,
                                   const uECC_word_t *right,
                                   const uECC_word_t *mod,
                                   wordcount_t num_words) {
 8005658:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800565c:	b0b5      	sub	sp, #212	; 0xd4
    uECC_word_t product[2 * uECC_MAX_WORDS];
    uECC_vli_mult(product, left, right, num_words);
 800565e:	ad04      	add	r5, sp, #16
/* Computes result = (left * right) % mod. */
uECC_VLI_API void uECC_vli_modMult(uECC_word_t *result,
                                   const uECC_word_t *left,
                                   const uECC_word_t *right,
                                   const uECC_word_t *mod,
                                   wordcount_t num_words) {
 8005660:	f99d 40f8 	ldrsb.w	r4, [sp, #248]	; 0xf8
 8005664:	4699      	mov	r9, r3
 8005666:	4680      	mov	r8, r0
    uECC_word_t product[2 * uECC_MAX_WORDS];
    uECC_vli_mult(product, left, right, num_words);
 8005668:	4623      	mov	r3, r4
 800566a:	4628      	mov	r0, r5
 800566c:	f7ff ff3e 	bl	80054ec <uECC_vli_mult>
                                uECC_word_t *product,
                                const uECC_word_t *mod,
                                wordcount_t num_words) {
    uECC_word_t mod_multiple[2 * uECC_MAX_WORDS];
    uECC_word_t tmp[2 * uECC_MAX_WORDS];
    uECC_word_t *v[2] = {tmp, product};
 8005670:	ab24      	add	r3, sp, #144	; 0x90
    uECC_word_t index;
    
    /* Shift mod so its highest set bit is at the maximum position. */
    bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) - uECC_vli_numBits(mod, num_words);
 8005672:	4621      	mov	r1, r4
 8005674:	4648      	mov	r0, r9
                                uECC_word_t *product,
                                const uECC_word_t *mod,
                                wordcount_t num_words) {
    uECC_word_t mod_multiple[2 * uECC_MAX_WORDS];
    uECC_word_t tmp[2 * uECC_MAX_WORDS];
    uECC_word_t *v[2] = {tmp, product};
 8005676:	9302      	str	r3, [sp, #8]
 8005678:	9503      	str	r5, [sp, #12]
    uECC_word_t index;
    
    /* Shift mod so its highest set bit is at the maximum position. */
    bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) - uECC_vli_numBits(mod, num_words);
 800567a:	f7ff ff9c 	bl	80055b6 <uECC_vli_numBits>
 800567e:	ebc0 1084 	rsb	r0, r0, r4, lsl #6
 8005682:	b285      	uxth	r5, r0
    wordcount_t word_shift = shift / uECC_WORD_BITS;
    wordcount_t bit_shift = shift % uECC_WORD_BITS;
 8005684:	4b49      	ldr	r3, [pc, #292]	; (80057ac <uECC_vli_modMult+0x154>)
    uECC_word_t *v[2] = {tmp, product};
    uECC_word_t index;
    
    /* Shift mod so its highest set bit is at the maximum position. */
    bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) - uECC_vli_numBits(mod, num_words);
    wordcount_t word_shift = shift / uECC_WORD_BITS;
 8005686:	b22a      	sxth	r2, r5
    wordcount_t bit_shift = shift % uECC_WORD_BITS;
 8005688:	4013      	ands	r3, r2
 800568a:	2b00      	cmp	r3, #0
 800568c:	bfbc      	itt	lt
 800568e:	f103 33ff 	addlt.w	r3, r3, #4294967295	; 0xffffffff
 8005692:	f063 031f 	ornlt	r3, r3, #31
    uECC_word_t *v[2] = {tmp, product};
    uECC_word_t index;
    
    /* Shift mod so its highest set bit is at the maximum position. */
    bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) - uECC_vli_numBits(mod, num_words);
    wordcount_t word_shift = shift / uECC_WORD_BITS;
 8005696:	f04f 0720 	mov.w	r7, #32
 800569a:	fb92 f7f7 	sdiv	r7, r2, r7
 800569e:	b2ff      	uxtb	r7, r7
    wordcount_t bit_shift = shift % uECC_WORD_BITS;
 80056a0:	bfb8      	it	lt
 80056a2:	3301      	addlt	r3, #1
    uECC_word_t carry = 0;
    uECC_vli_clear(mod_multiple, word_shift);
 80056a4:	b27f      	sxtb	r7, r7
    uECC_word_t index;
    
    /* Shift mod so its highest set bit is at the maximum position. */
    bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) - uECC_vli_numBits(mod, num_words);
    wordcount_t word_shift = shift / uECC_WORD_BITS;
    wordcount_t bit_shift = shift % uECC_WORD_BITS;
 80056a6:	b29e      	uxth	r6, r3
    uECC_word_t carry = 0;
    uECC_vli_clear(mod_multiple, word_shift);
 80056a8:	a814      	add	r0, sp, #80	; 0x50
 80056aa:	4639      	mov	r1, r7
 80056ac:	f7ff ff5e 	bl	800556c <uECC_vli_clear>
    if (bit_shift > 0) {
 80056b0:	b233      	sxth	r3, r6
 80056b2:	2b00      	cmp	r3, #0
 80056b4:	b238      	sxth	r0, r7
 80056b6:	dd14      	ble.n	80056e2 <uECC_vli_modMult+0x8a>
 80056b8:	aa14      	add	r2, sp, #80	; 0x50
 80056ba:	2100      	movs	r1, #0
 80056bc:	eb02 0080 	add.w	r0, r2, r0, lsl #2
        for(index = 0; index < (uECC_word_t)num_words; ++index) {
            mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;
            carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
 80056c0:	f1c3 0720 	rsb	r7, r3, #32
    bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) - uECC_vli_numBits(mod, num_words);
    wordcount_t word_shift = shift / uECC_WORD_BITS;
    wordcount_t bit_shift = shift % uECC_WORD_BITS;
    uECC_word_t carry = 0;
    uECC_vli_clear(mod_multiple, word_shift);
    if (bit_shift > 0) {
 80056c4:	460a      	mov	r2, r1
        for(index = 0; index < (uECC_word_t)num_words; ++index) {
 80056c6:	42a2      	cmp	r2, r4
 80056c8:	d212      	bcs.n	80056f0 <uECC_vli_modMult+0x98>
            mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;
 80056ca:	f859 6022 	ldr.w	r6, [r9, r2, lsl #2]
 80056ce:	fa06 fe03 	lsl.w	lr, r6, r3
 80056d2:	ea4e 0101 	orr.w	r1, lr, r1
 80056d6:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
            carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
 80056da:	fa26 f107 	lsr.w	r1, r6, r7
    wordcount_t word_shift = shift / uECC_WORD_BITS;
    wordcount_t bit_shift = shift % uECC_WORD_BITS;
    uECC_word_t carry = 0;
    uECC_vli_clear(mod_multiple, word_shift);
    if (bit_shift > 0) {
        for(index = 0; index < (uECC_word_t)num_words; ++index) {
 80056de:	3201      	adds	r2, #1
 80056e0:	e7f1      	b.n	80056c6 <uECC_vli_modMult+0x6e>
            mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;
            carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
        }
    } else {
        uECC_vli_set(mod_multiple + word_shift, mod, num_words);
 80056e2:	ab14      	add	r3, sp, #80	; 0x50
 80056e4:	4622      	mov	r2, r4
 80056e6:	4649      	mov	r1, r9
 80056e8:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 80056ec:	f7ff ff85 	bl	80055fa <uECC_vli_set>
 80056f0:	b227      	sxth	r7, r4
 80056f2:	007b      	lsls	r3, r7, #1
 80056f4:	9301      	str	r3, [sp, #4]
            v[1 - index][i] = diff;
        }
        index = !(index ^ borrow); /* Swap the index if there was no borrow */
        uECC_vli_rshift1(mod_multiple, num_words);
        mod_multiple[num_words - 1] |= mod_multiple[num_words] << (uECC_WORD_BITS - 1);
        uECC_vli_rshift1(mod_multiple + num_words, num_words);
 80056f6:	ab14      	add	r3, sp, #80	; 0x50
 80056f8:	eb03 0787 	add.w	r7, r3, r7, lsl #2
            }
            v[1 - index][i] = diff;
        }
        index = !(index ^ borrow); /* Swap the index if there was no borrow */
        uECC_vli_rshift1(mod_multiple, num_words);
        mod_multiple[num_words - 1] |= mod_multiple[num_words] << (uECC_WORD_BITS - 1);
 80056fc:	f104 39ff 	add.w	r9, r4, #4294967295	; 0xffffffff
 8005700:	ab34      	add	r3, sp, #208	; 0xd0
        uECC_vli_rshift1(mod_multiple + num_words, num_words);
 8005702:	2601      	movs	r6, #1
            }
            v[1 - index][i] = diff;
        }
        index = !(index ^ borrow); /* Swap the index if there was no borrow */
        uECC_vli_rshift1(mod_multiple, num_words);
        mod_multiple[num_words - 1] |= mod_multiple[num_words] << (uECC_WORD_BITS - 1);
 8005704:	eb03 0989 	add.w	r9, r3, r9, lsl #2
        }
    } else {
        uECC_vli_set(mod_multiple + word_shift, mod, num_words);
    }

    for (index = 1; shift >= 0; --shift) {
 8005708:	042b      	lsls	r3, r5, #16
 800570a:	d442      	bmi.n	8005792 <uECC_vli_modMult+0x13a>
        uECC_word_t borrow = 0;
        wordcount_t i;
        for (i = 0; i < num_words * 2; ++i) {
            uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
 800570c:	ab34      	add	r3, sp, #208	; 0xd0
        }
    } else {
        uECC_vli_set(mod_multiple + word_shift, mod, num_words);
    }

    for (index = 1; shift >= 0; --shift) {
 800570e:	2200      	movs	r2, #0
        for (i = 0; i < num_words * 2; ++i) {
            uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
            if (diff != v[index][i]) {
                borrow = (diff > v[index][i]);
            }
            v[1 - index][i] = diff;
 8005710:	f1c6 0001 	rsb	r0, r6, #1
        }
    } else {
        uECC_vli_set(mod_multiple + word_shift, mod, num_words);
    }

    for (index = 1; shift >= 0; --shift) {
 8005714:	4696      	mov	lr, r2
        uECC_word_t borrow = 0;
        wordcount_t i;
        for (i = 0; i < num_words * 2; ++i) {
            uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
 8005716:	eb03 0a86 	add.w	sl, r3, r6, lsl #2
            if (diff != v[index][i]) {
                borrow = (diff > v[index][i]);
            }
            v[1 - index][i] = diff;
 800571a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    }

    for (index = 1; shift >= 0; --shift) {
        uECC_word_t borrow = 0;
        wordcount_t i;
        for (i = 0; i < num_words * 2; ++i) {
 800571e:	9b01      	ldr	r3, [sp, #4]
 8005720:	b251      	sxtb	r1, r2
 8005722:	4299      	cmp	r1, r3
 8005724:	da1b      	bge.n	800575e <uECC_vli_modMult+0x106>
            uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
 8005726:	fa0f fc81 	sxth.w	ip, r1
 800572a:	f85a 3cc8 	ldr.w	r3, [sl, #-200]
 800572e:	f853 b02c 	ldr.w	fp, [r3, ip, lsl #2]
 8005732:	ab34      	add	r3, sp, #208	; 0xd0
 8005734:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8005738:	f851 3c80 	ldr.w	r3, [r1, #-128]
 800573c:	ebc3 030b 	rsb	r3, r3, fp
 8005740:	ebce 0303 	rsb	r3, lr, r3
            if (diff != v[index][i]) {
 8005744:	459b      	cmp	fp, r3
 8005746:	d004      	beq.n	8005752 <uECC_vli_modMult+0xfa>
                borrow = (diff > v[index][i]);
 8005748:	bf34      	ite	cc
 800574a:	f04f 0e01 	movcc.w	lr, #1
 800574e:	f04f 0e00 	movcs.w	lr, #0
            }
            v[1 - index][i] = diff;
 8005752:	f850 1cc8 	ldr.w	r1, [r0, #-200]
 8005756:	3201      	adds	r2, #1
 8005758:	f841 302c 	str.w	r3, [r1, ip, lsl #2]
 800575c:	e7df      	b.n	800571e <uECC_vli_modMult+0xc6>
        }
        index = !(index ^ borrow); /* Swap the index if there was no borrow */
 800575e:	ebce 0206 	rsb	r2, lr, r6
 8005762:	4256      	negs	r6, r2
        uECC_vli_rshift1(mod_multiple, num_words);
 8005764:	4621      	mov	r1, r4
 8005766:	a814      	add	r0, sp, #80	; 0x50
            if (diff != v[index][i]) {
                borrow = (diff > v[index][i]);
            }
            v[1 - index][i] = diff;
        }
        index = !(index ^ borrow); /* Swap the index if there was no borrow */
 8005768:	4156      	adcs	r6, r2
        uECC_vli_rshift1(mod_multiple, num_words);
 800576a:	f7ff ff68 	bl	800563e <uECC_vli_rshift1>
        mod_multiple[num_words - 1] |= mod_multiple[num_words] << (uECC_WORD_BITS - 1);
 800576e:	ab34      	add	r3, sp, #208	; 0xd0
 8005770:	eb03 0384 	add.w	r3, r3, r4, lsl #2
        uECC_vli_rshift1(mod_multiple + num_words, num_words);
 8005774:	4621      	mov	r1, r4
            }
            v[1 - index][i] = diff;
        }
        index = !(index ^ borrow); /* Swap the index if there was no borrow */
        uECC_vli_rshift1(mod_multiple, num_words);
        mod_multiple[num_words - 1] |= mod_multiple[num_words] << (uECC_WORD_BITS - 1);
 8005776:	f853 2c80 	ldr.w	r2, [r3, #-128]
 800577a:	f859 3c80 	ldr.w	r3, [r9, #-128]
        uECC_vli_rshift1(mod_multiple + num_words, num_words);
 800577e:	4638      	mov	r0, r7
            }
            v[1 - index][i] = diff;
        }
        index = !(index ^ borrow); /* Swap the index if there was no borrow */
        uECC_vli_rshift1(mod_multiple, num_words);
        mod_multiple[num_words - 1] |= mod_multiple[num_words] << (uECC_WORD_BITS - 1);
 8005780:	ea43 73c2 	orr.w	r3, r3, r2, lsl #31
 8005784:	3d01      	subs	r5, #1
 8005786:	f849 3c80 	str.w	r3, [r9, #-128]
 800578a:	b2ad      	uxth	r5, r5
        uECC_vli_rshift1(mod_multiple + num_words, num_words);
 800578c:	f7ff ff57 	bl	800563e <uECC_vli_rshift1>
 8005790:	e7ba      	b.n	8005708 <uECC_vli_modMult+0xb0>
    }
    uECC_vli_set(result, v[index], num_words);
 8005792:	ab34      	add	r3, sp, #208	; 0xd0
 8005794:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 8005798:	4622      	mov	r2, r4
 800579a:	f856 1cc8 	ldr.w	r1, [r6, #-200]
 800579e:	4640      	mov	r0, r8
 80057a0:	f7ff ff2b 	bl	80055fa <uECC_vli_set>
                                   const uECC_word_t *mod,
                                   wordcount_t num_words) {
    uECC_word_t product[2 * uECC_MAX_WORDS];
    uECC_vli_mult(product, left, right, num_words);
    uECC_vli_mmod(result, product, mod, num_words);
}
 80057a4:	b035      	add	sp, #212	; 0xd4
 80057a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80057aa:	bf00      	nop
 80057ac:	8000001f 	.word	0x8000001f

080057b0 <uECC_vli_modMult_fast>:

uECC_VLI_API void uECC_vli_modMult_fast(uECC_word_t *result,
                                        const uECC_word_t *left,
                                        const uECC_word_t *right,
                                        uECC_Curve curve) {
 80057b0:	b530      	push	{r4, r5, lr}
 80057b2:	461c      	mov	r4, r3
 80057b4:	b091      	sub	sp, #68	; 0x44
 80057b6:	4605      	mov	r5, r0
    uECC_word_t product[2 * uECC_MAX_WORDS];
    uECC_vli_mult(product, left, right, curve->num_words);
 80057b8:	f993 3000 	ldrsb.w	r3, [r3]
 80057bc:	4668      	mov	r0, sp
 80057be:	f7ff fe95 	bl	80054ec <uECC_vli_mult>
#if (uECC_OPTIMIZATION_LEVEL > 0)
    curve->mmod_fast(result, product);
 80057c2:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
 80057c6:	4669      	mov	r1, sp
 80057c8:	4628      	mov	r0, r5
 80057ca:	4798      	blx	r3
#else
    uECC_vli_mmod(result, product, curve->p, curve->num_words);
#endif
}
 80057cc:	b011      	add	sp, #68	; 0x44
 80057ce:	bd30      	pop	{r4, r5, pc}

080057d0 <uECC_vli_modSquare_fast>:
#endif /* uECC_ENABLE_VLI_API */

uECC_VLI_API void uECC_vli_modSquare_fast(uECC_word_t *result,
                                          const uECC_word_t *left,
                                          uECC_Curve curve) {
    uECC_vli_modMult_fast(result, left, left, curve);
 80057d0:	4613      	mov	r3, r2
 80057d2:	460a      	mov	r2, r1
 80057d4:	f7ff bfec 	b.w	80057b0 <uECC_vli_modMult_fast>

080057d8 <apply_z>:

/* Modify (x1, y1) => (x1 * z^2, y1 * z^3) */
static void apply_z(uECC_word_t * X1,
                    uECC_word_t * Y1,
                    const uECC_word_t * const Z,
                    uECC_Curve curve) {
 80057d8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80057da:	4615      	mov	r5, r2
 80057dc:	b089      	sub	sp, #36	; 0x24
 80057de:	461c      	mov	r4, r3
 80057e0:	4607      	mov	r7, r0
 80057e2:	460e      	mov	r6, r1
    uECC_word_t t1[uECC_MAX_WORDS];

    uECC_vli_modSquare_fast(t1, Z, curve);    /* z^2 */
 80057e4:	461a      	mov	r2, r3
 80057e6:	4629      	mov	r1, r5
 80057e8:	4668      	mov	r0, sp
 80057ea:	f7ff fff1 	bl	80057d0 <uECC_vli_modSquare_fast>
    uECC_vli_modMult_fast(X1, X1, t1, curve); /* x1 * z^2 */
 80057ee:	4623      	mov	r3, r4
 80057f0:	466a      	mov	r2, sp
 80057f2:	4639      	mov	r1, r7
 80057f4:	4638      	mov	r0, r7
 80057f6:	f7ff ffdb 	bl	80057b0 <uECC_vli_modMult_fast>
    uECC_vli_modMult_fast(t1, t1, Z, curve);  /* z^3 */
 80057fa:	4623      	mov	r3, r4
 80057fc:	462a      	mov	r2, r5
 80057fe:	4669      	mov	r1, sp
 8005800:	4668      	mov	r0, sp
 8005802:	f7ff ffd5 	bl	80057b0 <uECC_vli_modMult_fast>
    uECC_vli_modMult_fast(Y1, Y1, t1, curve); /* y1 * z^3 */
 8005806:	4623      	mov	r3, r4
 8005808:	466a      	mov	r2, sp
 800580a:	4631      	mov	r1, r6
 800580c:	4630      	mov	r0, r6
 800580e:	f7ff ffcf 	bl	80057b0 <uECC_vli_modMult_fast>
}
 8005812:	b009      	add	sp, #36	; 0x24
 8005814:	bdf0      	pop	{r4, r5, r6, r7, pc}

08005816 <uECC_vli_nativeToBytes>:

#else

uECC_VLI_API void uECC_vli_nativeToBytes(uint8_t *bytes,
                                         int num_bytes,
                                         const uECC_word_t *native) {
 8005816:	b5f0      	push	{r4, r5, r6, r7, lr}
    wordcount_t i;
    for (i = 0; i < num_bytes; ++i) {
 8005818:	2500      	movs	r5, #0
        unsigned b = num_bytes - 1 - i;
 800581a:	1e4f      	subs	r7, r1, #1

uECC_VLI_API void uECC_vli_nativeToBytes(uint8_t *bytes,
                                         int num_bytes,
                                         const uECC_word_t *native) {
    wordcount_t i;
    for (i = 0; i < num_bytes; ++i) {
 800581c:	b26c      	sxtb	r4, r5
 800581e:	428c      	cmp	r4, r1
 8005820:	f105 0501 	add.w	r5, r5, #1
 8005824:	da0a      	bge.n	800583c <uECC_vli_nativeToBytes+0x26>
        unsigned b = num_bytes - 1 - i;
 8005826:	1b3b      	subs	r3, r7, r4
        bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));
 8005828:	089e      	lsrs	r6, r3, #2
 800582a:	f003 0303 	and.w	r3, r3, #3
 800582e:	f852 6026 	ldr.w	r6, [r2, r6, lsl #2]
 8005832:	00db      	lsls	r3, r3, #3
 8005834:	fa26 f303 	lsr.w	r3, r6, r3
 8005838:	5503      	strb	r3, [r0, r4]
 800583a:	e7ef      	b.n	800581c <uECC_vli_nativeToBytes+0x6>
    }
}
 800583c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800583e <uECC_vli_bytesToNative>:

uECC_VLI_API void uECC_vli_bytesToNative(uECC_word_t *native,
                                         const uint8_t *bytes,
                                         int num_bytes) {
 800583e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005840:	4616      	mov	r6, r2
    wordcount_t i;
    uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
 8005842:	1cd3      	adds	r3, r2, #3
    }
}

uECC_VLI_API void uECC_vli_bytesToNative(uECC_word_t *native,
                                         const uint8_t *bytes,
                                         int num_bytes) {
 8005844:	460d      	mov	r5, r1
    wordcount_t i;
    uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
 8005846:	2104      	movs	r1, #4
 8005848:	fb93 f1f1 	sdiv	r1, r3, r1
 800584c:	b249      	sxtb	r1, r1
    }
}

uECC_VLI_API void uECC_vli_bytesToNative(uECC_word_t *native,
                                         const uint8_t *bytes,
                                         int num_bytes) {
 800584e:	4604      	mov	r4, r0
    wordcount_t i;
    uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
    for (i = 0; i < num_bytes; ++i) {
        unsigned b = num_bytes - 1 - i;
 8005850:	1e77      	subs	r7, r6, #1

uECC_VLI_API void uECC_vli_bytesToNative(uECC_word_t *native,
                                         const uint8_t *bytes,
                                         int num_bytes) {
    wordcount_t i;
    uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
 8005852:	f7ff fe8b 	bl	800556c <uECC_vli_clear>
    for (i = 0; i < num_bytes; ++i) {
 8005856:	2200      	movs	r2, #0
 8005858:	b251      	sxtb	r1, r2
 800585a:	428e      	cmp	r6, r1
 800585c:	f102 0201 	add.w	r2, r2, #1
 8005860:	dd0d      	ble.n	800587e <uECC_vli_bytesToNative+0x40>
        unsigned b = num_bytes - 1 - i;
 8005862:	1a7b      	subs	r3, r7, r1
        native[b / uECC_WORD_SIZE] |= 
 8005864:	0898      	lsrs	r0, r3, #2
 8005866:	5c69      	ldrb	r1, [r5, r1]
 8005868:	f003 0303 	and.w	r3, r3, #3
 800586c:	00db      	lsls	r3, r3, #3
 800586e:	fa01 f303 	lsl.w	r3, r1, r3
 8005872:	f854 1020 	ldr.w	r1, [r4, r0, lsl #2]
 8005876:	430b      	orrs	r3, r1
 8005878:	f844 3020 	str.w	r3, [r4, r0, lsl #2]
 800587c:	e7ec      	b.n	8005858 <uECC_vli_bytesToNative+0x1a>
            (uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
    }
}
 800587e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08005880 <HMAC_init>:
    return 0;
}

/* Compute an HMAC using K as a key (as in RFC 6979). Note that K is always
   the same size as the hash result size. */
static void HMAC_init(uECC_HashContext *hash_context, const uint8_t *K) {
 8005880:	b570      	push	{r4, r5, r6, lr}
    uint8_t *pad = hash_context->tmp + 2 * hash_context->result_size;
 8005882:	6943      	ldr	r3, [r0, #20]
 8005884:	6905      	ldr	r5, [r0, #16]
    return 0;
}

/* Compute an HMAC using K as a key (as in RFC 6979). Note that K is always
   the same size as the hash result size. */
static void HMAC_init(uECC_HashContext *hash_context, const uint8_t *K) {
 8005886:	4604      	mov	r4, r0
    uint8_t *pad = hash_context->tmp + 2 * hash_context->result_size;
 8005888:	eb03 0545 	add.w	r5, r3, r5, lsl #1
    unsigned i;
    for (i = 0; i < hash_context->result_size; ++i)
 800588c:	2300      	movs	r3, #0
 800588e:	6922      	ldr	r2, [r4, #16]
 8005890:	4293      	cmp	r3, r2
 8005892:	d205      	bcs.n	80058a0 <HMAC_init+0x20>
        pad[i] = K[i] ^ 0x36;
 8005894:	5cca      	ldrb	r2, [r1, r3]
 8005896:	f082 0236 	eor.w	r2, r2, #54	; 0x36
 800589a:	54ea      	strb	r2, [r5, r3]
/* Compute an HMAC using K as a key (as in RFC 6979). Note that K is always
   the same size as the hash result size. */
static void HMAC_init(uECC_HashContext *hash_context, const uint8_t *K) {
    uint8_t *pad = hash_context->tmp + 2 * hash_context->result_size;
    unsigned i;
    for (i = 0; i < hash_context->result_size; ++i)
 800589c:	3301      	adds	r3, #1
 800589e:	e7f6      	b.n	800588e <HMAC_init+0xe>
 80058a0:	442b      	add	r3, r5
        pad[i] = K[i] ^ 0x36;
    for (; i < hash_context->block_size; ++i)
        pad[i] = 0x36;
 80058a2:	2036      	movs	r0, #54	; 0x36
static void HMAC_init(uECC_HashContext *hash_context, const uint8_t *K) {
    uint8_t *pad = hash_context->tmp + 2 * hash_context->result_size;
    unsigned i;
    for (i = 0; i < hash_context->result_size; ++i)
        pad[i] = K[i] ^ 0x36;
    for (; i < hash_context->block_size; ++i)
 80058a4:	68e1      	ldr	r1, [r4, #12]
 80058a6:	1b5a      	subs	r2, r3, r5
 80058a8:	4291      	cmp	r1, r2
 80058aa:	d902      	bls.n	80058b2 <HMAC_init+0x32>
        pad[i] = 0x36;
 80058ac:	f803 0b01 	strb.w	r0, [r3], #1
 80058b0:	e7f8      	b.n	80058a4 <HMAC_init+0x24>

    hash_context->init_hash(hash_context);
 80058b2:	6823      	ldr	r3, [r4, #0]
 80058b4:	4620      	mov	r0, r4
 80058b6:	4798      	blx	r3
    hash_context->update_hash(hash_context, pad, hash_context->block_size);
 80058b8:	6863      	ldr	r3, [r4, #4]
 80058ba:	68e2      	ldr	r2, [r4, #12]
 80058bc:	4629      	mov	r1, r5
 80058be:	4620      	mov	r0, r4
}
 80058c0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        pad[i] = K[i] ^ 0x36;
    for (; i < hash_context->block_size; ++i)
        pad[i] = 0x36;

    hash_context->init_hash(hash_context);
    hash_context->update_hash(hash_context, pad, hash_context->block_size);
 80058c4:	4718      	bx	r3

080058c6 <HMAC_update>:
}

static void HMAC_update(uECC_HashContext *hash_context,
                        const uint8_t *message,
                        unsigned message_size) {
    hash_context->update_hash(hash_context, message, message_size);
 80058c6:	6843      	ldr	r3, [r0, #4]
 80058c8:	4718      	bx	r3

080058ca <HMAC_finish>:
}

static void HMAC_finish(uECC_HashContext *hash_context, const uint8_t *K, uint8_t *result) {
 80058ca:	b570      	push	{r4, r5, r6, lr}
    uint8_t *pad = hash_context->tmp + 2 * hash_context->result_size;
 80058cc:	6943      	ldr	r3, [r0, #20]
 80058ce:	6905      	ldr	r5, [r0, #16]
                        const uint8_t *message,
                        unsigned message_size) {
    hash_context->update_hash(hash_context, message, message_size);
}

static void HMAC_finish(uECC_HashContext *hash_context, const uint8_t *K, uint8_t *result) {
 80058d0:	4604      	mov	r4, r0
    uint8_t *pad = hash_context->tmp + 2 * hash_context->result_size;
 80058d2:	eb03 0545 	add.w	r5, r3, r5, lsl #1
                        const uint8_t *message,
                        unsigned message_size) {
    hash_context->update_hash(hash_context, message, message_size);
}

static void HMAC_finish(uECC_HashContext *hash_context, const uint8_t *K, uint8_t *result) {
 80058d6:	4616      	mov	r6, r2
    uint8_t *pad = hash_context->tmp + 2 * hash_context->result_size;
    unsigned i;
    for (i = 0; i < hash_context->result_size; ++i)
 80058d8:	2300      	movs	r3, #0
 80058da:	6922      	ldr	r2, [r4, #16]
 80058dc:	4293      	cmp	r3, r2
 80058de:	d205      	bcs.n	80058ec <HMAC_finish+0x22>
        pad[i] = K[i] ^ 0x5c;
 80058e0:	5cca      	ldrb	r2, [r1, r3]
 80058e2:	f082 025c 	eor.w	r2, r2, #92	; 0x5c
 80058e6:	54ea      	strb	r2, [r5, r3]
}

static void HMAC_finish(uECC_HashContext *hash_context, const uint8_t *K, uint8_t *result) {
    uint8_t *pad = hash_context->tmp + 2 * hash_context->result_size;
    unsigned i;
    for (i = 0; i < hash_context->result_size; ++i)
 80058e8:	3301      	adds	r3, #1
 80058ea:	e7f6      	b.n	80058da <HMAC_finish+0x10>
 80058ec:	442b      	add	r3, r5
        pad[i] = K[i] ^ 0x5c;
    for (; i < hash_context->block_size; ++i)
        pad[i] = 0x5c;
 80058ee:	205c      	movs	r0, #92	; 0x5c
static void HMAC_finish(uECC_HashContext *hash_context, const uint8_t *K, uint8_t *result) {
    uint8_t *pad = hash_context->tmp + 2 * hash_context->result_size;
    unsigned i;
    for (i = 0; i < hash_context->result_size; ++i)
        pad[i] = K[i] ^ 0x5c;
    for (; i < hash_context->block_size; ++i)
 80058f0:	68e1      	ldr	r1, [r4, #12]
 80058f2:	1b5a      	subs	r2, r3, r5
 80058f4:	4291      	cmp	r1, r2
 80058f6:	d902      	bls.n	80058fe <HMAC_finish+0x34>
        pad[i] = 0x5c;
 80058f8:	f803 0b01 	strb.w	r0, [r3], #1
 80058fc:	e7f8      	b.n	80058f0 <HMAC_finish+0x26>

    hash_context->finish_hash(hash_context, result);
 80058fe:	4631      	mov	r1, r6
 8005900:	68a3      	ldr	r3, [r4, #8]
 8005902:	4620      	mov	r0, r4
 8005904:	4798      	blx	r3

    hash_context->init_hash(hash_context);
 8005906:	6823      	ldr	r3, [r4, #0]
 8005908:	4620      	mov	r0, r4
 800590a:	4798      	blx	r3
    hash_context->update_hash(hash_context, pad, hash_context->block_size);
 800590c:	6863      	ldr	r3, [r4, #4]
 800590e:	68e2      	ldr	r2, [r4, #12]
 8005910:	4629      	mov	r1, r5
 8005912:	4620      	mov	r0, r4
 8005914:	4798      	blx	r3
    hash_context->update_hash(hash_context, result, hash_context->result_size);
 8005916:	6863      	ldr	r3, [r4, #4]
 8005918:	6922      	ldr	r2, [r4, #16]
 800591a:	4631      	mov	r1, r6
 800591c:	4620      	mov	r0, r4
 800591e:	4798      	blx	r3
    hash_context->finish_hash(hash_context, result);
 8005920:	68a3      	ldr	r3, [r4, #8]
 8005922:	4631      	mov	r1, r6
 8005924:	4620      	mov	r0, r4
}
 8005926:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    hash_context->finish_hash(hash_context, result);

    hash_context->init_hash(hash_context);
    hash_context->update_hash(hash_context, pad, hash_context->block_size);
    hash_context->update_hash(hash_context, result, hash_context->result_size);
    hash_context->finish_hash(hash_context, result);
 800592a:	4718      	bx	r3

0800592c <update_V>:
}

/* V = HMAC_K(V) */
static void update_V(uECC_HashContext *hash_context, uint8_t *K, uint8_t *V) {
 800592c:	b570      	push	{r4, r5, r6, lr}
 800592e:	4604      	mov	r4, r0
 8005930:	4615      	mov	r5, r2
 8005932:	460e      	mov	r6, r1
    HMAC_init(hash_context, K);
 8005934:	f7ff ffa4 	bl	8005880 <HMAC_init>
    HMAC_update(hash_context, V, hash_context->result_size);
 8005938:	6922      	ldr	r2, [r4, #16]
 800593a:	4629      	mov	r1, r5
 800593c:	4620      	mov	r0, r4
 800593e:	f7ff ffc2 	bl	80058c6 <HMAC_update>
    HMAC_finish(hash_context, K, V);
 8005942:	462a      	mov	r2, r5
 8005944:	4631      	mov	r1, r6
 8005946:	4620      	mov	r0, r4
}
 8005948:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

/* V = HMAC_K(V) */
static void update_V(uECC_HashContext *hash_context, uint8_t *K, uint8_t *V) {
    HMAC_init(hash_context, K);
    HMAC_update(hash_context, V, hash_context->result_size);
    HMAC_finish(hash_context, K, V);
 800594c:	f7ff bfbd 	b.w	80058ca <HMAC_finish>

08005950 <uECC_vli_add.isra.0>:
    #define RESUME_SYNTAX ".syntax divided \n\t"
#endif

#if (uECC_OPTIMIZATION_LEVEL >= 2)

uECC_VLI_API uECC_word_t uECC_vli_add(uECC_word_t *result,
 8005950:	b530      	push	{r4, r5, lr}
#endif
    uint32_t carry;
    uint32_t left_word;
    uint32_t right_word;
    
    __asm__ volatile (
 8005952:	4603      	mov	r3, r0
 8005954:	2000      	movs	r0, #0
 8005956:	c910      	ldmia	r1!, {r4}
 8005958:	ca20      	ldmia	r2!, {r5}
 800595a:	1964      	adds	r4, r4, r5
 800595c:	c310      	stmia	r3!, {r4}
 800595e:	c910      	ldmia	r1!, {r4}
 8005960:	ca20      	ldmia	r2!, {r5}
 8005962:	416c      	adcs	r4, r5
 8005964:	c310      	stmia	r3!, {r4}
 8005966:	c910      	ldmia	r1!, {r4}
 8005968:	ca20      	ldmia	r2!, {r5}
 800596a:	416c      	adcs	r4, r5
 800596c:	c310      	stmia	r3!, {r4}
 800596e:	c910      	ldmia	r1!, {r4}
 8005970:	ca20      	ldmia	r2!, {r5}
 8005972:	416c      	adcs	r4, r5
 8005974:	c310      	stmia	r3!, {r4}
 8005976:	c910      	ldmia	r1!, {r4}
 8005978:	ca20      	ldmia	r2!, {r5}
 800597a:	416c      	adcs	r4, r5
 800597c:	c310      	stmia	r3!, {r4}
 800597e:	c910      	ldmia	r1!, {r4}
 8005980:	ca20      	ldmia	r2!, {r5}
 8005982:	416c      	adcs	r4, r5
 8005984:	c310      	stmia	r3!, {r4}
 8005986:	c910      	ldmia	r1!, {r4}
 8005988:	ca20      	ldmia	r2!, {r5}
 800598a:	416c      	adcs	r4, r5
 800598c:	c310      	stmia	r3!, {r4}
 800598e:	c910      	ldmia	r1!, {r4}
 8005990:	ca20      	ldmia	r2!, {r5}
 8005992:	416c      	adcs	r4, r5
 8005994:	c310      	stmia	r3!, {r4}
 8005996:	4140      	adcs	r0, r0
          [right] REG_WRITE_LO (right_word)
        :
        : "cc", "memory"
    );
    return carry;
}
 8005998:	bd30      	pop	{r4, r5, pc}

0800599a <mod_sqrt_default>:

#if uECC_SUPPORT_COMPRESSED_POINT
#if uECC_SUPPORTS_secp160r1 || uECC_SUPPORTS_secp192r1 || \
    uECC_SUPPORTS_secp256r1 || uECC_SUPPORTS_secp256k1
/* Compute a = sqrt(a) (mod curve_p). */
static void mod_sqrt_default(uECC_word_t *a, uECC_Curve curve) {
 800599a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800599e:	b090      	sub	sp, #64	; 0x40
 80059a0:	460e      	mov	r6, r1
    bitcount_t i;
    uECC_word_t p1[uECC_MAX_WORDS] = {1};
 80059a2:	2220      	movs	r2, #32
 80059a4:	2100      	movs	r1, #0

#if uECC_SUPPORT_COMPRESSED_POINT
#if uECC_SUPPORTS_secp160r1 || uECC_SUPPORTS_secp192r1 || \
    uECC_SUPPORTS_secp256r1 || uECC_SUPPORTS_secp256k1
/* Compute a = sqrt(a) (mod curve_p). */
static void mod_sqrt_default(uECC_word_t *a, uECC_Curve curve) {
 80059a6:	4607      	mov	r7, r0
    bitcount_t i;
    uECC_word_t p1[uECC_MAX_WORDS] = {1};
 80059a8:	4668      	mov	r0, sp
 80059aa:	f007 fd90 	bl	800d4ce <memset>
    uECC_word_t l_result[uECC_MAX_WORDS] = {1};
 80059ae:	2220      	movs	r2, #32
#if uECC_SUPPORTS_secp160r1 || uECC_SUPPORTS_secp192r1 || \
    uECC_SUPPORTS_secp256r1 || uECC_SUPPORTS_secp256k1
/* Compute a = sqrt(a) (mod curve_p). */
static void mod_sqrt_default(uECC_word_t *a, uECC_Curve curve) {
    bitcount_t i;
    uECC_word_t p1[uECC_MAX_WORDS] = {1};
 80059b0:	2401      	movs	r4, #1
    uECC_word_t l_result[uECC_MAX_WORDS] = {1};
 80059b2:	2100      	movs	r1, #0
 80059b4:	eb0d 0002 	add.w	r0, sp, r2
#if uECC_SUPPORTS_secp160r1 || uECC_SUPPORTS_secp192r1 || \
    uECC_SUPPORTS_secp256r1 || uECC_SUPPORTS_secp256k1
/* Compute a = sqrt(a) (mod curve_p). */
static void mod_sqrt_default(uECC_word_t *a, uECC_Curve curve) {
    bitcount_t i;
    uECC_word_t p1[uECC_MAX_WORDS] = {1};
 80059b8:	9400      	str	r4, [sp, #0]
    uECC_word_t l_result[uECC_MAX_WORDS] = {1};
 80059ba:	f007 fd88 	bl	800d4ce <memset>
    wordcount_t num_words = curve->num_words;
 80059be:	4631      	mov	r1, r6
    
    /* When curve->p == 3 (mod 4), we can compute
       sqrt(a) = a^((curve->p + 1) / 4) (mod curve->p). */
    uECC_vli_add(p1, curve->p, p1, num_words); /* p1 = curve_p + 1 */
 80059c0:	466a      	mov	r2, sp
/* Compute a = sqrt(a) (mod curve_p). */
static void mod_sqrt_default(uECC_word_t *a, uECC_Curve curve) {
    bitcount_t i;
    uECC_word_t p1[uECC_MAX_WORDS] = {1};
    uECC_word_t l_result[uECC_MAX_WORDS] = {1};
    wordcount_t num_words = curve->num_words;
 80059c2:	f811 5b04 	ldrb.w	r5, [r1], #4
    uECC_SUPPORTS_secp256r1 || uECC_SUPPORTS_secp256k1
/* Compute a = sqrt(a) (mod curve_p). */
static void mod_sqrt_default(uECC_word_t *a, uECC_Curve curve) {
    bitcount_t i;
    uECC_word_t p1[uECC_MAX_WORDS] = {1};
    uECC_word_t l_result[uECC_MAX_WORDS] = {1};
 80059c6:	9408      	str	r4, [sp, #32]
    wordcount_t num_words = curve->num_words;
    
    /* When curve->p == 3 (mod 4), we can compute
       sqrt(a) = a^((curve->p + 1) / 4) (mod curve->p). */
    uECC_vli_add(p1, curve->p, p1, num_words); /* p1 = curve_p + 1 */
 80059c8:	4668      	mov	r0, sp
    for (i = uECC_vli_numBits(p1, num_words) - 1; i > 1; --i) {
 80059ca:	b26d      	sxtb	r5, r5
    uECC_word_t l_result[uECC_MAX_WORDS] = {1};
    wordcount_t num_words = curve->num_words;
    
    /* When curve->p == 3 (mod 4), we can compute
       sqrt(a) = a^((curve->p + 1) / 4) (mod curve->p). */
    uECC_vli_add(p1, curve->p, p1, num_words); /* p1 = curve_p + 1 */
 80059cc:	f7ff ffc0 	bl	8005950 <uECC_vli_add.isra.0>
    for (i = uECC_vli_numBits(p1, num_words) - 1; i > 1; --i) {
 80059d0:	4629      	mov	r1, r5
 80059d2:	4668      	mov	r0, sp
 80059d4:	f7ff fdef 	bl	80055b6 <uECC_vli_numBits>
 80059d8:	3801      	subs	r0, #1
 80059da:	b284      	uxth	r4, r0
 80059dc:	fa0f f884 	sxth.w	r8, r4
 80059e0:	f1b8 0f01 	cmp.w	r8, #1
 80059e4:	dd12      	ble.n	8005a0c <mod_sqrt_default+0x72>
        uECC_vli_modSquare_fast(l_result, l_result, curve);
 80059e6:	a908      	add	r1, sp, #32
 80059e8:	4608      	mov	r0, r1
 80059ea:	4632      	mov	r2, r6
 80059ec:	f7ff fef0 	bl	80057d0 <uECC_vli_modSquare_fast>
        if (uECC_vli_testBit(p1, i)) {
 80059f0:	4641      	mov	r1, r8
 80059f2:	4668      	mov	r0, sp
 80059f4:	f7ff fdd5 	bl	80055a2 <uECC_vli_testBit>
 80059f8:	b128      	cbz	r0, 8005a06 <mod_sqrt_default+0x6c>
            uECC_vli_modMult_fast(l_result, l_result, a, curve);
 80059fa:	a908      	add	r1, sp, #32
 80059fc:	4633      	mov	r3, r6
 80059fe:	463a      	mov	r2, r7
 8005a00:	4608      	mov	r0, r1
 8005a02:	f7ff fed5 	bl	80057b0 <uECC_vli_modMult_fast>
 8005a06:	3c01      	subs	r4, #1
 8005a08:	b2a4      	uxth	r4, r4
 8005a0a:	e7e7      	b.n	80059dc <mod_sqrt_default+0x42>
        }
    }
    uECC_vli_set(a, l_result, num_words);
 8005a0c:	462a      	mov	r2, r5
 8005a0e:	a908      	add	r1, sp, #32
 8005a10:	4638      	mov	r0, r7
 8005a12:	f7ff fdf2 	bl	80055fa <uECC_vli_set>
}
 8005a16:	b010      	add	sp, #64	; 0x40
 8005a18:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08005a1c <omega_mult_secp256k1>:
    /* add the 2^32 multiple */
    result[4 + num_words_secp256k1] =
        uECC_vli_add(result + 4, result + 4, right, num_words_secp256k1); 
}
#elif uECC_WORD_SIZE == 4
static void omega_mult_secp256k1(uint32_t * result, const uint32_t * right) {
 8005a1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005a1e:	460a      	mov	r2, r1
 8005a20:	4604      	mov	r4, r0
 8005a22:	1f0d      	subs	r5, r1, #4
 8005a24:	1f06      	subs	r6, r0, #4
 8005a26:	f101 071c 	add.w	r7, r1, #28
    /* Multiply by (2^9 + 2^8 + 2^7 + 2^6 + 2^4 + 1). */
    uint32_t carry = 0;
 8005a2a:	2300      	movs	r3, #0
    wordcount_t k;
    
    for (k = 0; k < num_words_secp256k1; ++k) {
        uint64_t p = (uint64_t)0x3D1 * right[k] + carry;
 8005a2c:	f240 3ed1 	movw	lr, #977	; 0x3d1
 8005a30:	f855 cf04 	ldr.w	ip, [r5, #4]!
 8005a34:	4618      	mov	r0, r3
 8005a36:	2100      	movs	r1, #0
 8005a38:	fbee 010c 	umlal	r0, r1, lr, ip
static void omega_mult_secp256k1(uint32_t * result, const uint32_t * right) {
    /* Multiply by (2^9 + 2^8 + 2^7 + 2^6 + 2^4 + 1). */
    uint32_t carry = 0;
    wordcount_t k;
    
    for (k = 0; k < num_words_secp256k1; ++k) {
 8005a3c:	42af      	cmp	r7, r5
        uint64_t p = (uint64_t)0x3D1 * right[k] + carry;
        result[k] = p;
 8005a3e:	f846 0f04 	str.w	r0, [r6, #4]!
        carry = p >> 32;
 8005a42:	460b      	mov	r3, r1
static void omega_mult_secp256k1(uint32_t * result, const uint32_t * right) {
    /* Multiply by (2^9 + 2^8 + 2^7 + 2^6 + 2^4 + 1). */
    uint32_t carry = 0;
    wordcount_t k;
    
    for (k = 0; k < num_words_secp256k1; ++k) {
 8005a44:	d1f4      	bne.n	8005a30 <omega_mult_secp256k1+0x14>
        uint64_t p = (uint64_t)0x3D1 * right[k] + carry;
        result[k] = p;
        carry = p >> 32;
    }
    result[num_words_secp256k1] = carry;
 8005a46:	6221      	str	r1, [r4, #32]
    /* add the 2^32 multiple */
    result[1 + num_words_secp256k1] =
        uECC_vli_add(result + 1, result + 1, right, num_words_secp256k1); 
 8005a48:	1d21      	adds	r1, r4, #4
 8005a4a:	4608      	mov	r0, r1
 8005a4c:	f7ff ff80 	bl	8005950 <uECC_vli_add.isra.0>
        result[k] = p;
        carry = p >> 32;
    }
    result[num_words_secp256k1] = carry;
    /* add the 2^32 multiple */
    result[1 + num_words_secp256k1] =
 8005a50:	6260      	str	r0, [r4, #36]	; 0x24
 8005a52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08005a54 <regularize_k>:
}

static uECC_word_t regularize_k(const uECC_word_t * const k,
                                uECC_word_t *k0,
                                uECC_word_t *k1,
                                uECC_Curve curve) {
 8005a54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005a56:	460e      	mov	r6, r1
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    bitcount_t num_n_bits = curve->num_n_bits;
    uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
 8005a58:	f103 0524 	add.w	r5, r3, #36	; 0x24
}

static uECC_word_t regularize_k(const uECC_word_t * const k,
                                uECC_word_t *k0,
                                uECC_word_t *k1,
                                uECC_Curve curve) {
 8005a5c:	4617      	mov	r7, r2
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    bitcount_t num_n_bits = curve->num_n_bits;
    uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
 8005a5e:	4601      	mov	r1, r0
 8005a60:	462a      	mov	r2, r5
 8005a62:	4630      	mov	r0, r6

static uECC_word_t regularize_k(const uECC_word_t * const k,
                                uECC_word_t *k0,
                                uECC_word_t *k1,
                                uECC_Curve curve) {
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8005a64:	885c      	ldrh	r4, [r3, #2]
    bitcount_t num_n_bits = curve->num_n_bits;
    uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
 8005a66:	f7ff ff73 	bl	8005950 <uECC_vli_add.isra.0>
 8005a6a:	b980      	cbnz	r0, 8005a8e <regularize_k+0x3a>

static uECC_word_t regularize_k(const uECC_word_t * const k,
                                uECC_word_t *k0,
                                uECC_word_t *k1,
                                uECC_Curve curve) {
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8005a6c:	b221      	sxth	r1, r4
 8005a6e:	f101 031f 	add.w	r3, r1, #31
 8005a72:	2220      	movs	r2, #32
 8005a74:	fb93 f3f2 	sdiv	r3, r3, r2
    bitcount_t num_n_bits = curve->num_n_bits;
    uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
 8005a78:	b25b      	sxtb	r3, r3
 8005a7a:	ebb1 1f43 	cmp.w	r1, r3, lsl #5
 8005a7e:	da08      	bge.n	8005a92 <regularize_k+0x3e>
        (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
         uECC_vli_testBit(k0, num_n_bits));
 8005a80:	4630      	mov	r0, r6
 8005a82:	f7ff fd8e 	bl	80055a2 <uECC_vli_testBit>
                                uECC_word_t *k0,
                                uECC_word_t *k1,
                                uECC_Curve curve) {
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    bitcount_t num_n_bits = curve->num_n_bits;
    uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
 8005a86:	1c04      	adds	r4, r0, #0
 8005a88:	bf18      	it	ne
 8005a8a:	2401      	movne	r4, #1
 8005a8c:	e002      	b.n	8005a94 <regularize_k+0x40>
 8005a8e:	2401      	movs	r4, #1
 8005a90:	e000      	b.n	8005a94 <regularize_k+0x40>
 8005a92:	4604      	mov	r4, r0
        (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
         uECC_vli_testBit(k0, num_n_bits));
    uECC_vli_add(k1, k0, curve->n, num_n_words);
 8005a94:	462a      	mov	r2, r5
 8005a96:	4631      	mov	r1, r6
 8005a98:	4638      	mov	r0, r7
 8005a9a:	f7ff ff59 	bl	8005950 <uECC_vli_add.isra.0>
    return carry;
}
 8005a9e:	4620      	mov	r0, r4
 8005aa0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08005aa2 <uECC_vli_sub.isra.1>:
#define asm_add 1

uECC_VLI_API uECC_word_t uECC_vli_sub(uECC_word_t *result,
 8005aa2:	b530      	push	{r4, r5, lr}
#endif
    uint32_t carry;
    uint32_t left_word;
    uint32_t right_word;
    
    __asm__ volatile (
 8005aa4:	2300      	movs	r3, #0
 8005aa6:	c910      	ldmia	r1!, {r4}
 8005aa8:	ca20      	ldmia	r2!, {r5}
 8005aaa:	1b64      	subs	r4, r4, r5
 8005aac:	c010      	stmia	r0!, {r4}
 8005aae:	c910      	ldmia	r1!, {r4}
 8005ab0:	ca20      	ldmia	r2!, {r5}
 8005ab2:	41ac      	sbcs	r4, r5
 8005ab4:	c010      	stmia	r0!, {r4}
 8005ab6:	c910      	ldmia	r1!, {r4}
 8005ab8:	ca20      	ldmia	r2!, {r5}
 8005aba:	41ac      	sbcs	r4, r5
 8005abc:	c010      	stmia	r0!, {r4}
 8005abe:	c910      	ldmia	r1!, {r4}
 8005ac0:	ca20      	ldmia	r2!, {r5}
 8005ac2:	41ac      	sbcs	r4, r5
 8005ac4:	c010      	stmia	r0!, {r4}
 8005ac6:	c910      	ldmia	r1!, {r4}
 8005ac8:	ca20      	ldmia	r2!, {r5}
 8005aca:	41ac      	sbcs	r4, r5
 8005acc:	c010      	stmia	r0!, {r4}
 8005ace:	c910      	ldmia	r1!, {r4}
 8005ad0:	ca20      	ldmia	r2!, {r5}
 8005ad2:	41ac      	sbcs	r4, r5
 8005ad4:	c010      	stmia	r0!, {r4}
 8005ad6:	c910      	ldmia	r1!, {r4}
 8005ad8:	ca20      	ldmia	r2!, {r5}
 8005ada:	41ac      	sbcs	r4, r5
 8005adc:	c010      	stmia	r0!, {r4}
 8005ade:	c910      	ldmia	r1!, {r4}
 8005ae0:	ca20      	ldmia	r2!, {r5}
 8005ae2:	41ac      	sbcs	r4, r5
 8005ae4:	c010      	stmia	r0!, {r4}
 8005ae6:	415b      	adcs	r3, r3
        :
        : "cc", "memory"
    );
    return !carry; /* Note that on ARM, carry flag set means "no borrow" when subtracting
                      (for some reason...) */
}
 8005ae8:	fab3 f083 	clz	r0, r3
 8005aec:	0940      	lsrs	r0, r0, #5
 8005aee:	bd30      	pop	{r4, r5, pc}

08005af0 <uECC_vli_cmp>:

#ifndef NO_SIGNING
/* Returns sign of left - right, in constant time. */
uECC_VLI_API cmpresult_t uECC_vli_cmp(const uECC_word_t *left,
                                      const uECC_word_t *right,
                                      wordcount_t num_words) {
 8005af0:	b530      	push	{r4, r5, lr}
 8005af2:	b089      	sub	sp, #36	; 0x24
 8005af4:	4615      	mov	r5, r2
    uECC_word_t tmp[uECC_MAX_WORDS];
    uECC_word_t neg = !!uECC_vli_sub(tmp, left, right, num_words);
 8005af6:	460a      	mov	r2, r1
 8005af8:	4601      	mov	r1, r0
 8005afa:	4668      	mov	r0, sp
 8005afc:	f7ff ffd1 	bl	8005aa2 <uECC_vli_sub.isra.1>
    uECC_word_t equal = uECC_vli_isZero(tmp, num_words);
 8005b00:	4629      	mov	r1, r5
/* Returns sign of left - right, in constant time. */
uECC_VLI_API cmpresult_t uECC_vli_cmp(const uECC_word_t *left,
                                      const uECC_word_t *right,
                                      wordcount_t num_words) {
    uECC_word_t tmp[uECC_MAX_WORDS];
    uECC_word_t neg = !!uECC_vli_sub(tmp, left, right, num_words);
 8005b02:	4604      	mov	r4, r0
    uECC_word_t equal = uECC_vli_isZero(tmp, num_words);
 8005b04:	4668      	mov	r0, sp
 8005b06:	f7ff fd3d 	bl	8005584 <uECC_vli_isZero>
    return (!equal - 2 * neg);
 8005b0a:	3400      	adds	r4, #0
 8005b0c:	bf18      	it	ne
 8005b0e:	2401      	movne	r4, #1
 8005b10:	0064      	lsls	r4, r4, #1
}
 8005b12:	2800      	cmp	r0, #0
 8005b14:	bf14      	ite	ne
 8005b16:	4260      	negne	r0, r4
 8005b18:	f1c4 0001 	rsbeq	r0, r4, #1
 8005b1c:	b009      	add	sp, #36	; 0x24
 8005b1e:	bd30      	pop	{r4, r5, pc}

08005b20 <uECC_generate_random_int>:
#ifndef NO_SIGNING
/* Generates a random integer in the range 0 < random < top.
   Both random and top have num_words words. */
uECC_VLI_API int uECC_generate_random_int(uECC_word_t *random,
                                          const uECC_word_t *top,
                                          wordcount_t num_words) {
 8005b20:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005b24:	468a      	mov	sl, r1
    uECC_word_t mask = (uECC_word_t)-1;
    uECC_word_t tries;
    bitcount_t num_bits = uECC_vli_numBits(top, num_words);

    if (!g_rng_function) {
 8005b26:	4f1b      	ldr	r7, [pc, #108]	; (8005b94 <uECC_generate_random_int+0x74>)
#ifndef NO_SIGNING
/* Generates a random integer in the range 0 < random < top.
   Both random and top have num_words words. */
uECC_VLI_API int uECC_generate_random_int(uECC_word_t *random,
                                          const uECC_word_t *top,
                                          wordcount_t num_words) {
 8005b28:	4606      	mov	r6, r0
    uECC_word_t mask = (uECC_word_t)-1;
    uECC_word_t tries;
    bitcount_t num_bits = uECC_vli_numBits(top, num_words);
 8005b2a:	4611      	mov	r1, r2
 8005b2c:	4650      	mov	r0, sl
#ifndef NO_SIGNING
/* Generates a random integer in the range 0 < random < top.
   Both random and top have num_words words. */
uECC_VLI_API int uECC_generate_random_int(uECC_word_t *random,
                                          const uECC_word_t *top,
                                          wordcount_t num_words) {
 8005b2e:	4615      	mov	r5, r2
    uECC_word_t mask = (uECC_word_t)-1;
    uECC_word_t tries;
    bitcount_t num_bits = uECC_vli_numBits(top, num_words);
 8005b30:	f7ff fd41 	bl	80055b6 <uECC_vli_numBits>

    if (!g_rng_function) {
 8005b34:	683b      	ldr	r3, [r7, #0]
 8005b36:	b913      	cbnz	r3, 8005b3e <uECC_generate_random_int+0x1e>
        return 0;
 8005b38:	2000      	movs	r0, #0
 8005b3a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    }

    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
        if (!g_rng_function((uint8_t *)random, num_words * uECC_WORD_SIZE)) {
 8005b3e:	2404      	movs	r4, #4
            return 0;
	    }
        random[num_words - 1] &= mask >> ((bitcount_t)(num_words * uECC_WORD_SIZE * 8 - num_bits));
 8005b40:	ebc0 1045 	rsb	r0, r0, r5, lsl #5
    if (!g_rng_function) {
        return 0;
    }

    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
        if (!g_rng_function((uint8_t *)random, num_words * uECC_WORD_SIZE)) {
 8005b44:	fb15 fb04 	smulbb	fp, r5, r4
            return 0;
	    }
        random[num_words - 1] &= mask >> ((bitcount_t)(num_words * uECC_WORD_SIZE * 8 - num_bits));
 8005b48:	b200      	sxth	r0, r0
 8005b4a:	fb04 6405 	mla	r4, r4, r5, r6
 8005b4e:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
 8005b52:	3c04      	subs	r4, #4
 8005b54:	fa29 f900 	lsr.w	r9, r9, r0
 8005b58:	f04f 0840 	mov.w	r8, #64	; 0x40
    if (!g_rng_function) {
        return 0;
    }

    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
        if (!g_rng_function((uint8_t *)random, num_words * uECC_WORD_SIZE)) {
 8005b5c:	683b      	ldr	r3, [r7, #0]
 8005b5e:	4659      	mov	r1, fp
 8005b60:	4630      	mov	r0, r6
 8005b62:	4798      	blx	r3
 8005b64:	2800      	cmp	r0, #0
 8005b66:	d0e7      	beq.n	8005b38 <uECC_generate_random_int+0x18>
            return 0;
	    }
        random[num_words - 1] &= mask >> ((bitcount_t)(num_words * uECC_WORD_SIZE * 8 - num_bits));
 8005b68:	6823      	ldr	r3, [r4, #0]
 8005b6a:	ea03 0309 	and.w	r3, r3, r9
 8005b6e:	6023      	str	r3, [r4, #0]
        if (!uECC_vli_isZero(random, num_words) &&
 8005b70:	4629      	mov	r1, r5
 8005b72:	4630      	mov	r0, r6
 8005b74:	f7ff fd06 	bl	8005584 <uECC_vli_isZero>
 8005b78:	b118      	cbz	r0, 8005b82 <uECC_generate_random_int+0x62>

    if (!g_rng_function) {
        return 0;
    }

    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
 8005b7a:	f1b8 0801 	subs.w	r8, r8, #1
 8005b7e:	d1ed      	bne.n	8005b5c <uECC_generate_random_int+0x3c>
 8005b80:	e7da      	b.n	8005b38 <uECC_generate_random_int+0x18>
        if (!g_rng_function((uint8_t *)random, num_words * uECC_WORD_SIZE)) {
            return 0;
	    }
        random[num_words - 1] &= mask >> ((bitcount_t)(num_words * uECC_WORD_SIZE * 8 - num_bits));
        if (!uECC_vli_isZero(random, num_words) &&
		        uECC_vli_cmp(top, random, num_words) == 1) {
 8005b82:	462a      	mov	r2, r5
 8005b84:	4631      	mov	r1, r6
 8005b86:	4650      	mov	r0, sl
 8005b88:	f7ff ffb2 	bl	8005af0 <uECC_vli_cmp>
    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
        if (!g_rng_function((uint8_t *)random, num_words * uECC_WORD_SIZE)) {
            return 0;
	    }
        random[num_words - 1] &= mask >> ((bitcount_t)(num_words * uECC_WORD_SIZE * 8 - num_bits));
        if (!uECC_vli_isZero(random, num_words) &&
 8005b8c:	2801      	cmp	r0, #1
 8005b8e:	d1f4      	bne.n	8005b7a <uECC_generate_random_int+0x5a>
		        uECC_vli_cmp(top, random, num_words) == 1) {
            return 1;
        }
    }
    return 0;
}
 8005b90:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005b94:	20000234 	.word	0x20000234

08005b98 <uECC_vli_modAdd>:
   Assumes that left < mod and right < mod, and that result does not overlap mod. */
uECC_VLI_API void uECC_vli_modAdd(uECC_word_t *result,
                                  const uECC_word_t *left,
                                  const uECC_word_t *right,
                                  const uECC_word_t *mod,
                                  wordcount_t num_words) {
 8005b98:	b570      	push	{r4, r5, r6, lr}
 8005b9a:	4604      	mov	r4, r0
 8005b9c:	461d      	mov	r5, r3
 8005b9e:	f99d 6010 	ldrsb.w	r6, [sp, #16]
    uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
 8005ba2:	f7ff fed5 	bl	8005950 <uECC_vli_add.isra.0>
    if (carry || uECC_vli_cmp_unsafe(mod, result, num_words) != 1) {
 8005ba6:	b930      	cbnz	r0, 8005bb6 <uECC_vli_modAdd+0x1e>
 8005ba8:	4632      	mov	r2, r6
 8005baa:	4621      	mov	r1, r4
 8005bac:	4628      	mov	r0, r5
 8005bae:	f7ff fd31 	bl	8005614 <uECC_vli_cmp_unsafe>
 8005bb2:	2801      	cmp	r0, #1
 8005bb4:	d006      	beq.n	8005bc4 <uECC_vli_modAdd+0x2c>
        /* result > mod (result = mod + remainder), so subtract mod to get remainder. */
        uECC_vli_sub(result, result, mod, num_words);
 8005bb6:	462a      	mov	r2, r5
 8005bb8:	4621      	mov	r1, r4
 8005bba:	4620      	mov	r0, r4
    }
}
 8005bbc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
                                  const uECC_word_t *mod,
                                  wordcount_t num_words) {
    uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
    if (carry || uECC_vli_cmp_unsafe(mod, result, num_words) != 1) {
        /* result > mod (result = mod + remainder), so subtract mod to get remainder. */
        uECC_vli_sub(result, result, mod, num_words);
 8005bc0:	f7ff bf6f 	b.w	8005aa2 <uECC_vli_sub.isra.1>
 8005bc4:	bd70      	pop	{r4, r5, r6, pc}

08005bc6 <x_side_secp256k1>:
    uECC_vli_modMult_fast(Y1, Y1, t4, curve);                   /* t2 = B * (A - x3) */
    uECC_vli_modSub(Y1, Y1, t5, curve->p, num_words_secp256k1); /* t2 = B * (A - x3) - y1^4 = y3 */
}

/* Computes result = x^3 + b. result must not overlap x. */
static void x_side_secp256k1(uECC_word_t *result, const uECC_word_t *x, uECC_Curve curve) {
 8005bc6:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8005bc8:	4604      	mov	r4, r0
 8005bca:	4615      	mov	r5, r2
 8005bcc:	460e      	mov	r6, r1
    uECC_vli_modSquare_fast(result, x, curve);                                /* r = x^2 */
 8005bce:	f7ff fdff 	bl	80057d0 <uECC_vli_modSquare_fast>
    uECC_vli_modMult_fast(result, result, x, curve);                          /* r = x^3 */
 8005bd2:	462b      	mov	r3, r5
 8005bd4:	4632      	mov	r2, r6
 8005bd6:	4621      	mov	r1, r4
 8005bd8:	4620      	mov	r0, r4
 8005bda:	f7ff fde9 	bl	80057b0 <uECC_vli_modMult_fast>
    uECC_vli_modAdd(result, result, curve->b, curve->p, num_words_secp256k1); /* r = x^3 + b */
 8005bde:	2308      	movs	r3, #8
 8005be0:	9300      	str	r3, [sp, #0]
 8005be2:	f105 0284 	add.w	r2, r5, #132	; 0x84
 8005be6:	1d2b      	adds	r3, r5, #4
 8005be8:	4621      	mov	r1, r4
 8005bea:	4620      	mov	r0, r4
 8005bec:	f7ff ffd4 	bl	8005b98 <uECC_vli_modAdd>
}
 8005bf0:	b002      	add	sp, #8
 8005bf2:	bd70      	pop	{r4, r5, r6, pc}

08005bf4 <vli_mmod_fast_secp256r1>:
            carry -= uECC_vli_sub(result, result, curve_secp256r1.p, num_words_secp256r1);
        }
    }
}
#elif uECC_WORD_SIZE == 4
static void vli_mmod_fast_secp256r1(uint32_t *result, uint32_t *product) {
 8005bf4:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint32_t tmp[num_words_secp256r1];
    int carry;
    
    /* t */
    uECC_vli_set(result, product, num_words_secp256r1);
 8005bf6:	2208      	movs	r2, #8
            carry -= uECC_vli_sub(result, result, curve_secp256r1.p, num_words_secp256r1);
        }
    }
}
#elif uECC_WORD_SIZE == 4
static void vli_mmod_fast_secp256r1(uint32_t *result, uint32_t *product) {
 8005bf8:	b089      	sub	sp, #36	; 0x24
 8005bfa:	460c      	mov	r4, r1
 8005bfc:	4606      	mov	r6, r0
    uint32_t tmp[num_words_secp256r1];
    int carry;
    
    /* t */
    uECC_vli_set(result, product, num_words_secp256r1);
 8005bfe:	f7ff fcfc 	bl	80055fa <uECC_vli_set>
    
    /* s1 */
    tmp[0] = tmp[1] = tmp[2] = 0;
    tmp[3] = product[11];
 8005c02:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 8005c04:	9303      	str	r3, [sp, #12]
    tmp[4] = product[12];
 8005c06:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 8005c08:	9304      	str	r3, [sp, #16]
    tmp[5] = product[13];
 8005c0a:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 8005c0c:	9305      	str	r3, [sp, #20]
    tmp[6] = product[14];
 8005c0e:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 8005c10:	9306      	str	r3, [sp, #24]
    
    /* t */
    uECC_vli_set(result, product, num_words_secp256r1);
    
    /* s1 */
    tmp[0] = tmp[1] = tmp[2] = 0;
 8005c12:	2700      	movs	r7, #0
    tmp[3] = product[11];
    tmp[4] = product[12];
    tmp[5] = product[13];
    tmp[6] = product[14];
    tmp[7] = product[15];
 8005c14:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 8005c16:	9307      	str	r3, [sp, #28]
    carry = uECC_vli_add(tmp, tmp, tmp, num_words_secp256r1);
 8005c18:	466a      	mov	r2, sp
 8005c1a:	4669      	mov	r1, sp
 8005c1c:	4668      	mov	r0, sp
    
    /* t */
    uECC_vli_set(result, product, num_words_secp256r1);
    
    /* s1 */
    tmp[0] = tmp[1] = tmp[2] = 0;
 8005c1e:	9702      	str	r7, [sp, #8]
 8005c20:	9701      	str	r7, [sp, #4]
 8005c22:	9700      	str	r7, [sp, #0]
    tmp[3] = product[11];
    tmp[4] = product[12];
    tmp[5] = product[13];
    tmp[6] = product[14];
    tmp[7] = product[15];
    carry = uECC_vli_add(tmp, tmp, tmp, num_words_secp256r1);
 8005c24:	f7ff fe94 	bl	8005950 <uECC_vli_add.isra.0>
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005c28:	466a      	mov	r2, sp
    tmp[3] = product[11];
    tmp[4] = product[12];
    tmp[5] = product[13];
    tmp[6] = product[14];
    tmp[7] = product[15];
    carry = uECC_vli_add(tmp, tmp, tmp, num_words_secp256r1);
 8005c2a:	4605      	mov	r5, r0
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005c2c:	4631      	mov	r1, r6
 8005c2e:	4630      	mov	r0, r6
 8005c30:	f7ff fe8e 	bl	8005950 <uECC_vli_add.isra.0>
    
    /* s2 */
    tmp[3] = product[12];
 8005c34:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005c36:	9303      	str	r3, [sp, #12]
    tmp[4] = product[13];
 8005c38:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005c3a:	9304      	str	r3, [sp, #16]
    tmp[5] = product[14];
 8005c3c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005c3e:	9305      	str	r3, [sp, #20]
    tmp[4] = product[12];
    tmp[5] = product[13];
    tmp[6] = product[14];
    tmp[7] = product[15];
    carry = uECC_vli_add(tmp, tmp, tmp, num_words_secp256r1);
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005c40:	4405      	add	r5, r0
    
    /* s2 */
    tmp[3] = product[12];
    tmp[4] = product[13];
    tmp[5] = product[14];
    tmp[6] = product[15];
 8005c42:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005c44:	9306      	str	r3, [sp, #24]
    tmp[7] = 0;
    carry += uECC_vli_add(tmp, tmp, tmp, num_words_secp256r1);
 8005c46:	466a      	mov	r2, sp
 8005c48:	4669      	mov	r1, sp
 8005c4a:	4668      	mov	r0, sp
    /* s2 */
    tmp[3] = product[12];
    tmp[4] = product[13];
    tmp[5] = product[14];
    tmp[6] = product[15];
    tmp[7] = 0;
 8005c4c:	9707      	str	r7, [sp, #28]
    carry += uECC_vli_add(tmp, tmp, tmp, num_words_secp256r1);
 8005c4e:	f7ff fe7f 	bl	8005950 <uECC_vli_add.isra.0>
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005c52:	466a      	mov	r2, sp
    tmp[3] = product[12];
    tmp[4] = product[13];
    tmp[5] = product[14];
    tmp[6] = product[15];
    tmp[7] = 0;
    carry += uECC_vli_add(tmp, tmp, tmp, num_words_secp256r1);
 8005c54:	4405      	add	r5, r0
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005c56:	4631      	mov	r1, r6
 8005c58:	4630      	mov	r0, r6
 8005c5a:	f7ff fe79 	bl	8005950 <uECC_vli_add.isra.0>
    
    /* s3 */
    tmp[0] = product[8];
 8005c5e:	6a23      	ldr	r3, [r4, #32]
 8005c60:	9300      	str	r3, [sp, #0]
    tmp[1] = product[9];
 8005c62:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005c64:	9301      	str	r3, [sp, #4]
    tmp[2] = product[10];
 8005c66:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8005c68:	9302      	str	r3, [sp, #8]
    tmp[3] = tmp[4] = tmp[5] = 0;
    tmp[6] = product[14];
 8005c6a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005c6c:	9306      	str	r3, [sp, #24]
    tmp[4] = product[13];
    tmp[5] = product[14];
    tmp[6] = product[15];
    tmp[7] = 0;
    carry += uECC_vli_add(tmp, tmp, tmp, num_words_secp256r1);
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005c6e:	4405      	add	r5, r0
    tmp[0] = product[8];
    tmp[1] = product[9];
    tmp[2] = product[10];
    tmp[3] = tmp[4] = tmp[5] = 0;
    tmp[6] = product[14];
    tmp[7] = product[15];
 8005c70:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005c72:	9307      	str	r3, [sp, #28]
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005c74:	466a      	mov	r2, sp
 8005c76:	4631      	mov	r1, r6
 8005c78:	4630      	mov	r0, r6
    
    /* s3 */
    tmp[0] = product[8];
    tmp[1] = product[9];
    tmp[2] = product[10];
    tmp[3] = tmp[4] = tmp[5] = 0;
 8005c7a:	9705      	str	r7, [sp, #20]
 8005c7c:	9704      	str	r7, [sp, #16]
 8005c7e:	9703      	str	r7, [sp, #12]
    tmp[6] = product[14];
    tmp[7] = product[15];
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005c80:	f7ff fe66 	bl	8005950 <uECC_vli_add.isra.0>
    
    /* s4 */
    tmp[0] = product[9];
 8005c84:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005c86:	9300      	str	r3, [sp, #0]
    tmp[1] = product[10];
 8005c88:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    tmp[2] = product[11];
    tmp[3] = product[13];
    tmp[4] = product[14];
 8005c8a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    tmp[7] = product[15];
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
    
    /* s4 */
    tmp[0] = product[9];
    tmp[1] = product[10];
 8005c8c:	9301      	str	r3, [sp, #4]
    tmp[2] = product[11];
 8005c8e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8005c90:	9302      	str	r3, [sp, #8]
    tmp[3] = product[13];
    tmp[4] = product[14];
 8005c92:	9204      	str	r2, [sp, #16]
    
    /* s4 */
    tmp[0] = product[9];
    tmp[1] = product[10];
    tmp[2] = product[11];
    tmp[3] = product[13];
 8005c94:	6b63      	ldr	r3, [r4, #52]	; 0x34
    tmp[4] = product[14];
    tmp[5] = product[15];
 8005c96:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    
    /* s4 */
    tmp[0] = product[9];
    tmp[1] = product[10];
    tmp[2] = product[11];
    tmp[3] = product[13];
 8005c98:	9303      	str	r3, [sp, #12]
    tmp[1] = product[9];
    tmp[2] = product[10];
    tmp[3] = tmp[4] = tmp[5] = 0;
    tmp[6] = product[14];
    tmp[7] = product[15];
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005c9a:	4405      	add	r5, r0
    tmp[0] = product[9];
    tmp[1] = product[10];
    tmp[2] = product[11];
    tmp[3] = product[13];
    tmp[4] = product[14];
    tmp[5] = product[15];
 8005c9c:	9205      	str	r2, [sp, #20]
    tmp[6] = product[13];
 8005c9e:	9306      	str	r3, [sp, #24]
    tmp[7] = product[8];
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005ca0:	466a      	mov	r2, sp
    tmp[2] = product[11];
    tmp[3] = product[13];
    tmp[4] = product[14];
    tmp[5] = product[15];
    tmp[6] = product[13];
    tmp[7] = product[8];
 8005ca2:	6a23      	ldr	r3, [r4, #32]
 8005ca4:	9307      	str	r3, [sp, #28]
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005ca6:	4631      	mov	r1, r6
 8005ca8:	4630      	mov	r0, r6
 8005caa:	f7ff fe51 	bl	8005950 <uECC_vli_add.isra.0>
    
    /* d1 */
    tmp[0] = product[11];
 8005cae:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8005cb0:	9300      	str	r3, [sp, #0]
    tmp[1] = product[12];
 8005cb2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005cb4:	9301      	str	r3, [sp, #4]
    tmp[2] = product[13];
 8005cb6:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005cb8:	9302      	str	r3, [sp, #8]
    tmp[3] = tmp[4] = tmp[5] = 0;
    tmp[6] = product[8];
 8005cba:	6a23      	ldr	r3, [r4, #32]
 8005cbc:	9306      	str	r3, [sp, #24]
    tmp[3] = product[13];
    tmp[4] = product[14];
    tmp[5] = product[15];
    tmp[6] = product[13];
    tmp[7] = product[8];
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005cbe:	4405      	add	r5, r0
    tmp[0] = product[11];
    tmp[1] = product[12];
    tmp[2] = product[13];
    tmp[3] = tmp[4] = tmp[5] = 0;
    tmp[6] = product[8];
    tmp[7] = product[10];
 8005cc0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8005cc2:	9307      	str	r3, [sp, #28]
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
 8005cc4:	466a      	mov	r2, sp
 8005cc6:	4631      	mov	r1, r6
 8005cc8:	4630      	mov	r0, r6
    
    /* d1 */
    tmp[0] = product[11];
    tmp[1] = product[12];
    tmp[2] = product[13];
    tmp[3] = tmp[4] = tmp[5] = 0;
 8005cca:	9705      	str	r7, [sp, #20]
 8005ccc:	9704      	str	r7, [sp, #16]
 8005cce:	9703      	str	r7, [sp, #12]
    tmp[6] = product[8];
    tmp[7] = product[10];
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
 8005cd0:	f7ff fee7 	bl	8005aa2 <uECC_vli_sub.isra.1>
    
    /* d2 */
    tmp[0] = product[12];
 8005cd4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005cd6:	9300      	str	r3, [sp, #0]
    tmp[1] = product[13];
 8005cd8:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005cda:	9301      	str	r3, [sp, #4]
    tmp[2] = product[14];
 8005cdc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005cde:	9302      	str	r3, [sp, #8]
    tmp[3] = product[15];
 8005ce0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005ce2:	9303      	str	r3, [sp, #12]
    tmp[4] = tmp[5] = 0;
    tmp[6] = product[9];
 8005ce4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005ce6:	9306      	str	r3, [sp, #24]
    tmp[1] = product[12];
    tmp[2] = product[13];
    tmp[3] = tmp[4] = tmp[5] = 0;
    tmp[6] = product[8];
    tmp[7] = product[10];
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
 8005ce8:	1a2d      	subs	r5, r5, r0
    tmp[1] = product[13];
    tmp[2] = product[14];
    tmp[3] = product[15];
    tmp[4] = tmp[5] = 0;
    tmp[6] = product[9];
    tmp[7] = product[11];
 8005cea:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8005cec:	9307      	str	r3, [sp, #28]
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
 8005cee:	466a      	mov	r2, sp
 8005cf0:	4631      	mov	r1, r6
 8005cf2:	4630      	mov	r0, r6
    /* d2 */
    tmp[0] = product[12];
    tmp[1] = product[13];
    tmp[2] = product[14];
    tmp[3] = product[15];
    tmp[4] = tmp[5] = 0;
 8005cf4:	9705      	str	r7, [sp, #20]
 8005cf6:	9704      	str	r7, [sp, #16]
    tmp[6] = product[9];
    tmp[7] = product[11];
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
 8005cf8:	f7ff fed3 	bl	8005aa2 <uECC_vli_sub.isra.1>
    
    /* d3 */
    tmp[0] = product[13];
 8005cfc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005cfe:	9300      	str	r3, [sp, #0]
    tmp[1] = product[14];
 8005d00:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005d02:	9301      	str	r3, [sp, #4]
    tmp[2] = product[15];
 8005d04:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005d06:	9302      	str	r3, [sp, #8]
    tmp[3] = product[8];
 8005d08:	6a23      	ldr	r3, [r4, #32]
 8005d0a:	9303      	str	r3, [sp, #12]
    tmp[4] = product[9];
 8005d0c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005d0e:	9304      	str	r3, [sp, #16]
    tmp[5] = product[10];
 8005d10:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8005d12:	9305      	str	r3, [sp, #20]
    tmp[2] = product[14];
    tmp[3] = product[15];
    tmp[4] = tmp[5] = 0;
    tmp[6] = product[9];
    tmp[7] = product[11];
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
 8005d14:	1a2d      	subs	r5, r5, r0
    tmp[2] = product[15];
    tmp[3] = product[8];
    tmp[4] = product[9];
    tmp[5] = product[10];
    tmp[6] = 0;
    tmp[7] = product[12];
 8005d16:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005d18:	9307      	str	r3, [sp, #28]
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
 8005d1a:	466a      	mov	r2, sp
 8005d1c:	4631      	mov	r1, r6
 8005d1e:	4630      	mov	r0, r6
    tmp[1] = product[14];
    tmp[2] = product[15];
    tmp[3] = product[8];
    tmp[4] = product[9];
    tmp[5] = product[10];
    tmp[6] = 0;
 8005d20:	9706      	str	r7, [sp, #24]
    tmp[7] = product[12];
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
 8005d22:	f7ff febe 	bl	8005aa2 <uECC_vli_sub.isra.1>
    
    /* d4 */
    tmp[0] = product[14];
 8005d26:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005d28:	9300      	str	r3, [sp, #0]
    tmp[1] = product[15];
 8005d2a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005d2c:	9301      	str	r3, [sp, #4]
    tmp[2] = 0;
    tmp[3] = product[9];
 8005d2e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005d30:	9303      	str	r3, [sp, #12]
    tmp[4] = product[10];
 8005d32:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8005d34:	9304      	str	r3, [sp, #16]
    tmp[5] = product[11];
 8005d36:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8005d38:	9305      	str	r3, [sp, #20]
    tmp[3] = product[8];
    tmp[4] = product[9];
    tmp[5] = product[10];
    tmp[6] = 0;
    tmp[7] = product[12];
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
 8005d3a:	1a2d      	subs	r5, r5, r0
    tmp[2] = 0;
    tmp[3] = product[9];
    tmp[4] = product[10];
    tmp[5] = product[11];
    tmp[6] = 0;
    tmp[7] = product[13];
 8005d3c:	6b63      	ldr	r3, [r4, #52]	; 0x34
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
    
    /* d4 */
    tmp[0] = product[14];
    tmp[1] = product[15];
    tmp[2] = 0;
 8005d3e:	9702      	str	r7, [sp, #8]
    tmp[3] = product[9];
    tmp[4] = product[10];
    tmp[5] = product[11];
    tmp[6] = 0;
    tmp[7] = product[13];
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
 8005d40:	466a      	mov	r2, sp
 8005d42:	4631      	mov	r1, r6
 8005d44:	4630      	mov	r0, r6
    tmp[1] = product[15];
    tmp[2] = 0;
    tmp[3] = product[9];
    tmp[4] = product[10];
    tmp[5] = product[11];
    tmp[6] = 0;
 8005d46:	9706      	str	r7, [sp, #24]
    tmp[7] = product[13];
 8005d48:	9307      	str	r3, [sp, #28]
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
 8005d4a:	f7ff feaa 	bl	8005aa2 <uECC_vli_sub.isra.1>
    
    if (carry < 0) {
 8005d4e:	1a2d      	subs	r5, r5, r0
 8005d50:	d514      	bpl.n	8005d7c <vli_mmod_fast_secp256r1+0x188>
        do {
            carry += uECC_vli_add(result, result, curve_secp256r1.p, num_words_secp256r1);
 8005d52:	4a0d      	ldr	r2, [pc, #52]	; (8005d88 <vli_mmod_fast_secp256r1+0x194>)
 8005d54:	4631      	mov	r1, r6
 8005d56:	4630      	mov	r0, r6
 8005d58:	f7ff fdfa 	bl	8005950 <uECC_vli_add.isra.0>
        } while (carry < 0);
 8005d5c:	182d      	adds	r5, r5, r0
 8005d5e:	d4f8      	bmi.n	8005d52 <vli_mmod_fast_secp256r1+0x15e>
 8005d60:	e00f      	b.n	8005d82 <vli_mmod_fast_secp256r1+0x18e>
    } else {
        while (carry || uECC_vli_cmp_unsafe(curve_secp256r1.p, result, num_words_secp256r1) != 1) {
 8005d62:	2208      	movs	r2, #8
 8005d64:	4631      	mov	r1, r6
 8005d66:	4808      	ldr	r0, [pc, #32]	; (8005d88 <vli_mmod_fast_secp256r1+0x194>)
 8005d68:	f7ff fc54 	bl	8005614 <uECC_vli_cmp_unsafe>
 8005d6c:	2801      	cmp	r0, #1
 8005d6e:	d008      	beq.n	8005d82 <vli_mmod_fast_secp256r1+0x18e>
            carry -= uECC_vli_sub(result, result, curve_secp256r1.p, num_words_secp256r1);
 8005d70:	4a05      	ldr	r2, [pc, #20]	; (8005d88 <vli_mmod_fast_secp256r1+0x194>)
 8005d72:	4631      	mov	r1, r6
 8005d74:	4630      	mov	r0, r6
 8005d76:	f7ff fe94 	bl	8005aa2 <uECC_vli_sub.isra.1>
 8005d7a:	1a2d      	subs	r5, r5, r0
    if (carry < 0) {
        do {
            carry += uECC_vli_add(result, result, curve_secp256r1.p, num_words_secp256r1);
        } while (carry < 0);
    } else {
        while (carry || uECC_vli_cmp_unsafe(curve_secp256r1.p, result, num_words_secp256r1) != 1) {
 8005d7c:	2d00      	cmp	r5, #0
 8005d7e:	d0f0      	beq.n	8005d62 <vli_mmod_fast_secp256r1+0x16e>
 8005d80:	e7f6      	b.n	8005d70 <vli_mmod_fast_secp256r1+0x17c>
            carry -= uECC_vli_sub(result, result, curve_secp256r1.p, num_words_secp256r1);
        }
    }
}
 8005d82:	b009      	add	sp, #36	; 0x24
 8005d84:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005d86:	bf00      	nop
 8005d88:	0800e678 	.word	0x0800e678

08005d8c <vli_mmod_fast_secp256k1>:
    uECC_vli_modAdd(result, result, curve->b, curve->p, num_words_secp256k1); /* r = x^3 + b */
}

#if (uECC_OPTIMIZATION_LEVEL > 0)
static void omega_mult_secp256k1(uECC_word_t *result, const uECC_word_t *right);
static void vli_mmod_fast_secp256k1(uECC_word_t *result, uECC_word_t *product) {
 8005d8c:	b570      	push	{r4, r5, r6, lr}
 8005d8e:	b090      	sub	sp, #64	; 0x40
 8005d90:	460e      	mov	r6, r1
 8005d92:	4604      	mov	r4, r0
    uECC_word_t tmp[2 * num_words_secp256k1];
    uECC_word_t carry;
    
    uECC_vli_clear(tmp, num_words_secp256k1);
 8005d94:	2108      	movs	r1, #8
 8005d96:	4668      	mov	r0, sp
 8005d98:	f7ff fbe8 	bl	800556c <uECC_vli_clear>
    uECC_vli_clear(tmp + num_words_secp256k1, num_words_secp256k1);
 8005d9c:	2108      	movs	r1, #8
 8005d9e:	a808      	add	r0, sp, #32
 8005da0:	f7ff fbe4 	bl	800556c <uECC_vli_clear>
    
    omega_mult_secp256k1(tmp, product + num_words_secp256k1); /* (Rq, q) = q * c */
 8005da4:	f106 0120 	add.w	r1, r6, #32
 8005da8:	4668      	mov	r0, sp
 8005daa:	f7ff fe37 	bl	8005a1c <omega_mult_secp256k1>
    
    carry = uECC_vli_add(result, product, tmp, num_words_secp256k1); /* (C, r) = r + q       */
 8005dae:	466a      	mov	r2, sp
 8005db0:	4631      	mov	r1, r6
 8005db2:	4620      	mov	r0, r4
 8005db4:	f7ff fdcc 	bl	8005950 <uECC_vli_add.isra.0>
    uECC_vli_clear(product, num_words_secp256k1);
 8005db8:	2108      	movs	r1, #8
    uECC_vli_clear(tmp, num_words_secp256k1);
    uECC_vli_clear(tmp + num_words_secp256k1, num_words_secp256k1);
    
    omega_mult_secp256k1(tmp, product + num_words_secp256k1); /* (Rq, q) = q * c */
    
    carry = uECC_vli_add(result, product, tmp, num_words_secp256k1); /* (C, r) = r + q       */
 8005dba:	4605      	mov	r5, r0
    uECC_vli_clear(product, num_words_secp256k1);
 8005dbc:	4630      	mov	r0, r6
 8005dbe:	f7ff fbd5 	bl	800556c <uECC_vli_clear>
    omega_mult_secp256k1(product, tmp + num_words_secp256k1); /* Rq*c */
 8005dc2:	a908      	add	r1, sp, #32
 8005dc4:	4630      	mov	r0, r6
 8005dc6:	f7ff fe29 	bl	8005a1c <omega_mult_secp256k1>
    carry += uECC_vli_add(result, result, product, num_words_secp256k1); /* (C1, r) = r + Rq*c */
 8005dca:	4632      	mov	r2, r6
 8005dcc:	4621      	mov	r1, r4
 8005dce:	4620      	mov	r0, r4
 8005dd0:	f7ff fdbe 	bl	8005950 <uECC_vli_add.isra.0>
 8005dd4:	4405      	add	r5, r0
    
    while (carry > 0) {
 8005dd6:	b135      	cbz	r5, 8005de6 <vli_mmod_fast_secp256k1+0x5a>
        --carry;
        uECC_vli_sub(result, result, curve_secp256k1.p, num_words_secp256k1);
 8005dd8:	4a0a      	ldr	r2, [pc, #40]	; (8005e04 <vli_mmod_fast_secp256k1+0x78>)
 8005dda:	4621      	mov	r1, r4
 8005ddc:	4620      	mov	r0, r4
    uECC_vli_clear(product, num_words_secp256k1);
    omega_mult_secp256k1(product, tmp + num_words_secp256k1); /* Rq*c */
    carry += uECC_vli_add(result, result, product, num_words_secp256k1); /* (C1, r) = r + Rq*c */
    
    while (carry > 0) {
        --carry;
 8005dde:	3d01      	subs	r5, #1
        uECC_vli_sub(result, result, curve_secp256k1.p, num_words_secp256k1);
 8005de0:	f7ff fe5f 	bl	8005aa2 <uECC_vli_sub.isra.1>
 8005de4:	e7f7      	b.n	8005dd6 <vli_mmod_fast_secp256k1+0x4a>
    }
    if (uECC_vli_cmp_unsafe(result, curve_secp256k1.p, num_words_secp256k1) > 0) {
 8005de6:	2208      	movs	r2, #8
 8005de8:	4906      	ldr	r1, [pc, #24]	; (8005e04 <vli_mmod_fast_secp256k1+0x78>)
 8005dea:	4620      	mov	r0, r4
 8005dec:	f7ff fc12 	bl	8005614 <uECC_vli_cmp_unsafe>
 8005df0:	2800      	cmp	r0, #0
 8005df2:	dd04      	ble.n	8005dfe <vli_mmod_fast_secp256k1+0x72>
        uECC_vli_sub(result, result, curve_secp256k1.p, num_words_secp256k1);
 8005df4:	4a03      	ldr	r2, [pc, #12]	; (8005e04 <vli_mmod_fast_secp256k1+0x78>)
 8005df6:	4621      	mov	r1, r4
 8005df8:	4620      	mov	r0, r4
 8005dfa:	f7ff fe52 	bl	8005aa2 <uECC_vli_sub.isra.1>
    }
}
 8005dfe:	b010      	add	sp, #64	; 0x40
 8005e00:	bd70      	pop	{r4, r5, r6, pc}
 8005e02:	bf00      	nop
 8005e04:	0800e5c4 	.word	0x0800e5c4

08005e08 <bits2int>:
/* -------- ECDSA code -------- */

static void bits2int(uECC_word_t *native,
                     const uint8_t *bits,
                     unsigned bits_size,
                     uECC_Curve curve) {
 8005e08:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    unsigned num_n_bytes = BITS_TO_BYTES(curve->num_n_bits);
 8005e0c:	f9b3 5002 	ldrsh.w	r5, [r3, #2]
/* -------- ECDSA code -------- */

static void bits2int(uECC_word_t *native,
                     const uint8_t *bits,
                     unsigned bits_size,
                     uECC_Curve curve) {
 8005e10:	4689      	mov	r9, r1
    unsigned num_n_bytes = BITS_TO_BYTES(curve->num_n_bits);
 8005e12:	2408      	movs	r4, #8
 8005e14:	1de9      	adds	r1, r5, #7
    unsigned num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8005e16:	351f      	adds	r5, #31

static void bits2int(uECC_word_t *native,
                     const uint8_t *bits,
                     unsigned bits_size,
                     uECC_Curve curve) {
    unsigned num_n_bytes = BITS_TO_BYTES(curve->num_n_bits);
 8005e18:	fb91 f4f4 	sdiv	r4, r1, r4
    unsigned num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8005e1c:	2120      	movs	r1, #32
 8005e1e:	4294      	cmp	r4, r2
 8005e20:	fb95 f5f1 	sdiv	r5, r5, r1
    if (bits_size > num_n_bytes) {
        bits_size = num_n_bytes;
    }
    uECC_vli_clear(native, num_n_words);
 8005e24:	fa4f f885 	sxtb.w	r8, r5
 8005e28:	bf28      	it	cs
 8005e2a:	4614      	movcs	r4, r2
/* -------- ECDSA code -------- */

static void bits2int(uECC_word_t *native,
                     const uint8_t *bits,
                     unsigned bits_size,
                     uECC_Curve curve) {
 8005e2c:	461f      	mov	r7, r3
    unsigned num_n_bytes = BITS_TO_BYTES(curve->num_n_bits);
    unsigned num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    if (bits_size > num_n_bytes) {
        bits_size = num_n_bytes;
    }
    uECC_vli_clear(native, num_n_words);
 8005e2e:	4641      	mov	r1, r8
/* -------- ECDSA code -------- */

static void bits2int(uECC_word_t *native,
                     const uint8_t *bits,
                     unsigned bits_size,
                     uECC_Curve curve) {
 8005e30:	4606      	mov	r6, r0
    unsigned num_n_bytes = BITS_TO_BYTES(curve->num_n_bits);
    unsigned num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    if (bits_size > num_n_bytes) {
        bits_size = num_n_bytes;
    }
    uECC_vli_clear(native, num_n_words);
 8005e32:	f7ff fb9b 	bl	800556c <uECC_vli_clear>
    uECC_vli_bytesToNative(native, bits, bits_size);
 8005e36:	4622      	mov	r2, r4
 8005e38:	4649      	mov	r1, r9
 8005e3a:	f7ff fd00 	bl	800583e <uECC_vli_bytesToNative>
    if (bits_size * 8 <= (unsigned)curve->num_n_bits) {
 8005e3e:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8005e42:	00e4      	lsls	r4, r4, #3
 8005e44:	429c      	cmp	r4, r3
 8005e46:	d91f      	bls.n	8005e88 <bits2int+0x80>
        return;
    }
    int shift = bits_size * 8 - curve->num_n_bits;
 8005e48:	1ae4      	subs	r4, r4, r3
 8005e4a:	eb06 0185 	add.w	r1, r6, r5, lsl #2
    uECC_word_t carry = 0;
 8005e4e:	2300      	movs	r3, #0
    uECC_word_t *ptr = native + num_n_words;
    while (ptr-- > native) {
        uECC_word_t temp = *ptr;
        *ptr = (temp >> shift) | carry;
        carry = temp << (uECC_WORD_BITS - shift);
 8005e50:	f1c4 0020 	rsb	r0, r4, #32
        return;
    }
    int shift = bits_size * 8 - curve->num_n_bits;
    uECC_word_t carry = 0;
    uECC_word_t *ptr = native + num_n_words;
    while (ptr-- > native) {
 8005e54:	428e      	cmp	r6, r1
 8005e56:	d208      	bcs.n	8005e6a <bits2int+0x62>
        uECC_word_t temp = *ptr;
 8005e58:	f851 2d04 	ldr.w	r2, [r1, #-4]!
        *ptr = (temp >> shift) | carry;
 8005e5c:	fa22 f504 	lsr.w	r5, r2, r4
 8005e60:	432b      	orrs	r3, r5
 8005e62:	600b      	str	r3, [r1, #0]
        carry = temp << (uECC_WORD_BITS - shift);
 8005e64:	fa02 f300 	lsl.w	r3, r2, r0
 8005e68:	e7f4      	b.n	8005e54 <bits2int+0x4c>
    }

    /* Reduce mod curve_n */
    if (uECC_vli_cmp_unsafe(curve->n, native, num_n_words) != 1) {
 8005e6a:	3724      	adds	r7, #36	; 0x24
 8005e6c:	4642      	mov	r2, r8
 8005e6e:	4631      	mov	r1, r6
 8005e70:	4638      	mov	r0, r7
 8005e72:	f7ff fbcf 	bl	8005614 <uECC_vli_cmp_unsafe>
 8005e76:	2801      	cmp	r0, #1
 8005e78:	d006      	beq.n	8005e88 <bits2int+0x80>
        uECC_vli_sub(native, native, curve->n, num_n_words);
 8005e7a:	463a      	mov	r2, r7
 8005e7c:	4631      	mov	r1, r6
 8005e7e:	4630      	mov	r0, r6
    }
}
 8005e80:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        carry = temp << (uECC_WORD_BITS - shift);
    }

    /* Reduce mod curve_n */
    if (uECC_vli_cmp_unsafe(curve->n, native, num_n_words) != 1) {
        uECC_vli_sub(native, native, curve->n, num_n_words);
 8005e84:	f7ff be0d 	b.w	8005aa2 <uECC_vli_sub.isra.1>
 8005e88:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08005e8c <uECC_vli_modSub.isra.2>:
    }
}

/* Computes result = (left - right) % mod.
   Assumes that left < mod and right < mod, and that result does not overlap mod. */
uECC_VLI_API void uECC_vli_modSub(uECC_word_t *result,
 8005e8c:	b538      	push	{r3, r4, r5, lr}
 8005e8e:	4604      	mov	r4, r0
 8005e90:	461d      	mov	r5, r3
                                  const uECC_word_t *left,
                                  const uECC_word_t *right,
                                  const uECC_word_t *mod,
                                  wordcount_t num_words) {
    uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
 8005e92:	f7ff fe06 	bl	8005aa2 <uECC_vli_sub.isra.1>
    if (l_borrow) {
 8005e96:	b130      	cbz	r0, 8005ea6 <uECC_vli_modSub.isra.2+0x1a>
        /* In this case, result == -diff == (max int) - diff. Since -x % d == d - x,
           we can get the correct result from result + mod (with overflow). */
        uECC_vli_add(result, result, mod, num_words);
 8005e98:	462a      	mov	r2, r5
 8005e9a:	4621      	mov	r1, r4
 8005e9c:	4620      	mov	r0, r4
    }
}
 8005e9e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
                                  wordcount_t num_words) {
    uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
    if (l_borrow) {
        /* In this case, result == -diff == (max int) - diff. Since -x % d == d - x,
           we can get the correct result from result + mod (with overflow). */
        uECC_vli_add(result, result, mod, num_words);
 8005ea2:	f7ff bd55 	b.w	8005950 <uECC_vli_add.isra.0>
 8005ea6:	bd38      	pop	{r3, r4, r5, pc}

08005ea8 <double_jacobian_default>:
#if uECC_SUPPORTS_secp160r1 || uECC_SUPPORTS_secp192r1 || \
    uECC_SUPPORTS_secp224r1 || uECC_SUPPORTS_secp256r1
static void double_jacobian_default(uECC_word_t * X1,
                                    uECC_word_t * Y1,
                                    uECC_word_t * Z1,
                                    uECC_Curve curve) {
 8005ea8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    /* t1 = X, t2 = Y, t3 = Z */
    uECC_word_t t4[uECC_MAX_WORDS];
    uECC_word_t t5[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;

    if (uECC_vli_isZero(Z1, num_words)) {
 8005eac:	f993 6000 	ldrsb.w	r6, [r3]
#if uECC_SUPPORTS_secp160r1 || uECC_SUPPORTS_secp192r1 || \
    uECC_SUPPORTS_secp224r1 || uECC_SUPPORTS_secp256r1
static void double_jacobian_default(uECC_word_t * X1,
                                    uECC_word_t * Y1,
                                    uECC_word_t * Z1,
                                    uECC_Curve curve) {
 8005eb0:	b092      	sub	sp, #72	; 0x48
 8005eb2:	4604      	mov	r4, r0
 8005eb4:	4689      	mov	r9, r1
    /* t1 = X, t2 = Y, t3 = Z */
    uECC_word_t t4[uECC_MAX_WORDS];
    uECC_word_t t5[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;

    if (uECC_vli_isZero(Z1, num_words)) {
 8005eb6:	4610      	mov	r0, r2
 8005eb8:	4631      	mov	r1, r6
#if uECC_SUPPORTS_secp160r1 || uECC_SUPPORTS_secp192r1 || \
    uECC_SUPPORTS_secp224r1 || uECC_SUPPORTS_secp256r1
static void double_jacobian_default(uECC_word_t * X1,
                                    uECC_word_t * Y1,
                                    uECC_word_t * Z1,
                                    uECC_Curve curve) {
 8005eba:	4615      	mov	r5, r2
 8005ebc:	4698      	mov	r8, r3
    /* t1 = X, t2 = Y, t3 = Z */
    uECC_word_t t4[uECC_MAX_WORDS];
    uECC_word_t t5[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;

    if (uECC_vli_isZero(Z1, num_words)) {
 8005ebe:	f7ff fb61 	bl	8005584 <uECC_vli_isZero>
 8005ec2:	2800      	cmp	r0, #0
 8005ec4:	f040 8092 	bne.w	8005fec <double_jacobian_default+0x144>
        return;
    }

    uECC_vli_modSquare_fast(t4, Y1, curve);   /* t4 = y1^2 */
 8005ec8:	4642      	mov	r2, r8
 8005eca:	4649      	mov	r1, r9
 8005ecc:	a802      	add	r0, sp, #8
 8005ece:	f7ff fc7f 	bl	80057d0 <uECC_vli_modSquare_fast>
    uECC_vli_modMult_fast(t5, X1, t4, curve); /* t5 = x1*y1^2 = A */
 8005ed2:	4643      	mov	r3, r8
 8005ed4:	aa02      	add	r2, sp, #8
 8005ed6:	4621      	mov	r1, r4
 8005ed8:	a80a      	add	r0, sp, #40	; 0x28
 8005eda:	f7ff fc69 	bl	80057b0 <uECC_vli_modMult_fast>
    uECC_vli_modSquare_fast(t4, t4, curve);   /* t4 = y1^4 */
 8005ede:	a902      	add	r1, sp, #8
 8005ee0:	4608      	mov	r0, r1
 8005ee2:	4642      	mov	r2, r8
 8005ee4:	f7ff fc74 	bl	80057d0 <uECC_vli_modSquare_fast>
    uECC_vli_modMult_fast(Y1, Y1, Z1, curve); /* t2 = y1*z1 = z3 */
 8005ee8:	4643      	mov	r3, r8
 8005eea:	462a      	mov	r2, r5
 8005eec:	4649      	mov	r1, r9
 8005eee:	4648      	mov	r0, r9
 8005ef0:	f7ff fc5e 	bl	80057b0 <uECC_vli_modMult_fast>
    uECC_vli_modSquare_fast(Z1, Z1, curve);   /* t3 = z1^2 */

    uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
 8005ef4:	f108 0704 	add.w	r7, r8, #4

    uECC_vli_modSquare_fast(t4, Y1, curve);   /* t4 = y1^2 */
    uECC_vli_modMult_fast(t5, X1, t4, curve); /* t5 = x1*y1^2 = A */
    uECC_vli_modSquare_fast(t4, t4, curve);   /* t4 = y1^4 */
    uECC_vli_modMult_fast(Y1, Y1, Z1, curve); /* t2 = y1*z1 = z3 */
    uECC_vli_modSquare_fast(Z1, Z1, curve);   /* t3 = z1^2 */
 8005ef8:	4642      	mov	r2, r8
 8005efa:	4629      	mov	r1, r5
 8005efc:	4628      	mov	r0, r5
 8005efe:	f7ff fc67 	bl	80057d0 <uECC_vli_modSquare_fast>

    uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
 8005f02:	463b      	mov	r3, r7
 8005f04:	462a      	mov	r2, r5
 8005f06:	4621      	mov	r1, r4
 8005f08:	4620      	mov	r0, r4
 8005f0a:	9600      	str	r6, [sp, #0]
 8005f0c:	f7ff fe44 	bl	8005b98 <uECC_vli_modAdd>
    uECC_vli_modAdd(Z1, Z1, Z1, curve->p, num_words); /* t3 = 2*z1^2 */
 8005f10:	463b      	mov	r3, r7
 8005f12:	462a      	mov	r2, r5
 8005f14:	4629      	mov	r1, r5
 8005f16:	4628      	mov	r0, r5
 8005f18:	9600      	str	r6, [sp, #0]
 8005f1a:	f7ff fe3d 	bl	8005b98 <uECC_vli_modAdd>
    uECC_vli_modSub(Z1, X1, Z1, curve->p, num_words); /* t3 = x1 - z1^2 */
 8005f1e:	463b      	mov	r3, r7
 8005f20:	462a      	mov	r2, r5
 8005f22:	4621      	mov	r1, r4
 8005f24:	4628      	mov	r0, r5
 8005f26:	f7ff ffb1 	bl	8005e8c <uECC_vli_modSub.isra.2>
    uECC_vli_modMult_fast(X1, X1, Z1, curve);                /* t1 = x1^2 - z1^4 */
 8005f2a:	4643      	mov	r3, r8
 8005f2c:	462a      	mov	r2, r5
 8005f2e:	4621      	mov	r1, r4
 8005f30:	4620      	mov	r0, r4
 8005f32:	f7ff fc3d 	bl	80057b0 <uECC_vli_modMult_fast>

    uECC_vli_modAdd(Z1, X1, X1, curve->p, num_words); /* t3 = 2*(x1^2 - z1^4) */
 8005f36:	463b      	mov	r3, r7
 8005f38:	4622      	mov	r2, r4
 8005f3a:	4621      	mov	r1, r4
 8005f3c:	4628      	mov	r0, r5
 8005f3e:	9600      	str	r6, [sp, #0]
 8005f40:	f7ff fe2a 	bl	8005b98 <uECC_vli_modAdd>
    uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = 3*(x1^2 - z1^4) */
 8005f44:	463b      	mov	r3, r7
 8005f46:	9600      	str	r6, [sp, #0]
 8005f48:	462a      	mov	r2, r5
 8005f4a:	4621      	mov	r1, r4
 8005f4c:	4620      	mov	r0, r4
 8005f4e:	f7ff fe23 	bl	8005b98 <uECC_vli_modAdd>
    if (uECC_vli_testBit(X1, 0)) {
 8005f52:	6823      	ldr	r3, [r4, #0]
 8005f54:	07db      	lsls	r3, r3, #31
 8005f56:	d513      	bpl.n	8005f80 <double_jacobian_default+0xd8>
        uECC_word_t l_carry = uECC_vli_add(X1, X1, curve->p, num_words);
 8005f58:	463a      	mov	r2, r7
 8005f5a:	4621      	mov	r1, r4
 8005f5c:	4620      	mov	r0, r4
 8005f5e:	f7ff fcf7 	bl	8005950 <uECC_vli_add.isra.0>
        uECC_vli_rshift1(X1, num_words);
 8005f62:	4631      	mov	r1, r6
    uECC_vli_modMult_fast(X1, X1, Z1, curve);                /* t1 = x1^2 - z1^4 */

    uECC_vli_modAdd(Z1, X1, X1, curve->p, num_words); /* t3 = 2*(x1^2 - z1^4) */
    uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = 3*(x1^2 - z1^4) */
    if (uECC_vli_testBit(X1, 0)) {
        uECC_word_t l_carry = uECC_vli_add(X1, X1, curve->p, num_words);
 8005f64:	4682      	mov	sl, r0
        uECC_vli_rshift1(X1, num_words);
 8005f66:	4620      	mov	r0, r4
 8005f68:	f7ff fb69 	bl	800563e <uECC_vli_rshift1>
        X1[num_words - 1] |= l_carry << (uECC_WORD_BITS - 1);
 8005f6c:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
 8005f70:	3b01      	subs	r3, #1
 8005f72:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
 8005f76:	ea40 70ca 	orr.w	r0, r0, sl, lsl #31
 8005f7a:	f844 0023 	str.w	r0, [r4, r3, lsl #2]
 8005f7e:	e003      	b.n	8005f88 <double_jacobian_default+0xe0>
    } else {
        uECC_vli_rshift1(X1, num_words);
 8005f80:	4631      	mov	r1, r6
 8005f82:	4620      	mov	r0, r4
 8005f84:	f7ff fb5b 	bl	800563e <uECC_vli_rshift1>
    }
    /* t1 = 3/2*(x1^2 - z1^4) = B */

    uECC_vli_modSquare_fast(Z1, X1, curve);                  /* t3 = B^2 */
 8005f88:	4642      	mov	r2, r8
 8005f8a:	4621      	mov	r1, r4
 8005f8c:	4628      	mov	r0, r5
 8005f8e:	f7ff fc1f 	bl	80057d0 <uECC_vli_modSquare_fast>
    uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - A */
 8005f92:	463b      	mov	r3, r7
 8005f94:	aa0a      	add	r2, sp, #40	; 0x28
 8005f96:	4629      	mov	r1, r5
 8005f98:	4628      	mov	r0, r5
 8005f9a:	f7ff ff77 	bl	8005e8c <uECC_vli_modSub.isra.2>
    uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - 2A = x3 */
 8005f9e:	463b      	mov	r3, r7
 8005fa0:	aa0a      	add	r2, sp, #40	; 0x28
 8005fa2:	4629      	mov	r1, r5
 8005fa4:	4628      	mov	r0, r5
 8005fa6:	f7ff ff71 	bl	8005e8c <uECC_vli_modSub.isra.2>
    uECC_vli_modSub(t5, t5, Z1, curve->p, num_words); /* t5 = A - x3 */
 8005faa:	a90a      	add	r1, sp, #40	; 0x28
 8005fac:	4608      	mov	r0, r1
 8005fae:	463b      	mov	r3, r7
 8005fb0:	462a      	mov	r2, r5
 8005fb2:	f7ff ff6b 	bl	8005e8c <uECC_vli_modSub.isra.2>
    uECC_vli_modMult_fast(X1, X1, t5, curve);                /* t1 = B * (A - x3) */
 8005fb6:	4643      	mov	r3, r8
 8005fb8:	aa0a      	add	r2, sp, #40	; 0x28
 8005fba:	4621      	mov	r1, r4
 8005fbc:	4620      	mov	r0, r4
 8005fbe:	f7ff fbf7 	bl	80057b0 <uECC_vli_modMult_fast>
    uECC_vli_modSub(t4, X1, t4, curve->p, num_words); /* t4 = B * (A - x3) - y1^4 = y3 */
 8005fc2:	aa02      	add	r2, sp, #8
 8005fc4:	463b      	mov	r3, r7
 8005fc6:	4610      	mov	r0, r2
 8005fc8:	4621      	mov	r1, r4
 8005fca:	f7ff ff5f 	bl	8005e8c <uECC_vli_modSub.isra.2>

    uECC_vli_set(X1, Z1, num_words);
 8005fce:	4632      	mov	r2, r6
 8005fd0:	4629      	mov	r1, r5
 8005fd2:	4620      	mov	r0, r4
 8005fd4:	f7ff fb11 	bl	80055fa <uECC_vli_set>
    uECC_vli_set(Z1, Y1, num_words);
 8005fd8:	4632      	mov	r2, r6
 8005fda:	4649      	mov	r1, r9
 8005fdc:	4628      	mov	r0, r5
 8005fde:	f7ff fb0c 	bl	80055fa <uECC_vli_set>
    uECC_vli_set(Y1, t4, num_words);
 8005fe2:	4632      	mov	r2, r6
 8005fe4:	a902      	add	r1, sp, #8
 8005fe6:	4648      	mov	r0, r9
 8005fe8:	f7ff fb07 	bl	80055fa <uECC_vli_set>
}
 8005fec:	b012      	add	sp, #72	; 0x48
 8005fee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08005ff2 <x_side_default>:

/* Computes result = x^3 + ax + b. result must not overlap x. */
static void x_side_default(uECC_word_t *result, const uECC_word_t *x, uECC_Curve curve) {
 8005ff2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005ff6:	4615      	mov	r5, r2
 8005ff8:	b08a      	sub	sp, #40	; 0x28
 8005ffa:	4604      	mov	r4, r0
 8005ffc:	4688      	mov	r8, r1
    uECC_word_t _3[uECC_MAX_WORDS] = {3}; /* -a = 3 */
 8005ffe:	2220      	movs	r2, #32
 8006000:	2100      	movs	r1, #0
 8006002:	a802      	add	r0, sp, #8
 8006004:	f007 fa63 	bl	800d4ce <memset>
    wordcount_t num_words = curve->num_words;

    uECC_vli_modSquare_fast(result, x, curve);                             /* r = x^2 */
    uECC_vli_modSub(result, result, _3, curve->p, num_words);       /* r = x^2 - 3 */
 8006008:	1d2f      	adds	r7, r5, #4
    uECC_vli_set(Y1, t4, num_words);
}

/* Computes result = x^3 + ax + b. result must not overlap x. */
static void x_side_default(uECC_word_t *result, const uECC_word_t *x, uECC_Curve curve) {
    uECC_word_t _3[uECC_MAX_WORDS] = {3}; /* -a = 3 */
 800600a:	2303      	movs	r3, #3
    wordcount_t num_words = curve->num_words;
 800600c:	782e      	ldrb	r6, [r5, #0]
    uECC_vli_set(Y1, t4, num_words);
}

/* Computes result = x^3 + ax + b. result must not overlap x. */
static void x_side_default(uECC_word_t *result, const uECC_word_t *x, uECC_Curve curve) {
    uECC_word_t _3[uECC_MAX_WORDS] = {3}; /* -a = 3 */
 800600e:	9302      	str	r3, [sp, #8]
    wordcount_t num_words = curve->num_words;

    uECC_vli_modSquare_fast(result, x, curve);                             /* r = x^2 */
 8006010:	462a      	mov	r2, r5
 8006012:	4641      	mov	r1, r8
 8006014:	4620      	mov	r0, r4
 8006016:	f7ff fbdb 	bl	80057d0 <uECC_vli_modSquare_fast>
    uECC_vli_modSub(result, result, _3, curve->p, num_words);       /* r = x^2 - 3 */
 800601a:	463b      	mov	r3, r7
 800601c:	aa02      	add	r2, sp, #8
 800601e:	4621      	mov	r1, r4
 8006020:	4620      	mov	r0, r4
 8006022:	f7ff ff33 	bl	8005e8c <uECC_vli_modSub.isra.2>
    uECC_vli_modMult_fast(result, result, x, curve);                       /* r = x^3 - 3x */
    uECC_vli_modAdd(result, result, curve->b, curve->p, num_words); /* r = x^3 - 3x + b */
 8006026:	b276      	sxtb	r6, r6
    uECC_word_t _3[uECC_MAX_WORDS] = {3}; /* -a = 3 */
    wordcount_t num_words = curve->num_words;

    uECC_vli_modSquare_fast(result, x, curve);                             /* r = x^2 */
    uECC_vli_modSub(result, result, _3, curve->p, num_words);       /* r = x^2 - 3 */
    uECC_vli_modMult_fast(result, result, x, curve);                       /* r = x^3 - 3x */
 8006028:	462b      	mov	r3, r5
 800602a:	4642      	mov	r2, r8
 800602c:	4621      	mov	r1, r4
 800602e:	4620      	mov	r0, r4
 8006030:	f7ff fbbe 	bl	80057b0 <uECC_vli_modMult_fast>
    uECC_vli_modAdd(result, result, curve->b, curve->p, num_words); /* r = x^3 - 3x + b */
 8006034:	9600      	str	r6, [sp, #0]
 8006036:	463b      	mov	r3, r7
 8006038:	f105 0284 	add.w	r2, r5, #132	; 0x84
 800603c:	4621      	mov	r1, r4
 800603e:	4620      	mov	r0, r4
 8006040:	f7ff fdaa 	bl	8005b98 <uECC_vli_modAdd>
}
 8006044:	b00a      	add	sp, #40	; 0x28
 8006046:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800604a <XYcZ_add>:
*/
static void XYcZ_add(uECC_word_t * X1,
                     uECC_word_t * Y1,
                     uECC_word_t * X2,
                     uECC_word_t * Y2,
                     uECC_Curve curve) {
 800604a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800604e:	b089      	sub	sp, #36	; 0x24
 8006050:	4614      	mov	r4, r2
    /* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
    uECC_word_t t5[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;
 8006052:	9d10      	ldr	r5, [sp, #64]	; 0x40
 8006054:	f815 9b04 	ldrb.w	r9, [r5], #4
*/
static void XYcZ_add(uECC_word_t * X1,
                     uECC_word_t * Y1,
                     uECC_word_t * X2,
                     uECC_word_t * Y2,
                     uECC_Curve curve) {
 8006058:	461e      	mov	r6, r3
 800605a:	4607      	mov	r7, r0
 800605c:	4688      	mov	r8, r1
    /* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
    uECC_word_t t5[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;
    
    uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
 800605e:	462b      	mov	r3, r5
 8006060:	4602      	mov	r2, r0
 8006062:	4621      	mov	r1, r4
 8006064:	4668      	mov	r0, sp
 8006066:	f7ff ff11 	bl	8005e8c <uECC_vli_modSub.isra.2>
    uECC_vli_modSquare_fast(t5, t5, curve);                  /* t5 = (x2 - x1)^2 = A */
 800606a:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800606c:	4669      	mov	r1, sp
 800606e:	4668      	mov	r0, sp
 8006070:	f7ff fbae 	bl	80057d0 <uECC_vli_modSquare_fast>
    uECC_vli_modMult_fast(X1, X1, t5, curve);                /* t1 = x1*A = B */
 8006074:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8006076:	466a      	mov	r2, sp
 8006078:	4639      	mov	r1, r7
 800607a:	4638      	mov	r0, r7
 800607c:	f7ff fb98 	bl	80057b0 <uECC_vli_modMult_fast>
    uECC_vli_modMult_fast(X2, X2, t5, curve);                /* t3 = x2*A = C */
 8006080:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8006082:	466a      	mov	r2, sp
 8006084:	4621      	mov	r1, r4
 8006086:	4620      	mov	r0, r4
 8006088:	f7ff fb92 	bl	80057b0 <uECC_vli_modMult_fast>
    uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
 800608c:	462b      	mov	r3, r5
 800608e:	4642      	mov	r2, r8
 8006090:	4631      	mov	r1, r6
 8006092:	4630      	mov	r0, r6
 8006094:	f7ff fefa 	bl	8005e8c <uECC_vli_modSub.isra.2>
    uECC_vli_modSquare_fast(t5, Y2, curve);                  /* t5 = (y2 - y1)^2 = D */
 8006098:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800609a:	4631      	mov	r1, r6
 800609c:	4668      	mov	r0, sp
 800609e:	f7ff fb97 	bl	80057d0 <uECC_vli_modSquare_fast>
                                                        
    uECC_vli_modSub(t5, t5, X1, curve->p, num_words); /* t5 = D - B */
 80060a2:	462b      	mov	r3, r5
 80060a4:	463a      	mov	r2, r7
 80060a6:	4669      	mov	r1, sp
 80060a8:	4668      	mov	r0, sp
 80060aa:	f7ff feef 	bl	8005e8c <uECC_vli_modSub.isra.2>
    uECC_vli_modSub(t5, t5, X2, curve->p, num_words); /* t5 = D - B - C = x3 */
 80060ae:	462b      	mov	r3, r5
 80060b0:	4622      	mov	r2, r4
 80060b2:	4669      	mov	r1, sp
 80060b4:	4668      	mov	r0, sp
 80060b6:	f7ff fee9 	bl	8005e8c <uECC_vli_modSub.isra.2>
    uECC_vli_modSub(X2, X2, X1, curve->p, num_words); /* t3 = C - B */
 80060ba:	462b      	mov	r3, r5
 80060bc:	463a      	mov	r2, r7
 80060be:	4621      	mov	r1, r4
 80060c0:	4620      	mov	r0, r4
 80060c2:	f7ff fee3 	bl	8005e8c <uECC_vli_modSub.isra.2>
    uECC_vli_modMult_fast(Y1, Y1, X2, curve);                /* t2 = y1*(C - B) */
 80060c6:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80060c8:	4622      	mov	r2, r4
 80060ca:	4641      	mov	r1, r8
 80060cc:	4640      	mov	r0, r8
 80060ce:	f7ff fb6f 	bl	80057b0 <uECC_vli_modMult_fast>
    uECC_vli_modSub(X2, X1, t5, curve->p, num_words); /* t3 = B - x3 */
 80060d2:	462b      	mov	r3, r5
 80060d4:	466a      	mov	r2, sp
 80060d6:	4639      	mov	r1, r7
 80060d8:	4620      	mov	r0, r4
 80060da:	f7ff fed7 	bl	8005e8c <uECC_vli_modSub.isra.2>
    uECC_vli_modMult_fast(Y2, Y2, X2, curve);                /* t4 = (y2 - y1)*(B - x3) */
 80060de:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80060e0:	4622      	mov	r2, r4
 80060e2:	4631      	mov	r1, r6
 80060e4:	4630      	mov	r0, r6
 80060e6:	f7ff fb63 	bl	80057b0 <uECC_vli_modMult_fast>
    uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y3 */
 80060ea:	462b      	mov	r3, r5
 80060ec:	4642      	mov	r2, r8
 80060ee:	4631      	mov	r1, r6
 80060f0:	4630      	mov	r0, r6
 80060f2:	f7ff fecb 	bl	8005e8c <uECC_vli_modSub.isra.2>
    
    uECC_vli_set(X2, t5, num_words);
 80060f6:	fa4f f289 	sxtb.w	r2, r9
 80060fa:	4669      	mov	r1, sp
 80060fc:	4620      	mov	r0, r4
 80060fe:	f7ff fa7c 	bl	80055fa <uECC_vli_set>
}
 8006102:	b009      	add	sp, #36	; 0x24
 8006104:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08006108 <XYcZ_addC>:
*/
static void XYcZ_addC(uECC_word_t * X1,
                      uECC_word_t * Y1,
                      uECC_word_t * X2,
                      uECC_word_t * Y2,
                      uECC_Curve curve) {
 8006108:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800610c:	b09b      	sub	sp, #108	; 0x6c
 800610e:	4615      	mov	r5, r2
    /* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
    uECC_word_t t5[uECC_MAX_WORDS];
    uECC_word_t t6[uECC_MAX_WORDS];
    uECC_word_t t7[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;
 8006110:	9c22      	ldr	r4, [sp, #136]	; 0x88
 8006112:	f814 9b04 	ldrb.w	r9, [r4], #4
*/
static void XYcZ_addC(uECC_word_t * X1,
                      uECC_word_t * Y1,
                      uECC_word_t * X2,
                      uECC_word_t * Y2,
                      uECC_Curve curve) {
 8006116:	461f      	mov	r7, r3
 8006118:	4606      	mov	r6, r0
 800611a:	4688      	mov	r8, r1
    uECC_word_t t5[uECC_MAX_WORDS];
    uECC_word_t t6[uECC_MAX_WORDS];
    uECC_word_t t7[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;
    
    uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
 800611c:	4623      	mov	r3, r4
 800611e:	4602      	mov	r2, r0
 8006120:	4629      	mov	r1, r5
 8006122:	a802      	add	r0, sp, #8
 8006124:	f7ff feb2 	bl	8005e8c <uECC_vli_modSub.isra.2>
    uECC_vli_modSquare_fast(t5, t5, curve);                  /* t5 = (x2 - x1)^2 = A */
 8006128:	a902      	add	r1, sp, #8
 800612a:	9a22      	ldr	r2, [sp, #136]	; 0x88
 800612c:	4608      	mov	r0, r1
 800612e:	f7ff fb4f 	bl	80057d0 <uECC_vli_modSquare_fast>
    uECC_vli_modMult_fast(X1, X1, t5, curve);                /* t1 = x1*A = B */
 8006132:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8006134:	aa02      	add	r2, sp, #8
 8006136:	4631      	mov	r1, r6
 8006138:	4630      	mov	r0, r6
 800613a:	f7ff fb39 	bl	80057b0 <uECC_vli_modMult_fast>
    uECC_vli_modMult_fast(X2, X2, t5, curve);                /* t3 = x2*A = C */
    uECC_vli_modAdd(t5, Y2, Y1, curve->p, num_words); /* t5 = y2 + y1 */
 800613e:	fa4f f989 	sxtb.w	r9, r9
    wordcount_t num_words = curve->num_words;
    
    uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
    uECC_vli_modSquare_fast(t5, t5, curve);                  /* t5 = (x2 - x1)^2 = A */
    uECC_vli_modMult_fast(X1, X1, t5, curve);                /* t1 = x1*A = B */
    uECC_vli_modMult_fast(X2, X2, t5, curve);                /* t3 = x2*A = C */
 8006142:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8006144:	aa02      	add	r2, sp, #8
 8006146:	4629      	mov	r1, r5
 8006148:	4628      	mov	r0, r5
 800614a:	f7ff fb31 	bl	80057b0 <uECC_vli_modMult_fast>
    uECC_vli_modAdd(t5, Y2, Y1, curve->p, num_words); /* t5 = y2 + y1 */
 800614e:	4623      	mov	r3, r4
 8006150:	4642      	mov	r2, r8
 8006152:	4639      	mov	r1, r7
 8006154:	a802      	add	r0, sp, #8
 8006156:	f8cd 9000 	str.w	r9, [sp]
 800615a:	f7ff fd1d 	bl	8005b98 <uECC_vli_modAdd>
    uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
 800615e:	4623      	mov	r3, r4
 8006160:	4642      	mov	r2, r8
 8006162:	4639      	mov	r1, r7
 8006164:	4638      	mov	r0, r7
 8006166:	f7ff fe91 	bl	8005e8c <uECC_vli_modSub.isra.2>
                                                        
    uECC_vli_modSub(t6, X2, X1, curve->p, num_words); /* t6 = C - B */
 800616a:	4623      	mov	r3, r4
 800616c:	4632      	mov	r2, r6
 800616e:	4629      	mov	r1, r5
 8006170:	a80a      	add	r0, sp, #40	; 0x28
 8006172:	f7ff fe8b 	bl	8005e8c <uECC_vli_modSub.isra.2>
    uECC_vli_modMult_fast(Y1, Y1, t6, curve);                /* t2 = y1 * (C - B) = E */
 8006176:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8006178:	aa0a      	add	r2, sp, #40	; 0x28
 800617a:	4641      	mov	r1, r8
 800617c:	4640      	mov	r0, r8
 800617e:	f7ff fb17 	bl	80057b0 <uECC_vli_modMult_fast>
    uECC_vli_modAdd(t6, X1, X2, curve->p, num_words); /* t6 = B + C */
 8006182:	4623      	mov	r3, r4
 8006184:	462a      	mov	r2, r5
 8006186:	4631      	mov	r1, r6
 8006188:	a80a      	add	r0, sp, #40	; 0x28
 800618a:	f8cd 9000 	str.w	r9, [sp]
 800618e:	f7ff fd03 	bl	8005b98 <uECC_vli_modAdd>
    uECC_vli_modSquare_fast(X2, Y2, curve);                  /* t3 = (y2 - y1)^2 = D */
 8006192:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8006194:	4639      	mov	r1, r7
 8006196:	4628      	mov	r0, r5
 8006198:	f7ff fb1a 	bl	80057d0 <uECC_vli_modSquare_fast>
    uECC_vli_modSub(X2, X2, t6, curve->p, num_words); /* t3 = D - (B + C) = x3 */
 800619c:	4623      	mov	r3, r4
 800619e:	aa0a      	add	r2, sp, #40	; 0x28
 80061a0:	4629      	mov	r1, r5
 80061a2:	4628      	mov	r0, r5
 80061a4:	f7ff fe72 	bl	8005e8c <uECC_vli_modSub.isra.2>
                                                        
    uECC_vli_modSub(t7, X1, X2, curve->p, num_words); /* t7 = B - x3 */
 80061a8:	4623      	mov	r3, r4
 80061aa:	462a      	mov	r2, r5
 80061ac:	4631      	mov	r1, r6
 80061ae:	a812      	add	r0, sp, #72	; 0x48
 80061b0:	f7ff fe6c 	bl	8005e8c <uECC_vli_modSub.isra.2>
    uECC_vli_modMult_fast(Y2, Y2, t7, curve);                /* t4 = (y2 - y1)*(B - x3) */
 80061b4:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80061b6:	aa12      	add	r2, sp, #72	; 0x48
 80061b8:	4639      	mov	r1, r7
 80061ba:	4638      	mov	r0, r7
 80061bc:	f7ff faf8 	bl	80057b0 <uECC_vli_modMult_fast>
    uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = (y2 - y1)*(B - x3) - E = y3 */
 80061c0:	4623      	mov	r3, r4
 80061c2:	4642      	mov	r2, r8
 80061c4:	4639      	mov	r1, r7
 80061c6:	4638      	mov	r0, r7
 80061c8:	f7ff fe60 	bl	8005e8c <uECC_vli_modSub.isra.2>
                                                        
    uECC_vli_modSquare_fast(t7, t5, curve);                  /* t7 = (y2 + y1)^2 = F */
 80061cc:	9a22      	ldr	r2, [sp, #136]	; 0x88
 80061ce:	a902      	add	r1, sp, #8
 80061d0:	a812      	add	r0, sp, #72	; 0x48
 80061d2:	f7ff fafd 	bl	80057d0 <uECC_vli_modSquare_fast>
    uECC_vli_modSub(t7, t7, t6, curve->p, num_words); /* t7 = F - (B + C) = x3' */
 80061d6:	a912      	add	r1, sp, #72	; 0x48
 80061d8:	4623      	mov	r3, r4
 80061da:	aa0a      	add	r2, sp, #40	; 0x28
 80061dc:	4608      	mov	r0, r1
 80061de:	f7ff fe55 	bl	8005e8c <uECC_vli_modSub.isra.2>
    uECC_vli_modSub(t6, t7, X1, curve->p, num_words); /* t6 = x3' - B */
 80061e2:	4623      	mov	r3, r4
 80061e4:	4632      	mov	r2, r6
 80061e6:	a912      	add	r1, sp, #72	; 0x48
 80061e8:	a80a      	add	r0, sp, #40	; 0x28
 80061ea:	f7ff fe4f 	bl	8005e8c <uECC_vli_modSub.isra.2>
    uECC_vli_modMult_fast(t6, t6, t5, curve);                /* t6 = (y2+y1)*(x3' - B) */
 80061ee:	a90a      	add	r1, sp, #40	; 0x28
 80061f0:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80061f2:	aa02      	add	r2, sp, #8
 80061f4:	4608      	mov	r0, r1
 80061f6:	f7ff fadb 	bl	80057b0 <uECC_vli_modMult_fast>
    uECC_vli_modSub(Y1, t6, Y1, curve->p, num_words); /* t2 = (y2+y1)*(x3' - B) - E = y3' */
 80061fa:	4623      	mov	r3, r4
 80061fc:	4642      	mov	r2, r8
 80061fe:	a90a      	add	r1, sp, #40	; 0x28
 8006200:	4640      	mov	r0, r8
 8006202:	f7ff fe43 	bl	8005e8c <uECC_vli_modSub.isra.2>
    
    uECC_vli_set(X1, t7, num_words);
 8006206:	464a      	mov	r2, r9
 8006208:	a912      	add	r1, sp, #72	; 0x48
 800620a:	4630      	mov	r0, r6
 800620c:	f7ff f9f5 	bl	80055fa <uECC_vli_set>
}
 8006210:	b01b      	add	sp, #108	; 0x6c
 8006212:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08006216 <vli_modInv_update>:
#define EVEN(vli) (!(vli[0] & 1))
static void vli_modInv_update(uECC_word_t *uv,
                              const uECC_word_t *mod,
                              wordcount_t num_words) {
    uECC_word_t carry = 0;
    if (!EVEN(uv)) {
 8006216:	6803      	ldr	r3, [r0, #0]
#endif /* uECC_SQUARE_FUNC */

#define EVEN(vli) (!(vli[0] & 1))
static void vli_modInv_update(uECC_word_t *uv,
                              const uECC_word_t *mod,
                              wordcount_t num_words) {
 8006218:	b570      	push	{r4, r5, r6, lr}
    uECC_word_t carry = 0;
    if (!EVEN(uv)) {
 800621a:	f013 0501 	ands.w	r5, r3, #1
#endif /* uECC_SQUARE_FUNC */

#define EVEN(vli) (!(vli[0] & 1))
static void vli_modInv_update(uECC_word_t *uv,
                              const uECC_word_t *mod,
                              wordcount_t num_words) {
 800621e:	4606      	mov	r6, r0
 8006220:	4614      	mov	r4, r2
    uECC_word_t carry = 0;
    if (!EVEN(uv)) {
 8006222:	d004      	beq.n	800622e <vli_modInv_update+0x18>
        carry = uECC_vli_add(uv, uv, mod, num_words);
 8006224:	460a      	mov	r2, r1
 8006226:	4601      	mov	r1, r0
 8006228:	f7ff fb92 	bl	8005950 <uECC_vli_add.isra.0>
 800622c:	4605      	mov	r5, r0
    }
    uECC_vli_rshift1(uv, num_words);
 800622e:	4621      	mov	r1, r4
 8006230:	4630      	mov	r0, r6
 8006232:	f7ff fa04 	bl	800563e <uECC_vli_rshift1>
    if (carry) {
 8006236:	b145      	cbz	r5, 800624a <vli_modInv_update+0x34>
        uv[num_words - 1] |= HIGH_BIT_SET;
 8006238:	f104 4280 	add.w	r2, r4, #1073741824	; 0x40000000
 800623c:	3a01      	subs	r2, #1
 800623e:	f856 3022 	ldr.w	r3, [r6, r2, lsl #2]
 8006242:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8006246:	f846 3022 	str.w	r3, [r6, r2, lsl #2]
 800624a:	bd70      	pop	{r4, r5, r6, pc}

0800624c <uECC_vli_modInv>:
/* Computes result = (1 / input) % mod. All VLIs are the same size.
   See "From Euclid's GCD to Montgomery Multiplication to the Great Divide" */
uECC_VLI_API void uECC_vli_modInv(uECC_word_t *result,
                                  const uECC_word_t *input,
                                  const uECC_word_t *mod,
                                  wordcount_t num_words) {
 800624c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800624e:	460f      	mov	r7, r1
 8006250:	b0a1      	sub	sp, #132	; 0x84
 8006252:	4606      	mov	r6, r0
    uECC_word_t a[uECC_MAX_WORDS], b[uECC_MAX_WORDS], u[uECC_MAX_WORDS], v[uECC_MAX_WORDS];
    cmpresult_t cmpResult;
    
    if (uECC_vli_isZero(input, num_words)) {
 8006254:	4619      	mov	r1, r3
 8006256:	4638      	mov	r0, r7
/* Computes result = (1 / input) % mod. All VLIs are the same size.
   See "From Euclid's GCD to Montgomery Multiplication to the Great Divide" */
uECC_VLI_API void uECC_vli_modInv(uECC_word_t *result,
                                  const uECC_word_t *input,
                                  const uECC_word_t *mod,
                                  wordcount_t num_words) {
 8006258:	4615      	mov	r5, r2
 800625a:	461c      	mov	r4, r3
    uECC_word_t a[uECC_MAX_WORDS], b[uECC_MAX_WORDS], u[uECC_MAX_WORDS], v[uECC_MAX_WORDS];
    cmpresult_t cmpResult;
    
    if (uECC_vli_isZero(input, num_words)) {
 800625c:	f7ff f992 	bl	8005584 <uECC_vli_isZero>
 8006260:	b120      	cbz	r0, 800626c <uECC_vli_modInv+0x20>
        uECC_vli_clear(result, num_words);
 8006262:	4621      	mov	r1, r4
 8006264:	4630      	mov	r0, r6
 8006266:	f7ff f981 	bl	800556c <uECC_vli_clear>
 800626a:	e06f      	b.n	800634c <uECC_vli_modInv+0x100>
        return;
    }

    uECC_vli_set(a, input, num_words);
 800626c:	4622      	mov	r2, r4
 800626e:	4639      	mov	r1, r7
 8006270:	4668      	mov	r0, sp
 8006272:	f7ff f9c2 	bl	80055fa <uECC_vli_set>
    uECC_vli_set(b, mod, num_words);
 8006276:	4622      	mov	r2, r4
 8006278:	4629      	mov	r1, r5
 800627a:	a808      	add	r0, sp, #32
 800627c:	f7ff f9bd 	bl	80055fa <uECC_vli_set>
    uECC_vli_clear(u, num_words);
 8006280:	4621      	mov	r1, r4
 8006282:	a810      	add	r0, sp, #64	; 0x40
 8006284:	f7ff f972 	bl	800556c <uECC_vli_clear>
    u[0] = 1;
 8006288:	2301      	movs	r3, #1
    uECC_vli_clear(v, num_words);
 800628a:	4621      	mov	r1, r4
 800628c:	a818      	add	r0, sp, #96	; 0x60
    }

    uECC_vli_set(a, input, num_words);
    uECC_vli_set(b, mod, num_words);
    uECC_vli_clear(u, num_words);
    u[0] = 1;
 800628e:	9310      	str	r3, [sp, #64]	; 0x40
    uECC_vli_clear(v, num_words);
 8006290:	f7ff f96c 	bl	800556c <uECC_vli_clear>
    while ((cmpResult = uECC_vli_cmp_unsafe(a, b, num_words)) != 0) {
 8006294:	4622      	mov	r2, r4
 8006296:	a908      	add	r1, sp, #32
 8006298:	4668      	mov	r0, sp
 800629a:	f7ff f9bb 	bl	8005614 <uECC_vli_cmp_unsafe>
 800629e:	2800      	cmp	r0, #0
 80062a0:	d04f      	beq.n	8006342 <uECC_vli_modInv+0xf6>
        if (EVEN(a)) {
 80062a2:	9b00      	ldr	r3, [sp, #0]
 80062a4:	07da      	lsls	r2, r3, #31
 80062a6:	d404      	bmi.n	80062b2 <uECC_vli_modInv+0x66>
            uECC_vli_rshift1(a, num_words);
 80062a8:	4621      	mov	r1, r4
 80062aa:	4668      	mov	r0, sp
 80062ac:	f7ff f9c7 	bl	800563e <uECC_vli_rshift1>
 80062b0:	e023      	b.n	80062fa <uECC_vli_modInv+0xae>
            vli_modInv_update(u, mod, num_words);
        } else if (EVEN(b)) {
 80062b2:	9b08      	ldr	r3, [sp, #32]
 80062b4:	07db      	lsls	r3, r3, #31
 80062b6:	d404      	bmi.n	80062c2 <uECC_vli_modInv+0x76>
            uECC_vli_rshift1(b, num_words);
 80062b8:	4621      	mov	r1, r4
 80062ba:	a808      	add	r0, sp, #32
 80062bc:	f7ff f9bf 	bl	800563e <uECC_vli_rshift1>
 80062c0:	e039      	b.n	8006336 <uECC_vli_modInv+0xea>
            vli_modInv_update(v, mod, num_words);
        } else if (cmpResult > 0) {
 80062c2:	2800      	cmp	r0, #0
 80062c4:	dd1d      	ble.n	8006302 <uECC_vli_modInv+0xb6>
            uECC_vli_sub(a, a, b, num_words);
 80062c6:	aa08      	add	r2, sp, #32
 80062c8:	4669      	mov	r1, sp
 80062ca:	4668      	mov	r0, sp
 80062cc:	f7ff fbe9 	bl	8005aa2 <uECC_vli_sub.isra.1>
            uECC_vli_rshift1(a, num_words);
 80062d0:	4621      	mov	r1, r4
 80062d2:	4668      	mov	r0, sp
 80062d4:	f7ff f9b3 	bl	800563e <uECC_vli_rshift1>
            if (uECC_vli_cmp_unsafe(u, v, num_words) < 0) {
 80062d8:	4622      	mov	r2, r4
 80062da:	a918      	add	r1, sp, #96	; 0x60
 80062dc:	a810      	add	r0, sp, #64	; 0x40
 80062de:	f7ff f999 	bl	8005614 <uECC_vli_cmp_unsafe>
 80062e2:	2800      	cmp	r0, #0
 80062e4:	da04      	bge.n	80062f0 <uECC_vli_modInv+0xa4>
                uECC_vli_add(u, u, mod, num_words);
 80062e6:	a910      	add	r1, sp, #64	; 0x40
 80062e8:	462a      	mov	r2, r5
 80062ea:	4608      	mov	r0, r1
 80062ec:	f7ff fb30 	bl	8005950 <uECC_vli_add.isra.0>
            }
            uECC_vli_sub(u, u, v, num_words);
 80062f0:	a910      	add	r1, sp, #64	; 0x40
 80062f2:	aa18      	add	r2, sp, #96	; 0x60
 80062f4:	4608      	mov	r0, r1
 80062f6:	f7ff fbd4 	bl	8005aa2 <uECC_vli_sub.isra.1>
            vli_modInv_update(u, mod, num_words);
 80062fa:	4622      	mov	r2, r4
 80062fc:	4629      	mov	r1, r5
 80062fe:	a810      	add	r0, sp, #64	; 0x40
 8006300:	e01c      	b.n	800633c <uECC_vli_modInv+0xf0>
        } else {
            uECC_vli_sub(b, b, a, num_words);
 8006302:	a908      	add	r1, sp, #32
 8006304:	466a      	mov	r2, sp
 8006306:	4608      	mov	r0, r1
 8006308:	f7ff fbcb 	bl	8005aa2 <uECC_vli_sub.isra.1>
            uECC_vli_rshift1(b, num_words);
 800630c:	4621      	mov	r1, r4
 800630e:	a808      	add	r0, sp, #32
 8006310:	f7ff f995 	bl	800563e <uECC_vli_rshift1>
            if (uECC_vli_cmp_unsafe(v, u, num_words) < 0) {
 8006314:	4622      	mov	r2, r4
 8006316:	a910      	add	r1, sp, #64	; 0x40
 8006318:	a818      	add	r0, sp, #96	; 0x60
 800631a:	f7ff f97b 	bl	8005614 <uECC_vli_cmp_unsafe>
 800631e:	2800      	cmp	r0, #0
 8006320:	da04      	bge.n	800632c <uECC_vli_modInv+0xe0>
                uECC_vli_add(v, v, mod, num_words);
 8006322:	a918      	add	r1, sp, #96	; 0x60
 8006324:	462a      	mov	r2, r5
 8006326:	4608      	mov	r0, r1
 8006328:	f7ff fb12 	bl	8005950 <uECC_vli_add.isra.0>
            }
            uECC_vli_sub(v, v, u, num_words);
 800632c:	a918      	add	r1, sp, #96	; 0x60
 800632e:	aa10      	add	r2, sp, #64	; 0x40
 8006330:	4608      	mov	r0, r1
 8006332:	f7ff fbb6 	bl	8005aa2 <uECC_vli_sub.isra.1>
            vli_modInv_update(v, mod, num_words);
 8006336:	4622      	mov	r2, r4
 8006338:	4629      	mov	r1, r5
 800633a:	a818      	add	r0, sp, #96	; 0x60
 800633c:	f7ff ff6b 	bl	8006216 <vli_modInv_update>
 8006340:	e7a8      	b.n	8006294 <uECC_vli_modInv+0x48>
        }
    }
    uECC_vli_set(result, u, num_words);
 8006342:	4622      	mov	r2, r4
 8006344:	a910      	add	r1, sp, #64	; 0x40
 8006346:	4630      	mov	r0, r6
 8006348:	f7ff f957 	bl	80055fa <uECC_vli_set>
}
 800634c:	b021      	add	sp, #132	; 0x84
 800634e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08006350 <EccPoint_mult>:
static void EccPoint_mult(uECC_word_t * result,
                          const uECC_word_t * point,
                          const uECC_word_t * scalar,
                          const uECC_word_t * initial_Z,
                          bitcount_t num_bits,
                          uECC_Curve curve) {
 8006350:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006354:	b0b1      	sub	sp, #196	; 0xc4
 8006356:	461e      	mov	r6, r3
 8006358:	9c3b      	ldr	r4, [sp, #236]	; 0xec
 800635a:	9004      	str	r0, [sp, #16]
    uECC_word_t z[uECC_MAX_WORDS];
    bitcount_t i;
    uECC_word_t nb;
    wordcount_t num_words = curve->num_words;
    
    uECC_vli_set(Rx[1], point, num_words);
 800635c:	f994 8000 	ldrsb.w	r8, [r4]
static void EccPoint_mult(uECC_word_t * result,
                          const uECC_word_t * point,
                          const uECC_word_t * scalar,
                          const uECC_word_t * initial_Z,
                          bitcount_t num_bits,
                          uECC_Curve curve) {
 8006360:	9206      	str	r2, [sp, #24]
    uECC_word_t z[uECC_MAX_WORDS];
    bitcount_t i;
    uECC_word_t nb;
    wordcount_t num_words = curve->num_words;
    
    uECC_vli_set(Rx[1], point, num_words);
 8006362:	a818      	add	r0, sp, #96	; 0x60
 8006364:	4642      	mov	r2, r8
static void EccPoint_mult(uECC_word_t * result,
                          const uECC_word_t * point,
                          const uECC_word_t * scalar,
                          const uECC_word_t * initial_Z,
                          bitcount_t num_bits,
                          uECC_Curve curve) {
 8006366:	9105      	str	r1, [sp, #20]
    uECC_word_t z[uECC_MAX_WORDS];
    bitcount_t i;
    uECC_word_t nb;
    wordcount_t num_words = curve->num_words;
    
    uECC_vli_set(Rx[1], point, num_words);
 8006368:	f7ff f947 	bl	80055fa <uECC_vli_set>
    uECC_vli_set(Ry[1], point + num_words, num_words);
 800636c:	ea4f 0388 	mov.w	r3, r8, lsl #2
 8006370:	9302      	str	r3, [sp, #8]
 8006372:	9a02      	ldr	r2, [sp, #8]
 8006374:	9b05      	ldr	r3, [sp, #20]
 8006376:	4413      	add	r3, r2
 8006378:	4619      	mov	r1, r3
 800637a:	4642      	mov	r2, r8
 800637c:	a828      	add	r0, sp, #160	; 0xa0
 800637e:	9303      	str	r3, [sp, #12]
 8006380:	f7ff f93b 	bl	80055fa <uECC_vli_set>
 8006384:	f994 5000 	ldrsb.w	r5, [r4]
                                uECC_word_t * Y2,
                                const uECC_word_t * const initial_Z,
                                uECC_Curve curve) {
    uECC_word_t z[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;
    if (initial_Z) {
 8006388:	b12e      	cbz	r6, 8006396 <EccPoint_mult+0x46>
        uECC_vli_set(z, initial_Z, num_words);
 800638a:	462a      	mov	r2, r5
 800638c:	4631      	mov	r1, r6
 800638e:	a808      	add	r0, sp, #32
 8006390:	f7ff f933 	bl	80055fa <uECC_vli_set>
 8006394:	e005      	b.n	80063a2 <EccPoint_mult+0x52>
    } else {
        uECC_vli_clear(z, num_words);
 8006396:	4629      	mov	r1, r5
 8006398:	a808      	add	r0, sp, #32
 800639a:	f7ff f8e7 	bl	800556c <uECC_vli_clear>
        z[0] = 1;
 800639e:	2301      	movs	r3, #1
 80063a0:	9308      	str	r3, [sp, #32]
    }

    uECC_vli_set(X2, X1, num_words);
 80063a2:	af10      	add	r7, sp, #64	; 0x40
 80063a4:	462a      	mov	r2, r5
 80063a6:	a918      	add	r1, sp, #96	; 0x60
 80063a8:	4638      	mov	r0, r7
    uECC_vli_set(Y2, Y1, num_words);
 80063aa:	f10d 0980 	add.w	r9, sp, #128	; 0x80
    } else {
        uECC_vli_clear(z, num_words);
        z[0] = 1;
    }

    uECC_vli_set(X2, X1, num_words);
 80063ae:	f7ff f924 	bl	80055fa <uECC_vli_set>
    uECC_vli_set(Y2, Y1, num_words);
 80063b2:	462a      	mov	r2, r5
 80063b4:	a928      	add	r1, sp, #160	; 0xa0
 80063b6:	4648      	mov	r0, r9
 80063b8:	f7ff f91f 	bl	80055fa <uECC_vli_set>

    apply_z(X1, Y1, z, curve);
 80063bc:	4623      	mov	r3, r4
 80063be:	aa08      	add	r2, sp, #32
 80063c0:	a928      	add	r1, sp, #160	; 0xa0
 80063c2:	a818      	add	r0, sp, #96	; 0x60
 80063c4:	f7ff fa08 	bl	80057d8 <apply_z>
    curve->double_jacobian(X1, Y1, z, curve);
 80063c8:	4623      	mov	r3, r4
 80063ca:	aa08      	add	r2, sp, #32
 80063cc:	a928      	add	r1, sp, #160	; 0xa0
 80063ce:	a818      	add	r0, sp, #96	; 0x60
 80063d0:	f8d4 50a4 	ldr.w	r5, [r4, #164]	; 0xa4
 80063d4:	47a8      	blx	r5
    apply_z(X2, Y2, z, curve);
 80063d6:	4623      	mov	r3, r4
 80063d8:	aa08      	add	r2, sp, #32
 80063da:	4649      	mov	r1, r9
 80063dc:	4638      	mov	r0, r7
 80063de:	f7ff f9fb 	bl	80057d8 <apply_z>
    uECC_vli_set(Rx[1], point, num_words);
    uECC_vli_set(Ry[1], point + num_words, num_words);

    XYcZ_initial_double(Rx[1], Ry[1], Rx[0], Ry[0], initial_Z, curve);

    for (i = num_bits - 2; i > 0; --i) {
 80063e2:	f9bd 60e8 	ldrsh.w	r6, [sp, #232]	; 0xe8
        nb = !uECC_vli_testBit(scalar, i);
        XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
 80063e6:	9707      	str	r7, [sp, #28]
    uECC_vli_set(Rx[1], point, num_words);
    uECC_vli_set(Ry[1], point + num_words, num_words);

    XYcZ_initial_double(Rx[1], Ry[1], Rx[0], Ry[0], initial_Z, curve);

    for (i = num_bits - 2; i > 0; --i) {
 80063e8:	3e02      	subs	r6, #2
 80063ea:	b2b6      	uxth	r6, r6
 80063ec:	b231      	sxth	r1, r6
 80063ee:	2900      	cmp	r1, #0
 80063f0:	dd22      	ble.n	8006438 <EccPoint_mult+0xe8>
        nb = !uECC_vli_testBit(scalar, i);
 80063f2:	9806      	ldr	r0, [sp, #24]
 80063f4:	f7ff f8d5 	bl	80055a2 <uECC_vli_testBit>
 80063f8:	fab0 f080 	clz	r0, r0
 80063fc:	0940      	lsrs	r0, r0, #5
        XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
 80063fe:	9b07      	ldr	r3, [sp, #28]
 8006400:	9400      	str	r4, [sp, #0]
 8006402:	f1c0 0701 	rsb	r7, r0, #1
 8006406:	017f      	lsls	r7, r7, #5
 8006408:	0140      	lsls	r0, r0, #5
 800640a:	eb03 0b07 	add.w	fp, r3, r7
 800640e:	eb03 0a00 	add.w	sl, r3, r0
 8006412:	eb09 0500 	add.w	r5, r9, r0
 8006416:	444f      	add	r7, r9
 8006418:	462b      	mov	r3, r5
 800641a:	4652      	mov	r2, sl
 800641c:	4639      	mov	r1, r7
 800641e:	4658      	mov	r0, fp
 8006420:	f7ff fe72 	bl	8006108 <XYcZ_addC>
 8006424:	3e01      	subs	r6, #1
        XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
 8006426:	9400      	str	r4, [sp, #0]
 8006428:	463b      	mov	r3, r7
 800642a:	465a      	mov	r2, fp
 800642c:	4629      	mov	r1, r5
 800642e:	4650      	mov	r0, sl
 8006430:	f7ff fe0b 	bl	800604a <XYcZ_add>
 8006434:	b2b6      	uxth	r6, r6
 8006436:	e7d9      	b.n	80063ec <EccPoint_mult+0x9c>
 8006438:	9b06      	ldr	r3, [sp, #24]
 800643a:	681d      	ldr	r5, [r3, #0]
    }

    nb = !uECC_vli_testBit(scalar, 0);
    XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
 800643c:	9400      	str	r4, [sp, #0]
 800643e:	f005 0501 	and.w	r5, r5, #1
 8006442:	f085 0501 	eor.w	r5, r5, #1
 8006446:	f1c5 0601 	rsb	r6, r5, #1
 800644a:	ab10      	add	r3, sp, #64	; 0x40
 800644c:	0176      	lsls	r6, r6, #5
 800644e:	199f      	adds	r7, r3, r6
 8006450:	ab20      	add	r3, sp, #128	; 0x80
 8006452:	441e      	add	r6, r3
 8006454:	016d      	lsls	r5, r5, #5
 8006456:	ab10      	add	r3, sp, #64	; 0x40
 8006458:	eb03 0905 	add.w	r9, r3, r5
 800645c:	ab20      	add	r3, sp, #128	; 0x80
 800645e:	441d      	add	r5, r3
    
    /* Find final 1/Z value. */
    uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */
 8006460:	f104 0a04 	add.w	sl, r4, #4
        XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
        XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
    }

    nb = !uECC_vli_testBit(scalar, 0);
    XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
 8006464:	462b      	mov	r3, r5
 8006466:	464a      	mov	r2, r9
 8006468:	4631      	mov	r1, r6
 800646a:	4638      	mov	r0, r7
 800646c:	f7ff fe4c 	bl	8006108 <XYcZ_addC>
    
    /* Find final 1/Z value. */
    uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */
 8006470:	4653      	mov	r3, sl
 8006472:	aa10      	add	r2, sp, #64	; 0x40
 8006474:	a918      	add	r1, sp, #96	; 0x60
 8006476:	a808      	add	r0, sp, #32
 8006478:	f7ff fd08 	bl	8005e8c <uECC_vli_modSub.isra.2>
    uECC_vli_modMult_fast(z, z, Ry[1 - nb], curve);               /* Yb * (X1 - X0) */
 800647c:	a908      	add	r1, sp, #32
 800647e:	4623      	mov	r3, r4
 8006480:	4632      	mov	r2, r6
 8006482:	4608      	mov	r0, r1
 8006484:	f7ff f994 	bl	80057b0 <uECC_vli_modMult_fast>
    uECC_vli_modMult_fast(z, z, point, curve);                    /* xP * Yb * (X1 - X0) */
 8006488:	a908      	add	r1, sp, #32
 800648a:	4623      	mov	r3, r4
 800648c:	9a05      	ldr	r2, [sp, #20]
 800648e:	4608      	mov	r0, r1
 8006490:	f7ff f98e 	bl	80057b0 <uECC_vli_modMult_fast>
    uECC_vli_modInv(z, z, curve->p, num_words);            /* 1 / (xP * Yb * (X1 - X0)) */
 8006494:	a908      	add	r1, sp, #32
 8006496:	4643      	mov	r3, r8
 8006498:	4652      	mov	r2, sl
 800649a:	4608      	mov	r0, r1
 800649c:	f7ff fed6 	bl	800624c <uECC_vli_modInv>
    /* yP / (xP * Yb * (X1 - X0)) */
    uECC_vli_modMult_fast(z, z, point + num_words, curve); 
 80064a0:	a908      	add	r1, sp, #32
 80064a2:	4623      	mov	r3, r4
 80064a4:	9a03      	ldr	r2, [sp, #12]
 80064a6:	4608      	mov	r0, r1
 80064a8:	f7ff f982 	bl	80057b0 <uECC_vli_modMult_fast>
    uECC_vli_modMult_fast(z, z, Rx[1 - nb], curve); /* Xb * yP / (xP * Yb * (X1 - X0)) */
 80064ac:	a908      	add	r1, sp, #32
 80064ae:	4623      	mov	r3, r4
 80064b0:	463a      	mov	r2, r7
 80064b2:	4608      	mov	r0, r1
 80064b4:	f7ff f97c 	bl	80057b0 <uECC_vli_modMult_fast>
    /* End 1/Z calculation */

    XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
 80064b8:	9400      	str	r4, [sp, #0]
 80064ba:	4633      	mov	r3, r6
 80064bc:	463a      	mov	r2, r7
 80064be:	4629      	mov	r1, r5
 80064c0:	4648      	mov	r0, r9
 80064c2:	f7ff fdc2 	bl	800604a <XYcZ_add>
    apply_z(Rx[0], Ry[0], z, curve);
 80064c6:	4623      	mov	r3, r4
 80064c8:	aa08      	add	r2, sp, #32
 80064ca:	a920      	add	r1, sp, #128	; 0x80
 80064cc:	a810      	add	r0, sp, #64	; 0x40
 80064ce:	f7ff f983 	bl	80057d8 <apply_z>
    
    uECC_vli_set(result, Rx[0], num_words);
 80064d2:	4642      	mov	r2, r8
 80064d4:	a910      	add	r1, sp, #64	; 0x40
 80064d6:	9804      	ldr	r0, [sp, #16]
 80064d8:	f7ff f88f 	bl	80055fa <uECC_vli_set>
    uECC_vli_set(result + num_words, Ry[0], num_words);
 80064dc:	9b04      	ldr	r3, [sp, #16]
 80064de:	9c02      	ldr	r4, [sp, #8]
 80064e0:	4423      	add	r3, r4
 80064e2:	4642      	mov	r2, r8
 80064e4:	a920      	add	r1, sp, #128	; 0x80
 80064e6:	4618      	mov	r0, r3
 80064e8:	f7ff f887 	bl	80055fa <uECC_vli_set>
}
 80064ec:	b031      	add	sp, #196	; 0xc4
 80064ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080064f2 <EccPoint_compute_public_key>:
    return carry;
}

static uECC_word_t EccPoint_compute_public_key(uECC_word_t *result,
                                               uECC_word_t *private,
                                               uECC_Curve curve) {
 80064f2:	b530      	push	{r4, r5, lr}
 80064f4:	4614      	mov	r4, r2
 80064f6:	b095      	sub	sp, #84	; 0x54
 80064f8:	4605      	mov	r5, r0
    uECC_word_t tmp1[uECC_MAX_WORDS];
    uECC_word_t tmp2[uECC_MAX_WORDS];
    uECC_word_t *p2[2] = {tmp1, tmp2};
 80064fa:	aa0c      	add	r2, sp, #48	; 0x30
    uECC_word_t carry;

    /* Regularize the bitcount for the private key so that attackers cannot use a side channel
       attack to learn the number of leading zeros. */
    carry = regularize_k(private, tmp1, tmp2, curve);
 80064fc:	4623      	mov	r3, r4
    return carry;
}

static uECC_word_t EccPoint_compute_public_key(uECC_word_t *result,
                                               uECC_word_t *private,
                                               uECC_Curve curve) {
 80064fe:	4608      	mov	r0, r1
    uECC_word_t tmp1[uECC_MAX_WORDS];
    uECC_word_t tmp2[uECC_MAX_WORDS];
    uECC_word_t *p2[2] = {tmp1, tmp2};
 8006500:	a904      	add	r1, sp, #16
 8006502:	9102      	str	r1, [sp, #8]
 8006504:	9203      	str	r2, [sp, #12]
    uECC_word_t carry;

    /* Regularize the bitcount for the private key so that attackers cannot use a side channel
       attack to learn the number of leading zeros. */
    carry = regularize_k(private, tmp1, tmp2, curve);
 8006506:	f7ff faa5 	bl	8005a54 <regularize_k>

    EccPoint_mult(result, curve->G, p2[!carry], 0, curve->num_n_bits + 1, curve);
 800650a:	fab0 f080 	clz	r0, r0
 800650e:	ab14      	add	r3, sp, #80	; 0x50
 8006510:	0940      	lsrs	r0, r0, #5
 8006512:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8006516:	8863      	ldrh	r3, [r4, #2]
 8006518:	9401      	str	r4, [sp, #4]
 800651a:	3301      	adds	r3, #1
 800651c:	b21b      	sxth	r3, r3
 800651e:	9300      	str	r3, [sp, #0]
 8006520:	f850 2c48 	ldr.w	r2, [r0, #-72]
 8006524:	2300      	movs	r3, #0
 8006526:	f104 0144 	add.w	r1, r4, #68	; 0x44
 800652a:	4628      	mov	r0, r5
 800652c:	f7ff ff10 	bl	8006350 <EccPoint_mult>

    if (EccPoint_isZero(result, curve)) {
 8006530:	7821      	ldrb	r1, [r4, #0]
 8006532:	0049      	lsls	r1, r1, #1
 8006534:	b249      	sxtb	r1, r1
 8006536:	4628      	mov	r0, r5
 8006538:	f7ff f824 	bl	8005584 <uECC_vli_isZero>
        return 0;
    }
    return 1;
}
 800653c:	fab0 f080 	clz	r0, r0
 8006540:	0940      	lsrs	r0, r0, #5
 8006542:	b015      	add	sp, #84	; 0x54
 8006544:	bd30      	pop	{r4, r5, pc}
	...

08006548 <uECC_sign_with_k>:
static int uECC_sign_with_k(const uint8_t *private_key,
                            const uint8_t *message_hash,
                            unsigned hash_size,
                            uECC_word_t *k,
                            uint8_t *signature,
                            uECC_Curve curve) {
 8006548:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800654c:	b0ab      	sub	sp, #172	; 0xac
 800654e:	461e      	mov	r6, r3
 8006550:	9d35      	ldr	r5, [sp, #212]	; 0xd4
 8006552:	9005      	str	r0, [sp, #20]
    uECC_word_t tmp[uECC_MAX_WORDS];
    uECC_word_t s[uECC_MAX_WORDS];
    uECC_word_t *k2[2] = {tmp, s};
    uECC_word_t p[uECC_MAX_WORDS * 2];
    uECC_word_t carry;
    wordcount_t num_words = curve->num_words;
 8006554:	f895 9000 	ldrb.w	r9, [r5]
static int uECC_sign_with_k(const uint8_t *private_key,
                            const uint8_t *message_hash,
                            unsigned hash_size,
                            uECC_word_t *k,
                            uint8_t *signature,
                            uECC_Curve curve) {
 8006558:	9106      	str	r1, [sp, #24]
    wordcount_t num_words = curve->num_words;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    bitcount_t num_n_bits = curve->num_n_bits;
    
    /* Make sure 0 < k < curve_n */
    if (uECC_vli_isZero(k, num_words) || uECC_vli_cmp(curve->n, k, num_n_words) != 1) {
 800655a:	fa4f fa89 	sxtb.w	sl, r9
                            uECC_word_t *k,
                            uint8_t *signature,
                            uECC_Curve curve) {
    uECC_word_t tmp[uECC_MAX_WORDS];
    uECC_word_t s[uECC_MAX_WORDS];
    uECC_word_t *k2[2] = {tmp, s};
 800655e:	ab12      	add	r3, sp, #72	; 0x48
 8006560:	f10d 0828 	add.w	r8, sp, #40	; 0x28
    wordcount_t num_words = curve->num_words;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    bitcount_t num_n_bits = curve->num_n_bits;
    
    /* Make sure 0 < k < curve_n */
    if (uECC_vli_isZero(k, num_words) || uECC_vli_cmp(curve->n, k, num_n_words) != 1) {
 8006564:	4651      	mov	r1, sl
 8006566:	4630      	mov	r0, r6
static int uECC_sign_with_k(const uint8_t *private_key,
                            const uint8_t *message_hash,
                            unsigned hash_size,
                            uECC_word_t *k,
                            uint8_t *signature,
                            uECC_Curve curve) {
 8006568:	9207      	str	r2, [sp, #28]
    uECC_word_t tmp[uECC_MAX_WORDS];
    uECC_word_t s[uECC_MAX_WORDS];
    uECC_word_t *k2[2] = {tmp, s};
 800656a:	f8cd 8020 	str.w	r8, [sp, #32]
 800656e:	9309      	str	r3, [sp, #36]	; 0x24
    wordcount_t num_words = curve->num_words;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    bitcount_t num_n_bits = curve->num_n_bits;
    
    /* Make sure 0 < k < curve_n */
    if (uECC_vli_isZero(k, num_words) || uECC_vli_cmp(curve->n, k, num_n_words) != 1) {
 8006570:	f7ff f808 	bl	8005584 <uECC_vli_isZero>
 8006574:	9003      	str	r0, [sp, #12]
 8006576:	b108      	cbz	r0, 800657c <uECC_sign_with_k+0x34>
        return 0;
 8006578:	2000      	movs	r0, #0
 800657a:	e0a9      	b.n	80066d0 <uECC_sign_with_k+0x188>
    uECC_word_t s[uECC_MAX_WORDS];
    uECC_word_t *k2[2] = {tmp, s};
    uECC_word_t p[uECC_MAX_WORDS * 2];
    uECC_word_t carry;
    wordcount_t num_words = curve->num_words;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 800657c:	f8b5 b002 	ldrh.w	fp, [r5, #2]
 8006580:	fa0f f48b 	sxth.w	r4, fp
 8006584:	2320      	movs	r3, #32
 8006586:	341f      	adds	r4, #31
    bitcount_t num_n_bits = curve->num_n_bits;
    
    /* Make sure 0 < k < curve_n */
    if (uECC_vli_isZero(k, num_words) || uECC_vli_cmp(curve->n, k, num_n_words) != 1) {
 8006588:	f105 0724 	add.w	r7, r5, #36	; 0x24
    uECC_word_t s[uECC_MAX_WORDS];
    uECC_word_t *k2[2] = {tmp, s};
    uECC_word_t p[uECC_MAX_WORDS * 2];
    uECC_word_t carry;
    wordcount_t num_words = curve->num_words;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 800658c:	fb94 f4f3 	sdiv	r4, r4, r3
    bitcount_t num_n_bits = curve->num_n_bits;
    
    /* Make sure 0 < k < curve_n */
    if (uECC_vli_isZero(k, num_words) || uECC_vli_cmp(curve->n, k, num_n_words) != 1) {
 8006590:	b264      	sxtb	r4, r4
 8006592:	4622      	mov	r2, r4
 8006594:	4631      	mov	r1, r6
 8006596:	4638      	mov	r0, r7
 8006598:	f7ff faaa 	bl	8005af0 <uECC_vli_cmp>
 800659c:	2801      	cmp	r0, #1
 800659e:	9004      	str	r0, [sp, #16]
 80065a0:	d1ea      	bne.n	8006578 <uECC_sign_with_k+0x30>
        return 0;
    }
    
    carry = regularize_k(k, tmp, s, curve);
 80065a2:	462b      	mov	r3, r5
 80065a4:	aa12      	add	r2, sp, #72	; 0x48
 80065a6:	4641      	mov	r1, r8
 80065a8:	4630      	mov	r0, r6
 80065aa:	f7ff fa53 	bl	8005a54 <regularize_k>
    EccPoint_mult(p, curve->G, k2[!carry], 0, num_n_bits + 1, curve);
 80065ae:	fab0 f080 	clz	r0, r0
 80065b2:	ab2a      	add	r3, sp, #168	; 0xa8
 80065b4:	0940      	lsrs	r0, r0, #5
 80065b6:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 80065ba:	f10b 0301 	add.w	r3, fp, #1
 80065be:	b21b      	sxth	r3, r3
 80065c0:	9300      	str	r3, [sp, #0]
 80065c2:	9501      	str	r5, [sp, #4]
 80065c4:	f850 2c88 	ldr.w	r2, [r0, #-136]
 80065c8:	9b03      	ldr	r3, [sp, #12]
 80065ca:	f105 0144 	add.w	r1, r5, #68	; 0x44
 80065ce:	a81a      	add	r0, sp, #104	; 0x68
 80065d0:	f7ff febe 	bl	8006350 <EccPoint_mult>
    if (uECC_vli_isZero(p, num_words)) {
 80065d4:	4651      	mov	r1, sl
 80065d6:	a81a      	add	r0, sp, #104	; 0x68
 80065d8:	f7fe ffd4 	bl	8005584 <uECC_vli_isZero>
 80065dc:	2800      	cmp	r0, #0
 80065de:	d1cb      	bne.n	8006578 <uECC_sign_with_k+0x30>
        return 0;
    }

	// github.com/kmackay/micro-ecc/issues/65
	uECC_recid = (p[curve->num_words] & 0x01);
 80065e0:	f995 3000 	ldrsb.w	r3, [r5]
 80065e4:	aa2a      	add	r2, sp, #168	; 0xa8
 80065e6:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80065ea:	4a3b      	ldr	r2, [pc, #236]	; (80066d8 <uECC_sign_with_k+0x190>)
 80065ec:	f853 3c40 	ldr.w	r3, [r3, #-64]
 80065f0:	f003 0301 	and.w	r3, r3, #1
 80065f4:	7013      	strb	r3, [r2, #0]
    
    /* If an RNG function was specified, get a random number
       to prevent side channel analysis of k. */
    if (!g_rng_function) {
 80065f6:	4b39      	ldr	r3, [pc, #228]	; (80066dc <uECC_sign_with_k+0x194>)
 80065f8:	681b      	ldr	r3, [r3, #0]
 80065fa:	b933      	cbnz	r3, 800660a <uECC_sign_with_k+0xc2>
        uECC_vli_clear(tmp, num_n_words);
 80065fc:	4621      	mov	r1, r4
 80065fe:	4640      	mov	r0, r8
 8006600:	f7fe ffb4 	bl	800556c <uECC_vli_clear>
        tmp[0] = 1;
 8006604:	9b04      	ldr	r3, [sp, #16]
 8006606:	930a      	str	r3, [sp, #40]	; 0x28
 8006608:	e006      	b.n	8006618 <uECC_sign_with_k+0xd0>
    } else if (!uECC_generate_random_int(tmp, curve->n, num_n_words)) {
 800660a:	4622      	mov	r2, r4
 800660c:	4639      	mov	r1, r7
 800660e:	4640      	mov	r0, r8
 8006610:	f7ff fa86 	bl	8005b20 <uECC_generate_random_int>
 8006614:	2800      	cmp	r0, #0
 8006616:	d0af      	beq.n	8006578 <uECC_sign_with_k+0x30>
        return 0;
    }

    /* Prevent side channel analysis of uECC_vli_modInv() to determine
       bits of k / the private key by premultiplying by a random number */
    uECC_vli_modMult(k, k, tmp, curve->n, num_n_words); /* k' = rand * k */
 8006618:	463b      	mov	r3, r7
 800661a:	aa0a      	add	r2, sp, #40	; 0x28
 800661c:	4631      	mov	r1, r6
 800661e:	4630      	mov	r0, r6
 8006620:	9400      	str	r4, [sp, #0]
 8006622:	f7ff f819 	bl	8005658 <uECC_vli_modMult>
    uECC_vli_modInv(k, k, curve->n, num_n_words);       /* k = 1 / k' */
 8006626:	4623      	mov	r3, r4
 8006628:	463a      	mov	r2, r7
 800662a:	4631      	mov	r1, r6
 800662c:	4630      	mov	r0, r6
 800662e:	f7ff fe0d 	bl	800624c <uECC_vli_modInv>
    uECC_vli_modMult(k, k, tmp, curve->n, num_n_words); /* k = 1 / k */
 8006632:	463b      	mov	r3, r7
 8006634:	aa0a      	add	r2, sp, #40	; 0x28
 8006636:	4631      	mov	r1, r6
 8006638:	4630      	mov	r0, r6
 800663a:	9400      	str	r4, [sp, #0]
 800663c:	f7ff f80c 	bl	8005658 <uECC_vli_modMult>
    
    uECC_vli_nativeToBytes(signature, curve->num_bytes, p); /* store r */
 8006640:	aa1a      	add	r2, sp, #104	; 0x68
 8006642:	f995 1001 	ldrsb.w	r1, [r5, #1]
 8006646:	9834      	ldr	r0, [sp, #208]	; 0xd0
 8006648:	f7ff f8e5 	bl	8005816 <uECC_vli_nativeToBytes>
    
    uECC_vli_bytesToNative(tmp, private_key, BITS_TO_BYTES(curve->num_n_bits)); /* tmp = d */
 800664c:	f9b5 3002 	ldrsh.w	r3, [r5, #2]
 8006650:	9905      	ldr	r1, [sp, #20]
 8006652:	3307      	adds	r3, #7
 8006654:	a80a      	add	r0, sp, #40	; 0x28
 8006656:	2208      	movs	r2, #8
 8006658:	fb93 f2f2 	sdiv	r2, r3, r2
 800665c:	f7ff f8ef 	bl	800583e <uECC_vli_bytesToNative>

    s[num_n_words - 1] = 0;
 8006660:	aa2a      	add	r2, sp, #168	; 0xa8
 8006662:	1e63      	subs	r3, r4, #1
 8006664:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8006668:	2200      	movs	r2, #0
 800666a:	f843 2c60 	str.w	r2, [r3, #-96]
    uECC_vli_set(s, p, num_words);
 800666e:	a91a      	add	r1, sp, #104	; 0x68
 8006670:	fa4f f289 	sxtb.w	r2, r9
 8006674:	a812      	add	r0, sp, #72	; 0x48
 8006676:	f7fe ffc0 	bl	80055fa <uECC_vli_set>
    uECC_vli_modMult(s, tmp, s, curve->n, num_n_words); /* s = r*d */
 800667a:	aa12      	add	r2, sp, #72	; 0x48
 800667c:	4610      	mov	r0, r2
 800667e:	463b      	mov	r3, r7
 8006680:	a90a      	add	r1, sp, #40	; 0x28
 8006682:	9400      	str	r4, [sp, #0]
 8006684:	f7fe ffe8 	bl	8005658 <uECC_vli_modMult>

    bits2int(tmp, message_hash, hash_size, curve);
 8006688:	462b      	mov	r3, r5
 800668a:	9a07      	ldr	r2, [sp, #28]
 800668c:	9906      	ldr	r1, [sp, #24]
 800668e:	a80a      	add	r0, sp, #40	; 0x28
 8006690:	f7ff fbba 	bl	8005e08 <bits2int>
    uECC_vli_modAdd(s, tmp, s, curve->n, num_n_words); /* s = e + r*d */
 8006694:	aa12      	add	r2, sp, #72	; 0x48
 8006696:	4610      	mov	r0, r2
 8006698:	463b      	mov	r3, r7
 800669a:	a90a      	add	r1, sp, #40	; 0x28
 800669c:	9400      	str	r4, [sp, #0]
 800669e:	f7ff fa7b 	bl	8005b98 <uECC_vli_modAdd>
    uECC_vli_modMult(s, s, k, curve->n, num_n_words);  /* s = (e + r*d) / k */
 80066a2:	a912      	add	r1, sp, #72	; 0x48
 80066a4:	4608      	mov	r0, r1
 80066a6:	463b      	mov	r3, r7
 80066a8:	4632      	mov	r2, r6
 80066aa:	9400      	str	r4, [sp, #0]
 80066ac:	f7fe ffd4 	bl	8005658 <uECC_vli_modMult>
    if (uECC_vli_numBits(s, num_n_words) > (bitcount_t)curve->num_bytes * 8) {
 80066b0:	4621      	mov	r1, r4
 80066b2:	a812      	add	r0, sp, #72	; 0x48
 80066b4:	f7fe ff7f 	bl	80055b6 <uECC_vli_numBits>
 80066b8:	f995 1001 	ldrsb.w	r1, [r5, #1]
 80066bc:	ebb0 0fc1 	cmp.w	r0, r1, lsl #3
 80066c0:	f73f af5a 	bgt.w	8006578 <uECC_sign_with_k+0x30>
        return 0;
    }
    uECC_vli_nativeToBytes(signature + curve->num_bytes, curve->num_bytes, s);
 80066c4:	9b34      	ldr	r3, [sp, #208]	; 0xd0
 80066c6:	aa12      	add	r2, sp, #72	; 0x48
 80066c8:	1858      	adds	r0, r3, r1
 80066ca:	f7ff f8a4 	bl	8005816 <uECC_vli_nativeToBytes>
    return 1;
 80066ce:	2001      	movs	r0, #1
}
 80066d0:	b02b      	add	sp, #172	; 0xac
 80066d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80066d6:	bf00      	nop
 80066d8:	20000444 	.word	0x20000444
 80066dc:	20000234 	.word	0x20000234

080066e0 <double_jacobian_secp256k1>:

/* Double in place */
static void double_jacobian_secp256k1(uECC_word_t * X1,
                                      uECC_word_t * Y1,
                                      uECC_word_t * Z1,
                                      uECC_Curve curve) {
 80066e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80066e4:	4605      	mov	r5, r0
 80066e6:	b093      	sub	sp, #76	; 0x4c
 80066e8:	460c      	mov	r4, r1
    /* t1 = X, t2 = Y, t3 = Z */
    uECC_word_t t4[num_words_secp256k1];
    uECC_word_t t5[num_words_secp256k1];
    
    if (uECC_vli_isZero(Z1, num_words_secp256k1)) {
 80066ea:	4610      	mov	r0, r2
 80066ec:	2108      	movs	r1, #8

/* Double in place */
static void double_jacobian_secp256k1(uECC_word_t * X1,
                                      uECC_word_t * Y1,
                                      uECC_word_t * Z1,
                                      uECC_Curve curve) {
 80066ee:	4617      	mov	r7, r2
 80066f0:	461e      	mov	r6, r3
    /* t1 = X, t2 = Y, t3 = Z */
    uECC_word_t t4[num_words_secp256k1];
    uECC_word_t t5[num_words_secp256k1];
    
    if (uECC_vli_isZero(Z1, num_words_secp256k1)) {
 80066f2:	f7fe ff47 	bl	8005584 <uECC_vli_isZero>
 80066f6:	2800      	cmp	r0, #0
 80066f8:	d166      	bne.n	80067c8 <double_jacobian_secp256k1+0xe8>
        return;
    }
    
    uECC_vli_modSquare_fast(t5, Y1, curve);   /* t5 = y1^2 */
 80066fa:	4632      	mov	r2, r6
 80066fc:	4621      	mov	r1, r4
 80066fe:	a80a      	add	r0, sp, #40	; 0x28
 8006700:	f7ff f866 	bl	80057d0 <uECC_vli_modSquare_fast>
    uECC_vli_modMult_fast(t4, X1, t5, curve); /* t4 = x1*y1^2 = A */
 8006704:	4633      	mov	r3, r6
 8006706:	aa0a      	add	r2, sp, #40	; 0x28
 8006708:	4629      	mov	r1, r5
 800670a:	a802      	add	r0, sp, #8
 800670c:	f7ff f850 	bl	80057b0 <uECC_vli_modMult_fast>
    uECC_vli_modSquare_fast(X1, X1, curve);   /* t1 = x1^2 */
 8006710:	4632      	mov	r2, r6
 8006712:	4629      	mov	r1, r5
 8006714:	4628      	mov	r0, r5
 8006716:	f7ff f85b 	bl	80057d0 <uECC_vli_modSquare_fast>
    uECC_vli_modSquare_fast(t5, t5, curve);   /* t5 = y1^4 */
 800671a:	a90a      	add	r1, sp, #40	; 0x28
 800671c:	4608      	mov	r0, r1
 800671e:	4632      	mov	r2, r6
 8006720:	f7ff f856 	bl	80057d0 <uECC_vli_modSquare_fast>
    uECC_vli_modMult_fast(Z1, Y1, Z1, curve); /* t3 = y1*z1 = z3 */
    
    uECC_vli_modAdd(Y1, X1, X1, curve->p, num_words_secp256k1); /* t2 = 2*x1^2 */
 8006724:	f04f 0808 	mov.w	r8, #8
    
    uECC_vli_modSquare_fast(t5, Y1, curve);   /* t5 = y1^2 */
    uECC_vli_modMult_fast(t4, X1, t5, curve); /* t4 = x1*y1^2 = A */
    uECC_vli_modSquare_fast(X1, X1, curve);   /* t1 = x1^2 */
    uECC_vli_modSquare_fast(t5, t5, curve);   /* t5 = y1^4 */
    uECC_vli_modMult_fast(Z1, Y1, Z1, curve); /* t3 = y1*z1 = z3 */
 8006728:	463a      	mov	r2, r7
 800672a:	4638      	mov	r0, r7
 800672c:	4633      	mov	r3, r6
 800672e:	4621      	mov	r1, r4
    
    uECC_vli_modAdd(Y1, X1, X1, curve->p, num_words_secp256k1); /* t2 = 2*x1^2 */
 8006730:	1d37      	adds	r7, r6, #4
    
    uECC_vli_modSquare_fast(t5, Y1, curve);   /* t5 = y1^2 */
    uECC_vli_modMult_fast(t4, X1, t5, curve); /* t4 = x1*y1^2 = A */
    uECC_vli_modSquare_fast(X1, X1, curve);   /* t1 = x1^2 */
    uECC_vli_modSquare_fast(t5, t5, curve);   /* t5 = y1^4 */
    uECC_vli_modMult_fast(Z1, Y1, Z1, curve); /* t3 = y1*z1 = z3 */
 8006732:	f7ff f83d 	bl	80057b0 <uECC_vli_modMult_fast>
    
    uECC_vli_modAdd(Y1, X1, X1, curve->p, num_words_secp256k1); /* t2 = 2*x1^2 */
 8006736:	463b      	mov	r3, r7
 8006738:	462a      	mov	r2, r5
 800673a:	4629      	mov	r1, r5
 800673c:	4620      	mov	r0, r4
 800673e:	f8cd 8000 	str.w	r8, [sp]
 8006742:	f7ff fa29 	bl	8005b98 <uECC_vli_modAdd>
    uECC_vli_modAdd(Y1, Y1, X1, curve->p, num_words_secp256k1); /* t2 = 3*x1^2 */
 8006746:	463b      	mov	r3, r7
 8006748:	f8cd 8000 	str.w	r8, [sp]
 800674c:	462a      	mov	r2, r5
 800674e:	4621      	mov	r1, r4
 8006750:	4620      	mov	r0, r4
 8006752:	f7ff fa21 	bl	8005b98 <uECC_vli_modAdd>
    if (uECC_vli_testBit(Y1, 0)) {
 8006756:	6823      	ldr	r3, [r4, #0]
 8006758:	07db      	lsls	r3, r3, #31
 800675a:	d50e      	bpl.n	800677a <double_jacobian_secp256k1+0x9a>
        uECC_word_t carry = uECC_vli_add(Y1, Y1, curve->p, num_words_secp256k1);
 800675c:	463a      	mov	r2, r7
 800675e:	4621      	mov	r1, r4
 8006760:	4620      	mov	r0, r4
 8006762:	f7ff f8f5 	bl	8005950 <uECC_vli_add.isra.0>
        uECC_vli_rshift1(Y1, num_words_secp256k1);
 8006766:	4641      	mov	r1, r8
    uECC_vli_modMult_fast(Z1, Y1, Z1, curve); /* t3 = y1*z1 = z3 */
    
    uECC_vli_modAdd(Y1, X1, X1, curve->p, num_words_secp256k1); /* t2 = 2*x1^2 */
    uECC_vli_modAdd(Y1, Y1, X1, curve->p, num_words_secp256k1); /* t2 = 3*x1^2 */
    if (uECC_vli_testBit(Y1, 0)) {
        uECC_word_t carry = uECC_vli_add(Y1, Y1, curve->p, num_words_secp256k1);
 8006768:	4681      	mov	r9, r0
        uECC_vli_rshift1(Y1, num_words_secp256k1);
 800676a:	4620      	mov	r0, r4
 800676c:	f7fe ff67 	bl	800563e <uECC_vli_rshift1>
        Y1[num_words_secp256k1 - 1] |= carry << (uECC_WORD_BITS - 1);
 8006770:	69e0      	ldr	r0, [r4, #28]
 8006772:	ea40 70c9 	orr.w	r0, r0, r9, lsl #31
 8006776:	61e0      	str	r0, [r4, #28]
 8006778:	e003      	b.n	8006782 <double_jacobian_secp256k1+0xa2>
    } else {
        uECC_vli_rshift1(Y1, num_words_secp256k1);
 800677a:	4641      	mov	r1, r8
 800677c:	4620      	mov	r0, r4
 800677e:	f7fe ff5e 	bl	800563e <uECC_vli_rshift1>
    }
    /* t2 = 3/2*(x1^2) = B */
    
    uECC_vli_modSquare_fast(X1, Y1, curve);                     /* t1 = B^2 */
 8006782:	4632      	mov	r2, r6
 8006784:	4621      	mov	r1, r4
 8006786:	4628      	mov	r0, r5
 8006788:	f7ff f822 	bl	80057d0 <uECC_vli_modSquare_fast>
    uECC_vli_modSub(X1, X1, t4, curve->p, num_words_secp256k1); /* t1 = B^2 - A */
 800678c:	463b      	mov	r3, r7
 800678e:	aa02      	add	r2, sp, #8
 8006790:	4629      	mov	r1, r5
 8006792:	4628      	mov	r0, r5
 8006794:	f7ff fb7a 	bl	8005e8c <uECC_vli_modSub.isra.2>
    uECC_vli_modSub(X1, X1, t4, curve->p, num_words_secp256k1); /* t1 = B^2 - 2A = x3 */
 8006798:	463b      	mov	r3, r7
 800679a:	aa02      	add	r2, sp, #8
 800679c:	4629      	mov	r1, r5
 800679e:	4628      	mov	r0, r5
 80067a0:	f7ff fb74 	bl	8005e8c <uECC_vli_modSub.isra.2>
    
    uECC_vli_modSub(t4, t4, X1, curve->p, num_words_secp256k1); /* t4 = A - x3 */
 80067a4:	a902      	add	r1, sp, #8
 80067a6:	4608      	mov	r0, r1
 80067a8:	463b      	mov	r3, r7
 80067aa:	462a      	mov	r2, r5
 80067ac:	f7ff fb6e 	bl	8005e8c <uECC_vli_modSub.isra.2>
    uECC_vli_modMult_fast(Y1, Y1, t4, curve);                   /* t2 = B * (A - x3) */
 80067b0:	4633      	mov	r3, r6
 80067b2:	aa02      	add	r2, sp, #8
 80067b4:	4621      	mov	r1, r4
 80067b6:	4620      	mov	r0, r4
 80067b8:	f7fe fffa 	bl	80057b0 <uECC_vli_modMult_fast>
    uECC_vli_modSub(Y1, Y1, t5, curve->p, num_words_secp256k1); /* t2 = B * (A - x3) - y1^4 = y3 */
 80067bc:	463b      	mov	r3, r7
 80067be:	aa0a      	add	r2, sp, #40	; 0x28
 80067c0:	4621      	mov	r1, r4
 80067c2:	4620      	mov	r0, r4
 80067c4:	f7ff fb62 	bl	8005e8c <uECC_vli_modSub.isra.2>
}
 80067c8:	b013      	add	sp, #76	; 0x4c
 80067ca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	...

080067d0 <uECC_set_rng>:

// PDG: added prototype
int uECC_valid_point(const uECC_word_t *point, uECC_Curve curve);

void uECC_set_rng(uECC_RNG_Function rng_function) {
    g_rng_function = rng_function;
 80067d0:	4b01      	ldr	r3, [pc, #4]	; (80067d8 <uECC_set_rng+0x8>)
 80067d2:	6018      	str	r0, [r3, #0]
 80067d4:	4770      	bx	lr
 80067d6:	bf00      	nop
 80067d8:	20000234 	.word	0x20000234

080067dc <uECC_secp256r1>:
#if (uECC_OPTIMIZATION_LEVEL > 0)
    &vli_mmod_fast_secp256r1
#endif
};

uECC_Curve uECC_secp256r1(void) { return &curve_secp256r1; }
 80067dc:	4800      	ldr	r0, [pc, #0]	; (80067e0 <uECC_secp256r1+0x4>)
 80067de:	4770      	bx	lr
 80067e0:	0800e674 	.word	0x0800e674

080067e4 <uECC_secp256k1>:
#if (uECC_OPTIMIZATION_LEVEL > 0)
    &vli_mmod_fast_secp256k1
#endif
};

uECC_Curve uECC_secp256k1(void) { return &curve_secp256k1; }
 80067e4:	4800      	ldr	r0, [pc, #0]	; (80067e8 <uECC_secp256k1+0x4>)
 80067e6:	4770      	bx	lr
 80067e8:	0800e5c0 	.word	0x0800e5c0

080067ec <uECC_make_key>:
    return 0;
}

int uECC_make_key(uint8_t *public_key,
                  uint8_t *private_key,
                  uECC_Curve curve) {
 80067ec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80067f0:	4606      	mov	r6, r0
 80067f2:	b099      	sub	sp, #100	; 0x64
 80067f4:	460f      	mov	r7, r1
 80067f6:	4614      	mov	r4, r2
 80067f8:	2540      	movs	r5, #64	; 0x40
    uECC_word_t private[uECC_MAX_WORDS];
    uECC_word_t public[uECC_MAX_WORDS * 2];
    uECC_word_t tries;

    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
        if (!uECC_generate_random_int(private, curve->n, BITS_TO_WORDS(curve->num_n_bits))) {
 80067fa:	f04f 0820 	mov.w	r8, #32
 80067fe:	f102 0924 	add.w	r9, r2, #36	; 0x24
 8006802:	f9b4 2002 	ldrsh.w	r2, [r4, #2]
 8006806:	4649      	mov	r1, r9
 8006808:	321f      	adds	r2, #31
 800680a:	4668      	mov	r0, sp
 800680c:	fb92 f2f8 	sdiv	r2, r2, r8
 8006810:	b252      	sxtb	r2, r2
 8006812:	f7ff f985 	bl	8005b20 <uECC_generate_random_int>
 8006816:	b908      	cbnz	r0, 800681c <uECC_make_key+0x30>
            return 0;
 8006818:	2000      	movs	r0, #0
 800681a:	e024      	b.n	8006866 <uECC_make_key+0x7a>
        }

        if (EccPoint_compute_public_key(public, private, curve)) {
 800681c:	4622      	mov	r2, r4
 800681e:	4669      	mov	r1, sp
 8006820:	a808      	add	r0, sp, #32
 8006822:	f7ff fe66 	bl	80064f2 <EccPoint_compute_public_key>
 8006826:	b1d8      	cbz	r0, 8006860 <uECC_make_key+0x74>
            uECC_vli_nativeToBytes(private_key, BITS_TO_BYTES(curve->num_n_bits), private);
 8006828:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
 800682c:	466a      	mov	r2, sp
 800682e:	3307      	adds	r3, #7
 8006830:	4638      	mov	r0, r7
 8006832:	2108      	movs	r1, #8
 8006834:	fb93 f1f1 	sdiv	r1, r3, r1
 8006838:	f7fe ffed 	bl	8005816 <uECC_vli_nativeToBytes>
            uECC_vli_nativeToBytes(public_key, curve->num_bytes, public);
 800683c:	aa08      	add	r2, sp, #32
 800683e:	f994 1001 	ldrsb.w	r1, [r4, #1]
 8006842:	4630      	mov	r0, r6
 8006844:	f7fe ffe7 	bl	8005816 <uECC_vli_nativeToBytes>
            uECC_vli_nativeToBytes(
 8006848:	f994 2000 	ldrsb.w	r2, [r4]
 800684c:	f994 1001 	ldrsb.w	r1, [r4, #1]
 8006850:	ab08      	add	r3, sp, #32
 8006852:	1870      	adds	r0, r6, r1
 8006854:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8006858:	f7fe ffdd 	bl	8005816 <uECC_vli_nativeToBytes>
                public_key + curve->num_bytes, curve->num_bytes, public + curve->num_words);
            return 1;
 800685c:	2001      	movs	r0, #1
 800685e:	e002      	b.n	8006866 <uECC_make_key+0x7a>
                  uECC_Curve curve) {
    uECC_word_t private[uECC_MAX_WORDS];
    uECC_word_t public[uECC_MAX_WORDS * 2];
    uECC_word_t tries;

    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
 8006860:	3d01      	subs	r5, #1
 8006862:	d1ce      	bne.n	8006802 <uECC_make_key+0x16>
 8006864:	e7d8      	b.n	8006818 <uECC_make_key+0x2c>
                public_key + curve->num_bytes, curve->num_bytes, public + curve->num_words);
            return 1;
        }
    }
    return 0;
}
 8006866:	b019      	add	sp, #100	; 0x64
 8006868:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800686c <uECC_shared_secret>:

int uECC_shared_secret(const uint8_t *public_key,
                       const uint8_t *private_key,
                       uint8_t *secret,
                       uECC_Curve curve) {
 800686c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8006870:	461c      	mov	r4, r3
 8006872:	b0a4      	sub	sp, #144	; 0x90
    uECC_word_t private[uECC_MAX_WORDS];
    uECC_word_t tmp[uECC_MAX_WORDS];
    uECC_word_t *p2[2] = {private, tmp};
    uECC_word_t *initial_Z = 0;
    uECC_word_t carry;
    wordcount_t num_words = curve->num_words;
 8006874:	f893 9000 	ldrb.w	r9, [r3]
    wordcount_t num_bytes = curve->num_bytes;
 8006878:	785e      	ldrb	r6, [r3, #1]
    
    uECC_vli_bytesToNative(private, private_key, BITS_TO_BYTES(curve->num_n_bits));
 800687a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
                       uint8_t *secret,
                       uECC_Curve curve) {
    uECC_word_t public[uECC_MAX_WORDS * 2];
    uECC_word_t private[uECC_MAX_WORDS];
    uECC_word_t tmp[uECC_MAX_WORDS];
    uECC_word_t *p2[2] = {private, tmp};
 800687e:	ad04      	add	r5, sp, #16
    uECC_word_t *initial_Z = 0;
    uECC_word_t carry;
    wordcount_t num_words = curve->num_words;
    wordcount_t num_bytes = curve->num_bytes;
    
    uECC_vli_bytesToNative(private, private_key, BITS_TO_BYTES(curve->num_n_bits));
 8006880:	3307      	adds	r3, #7
}

int uECC_shared_secret(const uint8_t *public_key,
                       const uint8_t *private_key,
                       uint8_t *secret,
                       uECC_Curve curve) {
 8006882:	4682      	mov	sl, r0
    uECC_word_t public[uECC_MAX_WORDS * 2];
    uECC_word_t private[uECC_MAX_WORDS];
    uECC_word_t tmp[uECC_MAX_WORDS];
    uECC_word_t *p2[2] = {private, tmp};
 8006884:	af0c      	add	r7, sp, #48	; 0x30
    uECC_word_t *initial_Z = 0;
    uECC_word_t carry;
    wordcount_t num_words = curve->num_words;
    wordcount_t num_bytes = curve->num_bytes;
    
    uECC_vli_bytesToNative(private, private_key, BITS_TO_BYTES(curve->num_n_bits));
 8006886:	4628      	mov	r0, r5
    uECC_vli_bytesToNative(public, public_key, num_bytes);
 8006888:	b276      	sxtb	r6, r6
}

int uECC_shared_secret(const uint8_t *public_key,
                       const uint8_t *private_key,
                       uint8_t *secret,
                       uECC_Curve curve) {
 800688a:	4690      	mov	r8, r2
    uECC_word_t *initial_Z = 0;
    uECC_word_t carry;
    wordcount_t num_words = curve->num_words;
    wordcount_t num_bytes = curve->num_bytes;
    
    uECC_vli_bytesToNative(private, private_key, BITS_TO_BYTES(curve->num_n_bits));
 800688c:	2208      	movs	r2, #8
 800688e:	fb93 f2f2 	sdiv	r2, r3, r2
                       uint8_t *secret,
                       uECC_Curve curve) {
    uECC_word_t public[uECC_MAX_WORDS * 2];
    uECC_word_t private[uECC_MAX_WORDS];
    uECC_word_t tmp[uECC_MAX_WORDS];
    uECC_word_t *p2[2] = {private, tmp};
 8006892:	9502      	str	r5, [sp, #8]
 8006894:	9703      	str	r7, [sp, #12]
    uECC_word_t *initial_Z = 0;
    uECC_word_t carry;
    wordcount_t num_words = curve->num_words;
    wordcount_t num_bytes = curve->num_bytes;
    
    uECC_vli_bytesToNative(private, private_key, BITS_TO_BYTES(curve->num_n_bits));
 8006896:	f7fe ffd2 	bl	800583e <uECC_vli_bytesToNative>
    uECC_vli_bytesToNative(public, public_key, num_bytes);
 800689a:	4632      	mov	r2, r6
 800689c:	4651      	mov	r1, sl
 800689e:	a814      	add	r0, sp, #80	; 0x50
 80068a0:	f7fe ffcd 	bl	800583e <uECC_vli_bytesToNative>
    uECC_vli_bytesToNative(public + num_words, public_key + num_bytes, num_bytes);
 80068a4:	fa4f f989 	sxtb.w	r9, r9
 80068a8:	ab14      	add	r3, sp, #80	; 0x50
 80068aa:	eb03 0089 	add.w	r0, r3, r9, lsl #2
 80068ae:	4632      	mov	r2, r6
 80068b0:	eb0a 0106 	add.w	r1, sl, r6
 80068b4:	f7fe ffc3 	bl	800583e <uECC_vli_bytesToNative>
    
    /* Regularize the bitcount for the private key so that attackers cannot use a side channel
       attack to learn the number of leading zeros. */
    carry = regularize_k(private, private, tmp, curve);
 80068b8:	4623      	mov	r3, r4
 80068ba:	463a      	mov	r2, r7
 80068bc:	4629      	mov	r1, r5
 80068be:	4628      	mov	r0, r5
 80068c0:	f7ff f8c8 	bl	8005a54 <regularize_k>
    
    /* If an RNG function was specified, try to get a random initial Z value to improve
       protection against side-channel attacks. */
    if (g_rng_function) {
 80068c4:	4b18      	ldr	r3, [pc, #96]	; (8006928 <uECC_shared_secret+0xbc>)
 80068c6:	681f      	ldr	r7, [r3, #0]
    uECC_vli_bytesToNative(public, public_key, num_bytes);
    uECC_vli_bytesToNative(public + num_words, public_key + num_bytes, num_bytes);
    
    /* Regularize the bitcount for the private key so that attackers cannot use a side channel
       attack to learn the number of leading zeros. */
    carry = regularize_k(private, private, tmp, curve);
 80068c8:	4605      	mov	r5, r0
    
    /* If an RNG function was specified, try to get a random initial Z value to improve
       protection against side-channel attacks. */
    if (g_rng_function) {
 80068ca:	b157      	cbz	r7, 80068e2 <uECC_shared_secret+0x76>
        if (!uECC_generate_random_int(p2[carry], curve->p, num_words)) {
 80068cc:	ab24      	add	r3, sp, #144	; 0x90
 80068ce:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 80068d2:	464a      	mov	r2, r9
 80068d4:	f853 7c88 	ldr.w	r7, [r3, #-136]
 80068d8:	1d21      	adds	r1, r4, #4
 80068da:	4638      	mov	r0, r7
 80068dc:	f7ff f920 	bl	8005b20 <uECC_generate_random_int>
 80068e0:	b1f8      	cbz	r0, 8006922 <uECC_shared_secret+0xb6>
            return 0;
        }
        initial_Z = p2[carry];
    }
    
    EccPoint_mult(public, public, p2[!carry], initial_Z, curve->num_n_bits + 1, curve);
 80068e2:	fab5 f085 	clz	r0, r5
 80068e6:	ab24      	add	r3, sp, #144	; 0x90
 80068e8:	0940      	lsrs	r0, r0, #5
 80068ea:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 80068ee:	8863      	ldrh	r3, [r4, #2]
 80068f0:	9401      	str	r4, [sp, #4]
 80068f2:	3301      	adds	r3, #1
 80068f4:	b21b      	sxth	r3, r3
 80068f6:	9300      	str	r3, [sp, #0]
 80068f8:	a914      	add	r1, sp, #80	; 0x50
 80068fa:	463b      	mov	r3, r7
 80068fc:	f850 2c88 	ldr.w	r2, [r0, #-136]
 8006900:	4608      	mov	r0, r1
 8006902:	f7ff fd25 	bl	8006350 <EccPoint_mult>
    uECC_vli_nativeToBytes(secret, num_bytes, public);
 8006906:	aa14      	add	r2, sp, #80	; 0x50
 8006908:	4631      	mov	r1, r6
 800690a:	4640      	mov	r0, r8
 800690c:	f7fe ff83 	bl	8005816 <uECC_vli_nativeToBytes>
    return !EccPoint_isZero(public, curve);
 8006910:	7821      	ldrb	r1, [r4, #0]
 8006912:	0049      	lsls	r1, r1, #1
 8006914:	b249      	sxtb	r1, r1
 8006916:	a814      	add	r0, sp, #80	; 0x50
 8006918:	f7fe fe34 	bl	8005584 <uECC_vli_isZero>
 800691c:	fab0 f080 	clz	r0, r0
 8006920:	0940      	lsrs	r0, r0, #5
}
 8006922:	b024      	add	sp, #144	; 0x90
 8006924:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8006928:	20000234 	.word	0x20000234

0800692c <uECC_compress>:
#endif

#if uECC_SUPPORT_COMPRESSED_POINT
void uECC_compress(const uint8_t *public_key, uint8_t *compressed, uECC_Curve curve) {
 800692c:	b530      	push	{r4, r5, lr}
    wordcount_t i;
    for (i = 0; i < curve->num_bytes; ++i) {
 800692e:	2400      	movs	r4, #0
 8006930:	b2e3      	uxtb	r3, r4
 8006932:	f992 5001 	ldrsb.w	r5, [r2, #1]
 8006936:	b25b      	sxtb	r3, r3
 8006938:	42ab      	cmp	r3, r5
 800693a:	f104 0401 	add.w	r4, r4, #1
 800693e:	da03      	bge.n	8006948 <uECC_compress+0x1c>
        compressed[i+1] = public_key[i];
 8006940:	5cc5      	ldrb	r5, [r0, r3]
 8006942:	440b      	add	r3, r1
 8006944:	705d      	strb	r5, [r3, #1]
 8006946:	e7f3      	b.n	8006930 <uECC_compress+0x4>
    }
    compressed[0] = 2 + (public_key[curve->num_bytes * 2 - 1] & 0x01);
 8006948:	eb00 0045 	add.w	r0, r0, r5, lsl #1
 800694c:	f810 3c01 	ldrb.w	r3, [r0, #-1]
 8006950:	f003 0301 	and.w	r3, r3, #1
 8006954:	3302      	adds	r3, #2
 8006956:	700b      	strb	r3, [r1, #0]
 8006958:	bd30      	pop	{r4, r5, pc}

0800695a <uECC_decompress>:
}

void uECC_decompress(const uint8_t *compressed, uint8_t *public_key, uECC_Curve curve) {
 800695a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uECC_word_t point[uECC_MAX_WORDS * 2];
    uECC_word_t *y = point + curve->num_words;
 800695e:	f992 7000 	ldrsb.w	r7, [r2]
        compressed[i+1] = public_key[i];
    }
    compressed[0] = 2 + (public_key[curve->num_bytes * 2 - 1] & 0x01);
}

void uECC_decompress(const uint8_t *compressed, uint8_t *public_key, uECC_Curve curve) {
 8006962:	b090      	sub	sp, #64	; 0x40
 8006964:	4614      	mov	r4, r2
 8006966:	4680      	mov	r8, r0
    uECC_word_t point[uECC_MAX_WORDS * 2];
    uECC_word_t *y = point + curve->num_words;
 8006968:	eb0d 0587 	add.w	r5, sp, r7, lsl #2
    uECC_vli_bytesToNative(point, compressed + 1, curve->num_bytes);
 800696c:	f992 2001 	ldrsb.w	r2, [r2, #1]
        compressed[i+1] = public_key[i];
    }
    compressed[0] = 2 + (public_key[curve->num_bytes * 2 - 1] & 0x01);
}

void uECC_decompress(const uint8_t *compressed, uint8_t *public_key, uECC_Curve curve) {
 8006970:	460e      	mov	r6, r1
    uECC_word_t point[uECC_MAX_WORDS * 2];
    uECC_word_t *y = point + curve->num_words;
    uECC_vli_bytesToNative(point, compressed + 1, curve->num_bytes);
 8006972:	1c41      	adds	r1, r0, #1
 8006974:	4668      	mov	r0, sp
 8006976:	f7fe ff62 	bl	800583e <uECC_vli_bytesToNative>
    curve->x_side(y, point, curve);
 800697a:	4622      	mov	r2, r4
 800697c:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 8006980:	4669      	mov	r1, sp
 8006982:	4628      	mov	r0, r5
 8006984:	4798      	blx	r3
    curve->mod_sqrt(y, curve);
 8006986:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 800698a:	4621      	mov	r1, r4
 800698c:	4628      	mov	r0, r5
 800698e:	4798      	blx	r3
    
    if ((y[0] & 0x01) != (compressed[0] & 0x01)) {
 8006990:	f898 2000 	ldrb.w	r2, [r8]
 8006994:	f85d 3027 	ldr.w	r3, [sp, r7, lsl #2]
 8006998:	4053      	eors	r3, r2
 800699a:	07db      	lsls	r3, r3, #31
 800699c:	d504      	bpl.n	80069a8 <uECC_decompress+0x4e>
        uECC_vli_sub(y, curve->p, y, curve->num_words);
 800699e:	462a      	mov	r2, r5
 80069a0:	1d21      	adds	r1, r4, #4
 80069a2:	4628      	mov	r0, r5
 80069a4:	f7ff f87d 	bl	8005aa2 <uECC_vli_sub.isra.1>
    }
    
    uECC_vli_nativeToBytes(public_key, curve->num_bytes, point);
 80069a8:	466a      	mov	r2, sp
 80069aa:	f994 1001 	ldrsb.w	r1, [r4, #1]
 80069ae:	4630      	mov	r0, r6
 80069b0:	f7fe ff31 	bl	8005816 <uECC_vli_nativeToBytes>
    uECC_vli_nativeToBytes(public_key + curve->num_bytes, curve->num_bytes, y);
 80069b4:	f994 1001 	ldrsb.w	r1, [r4, #1]
 80069b8:	462a      	mov	r2, r5
 80069ba:	1870      	adds	r0, r6, r1
 80069bc:	f7fe ff2b 	bl	8005816 <uECC_vli_nativeToBytes>
}
 80069c0:	b010      	add	sp, #64	; 0x40
 80069c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080069c6 <uECC_valid_point>:
#endif /* uECC_SUPPORT_COMPRESSED_POINT */

#ifndef NO_SIGNING
int uECC_valid_point(const uECC_word_t *point, uECC_Curve curve) {
 80069c6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    uECC_word_t tmp1[uECC_MAX_WORDS];
    uECC_word_t tmp2[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;
 80069ca:	780e      	ldrb	r6, [r1, #0]

    /* The point at infinity is invalid. */
    if (EccPoint_isZero(point, curve)) {
 80069cc:	b2f5      	uxtb	r5, r6
    uECC_vli_nativeToBytes(public_key + curve->num_bytes, curve->num_bytes, y);
}
#endif /* uECC_SUPPORT_COMPRESSED_POINT */

#ifndef NO_SIGNING
int uECC_valid_point(const uECC_word_t *point, uECC_Curve curve) {
 80069ce:	460f      	mov	r7, r1
    uECC_word_t tmp1[uECC_MAX_WORDS];
    uECC_word_t tmp2[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;

    /* The point at infinity is invalid. */
    if (EccPoint_isZero(point, curve)) {
 80069d0:	0069      	lsls	r1, r5, #1
    uECC_vli_nativeToBytes(public_key + curve->num_bytes, curve->num_bytes, y);
}
#endif /* uECC_SUPPORT_COMPRESSED_POINT */

#ifndef NO_SIGNING
int uECC_valid_point(const uECC_word_t *point, uECC_Curve curve) {
 80069d2:	b090      	sub	sp, #64	; 0x40
    uECC_word_t tmp1[uECC_MAX_WORDS];
    uECC_word_t tmp2[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;

    /* The point at infinity is invalid. */
    if (EccPoint_isZero(point, curve)) {
 80069d4:	b249      	sxtb	r1, r1
    uECC_vli_nativeToBytes(public_key + curve->num_bytes, curve->num_bytes, y);
}
#endif /* uECC_SUPPORT_COMPRESSED_POINT */

#ifndef NO_SIGNING
int uECC_valid_point(const uECC_word_t *point, uECC_Curve curve) {
 80069d6:	4680      	mov	r8, r0
    uECC_word_t tmp1[uECC_MAX_WORDS];
    uECC_word_t tmp2[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;

    /* The point at infinity is invalid. */
    if (EccPoint_isZero(point, curve)) {
 80069d8:	f7fe fdd4 	bl	8005584 <uECC_vli_isZero>
 80069dc:	4604      	mov	r4, r0
 80069de:	bb98      	cbnz	r0, 8006a48 <uECC_valid_point+0x82>
        return 0;
    }
    
    /* x and y must be smaller than p. */
    if (uECC_vli_cmp_unsafe(curve->p, point, num_words) != 1 ||
 80069e0:	f107 0a04 	add.w	sl, r7, #4
 80069e4:	b276      	sxtb	r6, r6
 80069e6:	4632      	mov	r2, r6
 80069e8:	4641      	mov	r1, r8
 80069ea:	4650      	mov	r0, sl
 80069ec:	f7fe fe12 	bl	8005614 <uECC_vli_cmp_unsafe>
 80069f0:	2801      	cmp	r0, #1
 80069f2:	d12b      	bne.n	8006a4c <uECC_valid_point+0x86>
            uECC_vli_cmp_unsafe(curve->p, point + num_words, num_words) != 1) {
 80069f4:	eb08 0986 	add.w	r9, r8, r6, lsl #2
 80069f8:	4632      	mov	r2, r6
 80069fa:	4649      	mov	r1, r9
 80069fc:	4650      	mov	r0, sl
 80069fe:	f7fe fe09 	bl	8005614 <uECC_vli_cmp_unsafe>
    if (EccPoint_isZero(point, curve)) {
        return 0;
    }
    
    /* x and y must be smaller than p. */
    if (uECC_vli_cmp_unsafe(curve->p, point, num_words) != 1 ||
 8006a02:	2801      	cmp	r0, #1
 8006a04:	d122      	bne.n	8006a4c <uECC_valid_point+0x86>
            uECC_vli_cmp_unsafe(curve->p, point + num_words, num_words) != 1) {
        return 0;
    }
    
    uECC_vli_modSquare_fast(tmp1, point + num_words, curve);
 8006a06:	463a      	mov	r2, r7
 8006a08:	4649      	mov	r1, r9
 8006a0a:	4668      	mov	r0, sp
 8006a0c:	f7fe fee0 	bl	80057d0 <uECC_vli_modSquare_fast>
    curve->x_side(tmp2, point, curve); /* tmp2 = x^3 + ax + b */
 8006a10:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8006a14:	a808      	add	r0, sp, #32
 8006a16:	463a      	mov	r2, r7
 8006a18:	4641      	mov	r1, r8
 8006a1a:	4798      	blx	r3
uECC_VLI_API uECC_word_t uECC_vli_equal(const uECC_word_t *left,
                                        const uECC_word_t *right,
                                        wordcount_t num_words) {
    uECC_word_t diff = 0;
    wordcount_t i;
    for (i = num_words - 1; i >= 0; --i) {
 8006a1c:	1e6b      	subs	r3, r5, #1
 8006a1e:	b2db      	uxtb	r3, r3
/* Constant-time comparison function - secure way to compare long integers */
/* Returns one if left == right, zero otherwise. */
uECC_VLI_API uECC_word_t uECC_vli_equal(const uECC_word_t *left,
                                        const uECC_word_t *right,
                                        wordcount_t num_words) {
    uECC_word_t diff = 0;
 8006a20:	4620      	mov	r0, r4
    wordcount_t i;
    for (i = num_words - 1; i >= 0; --i) {
 8006a22:	b25a      	sxtb	r2, r3
 8006a24:	2a00      	cmp	r2, #0
 8006a26:	db0b      	blt.n	8006a40 <uECC_valid_point+0x7a>
        diff |= (left[i] ^ right[i]);
 8006a28:	a910      	add	r1, sp, #64	; 0x40
 8006a2a:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 8006a2e:	3b01      	subs	r3, #1
 8006a30:	f852 1c40 	ldr.w	r1, [r2, #-64]
 8006a34:	f852 2c20 	ldr.w	r2, [r2, #-32]
 8006a38:	404a      	eors	r2, r1
 8006a3a:	4310      	orrs	r0, r2
 8006a3c:	b2db      	uxtb	r3, r3
 8006a3e:	e7f0      	b.n	8006a22 <uECC_valid_point+0x5c>
    
    uECC_vli_modSquare_fast(tmp1, point + num_words, curve);
    curve->x_side(tmp2, point, curve); /* tmp2 = x^3 + ax + b */
    
    /* Make sure that y^2 == x^3 + ax + b */
    return (int)(uECC_vli_equal(tmp1, tmp2, num_words));
 8006a40:	fab0 f080 	clz	r0, r0
 8006a44:	0940      	lsrs	r0, r0, #5
 8006a46:	e002      	b.n	8006a4e <uECC_valid_point+0x88>
    uECC_word_t tmp2[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;

    /* The point at infinity is invalid. */
    if (EccPoint_isZero(point, curve)) {
        return 0;
 8006a48:	2000      	movs	r0, #0
 8006a4a:	e000      	b.n	8006a4e <uECC_valid_point+0x88>
 8006a4c:	4620      	mov	r0, r4
    uECC_vli_modSquare_fast(tmp1, point + num_words, curve);
    curve->x_side(tmp2, point, curve); /* tmp2 = x^3 + ax + b */
    
    /* Make sure that y^2 == x^3 + ax + b */
    return (int)(uECC_vli_equal(tmp1, tmp2, num_words));
}
 8006a4e:	b010      	add	sp, #64	; 0x40
 8006a50:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08006a54 <uECC_valid_public_key>:

int uECC_valid_public_key(const uint8_t *public_key, uECC_Curve curve) {
 8006a54:	b530      	push	{r4, r5, lr}
 8006a56:	460c      	mov	r4, r1
 8006a58:	b091      	sub	sp, #68	; 0x44
 8006a5a:	4605      	mov	r5, r0
    uECC_word_t public[uECC_MAX_WORDS * 2];

    uECC_vli_bytesToNative(public, public_key, curve->num_bytes);
 8006a5c:	f991 2001 	ldrsb.w	r2, [r1, #1]
 8006a60:	4601      	mov	r1, r0
 8006a62:	4668      	mov	r0, sp
 8006a64:	f7fe feeb 	bl	800583e <uECC_vli_bytesToNative>
    uECC_vli_bytesToNative(
 8006a68:	f994 2001 	ldrsb.w	r2, [r4, #1]
 8006a6c:	f994 0000 	ldrsb.w	r0, [r4]
 8006a70:	18a9      	adds	r1, r5, r2
 8006a72:	eb0d 0080 	add.w	r0, sp, r0, lsl #2
 8006a76:	f7fe fee2 	bl	800583e <uECC_vli_bytesToNative>
        public + curve->num_words, public_key + curve->num_bytes, curve->num_bytes);
    return uECC_valid_point(public, curve);
 8006a7a:	4621      	mov	r1, r4
 8006a7c:	4668      	mov	r0, sp
 8006a7e:	f7ff ffa2 	bl	80069c6 <uECC_valid_point>
}
 8006a82:	b011      	add	sp, #68	; 0x44
 8006a84:	bd30      	pop	{r4, r5, pc}

08006a86 <uECC_compute_public_key>:

int uECC_compute_public_key(const uint8_t *private_key, uint8_t *public_key, uECC_Curve curve) {
 8006a86:	b570      	push	{r4, r5, r6, lr}
    uECC_word_t private[uECC_MAX_WORDS];
    uECC_word_t public[uECC_MAX_WORDS * 2];

    uECC_vli_bytesToNative(private, private_key, BITS_TO_BYTES(curve->num_n_bits));
 8006a88:	f9b2 3002 	ldrsh.w	r3, [r2, #2]
    uECC_vli_bytesToNative(
        public + curve->num_words, public_key + curve->num_bytes, curve->num_bytes);
    return uECC_valid_point(public, curve);
}

int uECC_compute_public_key(const uint8_t *private_key, uint8_t *public_key, uECC_Curve curve) {
 8006a8c:	b098      	sub	sp, #96	; 0x60
 8006a8e:	4615      	mov	r5, r2
    uECC_word_t private[uECC_MAX_WORDS];
    uECC_word_t public[uECC_MAX_WORDS * 2];

    uECC_vli_bytesToNative(private, private_key, BITS_TO_BYTES(curve->num_n_bits));
 8006a90:	3307      	adds	r3, #7
    uECC_vli_bytesToNative(
        public + curve->num_words, public_key + curve->num_bytes, curve->num_bytes);
    return uECC_valid_point(public, curve);
}

int uECC_compute_public_key(const uint8_t *private_key, uint8_t *public_key, uECC_Curve curve) {
 8006a92:	460e      	mov	r6, r1
    uECC_word_t private[uECC_MAX_WORDS];
    uECC_word_t public[uECC_MAX_WORDS * 2];

    uECC_vli_bytesToNative(private, private_key, BITS_TO_BYTES(curve->num_n_bits));
 8006a94:	2208      	movs	r2, #8
 8006a96:	4601      	mov	r1, r0
 8006a98:	fb93 f2f2 	sdiv	r2, r3, r2
 8006a9c:	4668      	mov	r0, sp
 8006a9e:	f7fe fece 	bl	800583e <uECC_vli_bytesToNative>

    /* Make sure the private key is in the range [1, n-1]. */
    if (uECC_vli_isZero(private, BITS_TO_WORDS(curve->num_n_bits))) {
 8006aa2:	f9b5 4002 	ldrsh.w	r4, [r5, #2]
 8006aa6:	2220      	movs	r2, #32
 8006aa8:	341f      	adds	r4, #31
 8006aaa:	fb94 f4f2 	sdiv	r4, r4, r2
 8006aae:	b264      	sxtb	r4, r4
 8006ab0:	4621      	mov	r1, r4
 8006ab2:	4668      	mov	r0, sp
 8006ab4:	f7fe fd66 	bl	8005584 <uECC_vli_isZero>
 8006ab8:	b108      	cbz	r0, 8006abe <uECC_compute_public_key+0x38>
        return 0;
 8006aba:	2000      	movs	r0, #0
 8006abc:	e020      	b.n	8006b00 <uECC_compute_public_key+0x7a>
    }

    if (uECC_vli_cmp(curve->n, private, BITS_TO_WORDS(curve->num_n_bits)) != 1) {
 8006abe:	4622      	mov	r2, r4
 8006ac0:	4669      	mov	r1, sp
 8006ac2:	f105 0024 	add.w	r0, r5, #36	; 0x24
 8006ac6:	f7ff f813 	bl	8005af0 <uECC_vli_cmp>
 8006aca:	2801      	cmp	r0, #1
 8006acc:	4604      	mov	r4, r0
 8006ace:	d1f4      	bne.n	8006aba <uECC_compute_public_key+0x34>
        return 0;
    }

    /* Compute public key. */
    if (!EccPoint_compute_public_key(public, private, curve)) {
 8006ad0:	462a      	mov	r2, r5
 8006ad2:	4669      	mov	r1, sp
 8006ad4:	a808      	add	r0, sp, #32
 8006ad6:	f7ff fd0c 	bl	80064f2 <EccPoint_compute_public_key>
 8006ada:	2800      	cmp	r0, #0
 8006adc:	d0ed      	beq.n	8006aba <uECC_compute_public_key+0x34>
        return 0;
    }

    uECC_vli_nativeToBytes(public_key, curve->num_bytes, public);
 8006ade:	aa08      	add	r2, sp, #32
 8006ae0:	f995 1001 	ldrsb.w	r1, [r5, #1]
 8006ae4:	4630      	mov	r0, r6
 8006ae6:	f7fe fe96 	bl	8005816 <uECC_vli_nativeToBytes>
    uECC_vli_nativeToBytes(
 8006aea:	f995 2000 	ldrsb.w	r2, [r5]
 8006aee:	f995 1001 	ldrsb.w	r1, [r5, #1]
 8006af2:	ab08      	add	r3, sp, #32
 8006af4:	1870      	adds	r0, r6, r1
 8006af6:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8006afa:	f7fe fe8c 	bl	8005816 <uECC_vli_nativeToBytes>
        public_key + curve->num_bytes, curve->num_bytes, public + curve->num_words);
    return 1;
 8006afe:	4620      	mov	r0, r4
}
 8006b00:	b018      	add	sp, #96	; 0x60
 8006b02:	bd70      	pop	{r4, r5, r6, pc}

08006b04 <uECC_sign>:

int uECC_sign(const uint8_t *private_key,
              const uint8_t *message_hash,
              unsigned hash_size,
              uint8_t *signature,
              uECC_Curve curve) {
 8006b04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006b08:	b08b      	sub	sp, #44	; 0x2c
 8006b0a:	4606      	mov	r6, r0
 8006b0c:	9d14      	ldr	r5, [sp, #80]	; 0x50
 8006b0e:	460f      	mov	r7, r1
 8006b10:	4690      	mov	r8, r2
 8006b12:	4699      	mov	r9, r3
 8006b14:	2440      	movs	r4, #64	; 0x40
    uECC_word_t k[uECC_MAX_WORDS];
    uECC_word_t tries;

    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
        if (!uECC_generate_random_int(k, curve->n, BITS_TO_WORDS(curve->num_n_bits))) {
 8006b16:	f04f 0a20 	mov.w	sl, #32
 8006b1a:	f105 0b24 	add.w	fp, r5, #36	; 0x24
 8006b1e:	f9b5 2002 	ldrsh.w	r2, [r5, #2]
 8006b22:	4659      	mov	r1, fp
 8006b24:	321f      	adds	r2, #31
 8006b26:	a802      	add	r0, sp, #8
 8006b28:	fb92 f2fa 	sdiv	r2, r2, sl
 8006b2c:	b252      	sxtb	r2, r2
 8006b2e:	f7fe fff7 	bl	8005b20 <uECC_generate_random_int>
 8006b32:	b908      	cbnz	r0, 8006b38 <uECC_sign+0x34>
            return 0;
 8006b34:	2000      	movs	r0, #0
 8006b36:	e00d      	b.n	8006b54 <uECC_sign+0x50>
        }

        if (uECC_sign_with_k(private_key, message_hash, hash_size, k, signature, curve)) {
 8006b38:	9501      	str	r5, [sp, #4]
 8006b3a:	f8cd 9000 	str.w	r9, [sp]
 8006b3e:	ab02      	add	r3, sp, #8
 8006b40:	4642      	mov	r2, r8
 8006b42:	4639      	mov	r1, r7
 8006b44:	4630      	mov	r0, r6
 8006b46:	f7ff fcff 	bl	8006548 <uECC_sign_with_k>
 8006b4a:	b910      	cbnz	r0, 8006b52 <uECC_sign+0x4e>
              uint8_t *signature,
              uECC_Curve curve) {
    uECC_word_t k[uECC_MAX_WORDS];
    uECC_word_t tries;

    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
 8006b4c:	3c01      	subs	r4, #1
 8006b4e:	d1e6      	bne.n	8006b1e <uECC_sign+0x1a>
 8006b50:	e7f0      	b.n	8006b34 <uECC_sign+0x30>
        if (!uECC_generate_random_int(k, curve->n, BITS_TO_WORDS(curve->num_n_bits))) {
            return 0;
        }

        if (uECC_sign_with_k(private_key, message_hash, hash_size, k, signature, curve)) {
            return 1;
 8006b52:	2001      	movs	r0, #1
        }
    }
    return 0;
}
 8006b54:	b00b      	add	sp, #44	; 0x2c
 8006b56:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08006b5a <uECC_sign_deterministic>:
int uECC_sign_deterministic(const uint8_t *private_key,
                            const uint8_t *message_hash,
                            unsigned hash_size,
                            uECC_HashContext *hash_context,
                            uint8_t *signature,
                            uECC_Curve curve) {
 8006b5a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006b5e:	b091      	sub	sp, #68	; 0x44
 8006b60:	4692      	mov	sl, r2
    uint8_t *K = hash_context->tmp;
    uint8_t *V = K + hash_context->result_size;
    wordcount_t num_bytes = curve->num_bytes;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8006b62:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
                            const uint8_t *message_hash,
                            unsigned hash_size,
                            uECC_HashContext *hash_context,
                            uint8_t *signature,
                            uECC_Curve curve) {
    uint8_t *K = hash_context->tmp;
 8006b64:	695d      	ldr	r5, [r3, #20]
    uint8_t *V = K + hash_context->result_size;
    wordcount_t num_bytes = curve->num_bytes;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8006b66:	f8b2 b002 	ldrh.w	fp, [r2, #2]
                            unsigned hash_size,
                            uECC_HashContext *hash_context,
                            uint8_t *signature,
                            uECC_Curve curve) {
    uint8_t *K = hash_context->tmp;
    uint8_t *V = K + hash_context->result_size;
 8006b6a:	691e      	ldr	r6, [r3, #16]
int uECC_sign_deterministic(const uint8_t *private_key,
                            const uint8_t *message_hash,
                            unsigned hash_size,
                            uECC_HashContext *hash_context,
                            uint8_t *signature,
                            uECC_Curve curve) {
 8006b6c:	461c      	mov	r4, r3
    uint8_t *K = hash_context->tmp;
    uint8_t *V = K + hash_context->result_size;
    wordcount_t num_bytes = curve->num_bytes;
 8006b6e:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8006b70:	fa0f f28b 	sxth.w	r2, fp
 8006b74:	9203      	str	r2, [sp, #12]
 8006b76:	2720      	movs	r7, #32
 8006b78:	321f      	adds	r2, #31
                            uECC_HashContext *hash_context,
                            uint8_t *signature,
                            uECC_Curve curve) {
    uint8_t *K = hash_context->tmp;
    uint8_t *V = K + hash_context->result_size;
    wordcount_t num_bytes = curve->num_bytes;
 8006b7a:	785b      	ldrb	r3, [r3, #1]
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8006b7c:	fb92 f7f7 	sdiv	r7, r2, r7
    bitcount_t num_n_bits = curve->num_n_bits;
    uECC_word_t tries;
    unsigned i;
    for (i = 0; i < hash_context->result_size; ++i) {
 8006b80:	2200      	movs	r2, #0
int uECC_sign_deterministic(const uint8_t *private_key,
                            const uint8_t *message_hash,
                            unsigned hash_size,
                            uECC_HashContext *hash_context,
                            uint8_t *signature,
                            uECC_Curve curve) {
 8006b82:	4680      	mov	r8, r0
 8006b84:	4689      	mov	r9, r1
    uint8_t *K = hash_context->tmp;
    uint8_t *V = K + hash_context->result_size;
 8006b86:	442e      	add	r6, r5
    wordcount_t num_bytes = curve->num_bytes;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8006b88:	b2ff      	uxtb	r7, r7
    bitcount_t num_n_bits = curve->num_n_bits;
    uECC_word_t tries;
    unsigned i;
    for (i = 0; i < hash_context->result_size; ++i) {
        V[i] = 0x01;
 8006b8a:	2001      	movs	r0, #1
        K[i] = 0;
 8006b8c:	4696      	mov	lr, r2
    wordcount_t num_bytes = curve->num_bytes;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    bitcount_t num_n_bits = curve->num_n_bits;
    uECC_word_t tries;
    unsigned i;
    for (i = 0; i < hash_context->result_size; ++i) {
 8006b8e:	6921      	ldr	r1, [r4, #16]
 8006b90:	428a      	cmp	r2, r1
 8006b92:	d204      	bcs.n	8006b9e <uECC_sign_deterministic+0x44>
        V[i] = 0x01;
 8006b94:	54b0      	strb	r0, [r6, r2]
        K[i] = 0;
 8006b96:	f805 e002 	strb.w	lr, [r5, r2]
    wordcount_t num_bytes = curve->num_bytes;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    bitcount_t num_n_bits = curve->num_n_bits;
    uECC_word_t tries;
    unsigned i;
    for (i = 0; i < hash_context->result_size; ++i) {
 8006b9a:	3201      	adds	r2, #1
 8006b9c:	e7f7      	b.n	8006b8e <uECC_sign_deterministic+0x34>
        V[i] = 0x01;
        K[i] = 0;
    }
    
    /* K = HMAC_K(V || 0x00 || int2octets(x) || h(m)) */
    HMAC_init(hash_context, K);
 8006b9e:	4629      	mov	r1, r5
 8006ba0:	4620      	mov	r0, r4
 8006ba2:	9304      	str	r3, [sp, #16]
 8006ba4:	f7fe fe6c 	bl	8005880 <HMAC_init>
    V[hash_context->result_size] = 0x00;
 8006ba8:	6922      	ldr	r2, [r4, #16]
 8006baa:	2100      	movs	r1, #0
 8006bac:	54b1      	strb	r1, [r6, r2]
    HMAC_update(hash_context, V, hash_context->result_size + 1);
 8006bae:	6922      	ldr	r2, [r4, #16]
 8006bb0:	4631      	mov	r1, r6
 8006bb2:	3201      	adds	r2, #1
 8006bb4:	4620      	mov	r0, r4
 8006bb6:	f7fe fe86 	bl	80058c6 <HMAC_update>
    HMAC_update(hash_context, private_key, num_bytes);
 8006bba:	9b04      	ldr	r3, [sp, #16]
 8006bbc:	b25b      	sxtb	r3, r3
 8006bbe:	461a      	mov	r2, r3
 8006bc0:	4641      	mov	r1, r8
 8006bc2:	4620      	mov	r0, r4
 8006bc4:	9304      	str	r3, [sp, #16]
 8006bc6:	f7fe fe7e 	bl	80058c6 <HMAC_update>
    HMAC_update(hash_context, message_hash, hash_size);
 8006bca:	4652      	mov	r2, sl
 8006bcc:	4649      	mov	r1, r9
 8006bce:	4620      	mov	r0, r4
 8006bd0:	f7fe fe79 	bl	80058c6 <HMAC_update>
    HMAC_finish(hash_context, K, K);
 8006bd4:	462a      	mov	r2, r5
 8006bd6:	4629      	mov	r1, r5
 8006bd8:	4620      	mov	r0, r4
 8006bda:	f7fe fe76 	bl	80058ca <HMAC_finish>

    update_V(hash_context, K, V);
 8006bde:	4632      	mov	r2, r6
 8006be0:	4629      	mov	r1, r5
 8006be2:	4620      	mov	r0, r4
 8006be4:	f7fe fea2 	bl	800592c <update_V>
    
    /* K = HMAC_K(V || 0x01 || int2octets(x) || h(m)) */
    HMAC_init(hash_context, K);
 8006be8:	4629      	mov	r1, r5
 8006bea:	4620      	mov	r0, r4
 8006bec:	f7fe fe48 	bl	8005880 <HMAC_init>
    V[hash_context->result_size] = 0x01;
 8006bf0:	6922      	ldr	r2, [r4, #16]
 8006bf2:	2101      	movs	r1, #1
 8006bf4:	54b1      	strb	r1, [r6, r2]
    HMAC_update(hash_context, V, hash_context->result_size + 1);
 8006bf6:	6922      	ldr	r2, [r4, #16]
 8006bf8:	4620      	mov	r0, r4
 8006bfa:	440a      	add	r2, r1
 8006bfc:	4631      	mov	r1, r6
 8006bfe:	f7fe fe62 	bl	80058c6 <HMAC_update>
    HMAC_update(hash_context, private_key, num_bytes);
 8006c02:	9b04      	ldr	r3, [sp, #16]
 8006c04:	4641      	mov	r1, r8
 8006c06:	461a      	mov	r2, r3
 8006c08:	4620      	mov	r0, r4
 8006c0a:	f7fe fe5c 	bl	80058c6 <HMAC_update>
    HMAC_update(hash_context, message_hash, hash_size);
 8006c0e:	4652      	mov	r2, sl
 8006c10:	4649      	mov	r1, r9
 8006c12:	4620      	mov	r0, r4
 8006c14:	f7fe fe57 	bl	80058c6 <HMAC_update>
    HMAC_finish(hash_context, K, K);
 8006c18:	462a      	mov	r2, r5
 8006c1a:	4629      	mov	r1, r5
 8006c1c:	4620      	mov	r0, r4
 8006c1e:	f7fe fe54 	bl	80058ca <HMAC_finish>
        wordcount_t T_bytes = 0;
        for (;;) {
            update_V(hash_context, K, V);
            for (i = 0; i < hash_context->result_size; ++i) {
                T_ptr[T_bytes++] = V[i];
                if (T_bytes >= num_n_words * uECC_WORD_SIZE) {
 8006c22:	b27f      	sxtb	r7, r7
    HMAC_update(hash_context, V, hash_context->result_size + 1);
    HMAC_update(hash_context, private_key, num_bytes);
    HMAC_update(hash_context, message_hash, hash_size);
    HMAC_finish(hash_context, K, K);

    update_V(hash_context, K, V);
 8006c24:	4632      	mov	r2, r6
 8006c26:	4629      	mov	r1, r5
 8006c28:	4620      	mov	r0, r4
 8006c2a:	f7fe fe7f 	bl	800592c <update_V>
 8006c2e:	b23b      	sxth	r3, r7
 8006c30:	009a      	lsls	r2, r3, #2
        }
    filled:
        if ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8 > num_n_bits) {
            uECC_word_t mask = (uECC_word_t)-1;
            T[num_n_words - 1] &=
                mask >> ((bitcount_t)(num_n_words * uECC_WORD_SIZE * 8 - num_n_bits));
 8006c32:	ebcb 1b47 	rsb	fp, fp, r7, lsl #5
 8006c36:	015b      	lsls	r3, r3, #5
 8006c38:	9306      	str	r3, [sp, #24]
 8006c3a:	fa0f fb8b 	sxth.w	fp, fp
 8006c3e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8006c42:	fa23 f30b 	lsr.w	r3, r3, fp
 8006c46:	9307      	str	r3, [sp, #28]
 8006c48:	2340      	movs	r3, #64	; 0x40
 8006c4a:	9304      	str	r3, [sp, #16]
            }
        }
    filled:
        if ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8 > num_n_bits) {
            uECC_word_t mask = (uECC_word_t)-1;
            T[num_n_words - 1] &=
 8006c4c:	3f01      	subs	r7, #1
 8006c4e:	446b      	add	r3, sp
 8006c50:	9205      	str	r2, [sp, #20]
 8006c52:	eb03 0787 	add.w	r7, r3, r7, lsl #2
                mask >> ((bitcount_t)(num_n_words * uECC_WORD_SIZE * 8 - num_n_bits));
 8006c56:	f04f 0b00 	mov.w	fp, #0
    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
        uECC_word_t T[uECC_MAX_WORDS];
        uint8_t *T_ptr = (uint8_t *)T;
        wordcount_t T_bytes = 0;
        for (;;) {
            update_V(hash_context, K, V);
 8006c5a:	4629      	mov	r1, r5
 8006c5c:	4620      	mov	r0, r4
 8006c5e:	4632      	mov	r2, r6
 8006c60:	f7fe fe64 	bl	800592c <update_V>
 8006c64:	6921      	ldr	r1, [r4, #16]
 8006c66:	4630      	mov	r0, r6
 8006c68:	4431      	add	r1, r6
            for (i = 0; i < hash_context->result_size; ++i) {
 8006c6a:	4288      	cmp	r0, r1
 8006c6c:	d0f5      	beq.n	8006c5a <uECC_sign_deterministic+0x100>
                T_ptr[T_bytes++] = V[i];
 8006c6e:	ab10      	add	r3, sp, #64	; 0x40
 8006c70:	fa43 f38b 	sxtab	r3, r3, fp
 8006c74:	f810 eb01 	ldrb.w	lr, [r0], #1
 8006c78:	f803 ec20 	strb.w	lr, [r3, #-32]
 8006c7c:	f10b 0201 	add.w	r2, fp, #1
 8006c80:	b2d2      	uxtb	r2, r2
                if (T_bytes >= num_n_words * uECC_WORD_SIZE) {
 8006c82:	9b05      	ldr	r3, [sp, #20]
 8006c84:	fa4f fe82 	sxtb.w	lr, r2
 8006c88:	459e      	cmp	lr, r3
 8006c8a:	da01      	bge.n	8006c90 <uECC_sign_deterministic+0x136>
        uint8_t *T_ptr = (uint8_t *)T;
        wordcount_t T_bytes = 0;
        for (;;) {
            update_V(hash_context, K, V);
            for (i = 0; i < hash_context->result_size; ++i) {
                T_ptr[T_bytes++] = V[i];
 8006c8c:	4693      	mov	fp, r2
 8006c8e:	e7ec      	b.n	8006c6a <uECC_sign_deterministic+0x110>
                    goto filled;
                }
            }
        }
    filled:
        if ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8 > num_n_bits) {
 8006c90:	9b03      	ldr	r3, [sp, #12]
 8006c92:	9a06      	ldr	r2, [sp, #24]
 8006c94:	4293      	cmp	r3, r2
            uECC_word_t mask = (uECC_word_t)-1;
            T[num_n_words - 1] &=
 8006c96:	bfbf      	itttt	lt
 8006c98:	f857 3c20 	ldrlt.w	r3, [r7, #-32]
 8006c9c:	9a07      	ldrlt	r2, [sp, #28]
 8006c9e:	4013      	andlt	r3, r2
 8006ca0:	f847 3c20 	strlt.w	r3, [r7, #-32]
                mask >> ((bitcount_t)(num_n_words * uECC_WORD_SIZE * 8 - num_n_bits));
        }
    
        if (uECC_sign_with_k(private_key, message_hash, hash_size, T, signature, curve)) {
 8006ca4:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8006ca6:	9301      	str	r3, [sp, #4]
 8006ca8:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8006caa:	9300      	str	r3, [sp, #0]
 8006cac:	4652      	mov	r2, sl
 8006cae:	ab08      	add	r3, sp, #32
 8006cb0:	4649      	mov	r1, r9
 8006cb2:	4640      	mov	r0, r8
 8006cb4:	f7ff fc48 	bl	8006548 <uECC_sign_with_k>
 8006cb8:	4683      	mov	fp, r0
 8006cba:	b110      	cbz	r0, 8006cc2 <uECC_sign_deterministic+0x168>
            return 1;
 8006cbc:	f04f 0b01 	mov.w	fp, #1
 8006cc0:	e01a      	b.n	8006cf8 <uECC_sign_deterministic+0x19e>
        }

        /* K = HMAC_K(V || 0x00) */
        HMAC_init(hash_context, K);
 8006cc2:	4629      	mov	r1, r5
 8006cc4:	4620      	mov	r0, r4
 8006cc6:	f7fe fddb 	bl	8005880 <HMAC_init>
        V[hash_context->result_size] = 0x00;
 8006cca:	6922      	ldr	r2, [r4, #16]
 8006ccc:	f806 b002 	strb.w	fp, [r6, r2]
        HMAC_update(hash_context, V, hash_context->result_size + 1);
 8006cd0:	6922      	ldr	r2, [r4, #16]
 8006cd2:	4631      	mov	r1, r6
 8006cd4:	3201      	adds	r2, #1
 8006cd6:	4620      	mov	r0, r4
 8006cd8:	f7fe fdf5 	bl	80058c6 <HMAC_update>
        HMAC_finish(hash_context, K, K);
 8006cdc:	462a      	mov	r2, r5
 8006cde:	4629      	mov	r1, r5
 8006ce0:	4620      	mov	r0, r4
 8006ce2:	f7fe fdf2 	bl	80058ca <HMAC_finish>

        update_V(hash_context, K, V);
 8006ce6:	4632      	mov	r2, r6
 8006ce8:	4629      	mov	r1, r5
 8006cea:	4620      	mov	r0, r4
 8006cec:	f7fe fe1e 	bl	800592c <update_V>
    HMAC_update(hash_context, message_hash, hash_size);
    HMAC_finish(hash_context, K, K);

    update_V(hash_context, K, V);

    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
 8006cf0:	9b04      	ldr	r3, [sp, #16]
 8006cf2:	3b01      	subs	r3, #1
 8006cf4:	9304      	str	r3, [sp, #16]
 8006cf6:	d1ae      	bne.n	8006c56 <uECC_sign_deterministic+0xfc>
        HMAC_finish(hash_context, K, K);

        update_V(hash_context, K, V);
    }
    return 0;
}
 8006cf8:	4658      	mov	r0, fp
 8006cfa:	b011      	add	sp, #68	; 0x44
 8006cfc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08006d00 <uECC_verify>:

int uECC_verify(const uint8_t *public_key,
                const uint8_t *message_hash,
                unsigned hash_size,
                const uint8_t *signature,
                uECC_Curve curve) {
 8006d00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006d04:	b0ff      	sub	sp, #508	; 0x1fc
 8006d06:	461c      	mov	r4, r3
 8006d08:	9d88      	ldr	r5, [sp, #544]	; 0x220
 8006d0a:	9209      	str	r2, [sp, #36]	; 0x24
    const uECC_word_t *points[4];
    const uECC_word_t *point;
    bitcount_t num_bits;
    bitcount_t i;
    uECC_word_t r[uECC_MAX_WORDS], s[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;
 8006d0c:	782b      	ldrb	r3, [r5, #0]
 8006d0e:	9303      	str	r3, [sp, #12]
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8006d10:	f9b5 3002 	ldrsh.w	r3, [r5, #2]

int uECC_verify(const uint8_t *public_key,
                const uint8_t *message_hash,
                unsigned hash_size,
                const uint8_t *signature,
                uECC_Curve curve) {
 8006d14:	9106      	str	r1, [sp, #24]
    const uECC_word_t *point;
    bitcount_t num_bits;
    bitcount_t i;
    uECC_word_t r[uECC_MAX_WORDS], s[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8006d16:	2220      	movs	r2, #32
 8006d18:	331f      	adds	r3, #31
 8006d1a:	fb93 f3f2 	sdiv	r3, r3, r2
 8006d1e:	b2db      	uxtb	r3, r3
 8006d20:	9305      	str	r3, [sp, #20]
    
    rx[num_n_words - 1] = 0;
 8006d22:	f99d 9014 	ldrsb.w	r9, [sp, #20]
    r[num_n_words - 1] = 0;
    s[num_n_words - 1] = 0;

    uECC_vli_bytesToNative(public, public_key, curve->num_bytes);
 8006d26:	f995 2001 	ldrsb.w	r2, [r5, #1]
    bitcount_t i;
    uECC_word_t r[uECC_MAX_WORDS], s[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    
    rx[num_n_words - 1] = 0;
 8006d2a:	f109 38ff 	add.w	r8, r9, #4294967295	; 0xffffffff
 8006d2e:	ab26      	add	r3, sp, #152	; 0x98
 8006d30:	f04f 0b00 	mov.w	fp, #0
 8006d34:	f843 b028 	str.w	fp, [r3, r8, lsl #2]
    r[num_n_words - 1] = 0;
 8006d38:	ab7e      	add	r3, sp, #504	; 0x1f8
 8006d3a:	eb03 0388 	add.w	r3, r3, r8, lsl #2
    s[num_n_words - 1] = 0;

    uECC_vli_bytesToNative(public, public_key, curve->num_bytes);
 8006d3e:	4601      	mov	r1, r0

int uECC_verify(const uint8_t *public_key,
                const uint8_t *message_hash,
                unsigned hash_size,
                const uint8_t *signature,
                uECC_Curve curve) {
 8006d40:	4607      	mov	r7, r0
    
    rx[num_n_words - 1] = 0;
    r[num_n_words - 1] = 0;
    s[num_n_words - 1] = 0;

    uECC_vli_bytesToNative(public, public_key, curve->num_bytes);
 8006d42:	a85e      	add	r0, sp, #376	; 0x178
    uECC_word_t r[uECC_MAX_WORDS], s[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    
    rx[num_n_words - 1] = 0;
    r[num_n_words - 1] = 0;
 8006d44:	f843 bcc0 	str.w	fp, [r3, #-192]
    s[num_n_words - 1] = 0;
 8006d48:	f843 bca0 	str.w	fp, [r3, #-160]

    uECC_vli_bytesToNative(public, public_key, curve->num_bytes);
 8006d4c:	f7fe fd77 	bl	800583e <uECC_vli_bytesToNative>
    uECC_vli_bytesToNative(
        public + num_words, public_key + curve->num_bytes, curve->num_bytes);
 8006d50:	f99d 600c 	ldrsb.w	r6, [sp, #12]
 8006d54:	00b3      	lsls	r3, r6, #2
 8006d56:	9308      	str	r3, [sp, #32]
    rx[num_n_words - 1] = 0;
    r[num_n_words - 1] = 0;
    s[num_n_words - 1] = 0;

    uECC_vli_bytesToNative(public, public_key, curve->num_bytes);
    uECC_vli_bytesToNative(
 8006d58:	00b2      	lsls	r2, r6, #2
 8006d5a:	ab5e      	add	r3, sp, #376	; 0x178
 8006d5c:	4413      	add	r3, r2
 8006d5e:	f995 2001 	ldrsb.w	r2, [r5, #1]
 8006d62:	9304      	str	r3, [sp, #16]
 8006d64:	4618      	mov	r0, r3
 8006d66:	18b9      	adds	r1, r7, r2
 8006d68:	f7fe fd69 	bl	800583e <uECC_vli_bytesToNative>
        public + num_words, public_key + curve->num_bytes, curve->num_bytes);
    uECC_vli_bytesToNative(r, signature, curve->num_bytes);
 8006d6c:	4621      	mov	r1, r4
 8006d6e:	f995 2001 	ldrsb.w	r2, [r5, #1]
 8006d72:	a84e      	add	r0, sp, #312	; 0x138
 8006d74:	f7fe fd63 	bl	800583e <uECC_vli_bytesToNative>
    uECC_vli_bytesToNative(s, signature + curve->num_bytes, curve->num_bytes);
 8006d78:	f995 2001 	ldrsb.w	r2, [r5, #1]
 8006d7c:	a856      	add	r0, sp, #344	; 0x158
 8006d7e:	18a1      	adds	r1, r4, r2
 8006d80:	f7fe fd5d 	bl	800583e <uECC_vli_bytesToNative>
    
    /* r, s must not be 0. */
    if (uECC_vli_isZero(r, num_words) || uECC_vli_isZero(s, num_words)) {
 8006d84:	4631      	mov	r1, r6
 8006d86:	a84e      	add	r0, sp, #312	; 0x138
 8006d88:	f7fe fbfc 	bl	8005584 <uECC_vli_isZero>
 8006d8c:	4604      	mov	r4, r0
 8006d8e:	2800      	cmp	r0, #0
 8006d90:	f040 8138 	bne.w	8007004 <uECC_verify+0x304>
 8006d94:	4631      	mov	r1, r6
 8006d96:	a856      	add	r0, sp, #344	; 0x158
 8006d98:	f7fe fbf4 	bl	8005584 <uECC_vli_isZero>
 8006d9c:	9002      	str	r0, [sp, #8]
 8006d9e:	2800      	cmp	r0, #0
 8006da0:	f040 8132 	bne.w	8007008 <uECC_verify+0x308>
        return 0;
    }

    /* r, s must be < n. */
    if (uECC_vli_cmp_unsafe(curve->n, r, num_n_words) != 1 ||
 8006da4:	f105 0a24 	add.w	sl, r5, #36	; 0x24
 8006da8:	464a      	mov	r2, r9
 8006daa:	a94e      	add	r1, sp, #312	; 0x138
 8006dac:	4650      	mov	r0, sl
 8006dae:	f7fe fc31 	bl	8005614 <uECC_vli_cmp_unsafe>
 8006db2:	2801      	cmp	r0, #1
 8006db4:	f040 812a 	bne.w	800700c <uECC_verify+0x30c>
            uECC_vli_cmp_unsafe(curve->n, s, num_n_words) != 1) {
 8006db8:	464a      	mov	r2, r9
 8006dba:	a956      	add	r1, sp, #344	; 0x158
 8006dbc:	4650      	mov	r0, sl
 8006dbe:	f7fe fc29 	bl	8005614 <uECC_vli_cmp_unsafe>
    if (uECC_vli_isZero(r, num_words) || uECC_vli_isZero(s, num_words)) {
        return 0;
    }

    /* r, s must be < n. */
    if (uECC_vli_cmp_unsafe(curve->n, r, num_n_words) != 1 ||
 8006dc2:	2801      	cmp	r0, #1
            uECC_vli_cmp_unsafe(curve->n, s, num_n_words) != 1) {
 8006dc4:	9007      	str	r0, [sp, #28]
    if (uECC_vli_isZero(r, num_words) || uECC_vli_isZero(s, num_words)) {
        return 0;
    }

    /* r, s must be < n. */
    if (uECC_vli_cmp_unsafe(curve->n, r, num_n_words) != 1 ||
 8006dc6:	f040 8121 	bne.w	800700c <uECC_verify+0x30c>
            uECC_vli_cmp_unsafe(curve->n, s, num_n_words) != 1) {
        return 0;
    }

    /* Calculate u1 and u2. */
    uECC_vli_modInv(z, s, curve->n, num_n_words); /* z = 1/s */
 8006dca:	ac1e      	add	r4, sp, #120	; 0x78
    u1[num_n_words - 1] = 0;
 8006dcc:	af0e      	add	r7, sp, #56	; 0x38
            uECC_vli_cmp_unsafe(curve->n, s, num_n_words) != 1) {
        return 0;
    }

    /* Calculate u1 and u2. */
    uECC_vli_modInv(z, s, curve->n, num_n_words); /* z = 1/s */
 8006dce:	464b      	mov	r3, r9
 8006dd0:	4652      	mov	r2, sl
 8006dd2:	a956      	add	r1, sp, #344	; 0x158
 8006dd4:	4620      	mov	r0, r4
 8006dd6:	f7ff fa39 	bl	800624c <uECC_vli_modInv>
    u1[num_n_words - 1] = 0;
 8006dda:	9b02      	ldr	r3, [sp, #8]
 8006ddc:	f847 3028 	str.w	r3, [r7, r8, lsl #2]
    bits2int(u1, message_hash, hash_size, curve);
 8006de0:	4638      	mov	r0, r7
 8006de2:	462b      	mov	r3, r5
 8006de4:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8006de6:	9906      	ldr	r1, [sp, #24]
 8006de8:	f7ff f80e 	bl	8005e08 <bits2int>
    uECC_vli_modMult(u1, u1, z, curve->n, num_n_words); /* u1 = e/s */
 8006dec:	4639      	mov	r1, r7
 8006dee:	4638      	mov	r0, r7
 8006df0:	f8cd 9000 	str.w	r9, [sp]
 8006df4:	4653      	mov	r3, sl
 8006df6:	4622      	mov	r2, r4
 8006df8:	f7fe fc2e 	bl	8005658 <uECC_vli_modMult>
    uECC_vli_modMult(u2, r, z, curve->n, num_n_words); /* u2 = r/s */
    
    /* Calculate sum = G + Q. */
    uECC_vli_set(sum, public, num_words);
 8006dfc:	f50d 78dc 	add.w	r8, sp, #440	; 0x1b8
    /* Calculate u1 and u2. */
    uECC_vli_modInv(z, s, curve->n, num_n_words); /* z = 1/s */
    u1[num_n_words - 1] = 0;
    bits2int(u1, message_hash, hash_size, curve);
    uECC_vli_modMult(u1, u1, z, curve->n, num_n_words); /* u1 = e/s */
    uECC_vli_modMult(u2, r, z, curve->n, num_n_words); /* u2 = r/s */
 8006e00:	4653      	mov	r3, sl
 8006e02:	f8cd 9000 	str.w	r9, [sp]
 8006e06:	4622      	mov	r2, r4
 8006e08:	a94e      	add	r1, sp, #312	; 0x138
 8006e0a:	a816      	add	r0, sp, #88	; 0x58
 8006e0c:	f7fe fc24 	bl	8005658 <uECC_vli_modMult>
    
    /* Calculate sum = G + Q. */
    uECC_vli_set(sum, public, num_words);
 8006e10:	4640      	mov	r0, r8
 8006e12:	4632      	mov	r2, r6
 8006e14:	a95e      	add	r1, sp, #376	; 0x178
 8006e16:	f7fe fbf0 	bl	80055fa <uECC_vli_set>
    uECC_vli_set(sum + num_words, public + num_words, num_words);
 8006e1a:	00b3      	lsls	r3, r6, #2
 8006e1c:	eb08 0b03 	add.w	fp, r8, r3
 8006e20:	4658      	mov	r0, fp
 8006e22:	4632      	mov	r2, r6
 8006e24:	9904      	ldr	r1, [sp, #16]
 8006e26:	f7fe fbe8 	bl	80055fa <uECC_vli_set>
    uECC_vli_set(tx, curve->G, num_words);
 8006e2a:	f105 0344 	add.w	r3, r5, #68	; 0x44
 8006e2e:	4619      	mov	r1, r3
 8006e30:	4632      	mov	r2, r6
 8006e32:	a836      	add	r0, sp, #216	; 0xd8
 8006e34:	9304      	str	r3, [sp, #16]
 8006e36:	f7fe fbe0 	bl	80055fa <uECC_vli_set>
    uECC_vli_set(ty, curve->G + num_words, num_words);
 8006e3a:	9b04      	ldr	r3, [sp, #16]
 8006e3c:	00b1      	lsls	r1, r6, #2
 8006e3e:	1859      	adds	r1, r3, r1
 8006e40:	4632      	mov	r2, r6
 8006e42:	a83e      	add	r0, sp, #248	; 0xf8
 8006e44:	f7fe fbd9 	bl	80055fa <uECC_vli_set>
    uECC_vli_modSub(z, sum, tx, curve->p, num_words); /* z = x2 - x1 */
 8006e48:	1d2b      	adds	r3, r5, #4
 8006e4a:	4641      	mov	r1, r8
 8006e4c:	aa36      	add	r2, sp, #216	; 0xd8
 8006e4e:	4620      	mov	r0, r4
 8006e50:	9306      	str	r3, [sp, #24]
 8006e52:	f7ff f81b 	bl	8005e8c <uECC_vli_modSub.isra.2>
    XYcZ_add(tx, ty, sum, sum + num_words, curve);
 8006e56:	465b      	mov	r3, fp
 8006e58:	4642      	mov	r2, r8
 8006e5a:	a93e      	add	r1, sp, #248	; 0xf8
 8006e5c:	a836      	add	r0, sp, #216	; 0xd8
 8006e5e:	9500      	str	r5, [sp, #0]
 8006e60:	f7ff f8f3 	bl	800604a <XYcZ_add>
    uECC_vli_modInv(z, z, curve->p, num_words); /* z = 1/z */
 8006e64:	4633      	mov	r3, r6
 8006e66:	1d2a      	adds	r2, r5, #4
 8006e68:	4621      	mov	r1, r4
 8006e6a:	4620      	mov	r0, r4
 8006e6c:	f7ff f9ee 	bl	800624c <uECC_vli_modInv>
    apply_z(sum, sum + num_words, z, curve);
 8006e70:	4622      	mov	r2, r4
 8006e72:	4659      	mov	r1, fp
 8006e74:	4640      	mov	r0, r8
 8006e76:	462b      	mov	r3, r5
 8006e78:	f7fe fcae 	bl	80057d8 <apply_z>
    
    /* Use Shamir's trick to calculate u1*G + u2*Q */
    points[0] = 0;
 8006e7c:	9b02      	ldr	r3, [sp, #8]
 8006e7e:	930a      	str	r3, [sp, #40]	; 0x28
    points[1] = curve->G;
 8006e80:	9b04      	ldr	r3, [sp, #16]
 8006e82:	930b      	str	r3, [sp, #44]	; 0x2c
    points[2] = public;
    points[3] = sum;
    num_bits = smax(uECC_vli_numBits(u1, num_n_words),
 8006e84:	4649      	mov	r1, r9
    apply_z(sum, sum + num_words, z, curve);
    
    /* Use Shamir's trick to calculate u1*G + u2*Q */
    points[0] = 0;
    points[1] = curve->G;
    points[2] = public;
 8006e86:	ab5e      	add	r3, sp, #376	; 0x178
    points[3] = sum;
    num_bits = smax(uECC_vli_numBits(u1, num_n_words),
 8006e88:	4638      	mov	r0, r7
    apply_z(sum, sum + num_words, z, curve);
    
    /* Use Shamir's trick to calculate u1*G + u2*Q */
    points[0] = 0;
    points[1] = curve->G;
    points[2] = public;
 8006e8a:	930c      	str	r3, [sp, #48]	; 0x30
    points[3] = sum;
 8006e8c:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
    num_bits = smax(uECC_vli_numBits(u1, num_n_words),
 8006e90:	f7fe fb91 	bl	80055b6 <uECC_vli_numBits>
 8006e94:	4649      	mov	r1, r9
 8006e96:	4680      	mov	r8, r0
 8006e98:	a816      	add	r0, sp, #88	; 0x58
 8006e9a:	f7fe fb8c 	bl	80055b6 <uECC_vli_numBits>
                    uECC_vli_numBits(u2, num_n_words));
    
    point = points[(!!uECC_vli_testBit(u1, num_bits - 1)) |
 8006e9e:	4540      	cmp	r0, r8
 8006ea0:	bfb8      	it	lt
 8006ea2:	4640      	movlt	r0, r8
 8006ea4:	fa1f f880 	uxth.w	r8, r0
 8006ea8:	f108 39ff 	add.w	r9, r8, #4294967295	; 0xffffffff
 8006eac:	fa0f f989 	sxth.w	r9, r9
 8006eb0:	4649      	mov	r1, r9
 8006eb2:	4638      	mov	r0, r7
 8006eb4:	f7fe fb75 	bl	80055a2 <uECC_vli_testBit>
                   ((!!uECC_vli_testBit(u2, num_bits - 1)) << 1)];
 8006eb8:	4649      	mov	r1, r9
    points[2] = public;
    points[3] = sum;
    num_bits = smax(uECC_vli_numBits(u1, num_n_words),
                    uECC_vli_numBits(u2, num_n_words));
    
    point = points[(!!uECC_vli_testBit(u1, num_bits - 1)) |
 8006eba:	1c07      	adds	r7, r0, #0
                   ((!!uECC_vli_testBit(u2, num_bits - 1)) << 1)];
 8006ebc:	a816      	add	r0, sp, #88	; 0x58
    points[2] = public;
    points[3] = sum;
    num_bits = smax(uECC_vli_numBits(u1, num_n_words),
                    uECC_vli_numBits(u2, num_n_words));
    
    point = points[(!!uECC_vli_testBit(u1, num_bits - 1)) |
 8006ebe:	bf18      	it	ne
 8006ec0:	2701      	movne	r7, #1
                   ((!!uECC_vli_testBit(u2, num_bits - 1)) << 1)];
 8006ec2:	f7fe fb6e 	bl	80055a2 <uECC_vli_testBit>
 8006ec6:	2800      	cmp	r0, #0
 8006ec8:	bf14      	ite	ne
 8006eca:	2302      	movne	r3, #2
 8006ecc:	2300      	moveq	r3, #0
    points[2] = public;
    points[3] = sum;
    num_bits = smax(uECC_vli_numBits(u1, num_n_words),
                    uECC_vli_numBits(u2, num_n_words));
    
    point = points[(!!uECC_vli_testBit(u1, num_bits - 1)) |
 8006ece:	431f      	orrs	r7, r3
    XYcZ_add(tx, ty, sum, sum + num_words, curve);
    uECC_vli_modInv(z, z, curve->p, num_words); /* z = 1/z */
    apply_z(sum, sum + num_words, z, curve);
    
    /* Use Shamir's trick to calculate u1*G + u2*Q */
    points[0] = 0;
 8006ed0:	f10d 0b28 	add.w	fp, sp, #40	; 0x28
    num_bits = smax(uECC_vli_numBits(u1, num_n_words),
                    uECC_vli_numBits(u2, num_n_words));
    
    point = points[(!!uECC_vli_testBit(u1, num_bits - 1)) |
                   ((!!uECC_vli_testBit(u2, num_bits - 1)) << 1)];
    uECC_vli_set(rx, point, num_words);
 8006ed4:	4632      	mov	r2, r6
    points[2] = public;
    points[3] = sum;
    num_bits = smax(uECC_vli_numBits(u1, num_n_words),
                    uECC_vli_numBits(u2, num_n_words));
    
    point = points[(!!uECC_vli_testBit(u1, num_bits - 1)) |
 8006ed6:	f85b 7027 	ldr.w	r7, [fp, r7, lsl #2]
                   ((!!uECC_vli_testBit(u2, num_bits - 1)) << 1)];
    uECC_vli_set(rx, point, num_words);
 8006eda:	a826      	add	r0, sp, #152	; 0x98
 8006edc:	4639      	mov	r1, r7
 8006ede:	f7fe fb8c 	bl	80055fa <uECC_vli_set>
    uECC_vli_set(ry, point + num_words, num_words);
 8006ee2:	f10d 09b8 	add.w	r9, sp, #184	; 0xb8
 8006ee6:	00b3      	lsls	r3, r6, #2
 8006ee8:	18f9      	adds	r1, r7, r3
 8006eea:	4632      	mov	r2, r6
 8006eec:	4648      	mov	r0, r9
 8006eee:	f7fe fb84 	bl	80055fa <uECC_vli_set>
    uECC_vli_clear(z, num_words);
 8006ef2:	4631      	mov	r1, r6
 8006ef4:	4620      	mov	r0, r4
 8006ef6:	f7fe fb39 	bl	800556c <uECC_vli_clear>
    z[0] = 1;

    for (i = num_bits - 2; i >= 0; --i) {
 8006efa:	f1a8 0702 	sub.w	r7, r8, #2
    point = points[(!!uECC_vli_testBit(u1, num_bits - 1)) |
                   ((!!uECC_vli_testBit(u2, num_bits - 1)) << 1)];
    uECC_vli_set(rx, point, num_words);
    uECC_vli_set(ry, point + num_words, num_words);
    uECC_vli_clear(z, num_words);
    z[0] = 1;
 8006efe:	9b07      	ldr	r3, [sp, #28]
 8006f00:	6023      	str	r3, [r4, #0]

    for (i = num_bits - 2; i >= 0; --i) {
 8006f02:	b2bf      	uxth	r7, r7
 8006f04:	f10d 0898 	add.w	r8, sp, #152	; 0x98
 8006f08:	fa0f fb87 	sxth.w	fp, r7
 8006f0c:	f1bb 0f00 	cmp.w	fp, #0
 8006f10:	db46      	blt.n	8006fa0 <uECC_verify+0x2a0>
        uECC_word_t index;
        curve->double_jacobian(rx, ry, z, curve);
 8006f12:	462b      	mov	r3, r5
 8006f14:	4622      	mov	r2, r4
 8006f16:	f8d5 60a4 	ldr.w	r6, [r5, #164]	; 0xa4
 8006f1a:	4649      	mov	r1, r9
 8006f1c:	4640      	mov	r0, r8
 8006f1e:	47b0      	blx	r6
        
        index = (!!uECC_vli_testBit(u1, i)) | ((!!uECC_vli_testBit(u2, i)) << 1);
 8006f20:	4659      	mov	r1, fp
 8006f22:	a80e      	add	r0, sp, #56	; 0x38
 8006f24:	f7fe fb3d 	bl	80055a2 <uECC_vli_testBit>
 8006f28:	4659      	mov	r1, fp
 8006f2a:	1c06      	adds	r6, r0, #0
 8006f2c:	a816      	add	r0, sp, #88	; 0x58
 8006f2e:	bf18      	it	ne
 8006f30:	2601      	movne	r6, #1
 8006f32:	f7fe fb36 	bl	80055a2 <uECC_vli_testBit>
 8006f36:	2800      	cmp	r0, #0
 8006f38:	bf14      	ite	ne
 8006f3a:	2302      	movne	r3, #2
 8006f3c:	2300      	moveq	r3, #0
        point = points[index];
 8006f3e:	431e      	orrs	r6, r3
 8006f40:	ab0a      	add	r3, sp, #40	; 0x28
 8006f42:	f853 b026 	ldr.w	fp, [r3, r6, lsl #2]
        if (point) {
 8006f46:	f1bb 0f00 	cmp.w	fp, #0
 8006f4a:	d026      	beq.n	8006f9a <uECC_verify+0x29a>
            uECC_vli_set(tx, point, num_words);
 8006f4c:	f99d 600c 	ldrsb.w	r6, [sp, #12]
 8006f50:	4659      	mov	r1, fp
 8006f52:	4632      	mov	r2, r6
 8006f54:	a836      	add	r0, sp, #216	; 0xd8
 8006f56:	f7fe fb50 	bl	80055fa <uECC_vli_set>
            uECC_vli_set(ty, point + num_words, num_words);
 8006f5a:	9b08      	ldr	r3, [sp, #32]
 8006f5c:	4632      	mov	r2, r6
 8006f5e:	eb0b 0103 	add.w	r1, fp, r3
 8006f62:	a83e      	add	r0, sp, #248	; 0xf8
 8006f64:	f7fe fb49 	bl	80055fa <uECC_vli_set>
            apply_z(tx, ty, z, curve);
 8006f68:	462b      	mov	r3, r5
 8006f6a:	4622      	mov	r2, r4
 8006f6c:	a93e      	add	r1, sp, #248	; 0xf8
 8006f6e:	a836      	add	r0, sp, #216	; 0xd8
 8006f70:	f7fe fc32 	bl	80057d8 <apply_z>
            uECC_vli_modSub(tz, rx, tx, curve->p, num_words); /* Z = x2 - x1 */
 8006f74:	9b06      	ldr	r3, [sp, #24]
 8006f76:	aa36      	add	r2, sp, #216	; 0xd8
 8006f78:	4641      	mov	r1, r8
 8006f7a:	a846      	add	r0, sp, #280	; 0x118
 8006f7c:	f7fe ff86 	bl	8005e8c <uECC_vli_modSub.isra.2>
            XYcZ_add(tx, ty, rx, ry, curve);
 8006f80:	464b      	mov	r3, r9
 8006f82:	4642      	mov	r2, r8
 8006f84:	a93e      	add	r1, sp, #248	; 0xf8
 8006f86:	a836      	add	r0, sp, #216	; 0xd8
 8006f88:	9500      	str	r5, [sp, #0]
 8006f8a:	f7ff f85e 	bl	800604a <XYcZ_add>
            uECC_vli_modMult_fast(z, z, tz, curve);
 8006f8e:	462b      	mov	r3, r5
 8006f90:	aa46      	add	r2, sp, #280	; 0x118
 8006f92:	4621      	mov	r1, r4
 8006f94:	4620      	mov	r0, r4
 8006f96:	f7fe fc0b 	bl	80057b0 <uECC_vli_modMult_fast>
 8006f9a:	3f01      	subs	r7, #1
 8006f9c:	b2bf      	uxth	r7, r7
 8006f9e:	e7b3      	b.n	8006f08 <uECC_verify+0x208>
        }
    }

    uECC_vli_modInv(z, z, curve->p, num_words); /* Z = 1/Z */
 8006fa0:	f99d 300c 	ldrsb.w	r3, [sp, #12]
 8006fa4:	9a06      	ldr	r2, [sp, #24]
 8006fa6:	4621      	mov	r1, r4
 8006fa8:	4620      	mov	r0, r4
 8006faa:	f7ff f94f 	bl	800624c <uECC_vli_modInv>
    apply_z(rx, ry, z, curve);
 8006fae:	462b      	mov	r3, r5
 8006fb0:	4622      	mov	r2, r4
 8006fb2:	4649      	mov	r1, r9
 8006fb4:	4640      	mov	r0, r8
 8006fb6:	f7fe fc0f 	bl	80057d8 <apply_z>
    
    /* v = x1 (mod n) */
    if (uECC_vli_cmp_unsafe(curve->n, rx, num_n_words) != 1) {
 8006fba:	f99d 2014 	ldrsb.w	r2, [sp, #20]
 8006fbe:	4641      	mov	r1, r8
 8006fc0:	4650      	mov	r0, sl
 8006fc2:	f7fe fb27 	bl	8005614 <uECC_vli_cmp_unsafe>
 8006fc6:	2801      	cmp	r0, #1
 8006fc8:	d004      	beq.n	8006fd4 <uECC_verify+0x2d4>
        uECC_vli_sub(rx, rx, curve->n, num_n_words);
 8006fca:	4652      	mov	r2, sl
 8006fcc:	4641      	mov	r1, r8
 8006fce:	4640      	mov	r0, r8
 8006fd0:	f7fe fd67 	bl	8005aa2 <uECC_vli_sub.isra.1>
uECC_VLI_API uECC_word_t uECC_vli_equal(const uECC_word_t *left,
                                        const uECC_word_t *right,
                                        wordcount_t num_words) {
    uECC_word_t diff = 0;
    wordcount_t i;
    for (i = num_words - 1; i >= 0; --i) {
 8006fd4:	9b03      	ldr	r3, [sp, #12]
 8006fd6:	3b01      	subs	r3, #1
 8006fd8:	b2db      	uxtb	r3, r3
/* Constant-time comparison function - secure way to compare long integers */
/* Returns one if left == right, zero otherwise. */
uECC_VLI_API uECC_word_t uECC_vli_equal(const uECC_word_t *left,
                                        const uECC_word_t *right,
                                        wordcount_t num_words) {
    uECC_word_t diff = 0;
 8006fda:	2000      	movs	r0, #0
    wordcount_t i;
    for (i = num_words - 1; i >= 0; --i) {
 8006fdc:	b25a      	sxtb	r2, r3
 8006fde:	2a00      	cmp	r2, #0
 8006fe0:	db0c      	blt.n	8006ffc <uECC_verify+0x2fc>
        diff |= (left[i] ^ right[i]);
 8006fe2:	b212      	sxth	r2, r2
 8006fe4:	a97e      	add	r1, sp, #504	; 0x1f8
 8006fe6:	eb01 0482 	add.w	r4, r1, r2, lsl #2
 8006fea:	f858 1022 	ldr.w	r1, [r8, r2, lsl #2]
 8006fee:	f854 2cc0 	ldr.w	r2, [r4, #-192]
 8006ff2:	3b01      	subs	r3, #1
 8006ff4:	404a      	eors	r2, r1
 8006ff6:	4310      	orrs	r0, r2
 8006ff8:	b2db      	uxtb	r3, r3
 8006ffa:	e7ef      	b.n	8006fdc <uECC_verify+0x2dc>
    if (uECC_vli_cmp_unsafe(curve->n, rx, num_n_words) != 1) {
        uECC_vli_sub(rx, rx, curve->n, num_n_words);
    }

    /* Accept only if v == r. */
    return (int)(uECC_vli_equal(rx, r, num_words));
 8006ffc:	fab0 f080 	clz	r0, r0
 8007000:	0940      	lsrs	r0, r0, #5
 8007002:	e004      	b.n	800700e <uECC_verify+0x30e>
    uECC_vli_bytesToNative(r, signature, curve->num_bytes);
    uECC_vli_bytesToNative(s, signature + curve->num_bytes, curve->num_bytes);
    
    /* r, s must not be 0. */
    if (uECC_vli_isZero(r, num_words) || uECC_vli_isZero(s, num_words)) {
        return 0;
 8007004:	4658      	mov	r0, fp
 8007006:	e002      	b.n	800700e <uECC_verify+0x30e>
 8007008:	4620      	mov	r0, r4
 800700a:	e000      	b.n	800700e <uECC_verify+0x30e>
 800700c:	9802      	ldr	r0, [sp, #8]
        uECC_vli_sub(rx, rx, curve->n, num_n_words);
    }

    /* Accept only if v == r. */
    return (int)(uECC_vli_equal(rx, r, num_words));
}
 800700e:	b07f      	add	sp, #508	; 0x1fc
 8007010:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08007014 <HAL_GetTick>:
const uint32_t MSIRangeTable[12] = {100000, 200000, 400000, 800000, 1000000, 2000000, \
                                  4000000, 8000000, 16000000, 24000000, 32000000, 48000000};
uint32_t SystemCoreClock;

// TODO: cleanup HAL stuff to not use this
uint32_t HAL_GetTick(void) { return 53; }
 8007014:	2035      	movs	r0, #53	; 0x35
 8007016:	4770      	bx	lr

08007018 <HAL_InitTick>:
uint32_t uwTickPrio = 0;            /* (1UL << __NVIC_PRIO_BITS); * Invalid priority */

// unwanted junk from stm32l4xx_hal_rcc.c
HAL_StatusTypeDef HAL_InitTick (uint32_t TickPriority) { return 0; }
 8007018:	2000      	movs	r0, #0
 800701a:	4770      	bx	lr

0800701c <HAL_PWREx_GetVoltageRange>:
  *         or PWR_REGULATOR_VOLTAGE_SCALE1_BOOST when applicable)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
#if defined(PWR_CR5_R1MODE)
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 800701c:	4b07      	ldr	r3, [pc, #28]	; (800703c <HAL_PWREx_GetVoltageRange+0x20>)
 800701e:	6818      	ldr	r0, [r3, #0]
 8007020:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 8007024:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 8007028:	d006      	beq.n	8007038 <HAL_PWREx_GetVoltageRange+0x1c>
    {
      return PWR_REGULATOR_VOLTAGE_SCALE2;
    }
    else if (READ_BIT(PWR->CR5, PWR_CR5_R1MODE) == PWR_CR5_R1MODE)
 800702a:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
    {
      /* PWR_CR5_R1MODE bit set means that Range 1 Boost is disabled */
      return PWR_REGULATOR_VOLTAGE_SCALE1;
 800702e:	f410 7080 	ands.w	r0, r0, #256	; 0x100
 8007032:	bf18      	it	ne
 8007034:	f44f 7000 	movne.w	r0, #512	; 0x200
      return PWR_REGULATOR_VOLTAGE_SCALE1_BOOST;
    }
#else
  return  (PWR->CR1 & PWR_CR1_VOS);
#endif
}
 8007038:	4770      	bx	lr
 800703a:	bf00      	nop
 800703c:	40007000 	.word	0x40007000

08007040 <HAL_PWREx_ControlVoltageScaling>:
  *        50 microseconds, HAL_TIMEOUT status is reported.
  * @retval HAL Status
  */
#define PWR_FLAG_SETTING_DELAY_US                      50UL   /*!< Time out value for REGLPF and VOSF flags setting */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
{
 8007040:	4b29      	ldr	r3, [pc, #164]	; (80070e8 <HAL_PWREx_ControlVoltageScaling+0xa8>)

#if defined(PWR_CR5_R1MODE)
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8007042:	681a      	ldr	r2, [r3, #0]
  uint32_t wait_loop_index;

  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));

#if defined(PWR_CR5_R1MODE)
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
 8007044:	b9f0      	cbnz	r0, 8007084 <HAL_PWREx_ControlVoltageScaling+0x44>
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8007046:	f402 62c0 	and.w	r2, r2, #1536	; 0x600
 800704a:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
    {
      /* Make sure Range 1 Boost is enabled */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 800704e:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8007052:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8007056:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

#if defined(PWR_CR5_R1MODE)
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 800705a:	d138      	bne.n	80070ce <HAL_PWREx_ControlVoltageScaling+0x8e>
    {
      /* Make sure Range 1 Boost is enabled */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);

      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 800705c:	681a      	ldr	r2, [r3, #0]
 800705e:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 8007062:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8007066:	601a      	str	r2, [r3, #0]

      /* Wait until VOSF is cleared */
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
 8007068:	4a20      	ldr	r2, [pc, #128]	; (80070ec <HAL_PWREx_ControlVoltageScaling+0xac>)
 800706a:	6811      	ldr	r1, [r2, #0]
 800706c:	2232      	movs	r2, #50	; 0x32
 800706e:	434a      	muls	r2, r1
 8007070:	491f      	ldr	r1, [pc, #124]	; (80070f0 <HAL_PWREx_ControlVoltageScaling+0xb0>)
 8007072:	fbb2 f2f1 	udiv	r2, r2, r1
 8007076:	3201      	adds	r2, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8007078:	6959      	ldr	r1, [r3, #20]
 800707a:	0549      	lsls	r1, r1, #21
 800707c:	d521      	bpl.n	80070c2 <HAL_PWREx_ControlVoltageScaling+0x82>
 800707e:	b302      	cbz	r2, 80070c2 <HAL_PWREx_ControlVoltageScaling+0x82>
      {
        wait_loop_index--;
 8007080:	3a01      	subs	r2, #1
 8007082:	e7f9      	b.n	8007078 <HAL_PWREx_ControlVoltageScaling+0x38>
    {
      /* Enable Range 1 Boost (no issue if bit already reset) */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
    }
  }
  else if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 8007084:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8007088:	d126      	bne.n	80070d8 <HAL_PWREx_ControlVoltageScaling+0x98>
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 800708a:	f402 62c0 	and.w	r2, r2, #1536	; 0x600
 800708e:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
    {
      /* Make sure Range 1 Boost is disabled */
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8007092:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8007096:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800709a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    }
  }
  else if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 800709e:	d120      	bne.n	80070e2 <HAL_PWREx_ControlVoltageScaling+0xa2>
    {
      /* Make sure Range 1 Boost is disabled */
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);

      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 80070a0:	681a      	ldr	r2, [r3, #0]
 80070a2:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 80070a6:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80070aa:	601a      	str	r2, [r3, #0]

      /* Wait until VOSF is cleared */
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
 80070ac:	4a0f      	ldr	r2, [pc, #60]	; (80070ec <HAL_PWREx_ControlVoltageScaling+0xac>)
 80070ae:	6811      	ldr	r1, [r2, #0]
 80070b0:	2232      	movs	r2, #50	; 0x32
 80070b2:	434a      	muls	r2, r1
 80070b4:	490e      	ldr	r1, [pc, #56]	; (80070f0 <HAL_PWREx_ControlVoltageScaling+0xb0>)
 80070b6:	fbb2 f2f1 	udiv	r2, r2, r1
 80070ba:	3201      	adds	r2, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80070bc:	6959      	ldr	r1, [r3, #20]
 80070be:	0549      	lsls	r1, r1, #21
 80070c0:	d406      	bmi.n	80070d0 <HAL_PWREx_ControlVoltageScaling+0x90>
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
      {
        wait_loop_index--;
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 80070c2:	4b09      	ldr	r3, [pc, #36]	; (80070e8 <HAL_PWREx_ControlVoltageScaling+0xa8>)
 80070c4:	695b      	ldr	r3, [r3, #20]
 80070c6:	0558      	lsls	r0, r3, #21
 80070c8:	d50b      	bpl.n	80070e2 <HAL_PWREx_ControlVoltageScaling+0xa2>
      {
        return HAL_TIMEOUT;
 80070ca:	2003      	movs	r0, #3
 80070cc:	4770      	bx	lr
 80070ce:	4770      	bx	lr
      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);

      /* Wait until VOSF is cleared */
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80070d0:	2a00      	cmp	r2, #0
 80070d2:	d0f6      	beq.n	80070c2 <HAL_PWREx_ControlVoltageScaling+0x82>
      {
        wait_loop_index--;
 80070d4:	3a01      	subs	r2, #1
 80070d6:	e7f1      	b.n	80070bc <HAL_PWREx_ControlVoltageScaling+0x7c>
    }
  }
  else
  {
    /* Set Range 2 */
    MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 80070d8:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 80070dc:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80070e0:	601a      	str	r2, [r3, #0]
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
#endif

  return HAL_OK;
 80070e2:	2000      	movs	r0, #0
}
 80070e4:	4770      	bx	lr
 80070e6:	bf00      	nop
 80070e8:	40007000 	.word	0x40007000
 80070ec:	20000448 	.word	0x20000448
 80070f0:	000f4240 	.word	0x000f4240

080070f4 <HAL_SDEx_DriveTransceiver_1_8V_Callback>:

__weak void HAL_SDEx_DriveTransceiver_1_8V_Callback(FlagStatus status)
{
 80070f4:	4770      	bx	lr
	...

080070f8 <se2_write1>:

// se2_write1()
//
    static bool
se2_write1(uint8_t cmd, uint8_t arg)
{
 80070f8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    uint8_t data[3] = { cmd, 1, arg };
 80070fa:	2301      	movs	r3, #1
 80070fc:	f88d 300d 	strb.w	r3, [sp, #13]

    HAL_StatusTypeDef rv = HAL_I2C_Master_Transmit(&i2c_port, I2C_ADDR, 
 8007100:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
// se2_write1()
//
    static bool
se2_write1(uint8_t cmd, uint8_t arg)
{
    uint8_t data[3] = { cmd, 1, arg };
 8007104:	f88d 000c 	strb.w	r0, [sp, #12]
 8007108:	f88d 100e 	strb.w	r1, [sp, #14]

    HAL_StatusTypeDef rv = HAL_I2C_Master_Transmit(&i2c_port, I2C_ADDR, 
 800710c:	9300      	str	r3, [sp, #0]
 800710e:	aa03      	add	r2, sp, #12
 8007110:	2303      	movs	r3, #3
 8007112:	2136      	movs	r1, #54	; 0x36
 8007114:	4804      	ldr	r0, [pc, #16]	; (8007128 <se2_write1+0x30>)
 8007116:	f004 fb33 	bl	800b780 <HAL_I2C_Master_Transmit>
                                                    data, sizeof(data), HAL_MAX_DELAY);

    return (rv != HAL_OK);
}
 800711a:	3000      	adds	r0, #0
 800711c:	bf18      	it	ne
 800711e:	2001      	movne	r0, #1
 8007120:	b005      	add	sp, #20
 8007122:	f85d fb04 	ldr.w	pc, [sp], #4
 8007126:	bf00      	nop
 8007128:	2000023c 	.word	0x2000023c

0800712c <se2_write_n>:

// se2_write_n()
//
    static bool
se2_write_n(uint8_t cmd, uint8_t *param1, const uint8_t *data_in, uint8_t len)
{
 800712c:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint8_t data[2 + (param1?1:0) + len], *p = data;
 800712e:	2900      	cmp	r1, #0
 8007130:	bf14      	ite	ne
 8007132:	2403      	movne	r4, #3
 8007134:	2402      	moveq	r4, #2
 8007136:	441c      	add	r4, r3

// se2_write_n()
//
    static bool
se2_write_n(uint8_t cmd, uint8_t *param1, const uint8_t *data_in, uint8_t len)
{
 8007138:	4616      	mov	r6, r2
 800713a:	461a      	mov	r2, r3
    uint8_t data[2 + (param1?1:0) + len], *p = data;
 800713c:	f104 0307 	add.w	r3, r4, #7

// se2_write_n()
//
    static bool
se2_write_n(uint8_t cmd, uint8_t *param1, const uint8_t *data_in, uint8_t len)
{
 8007140:	b083      	sub	sp, #12
    uint8_t data[2 + (param1?1:0) + len], *p = data;
 8007142:	f023 0307 	bic.w	r3, r3, #7

// se2_write_n()
//
    static bool
se2_write_n(uint8_t cmd, uint8_t *param1, const uint8_t *data_in, uint8_t len)
{
 8007146:	af02      	add	r7, sp, #8
    uint8_t data[2 + (param1?1:0) + len], *p = data;
 8007148:	ebad 0d03 	sub.w	sp, sp, r3
 800714c:	ad02      	add	r5, sp, #8

    *(p++) = cmd;
    *(p++) = sizeof(data) - 2;
 800714e:	f1a4 0302 	sub.w	r3, r4, #2
    static bool
se2_write_n(uint8_t cmd, uint8_t *param1, const uint8_t *data_in, uint8_t len)
{
    uint8_t data[2 + (param1?1:0) + len], *p = data;

    *(p++) = cmd;
 8007152:	f88d 0008 	strb.w	r0, [sp, #8]
    *(p++) = sizeof(data) - 2;
 8007156:	706b      	strb	r3, [r5, #1]
    if(param1) {
        *(p++) = *param1;
 8007158:	bf1b      	ittet	ne
 800715a:	780b      	ldrbne	r3, [r1, #0]
 800715c:	70ab      	strbne	r3, [r5, #2]
se2_write_n(uint8_t cmd, uint8_t *param1, const uint8_t *data_in, uint8_t len)
{
    uint8_t data[2 + (param1?1:0) + len], *p = data;

    *(p++) = cmd;
    *(p++) = sizeof(data) - 2;
 800715e:	f10d 000a 	addeq.w	r0, sp, #10
    if(param1) {
        *(p++) = *param1;
 8007162:	f10d 000b 	addne.w	r0, sp, #11
    }
    if(len) {
 8007166:	b112      	cbz	r2, 800716e <se2_write_n+0x42>
        memcpy(p, data_in, len);
 8007168:	4631      	mov	r1, r6
 800716a:	f006 f98a 	bl	800d482 <memcpy>
    }

    HAL_StatusTypeDef rv = HAL_I2C_Master_Transmit(&i2c_port, I2C_ADDR,
 800716e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8007172:	9300      	str	r3, [sp, #0]
 8007174:	462a      	mov	r2, r5
 8007176:	b2a3      	uxth	r3, r4
 8007178:	2136      	movs	r1, #54	; 0x36
 800717a:	4804      	ldr	r0, [pc, #16]	; (800718c <se2_write_n+0x60>)
 800717c:	f004 fb00 	bl	800b780 <HAL_I2C_Master_Transmit>
                                                    data, sizeof(data), HAL_MAX_DELAY);

    return (rv != HAL_OK);
}
 8007180:	3000      	adds	r0, #0
 8007182:	bf18      	it	ne
 8007184:	2001      	movne	r0, #1
 8007186:	3704      	adds	r7, #4
 8007188:	46bd      	mov	sp, r7
 800718a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800718c:	2000023c 	.word	0x2000023c

08007190 <se2_read_n>:
se2_read_n(uint8_t len, uint8_t *rx)
{
    // Response time of the chip varies from 0ms (read buffer), is typically
    // 3ms for simple things, and peaks at 200ms for complex ECC stuff.
    // Poll until chip provides an answer.
    ASSERT(len >= 2);
 8007190:	2801      	cmp	r0, #1

// se2_read_n()
//
    static uint8_t
se2_read_n(uint8_t len, uint8_t *rx)
{
 8007192:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8007196:	4604      	mov	r4, r0
 8007198:	460e      	mov	r6, r1
    // Response time of the chip varies from 0ms (read buffer), is typically
    // 3ms for simple things, and peaks at 200ms for complex ECC stuff.
    // Poll until chip provides an answer.
    ASSERT(len >= 2);
 800719a:	d802      	bhi.n	80071a2 <se2_read_n+0x12>
 800719c:	4810      	ldr	r0, [pc, #64]	; (80071e0 <se2_read_n+0x50>)
 800719e:	f7f9 fc1d 	bl	80009dc <fatal_error>
 80071a2:	f44f 7596 	mov.w	r5, #300	; 0x12c

    for(int tries=0; tries<300; tries++) {
        HAL_StatusTypeDef rv = HAL_I2C_Master_Receive(&i2c_port, I2C_ADDR, rx, len, HAL_MAX_DELAY);
 80071a6:	b287      	uxth	r7, r0
 80071a8:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
 80071ac:	f8cd 8000 	str.w	r8, [sp]
 80071b0:	463b      	mov	r3, r7
 80071b2:	4632      	mov	r2, r6
 80071b4:	2136      	movs	r1, #54	; 0x36
 80071b6:	480b      	ldr	r0, [pc, #44]	; (80071e4 <se2_read_n+0x54>)
 80071b8:	f004 fb92 	bl	800b8e0 <HAL_I2C_Master_Receive>
        if(rv == HAL_OK) {
 80071bc:	b928      	cbnz	r0, 80071ca <se2_read_n+0x3a>
            if(rx[0] != len-1) {
 80071be:	7833      	ldrb	r3, [r6, #0]
 80071c0:	3c01      	subs	r4, #1
 80071c2:	42a3      	cmp	r3, r4
 80071c4:	d108      	bne.n	80071d8 <se2_read_n+0x48>
                return RC_WRONG_SIZE;
            }

            return rx[1];
 80071c6:	7870      	ldrb	r0, [r6, #1]
 80071c8:	e007      	b.n	80071da <se2_read_n+0x4a>
        }

        delay_ms(1);
 80071ca:	2001      	movs	r0, #1
 80071cc:	f7fc fb60 	bl	8003890 <delay_ms>
    // Response time of the chip varies from 0ms (read buffer), is typically
    // 3ms for simple things, and peaks at 200ms for complex ECC stuff.
    // Poll until chip provides an answer.
    ASSERT(len >= 2);

    for(int tries=0; tries<300; tries++) {
 80071d0:	3d01      	subs	r5, #1
 80071d2:	d1eb      	bne.n	80071ac <se2_read_n+0x1c>

        delay_ms(1);
    }

    // timeout
    return RC_NO_ACK;
 80071d4:	200f      	movs	r0, #15
 80071d6:	e000      	b.n	80071da <se2_read_n+0x4a>

    for(int tries=0; tries<300; tries++) {
        HAL_StatusTypeDef rv = HAL_I2C_Master_Receive(&i2c_port, I2C_ADDR, rx, len, HAL_MAX_DELAY);
        if(rv == HAL_OK) {
            if(rx[0] != len-1) {
                return RC_WRONG_SIZE;
 80071d8:	201f      	movs	r0, #31
        delay_ms(1);
    }

    // timeout
    return RC_NO_ACK;
}
 80071da:	b002      	add	sp, #8
 80071dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80071e0:	0800d558 	.word	0x0800d558
 80071e4:	2000023c 	.word	0x2000023c

080071e8 <se2_read1>:

// se2_read1()
//
    static uint8_t
se2_read1(void)
{
 80071e8:	b507      	push	{r0, r1, r2, lr}
    // many commands return a single (framed) status byte, where 0xAA == success
    uint8_t rx[2];

    return se2_read_n(2, rx);
 80071ea:	2002      	movs	r0, #2
 80071ec:	a901      	add	r1, sp, #4
 80071ee:	f7ff ffcf 	bl	8007190 <se2_read_n>
}
 80071f2:	b003      	add	sp, #12
 80071f4:	f85d fb04 	ldr.w	pc, [sp], #4

080071f8 <rng_for_uECC>:

// rng_for_uECC()
//
    static int
rng_for_uECC(uint8_t *dest, unsigned size)
{
 80071f8:	b508      	push	{r3, lr}
    'dest' was filled with random data, or 0 if the random data could not be generated.
    The filled-in values should be either truly random, or from a cryptographically-secure PRNG.

    typedef int (*uECC_RNG_Function)(uint8_t *dest, unsigned size);
    */
    rng_buffer(dest, size);
 80071fa:	f7fb fa89 	bl	8002710 <rng_buffer>

    return 1;
}
 80071fe:	2001      	movs	r0, #1
 8007200:	bd08      	pop	{r3, pc}
	...

08007204 <se2_write_buffer>:

// se2_write_buffer()
//
    static void
se2_write_buffer(const uint8_t *data, int len)
{
 8007204:	b508      	push	{r3, lr}
    // no response to this command, just blindly write it
    CALL_CHECK(se2_write_n(0x87, NULL, data, len));
 8007206:	4602      	mov	r2, r0
 8007208:	b2cb      	uxtb	r3, r1
 800720a:	2087      	movs	r0, #135	; 0x87
 800720c:	2100      	movs	r1, #0
 800720e:	f7ff ff8d 	bl	800712c <se2_write_n>
 8007212:	b118      	cbz	r0, 800721c <se2_write_buffer+0x18>
 8007214:	21be      	movs	r1, #190	; 0xbe
 8007216:	4802      	ldr	r0, [pc, #8]	; (8007220 <se2_write_buffer+0x1c>)
 8007218:	f006 f968 	bl	800d4ec <longjmp>
 800721c:	bd08      	pop	{r3, pc}
 800721e:	bf00      	nop
 8007220:	20000288 	.word	0x20000288

08007224 <se2_write_page>:
//
// Caution: Can be read and/or intercepted.
//
    void
se2_write_page(uint8_t page_num, const uint8_t data[32])
{
 8007224:	b513      	push	{r0, r1, r4, lr}
 8007226:	ac02      	add	r4, sp, #8
    CALL_CHECK(se2_write_n(0x96, &page_num, data, 32));
 8007228:	460a      	mov	r2, r1
//
// Caution: Can be read and/or intercepted.
//
    void
se2_write_page(uint8_t page_num, const uint8_t data[32])
{
 800722a:	f804 0d01 	strb.w	r0, [r4, #-1]!
    CALL_CHECK(se2_write_n(0x96, &page_num, data, 32));
 800722e:	2320      	movs	r3, #32
 8007230:	4621      	mov	r1, r4
 8007232:	2096      	movs	r0, #150	; 0x96
 8007234:	f7ff ff7a 	bl	800712c <se2_write_n>
 8007238:	b108      	cbz	r0, 800723e <se2_write_page+0x1a>
 800723a:	21c8      	movs	r1, #200	; 0xc8
 800723c:	e004      	b.n	8007248 <se2_write_page+0x24>

    CHECK_RIGHT(se2_read1() == RC_SUCCESS);
 800723e:	f7ff ffd3 	bl	80071e8 <se2_read1>
 8007242:	28aa      	cmp	r0, #170	; 0xaa
 8007244:	d003      	beq.n	800724e <se2_write_page+0x2a>
 8007246:	21ca      	movs	r1, #202	; 0xca
 8007248:	4802      	ldr	r0, [pc, #8]	; (8007254 <se2_write_page+0x30>)
 800724a:	f006 f94f 	bl	800d4ec <longjmp>
}
 800724e:	b002      	add	sp, #8
 8007250:	bd10      	pop	{r4, pc}
 8007252:	bf00      	nop
 8007254:	20000288 	.word	0x20000288

08007258 <se2_pick_keypair>:
//
    void
se2_pick_keypair(uint8_t pubkey_num, bool lock)
{
    // use device RNG to pick a keypair
    ASSERT(pubkey_num < 2);
 8007258:	2801      	cmp	r0, #1

// se2_pick_keypair()
//
    void
se2_pick_keypair(uint8_t pubkey_num, bool lock)
{
 800725a:	b508      	push	{r3, lr}
    // use device RNG to pick a keypair
    ASSERT(pubkey_num < 2);
 800725c:	d902      	bls.n	8007264 <se2_pick_keypair+0xc>
 800725e:	480a      	ldr	r0, [pc, #40]	; (8007288 <se2_pick_keypair+0x30>)
 8007260:	f7f9 fbbc 	bl	80009dc <fatal_error>

    int wpe = lock ? 0x1 : 0x0;
    CALL_CHECK(se2_write1(0xcb, (wpe <<6) | pubkey_num));
 8007264:	ea40 1181 	orr.w	r1, r0, r1, lsl #6
 8007268:	b2c9      	uxtb	r1, r1
 800726a:	20cb      	movs	r0, #203	; 0xcb
 800726c:	f7ff ff44 	bl	80070f8 <se2_write1>
 8007270:	b108      	cbz	r0, 8007276 <se2_pick_keypair+0x1e>
 8007272:	21d6      	movs	r1, #214	; 0xd6
 8007274:	e004      	b.n	8007280 <se2_pick_keypair+0x28>

    CHECK_RIGHT(se2_read1() == RC_SUCCESS);
 8007276:	f7ff ffb7 	bl	80071e8 <se2_read1>
 800727a:	28aa      	cmp	r0, #170	; 0xaa
 800727c:	d003      	beq.n	8007286 <se2_pick_keypair+0x2e>
 800727e:	21d8      	movs	r1, #216	; 0xd8
 8007280:	4802      	ldr	r0, [pc, #8]	; (800728c <se2_pick_keypair+0x34>)
 8007282:	f006 f933 	bl	800d4ec <longjmp>
 8007286:	bd08      	pop	{r3, pc}
 8007288:	0800d558 	.word	0x0800d558
 800728c:	20000288 	.word	0x20000288

08007290 <se2_verify_page>:

// se2_verify_page()
//
    bool
se2_verify_page(uint8_t page_num, uint8_t data[32], int keynum, const uint8_t *secret)
{
 8007290:	b570      	push	{r4, r5, r6, lr}
 8007292:	b0dc      	sub	sp, #368	; 0x170
 8007294:	460d      	mov	r5, r1
 8007296:	f88d 0007 	strb.w	r0, [sp, #7]
    // "Compute and Read Page Authentication" using HMAC secret A or S

    // .. pick a nonce
    uint8_t chal[32];
    rng_buffer(chal, sizeof(chal));
 800729a:	2120      	movs	r1, #32
 800729c:	a802      	add	r0, sp, #8

// se2_verify_page()
//
    bool
se2_verify_page(uint8_t page_num, uint8_t data[32], int keynum, const uint8_t *secret)
{
 800729e:	4616      	mov	r6, r2
 80072a0:	461c      	mov	r4, r3
    // "Compute and Read Page Authentication" using HMAC secret A or S

    // .. pick a nonce
    uint8_t chal[32];
    rng_buffer(chal, sizeof(chal));
 80072a2:	f7fb fa35 	bl	8002710 <rng_buffer>
    se2_write_buffer(chal, sizeof(chal));
 80072a6:	2120      	movs	r1, #32
 80072a8:	a802      	add	r0, sp, #8
 80072aa:	f7ff ffab 	bl	8007204 <se2_write_buffer>
    
    // .. do it (HMAC method, not ECDSA)
    CALL_CHECK(se2_write1(0xa5, (keynum<<5) | page_num));
 80072ae:	f89d 1007 	ldrb.w	r1, [sp, #7]
 80072b2:	ea41 1146 	orr.w	r1, r1, r6, lsl #5
 80072b6:	b2c9      	uxtb	r1, r1
 80072b8:	20a5      	movs	r0, #165	; 0xa5
 80072ba:	f7ff ff1d 	bl	80070f8 <se2_write1>
 80072be:	b108      	cbz	r0, 80072c4 <se2_verify_page+0x34>
 80072c0:	21e8      	movs	r1, #232	; 0xe8
 80072c2:	e006      	b.n	80072d2 <se2_verify_page+0x42>

    uint8_t check[34];
    CHECK_RIGHT(se2_read_n(sizeof(check), check) == RC_SUCCESS);
 80072c4:	a912      	add	r1, sp, #72	; 0x48
 80072c6:	2022      	movs	r0, #34	; 0x22
 80072c8:	f7ff ff62 	bl	8007190 <se2_read_n>
 80072cc:	28aa      	cmp	r0, #170	; 0xaa
 80072ce:	d003      	beq.n	80072d8 <se2_verify_page+0x48>
 80072d0:	21eb      	movs	r1, #235	; 0xeb
 80072d2:	481b      	ldr	r0, [pc, #108]	; (8007340 <se2_verify_page+0xb0>)
 80072d4:	f006 f90a 	bl	800d4ec <longjmp>

    // .. see if we can arrive at same HMAC result.

    HMAC_CTX ctx;
    hmac_sha256_init(&ctx);
 80072d8:	a81b      	add	r0, sp, #108	; 0x6c
 80072da:	f7fe f8c7 	bl	800546c <hmac_sha256_init>

    //  msg = self.rom_id + expected + chal + bytes([page_num]) + self.manid
    hmac_sha256_update(&ctx, SE2_SECRETS->romid, 8);
 80072de:	4b19      	ldr	r3, [pc, #100]	; (8007344 <se2_verify_page+0xb4>)
 80072e0:	4a19      	ldr	r2, [pc, #100]	; (8007348 <se2_verify_page+0xb8>)
 80072e2:	f893 10b0 	ldrb.w	r1, [r3, #176]	; 0xb0
 80072e6:	4b19      	ldr	r3, [pc, #100]	; (800734c <se2_verify_page+0xbc>)
 80072e8:	29ff      	cmp	r1, #255	; 0xff
 80072ea:	bf0c      	ite	eq
 80072ec:	4619      	moveq	r1, r3
 80072ee:	4611      	movne	r1, r2
 80072f0:	a81b      	add	r0, sp, #108	; 0x6c
 80072f2:	2208      	movs	r2, #8
 80072f4:	3160      	adds	r1, #96	; 0x60
 80072f6:	f7fe f8bf 	bl	8005478 <hmac_sha256_update>
    hmac_sha256_update(&ctx, data, 32);
 80072fa:	4629      	mov	r1, r5
 80072fc:	a81b      	add	r0, sp, #108	; 0x6c
 80072fe:	2220      	movs	r2, #32
 8007300:	f7fe f8ba 	bl	8005478 <hmac_sha256_update>
    hmac_sha256_update(&ctx, chal, 32);
 8007304:	a902      	add	r1, sp, #8
 8007306:	a81b      	add	r0, sp, #108	; 0x6c
 8007308:	2220      	movs	r2, #32
 800730a:	f7fe f8b5 	bl	8005478 <hmac_sha256_update>
    hmac_sha256_update(&ctx, &page_num, 1);
 800730e:	f10d 0107 	add.w	r1, sp, #7
 8007312:	a81b      	add	r0, sp, #108	; 0x6c
 8007314:	2201      	movs	r2, #1
 8007316:	f7fe f8af 	bl	8005478 <hmac_sha256_update>
    hmac_sha256_update(&ctx, DEV_MANID, 2);
 800731a:	a81b      	add	r0, sp, #108	; 0x6c
 800731c:	2202      	movs	r2, #2
 800731e:	490c      	ldr	r1, [pc, #48]	; (8007350 <se2_verify_page+0xc0>)
 8007320:	f7fe f8aa 	bl	8005478 <hmac_sha256_update>

    uint8_t expect[32];
    hmac_sha256_final(&ctx, secret, expect);
 8007324:	aa0a      	add	r2, sp, #40	; 0x28
 8007326:	4621      	mov	r1, r4
 8007328:	a81b      	add	r0, sp, #108	; 0x6c
 800732a:	f7fe f8bb 	bl	80054a4 <hmac_sha256_final>

    return check_equal(expect, check+2, 32);
 800732e:	2220      	movs	r2, #32
 8007330:	f10d 014a 	add.w	r1, sp, #74	; 0x4a
 8007334:	a80a      	add	r0, sp, #40	; 0x28
 8007336:	f7fb f99a 	bl	800266e <check_equal>
}
 800733a:	b05c      	add	sp, #368	; 0x170
 800733c:	bd70      	pop	{r4, r5, r6, pc}
 800733e:	bf00      	nop
 8007340:	20000288 	.word	0x20000288
 8007344:	0801e000 	.word	0x0801e000
 8007348:	0801e0b0 	.word	0x0801e0b0
 800734c:	200002e4 	.word	0x200002e4
 8007350:	0800e787 	.word	0x0800e787

08007354 <se2_read_page>:
// Must always authenticate what we read, because just normal read (no encryption)
// does not have any MiTM protection at all.
//
    void
se2_read_page(uint8_t page_num, uint8_t data[32], bool verify)
{
 8007354:	b570      	push	{r4, r5, r6, lr}
 8007356:	4604      	mov	r4, r0
 8007358:	b08a      	sub	sp, #40	; 0x28
 800735a:	460d      	mov	r5, r1
    CALL_CHECK(se2_write1(0x69, page_num));
 800735c:	4601      	mov	r1, r0
 800735e:	2069      	movs	r0, #105	; 0x69
// Must always authenticate what we read, because just normal read (no encryption)
// does not have any MiTM protection at all.
//
    void
se2_read_page(uint8_t page_num, uint8_t data[32], bool verify)
{
 8007360:	4616      	mov	r6, r2
    CALL_CHECK(se2_write1(0x69, page_num));
 8007362:	f7ff fec9 	bl	80070f8 <se2_write1>
 8007366:	b110      	cbz	r0, 800736e <se2_read_page+0x1a>
 8007368:	f240 1107 	movw	r1, #263	; 0x107
 800736c:	e007      	b.n	800737e <se2_read_page+0x2a>

    uint8_t rx[2+32];
    CHECK_RIGHT(se2_read_n(sizeof(rx), rx) == RC_SUCCESS);
 800736e:	a901      	add	r1, sp, #4
 8007370:	2022      	movs	r0, #34	; 0x22
 8007372:	f7ff ff0d 	bl	8007190 <se2_read_n>
 8007376:	28aa      	cmp	r0, #170	; 0xaa
 8007378:	d004      	beq.n	8007384 <se2_read_page+0x30>
 800737a:	f44f 7185 	mov.w	r1, #266	; 0x10a
 800737e:	4818      	ldr	r0, [pc, #96]	; (80073e0 <se2_read_page+0x8c>)
 8007380:	f006 f8b4 	bl	800d4ec <longjmp>

    CHECK_RIGHT(rx[0] == 33);
 8007384:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8007388:	2b21      	cmp	r3, #33	; 0x21
 800738a:	d002      	beq.n	8007392 <se2_read_page+0x3e>
 800738c:	f44f 7186 	mov.w	r1, #268	; 0x10c
 8007390:	e7f5      	b.n	800737e <se2_read_page+0x2a>
    CHECK_RIGHT(rx[1] == RC_SUCCESS);
 8007392:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8007396:	2baa      	cmp	r3, #170	; 0xaa
 8007398:	d002      	beq.n	80073a0 <se2_read_page+0x4c>
 800739a:	f240 110d 	movw	r1, #269	; 0x10d
 800739e:	e7ee      	b.n	800737e <se2_read_page+0x2a>

    memcpy(data, rx+2, 32);
 80073a0:	f10d 0306 	add.w	r3, sp, #6
 80073a4:	462a      	mov	r2, r5
 80073a6:	f10d 0126 	add.w	r1, sp, #38	; 0x26
 80073aa:	f853 0b04 	ldr.w	r0, [r3], #4
 80073ae:	f842 0b04 	str.w	r0, [r2], #4
 80073b2:	428b      	cmp	r3, r1
 80073b4:	d1f9      	bne.n	80073aa <se2_read_page+0x56>

    if(!verify) return;
 80073b6:	b186      	cbz	r6, 80073da <se2_read_page+0x86>

    CHECK_RIGHT(se2_verify_page(page_num, data, 0, SE2_SECRETS->pairing));
 80073b8:	4b0a      	ldr	r3, [pc, #40]	; (80073e4 <se2_read_page+0x90>)
 80073ba:	4a0b      	ldr	r2, [pc, #44]	; (80073e8 <se2_read_page+0x94>)
 80073bc:	f893 10b0 	ldrb.w	r1, [r3, #176]	; 0xb0
 80073c0:	4b0a      	ldr	r3, [pc, #40]	; (80073ec <se2_read_page+0x98>)
 80073c2:	4620      	mov	r0, r4
 80073c4:	29ff      	cmp	r1, #255	; 0xff
 80073c6:	bf18      	it	ne
 80073c8:	4613      	movne	r3, r2
 80073ca:	2200      	movs	r2, #0
 80073cc:	4629      	mov	r1, r5
 80073ce:	f7ff ff5f 	bl	8007290 <se2_verify_page>
 80073d2:	b910      	cbnz	r0, 80073da <se2_read_page+0x86>
 80073d4:	f240 1113 	movw	r1, #275	; 0x113
 80073d8:	e7d1      	b.n	800737e <se2_read_page+0x2a>
}
 80073da:	b00a      	add	sp, #40	; 0x28
 80073dc:	bd70      	pop	{r4, r5, r6, pc}
 80073de:	bf00      	nop
 80073e0:	20000288 	.word	0x20000288
 80073e4:	0801e000 	.word	0x0801e000
 80073e8:	0801e0b0 	.word	0x0801e0b0
 80073ec:	200002e4 	.word	0x200002e4

080073f0 <se2_read_encrypted>:
// - use key to read, but must also do verify because no replay protection otherwise
// - page must be protected with EPH or ECH, and of course !RP
//
    void
se2_read_encrypted(uint8_t page_num, uint8_t data[32], int keynum, const uint8_t *secret)
{
 80073f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80073f2:	b0d7      	sub	sp, #348	; 0x15c
 80073f4:	461e      	mov	r6, r3
    // only supporting secret A or S.
    ASSERT((keynum == 0) || (keynum == 2));
 80073f6:	f032 0302 	bics.w	r3, r2, #2
// - use key to read, but must also do verify because no replay protection otherwise
// - page must be protected with EPH or ECH, and of course !RP
//
    void
se2_read_encrypted(uint8_t page_num, uint8_t data[32], int keynum, const uint8_t *secret)
{
 80073fa:	460c      	mov	r4, r1
 80073fc:	4615      	mov	r5, r2
 80073fe:	f88d 0007 	strb.w	r0, [sp, #7]
    // only supporting secret A or S.
    ASSERT((keynum == 0) || (keynum == 2));
 8007402:	d002      	beq.n	800740a <se2_read_encrypted+0x1a>
 8007404:	4835      	ldr	r0, [pc, #212]	; (80074dc <se2_read_encrypted+0xec>)
 8007406:	f7f9 fae9 	bl	80009dc <fatal_error>

    CALL_CHECK(se2_write1(0x4b, (keynum << 6) | page_num));
 800740a:	f89d 1007 	ldrb.w	r1, [sp, #7]
 800740e:	ea41 1182 	orr.w	r1, r1, r2, lsl #6
 8007412:	b2c9      	uxtb	r1, r1
 8007414:	204b      	movs	r0, #75	; 0x4b
 8007416:	f7ff fe6f 	bl	80070f8 <se2_write1>
 800741a:	b110      	cbz	r0, 8007422 <se2_read_encrypted+0x32>
 800741c:	f240 1163 	movw	r1, #355	; 0x163
 8007420:	e007      	b.n	8007432 <se2_read_encrypted+0x42>

    uint8_t rx[2+8+32];
    CHECK_RIGHT(se2_read_n(sizeof(rx), rx) == RC_SUCCESS);
 8007422:	a90a      	add	r1, sp, #40	; 0x28
 8007424:	202a      	movs	r0, #42	; 0x2a
 8007426:	f7ff feb3 	bl	8007190 <se2_read_n>
 800742a:	28aa      	cmp	r0, #170	; 0xaa
 800742c:	d004      	beq.n	8007438 <se2_read_encrypted+0x48>
 800742e:	f44f 71b3 	mov.w	r1, #358	; 0x166
 8007432:	482b      	ldr	r0, [pc, #172]	; (80074e0 <se2_read_encrypted+0xf0>)
 8007434:	f006 f85a 	bl	800d4ec <longjmp>

    CHECK_RIGHT(rx[1] == RC_SUCCESS);
 8007438:	f89d 3029 	ldrb.w	r3, [sp, #41]	; 0x29
 800743c:	2baa      	cmp	r3, #170	; 0xaa
 800743e:	d002      	beq.n	8007446 <se2_read_encrypted+0x56>
 8007440:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8007444:	e7f5      	b.n	8007432 <se2_read_encrypted+0x42>

    // .. decrypt result.
    uint8_t *chal = rx+2;
    memcpy(data, rx+2+8, 32);
 8007446:	f10d 0332 	add.w	r3, sp, #50	; 0x32
 800744a:	4622      	mov	r2, r4
 800744c:	f10d 0152 	add.w	r1, sp, #82	; 0x52
 8007450:	f853 0b04 	ldr.w	r0, [r3], #4
 8007454:	f842 0b04 	str.w	r0, [r2], #4
 8007458:	428b      	cmp	r3, r1
 800745a:	d1f9      	bne.n	8007450 <se2_read_encrypted+0x60>

    HMAC_CTX ctx;
    hmac_sha256_init(&ctx);
 800745c:	a815      	add	r0, sp, #84	; 0x54
 800745e:	f7fe f805 	bl	800546c <hmac_sha256_init>

    //  msg = chal + self.rom_id + bytes([page_num]) + self.manid
    hmac_sha256_update(&ctx, chal, 8);
 8007462:	2208      	movs	r2, #8
 8007464:	f10d 012a 	add.w	r1, sp, #42	; 0x2a
 8007468:	a815      	add	r0, sp, #84	; 0x54
 800746a:	f7fe f805 	bl	8005478 <hmac_sha256_update>
    hmac_sha256_update(&ctx, SE2_SECRETS->romid, 8);
 800746e:	4b1d      	ldr	r3, [pc, #116]	; (80074e4 <se2_read_encrypted+0xf4>)
 8007470:	4a1d      	ldr	r2, [pc, #116]	; (80074e8 <se2_read_encrypted+0xf8>)
 8007472:	f893 10b0 	ldrb.w	r1, [r3, #176]	; 0xb0
 8007476:	4b1d      	ldr	r3, [pc, #116]	; (80074ec <se2_read_encrypted+0xfc>)
 8007478:	29ff      	cmp	r1, #255	; 0xff
 800747a:	bf0c      	ite	eq
 800747c:	4619      	moveq	r1, r3
 800747e:	4611      	movne	r1, r2
 8007480:	3160      	adds	r1, #96	; 0x60
 8007482:	2208      	movs	r2, #8
 8007484:	a815      	add	r0, sp, #84	; 0x54
 8007486:	f7fd fff7 	bl	8005478 <hmac_sha256_update>
    hmac_sha256_update(&ctx, &page_num, 1);
 800748a:	2201      	movs	r2, #1
 800748c:	f10d 0107 	add.w	r1, sp, #7
 8007490:	a815      	add	r0, sp, #84	; 0x54
 8007492:	f7fd fff1 	bl	8005478 <hmac_sha256_update>
    hmac_sha256_update(&ctx, DEV_MANID, 2);

    uint8_t otp[32];
    hmac_sha256_final(&ctx, secret, otp);
 8007496:	af02      	add	r7, sp, #8

    //  msg = chal + self.rom_id + bytes([page_num]) + self.manid
    hmac_sha256_update(&ctx, chal, 8);
    hmac_sha256_update(&ctx, SE2_SECRETS->romid, 8);
    hmac_sha256_update(&ctx, &page_num, 1);
    hmac_sha256_update(&ctx, DEV_MANID, 2);
 8007498:	2202      	movs	r2, #2
 800749a:	4915      	ldr	r1, [pc, #84]	; (80074f0 <se2_read_encrypted+0x100>)
 800749c:	a815      	add	r0, sp, #84	; 0x54
 800749e:	f7fd ffeb 	bl	8005478 <hmac_sha256_update>

    uint8_t otp[32];
    hmac_sha256_final(&ctx, secret, otp);
 80074a2:	463a      	mov	r2, r7
 80074a4:	4631      	mov	r1, r6
 80074a6:	a815      	add	r0, sp, #84	; 0x54
 80074a8:	f7fd fffc 	bl	80054a4 <hmac_sha256_final>
 80074ac:	4622      	mov	r2, r4
 80074ae:	2300      	movs	r3, #0
		*(acc) ^= *(more);
 80074b0:	7810      	ldrb	r0, [r2, #0]
 80074b2:	5cf9      	ldrb	r1, [r7, r3]
 80074b4:	3301      	adds	r3, #1
 80074b6:	4041      	eors	r1, r0
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 80074b8:	2b20      	cmp	r3, #32
		*(acc) ^= *(more);
 80074ba:	f802 1b01 	strb.w	r1, [r2], #1
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 80074be:	d1f7      	bne.n	80074b0 <se2_read_encrypted+0xc0>

    xor_mixin(data, otp, 32);

    // CRITICAL: verify right result using a nonce we pick!
    CHECK_RIGHT(se2_verify_page(page_num, data, keynum, secret));
 80074c0:	4633      	mov	r3, r6
 80074c2:	462a      	mov	r2, r5
 80074c4:	4621      	mov	r1, r4
 80074c6:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80074ca:	f7ff fee1 	bl	8007290 <se2_verify_page>
 80074ce:	b910      	cbnz	r0, 80074d6 <se2_read_encrypted+0xe6>
 80074d0:	f240 117d 	movw	r1, #381	; 0x17d
 80074d4:	e7ad      	b.n	8007432 <se2_read_encrypted+0x42>
}
 80074d6:	b057      	add	sp, #348	; 0x15c
 80074d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80074da:	bf00      	nop
 80074dc:	0800d558 	.word	0x0800d558
 80074e0:	20000288 	.word	0x20000288
 80074e4:	0801e000 	.word	0x0801e000
 80074e8:	0801e0b0 	.word	0x0801e0b0
 80074ec:	200002e4 	.word	0x200002e4
 80074f0:	0800e787 	.word	0x0800e787

080074f4 <se2_write_encrypted>:
// - needs existing value to pass auth challenge (so we re-read it)
// - so cannot be used on read-protected pages like keys
//
    void
se2_write_encrypted(uint8_t page_num, const uint8_t data[32], int keynum, const uint8_t *secret)
{
 80074f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80074f8:	460f      	mov	r7, r1
    // only supporting secret A or S.
    ASSERT((keynum == 0) || (keynum == 2));
 80074fa:	f032 0102 	bics.w	r1, r2, #2
// - needs existing value to pass auth challenge (so we re-read it)
// - so cannot be used on read-protected pages like keys
//
    void
se2_write_encrypted(uint8_t page_num, const uint8_t data[32], int keynum, const uint8_t *secret)
{
 80074fe:	b0e4      	sub	sp, #400	; 0x190
 8007500:	4606      	mov	r6, r0
 8007502:	4690      	mov	r8, r2
 8007504:	4699      	mov	r9, r3
    // only supporting secret A or S.
    ASSERT((keynum == 0) || (keynum == 2));
 8007506:	d002      	beq.n	800750e <se2_write_encrypted+0x1a>
 8007508:	484d      	ldr	r0, [pc, #308]	; (8007640 <se2_write_encrypted+0x14c>)
 800750a:	f7f9 fa67 	bl	80009dc <fatal_error>

    // need old value to for authentication purposes
    uint8_t     old_data[32];
    se2_read_encrypted(page_num, old_data, keynum, secret);
 800750e:	a901      	add	r1, sp, #4
 8007510:	f7ff ff6e 	bl	80073f0 <se2_read_encrypted>

    uint8_t PGDV = page_num | 0x80;
 8007514:	f066 037f 	orn	r3, r6, #127	; 0x7f

    // pick a nonce
    // (hmac auth + chal) will be written to the "buffer"
    uint8_t chal_check[32+8];
    rng_buffer(&chal_check[32], 8);
 8007518:	2108      	movs	r1, #8
 800751a:	a821      	add	r0, sp, #132	; 0x84

    // need old value to for authentication purposes
    uint8_t     old_data[32];
    se2_read_encrypted(page_num, old_data, keynum, secret);

    uint8_t PGDV = page_num | 0x80;
 800751c:	f88d 3002 	strb.w	r3, [sp, #2]

    // pick a nonce
    // (hmac auth + chal) will be written to the "buffer"
    uint8_t chal_check[32+8];
    rng_buffer(&chal_check[32], 8);
 8007520:	f7fb f8f6 	bl	8002710 <rng_buffer>

    HMAC_CTX ctx;
    hmac_sha256_init(&ctx);
 8007524:	a823      	add	r0, sp, #140	; 0x8c
 8007526:	f7fd ffa1 	bl	800546c <hmac_sha256_init>

    // msg = chal + self.rom_id + PGDV + self.manid
    hmac_sha256_update(&ctx, &chal_check[32], 8);
 800752a:	2208      	movs	r2, #8
 800752c:	a921      	add	r1, sp, #132	; 0x84
 800752e:	a823      	add	r0, sp, #140	; 0x8c
 8007530:	f7fd ffa2 	bl	8005478 <hmac_sha256_update>
    hmac_sha256_update(&ctx, SE2_SECRETS->romid, 8);
 8007534:	4b43      	ldr	r3, [pc, #268]	; (8007644 <se2_write_encrypted+0x150>)
 8007536:	4a44      	ldr	r2, [pc, #272]	; (8007648 <se2_write_encrypted+0x154>)
 8007538:	f893 10b0 	ldrb.w	r1, [r3, #176]	; 0xb0
 800753c:	4b43      	ldr	r3, [pc, #268]	; (800764c <se2_write_encrypted+0x158>)
 800753e:	29ff      	cmp	r1, #255	; 0xff
 8007540:	bf0c      	ite	eq
 8007542:	4619      	moveq	r1, r3
 8007544:	4611      	movne	r1, r2
 8007546:	3160      	adds	r1, #96	; 0x60
 8007548:	2208      	movs	r2, #8
 800754a:	a823      	add	r0, sp, #140	; 0x8c
 800754c:	f7fd ff94 	bl	8005478 <hmac_sha256_update>
    hmac_sha256_update(&ctx, &PGDV, 1);
 8007550:	2201      	movs	r2, #1
 8007552:	f10d 0102 	add.w	r1, sp, #2
 8007556:	a823      	add	r0, sp, #140	; 0x8c
 8007558:	f7fd ff8e 	bl	8005478 <hmac_sha256_update>
    hmac_sha256_update(&ctx, DEV_MANID, 2);
 800755c:	2202      	movs	r2, #2
 800755e:	493c      	ldr	r1, [pc, #240]	; (8007650 <se2_write_encrypted+0x15c>)
 8007560:	a823      	add	r0, sp, #140	; 0x8c
 8007562:	f7fd ff89 	bl	8005478 <hmac_sha256_update>
    ASSERT(ctx.num_pending == 19);
 8007566:	9b63      	ldr	r3, [sp, #396]	; 0x18c
 8007568:	2b13      	cmp	r3, #19
 800756a:	d1cd      	bne.n	8007508 <se2_write_encrypted+0x14>

    uint8_t otp[32];
    hmac_sha256_final(&ctx, secret, otp);
 800756c:	f10d 0a24 	add.w	sl, sp, #36	; 0x24
 8007570:	4652      	mov	r2, sl
 8007572:	4649      	mov	r1, r9
 8007574:	a823      	add	r0, sp, #140	; 0x8c

    // encrypt new value
    uint8_t tmp[32];
    memcpy(tmp, data, 32);
 8007576:	ad11      	add	r5, sp, #68	; 0x44
    hmac_sha256_update(&ctx, &PGDV, 1);
    hmac_sha256_update(&ctx, DEV_MANID, 2);
    ASSERT(ctx.num_pending == 19);

    uint8_t otp[32];
    hmac_sha256_final(&ctx, secret, otp);
 8007578:	f7fd ff94 	bl	80054a4 <hmac_sha256_final>

    // encrypt new value
    uint8_t tmp[32];
    memcpy(tmp, data, 32);
 800757c:	462c      	mov	r4, r5
 800757e:	463b      	mov	r3, r7
 8007580:	f107 0e20 	add.w	lr, r7, #32
 8007584:	6818      	ldr	r0, [r3, #0]
 8007586:	6859      	ldr	r1, [r3, #4]
 8007588:	4622      	mov	r2, r4
 800758a:	c203      	stmia	r2!, {r0, r1}
 800758c:	3308      	adds	r3, #8
 800758e:	4573      	cmp	r3, lr
 8007590:	4614      	mov	r4, r2
 8007592:	d1f7      	bne.n	8007584 <se2_write_encrypted+0x90>
 8007594:	2400      	movs	r4, #0
		*(acc) ^= *(more);
 8007596:	5d2a      	ldrb	r2, [r5, r4]
 8007598:	f81a 3004 	ldrb.w	r3, [sl, r4]
 800759c:	4053      	eors	r3, r2
 800759e:	552b      	strb	r3, [r5, r4]
 80075a0:	3401      	adds	r4, #1
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 80075a2:	2c20      	cmp	r4, #32
 80075a4:	d1f7      	bne.n	8007596 <se2_write_encrypted+0xa2>
    xor_mixin(tmp, otp, 32);

    // "tmp" now encrypted, but also need right auth value in buffer

    // msg2 = self.rom_id + old_data + new_data + PGDV + self.manid
    hmac_sha256_init(&ctx);
 80075a6:	a823      	add	r0, sp, #140	; 0x8c
 80075a8:	f7fd ff60 	bl	800546c <hmac_sha256_init>
    hmac_sha256_update(&ctx, SE2_SECRETS->romid, 8);
 80075ac:	4b25      	ldr	r3, [pc, #148]	; (8007644 <se2_write_encrypted+0x150>)
 80075ae:	4a26      	ldr	r2, [pc, #152]	; (8007648 <se2_write_encrypted+0x154>)
 80075b0:	f893 10b0 	ldrb.w	r1, [r3, #176]	; 0xb0
 80075b4:	4b25      	ldr	r3, [pc, #148]	; (800764c <se2_write_encrypted+0x158>)
 80075b6:	29ff      	cmp	r1, #255	; 0xff
 80075b8:	bf0c      	ite	eq
 80075ba:	4619      	moveq	r1, r3
 80075bc:	4611      	movne	r1, r2
 80075be:	3160      	adds	r1, #96	; 0x60
 80075c0:	2208      	movs	r2, #8
 80075c2:	a823      	add	r0, sp, #140	; 0x8c
 80075c4:	f7fd ff58 	bl	8005478 <hmac_sha256_update>
    hmac_sha256_update(&ctx, old_data, 32);
 80075c8:	4622      	mov	r2, r4
 80075ca:	a901      	add	r1, sp, #4
 80075cc:	a823      	add	r0, sp, #140	; 0x8c
 80075ce:	f7fd ff53 	bl	8005478 <hmac_sha256_update>
    hmac_sha256_update(&ctx, data, 32);
 80075d2:	4622      	mov	r2, r4
 80075d4:	4639      	mov	r1, r7
 80075d6:	a823      	add	r0, sp, #140	; 0x8c
 80075d8:	f7fd ff4e 	bl	8005478 <hmac_sha256_update>
    hmac_sha256_update(&ctx, &PGDV, 1);
 80075dc:	2201      	movs	r2, #1
 80075de:	f10d 0102 	add.w	r1, sp, #2
 80075e2:	a823      	add	r0, sp, #140	; 0x8c
 80075e4:	f7fd ff48 	bl	8005478 <hmac_sha256_update>
    hmac_sha256_update(&ctx, DEV_MANID, 2);
 80075e8:	2202      	movs	r2, #2
 80075ea:	4919      	ldr	r1, [pc, #100]	; (8007650 <se2_write_encrypted+0x15c>)
 80075ec:	a823      	add	r0, sp, #140	; 0x8c
 80075ee:	f7fd ff43 	bl	8005478 <hmac_sha256_update>

    ASSERT(ctx.num_pending == 75);
 80075f2:	9b63      	ldr	r3, [sp, #396]	; 0x18c
 80075f4:	2b4b      	cmp	r3, #75	; 0x4b
 80075f6:	d187      	bne.n	8007508 <se2_write_encrypted+0x14>
    hmac_sha256_final(&ctx, secret, chal_check);
 80075f8:	aa19      	add	r2, sp, #100	; 0x64
 80075fa:	4649      	mov	r1, r9
 80075fc:	a823      	add	r0, sp, #140	; 0x8c
 80075fe:	f7fd ff51 	bl	80054a4 <hmac_sha256_final>

    // send chip both our nonce (challenge) and also HMAC auth check value
    se2_write_buffer(chal_check, sizeof(chal_check));
 8007602:	2128      	movs	r1, #40	; 0x28
 8007604:	a819      	add	r0, sp, #100	; 0x64
 8007606:	f7ff fdfd 	bl	8007204 <se2_write_buffer>

    // send encrypted data now
    uint8_t pn = (keynum << 6) | page_num;
 800760a:	ea46 1688 	orr.w	r6, r6, r8, lsl #6
    CALL_CHECK(se2_write_n(0x99, &pn, tmp, 32));
 800760e:	4623      	mov	r3, r4
 8007610:	462a      	mov	r2, r5
 8007612:	f10d 0103 	add.w	r1, sp, #3
 8007616:	2099      	movs	r0, #153	; 0x99

    // send chip both our nonce (challenge) and also HMAC auth check value
    se2_write_buffer(chal_check, sizeof(chal_check));

    // send encrypted data now
    uint8_t pn = (keynum << 6) | page_num;
 8007618:	f88d 6003 	strb.w	r6, [sp, #3]
    CALL_CHECK(se2_write_n(0x99, &pn, tmp, 32));
 800761c:	f7ff fd86 	bl	800712c <se2_write_n>
 8007620:	b110      	cbz	r0, 8007628 <se2_write_encrypted+0x134>
 8007622:	f240 1151 	movw	r1, #337	; 0x151
 8007626:	e005      	b.n	8007634 <se2_write_encrypted+0x140>

    CHECK_RIGHT(se2_read1() == RC_SUCCESS);
 8007628:	f7ff fdde 	bl	80071e8 <se2_read1>
 800762c:	28aa      	cmp	r0, #170	; 0xaa
 800762e:	d004      	beq.n	800763a <se2_write_encrypted+0x146>
 8007630:	f240 1153 	movw	r1, #339	; 0x153
 8007634:	4807      	ldr	r0, [pc, #28]	; (8007654 <se2_write_encrypted+0x160>)
 8007636:	f005 ff59 	bl	800d4ec <longjmp>
}
 800763a:	b064      	add	sp, #400	; 0x190
 800763c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8007640:	0800d558 	.word	0x0800d558
 8007644:	0801e000 	.word	0x0801e000
 8007648:	0801e0b0 	.word	0x0801e0b0
 800764c:	200002e4 	.word	0x200002e4
 8007650:	0800e787 	.word	0x0800e787
 8007654:	20000288 	.word	0x20000288

08007658 <se2_get_protection>:
//
// Caution: Use only in a controlled environment! No MiTM protection.
//
    uint8_t
se2_get_protection(uint8_t page_num)
{
 8007658:	b508      	push	{r3, lr}
    CALL_CHECK(se2_write1(0xaa, page_num));
 800765a:	4601      	mov	r1, r0
 800765c:	20aa      	movs	r0, #170	; 0xaa
 800765e:	f7ff fd4b 	bl	80070f8 <se2_write1>
 8007662:	b120      	cbz	r0, 800766e <se2_get_protection+0x16>
 8007664:	f44f 71c4 	mov.w	r1, #392	; 0x188
 8007668:	4803      	ldr	r0, [pc, #12]	; (8007678 <se2_get_protection+0x20>)
 800766a:	f005 ff3f 	bl	800d4ec <longjmp>

    return se2_read1();
}
 800766e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    uint8_t
se2_get_protection(uint8_t page_num)
{
    CALL_CHECK(se2_write1(0xaa, page_num));

    return se2_read1();
 8007672:	f7ff bdb9 	b.w	80071e8 <se2_read1>
 8007676:	bf00      	nop
 8007678:	20000288 	.word	0x20000288

0800767c <se2_set_protection>:
//
// Caution: Use only in a controlled environment! No MiTM protection.
//
    void
se2_set_protection(uint8_t page_num, uint8_t flags)
{
 800767c:	b530      	push	{r4, r5, lr}
 800767e:	b085      	sub	sp, #20
 8007680:	460c      	mov	r4, r1
 8007682:	4605      	mov	r5, r0
    if(se2_get_protection(page_num) == flags) {
 8007684:	f7ff ffe8 	bl	8007658 <se2_get_protection>
 8007688:	42a0      	cmp	r0, r4
 800768a:	d01f      	beq.n	80076cc <se2_set_protection+0x50>
// se2_write2()
//
    static bool
se2_write2(uint8_t cmd, uint8_t arg1, uint8_t arg2)
{
    uint8_t data[4] = { cmd, 2, arg1, arg2 };
 800768c:	23c3      	movs	r3, #195	; 0xc3
 800768e:	f88d 300c 	strb.w	r3, [sp, #12]
 8007692:	2302      	movs	r3, #2
 8007694:	f88d 300d 	strb.w	r3, [sp, #13]

    HAL_StatusTypeDef rv = HAL_I2C_Master_Transmit(&i2c_port, I2C_ADDR,
 8007698:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800769c:	9300      	str	r3, [sp, #0]
 800769e:	aa03      	add	r2, sp, #12
 80076a0:	2304      	movs	r3, #4
 80076a2:	2136      	movs	r1, #54	; 0x36
 80076a4:	480a      	ldr	r0, [pc, #40]	; (80076d0 <se2_set_protection+0x54>)
// se2_write2()
//
    static bool
se2_write2(uint8_t cmd, uint8_t arg1, uint8_t arg2)
{
    uint8_t data[4] = { cmd, 2, arg1, arg2 };
 80076a6:	f88d 500e 	strb.w	r5, [sp, #14]
 80076aa:	f88d 400f 	strb.w	r4, [sp, #15]

    HAL_StatusTypeDef rv = HAL_I2C_Master_Transmit(&i2c_port, I2C_ADDR,
 80076ae:	f004 f867 	bl	800b780 <HAL_I2C_Master_Transmit>
{
    if(se2_get_protection(page_num) == flags) {
        return;
    }

    CALL_CHECK(se2_write2(0xc3, page_num, flags));
 80076b2:	b110      	cbz	r0, 80076ba <se2_set_protection+0x3e>
 80076b4:	f44f 71cc 	mov.w	r1, #408	; 0x198
 80076b8:	e005      	b.n	80076c6 <se2_set_protection+0x4a>

    CHECK_RIGHT(se2_read1() == RC_SUCCESS);
 80076ba:	f7ff fd95 	bl	80071e8 <se2_read1>
 80076be:	28aa      	cmp	r0, #170	; 0xaa
 80076c0:	d004      	beq.n	80076cc <se2_set_protection+0x50>
 80076c2:	f44f 71cd 	mov.w	r1, #410	; 0x19a
 80076c6:	4803      	ldr	r0, [pc, #12]	; (80076d4 <se2_set_protection+0x58>)
 80076c8:	f005 ff10 	bl	800d4ec <longjmp>
}
 80076cc:	b005      	add	sp, #20
 80076ce:	bd30      	pop	{r4, r5, pc}
 80076d0:	2000023c 	.word	0x2000023c
 80076d4:	20000288 	.word	0x20000288

080076d8 <se2_probe>:

// se2_probe()
//
    void
se2_probe(void)
{
 80076d8:	b500      	push	{lr}
    // error handling.
    if(setjmp(error_env)) {
 80076da:	4812      	ldr	r0, [pc, #72]	; (8007724 <se2_probe+0x4c>)

// se2_probe()
//
    void
se2_probe(void)
{
 80076dc:	b089      	sub	sp, #36	; 0x24
    // error handling.
    if(setjmp(error_env)) {
 80076de:	f005 feff 	bl	800d4e0 <setjmp>
 80076e2:	b120      	cbz	r0, 80076ee <se2_probe+0x16>
        oled_show(screen_se2_issue);
 80076e4:	4810      	ldr	r0, [pc, #64]	; (8007728 <se2_probe+0x50>)
 80076e6:	f7f9 fb85 	bl	8000df4 <oled_show>
        LOCKUP_FOREVER();
 80076ea:	bf30      	wfi
 80076ec:	e7fd      	b.n	80076ea <se2_probe+0x12>
        // not reached
    }

    // See what's attached. Read serial number and verify it using shared secret
    rng_delay();
 80076ee:	f7fb f826 	bl	800273e <rng_delay>
    if(rom_secrets->se2.pairing[0] == 0xff) {
 80076f2:	4b0e      	ldr	r3, [pc, #56]	; (800772c <se2_probe+0x54>)
 80076f4:	f893 30b0 	ldrb.w	r3, [r3, #176]	; 0xb0
 80076f8:	2bff      	cmp	r3, #255	; 0xff
 80076fa:	d00f      	beq.n	800771c <se2_probe+0x44>
        // chip not setup yet, ok in factory
    } else {
        // This is also verifying the pairing secret, effectively.
        uint8_t tmp[32];
        se2_read_page(PGN_ROM_OPTIONS, tmp, true);
 80076fc:	2201      	movs	r2, #1
 80076fe:	4669      	mov	r1, sp
 8007700:	201c      	movs	r0, #28
 8007702:	f7ff fe27 	bl	8007354 <se2_read_page>

        CHECK_RIGHT(check_equal(&tmp[24], rom_secrets->se2.romid, 8));
 8007706:	2208      	movs	r2, #8
 8007708:	4909      	ldr	r1, [pc, #36]	; (8007730 <se2_probe+0x58>)
 800770a:	a806      	add	r0, sp, #24
 800770c:	f7fa ffaf 	bl	800266e <check_equal>
 8007710:	b920      	cbnz	r0, 800771c <se2_probe+0x44>
 8007712:	f44f 71d9 	mov.w	r1, #434	; 0x1b2
 8007716:	4803      	ldr	r0, [pc, #12]	; (8007724 <se2_probe+0x4c>)
 8007718:	f005 fee8 	bl	800d4ec <longjmp>
    }
}
 800771c:	b009      	add	sp, #36	; 0x24
 800771e:	f85d fb04 	ldr.w	pc, [sp], #4
 8007722:	bf00      	nop
 8007724:	20000288 	.word	0x20000288
 8007728:	0800da42 	.word	0x0800da42
 800772c:	0801e000 	.word	0x0801e000
 8007730:	0801e110 	.word	0x0801e110

08007734 <se2_clear_volatile>:
// No command to reset the volatile state on this chip! Could
// be sensitive at times. 608 has a watchdog for this!!
//
    void
se2_clear_volatile(void)
{
 8007734:	b530      	push	{r4, r5, lr}
    // funny business means MitM?
    if(setjmp(error_env)) fatal_mitm();
 8007736:	481e      	ldr	r0, [pc, #120]	; (80077b0 <se2_clear_volatile+0x7c>)
// No command to reset the volatile state on this chip! Could
// be sensitive at times. 608 has a watchdog for this!!
//
    void
se2_clear_volatile(void)
{
 8007738:	b08d      	sub	sp, #52	; 0x34
    // funny business means MitM?
    if(setjmp(error_env)) fatal_mitm();
 800773a:	f005 fed1 	bl	800d4e0 <setjmp>
 800773e:	4604      	mov	r4, r0
 8007740:	b108      	cbz	r0, 8007746 <se2_clear_volatile+0x12>
 8007742:	f7f9 f955 	bl	80009f0 <fatal_mitm>

    uint8_t z32[32] = {0};
 8007746:	2520      	movs	r5, #32
 8007748:	462a      	mov	r2, r5
 800774a:	4601      	mov	r1, r0
 800774c:	a804      	add	r0, sp, #16
 800774e:	f005 febe 	bl	800d4ce <memset>

    se2_write_page(PGN_PUBKEY_S+0, z32);
 8007752:	a904      	add	r1, sp, #16
 8007754:	201e      	movs	r0, #30
 8007756:	f7ff fd65 	bl	8007224 <se2_write_page>
    se2_write_page(PGN_PUBKEY_S+1, z32);
 800775a:	a904      	add	r1, sp, #16
 800775c:	201f      	movs	r0, #31
 800775e:	f7ff fd61 	bl	8007224 <se2_write_page>

    se2_write_buffer(z32, 32);
 8007762:	4629      	mov	r1, r5
 8007764:	a804      	add	r0, sp, #16
 8007766:	f7ff fd4d 	bl	8007204 <se2_write_buffer>
// se2_write2()
//
    static bool
se2_write2(uint8_t cmd, uint8_t arg1, uint8_t arg2)
{
    uint8_t data[4] = { cmd, 2, arg1, arg2 };
 800776a:	233c      	movs	r3, #60	; 0x3c
 800776c:	f88d 300c 	strb.w	r3, [sp, #12]
 8007770:	2302      	movs	r3, #2
 8007772:	f88d 300d 	strb.w	r3, [sp, #13]
 8007776:	2380      	movs	r3, #128	; 0x80
 8007778:	f88d 300e 	strb.w	r3, [sp, #14]

    HAL_StatusTypeDef rv = HAL_I2C_Master_Transmit(&i2c_port, I2C_ADDR,
 800777c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8007780:	9300      	str	r3, [sp, #0]
 8007782:	aa03      	add	r2, sp, #12
 8007784:	2304      	movs	r3, #4
 8007786:	2136      	movs	r1, #54	; 0x36
 8007788:	480a      	ldr	r0, [pc, #40]	; (80077b4 <se2_clear_volatile+0x80>)
// se2_write2()
//
    static bool
se2_write2(uint8_t cmd, uint8_t arg1, uint8_t arg2)
{
    uint8_t data[4] = { cmd, 2, arg1, arg2 };
 800778a:	f88d 400f 	strb.w	r4, [sp, #15]

    HAL_StatusTypeDef rv = HAL_I2C_Master_Transmit(&i2c_port, I2C_ADDR,
 800778e:	f003 fff7 	bl	800b780 <HAL_I2C_Master_Transmit>

    se2_write_buffer(z32, 32);

    // rotate the secret S ... not ideal but only way I've got to change it
    // - also clears ECDH_SECRET_S flag
    CALL_CHECK(se2_write2(0x3c, (2<<6), 0));
 8007792:	b110      	cbz	r0, 800779a <se2_clear_volatile+0x66>
 8007794:	f44f 71e5 	mov.w	r1, #458	; 0x1ca
 8007798:	e005      	b.n	80077a6 <se2_clear_volatile+0x72>
    CHECK_RIGHT(se2_read1() == RC_SUCCESS);
 800779a:	f7ff fd25 	bl	80071e8 <se2_read1>
 800779e:	28aa      	cmp	r0, #170	; 0xaa
 80077a0:	d004      	beq.n	80077ac <se2_clear_volatile+0x78>
 80077a2:	f240 11cb 	movw	r1, #459	; 0x1cb
 80077a6:	4802      	ldr	r0, [pc, #8]	; (80077b0 <se2_clear_volatile+0x7c>)
 80077a8:	f005 fea0 	bl	800d4ec <longjmp>
}
 80077ac:	b00d      	add	sp, #52	; 0x34
 80077ae:	bd30      	pop	{r4, r5, pc}
 80077b0:	20000288 	.word	0x20000288
 80077b4:	2000023c 	.word	0x2000023c

080077b8 <se2_setup_config>:
// But once started, we assume operation in a safe trusted environment
// (ie. the Coinkite factory in Toronto).
//
    void
se2_setup_config(void)
{
 80077b8:	b570      	push	{r4, r5, r6, lr}
    // error handling.
    if((setjmp(error_env))) {
 80077ba:	484f      	ldr	r0, [pc, #316]	; (80078f8 <se2_setup_config+0x140>)
// But once started, we assume operation in a safe trusted environment
// (ie. the Coinkite factory in Toronto).
//
    void
se2_setup_config(void)
{
 80077bc:	b088      	sub	sp, #32
    // error handling.
    if((setjmp(error_env))) {
 80077be:	f005 fe8f 	bl	800d4e0 <setjmp>
 80077c2:	4605      	mov	r5, r0
 80077c4:	b120      	cbz	r0, 80077d0 <se2_setup_config+0x18>
        oled_show(screen_se2_issue);
 80077c6:	484d      	ldr	r0, [pc, #308]	; (80078fc <se2_setup_config+0x144>)
 80077c8:	f7f9 fb14 	bl	8000df4 <oled_show>

        LOCKUP_FOREVER();
 80077cc:	bf30      	wfi
 80077ce:	e7fd      	b.n	80077cc <se2_setup_config+0x14>
    }

    if(rom_secrets->se2.pairing[0] != 0xff) {
 80077d0:	4b4b      	ldr	r3, [pc, #300]	; (8007900 <se2_setup_config+0x148>)
 80077d2:	f893 10b0 	ldrb.w	r1, [r3, #176]	; 0xb0
 80077d6:	29ff      	cmp	r1, #255	; 0xff
 80077d8:	f040 808c 	bne.w	80078f4 <se2_setup_config+0x13c>
        // we've been here, so nothing more to do / anything we do will fail, etc.
        return;
    }

    // Global (ram) copy of values to be writen, so we can use them during setup
    memset(&_tbd, 0xff, sizeof(_tbd));
 80077dc:	4c49      	ldr	r4, [pc, #292]	; (8007904 <se2_setup_config+0x14c>)
 80077de:	22e0      	movs	r2, #224	; 0xe0
 80077e0:	4620      	mov	r0, r4
 80077e2:	f005 fe74 	bl	800d4ce <memset>

    // pick internal keys
    rng_buffer(_tbd.tpin_key, 32);
 80077e6:	2120      	movs	r1, #32
 80077e8:	f104 0080 	add.w	r0, r4, #128	; 0x80
 80077ec:	f7fa ff90 	bl	8002710 <rng_buffer>

    // capture serial of device
    uint8_t tmp[32];
    se2_read_page(PGN_ROM_OPTIONS, tmp, false);
 80077f0:	462a      	mov	r2, r5
 80077f2:	4669      	mov	r1, sp
 80077f4:	201c      	movs	r0, #28
 80077f6:	f7ff fdad 	bl	8007354 <se2_read_page>

    ASSERT(tmp[1] == 0x00);     // check ANON is not set
 80077fa:	f89d 5001 	ldrb.w	r5, [sp, #1]
 80077fe:	b115      	cbz	r5, 8007806 <se2_setup_config+0x4e>
 8007800:	4841      	ldr	r0, [pc, #260]	; (8007908 <se2_setup_config+0x150>)
 8007802:	f7f9 f8eb 	bl	80009dc <fatal_error>

    memcpy(_tbd.romid, tmp+24, 8);
 8007806:	ab06      	add	r3, sp, #24
 8007808:	cb03      	ldmia	r3!, {r0, r1}
 800780a:	6620      	str	r0, [r4, #96]	; 0x60
 800780c:	6661      	str	r1, [r4, #100]	; 0x64

    // forget a secret - B (will not be used)
    rng_buffer(tmp, 32);
 800780e:	4668      	mov	r0, sp
 8007810:	2120      	movs	r1, #32
 8007812:	f7fa ff7d 	bl	8002710 <rng_buffer>
    se2_write_page(PGN_SECRET_B, tmp);
 8007816:	4669      	mov	r1, sp
 8007818:	201a      	movs	r0, #26
 800781a:	f7ff fd03 	bl	8007224 <se2_write_page>

    // have chip pick a keypair, record public part for later
    se2_pick_keypair(0, true);
 800781e:	2101      	movs	r1, #1
 8007820:	4628      	mov	r0, r5
 8007822:	f7ff fd19 	bl	8007258 <se2_pick_keypair>
    se2_read_page(PGN_PUBKEY_A,   &_tbd.pubkey_A[0], false);
 8007826:	462a      	mov	r2, r5
 8007828:	f104 0120 	add.w	r1, r4, #32
 800782c:	2010      	movs	r0, #16
 800782e:	f7ff fd91 	bl	8007354 <se2_read_page>
    se2_read_page(PGN_PUBKEY_A+1, &_tbd.pubkey_A[32], false);

    // Burn privkey B with garbage. Invalid ECC key like this cannot
    // be used (except to make errors)
    memset(tmp, 0, 32);
 8007832:	2620      	movs	r6, #32
    se2_write_page(PGN_SECRET_B, tmp);

    // have chip pick a keypair, record public part for later
    se2_pick_keypair(0, true);
    se2_read_page(PGN_PUBKEY_A,   &_tbd.pubkey_A[0], false);
    se2_read_page(PGN_PUBKEY_A+1, &_tbd.pubkey_A[32], false);
 8007834:	462a      	mov	r2, r5
 8007836:	f104 0140 	add.w	r1, r4, #64	; 0x40
 800783a:	2011      	movs	r0, #17
 800783c:	f7ff fd8a 	bl	8007354 <se2_read_page>

    // Burn privkey B with garbage. Invalid ECC key like this cannot
    // be used (except to make errors)
    memset(tmp, 0, 32);
 8007840:	4632      	mov	r2, r6
 8007842:	4629      	mov	r1, r5
 8007844:	4668      	mov	r0, sp
 8007846:	f005 fe42 	bl	800d4ce <memset>
    se2_write_page(PGN_PRIVKEY_B, tmp);
 800784a:	4669      	mov	r1, sp
 800784c:	2017      	movs	r0, #23
 800784e:	f7ff fce9 	bl	8007224 <se2_write_page>
    se2_write_page(PGN_PRIVKEY_B+1, tmp);
 8007852:	4669      	mov	r1, sp
 8007854:	2018      	movs	r0, #24
 8007856:	f7ff fce5 	bl	8007224 <se2_write_page>
    se2_write_page(PGN_PUBKEY_B, tmp);
 800785a:	4669      	mov	r1, sp
 800785c:	2012      	movs	r0, #18
 800785e:	f7ff fce1 	bl	8007224 <se2_write_page>
    se2_write_page(PGN_PUBKEY_B+1, tmp);
 8007862:	4669      	mov	r1, sp
 8007864:	2013      	movs	r0, #19
 8007866:	f7ff fcdd 	bl	8007224 <se2_write_page>

    // pick a paring secret (A)
    do {
        rng_buffer(_tbd.pairing, 32);
 800786a:	4631      	mov	r1, r6
 800786c:	4620      	mov	r0, r4
 800786e:	f7fa ff4f 	bl	8002710 <rng_buffer>
    } while(_tbd.pairing[0] == 0xff);
 8007872:	7823      	ldrb	r3, [r4, #0]
 8007874:	2bff      	cmp	r3, #255	; 0xff
 8007876:	d0f8      	beq.n	800786a <se2_setup_config+0xb2>
    se2_write_page(PGN_SECRET_A, _tbd.pairing);
 8007878:	4621      	mov	r1, r4
 800787a:	2019      	movs	r0, #25
 800787c:	f7ff fcd2 	bl	8007224 <se2_write_page>

    // called the "easy" key, this one requires only SE2 pairing to read/write
    // - so we can wipe it anytime as part of bricking (maybe)
    // - but also so that more than just the paired pubkey w/ SE1 is needed
    rng_buffer(tmp, 32);
 8007880:	2120      	movs	r1, #32
 8007882:	4668      	mov	r0, sp
 8007884:	f7fa ff44 	bl	8002710 <rng_buffer>
    se2_write_page(PGN_SE2_EASY_KEY, tmp);
 8007888:	4669      	mov	r1, sp
 800788a:	200e      	movs	r0, #14
 800788c:	f7ff fcca 	bl	8007224 <se2_write_page>

    // wipe all trick pins and data slots
    memset(tmp, 0, 32);
 8007890:	2220      	movs	r2, #32
 8007892:	2100      	movs	r1, #0
 8007894:	4668      	mov	r0, sp
 8007896:	f005 fe1a 	bl	800d4ce <memset>
    se2_write_page(PGN_SECRET_A, _tbd.pairing);

    // called the "easy" key, this one requires only SE2 pairing to read/write
    // - so we can wipe it anytime as part of bricking (maybe)
    // - but also so that more than just the paired pubkey w/ SE1 is needed
    rng_buffer(tmp, 32);
 800789a:	466c      	mov	r4, sp
    se2_write_page(PGN_SE2_EASY_KEY, tmp);

    // wipe all trick pins and data slots
    memset(tmp, 0, 32);
    for(int pn=0; pn <= PGN_LAST_TRICK; pn++) {
 800789c:	2500      	movs	r5, #0
        se2_write_page(pn, tmp);
 800789e:	b2e8      	uxtb	r0, r5
 80078a0:	4621      	mov	r1, r4
    rng_buffer(tmp, 32);
    se2_write_page(PGN_SE2_EASY_KEY, tmp);

    // wipe all trick pins and data slots
    memset(tmp, 0, 32);
    for(int pn=0; pn <= PGN_LAST_TRICK; pn++) {
 80078a2:	3501      	adds	r5, #1
        se2_write_page(pn, tmp);
 80078a4:	f7ff fcbe 	bl	8007224 <se2_write_page>
    rng_buffer(tmp, 32);
    se2_write_page(PGN_SE2_EASY_KEY, tmp);

    // wipe all trick pins and data slots
    memset(tmp, 0, 32);
    for(int pn=0; pn <= PGN_LAST_TRICK; pn++) {
 80078a8:	2d0e      	cmp	r5, #14
 80078aa:	d1f8      	bne.n	800789e <se2_setup_config+0xe6>
        se2_write_page(pn, tmp);
    }

    // save the shared secrets for ourselves, in flash
    flash_save_se2_data(&_tbd);
 80078ac:	4815      	ldr	r0, [pc, #84]	; (8007904 <se2_setup_config+0x14c>)
 80078ae:	f7fa fc9d 	bl	80021ec <flash_save_se2_data>

    // Now safe to lock down the SE2; failures up to this point could be
    // recovered by picking new values. After this, if main flash corrupt, no
    // way to read these values back, nor replace them with new ones.
    se2_set_protection(PGN_SECRET_A, PROT_WP);
 80078b2:	2102      	movs	r1, #2
 80078b4:	2019      	movs	r0, #25
 80078b6:	f7ff fee1 	bl	800767c <se2_set_protection>
    se2_set_protection(PGN_SECRET_B, PROT_WP);
 80078ba:	2102      	movs	r1, #2
 80078bc:	201a      	movs	r0, #26
 80078be:	f7ff fedd 	bl	800767c <se2_set_protection>
    se2_set_protection(PGN_PUBKEY_A, PROT_WP);
 80078c2:	2102      	movs	r1, #2
 80078c4:	2010      	movs	r0, #16
 80078c6:	f7ff fed9 	bl	800767c <se2_set_protection>
    se2_set_protection(PGN_PUBKEY_B, PROT_WP);
 80078ca:	2102      	movs	r1, #2
 80078cc:	2012      	movs	r0, #18
 80078ce:	f7ff fed5 	bl	800767c <se2_set_protection>

    se2_set_protection(PGN_SE2_EASY_KEY, PROT_EPH);
 80078d2:	4628      	mov	r0, r5
 80078d4:	2110      	movs	r1, #16
 80078d6:	f7ff fed1 	bl	800767c <se2_set_protection>
 80078da:	2400      	movs	r4, #0
    for(int pn=0; pn <= PGN_LAST_TRICK; pn++) {
        se2_set_protection(pn, PROT_EPH);
 80078dc:	2510      	movs	r5, #16
 80078de:	b2e0      	uxtb	r0, r4
 80078e0:	4629      	mov	r1, r5
    se2_set_protection(PGN_SECRET_B, PROT_WP);
    se2_set_protection(PGN_PUBKEY_A, PROT_WP);
    se2_set_protection(PGN_PUBKEY_B, PROT_WP);

    se2_set_protection(PGN_SE2_EASY_KEY, PROT_EPH);
    for(int pn=0; pn <= PGN_LAST_TRICK; pn++) {
 80078e2:	3401      	adds	r4, #1
        se2_set_protection(pn, PROT_EPH);
 80078e4:	f7ff feca 	bl	800767c <se2_set_protection>
    se2_set_protection(PGN_SECRET_B, PROT_WP);
    se2_set_protection(PGN_PUBKEY_A, PROT_WP);
    se2_set_protection(PGN_PUBKEY_B, PROT_WP);

    se2_set_protection(PGN_SE2_EASY_KEY, PROT_EPH);
    for(int pn=0; pn <= PGN_LAST_TRICK; pn++) {
 80078e8:	2c0e      	cmp	r4, #14
 80078ea:	d1f8      	bne.n	80078de <se2_setup_config+0x126>
        se2_set_protection(pn, PROT_EPH);
    }

    se2_set_protection(PGN_ROM_OPTIONS, PROT_APH);       // not planning to change
 80078ec:	2108      	movs	r1, #8
 80078ee:	201c      	movs	r0, #28
 80078f0:	f7ff fec4 	bl	800767c <se2_set_protection>

    // NOTE: PGN_SE2_HARD_KEY and PUBKEY_C not yet known
}
 80078f4:	b008      	add	sp, #32
 80078f6:	bd70      	pop	{r4, r5, r6, pc}
 80078f8:	20000288 	.word	0x20000288
 80078fc:	0800da42 	.word	0x0800da42
 8007900:	0801e000 	.word	0x0801e000
 8007904:	200002e4 	.word	0x200002e4
 8007908:	0800d558 	.word	0x0800d558

0800790c <se2_save_auth_pubkey>:
// Record and enable an ECC pubkey for joining purposes.
// - trusted env. so no need for encrypted comms
//
    void
se2_save_auth_pubkey(const uint8_t pubkey[64])
{
 800790c:	b510      	push	{r4, lr}
 800790e:	b08a      	sub	sp, #40	; 0x28
 8007910:	9001      	str	r0, [sp, #4]
    if(setjmp(error_env)) fatal_mitm();
 8007912:	481e      	ldr	r0, [pc, #120]	; (800798c <se2_save_auth_pubkey+0x80>)
 8007914:	f005 fde4 	bl	800d4e0 <setjmp>
 8007918:	b108      	cbz	r0, 800791e <se2_save_auth_pubkey+0x12>
 800791a:	f7f9 f869 	bl	80009f0 <fatal_mitm>

    ASSERT(check_all_ones(rom_secrets->se2.auth_pubkey, 64));
 800791e:	2140      	movs	r1, #64	; 0x40
 8007920:	481b      	ldr	r0, [pc, #108]	; (8007990 <se2_save_auth_pubkey+0x84>)
 8007922:	f7fa fe8d 	bl	8002640 <check_all_ones>
 8007926:	b910      	cbnz	r0, 800792e <se2_save_auth_pubkey+0x22>
 8007928:	481a      	ldr	r0, [pc, #104]	; (8007994 <se2_save_auth_pubkey+0x88>)
 800792a:	f7f9 f857 	bl	80009dc <fatal_error>
    memcpy(&_tbd, &rom_secrets->se2, sizeof(_tbd));
 800792e:	4c1a      	ldr	r4, [pc, #104]	; (8007998 <se2_save_auth_pubkey+0x8c>)
 8007930:	491a      	ldr	r1, [pc, #104]	; (800799c <se2_save_auth_pubkey+0x90>)
 8007932:	22e0      	movs	r2, #224	; 0xe0
 8007934:	4620      	mov	r0, r4
 8007936:	f005 fda4 	bl	800d482 <memcpy>

    // pick the "hard" key now
    uint8_t     tmp[32];
    rng_buffer(tmp, 32);
 800793a:	2120      	movs	r1, #32
 800793c:	a802      	add	r0, sp, #8
 800793e:	f7fa fee7 	bl	8002710 <rng_buffer>
    se2_write_page(PGN_SE2_HARD_KEY, tmp);
 8007942:	a902      	add	r1, sp, #8
 8007944:	200f      	movs	r0, #15
 8007946:	f7ff fc6d 	bl	8007224 <se2_write_page>

    // save SE1 pubkey into "pubkey C"
    se2_write_page(PGN_PUBKEY_C, &pubkey[0]);
 800794a:	9901      	ldr	r1, [sp, #4]
 800794c:	2014      	movs	r0, #20
 800794e:	f7ff fc69 	bl	8007224 <se2_write_page>
    se2_write_page(PGN_PUBKEY_C+1, &pubkey[32]);
 8007952:	9b01      	ldr	r3, [sp, #4]
 8007954:	2015      	movs	r0, #21
 8007956:	f103 0120 	add.w	r1, r3, #32
 800795a:	f7ff fc63 	bl	8007224 <se2_write_page>

    memcpy(_tbd.auth_pubkey, pubkey, 64);
 800795e:	9b01      	ldr	r3, [sp, #4]
 8007960:	34a0      	adds	r4, #160	; 0xa0
 8007962:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8007966:	f853 1b04 	ldr.w	r1, [r3], #4
 800796a:	f844 1b04 	str.w	r1, [r4], #4
 800796e:	4293      	cmp	r3, r2
 8007970:	d1f9      	bne.n	8007966 <se2_save_auth_pubkey+0x5a>

    // commit pubkey to mcu flash
    flash_save_se2_data(&_tbd);
 8007972:	4809      	ldr	r0, [pc, #36]	; (8007998 <se2_save_auth_pubkey+0x8c>)
 8007974:	f7fa fc3a 	bl	80021ec <flash_save_se2_data>

    // lock it all up
    se2_set_protection(PGN_SE2_HARD_KEY, PROT_WP | PROT_ECH | PROT_ECW);
 8007978:	21c2      	movs	r1, #194	; 0xc2
 800797a:	200f      	movs	r0, #15
 800797c:	f7ff fe7e 	bl	800767c <se2_set_protection>
    se2_set_protection(PGN_PUBKEY_C, PROT_WP | PROT_RP | PROT_AUTH);
 8007980:	2123      	movs	r1, #35	; 0x23
 8007982:	2014      	movs	r0, #20
 8007984:	f7ff fe7a 	bl	800767c <se2_set_protection>
}
 8007988:	b00a      	add	sp, #40	; 0x28
 800798a:	bd10      	pop	{r4, pc}
 800798c:	20000288 	.word	0x20000288
 8007990:	0801e150 	.word	0x0801e150
 8007994:	0800d558 	.word	0x0800d558
 8007998:	200002e4 	.word	0x200002e4
 800799c:	0801e0b0 	.word	0x0801e0b0

080079a0 <trick_pin_hash>:
// - unrelated to hashing of any other PIN codes
// - so doing hmac-sha256 with unique key
//
    void
trick_pin_hash(const char *pin, int pin_len, uint8_t tpin_hash[32])
{
 80079a0:	b570      	push	{r4, r5, r6, lr}
    ASSERT(pin_len >= 0);           // 12-12 typical, but empty = blank PIN
 80079a2:	1e0e      	subs	r6, r1, #0
// - unrelated to hashing of any other PIN codes
// - so doing hmac-sha256 with unique key
//
    void
trick_pin_hash(const char *pin, int pin_len, uint8_t tpin_hash[32])
{
 80079a4:	b0c2      	sub	sp, #264	; 0x108
 80079a6:	4605      	mov	r5, r0
 80079a8:	4614      	mov	r4, r2
    ASSERT(pin_len >= 0);           // 12-12 typical, but empty = blank PIN
 80079aa:	da02      	bge.n	80079b2 <trick_pin_hash+0x12>
 80079ac:	4812      	ldr	r0, [pc, #72]	; (80079f8 <trick_pin_hash+0x58>)
 80079ae:	f7f9 f815 	bl	80009dc <fatal_error>

    HMAC_CTX ctx;

    hmac_sha256_init(&ctx);
 80079b2:	a801      	add	r0, sp, #4
 80079b4:	f7fd fd5a 	bl	800546c <hmac_sha256_init>
    hmac_sha256_update(&ctx, (uint8_t *)pin, pin_len);
 80079b8:	4632      	mov	r2, r6
 80079ba:	4629      	mov	r1, r5
 80079bc:	a801      	add	r0, sp, #4
 80079be:	f7fd fd5b 	bl	8005478 <hmac_sha256_update>
    hmac_sha256_final(&ctx, SE2_SECRETS->tpin_key, tpin_hash);
 80079c2:	4b0e      	ldr	r3, [pc, #56]	; (80079fc <trick_pin_hash+0x5c>)
 80079c4:	4a0e      	ldr	r2, [pc, #56]	; (8007a00 <trick_pin_hash+0x60>)
 80079c6:	f893 10b0 	ldrb.w	r1, [r3, #176]	; 0xb0
 80079ca:	4b0e      	ldr	r3, [pc, #56]	; (8007a04 <trick_pin_hash+0x64>)
 80079cc:	29ff      	cmp	r1, #255	; 0xff
 80079ce:	bf0c      	ite	eq
 80079d0:	4619      	moveq	r1, r3
 80079d2:	4611      	movne	r1, r2
 80079d4:	a801      	add	r0, sp, #4
 80079d6:	4622      	mov	r2, r4
 80079d8:	3180      	adds	r1, #128	; 0x80
 80079da:	f7fd fd63 	bl	80054a4 <hmac_sha256_final>

    // and a double SHA for good measure
    sha256_single(tpin_hash, 32, tpin_hash);
 80079de:	4622      	mov	r2, r4
 80079e0:	4620      	mov	r0, r4
 80079e2:	2120      	movs	r1, #32
 80079e4:	f7fd fd22 	bl	800542c <sha256_single>
    sha256_single(tpin_hash, 32, tpin_hash);
 80079e8:	4622      	mov	r2, r4
 80079ea:	2120      	movs	r1, #32
 80079ec:	4620      	mov	r0, r4
 80079ee:	f7fd fd1d 	bl	800542c <sha256_single>
}
 80079f2:	b042      	add	sp, #264	; 0x108
 80079f4:	bd70      	pop	{r4, r5, r6, pc}
 80079f6:	bf00      	nop
 80079f8:	0800d558 	.word	0x0800d558
 80079fc:	0801e000 	.word	0x0801e000
 8007a00:	0801e0b0 	.word	0x0801e0b0
 8007a04:	200002e4 	.word	0x200002e4

08007a08 <p256_gen_keypair>:

// p256_gen_keypair()
//
    void
p256_gen_keypair(uint8_t privkey[32], uint8_t pubkey[64])
{
 8007a08:	b538      	push	{r3, r4, r5, lr}
 8007a0a:	4605      	mov	r5, r0
    uECC_set_rng(rng_for_uECC);
 8007a0c:	4808      	ldr	r0, [pc, #32]	; (8007a30 <p256_gen_keypair+0x28>)

// p256_gen_keypair()
//
    void
p256_gen_keypair(uint8_t privkey[32], uint8_t pubkey[64])
{
 8007a0e:	460c      	mov	r4, r1
    uECC_set_rng(rng_for_uECC);
 8007a10:	f7fe fede 	bl	80067d0 <uECC_set_rng>

    int ok = uECC_make_key(pubkey, privkey, uECC_secp256r1());
 8007a14:	f7fe fee2 	bl	80067dc <uECC_secp256r1>
 8007a18:	4629      	mov	r1, r5
 8007a1a:	4602      	mov	r2, r0
 8007a1c:	4620      	mov	r0, r4
 8007a1e:	f7fe fee5 	bl	80067ec <uECC_make_key>
    ASSERT(ok == 1);
 8007a22:	2801      	cmp	r0, #1
 8007a24:	d002      	beq.n	8007a2c <p256_gen_keypair+0x24>
 8007a26:	4803      	ldr	r0, [pc, #12]	; (8007a34 <p256_gen_keypair+0x2c>)
 8007a28:	f7f8 ffd8 	bl	80009dc <fatal_error>
 8007a2c:	bd38      	pop	{r3, r4, r5, pc}
 8007a2e:	bf00      	nop
 8007a30:	080071f9 	.word	0x080071f9
 8007a34:	0800d558 	.word	0x0800d558

08007a38 <ps256_ecdh>:

// ps256_ecdh()
//
    void
ps256_ecdh(const uint8_t pubkey[64], const uint8_t privkey[32], uint8_t result[32])
{
 8007a38:	b570      	push	{r4, r5, r6, lr}
 8007a3a:	4604      	mov	r4, r0
    uECC_set_rng(rng_for_uECC);
 8007a3c:	4809      	ldr	r0, [pc, #36]	; (8007a64 <ps256_ecdh+0x2c>)

// ps256_ecdh()
//
    void
ps256_ecdh(const uint8_t pubkey[64], const uint8_t privkey[32], uint8_t result[32])
{
 8007a3e:	460d      	mov	r5, r1
 8007a40:	4616      	mov	r6, r2
    uECC_set_rng(rng_for_uECC);
 8007a42:	f7fe fec5 	bl	80067d0 <uECC_set_rng>

    int ok = uECC_shared_secret(pubkey, privkey, result, uECC_secp256r1());
 8007a46:	f7fe fec9 	bl	80067dc <uECC_secp256r1>
 8007a4a:	4632      	mov	r2, r6
 8007a4c:	4603      	mov	r3, r0
 8007a4e:	4629      	mov	r1, r5
 8007a50:	4620      	mov	r0, r4
 8007a52:	f7fe ff0b 	bl	800686c <uECC_shared_secret>
    ASSERT(ok == 1);
 8007a56:	2801      	cmp	r0, #1
 8007a58:	d002      	beq.n	8007a60 <ps256_ecdh+0x28>
 8007a5a:	4803      	ldr	r0, [pc, #12]	; (8007a68 <ps256_ecdh+0x30>)
 8007a5c:	f7f8 ffbe 	bl	80009dc <fatal_error>
 8007a60:	bd70      	pop	{r4, r5, r6, pc}
 8007a62:	bf00      	nop
 8007a64:	080071f9 	.word	0x080071f9
 8007a68:	0800d558 	.word	0x0800d558

08007a6c <se2_read_hard_secret>:

// se2_read_hard_secret()
//
    static bool
se2_read_hard_secret(uint8_t hard_key[32], const uint8_t pin_digest[32])
{
 8007a6c:	b510      	push	{r4, lr}
 8007a6e:	b0e8      	sub	sp, #416	; 0x1a0
 8007a70:	9002      	str	r0, [sp, #8]
    if(setjmp(error_env)) {
 8007a72:	4837      	ldr	r0, [pc, #220]	; (8007b50 <se2_read_hard_secret+0xe4>)

// se2_read_hard_secret()
//
    static bool
se2_read_hard_secret(uint8_t hard_key[32], const uint8_t pin_digest[32])
{
 8007a74:	9103      	str	r1, [sp, #12]
    if(setjmp(error_env)) {
 8007a76:	f005 fd33 	bl	800d4e0 <setjmp>
 8007a7a:	2800      	cmp	r0, #0
 8007a7c:	d164      	bne.n	8007b48 <se2_read_hard_secret+0xdc>
    //
    SHA256_CTX ctx;

    // pick a temp key pair, share public part w/ SE2
    uint8_t tmp_privkey[32], tmp_pubkey[64];
    p256_gen_keypair(tmp_privkey, tmp_pubkey);
 8007a7e:	a925      	add	r1, sp, #148	; 0x94
 8007a80:	a805      	add	r0, sp, #20
 8007a82:	f7ff ffc1 	bl	8007a08 <p256_gen_keypair>

    // - this can be mitm-ed, but we sign it next so doesn't matter
    se2_write_page(PGN_PUBKEY_S, &tmp_pubkey[0]);
 8007a86:	a925      	add	r1, sp, #148	; 0x94
 8007a88:	201e      	movs	r0, #30
 8007a8a:	f7ff fbcb 	bl	8007224 <se2_write_page>
    se2_write_page(PGN_PUBKEY_S+1, &tmp_pubkey[32]);
 8007a8e:	a92d      	add	r1, sp, #180	; 0xb4
 8007a90:	201f      	movs	r0, #31
 8007a92:	f7ff fbc7 	bl	8007224 <se2_write_page>

    // pick nonce
    uint8_t chal[32+32];
    rng_buffer(chal, sizeof(chal));
 8007a96:	2140      	movs	r1, #64	; 0x40
 8007a98:	a835      	add	r0, sp, #212	; 0xd4
 8007a9a:	f7fa fe39 	bl	8002710 <rng_buffer>
    se2_write_buffer(chal, sizeof(chal));
 8007a9e:	2140      	movs	r1, #64	; 0x40
 8007aa0:	a835      	add	r0, sp, #212	; 0xd4
 8007aa2:	f7ff fbaf 	bl	8007204 <se2_write_buffer>

    // md = ngu.hash.sha256s(T_pubkey + chal[0:32])
    sha256_init(&ctx);
 8007aa6:	a855      	add	r0, sp, #340	; 0x154
 8007aa8:	f7fd fc56 	bl	8005358 <sha256_init>
    sha256_update(&ctx, tmp_pubkey, 64);
 8007aac:	2240      	movs	r2, #64	; 0x40
 8007aae:	a925      	add	r1, sp, #148	; 0x94
 8007ab0:	a855      	add	r0, sp, #340	; 0x154
 8007ab2:	f7fd fc61 	bl	8005378 <sha256_update>
    sha256_update(&ctx, chal, 32);      // only first 32 bytes
 8007ab6:	2220      	movs	r2, #32
 8007ab8:	a935      	add	r1, sp, #212	; 0xd4
 8007aba:	a855      	add	r0, sp, #340	; 0x154
 8007abc:	f7fd fc5c 	bl	8005378 <sha256_update>

    uint8_t md[32];
    sha256_final(&ctx, md);
 8007ac0:	a90d      	add	r1, sp, #52	; 0x34
 8007ac2:	a855      	add	r0, sp, #340	; 0x154
 8007ac4:	f7fd fc9e 	bl	8005404 <sha256_final>
    // Get that digest signed by SE1 now, and doing that requires
    // the main pin, because the required slot requires auth by that key.
    // - this is the critical step attackers would not be able to emulate w/o SE1 contents
    // - fails here if PIN wrong
    uint8_t signature[64];
    int arc = ae_sign_authed(KEYNUM_joiner_key, md, signature, KEYNUM_main_pin, pin_digest);
 8007ac8:	9b03      	ldr	r3, [sp, #12]
 8007aca:	9300      	str	r3, [sp, #0]
 8007acc:	aa45      	add	r2, sp, #276	; 0x114
 8007ace:	2303      	movs	r3, #3
 8007ad0:	a90d      	add	r1, sp, #52	; 0x34
 8007ad2:	2007      	movs	r0, #7
 8007ad4:	f7fb f96e 	bl	8002db4 <ae_sign_authed>
    CHECK_RIGHT(arc == 0);
 8007ad8:	4604      	mov	r4, r0
 8007ada:	b110      	cbz	r0, 8007ae2 <se2_read_hard_secret+0x76>
 8007adc:	f240 411a 	movw	r1, #1050	; 0x41a
 8007ae0:	e00f      	b.n	8007b02 <se2_read_hard_secret+0x96>

    // "Authenticate ECDSA Public Key" = 0xA8
    // cs_offset=32   ecdh_keynum=0=pubA ECDH=1 WR=0
    uint8_t param = ((32-1) << 3) | (0 << 2) | 0x2;
 8007ae2:	23fa      	movs	r3, #250	; 0xfa
 8007ae4:	f88d 3013 	strb.w	r3, [sp, #19]
    se2_write_n(0xA8, &param, signature, 64);
 8007ae8:	aa45      	add	r2, sp, #276	; 0x114
 8007aea:	2340      	movs	r3, #64	; 0x40
 8007aec:	f10d 0113 	add.w	r1, sp, #19
 8007af0:	20a8      	movs	r0, #168	; 0xa8
 8007af2:	f7ff fb1b 	bl	800712c <se2_write_n>
    CHECK_RIGHT(se2_read1() == RC_SUCCESS);
 8007af6:	f7ff fb77 	bl	80071e8 <se2_read1>
 8007afa:	28aa      	cmp	r0, #170	; 0xaa
 8007afc:	d004      	beq.n	8007b08 <se2_read_hard_secret+0x9c>
 8007afe:	f44f 6184 	mov.w	r1, #1056	; 0x420
 8007b02:	4813      	ldr	r0, [pc, #76]	; (8007b50 <se2_read_hard_secret+0xe4>)
 8007b04:	f005 fcf2 	bl	800d4ec <longjmp>

    uint8_t shared_x[32], shared_secret[32];
    ps256_ecdh(rom_secrets->se2.pubkey_A, tmp_privkey, shared_x);
 8007b08:	aa15      	add	r2, sp, #84	; 0x54
 8007b0a:	a905      	add	r1, sp, #20
 8007b0c:	4811      	ldr	r0, [pc, #68]	; (8007b54 <se2_read_hard_secret+0xe8>)
 8007b0e:	f7ff ff93 	bl	8007a38 <ps256_ecdh>

    // shared secret S will be SHA over X of shared ECDH point + chal[32:]
    //  s = ngu.hash.sha256s(x + chal[32:])
    sha256_init(&ctx);
 8007b12:	a855      	add	r0, sp, #340	; 0x154
 8007b14:	f7fd fc20 	bl	8005358 <sha256_init>
    sha256_update(&ctx, shared_x, 32);
 8007b18:	2220      	movs	r2, #32
 8007b1a:	a915      	add	r1, sp, #84	; 0x54
 8007b1c:	a855      	add	r0, sp, #340	; 0x154
 8007b1e:	f7fd fc2b 	bl	8005378 <sha256_update>
    sha256_update(&ctx, &chal[32], 32);      // second half
 8007b22:	2220      	movs	r2, #32
 8007b24:	a93d      	add	r1, sp, #244	; 0xf4
 8007b26:	a855      	add	r0, sp, #340	; 0x154
 8007b28:	f7fd fc26 	bl	8005378 <sha256_update>
    sha256_final(&ctx, shared_secret);
 8007b2c:	a91d      	add	r1, sp, #116	; 0x74
 8007b2e:	a855      	add	r0, sp, #340	; 0x154
 8007b30:	f7fd fc68 	bl	8005404 <sha256_final>

    se2_read_encrypted(PGN_SE2_HARD_KEY, hard_key, 2, shared_secret);
 8007b34:	200f      	movs	r0, #15
 8007b36:	ab1d      	add	r3, sp, #116	; 0x74
 8007b38:	2202      	movs	r2, #2
 8007b3a:	9902      	ldr	r1, [sp, #8]
 8007b3c:	f7ff fc58 	bl	80073f0 <se2_read_encrypted>

    // CONCERN: secret "S" is retained in SE2's sram. No API to clear it.
    // - but you'd need to see our copy of that value to make use of it
    // - and PIN checked already to get here, so you could re-do anyway
    se2_clear_volatile();
 8007b40:	f7ff fdf8 	bl	8007734 <se2_clear_volatile>

    return false;
 8007b44:	4620      	mov	r0, r4
 8007b46:	e000      	b.n	8007b4a <se2_read_hard_secret+0xde>
    static bool
se2_read_hard_secret(uint8_t hard_key[32], const uint8_t pin_digest[32])
{
    if(setjmp(error_env)) {
        DEBUG("se2_read_hard_secret");
        return true;
 8007b48:	2001      	movs	r0, #1
    // - but you'd need to see our copy of that value to make use of it
    // - and PIN checked already to get here, so you could re-do anyway
    se2_clear_volatile();

    return false;
}
 8007b4a:	b068      	add	sp, #416	; 0x1a0
 8007b4c:	bd10      	pop	{r4, pc}
 8007b4e:	bf00      	nop
 8007b50:	20000288 	.word	0x20000288
 8007b54:	0801e0d0 	.word	0x0801e0d0

08007b58 <se2_calc_seed_key>:

// se2_calc_seed_key()
//
    static bool
se2_calc_seed_key(uint8_t aes_key[32], const mcu_key_t *mcu_key, const uint8_t pin_digest[32])
{
 8007b58:	b570      	push	{r4, r5, r6, lr}
 8007b5a:	b0d2      	sub	sp, #328	; 0x148
 8007b5c:	4614      	mov	r4, r2
    // Gather key parts from all over. Combine them w/ HMAC into a AES-256 key
    uint8_t se1_easy_key[32], se1_hard_key[32];
    se2_read_encrypted(PGN_SE2_EASY_KEY, se1_easy_key, 0, rom_secrets->se2.pairing);
 8007b5e:	4b15      	ldr	r3, [pc, #84]	; (8007bb4 <se2_calc_seed_key+0x5c>)
 8007b60:	2200      	movs	r2, #0

// se2_calc_seed_key()
//
    static bool
se2_calc_seed_key(uint8_t aes_key[32], const mcu_key_t *mcu_key, const uint8_t pin_digest[32])
{
 8007b62:	4605      	mov	r5, r0
 8007b64:	460e      	mov	r6, r1
    // Gather key parts from all over. Combine them w/ HMAC into a AES-256 key
    uint8_t se1_easy_key[32], se1_hard_key[32];
    se2_read_encrypted(PGN_SE2_EASY_KEY, se1_easy_key, 0, rom_secrets->se2.pairing);
 8007b66:	200e      	movs	r0, #14
 8007b68:	a901      	add	r1, sp, #4
 8007b6a:	f7ff fc41 	bl	80073f0 <se2_read_encrypted>

    if(se2_read_hard_secret(se1_hard_key, pin_digest)) return true;
 8007b6e:	4621      	mov	r1, r4
 8007b70:	a809      	add	r0, sp, #36	; 0x24
 8007b72:	f7ff ff7b 	bl	8007a6c <se2_read_hard_secret>
 8007b76:	4604      	mov	r4, r0
 8007b78:	b9c8      	cbnz	r0, 8007bae <se2_calc_seed_key+0x56>

    HMAC_CTX ctx;
    hmac_sha256_init(&ctx);
 8007b7a:	a811      	add	r0, sp, #68	; 0x44
 8007b7c:	f7fd fc76 	bl	800546c <hmac_sha256_init>
    hmac_sha256_update(&ctx, mcu_key->value, 32);
 8007b80:	2220      	movs	r2, #32
 8007b82:	4631      	mov	r1, r6
 8007b84:	a811      	add	r0, sp, #68	; 0x44
 8007b86:	f7fd fc77 	bl	8005478 <hmac_sha256_update>
    hmac_sha256_update(&ctx, se1_hard_key, 32);
 8007b8a:	2220      	movs	r2, #32
 8007b8c:	a909      	add	r1, sp, #36	; 0x24
 8007b8e:	a811      	add	r0, sp, #68	; 0x44
 8007b90:	f7fd fc72 	bl	8005478 <hmac_sha256_update>
    hmac_sha256_update(&ctx, se1_easy_key, 32);
 8007b94:	2220      	movs	r2, #32
 8007b96:	a901      	add	r1, sp, #4
 8007b98:	a811      	add	r0, sp, #68	; 0x44
 8007b9a:	f7fd fc6d 	bl	8005478 <hmac_sha256_update>

    // combine them all using anther MCU key via HMAC-SHA256
    hmac_sha256_final(&ctx, rom_secrets->mcu_hmac_key, aes_key);
 8007b9e:	a811      	add	r0, sp, #68	; 0x44
 8007ba0:	462a      	mov	r2, r5
 8007ba2:	4905      	ldr	r1, [pc, #20]	; (8007bb8 <se2_calc_seed_key+0x60>)
 8007ba4:	f7fd fc7e 	bl	80054a4 <hmac_sha256_final>
    hmac_sha256_init(&ctx);     // clear secrets
 8007ba8:	a811      	add	r0, sp, #68	; 0x44
 8007baa:	f7fd fc5f 	bl	800546c <hmac_sha256_init>

    //puts2("aeskey="); hex_dump(aes_key, 32);
    return false;
}
 8007bae:	4620      	mov	r0, r4
 8007bb0:	b052      	add	sp, #328	; 0x148
 8007bb2:	bd70      	pop	{r4, r5, r6, pc}
 8007bb4:	0801e0b0 	.word	0x0801e0b0
 8007bb8:	0801e090 	.word	0x0801e090

08007bbc <se2_setup>:

// se2_setup()
//
    void
se2_setup(void)
{
 8007bbc:	b5f0      	push	{r4, r5, r6, r7, lr}
    if(i2c_port.Instance == I2C2) {
 8007bbe:	4e1b      	ldr	r6, [pc, #108]	; (8007c2c <se2_setup+0x70>)
 8007bc0:	4f1b      	ldr	r7, [pc, #108]	; (8007c30 <se2_setup+0x74>)
 8007bc2:	6833      	ldr	r3, [r6, #0]
 8007bc4:	42bb      	cmp	r3, r7

// se2_setup()
//
    void
se2_setup(void)
{
 8007bc6:	b089      	sub	sp, #36	; 0x24
    if(i2c_port.Instance == I2C2) {
 8007bc8:	d02d      	beq.n	8007c26 <se2_setup+0x6a>
    STATIC_ASSERT(offsetof(trick_slot_t, pin_len) == 8+64+16);
    STATIC_ASSERT(offsetof(trick_slot_t, blank_slots) == 8+64+16+4);
    STATIC_ASSERT(offsetof(trick_slot_t, spare) == 8+64+16+4+4);

    // unlikely we need:
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007bca:	4b1a      	ldr	r3, [pc, #104]	; (8007c34 <se2_setup+0x78>)
    __HAL_RCC_I2C2_CLK_ENABLE();

    // I2C2 bus is dedicated to our DS28C36B part.
    // - B13 and B14
    GPIO_InitTypeDef setup = {
 8007bcc:	4d1a      	ldr	r5, [pc, #104]	; (8007c38 <se2_setup+0x7c>)
    STATIC_ASSERT(offsetof(trick_slot_t, pin_len) == 8+64+16);
    STATIC_ASSERT(offsetof(trick_slot_t, blank_slots) == 8+64+16+4);
    STATIC_ASSERT(offsetof(trick_slot_t, spare) == 8+64+16+4+4);

    // unlikely we need:
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007bce:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8007bd0:	f042 0202 	orr.w	r2, r2, #2
 8007bd4:	64da      	str	r2, [r3, #76]	; 0x4c
 8007bd6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8007bd8:	f002 0202 	and.w	r2, r2, #2
 8007bdc:	9201      	str	r2, [sp, #4]
 8007bde:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_I2C2_CLK_ENABLE();
 8007be0:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8007be2:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8007be6:	659a      	str	r2, [r3, #88]	; 0x58
 8007be8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8007bea:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8007bee:	9302      	str	r3, [sp, #8]
 8007bf0:	9b02      	ldr	r3, [sp, #8]

    // I2C2 bus is dedicated to our DS28C36B part.
    // - B13 and B14
    GPIO_InitTypeDef setup = {
 8007bf2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8007bf4:	ac03      	add	r4, sp, #12
 8007bf6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8007bf8:	682b      	ldr	r3, [r5, #0]
        .Mode = GPIO_MODE_AF_OD,
        .Pull = GPIO_NOPULL,
        .Speed = GPIO_SPEED_FREQ_VERY_HIGH,
        .Alternate = GPIO_AF4_I2C2,
    };
    HAL_GPIO_Init(GPIOB, &setup);
 8007bfa:	4810      	ldr	r0, [pc, #64]	; (8007c3c <se2_setup+0x80>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
    __HAL_RCC_I2C2_CLK_ENABLE();

    // I2C2 bus is dedicated to our DS28C36B part.
    // - B13 and B14
    GPIO_InitTypeDef setup = {
 8007bfc:	6023      	str	r3, [r4, #0]
        .Mode = GPIO_MODE_AF_OD,
        .Pull = GPIO_NOPULL,
        .Speed = GPIO_SPEED_FREQ_VERY_HIGH,
        .Alternate = GPIO_AF4_I2C2,
    };
    HAL_GPIO_Init(GPIOB, &setup);
 8007bfe:	a903      	add	r1, sp, #12
 8007c00:	f7f9 f9de 	bl	8000fc0 <HAL_GPIO_Init>

    // Setup HAL device
    memset(&i2c_port, 0, sizeof(i2c_port));
 8007c04:	224c      	movs	r2, #76	; 0x4c
 8007c06:	2100      	movs	r1, #0
 8007c08:	4630      	mov	r0, r6
 8007c0a:	f005 fc60 	bl	800d4ce <memset>
    i2c_port.Instance = I2C2;

    // see I2C_InitTypeDef
    i2c_port.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8007c0e:	2301      	movs	r3, #1
 8007c10:	60f3      	str	r3, [r6, #12]
    //i2c_port.Init.Timing = 0x0050174f;     // ie. 1Mhz "fast mode plus" in CubeMX @ 120Mhz
    i2c_port.Init.Timing = 0x00b03fb8;     // 400khz "fast mode" in CubeMX @ 120Mhz (measured ok)
    //i2c_port.Init.Timing = 0xf01075ff;     // 40khz "std mode" in CubeMX @ 120Mhz (works)
    i2c_port.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;

    HAL_StatusTypeDef rv = HAL_I2C_Init(&i2c_port);
 8007c12:	4630      	mov	r0, r6
    i2c_port.Instance = I2C2;

    // see I2C_InitTypeDef
    i2c_port.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
    //i2c_port.Init.Timing = 0x0050174f;     // ie. 1Mhz "fast mode plus" in CubeMX @ 120Mhz
    i2c_port.Init.Timing = 0x00b03fb8;     // 400khz "fast mode" in CubeMX @ 120Mhz (measured ok)
 8007c14:	4b0a      	ldr	r3, [pc, #40]	; (8007c40 <se2_setup+0x84>)
    };
    HAL_GPIO_Init(GPIOB, &setup);

    // Setup HAL device
    memset(&i2c_port, 0, sizeof(i2c_port));
    i2c_port.Instance = I2C2;
 8007c16:	6037      	str	r7, [r6, #0]

    // see I2C_InitTypeDef
    i2c_port.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
    //i2c_port.Init.Timing = 0x0050174f;     // ie. 1Mhz "fast mode plus" in CubeMX @ 120Mhz
    i2c_port.Init.Timing = 0x00b03fb8;     // 400khz "fast mode" in CubeMX @ 120Mhz (measured ok)
 8007c18:	6073      	str	r3, [r6, #4]
    //i2c_port.Init.Timing = 0xf01075ff;     // 40khz "std mode" in CubeMX @ 120Mhz (works)
    i2c_port.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;

    HAL_StatusTypeDef rv = HAL_I2C_Init(&i2c_port);
 8007c1a:	f003 fd5f 	bl	800b6dc <HAL_I2C_Init>
    ASSERT(rv == HAL_OK);
 8007c1e:	b110      	cbz	r0, 8007c26 <se2_setup+0x6a>
 8007c20:	4808      	ldr	r0, [pc, #32]	; (8007c44 <se2_setup+0x88>)
 8007c22:	f7f8 fedb 	bl	80009dc <fatal_error>

    // compile time checks
    STATIC_ASSERT(offsetof(rom_secrets_t, se2) % 8 == 0);
    STATIC_ASSERT(PGN_LAST_TRICK < PGN_SE2_EASY_KEY);
}
 8007c26:	b009      	add	sp, #36	; 0x24
 8007c28:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007c2a:	bf00      	nop
 8007c2c:	2000023c 	.word	0x2000023c
 8007c30:	40005800 	.word	0x40005800
 8007c34:	40021000 	.word	0x40021000
 8007c38:	0800e770 	.word	0x0800e770
 8007c3c:	48000400 	.word	0x48000400
 8007c40:	00b03fb8 	.word	0x00b03fb8
 8007c44:	0800d558 	.word	0x0800d558

08007c48 <se2_clear_tricks>:
//
// Wipe all the trick PIN's and their data.
//
    void
se2_clear_tricks(void)
{
 8007c48:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007c4a:	b089      	sub	sp, #36	; 0x24
    se2_setup();
 8007c4c:	f7ff ffb6 	bl	8007bbc <se2_setup>

    // funny business means MitM?
    if(setjmp(error_env)) fatal_mitm();
 8007c50:	480f      	ldr	r0, [pc, #60]	; (8007c90 <se2_clear_tricks+0x48>)
 8007c52:	f005 fc45 	bl	800d4e0 <setjmp>
 8007c56:	4604      	mov	r4, r0
 8007c58:	b108      	cbz	r0, 8007c5e <se2_clear_tricks+0x16>
 8007c5a:	f7f8 fec9 	bl	80009f0 <fatal_mitm>

    // wipe with all zeros
    uint8_t tmp[32] = {0};
 8007c5e:	4601      	mov	r1, r0
 8007c60:	2220      	movs	r2, #32
 8007c62:	4668      	mov	r0, sp
 8007c64:	f005 fc33 	bl	800d4ce <memset>
    for(int pn=0; pn <= PGN_LAST_TRICK; pn++) {
        se2_write_encrypted(pn, tmp, 0, SE2_SECRETS->pairing);
 8007c68:	4f0a      	ldr	r7, [pc, #40]	; (8007c94 <se2_clear_tricks+0x4c>)
 8007c6a:	4e0b      	ldr	r6, [pc, #44]	; (8007c98 <se2_clear_tricks+0x50>)
 8007c6c:	4d0b      	ldr	r5, [pc, #44]	; (8007c9c <se2_clear_tricks+0x54>)
 8007c6e:	f897 30b0 	ldrb.w	r3, [r7, #176]	; 0xb0
 8007c72:	b2e0      	uxtb	r0, r4
 8007c74:	2bff      	cmp	r3, #255	; 0xff
 8007c76:	bf0c      	ite	eq
 8007c78:	4633      	moveq	r3, r6
 8007c7a:	462b      	movne	r3, r5
 8007c7c:	2200      	movs	r2, #0
 8007c7e:	4669      	mov	r1, sp
    // funny business means MitM?
    if(setjmp(error_env)) fatal_mitm();

    // wipe with all zeros
    uint8_t tmp[32] = {0};
    for(int pn=0; pn <= PGN_LAST_TRICK; pn++) {
 8007c80:	3401      	adds	r4, #1
        se2_write_encrypted(pn, tmp, 0, SE2_SECRETS->pairing);
 8007c82:	f7ff fc37 	bl	80074f4 <se2_write_encrypted>
    // funny business means MitM?
    if(setjmp(error_env)) fatal_mitm();

    // wipe with all zeros
    uint8_t tmp[32] = {0};
    for(int pn=0; pn <= PGN_LAST_TRICK; pn++) {
 8007c86:	2c0e      	cmp	r4, #14
 8007c88:	d1f1      	bne.n	8007c6e <se2_clear_tricks+0x26>
        se2_write_encrypted(pn, tmp, 0, SE2_SECRETS->pairing);
    }
}
 8007c8a:	b009      	add	sp, #36	; 0x24
 8007c8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007c8e:	bf00      	nop
 8007c90:	20000288 	.word	0x20000288
 8007c94:	0801e000 	.word	0x0801e000
 8007c98:	200002e4 	.word	0x200002e4
 8007c9c:	0801e0b0 	.word	0x0801e0b0

08007ca0 <se2_read_trick_data>:
//
// Read 1 or 2 data slots that immediately follow a trick PIN slot.
//
    void
se2_read_trick_data(int slot_num, uint16_t tc_flags, uint8_t data[64])
{
 8007ca0:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 8007ca4:	9002      	str	r0, [sp, #8]
    if(setjmp(error_env)) fatal_mitm();
 8007ca6:	4818      	ldr	r0, [pc, #96]	; (8007d08 <se2_read_trick_data+0x68>)
//
// Read 1 or 2 data slots that immediately follow a trick PIN slot.
//
    void
se2_read_trick_data(int slot_num, uint16_t tc_flags, uint8_t data[64])
{
 8007ca8:	9103      	str	r1, [sp, #12]
 8007caa:	9201      	str	r2, [sp, #4]
    if(setjmp(error_env)) fatal_mitm();
 8007cac:	f005 fc18 	bl	800d4e0 <setjmp>
 8007cb0:	4605      	mov	r5, r0
 8007cb2:	b108      	cbz	r0, 8007cb8 <se2_read_trick_data+0x18>
 8007cb4:	f7f8 fe9c 	bl	80009f0 <fatal_mitm>

    se2_setup();
    se2_read_encrypted(slot_num+1, &data[0], 0, SE2_SECRETS->pairing);
 8007cb8:	f8df 8058 	ldr.w	r8, [pc, #88]	; 8007d14 <se2_read_trick_data+0x74>
 8007cbc:	4f13      	ldr	r7, [pc, #76]	; (8007d0c <se2_read_trick_data+0x6c>)
 8007cbe:	4e14      	ldr	r6, [pc, #80]	; (8007d10 <se2_read_trick_data+0x70>)
    void
se2_read_trick_data(int slot_num, uint16_t tc_flags, uint8_t data[64])
{
    if(setjmp(error_env)) fatal_mitm();

    se2_setup();
 8007cc0:	f7ff ff7c 	bl	8007bbc <se2_setup>
    se2_read_encrypted(slot_num+1, &data[0], 0, SE2_SECRETS->pairing);
 8007cc4:	f89d 4008 	ldrb.w	r4, [sp, #8]
 8007cc8:	f898 30b0 	ldrb.w	r3, [r8, #176]	; 0xb0
 8007ccc:	9901      	ldr	r1, [sp, #4]
 8007cce:	1c60      	adds	r0, r4, #1
 8007cd0:	2bff      	cmp	r3, #255	; 0xff
 8007cd2:	bf0c      	ite	eq
 8007cd4:	463b      	moveq	r3, r7
 8007cd6:	4633      	movne	r3, r6
 8007cd8:	462a      	mov	r2, r5
 8007cda:	b2c0      	uxtb	r0, r0
 8007cdc:	f7ff fb88 	bl	80073f0 <se2_read_encrypted>

    if(tc_flags & TC_XPRV_WALLET) {
 8007ce0:	9b03      	ldr	r3, [sp, #12]
 8007ce2:	051b      	lsls	r3, r3, #20
 8007ce4:	d50c      	bpl.n	8007d00 <se2_read_trick_data+0x60>
        se2_read_encrypted(slot_num+2, &data[32], 0, SE2_SECRETS->pairing);
 8007ce6:	f898 30b0 	ldrb.w	r3, [r8, #176]	; 0xb0
 8007cea:	9901      	ldr	r1, [sp, #4]
 8007cec:	1ca0      	adds	r0, r4, #2
 8007cee:	2bff      	cmp	r3, #255	; 0xff
 8007cf0:	bf0c      	ite	eq
 8007cf2:	463b      	moveq	r3, r7
 8007cf4:	4633      	movne	r3, r6
 8007cf6:	462a      	mov	r2, r5
 8007cf8:	3120      	adds	r1, #32
 8007cfa:	b2c0      	uxtb	r0, r0
 8007cfc:	f7ff fb78 	bl	80073f0 <se2_read_encrypted>
    }
}
 8007d00:	b004      	add	sp, #16
 8007d02:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8007d06:	bf00      	nop
 8007d08:	20000288 	.word	0x20000288
 8007d0c:	200002e4 	.word	0x200002e4
 8007d10:	0801e0b0 	.word	0x0801e0b0
 8007d14:	0801e000 	.word	0x0801e000

08007d18 <se2_test_trick_pin>:
// - if not in safety mode, the side-effect (brick, etc) will have happened before this returns
// - will always check all slots so bus traffic doesn't change based on result.
//
    bool
se2_test_trick_pin(const char *pin, int pin_len, trick_slot_t *found_slot, bool safety_mode)
{
 8007d18:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8007d1c:	b0fd      	sub	sp, #500	; 0x1f4
 8007d1e:	e88d 000c 	stmia.w	sp, {r2, r3}
 8007d22:	9003      	str	r0, [sp, #12]
 8007d24:	9102      	str	r1, [sp, #8]
    se2_setup();
 8007d26:	f7ff ff49 	bl	8007bbc <se2_setup>

    // error handling.
    if(setjmp(error_env)) {
 8007d2a:	4866      	ldr	r0, [pc, #408]	; (8007ec4 <se2_test_trick_pin+0x1ac>)
 8007d2c:	f005 fbd8 	bl	800d4e0 <setjmp>
 8007d30:	4604      	mov	r4, r0
 8007d32:	b128      	cbz	r0, 8007d40 <se2_test_trick_pin+0x28>
        // remember messing w/ i2c bus during operation could lead here.
        if(!safety_mode) fatal_mitm();
 8007d34:	9b01      	ldr	r3, [sp, #4]
 8007d36:	b10b      	cbz	r3, 8007d3c <se2_test_trick_pin+0x24>

        return false;
 8007d38:	2000      	movs	r0, #0
 8007d3a:	e0c0      	b.n	8007ebe <se2_test_trick_pin+0x1a6>
    se2_setup();

    // error handling.
    if(setjmp(error_env)) {
        // remember messing w/ i2c bus during operation could lead here.
        if(!safety_mode) fatal_mitm();
 8007d3c:	f7f8 fe58 	bl	80009f0 <fatal_mitm>

        return false;
    }

    // zero-length pin not allowed
    if(!pin_len) return false;
 8007d40:	9b02      	ldr	r3, [sp, #8]
 8007d42:	2b00      	cmp	r3, #0
 8007d44:	d0f8      	beq.n	8007d38 <se2_test_trick_pin+0x20>

    uint8_t     tpin_hash[32];
    trick_pin_hash(pin, pin_len, tpin_hash);
 8007d46:	aa04      	add	r2, sp, #16
 8007d48:	4619      	mov	r1, r3
 8007d4a:	9803      	ldr	r0, [sp, #12]

    // always read all data first, and without any time differences
    uint8_t slots[NUM_TRICKS][32];
    int pn = PGN_TRICK(0);
    for(int i=0; i<NUM_TRICKS; i++, pn++) {
        se2_read_encrypted(pn, slots[i], 0, SE2_SECRETS->pairing);
 8007d4c:	f8df 818c 	ldr.w	r8, [pc, #396]	; 8007edc <se2_test_trick_pin+0x1c4>
 8007d50:	4f5d      	ldr	r7, [pc, #372]	; (8007ec8 <se2_test_trick_pin+0x1b0>)
 8007d52:	4d5e      	ldr	r5, [pc, #376]	; (8007ecc <se2_test_trick_pin+0x1b4>)

    // zero-length pin not allowed
    if(!pin_len) return false;

    uint8_t     tpin_hash[32];
    trick_pin_hash(pin, pin_len, tpin_hash);
 8007d54:	f7ff fe24 	bl	80079a0 <trick_pin_hash>

    // always read all data first, and without any time differences
    uint8_t slots[NUM_TRICKS][32];
    int pn = PGN_TRICK(0);
    for(int i=0; i<NUM_TRICKS; i++, pn++) {
        se2_read_encrypted(pn, slots[i], 0, SE2_SECRETS->pairing);
 8007d58:	f898 30b0 	ldrb.w	r3, [r8, #176]	; 0xb0
 8007d5c:	ae0c      	add	r6, sp, #48	; 0x30
 8007d5e:	2bff      	cmp	r3, #255	; 0xff
 8007d60:	bf0c      	ite	eq
 8007d62:	463b      	moveq	r3, r7
 8007d64:	462b      	movne	r3, r5
 8007d66:	eb06 1144 	add.w	r1, r6, r4, lsl #5
 8007d6a:	b2e0      	uxtb	r0, r4
 8007d6c:	2200      	movs	r2, #0
    trick_pin_hash(pin, pin_len, tpin_hash);

    // always read all data first, and without any time differences
    uint8_t slots[NUM_TRICKS][32];
    int pn = PGN_TRICK(0);
    for(int i=0; i<NUM_TRICKS; i++, pn++) {
 8007d6e:	3401      	adds	r4, #1
        se2_read_encrypted(pn, slots[i], 0, SE2_SECRETS->pairing);
 8007d70:	f7ff fb3e 	bl	80073f0 <se2_read_encrypted>
    trick_pin_hash(pin, pin_len, tpin_hash);

    // always read all data first, and without any time differences
    uint8_t slots[NUM_TRICKS][32];
    int pn = PGN_TRICK(0);
    for(int i=0; i<NUM_TRICKS; i++, pn++) {
 8007d74:	2c0e      	cmp	r4, #14
 8007d76:	d1ef      	bne.n	8007d58 <se2_test_trick_pin+0x40>
        se2_read_encrypted(pn, slots[i], 0, SE2_SECRETS->pairing);
    }
    se2_clear_volatile();
 8007d78:	f7ff fcdc 	bl	8007734 <se2_clear_volatile>
 8007d7c:	2500      	movs	r5, #0
 8007d7e:	462f      	mov	r7, r5
 8007d80:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    // Look for matches
    int found = -1;
    uint32_t blank = 0;
    for(int i=0; i<NUM_TRICKS; i++) {
        uint8_t *here = &slots[i][0];
        if(check_equal(here, tpin_hash, 28)) {
 8007d84:	f04f 091c 	mov.w	r9, #28
 8007d88:	eb06 1845 	add.w	r8, r6, r5, lsl #5
 8007d8c:	464a      	mov	r2, r9
 8007d8e:	a904      	add	r1, sp, #16
 8007d90:	4640      	mov	r0, r8
 8007d92:	f7fa fc6c 	bl	800266e <check_equal>
            // we have a winner... but keep checking
            found = i;
        }
        blank |= (!!check_all_zeros(here, 32)) << i;
 8007d96:	2120      	movs	r1, #32
    // Look for matches
    int found = -1;
    uint32_t blank = 0;
    for(int i=0; i<NUM_TRICKS; i++) {
        uint8_t *here = &slots[i][0];
        if(check_equal(here, tpin_hash, 28)) {
 8007d98:	2800      	cmp	r0, #0
 8007d9a:	bf18      	it	ne
 8007d9c:	462c      	movne	r4, r5
            // we have a winner... but keep checking
            found = i;
        }
        blank |= (!!check_all_zeros(here, 32)) << i;
 8007d9e:	4640      	mov	r0, r8
 8007da0:	f7fa fc56 	bl	8002650 <check_all_zeros>
 8007da4:	40a8      	lsls	r0, r5
    se2_clear_volatile();
    
    // Look for matches
    int found = -1;
    uint32_t blank = 0;
    for(int i=0; i<NUM_TRICKS; i++) {
 8007da6:	3501      	adds	r5, #1
 8007da8:	2d0e      	cmp	r5, #14
        uint8_t *here = &slots[i][0];
        if(check_equal(here, tpin_hash, 28)) {
            // we have a winner... but keep checking
            found = i;
        }
        blank |= (!!check_all_zeros(here, 32)) << i;
 8007daa:	ea47 0700 	orr.w	r7, r7, r0
    se2_clear_volatile();
    
    // Look for matches
    int found = -1;
    uint32_t blank = 0;
    for(int i=0; i<NUM_TRICKS; i++) {
 8007dae:	d1eb      	bne.n	8007d88 <se2_test_trick_pin+0x70>
            // we have a winner... but keep checking
            found = i;
        }
        blank |= (!!check_all_zeros(here, 32)) << i;
    }
    rng_delay();
 8007db0:	f7fa fcc5 	bl	800273e <rng_delay>

    memset(found_slot, 0, sizeof(trick_slot_t));
 8007db4:	2280      	movs	r2, #128	; 0x80
 8007db6:	2100      	movs	r1, #0
 8007db8:	9800      	ldr	r0, [sp, #0]
 8007dba:	f005 fb88 	bl	800d4ce <memset>

    if(safety_mode) {
 8007dbe:	9b01      	ldr	r3, [sp, #4]
 8007dc0:	b10b      	cbz	r3, 8007dc6 <se2_test_trick_pin+0xae>
        // tell them which slots are available, iff working after main pin is set
        found_slot->blank_slots = blank;
 8007dc2:	9b00      	ldr	r3, [sp, #0]
 8007dc4:	65df      	str	r7, [r3, #92]	; 0x5c
    }

    if(found >= 0) {
 8007dc6:	1c63      	adds	r3, r4, #1
 8007dc8:	d106      	bne.n	8007dd8 <se2_test_trick_pin+0xc0>

        return true;
    } else {
    fake_out:
        // do similar work? 
        found_slot->slot_num = -1;
 8007dca:	9a00      	ldr	r2, [sp, #0]
 8007dcc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8007dd0:	6013      	str	r3, [r2, #0]
        rng_delay();
 8007dd2:	f7fa fcb4 	bl	800273e <rng_delay>
 8007dd6:	e7af      	b.n	8007d38 <se2_test_trick_pin+0x20>
        found_slot->blank_slots = blank;
    }

    if(found >= 0) {
        // match found
        found_slot->slot_num = found;
 8007dd8:	9b00      	ldr	r3, [sp, #0]

        // 28 bytes are the PIN hash, last 4 bytes is our meta-data.
        // following slot(s) may hold wallet data (32-64 bytes)
        memcpy(&found_slot->tc_flags, &slots[found][28], 2);
 8007dda:	9800      	ldr	r0, [sp, #0]
        found_slot->blank_slots = blank;
    }

    if(found >= 0) {
        // match found
        found_slot->slot_num = found;
 8007ddc:	601c      	str	r4, [r3, #0]

        // 28 bytes are the PIN hash, last 4 bytes is our meta-data.
        // following slot(s) may hold wallet data (32-64 bytes)
        memcpy(&found_slot->tc_flags, &slots[found][28], 2);
 8007dde:	0163      	lsls	r3, r4, #5
 8007de0:	aa0c      	add	r2, sp, #48	; 0x30
 8007de2:	f103 011c 	add.w	r1, r3, #28
        memcpy(&found_slot->tc_arg, &slots[found][30], 2);
 8007de6:	331e      	adds	r3, #30
        // match found
        found_slot->slot_num = found;

        // 28 bytes are the PIN hash, last 4 bytes is our meta-data.
        // following slot(s) may hold wallet data (32-64 bytes)
        memcpy(&found_slot->tc_flags, &slots[found][28], 2);
 8007de8:	5a51      	ldrh	r1, [r2, r1]
 8007dea:	8081      	strh	r1, [r0, #4]
        memcpy(&found_slot->tc_arg, &slots[found][30], 2);

        uint16_t todo = found_slot->tc_flags;
 8007dec:	8885      	ldrh	r5, [r0, #4]
        found_slot->slot_num = found;

        // 28 bytes are the PIN hash, last 4 bytes is our meta-data.
        // following slot(s) may hold wallet data (32-64 bytes)
        memcpy(&found_slot->tc_flags, &slots[found][28], 2);
        memcpy(&found_slot->tc_arg, &slots[found][30], 2);
 8007dee:	5ad3      	ldrh	r3, [r2, r3]
 8007df0:	80c3      	strh	r3, [r0, #6]

        uint16_t todo = found_slot->tc_flags;

        // hmm: don't need this data if safety is off.. but we have it anyway
        if(found_slot->tc_flags & TC_WORD_WALLET) {
 8007df2:	04ef      	lsls	r7, r5, #19
        // 28 bytes are the PIN hash, last 4 bytes is our meta-data.
        // following slot(s) may hold wallet data (32-64 bytes)
        memcpy(&found_slot->tc_flags, &slots[found][28], 2);
        memcpy(&found_slot->tc_arg, &slots[found][30], 2);

        uint16_t todo = found_slot->tc_flags;
 8007df4:	4603      	mov	r3, r0

        // hmm: don't need this data if safety is off.. but we have it anyway
        if(found_slot->tc_flags & TC_WORD_WALLET) {
 8007df6:	d511      	bpl.n	8007e1c <se2_test_trick_pin+0x104>
            // it's a 24-word BIP-39 seed phrase, un-encrypted.
            if(found+1 < NUM_TRICKS) {
 8007df8:	2c0c      	cmp	r4, #12
 8007dfa:	dc35      	bgt.n	8007e68 <se2_test_trick_pin+0x150>
                memcpy(found_slot->xdata, &slots[found+1][0], 32);
 8007dfc:	3401      	adds	r4, #1
 8007dfe:	eb02 1444 	add.w	r4, r2, r4, lsl #5
 8007e02:	3308      	adds	r3, #8
 8007e04:	f104 0620 	add.w	r6, r4, #32
 8007e08:	4622      	mov	r2, r4
 8007e0a:	ca03      	ldmia	r2!, {r0, r1}
 8007e0c:	42b2      	cmp	r2, r6
 8007e0e:	6018      	str	r0, [r3, #0]
 8007e10:	6059      	str	r1, [r3, #4]
 8007e12:	4614      	mov	r4, r2
 8007e14:	f103 0308 	add.w	r3, r3, #8
 8007e18:	d1f6      	bne.n	8007e08 <se2_test_trick_pin+0xf0>
 8007e1a:	e025      	b.n	8007e68 <se2_test_trick_pin+0x150>
            }
        } else if(found_slot->tc_flags & TC_XPRV_WALLET) {
 8007e1c:	052e      	lsls	r6, r5, #20
 8007e1e:	d523      	bpl.n	8007e68 <se2_test_trick_pin+0x150>
            // it's an xprv-based wallet
            if(found+2 < NUM_TRICKS) {
 8007e20:	2c0b      	cmp	r4, #11
 8007e22:	dc21      	bgt.n	8007e68 <se2_test_trick_pin+0x150>
                memcpy(&found_slot->xdata[0], &slots[found+1][0], 32);
 8007e24:	1c63      	adds	r3, r4, #1
 8007e26:	eb02 1343 	add.w	r3, r2, r3, lsl #5
 8007e2a:	9a00      	ldr	r2, [sp, #0]
 8007e2c:	f103 0720 	add.w	r7, r3, #32
 8007e30:	3208      	adds	r2, #8
 8007e32:	461e      	mov	r6, r3
 8007e34:	ce03      	ldmia	r6!, {r0, r1}
 8007e36:	42be      	cmp	r6, r7
 8007e38:	6010      	str	r0, [r2, #0]
 8007e3a:	6051      	str	r1, [r2, #4]
 8007e3c:	4633      	mov	r3, r6
 8007e3e:	f102 0208 	add.w	r2, r2, #8
 8007e42:	d1f6      	bne.n	8007e32 <se2_test_trick_pin+0x11a>
                memcpy(&found_slot->xdata[32], &slots[found+2][0], 32);
 8007e44:	ab7c      	add	r3, sp, #496	; 0x1f0
 8007e46:	eb03 1444 	add.w	r4, r3, r4, lsl #5
 8007e4a:	9b00      	ldr	r3, [sp, #0]
 8007e4c:	f5a4 76b0 	sub.w	r6, r4, #352	; 0x160
 8007e50:	3328      	adds	r3, #40	; 0x28
 8007e52:	f5a4 74c0 	sub.w	r4, r4, #384	; 0x180
 8007e56:	4622      	mov	r2, r4
 8007e58:	ca03      	ldmia	r2!, {r0, r1}
 8007e5a:	42b2      	cmp	r2, r6
 8007e5c:	6018      	str	r0, [r3, #0]
 8007e5e:	6059      	str	r1, [r3, #4]
 8007e60:	4614      	mov	r4, r2
 8007e62:	f103 0308 	add.w	r3, r3, #8
 8007e66:	d1f6      	bne.n	8007e56 <se2_test_trick_pin+0x13e>
            }
        }

        if(!safety_mode && todo) {
 8007e68:	9b01      	ldr	r3, [sp, #4]
 8007e6a:	b10b      	cbz	r3, 8007e70 <se2_test_trick_pin+0x158>
                goto fake_out;
            }
            // TC_DELTA_MODE implemented by caller
        }

        return true;
 8007e6c:	2001      	movs	r0, #1
 8007e6e:	e026      	b.n	8007ebe <se2_test_trick_pin+0x1a6>
                memcpy(&found_slot->xdata[0], &slots[found+1][0], 32);
                memcpy(&found_slot->xdata[32], &slots[found+2][0], 32);
            }
        }

        if(!safety_mode && todo) {
 8007e70:	2d00      	cmp	r5, #0
 8007e72:	d0fb      	beq.n	8007e6c <se2_test_trick_pin+0x154>
            puthex4(todo);
            putchar(' ');
#endif

            // code here to brick or wipe
            if(todo & TC_WIPE) {
 8007e74:	0428      	lsls	r0, r5, #16
 8007e76:	d50a      	bpl.n	8007e8e <se2_test_trick_pin+0x176>
                // wipe keys - useful to combine with other stuff
                // .. see below if not combined w/ a fatal action
                mcu_key_clear(NULL);
 8007e78:	9801      	ldr	r0, [sp, #4]
 8007e7a:	f7fa fafd 	bl	8002478 <mcu_key_clear>
                DEBUG("wiped");

                if(todo == TC_WIPE) {
 8007e7e:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
 8007e82:	d104      	bne.n	8007e8e <se2_test_trick_pin+0x176>
                    // we wiped, but no faking it out or rebooting, so
                    // show attacker we are wiped, and die.
                    // - need to still allow WIPE+WALLET case
                    oled_show(screen_wiped);
 8007e84:	4812      	ldr	r0, [pc, #72]	; (8007ed0 <se2_test_trick_pin+0x1b8>)
 8007e86:	f7f8 ffb5 	bl	8000df4 <oled_show>
                    LOCKUP_FOREVER();
 8007e8a:	bf30      	wfi
 8007e8c:	e7fd      	b.n	8007e8a <se2_test_trick_pin+0x172>
                }
            }
            if(todo & TC_BRICK) {
 8007e8e:	0469      	lsls	r1, r5, #17
 8007e90:	d40d      	bmi.n	8007eae <se2_test_trick_pin+0x196>
                fast_brick();
                // NOT REACHED; unit locks up w/ msg shown
            }
            if(todo & TC_REBOOT) {
 8007e92:	05aa      	lsls	r2, r5, #22
 8007e94:	d510      	bpl.n	8007eb8 <se2_test_trick_pin+0x1a0>
 8007e96:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8007e9a:	490e      	ldr	r1, [pc, #56]	; (8007ed4 <se2_test_trick_pin+0x1bc>)
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8007e9c:	4b0e      	ldr	r3, [pc, #56]	; (8007ed8 <se2_test_trick_pin+0x1c0>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8007e9e:	68ca      	ldr	r2, [r1, #12]
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8007ea0:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8007ea4:	4313      	orrs	r3, r2
 8007ea6:	60cb      	str	r3, [r1, #12]
 8007ea8:	f3bf 8f4f 	dsb	sy
 8007eac:	e002      	b.n	8007eb4 <se2_test_trick_pin+0x19c>
                    oled_show(screen_wiped);
                    LOCKUP_FOREVER();
                }
            }
            if(todo & TC_BRICK) {
                fast_brick();
 8007eae:	f7fa fb81 	bl	80025b4 <fast_brick>
 8007eb2:	e7ee      	b.n	8007e92 <se2_test_trick_pin+0x17a>
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 8007eb4:	bf00      	nop
 8007eb6:	e7fd      	b.n	8007eb4 <se2_test_trick_pin+0x19c>
            }
            if(todo & TC_REBOOT) {
                // just reboot, but might look like we wiped secret
                NVIC_SystemReset();
            }
            if(todo & TC_FAKE_OUT) {
 8007eb8:	04ab      	lsls	r3, r5, #18
 8007eba:	d486      	bmi.n	8007dca <se2_test_trick_pin+0xb2>
 8007ebc:	e7d6      	b.n	8007e6c <se2_test_trick_pin+0x154>
        found_slot->slot_num = -1;
        rng_delay();

        return false;
    }
}
 8007ebe:	b07d      	add	sp, #500	; 0x1f4
 8007ec0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8007ec4:	20000288 	.word	0x20000288
 8007ec8:	200002e4 	.word	0x200002e4
 8007ecc:	0801e0b0 	.word	0x0801e0b0
 8007ed0:	0800dd36 	.word	0x0800dd36
 8007ed4:	e000ed00 	.word	0xe000ed00
 8007ed8:	05fa0004 	.word	0x05fa0004
 8007edc:	0801e000 	.word	0x0801e000

08007ee0 <se2_handle_bad_pin>:
// Attacker (or confused owner) has just given a wrong PIN code (didn't match true
// PIN nor any trick PIN)... maybe do something special.
//
    void 
se2_handle_bad_pin(int num_fails)
{
 8007ee0:	b510      	push	{r4, lr}
 8007ee2:	b0a2      	sub	sp, #136	; 0x88
 8007ee4:	4604      	mov	r4, r0
    trick_slot_t    slot;

    bool is_trick = se2_test_trick_pin("!p", 2, &slot, true);
 8007ee6:	2301      	movs	r3, #1
 8007ee8:	aa02      	add	r2, sp, #8
 8007eea:	2102      	movs	r1, #2
 8007eec:	4810      	ldr	r0, [pc, #64]	; (8007f30 <se2_handle_bad_pin+0x50>)
 8007eee:	f7ff ff13 	bl	8007d18 <se2_test_trick_pin>
    if(!is_trick) return;
 8007ef2:	b1d8      	cbz	r0, 8007f2c <se2_handle_bad_pin+0x4c>

    // Are we configured to do something in this case?
    if(num_fails >= slot.tc_arg) {
 8007ef4:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8007ef8:	42a3      	cmp	r3, r4
 8007efa:	dc17      	bgt.n	8007f2c <se2_handle_bad_pin+0x4c>
        if(slot.tc_flags & TC_WIPE) {
 8007efc:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
 8007f00:	2b00      	cmp	r3, #0
 8007f02:	da0d      	bge.n	8007f20 <se2_handle_bad_pin+0x40>
            // Wipe keys and stop. They can power cycle and keep trying
            // so only do this if a valid key currently exists.
            bool valid;
            const mcu_key_t *cur = mcu_key_get(&valid);
 8007f04:	f10d 0007 	add.w	r0, sp, #7
 8007f08:	f7fa fa96 	bl	8002438 <mcu_key_get>

            if(valid) {
 8007f0c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8007f10:	b133      	cbz	r3, 8007f20 <se2_handle_bad_pin+0x40>
                mcu_key_clear(cur);
 8007f12:	f7fa fab1 	bl	8002478 <mcu_key_clear>
                oled_show(screen_wiped);
 8007f16:	4807      	ldr	r0, [pc, #28]	; (8007f34 <se2_handle_bad_pin+0x54>)
 8007f18:	f7f8 ff6c 	bl	8000df4 <oled_show>

                LOCKUP_FOREVER();
 8007f1c:	bf30      	wfi
 8007f1e:	e7fd      	b.n	8007f1c <se2_handle_bad_pin+0x3c>
            }
        }

        if(slot.tc_flags & TC_BRICK) {
 8007f20:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 8007f24:	045b      	lsls	r3, r3, #17
 8007f26:	d501      	bpl.n	8007f2c <se2_handle_bad_pin+0x4c>
            // Not mutually exclusive: if both flags are set, the first
            // time it's triggered the seed will be wiped (and then lockup)
            // Next wrong pin will not have a seed to clear, and so this
            // brick code will happen.
            fast_brick();
 8007f28:	f7fa fb44 	bl	80025b4 <fast_brick>
        }
    }
}
 8007f2c:	b022      	add	sp, #136	; 0x88
 8007f2e:	bd10      	pop	{r4, pc}
 8007f30:	0800e784 	.word	0x0800e784
 8007f34:	0800dd36 	.word	0x0800dd36

08007f38 <se2_save_trick>:
//
// Save trick setup. T if okay
//
    int
se2_save_trick(const trick_slot_t *config)
{
 8007f38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007f3c:	b092      	sub	sp, #72	; 0x48
 8007f3e:	9001      	str	r0, [sp, #4]
    se2_setup();
 8007f40:	f7ff fe3c 	bl	8007bbc <se2_setup>
    if(setjmp(error_env)) {
 8007f44:	4845      	ldr	r0, [pc, #276]	; (800805c <se2_save_trick+0x124>)
 8007f46:	f005 facb 	bl	800d4e0 <setjmp>
 8007f4a:	4604      	mov	r4, r0
 8007f4c:	2800      	cmp	r0, #0
 8007f4e:	d17c      	bne.n	800804a <se2_save_trick+0x112>
        return EPIN_SE2_FAIL;
    }

    if((config->slot_num < 0) || (config->slot_num >= NUM_TRICKS) ) {
 8007f50:	9b01      	ldr	r3, [sp, #4]
 8007f52:	681b      	ldr	r3, [r3, #0]
 8007f54:	2b0d      	cmp	r3, #13
 8007f56:	d87b      	bhi.n	8008050 <se2_save_trick+0x118>
        return EPIN_RANGE_ERR;
    }
    if((config->slot_num >= NUM_TRICKS-1) && (config->tc_flags & TC_WORD_WALLET) ) {
 8007f58:	d104      	bne.n	8007f64 <se2_save_trick+0x2c>
 8007f5a:	9b01      	ldr	r3, [sp, #4]
 8007f5c:	889b      	ldrh	r3, [r3, #4]
 8007f5e:	04d9      	lsls	r1, r3, #19
 8007f60:	d502      	bpl.n	8007f68 <se2_save_trick+0x30>
 8007f62:	e075      	b.n	8008050 <se2_save_trick+0x118>
        // last slot cannot hold a seed-word wallet.
        return EPIN_RANGE_ERR;
    }
    if((config->slot_num >= NUM_TRICKS-2) && (config->tc_flags & TC_XPRV_WALLET) ) {
 8007f64:	2b0c      	cmp	r3, #12
 8007f66:	d103      	bne.n	8007f70 <se2_save_trick+0x38>
 8007f68:	9b01      	ldr	r3, [sp, #4]
 8007f6a:	889b      	ldrh	r3, [r3, #4]
 8007f6c:	051a      	lsls	r2, r3, #20
 8007f6e:	d46f      	bmi.n	8008050 <se2_save_trick+0x118>
        // last slot cannot hold an xprv wallet.
        return EPIN_RANGE_ERR;
    }
    if(config->pin_len > sizeof(config->pin)) {
 8007f70:	9b01      	ldr	r3, [sp, #4]
 8007f72:	6d99      	ldr	r1, [r3, #88]	; 0x58
 8007f74:	2910      	cmp	r1, #16
 8007f76:	d86b      	bhi.n	8008050 <se2_save_trick+0x118>
        return EPIN_RANGE_ERR;
    }

    if(config->blank_slots) {
 8007f78:	6ddd      	ldr	r5, [r3, #92]	; 0x5c
 8007f7a:	b1fd      	cbz	r5, 8007fbc <se2_save_trick+0x84>
        // blank indicated slots
        uint8_t zeros[32] = { 0 };
 8007f7c:	2220      	movs	r2, #32
 8007f7e:	2100      	movs	r1, #0
 8007f80:	a802      	add	r0, sp, #8
 8007f82:	f005 faa4 	bl	800d4ce <memset>

        for(int i=0; i<NUM_TRICKS; i++) {
            uint32_t mask = (1 << i);

            if(mask & config->blank_slots) {
                se2_write_encrypted(PGN_TRICK(i), zeros, 0, SE2_SECRETS->pairing);
 8007f86:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 8008068 <se2_save_trick+0x130>
 8007f8a:	4f35      	ldr	r7, [pc, #212]	; (8008060 <se2_save_trick+0x128>)
 8007f8c:	4e35      	ldr	r6, [pc, #212]	; (8008064 <se2_save_trick+0x12c>)

    if(config->blank_slots) {
        // blank indicated slots
        uint8_t zeros[32] = { 0 };

        for(int i=0; i<NUM_TRICKS; i++) {
 8007f8e:	2500      	movs	r5, #0
            uint32_t mask = (1 << i);

            if(mask & config->blank_slots) {
 8007f90:	9a01      	ldr	r2, [sp, #4]
 8007f92:	2301      	movs	r3, #1
 8007f94:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 8007f96:	40ab      	lsls	r3, r5
 8007f98:	4213      	tst	r3, r2
 8007f9a:	d103      	bne.n	8007fa4 <se2_save_trick+0x6c>

    if(config->blank_slots) {
        // blank indicated slots
        uint8_t zeros[32] = { 0 };

        for(int i=0; i<NUM_TRICKS; i++) {
 8007f9c:	3501      	adds	r5, #1
 8007f9e:	2d0e      	cmp	r5, #14
 8007fa0:	d1f6      	bne.n	8007f90 <se2_save_trick+0x58>
 8007fa2:	e057      	b.n	8008054 <se2_save_trick+0x11c>
            uint32_t mask = (1 << i);

            if(mask & config->blank_slots) {
                se2_write_encrypted(PGN_TRICK(i), zeros, 0, SE2_SECRETS->pairing);
 8007fa4:	f898 30b0 	ldrb.w	r3, [r8, #176]	; 0xb0
 8007fa8:	2200      	movs	r2, #0
 8007faa:	2bff      	cmp	r3, #255	; 0xff
 8007fac:	bf0c      	ite	eq
 8007fae:	463b      	moveq	r3, r7
 8007fb0:	4633      	movne	r3, r6
 8007fb2:	a902      	add	r1, sp, #8
 8007fb4:	b2e8      	uxtb	r0, r5
 8007fb6:	f7ff fa9d 	bl	80074f4 <se2_write_encrypted>
 8007fba:	e7ef      	b.n	8007f9c <se2_save_trick+0x64>
            }
        }
    } else {
        // construct data to save
        uint8_t     tpin_digest[32];
        trick_pin_hash(config->pin, config->pin_len, tpin_digest);
 8007fbc:	9b01      	ldr	r3, [sp, #4]

        memcpy(&tpin_digest[28], &config->tc_flags, 2);
        memcpy(&tpin_digest[30], &config->tc_arg, 2);

        // write into SE2
        se2_write_encrypted(PGN_TRICK(config->slot_num), tpin_digest, 0, SE2_SECRETS->pairing);
 8007fbe:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 8008068 <se2_save_trick+0x130>
 8007fc2:	4f27      	ldr	r7, [pc, #156]	; (8008060 <se2_save_trick+0x128>)
 8007fc4:	4e27      	ldr	r6, [pc, #156]	; (8008064 <se2_save_trick+0x12c>)
            }
        }
    } else {
        // construct data to save
        uint8_t     tpin_digest[32];
        trick_pin_hash(config->pin, config->pin_len, tpin_digest);
 8007fc6:	f103 0048 	add.w	r0, r3, #72	; 0x48
 8007fca:	aa0a      	add	r2, sp, #40	; 0x28
 8007fcc:	f7ff fce8 	bl	80079a0 <trick_pin_hash>

        memcpy(&tpin_digest[28], &config->tc_flags, 2);
 8007fd0:	9b01      	ldr	r3, [sp, #4]
        memcpy(&tpin_digest[30], &config->tc_arg, 2);

        // write into SE2
        se2_write_encrypted(PGN_TRICK(config->slot_num), tpin_digest, 0, SE2_SECRETS->pairing);
 8007fd2:	9801      	ldr	r0, [sp, #4]
    } else {
        // construct data to save
        uint8_t     tpin_digest[32];
        trick_pin_hash(config->pin, config->pin_len, tpin_digest);

        memcpy(&tpin_digest[28], &config->tc_flags, 2);
 8007fd4:	889b      	ldrh	r3, [r3, #4]
 8007fd6:	f8ad 3044 	strh.w	r3, [sp, #68]	; 0x44
        memcpy(&tpin_digest[30], &config->tc_arg, 2);
 8007fda:	9b01      	ldr	r3, [sp, #4]

        // write into SE2
        se2_write_encrypted(PGN_TRICK(config->slot_num), tpin_digest, 0, SE2_SECRETS->pairing);
 8007fdc:	7800      	ldrb	r0, [r0, #0]
        // construct data to save
        uint8_t     tpin_digest[32];
        trick_pin_hash(config->pin, config->pin_len, tpin_digest);

        memcpy(&tpin_digest[28], &config->tc_flags, 2);
        memcpy(&tpin_digest[30], &config->tc_arg, 2);
 8007fde:	88db      	ldrh	r3, [r3, #6]
 8007fe0:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46

        // write into SE2
        se2_write_encrypted(PGN_TRICK(config->slot_num), tpin_digest, 0, SE2_SECRETS->pairing);
 8007fe4:	f898 30b0 	ldrb.w	r3, [r8, #176]	; 0xb0
 8007fe8:	462a      	mov	r2, r5
 8007fea:	2bff      	cmp	r3, #255	; 0xff
 8007fec:	bf0c      	ite	eq
 8007fee:	463b      	moveq	r3, r7
 8007ff0:	4633      	movne	r3, r6
 8007ff2:	a90a      	add	r1, sp, #40	; 0x28
 8007ff4:	f7ff fa7e 	bl	80074f4 <se2_write_encrypted>

        if(config->tc_flags & (TC_WORD_WALLET | TC_XPRV_WALLET)) {
 8007ff8:	9b01      	ldr	r3, [sp, #4]
 8007ffa:	889b      	ldrh	r3, [r3, #4]
 8007ffc:	f403 53c0 	and.w	r3, r3, #6144	; 0x1800
 8008000:	b9a3      	cbnz	r3, 800802c <se2_save_trick+0xf4>
            se2_write_encrypted(PGN_TRICK(config->slot_num+1), &config->xdata[0],
                                                                    0, SE2_SECRETS->pairing);
        }
        if(config->tc_flags & TC_XPRV_WALLET) {
 8008002:	9b01      	ldr	r3, [sp, #4]
 8008004:	889b      	ldrh	r3, [r3, #4]
 8008006:	051b      	lsls	r3, r3, #20
 8008008:	d524      	bpl.n	8008054 <se2_save_trick+0x11c>
            se2_write_encrypted(PGN_TRICK(config->slot_num+2), &config->xdata[32],
 800800a:	9901      	ldr	r1, [sp, #4]
                                                                    0, SE2_SECRETS->pairing);
 800800c:	4b16      	ldr	r3, [pc, #88]	; (8008068 <se2_save_trick+0x130>)
        if(config->tc_flags & (TC_WORD_WALLET | TC_XPRV_WALLET)) {
            se2_write_encrypted(PGN_TRICK(config->slot_num+1), &config->xdata[0],
                                                                    0, SE2_SECRETS->pairing);
        }
        if(config->tc_flags & TC_XPRV_WALLET) {
            se2_write_encrypted(PGN_TRICK(config->slot_num+2), &config->xdata[32],
 800800e:	f851 0b28 	ldr.w	r0, [r1], #40
                                                                    0, SE2_SECRETS->pairing);
 8008012:	f893 50b0 	ldrb.w	r5, [r3, #176]	; 0xb0
        if(config->tc_flags & (TC_WORD_WALLET | TC_XPRV_WALLET)) {
            se2_write_encrypted(PGN_TRICK(config->slot_num+1), &config->xdata[0],
                                                                    0, SE2_SECRETS->pairing);
        }
        if(config->tc_flags & TC_XPRV_WALLET) {
            se2_write_encrypted(PGN_TRICK(config->slot_num+2), &config->xdata[32],
 8008016:	4a13      	ldr	r2, [pc, #76]	; (8008064 <se2_save_trick+0x12c>)
 8008018:	4b11      	ldr	r3, [pc, #68]	; (8008060 <se2_save_trick+0x128>)
 800801a:	3002      	adds	r0, #2
 800801c:	2dff      	cmp	r5, #255	; 0xff
 800801e:	bf18      	it	ne
 8008020:	4613      	movne	r3, r2
 8008022:	b2c0      	uxtb	r0, r0
 8008024:	2200      	movs	r2, #0
 8008026:	f7ff fa65 	bl	80074f4 <se2_write_encrypted>
 800802a:	e013      	b.n	8008054 <se2_save_trick+0x11c>

        // write into SE2
        se2_write_encrypted(PGN_TRICK(config->slot_num), tpin_digest, 0, SE2_SECRETS->pairing);

        if(config->tc_flags & (TC_WORD_WALLET | TC_XPRV_WALLET)) {
            se2_write_encrypted(PGN_TRICK(config->slot_num+1), &config->xdata[0],
 800802c:	9901      	ldr	r1, [sp, #4]
                                                                    0, SE2_SECRETS->pairing);
 800802e:	f898 30b0 	ldrb.w	r3, [r8, #176]	; 0xb0

        // write into SE2
        se2_write_encrypted(PGN_TRICK(config->slot_num), tpin_digest, 0, SE2_SECRETS->pairing);

        if(config->tc_flags & (TC_WORD_WALLET | TC_XPRV_WALLET)) {
            se2_write_encrypted(PGN_TRICK(config->slot_num+1), &config->xdata[0],
 8008032:	f851 0b08 	ldr.w	r0, [r1], #8
 8008036:	3001      	adds	r0, #1
 8008038:	2bff      	cmp	r3, #255	; 0xff
 800803a:	bf0c      	ite	eq
 800803c:	463b      	moveq	r3, r7
 800803e:	4633      	movne	r3, r6
 8008040:	462a      	mov	r2, r5
 8008042:	b2c0      	uxtb	r0, r0
 8008044:	f7ff fa56 	bl	80074f4 <se2_write_encrypted>
 8008048:	e7db      	b.n	8008002 <se2_save_trick+0xca>
    int
se2_save_trick(const trick_slot_t *config)
{
    se2_setup();
    if(setjmp(error_env)) {
        return EPIN_SE2_FAIL;
 800804a:	f06f 0472 	mvn.w	r4, #114	; 0x72
 800804e:	e001      	b.n	8008054 <se2_save_trick+0x11c>
    }

    if((config->slot_num < 0) || (config->slot_num >= NUM_TRICKS) ) {
        return EPIN_RANGE_ERR;
 8008050:	f06f 0466 	mvn.w	r4, #102	; 0x66
                                                                    0, SE2_SECRETS->pairing);
        }
    }

    return 0;
}
 8008054:	4620      	mov	r0, r4
 8008056:	b012      	add	sp, #72	; 0x48
 8008058:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800805c:	20000288 	.word	0x20000288
 8008060:	200002e4 	.word	0x200002e4
 8008064:	0801e0b0 	.word	0x0801e0b0
 8008068:	0801e000 	.word	0x0801e000

0800806c <se2_encrypt_secret>:
//
    bool
se2_encrypt_secret(const uint8_t secret[], int secret_len, int offset, 
    uint8_t main_slot[], uint8_t *check_value,
    const uint8_t pin_digest[32])
{
 800806c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008070:	f5ad 7d11 	sub.w	sp, sp, #580	; 0x244
 8008074:	469a      	mov	sl, r3
 8008076:	4683      	mov	fp, r0
 8008078:	4689      	mov	r9, r1
 800807a:	4690      	mov	r8, r2
 800807c:	9f9a      	ldr	r7, [sp, #616]	; 0x268
    se2_setup();
 800807e:	f7ff fd9d 	bl	8007bbc <se2_setup>

    bool is_valid;
    const mcu_key_t *cur = mcu_key_get(&is_valid);
 8008082:	f10d 000b 	add.w	r0, sp, #11
 8008086:	f7fa f9d7 	bl	8002438 <mcu_key_get>

    if(!is_valid) {
 800808a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800808e:	b923      	cbnz	r3, 800809a <se2_encrypt_secret+0x2e>
        if(!check_value) {
 8008090:	b90f      	cbnz	r7, 8008096 <se2_encrypt_secret+0x2a>
            // problem: we are not writing the check value but it would be changed.
            // ie: change long secret before real secret--unlikely
            return true;
 8008092:	2601      	movs	r6, #1
 8008094:	e032      	b.n	80080fc <se2_encrypt_secret+0x90>
        }

        // pick a fresh MCU key if we don't have one; can do that
        // because we are encryption and saving (presumably for first time)
        // - will become a brick if no more slots
        cur = mcu_key_pick();     
 8008096:	f7fa fa31 	bl	80024fc <mcu_key_pick>
    }

    uint8_t aes_key[32];
    if(se2_calc_seed_key(aes_key, cur, pin_digest)) return true;
 800809a:	4601      	mov	r1, r0
 800809c:	9a9b      	ldr	r2, [sp, #620]	; 0x26c
 800809e:	a807      	add	r0, sp, #28
 80080a0:	f7ff fd5a 	bl	8007b58 <se2_calc_seed_key>
 80080a4:	4606      	mov	r6, r0
 80080a6:	2800      	cmp	r0, #0
 80080a8:	d1f3      	bne.n	8008092 <se2_encrypt_secret+0x26>

    uint8_t nonce[16];
    memcpy(nonce, rom_secrets->mcu_hmac_key, sizeof(nonce)-1);
 80080aa:	4b17      	ldr	r3, [pc, #92]	; (8008108 <se2_encrypt_secret+0x9c>)
 80080ac:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80080ae:	ad03      	add	r5, sp, #12
 80080b0:	462c      	mov	r4, r5
 80080b2:	c407      	stmia	r4!, {r0, r1, r2}
 80080b4:	f824 3b02 	strh.w	r3, [r4], #2
 80080b8:	0c1b      	lsrs	r3, r3, #16
 80080ba:	7023      	strb	r3, [r4, #0]
    nonce[15] = offset / AES_BLOCK_SIZE;

    // encrypt the secret
    AES_CTX ctx;
    aes_init(&ctx);
 80080bc:	a80f      	add	r0, sp, #60	; 0x3c
    uint8_t aes_key[32];
    if(se2_calc_seed_key(aes_key, cur, pin_digest)) return true;

    uint8_t nonce[16];
    memcpy(nonce, rom_secrets->mcu_hmac_key, sizeof(nonce)-1);
    nonce[15] = offset / AES_BLOCK_SIZE;
 80080be:	2310      	movs	r3, #16
 80080c0:	fb98 f8f3 	sdiv	r8, r8, r3
 80080c4:	f88d 801b 	strb.w	r8, [sp, #27]

    // encrypt the secret
    AES_CTX ctx;
    aes_init(&ctx);
 80080c8:	f000 f886 	bl	80081d8 <aes_init>
    aes_add(&ctx, secret, secret_len);
 80080cc:	464a      	mov	r2, r9
 80080ce:	4659      	mov	r1, fp
 80080d0:	a80f      	add	r0, sp, #60	; 0x3c
 80080d2:	f000 f887 	bl	80081e4 <aes_add>
    aes_done(&ctx, main_slot, secret_len, aes_key, nonce);
 80080d6:	9500      	str	r5, [sp, #0]
 80080d8:	ab07      	add	r3, sp, #28
 80080da:	464a      	mov	r2, r9
 80080dc:	4651      	mov	r1, sl
 80080de:	a80f      	add	r0, sp, #60	; 0x3c
 80080e0:	f000 f896 	bl	8008210 <aes_done>

    if(check_value) {
 80080e4:	b157      	cbz	r7, 80080fc <se2_encrypt_secret+0x90>
        // encrypt the check value: 32 zeros
        aes_init(&ctx);
 80080e6:	a80f      	add	r0, sp, #60	; 0x3c
 80080e8:	f000 f876 	bl	80081d8 <aes_init>
        ctx.num_pending = 32;
 80080ec:	2220      	movs	r2, #32
        aes_done(&ctx, check_value, 32, aes_key, nonce);
 80080ee:	9500      	str	r5, [sp, #0]
 80080f0:	ab07      	add	r3, sp, #28
 80080f2:	4639      	mov	r1, r7
 80080f4:	a80f      	add	r0, sp, #60	; 0x3c
    aes_done(&ctx, main_slot, secret_len, aes_key, nonce);

    if(check_value) {
        // encrypt the check value: 32 zeros
        aes_init(&ctx);
        ctx.num_pending = 32;
 80080f6:	928f      	str	r2, [sp, #572]	; 0x23c
        aes_done(&ctx, check_value, 32, aes_key, nonce);
 80080f8:	f000 f88a 	bl	8008210 <aes_done>
    }

    return false;
}
 80080fc:	4630      	mov	r0, r6
 80080fe:	f50d 7d11 	add.w	sp, sp, #580	; 0x244
 8008102:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008106:	bf00      	nop
 8008108:	0801e090 	.word	0x0801e090

0800810c <se2_decrypt_secret>:
//
    void
se2_decrypt_secret(uint8_t secret[], int secret_len, int offset,
        const uint8_t main_slot[], const uint8_t *check_value,
        const uint8_t pin_digest[32], bool *is_valid)
{
 800810c:	b530      	push	{r4, r5, lr}
 800810e:	f5ad 7d1f 	sub.w	sp, sp, #636	; 0x27c
 8008112:	9307      	str	r3, [sp, #28]
 8008114:	9005      	str	r0, [sp, #20]
 8008116:	9103      	str	r1, [sp, #12]
 8008118:	9206      	str	r2, [sp, #24]
    se2_setup();
 800811a:	f7ff fd4f 	bl	8007bbc <se2_setup>

    const mcu_key_t *cur = mcu_key_get(is_valid);
 800811e:	98a4      	ldr	r0, [sp, #656]	; 0x290
 8008120:	f7fa f98a 	bl	8002438 <mcu_key_get>
    if(!*is_valid) {
 8008124:	9ba4      	ldr	r3, [sp, #656]	; 0x290
        const uint8_t main_slot[], const uint8_t *check_value,
        const uint8_t pin_digest[32], bool *is_valid)
{
    se2_setup();

    const mcu_key_t *cur = mcu_key_get(is_valid);
 8008126:	9004      	str	r0, [sp, #16]
    if(!*is_valid) {
 8008128:	781b      	ldrb	r3, [r3, #0]
 800812a:	2b00      	cmp	r3, #0
 800812c:	d046      	beq.n	80081bc <se2_decrypt_secret+0xb0>
        // no key set? won't be able to decrypt.
        return;
    }

    int line_num;
    if((line_num = setjmp(error_env))) {
 800812e:	4825      	ldr	r0, [pc, #148]	; (80081c4 <se2_decrypt_secret+0xb8>)
 8008130:	f005 f9d6 	bl	800d4e0 <setjmp>
 8008134:	b118      	cbz	r0, 800813e <se2_decrypt_secret+0x32>
        // internal failures / broken i2c buses will come here
        //puts2("se2_decrypt_secret: se2.c:"); putdec4(line_num); putchar('\n');
        *is_valid = false;
 8008136:	9aa4      	ldr	r2, [sp, #656]	; 0x290
 8008138:	2300      	movs	r3, #0
 800813a:	7013      	strb	r3, [r2, #0]
        return;
 800813c:	e03e      	b.n	80081bc <se2_decrypt_secret+0xb0>
    }

    AES_CTX ctx;
    uint8_t aes_key[32];
    if(se2_calc_seed_key(aes_key, cur, pin_digest)) {
 800813e:	9aa3      	ldr	r2, [sp, #652]	; 0x28c
 8008140:	9904      	ldr	r1, [sp, #16]
 8008142:	a80d      	add	r0, sp, #52	; 0x34
 8008144:	f7ff fd08 	bl	8007b58 <se2_calc_seed_key>
 8008148:	2800      	cmp	r0, #0
 800814a:	d1f4      	bne.n	8008136 <se2_decrypt_secret+0x2a>
        *is_valid = false;
        return;
    }

    uint8_t nonce[16];
    memcpy(nonce, rom_secrets->mcu_hmac_key, sizeof(nonce)-1);
 800814c:	4b1e      	ldr	r3, [pc, #120]	; (80081c8 <se2_decrypt_secret+0xbc>)
 800814e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8008150:	ad09      	add	r5, sp, #36	; 0x24
 8008152:	462c      	mov	r4, r5
 8008154:	c407      	stmia	r4!, {r0, r1, r2}
 8008156:	f824 3b02 	strh.w	r3, [r4], #2
 800815a:	0c1b      	lsrs	r3, r3, #16
 800815c:	7023      	strb	r3, [r4, #0]
    nonce[15] = offset / AES_BLOCK_SIZE;
 800815e:	9a06      	ldr	r2, [sp, #24]
 8008160:	2310      	movs	r3, #16
 8008162:	fb92 f3f3 	sdiv	r3, r2, r3
 8008166:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33

    if(check_value) {
 800816a:	9ba2      	ldr	r3, [sp, #648]	; 0x288
 800816c:	b1b3      	cbz	r3, 800819c <se2_decrypt_secret+0x90>
        // decrypt the check value
        aes_init(&ctx);
 800816e:	a81d      	add	r0, sp, #116	; 0x74
 8008170:	f000 f832 	bl	80081d8 <aes_init>
        aes_add(&ctx, check_value, 32);
 8008174:	2220      	movs	r2, #32
 8008176:	99a2      	ldr	r1, [sp, #648]	; 0x288
 8008178:	a81d      	add	r0, sp, #116	; 0x74
 800817a:	f000 f833 	bl	80081e4 <aes_add>
        uint8_t got[32];
        aes_done(&ctx, got, 32, aes_key, nonce);
 800817e:	a915      	add	r1, sp, #84	; 0x54
 8008180:	a81d      	add	r0, sp, #116	; 0x74
 8008182:	9500      	str	r5, [sp, #0]
 8008184:	ab0d      	add	r3, sp, #52	; 0x34
 8008186:	2220      	movs	r2, #32
 8008188:	f000 f842 	bl	8008210 <aes_done>

        // does it work?
        if(!check_all_zeros(got, 32)) {
 800818c:	2120      	movs	r1, #32
 800818e:	a815      	add	r0, sp, #84	; 0x54
 8008190:	f7fa fa5e 	bl	8002650 <check_all_zeros>
 8008194:	b910      	cbnz	r0, 800819c <se2_decrypt_secret+0x90>
            DEBUG("bad chk");
            *is_valid = false;
 8008196:	9ba4      	ldr	r3, [sp, #656]	; 0x290
 8008198:	7018      	strb	r0, [r3, #0]
 800819a:	e00f      	b.n	80081bc <se2_decrypt_secret+0xb0>
            return;
        }
    }

    // decrypt the real data
    aes_init(&ctx);
 800819c:	a81d      	add	r0, sp, #116	; 0x74
 800819e:	f000 f81b 	bl	80081d8 <aes_init>
    aes_add(&ctx, main_slot, secret_len);
 80081a2:	9a03      	ldr	r2, [sp, #12]
 80081a4:	9907      	ldr	r1, [sp, #28]
 80081a6:	a81d      	add	r0, sp, #116	; 0x74
 80081a8:	f000 f81c 	bl	80081e4 <aes_add>
    aes_done(&ctx, secret, secret_len, aes_key, nonce);
 80081ac:	ab09      	add	r3, sp, #36	; 0x24
 80081ae:	9300      	str	r3, [sp, #0]
 80081b0:	9a03      	ldr	r2, [sp, #12]
 80081b2:	9905      	ldr	r1, [sp, #20]
 80081b4:	ab0d      	add	r3, sp, #52	; 0x34
 80081b6:	a81d      	add	r0, sp, #116	; 0x74
 80081b8:	f000 f82a 	bl	8008210 <aes_done>
}
 80081bc:	f50d 7d1f 	add.w	sp, sp, #636	; 0x27c
 80081c0:	bd30      	pop	{r4, r5, pc}
 80081c2:	bf00      	nop
 80081c4:	20000288 	.word	0x20000288
 80081c8:	0801e090 	.word	0x0801e090

080081cc <word_pump_bytes>:
    uint32_t rv;

    if(((uint32_t)src) & 0x3) {
        memcpy(&rv, *src, 4);
    } else {
        rv = *(uint32_t *)(*src);
 80081cc:	6803      	ldr	r3, [r0, #0]
 80081ce:	f853 2b04 	ldr.w	r2, [r3], #4
    }
    (*src) += 4;
 80081d2:	6003      	str	r3, [r0, #0]

    return __REV(rv);
}
 80081d4:	ba10      	rev	r0, r2
 80081d6:	4770      	bx	lr

080081d8 <aes_init>:
// aes_init()
//
    void
aes_init(AES_CTX *ctx)
{
    memset(ctx, 0, sizeof(AES_CTX));
 80081d8:	f44f 7201 	mov.w	r2, #516	; 0x204
 80081dc:	2100      	movs	r1, #0
 80081de:	f005 b976 	b.w	800d4ce <memset>
	...

080081e4 <aes_add>:
//
// - capture more data to be encrypted/decrypted
//
    void
aes_add(AES_CTX *ctx, const uint8_t data_in[], uint32_t len)
{
 80081e4:	b538      	push	{r3, r4, r5, lr}
 80081e6:	4604      	mov	r4, r0
    memcpy(ctx->pending+ctx->num_pending, data_in, len);
 80081e8:	f8d0 0200 	ldr.w	r0, [r0, #512]	; 0x200
 80081ec:	4420      	add	r0, r4
//
// - capture more data to be encrypted/decrypted
//
    void
aes_add(AES_CTX *ctx, const uint8_t data_in[], uint32_t len)
{
 80081ee:	4615      	mov	r5, r2
    memcpy(ctx->pending+ctx->num_pending, data_in, len);
 80081f0:	f005 f947 	bl	800d482 <memcpy>
    ctx->num_pending += len;
 80081f4:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
 80081f8:	442a      	add	r2, r5

    ASSERT(ctx->num_pending < sizeof(ctx->pending));
 80081fa:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
//
    void
aes_add(AES_CTX *ctx, const uint8_t data_in[], uint32_t len)
{
    memcpy(ctx->pending+ctx->num_pending, data_in, len);
    ctx->num_pending += len;
 80081fe:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200

    ASSERT(ctx->num_pending < sizeof(ctx->pending));
 8008202:	d302      	bcc.n	800820a <aes_add+0x26>
 8008204:	4801      	ldr	r0, [pc, #4]	; (800820c <aes_add+0x28>)
 8008206:	f7f8 fbe9 	bl	80009dc <fatal_error>
 800820a:	bd38      	pop	{r3, r4, r5, pc}
 800820c:	0800d558 	.word	0x0800d558

08008210 <aes_done>:
//
// Do the decryption.
//
    void
aes_done(AES_CTX *ctx, uint8_t data_out[], uint32_t len, const uint8_t key[32], const uint8_t nonce[AES_BLOCK_SIZE])
{
 8008210:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8008214:	4690      	mov	r8, r2
    ASSERT(len <= ctx->num_pending);
 8008216:	f8d0 2200 	ldr.w	r2, [r0, #512]	; 0x200
//
// Do the decryption.
//
    void
aes_done(AES_CTX *ctx, uint8_t data_out[], uint32_t len, const uint8_t key[32], const uint8_t nonce[AES_BLOCK_SIZE])
{
 800821a:	b085      	sub	sp, #20
    ASSERT(len <= ctx->num_pending);
 800821c:	4542      	cmp	r2, r8
//
// Do the decryption.
//
    void
aes_done(AES_CTX *ctx, uint8_t data_out[], uint32_t len, const uint8_t key[32], const uint8_t nonce[AES_BLOCK_SIZE])
{
 800821e:	4606      	mov	r6, r0
 8008220:	460f      	mov	r7, r1
 8008222:	f8dd 9030 	ldr.w	r9, [sp, #48]	; 0x30
    ASSERT(len <= ctx->num_pending);
 8008226:	d202      	bcs.n	800822e <aes_done+0x1e>
 8008228:	4855      	ldr	r0, [pc, #340]	; (8008380 <aes_done+0x170>)
 800822a:	f7f8 fbd7 	bl	80009dc <fatal_error>

    // enable clock to block
    __HAL_RCC_AES_CLK_ENABLE();
 800822e:	4c55      	ldr	r4, [pc, #340]	; (8008384 <aes_done+0x174>)

    // most changes have to be made w/ module disabled
    AES->CR &= ~AES_CR_EN;
 8008230:	4955      	ldr	r1, [pc, #340]	; (8008388 <aes_done+0x178>)
aes_done(AES_CTX *ctx, uint8_t data_out[], uint32_t len, const uint8_t key[32], const uint8_t nonce[AES_BLOCK_SIZE])
{
    ASSERT(len <= ctx->num_pending);

    // enable clock to block
    __HAL_RCC_AES_CLK_ENABLE();
 8008232:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 8008234:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8008238:	64e2      	str	r2, [r4, #76]	; 0x4c
 800823a:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 800823c:	f402 3280 	and.w	r2, r2, #65536	; 0x10000
 8008240:	9201      	str	r2, [sp, #4]
 8008242:	9a01      	ldr	r2, [sp, #4]

    // most changes have to be made w/ module disabled
    AES->CR &= ~AES_CR_EN;
 8008244:	680a      	ldr	r2, [r1, #0]
 8008246:	f022 0201 	bic.w	r2, r2, #1
 800824a:	600a      	str	r2, [r1, #0]

    // set the key size and operation mode
    MODIFY_REG(AES->CR, AES_CR_KEYSIZE, CRYP_KEYSIZE_256B);
 800824c:	680a      	ldr	r2, [r1, #0]
 800824e:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8008252:	600a      	str	r2, [r1, #0]
    MODIFY_REG(AES->CR, AES_CR_DATATYPE|AES_CR_MODE|AES_CR_CHMOD, 
 8008254:	680a      	ldr	r2, [r1, #0]
 8008256:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
            CRYP_DATATYPE_8B | CRYP_ALGOMODE_ENCRYPT | CRYP_CHAINMODE_AES_CTR);

    // load key and IV values
    const uint8_t *K = key;
 800825a:	ad04      	add	r5, sp, #16
    // most changes have to be made w/ module disabled
    AES->CR &= ~AES_CR_EN;

    // set the key size and operation mode
    MODIFY_REG(AES->CR, AES_CR_KEYSIZE, CRYP_KEYSIZE_256B);
    MODIFY_REG(AES->CR, AES_CR_DATATYPE|AES_CR_MODE|AES_CR_CHMOD, 
 800825c:	f022 027e 	bic.w	r2, r2, #126	; 0x7e
 8008260:	f042 0244 	orr.w	r2, r2, #68	; 0x44
 8008264:	600a      	str	r2, [r1, #0]
            CRYP_DATATYPE_8B | CRYP_ALGOMODE_ENCRYPT | CRYP_CHAINMODE_AES_CTR);

    // load key and IV values
    const uint8_t *K = key;
 8008266:	f845 3d08 	str.w	r3, [r5, #-8]!
    AES->KEYR7 = word_pump_bytes(&K);
 800826a:	4628      	mov	r0, r5
 800826c:	f7ff ffae 	bl	80081cc <word_pump_bytes>
 8008270:	63c8      	str	r0, [r1, #60]	; 0x3c
    AES->KEYR6 = word_pump_bytes(&K);
 8008272:	4628      	mov	r0, r5
 8008274:	f7ff ffaa 	bl	80081cc <word_pump_bytes>
 8008278:	6388      	str	r0, [r1, #56]	; 0x38
    AES->KEYR5 = word_pump_bytes(&K);
 800827a:	4628      	mov	r0, r5
 800827c:	f7ff ffa6 	bl	80081cc <word_pump_bytes>
 8008280:	6348      	str	r0, [r1, #52]	; 0x34
    AES->KEYR4 = word_pump_bytes(&K);
 8008282:	4628      	mov	r0, r5
 8008284:	f7ff ffa2 	bl	80081cc <word_pump_bytes>
 8008288:	6308      	str	r0, [r1, #48]	; 0x30
    AES->KEYR3 = word_pump_bytes(&K);
 800828a:	4628      	mov	r0, r5
 800828c:	f7ff ff9e 	bl	80081cc <word_pump_bytes>
 8008290:	61c8      	str	r0, [r1, #28]
    AES->KEYR2 = word_pump_bytes(&K);
 8008292:	4628      	mov	r0, r5
 8008294:	f7ff ff9a 	bl	80081cc <word_pump_bytes>
 8008298:	6188      	str	r0, [r1, #24]
    AES->KEYR1 = word_pump_bytes(&K);
 800829a:	4628      	mov	r0, r5
 800829c:	f7ff ff96 	bl	80081cc <word_pump_bytes>
 80082a0:	6148      	str	r0, [r1, #20]
    AES->KEYR0 = word_pump_bytes(&K);
 80082a2:	4628      	mov	r0, r5
 80082a4:	f7ff ff92 	bl	80081cc <word_pump_bytes>
 80082a8:	6108      	str	r0, [r1, #16]

    if(nonce) {
 80082aa:	f1b9 0f00 	cmp.w	r9, #0
 80082ae:	d013      	beq.n	80082d8 <aes_done+0xc8>
        const uint8_t *N = nonce;
 80082b0:	ad04      	add	r5, sp, #16
 80082b2:	f845 9d04 	str.w	r9, [r5, #-4]!
        AES->IVR3 = word_pump_bytes(&N);
 80082b6:	4628      	mov	r0, r5
 80082b8:	f7ff ff88 	bl	80081cc <word_pump_bytes>
 80082bc:	62c8      	str	r0, [r1, #44]	; 0x2c
        AES->IVR2 = word_pump_bytes(&N);
 80082be:	4628      	mov	r0, r5
 80082c0:	f7ff ff84 	bl	80081cc <word_pump_bytes>
 80082c4:	6288      	str	r0, [r1, #40]	; 0x28
        AES->IVR1 = word_pump_bytes(&N);
 80082c6:	4628      	mov	r0, r5
 80082c8:	f7ff ff80 	bl	80081cc <word_pump_bytes>
 80082cc:	6248      	str	r0, [r1, #36]	; 0x24
        AES->IVR0 = word_pump_bytes(&N);
 80082ce:	4628      	mov	r0, r5
 80082d0:	f7ff ff7c 	bl	80081cc <word_pump_bytes>
 80082d4:	6208      	str	r0, [r1, #32]
 80082d6:	e007      	b.n	80082e8 <aes_done+0xd8>
    } else {
        AES->IVR3 = 0;
 80082d8:	f8c1 902c 	str.w	r9, [r1, #44]	; 0x2c
        AES->IVR2 = 0;
 80082dc:	f8c1 9028 	str.w	r9, [r1, #40]	; 0x28
        AES->IVR1 = 0;
 80082e0:	f8c1 9024 	str.w	r9, [r1, #36]	; 0x24
        AES->IVR0 = 0;          // maybe should be byte-swapped one, but whatever
 80082e4:	f8c1 9020 	str.w	r9, [r1, #32]
    }

    // Enable the Peripheral
    AES->CR |= AES_CR_EN;
 80082e8:	4a27      	ldr	r2, [pc, #156]	; (8008388 <aes_done+0x178>)

    ASSERT((((uint32_t)&ctx->pending) & 3) == 0);      // safe because of special attr

    uint32_t    *p = (uint32_t *)ctx->pending;
    for(int i=0; i < ctx->num_pending; i += 16) {
 80082ea:	f8d6 0200 	ldr.w	r0, [r6, #512]	; 0x200
        AES->IVR1 = 0;
        AES->IVR0 = 0;          // maybe should be byte-swapped one, but whatever
    }

    // Enable the Peripheral
    AES->CR |= AES_CR_EN;
 80082ee:	6813      	ldr	r3, [r2, #0]
 80082f0:	f043 0301 	orr.w	r3, r3, #1
 80082f4:	6013      	str	r3, [r2, #0]
 80082f6:	4615      	mov	r5, r2

    ASSERT((((uint32_t)&ctx->pending) & 3) == 0);      // safe because of special attr

    uint32_t    *p = (uint32_t *)ctx->pending;
 80082f8:	4633      	mov	r3, r6
    for(int i=0; i < ctx->num_pending; i += 16) {
 80082fa:	1b99      	subs	r1, r3, r6
 80082fc:	4281      	cmp	r1, r0
 80082fe:	da1c      	bge.n	800833a <aes_done+0x12a>
        // Write the block to the AES engine
        AES->DINR = *p; p++;
 8008300:	6819      	ldr	r1, [r3, #0]
 8008302:	6091      	str	r1, [r2, #8]
        AES->DINR = *p; p++;
 8008304:	6859      	ldr	r1, [r3, #4]
 8008306:	6091      	str	r1, [r2, #8]
        AES->DINR = *p; p++;
 8008308:	6899      	ldr	r1, [r3, #8]
 800830a:	6091      	str	r1, [r2, #8]
        AES->DINR = *p; p++;
 800830c:	68d9      	ldr	r1, [r3, #12]
 800830e:	6091      	str	r1, [r2, #8]
 8008310:	3310      	adds	r3, #16

        // Wait for CCF flag to be raised
        while(HAL_IS_BIT_CLR(AES->SR, AES_SR_CCF)) {
 8008312:	6869      	ldr	r1, [r5, #4]
 8008314:	07c9      	lsls	r1, r1, #31
 8008316:	d5fc      	bpl.n	8008312 <aes_done+0x102>
            // no timeout -- just 75 cycles?
        }

        // clear CCF flag
        SET_BIT(AES->CR, CRYP_CCF_CLEAR);
 8008318:	6829      	ldr	r1, [r5, #0]
 800831a:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 800831e:	6029      	str	r1, [r5, #0]

        // work in place, overwrite what we just wrote
        uint32_t    *out = p - 4;
        *out = AES->DOUTR; out++;
 8008320:	68e9      	ldr	r1, [r5, #12]
 8008322:	f843 1c10 	str.w	r1, [r3, #-16]
        *out = AES->DOUTR; out++;
 8008326:	68e9      	ldr	r1, [r5, #12]
 8008328:	f843 1c0c 	str.w	r1, [r3, #-12]
        *out = AES->DOUTR; out++;
 800832c:	68e9      	ldr	r1, [r5, #12]
 800832e:	f843 1c08 	str.w	r1, [r3, #-8]
        *out = AES->DOUTR;
 8008332:	68e9      	ldr	r1, [r5, #12]
 8008334:	f843 1c04 	str.w	r1, [r3, #-4]
 8008338:	e7df      	b.n	80082fa <aes_done+0xea>
    }

    memcpy(data_out, ctx->pending, len);
 800833a:	4642      	mov	r2, r8
 800833c:	4631      	mov	r1, r6
 800833e:	4638      	mov	r0, r7
 8008340:	f005 f89f 	bl	800d482 <memcpy>

    memset(ctx, 0, sizeof(AES_CTX));
 8008344:	f44f 7201 	mov.w	r2, #516	; 0x204
 8008348:	2100      	movs	r1, #0
 800834a:	4630      	mov	r0, r6
 800834c:	f005 f8bf 	bl	800d4ce <memset>

    // reset state of chip block, and leave clock off as well
    __HAL_RCC_AES_CLK_ENABLE();
 8008350:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8008352:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8008356:	64e3      	str	r3, [r4, #76]	; 0x4c
 8008358:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800835a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800835e:	9303      	str	r3, [sp, #12]
 8008360:	9b03      	ldr	r3, [sp, #12]
    __HAL_RCC_AES_FORCE_RESET();
 8008362:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8008364:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8008368:	62e3      	str	r3, [r4, #44]	; 0x2c
    __HAL_RCC_AES_RELEASE_RESET();
 800836a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800836c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8008370:	62e3      	str	r3, [r4, #44]	; 0x2c
    __HAL_RCC_AES_CLK_DISABLE();
 8008372:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8008374:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8008378:	64e3      	str	r3, [r4, #76]	; 0x4c
}
 800837a:	b005      	add	sp, #20
 800837c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8008380:	0800d558 	.word	0x0800d558
 8008384:	40021000 	.word	0x40021000
 8008388:	50060000 	.word	0x50060000

0800838c <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 800838c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint32_t vos;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */

  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 800838e:	4d1c      	ldr	r5, [pc, #112]	; (8008400 <RCC_SetFlashLatencyFromMSIRange+0x74>)
 8008390:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8008392:	00d9      	lsls	r1, r3, #3
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 8008394:	4604      	mov	r4, r0
  uint32_t vos;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */

  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8008396:	d502      	bpl.n	800839e <RCC_SetFlashLatencyFromMSIRange+0x12>
  {
    vos = HAL_PWREx_GetVoltageRange();
 8008398:	f7fe fe40 	bl	800701c <HAL_PWREx_GetVoltageRange>
 800839c:	e00e      	b.n	80083bc <RCC_SetFlashLatencyFromMSIRange+0x30>
  }
  else
  {
    __HAL_RCC_PWR_CLK_ENABLE();
 800839e:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80083a0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80083a4:	65ab      	str	r3, [r5, #88]	; 0x58
 80083a6:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80083a8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80083ac:	9301      	str	r3, [sp, #4]
 80083ae:	9b01      	ldr	r3, [sp, #4]
    vos = HAL_PWREx_GetVoltageRange();
 80083b0:	f7fe fe34 	bl	800701c <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
 80083b4:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80083b6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80083ba:	65ab      	str	r3, [r5, #88]	; 0x58
  }

  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 80083bc:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 80083c0:	d106      	bne.n	80083d0 <RCC_SetFlashLatencyFromMSIRange+0x44>
  {
    if(msirange > RCC_MSIRANGE_8)
 80083c2:	2c80      	cmp	r4, #128	; 0x80
 80083c4:	d90b      	bls.n	80083de <RCC_SetFlashLatencyFromMSIRange+0x52>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
 80083c6:	2ca0      	cmp	r4, #160	; 0xa0
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else
      {
        /* MSI 24Mhz or 32Mhz */
        latency = FLASH_LATENCY_1; /* 1WS */
 80083c8:	bf8c      	ite	hi
 80083ca:	2302      	movhi	r3, #2
 80083cc:	2301      	movls	r3, #1
 80083ce:	e009      	b.n	80083e4 <RCC_SetFlashLatencyFromMSIRange+0x58>
  }
  else
  {
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
    defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    if(msirange >= RCC_MSIRANGE_8)
 80083d0:	2c7f      	cmp	r4, #127	; 0x7f
 80083d2:	d806      	bhi.n	80083e2 <RCC_SetFlashLatencyFromMSIRange+0x56>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
      {
        /* MSI 48Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
 80083d4:	f1a4 0270 	sub.w	r2, r4, #112	; 0x70
 80083d8:	4253      	negs	r3, r2
 80083da:	4153      	adcs	r3, r2
 80083dc:	e002      	b.n	80083e4 <RCC_SetFlashLatencyFromMSIRange+0x58>
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
  uint32_t vos;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 80083de:	2300      	movs	r3, #0
 80083e0:	e000      	b.n	80083e4 <RCC_SetFlashLatencyFromMSIRange+0x58>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
      {
        /* MSI 48Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
 80083e2:	2302      	movs	r3, #2
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#endif
  }

  __HAL_FLASH_SET_LATENCY(latency);
 80083e4:	4907      	ldr	r1, [pc, #28]	; (8008404 <RCC_SetFlashLatencyFromMSIRange+0x78>)
 80083e6:	680a      	ldr	r2, [r1, #0]
 80083e8:	f022 020f 	bic.w	r2, r2, #15
 80083ec:	431a      	orrs	r2, r3
 80083ee:	600a      	str	r2, [r1, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if(__HAL_FLASH_GET_LATENCY() != latency)
 80083f0:	6808      	ldr	r0, [r1, #0]
 80083f2:	f000 000f 	and.w	r0, r0, #15
  {
    return HAL_ERROR;
  }

  return HAL_OK;
}
 80083f6:	1ac0      	subs	r0, r0, r3
 80083f8:	bf18      	it	ne
 80083fa:	2001      	movne	r0, #1
 80083fc:	b003      	add	sp, #12
 80083fe:	bd30      	pop	{r4, r5, pc}
 8008400:	40021000 	.word	0x40021000
 8008404:	40022000 	.word	0x40022000

08008408 <HAL_RCC_DeInit>:
  *            - Peripheral clock sources
  *            - LSI, LSE and RTC clocks (Backup domain)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_DeInit(void)
{
 8008408:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart;

  /* Reset to default System clock */
  /* Set MSION bit */
  SET_BIT(RCC->CR, RCC_CR_MSION);
 800840a:	4c34      	ldr	r4, [pc, #208]	; (80084dc <HAL_RCC_DeInit+0xd4>)
 800840c:	6823      	ldr	r3, [r4, #0]
 800840e:	f043 0301 	orr.w	r3, r3, #1
 8008412:	6023      	str	r3, [r4, #0]

  /* Insure MSIRDY bit is set before writing default MSIRANGE value */
  /* Get start tick */
  tickstart = HAL_GetTick();
 8008414:	f7fe fdfe 	bl	8007014 <HAL_GetTick>
 8008418:	4605      	mov	r5, r0

  /* Wait till MSI is ready */
  while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 800841a:	6823      	ldr	r3, [r4, #0]
 800841c:	4a2f      	ldr	r2, [pc, #188]	; (80084dc <HAL_RCC_DeInit+0xd4>)
 800841e:	079b      	lsls	r3, r3, #30
 8008420:	d406      	bmi.n	8008430 <HAL_RCC_DeInit+0x28>
  {
    if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8008422:	f7fe fdf7 	bl	8007014 <HAL_GetTick>
 8008426:	1b40      	subs	r0, r0, r5
 8008428:	2802      	cmp	r0, #2
 800842a:	d9f6      	bls.n	800841a <HAL_RCC_DeInit+0x12>
    {
      return HAL_TIMEOUT;
 800842c:	2503      	movs	r5, #3
 800842e:	e052      	b.n	80084d6 <HAL_RCC_DeInit+0xce>
    }
  }

  /* Set MSIRANGE default value */
  MODIFY_REG(RCC->CR, RCC_CR_MSIRANGE, RCC_MSIRANGE_6);
 8008430:	6813      	ldr	r3, [r2, #0]
 8008432:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8008436:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 800843a:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register (MSI is selected as system clock source) */
  CLEAR_REG(RCC->CFGR);
 800843c:	2300      	movs	r3, #0
 800843e:	6093      	str	r3, [r2, #8]

  /* Update the SystemCoreClock global variable for MSI as system clock source */
  SystemCoreClock = MSI_VALUE;
 8008440:	4b27      	ldr	r3, [pc, #156]	; (80084e0 <HAL_RCC_DeInit+0xd8>)
 8008442:	4a28      	ldr	r2, [pc, #160]	; (80084e4 <HAL_RCC_DeInit+0xdc>)
 8008444:	601a      	str	r2, [r3, #0]

  /* Configure the source of time base considering new system clock settings  */
  if(HAL_InitTick(uwTickPrio) != HAL_OK)
 8008446:	4b28      	ldr	r3, [pc, #160]	; (80084e8 <HAL_RCC_DeInit+0xe0>)
 8008448:	6818      	ldr	r0, [r3, #0]
 800844a:	f7fe fde5 	bl	8007018 <HAL_InitTick>
 800844e:	4605      	mov	r5, r0
 8008450:	2800      	cmp	r0, #0
 8008452:	d13f      	bne.n	80084d4 <HAL_RCC_DeInit+0xcc>
    return HAL_ERROR;
  }

  /* Insure MSI selected as system clock source */
  /* Get start tick */
  tickstart = HAL_GetTick();
 8008454:	f7fe fdde 	bl	8007014 <HAL_GetTick>

  /* Wait till system clock source is ready */
  while(READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
  {
    if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8008458:	f241 3788 	movw	r7, #5000	; 0x1388
    return HAL_ERROR;
  }

  /* Insure MSI selected as system clock source */
  /* Get start tick */
  tickstart = HAL_GetTick();
 800845c:	4606      	mov	r6, r0

  /* Wait till system clock source is ready */
  while(READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
 800845e:	68a3      	ldr	r3, [r4, #8]
 8008460:	4a1e      	ldr	r2, [pc, #120]	; (80084dc <HAL_RCC_DeInit+0xd4>)
 8008462:	f013 0f0c 	tst.w	r3, #12
 8008466:	d005      	beq.n	8008474 <HAL_RCC_DeInit+0x6c>
  {
    if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8008468:	f7fe fdd4 	bl	8007014 <HAL_GetTick>
 800846c:	1b80      	subs	r0, r0, r6
 800846e:	42b8      	cmp	r0, r7
 8008470:	d9f5      	bls.n	800845e <HAL_RCC_DeInit+0x56>
 8008472:	e7db      	b.n	800842c <HAL_RCC_DeInit+0x24>
  }

  /* Reset HSION, HSIKERON, HSIASFS, HSEON, HSECSSON, PLLON, PLLSAIxON bits */
#if defined(RCC_PLLSAI2_SUPPORT)

  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSION | RCC_CR_HSIKERON| RCC_CR_HSIASFS | RCC_CR_PLLON | RCC_CR_PLLSAI1ON | RCC_CR_PLLSAI2ON);
 8008474:	6811      	ldr	r1, [r2, #0]
 8008476:	4b1d      	ldr	r3, [pc, #116]	; (80084ec <HAL_RCC_DeInit+0xe4>)
 8008478:	400b      	ands	r3, r1
 800847a:	6013      	str	r3, [r2, #0]

#endif /* RCC_PLLSAI2_SUPPORT */

  /* Insure PLLRDY, PLLSAI1RDY and PLLSAI2RDY (if present) are reset */
  /* Get start tick */
  tickstart = HAL_GetTick();
 800847c:	f7fe fdca 	bl	8007014 <HAL_GetTick>
 8008480:	4606      	mov	r6, r0

#if defined(RCC_PLLSAI2_SUPPORT)

  while(READ_BIT(RCC->CR, RCC_CR_PLLRDY | RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY) != 0U)
 8008482:	6822      	ldr	r2, [r4, #0]
 8008484:	4b15      	ldr	r3, [pc, #84]	; (80084dc <HAL_RCC_DeInit+0xd4>)
 8008486:	f012 5228 	ands.w	r2, r2, #704643072	; 0x2a000000
 800848a:	d005      	beq.n	8008498 <HAL_RCC_DeInit+0x90>

  while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)

#endif
  {
    if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800848c:	f7fe fdc2 	bl	8007014 <HAL_GetTick>
 8008490:	1b80      	subs	r0, r0, r6
 8008492:	2802      	cmp	r0, #2
 8008494:	d9f5      	bls.n	8008482 <HAL_RCC_DeInit+0x7a>
 8008496:	e7c9      	b.n	800842c <HAL_RCC_DeInit+0x24>
      return HAL_TIMEOUT;
    }
  }

  /* Reset PLLCFGR register */
  CLEAR_REG(RCC->PLLCFGR);
 8008498:	60da      	str	r2, [r3, #12]
  SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN_4 );
 800849a:	68d9      	ldr	r1, [r3, #12]
 800849c:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 80084a0:	60d9      	str	r1, [r3, #12]

#if defined(RCC_PLLSAI1_SUPPORT)

  /* Reset PLLSAI1CFGR register */
  CLEAR_REG(RCC->PLLSAI1CFGR);
 80084a2:	611a      	str	r2, [r3, #16]
  SET_BIT(RCC->PLLSAI1CFGR,  RCC_PLLSAI1CFGR_PLLSAI1N_4 );
 80084a4:	6919      	ldr	r1, [r3, #16]
 80084a6:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 80084aa:	6119      	str	r1, [r3, #16]
#endif /* RCC_PLLSAI1_SUPPORT */

#if defined(RCC_PLLSAI2_SUPPORT)

  /* Reset PLLSAI2CFGR register */
  CLEAR_REG(RCC->PLLSAI2CFGR);
 80084ac:	615a      	str	r2, [r3, #20]
  SET_BIT(RCC->PLLSAI2CFGR,  RCC_PLLSAI2CFGR_PLLSAI2N_4 );
 80084ae:	6959      	ldr	r1, [r3, #20]
 80084b0:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 80084b4:	6159      	str	r1, [r3, #20]

#endif /* RCC_PLLSAI2_SUPPORT */

  /* Reset HSEBYP bit */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
 80084b6:	6819      	ldr	r1, [r3, #0]
 80084b8:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 80084bc:	6019      	str	r1, [r3, #0]

  /* Disable all interrupts */
  CLEAR_REG(RCC->CIER);
 80084be:	619a      	str	r2, [r3, #24]

  /* Clear all interrupt flags */
  WRITE_REG(RCC->CICR, 0xFFFFFFFFU);
 80084c0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80084c4:	621a      	str	r2, [r3, #32]

  /* Clear all reset flags */
  SET_BIT(RCC->CSR, RCC_CSR_RMVF);
 80084c6:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 80084ca:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 80084ce:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

  return HAL_OK;
 80084d2:	e000      	b.n	80084d6 <HAL_RCC_DeInit+0xce>
  SystemCoreClock = MSI_VALUE;

  /* Configure the source of time base considering new system clock settings  */
  if(HAL_InitTick(uwTickPrio) != HAL_OK)
  {
    return HAL_ERROR;
 80084d4:	2501      	movs	r5, #1

  /* Clear all reset flags */
  SET_BIT(RCC->CSR, RCC_CSR_RMVF);

  return HAL_OK;
}
 80084d6:	4628      	mov	r0, r5
 80084d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80084da:	bf00      	nop
 80084dc:	40021000 	.word	0x40021000
 80084e0:	20000448 	.word	0x20000448
 80084e4:	003d0900 	.word	0x003d0900
 80084e8:	20000238 	.word	0x20000238
 80084ec:	eafef4ff 	.word	0xeafef4ff

080084f0 <HAL_RCC_MCOConfig>:
  *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
  *            @arg @ref RCC_MCODIV_16  division by 16 applied to MCO clock
  * @retval None
  */
void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 80084f0:	b570      	push	{r4, r5, r6, lr}

  /* Prevent unused argument(s) compilation warning if no assert_param check */
  UNUSED(RCC_MCOx);

  /* MCO Clock Enable */
  __MCO1_CLK_ENABLE();
 80084f2:	4c11      	ldr	r4, [pc, #68]	; (8008538 <HAL_RCC_MCOConfig+0x48>)
 80084f4:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80084f6:	f043 0301 	orr.w	r3, r3, #1
 80084fa:	64e3      	str	r3, [r4, #76]	; 0x4c
 80084fc:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
  *            @arg @ref RCC_MCODIV_16  division by 16 applied to MCO clock
  * @retval None
  */
void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 80084fe:	b086      	sub	sp, #24

  /* Prevent unused argument(s) compilation warning if no assert_param check */
  UNUSED(RCC_MCOx);

  /* MCO Clock Enable */
  __MCO1_CLK_ENABLE();
 8008500:	f003 0301 	and.w	r3, r3, #1
 8008504:	9300      	str	r3, [sp, #0]
 8008506:	9b00      	ldr	r3, [sp, #0]

  /* Configue the MCO1 pin in alternate function mode */
  GPIO_InitStruct.Pin = MCO1_PIN;
 8008508:	f44f 7380 	mov.w	r3, #256	; 0x100
 800850c:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800850e:	2302      	movs	r3, #2
 8008510:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8008512:	9304      	str	r3, [sp, #16]
  *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
  *            @arg @ref RCC_MCODIV_16  division by 16 applied to MCO clock
  * @retval None
  */
void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 8008514:	460d      	mov	r5, r1

  /* Configue the MCO1 pin in alternate function mode */
  GPIO_InitStruct.Pin = MCO1_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008516:	2300      	movs	r3, #0
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
  HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
 8008518:	a901      	add	r1, sp, #4
 800851a:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
  *            @arg @ref RCC_MCODIV_16  division by 16 applied to MCO clock
  * @retval None
  */
void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 800851e:	4616      	mov	r6, r2

  /* Configue the MCO1 pin in alternate function mode */
  GPIO_InitStruct.Pin = MCO1_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008520:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 8008522:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
 8008524:	f7f8 fd4c 	bl	8000fc0 <HAL_GPIO_Init>

  /* Mask MCOSEL[] and MCOPRE[] bits then set MCO1 clock source and prescaler */
  MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCOSEL | RCC_CFGR_MCOPRE), (RCC_MCOSource | RCC_MCODiv ));
 8008528:	68a2      	ldr	r2, [r4, #8]
 800852a:	f022 42fe 	bic.w	r2, r2, #2130706432	; 0x7f000000
 800852e:	4316      	orrs	r6, r2
 8008530:	4335      	orrs	r5, r6
 8008532:	60a5      	str	r5, [r4, #8]
}
 8008534:	b006      	add	sp, #24
 8008536:	bd70      	pop	{r4, r5, r6, pc}
 8008538:	40021000 	.word	0x40021000

0800853c <HAL_RCC_GetSysClockFreq>:
{
  uint32_t msirange = 0U, sysclockfreq = 0U;
  uint32_t pllvco, pllsource, pllr, pllm;    /* no init needed */
  uint32_t sysclk_source, pll_oscsource;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 800853c:	4a24      	ldr	r2, [pc, #144]	; (80085d0 <HAL_RCC_GetSysClockFreq+0x94>)
 800853e:	6893      	ldr	r3, [r2, #8]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8008540:	68d1      	ldr	r1, [r2, #12]

  if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 8008542:	f013 030c 	ands.w	r3, r3, #12
 8008546:	d005      	beq.n	8008554 <HAL_RCC_GetSysClockFreq+0x18>
 8008548:	2b0c      	cmp	r3, #12
 800854a:	d114      	bne.n	8008576 <HAL_RCC_GetSysClockFreq+0x3a>
     ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 800854c:	f001 0103 	and.w	r1, r1, #3
 8008550:	2901      	cmp	r1, #1
 8008552:	d11a      	bne.n	800858a <HAL_RCC_GetSysClockFreq+0x4e>
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 8008554:	6810      	ldr	r0, [r2, #0]
 8008556:	491e      	ldr	r1, [pc, #120]	; (80085d0 <HAL_RCC_GetSysClockFreq+0x94>)
 8008558:	0700      	lsls	r0, r0, #28
    { /* MSISRANGE from RCC_CSR applies */
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 800855a:	bf54      	ite	pl
 800855c:	f8d1 1094 	ldrpl.w	r1, [r1, #148]	; 0x94
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8008560:	6809      	ldrmi	r1, [r1, #0]
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 8008562:	481c      	ldr	r0, [pc, #112]	; (80085d4 <HAL_RCC_GetSysClockFreq+0x98>)
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
    { /* MSISRANGE from RCC_CSR applies */
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8008564:	bf54      	ite	pl
 8008566:	f3c1 2103 	ubfxpl	r1, r1, #8, #4
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 800856a:	f3c1 1103 	ubfxmi	r1, r1, #4, #4
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 800856e:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]

    if(sysclk_source == RCC_CFGR_SWS_MSI)
 8008572:	b35b      	cbz	r3, 80085cc <HAL_RCC_GetSysClockFreq+0x90>
 8008574:	e006      	b.n	8008584 <HAL_RCC_GetSysClockFreq+0x48>
    {
      /* MSI used as system clock source */
      sysclockfreq = msirange;
    }
  }
  else if(sysclk_source == RCC_CFGR_SWS_HSI)
 8008576:	2b04      	cmp	r3, #4
 8008578:	d027      	beq.n	80085ca <HAL_RCC_GetSysClockFreq+0x8e>
 800857a:	2b08      	cmp	r3, #8
 800857c:	4816      	ldr	r0, [pc, #88]	; (80085d8 <HAL_RCC_GetSysClockFreq+0x9c>)
 800857e:	bf18      	it	ne
 8008580:	2000      	movne	r0, #0
 8008582:	4770      	bx	lr
  else
  {
    /* unexpected case: sysclockfreq at 0 */
  }

  if(sysclk_source == RCC_CFGR_SWS_PLL)
 8008584:	2b0c      	cmp	r3, #12
 8008586:	d001      	beq.n	800858c <HAL_RCC_GetSysClockFreq+0x50>
 8008588:	e01d      	b.n	80085c6 <HAL_RCC_GetSysClockFreq+0x8a>
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0U, sysclockfreq = 0U;
 800858a:	2000      	movs	r0, #0
    /* PLL used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE) * PLLN / PLLM
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 800858c:	68d3      	ldr	r3, [r2, #12]

    switch (pllsource)
 800858e:	f003 0303 	and.w	r3, r3, #3
 8008592:	2b02      	cmp	r3, #2
 8008594:	d004      	beq.n	80085a0 <HAL_RCC_GetSysClockFreq+0x64>
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllvco = HSI_VALUE;
      break;

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pllvco = HSE_VALUE;
 8008596:	4910      	ldr	r1, [pc, #64]	; (80085d8 <HAL_RCC_GetSysClockFreq+0x9c>)
 8008598:	2b03      	cmp	r3, #3
 800859a:	bf08      	it	eq
 800859c:	4608      	moveq	r0, r1
 800859e:	e000      	b.n	80085a2 <HAL_RCC_GetSysClockFreq+0x66>
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);

    switch (pllsource)
    {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllvco = HSI_VALUE;
 80085a0:	480e      	ldr	r0, [pc, #56]	; (80085dc <HAL_RCC_GetSysClockFreq+0xa0>)
    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
    default:
      pllvco = msirange;
      break;
    }
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 80085a2:	68d3      	ldr	r3, [r2, #12]
    pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 80085a4:	68d1      	ldr	r1, [r2, #12]
 80085a6:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80085aa:	f3c1 2106 	ubfx	r1, r1, #8, #7
 80085ae:	4348      	muls	r0, r1
 80085b0:	3301      	adds	r3, #1
 80085b2:	fbb0 f3f3 	udiv	r3, r0, r3
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 80085b6:	68d0      	ldr	r0, [r2, #12]
    sysclockfreq = pllvco / pllr;
 80085b8:	f3c0 6041 	ubfx	r0, r0, #25, #2
 80085bc:	3001      	adds	r0, #1
 80085be:	0040      	lsls	r0, r0, #1
 80085c0:	fbb3 f0f0 	udiv	r0, r3, r0
 80085c4:	4770      	bx	lr
 80085c6:	2000      	movs	r0, #0
 80085c8:	4770      	bx	lr
    }
  }
  else if(sysclk_source == RCC_CFGR_SWS_HSI)
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 80085ca:	4804      	ldr	r0, [pc, #16]	; (80085dc <HAL_RCC_GetSysClockFreq+0xa0>)
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
    sysclockfreq = pllvco / pllr;
  }

  return sysclockfreq;
}
 80085cc:	4770      	bx	lr
 80085ce:	bf00      	nop
 80085d0:	40021000 	.word	0x40021000
 80085d4:	0800e740 	.word	0x0800e740
 80085d8:	007a1200 	.word	0x007a1200
 80085dc:	00f42400 	.word	0x00f42400

080085e0 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80085e0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status;
  uint32_t sysclk_source, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 80085e4:	4605      	mov	r5, r0
 80085e6:	2800      	cmp	r0, #0
 80085e8:	f000 82a9 	beq.w	8008b3e <HAL_RCC_OscConfig+0x55e>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 80085ec:	4c9f      	ldr	r4, [pc, #636]	; (800886c <HAL_RCC_OscConfig+0x28c>)
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80085ee:	6803      	ldr	r3, [r0, #0]
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 80085f0:	68a6      	ldr	r6, [r4, #8]
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 80085f2:	68e7      	ldr	r7, [r4, #12]

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80085f4:	06db      	lsls	r3, r3, #27
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 80085f6:	f006 060c 	and.w	r6, r6, #12
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 80085fa:	f007 0703 	and.w	r7, r7, #3

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80085fe:	f140 8091 	bpl.w	8008724 <HAL_RCC_OscConfig+0x144>
    assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

    /* Check if MSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 8008602:	b11e      	cbz	r6, 800860c <HAL_RCC_OscConfig+0x2c>
 8008604:	2e0c      	cmp	r6, #12
 8008606:	d155      	bne.n	80086b4 <HAL_RCC_OscConfig+0xd4>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_MSI)))
 8008608:	2f01      	cmp	r7, #1
 800860a:	d153      	bne.n	80086b4 <HAL_RCC_OscConfig+0xd4>
    {
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 800860c:	6823      	ldr	r3, [r4, #0]
 800860e:	0798      	lsls	r0, r3, #30
 8008610:	d503      	bpl.n	800861a <HAL_RCC_OscConfig+0x3a>
 8008612:	69ab      	ldr	r3, [r5, #24]
 8008614:	2b00      	cmp	r3, #0
 8008616:	f000 8292 	beq.w	8008b3e <HAL_RCC_OscConfig+0x55e>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the CPU clock
           (HCLK) and the supply voltage of the device. */
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 800861a:	6822      	ldr	r2, [r4, #0]
 800861c:	4b93      	ldr	r3, [pc, #588]	; (800886c <HAL_RCC_OscConfig+0x28c>)
 800861e:	6a28      	ldr	r0, [r5, #32]
 8008620:	0711      	lsls	r1, r2, #28
 8008622:	bf56      	itet	pl
 8008624:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
 8008628:	681b      	ldrmi	r3, [r3, #0]
 800862a:	091b      	lsrpl	r3, r3, #4
 800862c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8008630:	4283      	cmp	r3, r0
 8008632:	d216      	bcs.n	8008662 <HAL_RCC_OscConfig+0x82>
        {
          /* First increase number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8008634:	f7ff feaa 	bl	800838c <RCC_SetFlashLatencyFromMSIRange>
 8008638:	2800      	cmp	r0, #0
 800863a:	f040 8280 	bne.w	8008b3e <HAL_RCC_OscConfig+0x55e>
          {
            return HAL_ERROR;
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800863e:	6823      	ldr	r3, [r4, #0]
 8008640:	f043 0308 	orr.w	r3, r3, #8
 8008644:	6023      	str	r3, [r4, #0]
 8008646:	6823      	ldr	r3, [r4, #0]
 8008648:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 800864c:	6a2b      	ldr	r3, [r5, #32]
 800864e:	4313      	orrs	r3, r2
 8008650:	6023      	str	r3, [r4, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8008652:	6863      	ldr	r3, [r4, #4]
 8008654:	69ea      	ldr	r2, [r5, #28]
 8008656:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 800865a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800865e:	6063      	str	r3, [r4, #4]
 8008660:	e015      	b.n	800868e <HAL_RCC_OscConfig+0xae>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8008662:	6823      	ldr	r3, [r4, #0]
 8008664:	f043 0308 	orr.w	r3, r3, #8
 8008668:	6023      	str	r3, [r4, #0]
 800866a:	6823      	ldr	r3, [r4, #0]
 800866c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8008670:	4303      	orrs	r3, r0
 8008672:	6023      	str	r3, [r4, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8008674:	6863      	ldr	r3, [r4, #4]
 8008676:	69ea      	ldr	r2, [r5, #28]
 8008678:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 800867c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8008680:	6063      	str	r3, [r4, #4]

          /* Decrease number of wait states update if necessary */
          /* Only possible when MSI is the System clock source  */
          if(sysclk_source == RCC_CFGR_SWS_MSI)
 8008682:	b926      	cbnz	r6, 800868e <HAL_RCC_OscConfig+0xae>
          {
            if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8008684:	f7ff fe82 	bl	800838c <RCC_SetFlashLatencyFromMSIRange>
 8008688:	2800      	cmp	r0, #0
 800868a:	f040 8258 	bne.w	8008b3e <HAL_RCC_OscConfig+0x55e>
            }
          }
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 800868e:	f7ff ff55 	bl	800853c <HAL_RCC_GetSysClockFreq>
 8008692:	68a3      	ldr	r3, [r4, #8]
 8008694:	4a76      	ldr	r2, [pc, #472]	; (8008870 <HAL_RCC_OscConfig+0x290>)
 8008696:	f3c3 1303 	ubfx	r3, r3, #4, #4
 800869a:	5cd3      	ldrb	r3, [r2, r3]
 800869c:	f003 031f 	and.w	r3, r3, #31
 80086a0:	40d8      	lsrs	r0, r3
 80086a2:	4b74      	ldr	r3, [pc, #464]	; (8008874 <HAL_RCC_OscConfig+0x294>)
 80086a4:	6018      	str	r0, [r3, #0]

        /* Configure the source of time base considering new system clocks settings*/
        status = HAL_InitTick(uwTickPrio);
 80086a6:	4b74      	ldr	r3, [pc, #464]	; (8008878 <HAL_RCC_OscConfig+0x298>)
 80086a8:	6818      	ldr	r0, [r3, #0]
 80086aa:	f7fe fcb5 	bl	8007018 <HAL_InitTick>
        if(status != HAL_OK)
 80086ae:	2800      	cmp	r0, #0
 80086b0:	d038      	beq.n	8008724 <HAL_RCC_OscConfig+0x144>
 80086b2:	e245      	b.n	8008b40 <HAL_RCC_OscConfig+0x560>
      }
    }
    else
    {
      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 80086b4:	69ab      	ldr	r3, [r5, #24]
 80086b6:	b323      	cbz	r3, 8008702 <HAL_RCC_OscConfig+0x122>
      {
        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 80086b8:	6823      	ldr	r3, [r4, #0]
 80086ba:	f043 0301 	orr.w	r3, r3, #1
 80086be:	6023      	str	r3, [r4, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();
 80086c0:	f7fe fca8 	bl	8007014 <HAL_GetTick>
 80086c4:	4680      	mov	r8, r0

        /* Wait till MSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 80086c6:	6822      	ldr	r2, [r4, #0]
 80086c8:	4b68      	ldr	r3, [pc, #416]	; (800886c <HAL_RCC_OscConfig+0x28c>)
 80086ca:	0792      	lsls	r2, r2, #30
 80086cc:	d407      	bmi.n	80086de <HAL_RCC_OscConfig+0xfe>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80086ce:	f7fe fca1 	bl	8007014 <HAL_GetTick>
 80086d2:	ebc8 0000 	rsb	r0, r8, r0
 80086d6:	2802      	cmp	r0, #2
 80086d8:	d9f5      	bls.n	80086c6 <HAL_RCC_OscConfig+0xe6>
          {
            return HAL_TIMEOUT;
 80086da:	2003      	movs	r0, #3
 80086dc:	e230      	b.n	8008b40 <HAL_RCC_OscConfig+0x560>
          }
        }
         /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80086de:	681a      	ldr	r2, [r3, #0]
 80086e0:	f042 0208 	orr.w	r2, r2, #8
 80086e4:	601a      	str	r2, [r3, #0]
 80086e6:	681a      	ldr	r2, [r3, #0]
 80086e8:	f022 01f0 	bic.w	r1, r2, #240	; 0xf0
 80086ec:	6a2a      	ldr	r2, [r5, #32]
 80086ee:	430a      	orrs	r2, r1
 80086f0:	601a      	str	r2, [r3, #0]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80086f2:	685a      	ldr	r2, [r3, #4]
 80086f4:	69e9      	ldr	r1, [r5, #28]
 80086f6:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 80086fa:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80086fe:	605a      	str	r2, [r3, #4]
 8008700:	e010      	b.n	8008724 <HAL_RCC_OscConfig+0x144>

      }
      else
      {
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 8008702:	6823      	ldr	r3, [r4, #0]
 8008704:	f023 0301 	bic.w	r3, r3, #1
 8008708:	6023      	str	r3, [r4, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();
 800870a:	f7fe fc83 	bl	8007014 <HAL_GetTick>
 800870e:	4680      	mov	r8, r0

        /* Wait till MSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
 8008710:	6823      	ldr	r3, [r4, #0]
 8008712:	0798      	lsls	r0, r3, #30
 8008714:	d506      	bpl.n	8008724 <HAL_RCC_OscConfig+0x144>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8008716:	f7fe fc7d 	bl	8007014 <HAL_GetTick>
 800871a:	ebc8 0000 	rsb	r0, r8, r0
 800871e:	2802      	cmp	r0, #2
 8008720:	d9f6      	bls.n	8008710 <HAL_RCC_OscConfig+0x130>
 8008722:	e7da      	b.n	80086da <HAL_RCC_OscConfig+0xfa>
        }
      }
    }
  }
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8008724:	682b      	ldr	r3, [r5, #0]
 8008726:	07d9      	lsls	r1, r3, #31
 8008728:	d403      	bmi.n	8008732 <HAL_RCC_OscConfig+0x152>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800872a:	682b      	ldr	r3, [r5, #0]
 800872c:	079a      	lsls	r2, r3, #30
 800872e:	d440      	bmi.n	80087b2 <HAL_RCC_OscConfig+0x1d2>
 8008730:	e07f      	b.n	8008832 <HAL_RCC_OscConfig+0x252>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((sysclk_source == RCC_CFGR_SWS_HSE) ||
 8008732:	2e08      	cmp	r6, #8
 8008734:	d003      	beq.n	800873e <HAL_RCC_OscConfig+0x15e>
 8008736:	2e0c      	cmp	r6, #12
 8008738:	d108      	bne.n	800874c <HAL_RCC_OscConfig+0x16c>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSE)))
 800873a:	2f03      	cmp	r7, #3
 800873c:	d106      	bne.n	800874c <HAL_RCC_OscConfig+0x16c>
    {
      if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800873e:	6823      	ldr	r3, [r4, #0]
 8008740:	039b      	lsls	r3, r3, #14
 8008742:	d5f2      	bpl.n	800872a <HAL_RCC_OscConfig+0x14a>
 8008744:	686b      	ldr	r3, [r5, #4]
 8008746:	2b00      	cmp	r3, #0
 8008748:	d1ef      	bne.n	800872a <HAL_RCC_OscConfig+0x14a>
 800874a:	e1f8      	b.n	8008b3e <HAL_RCC_OscConfig+0x55e>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800874c:	686b      	ldr	r3, [r5, #4]
 800874e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8008752:	d006      	beq.n	8008762 <HAL_RCC_OscConfig+0x182>
 8008754:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8008758:	d108      	bne.n	800876c <HAL_RCC_OscConfig+0x18c>
 800875a:	6823      	ldr	r3, [r4, #0]
 800875c:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8008760:	6023      	str	r3, [r4, #0]
 8008762:	6823      	ldr	r3, [r4, #0]
 8008764:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8008768:	6023      	str	r3, [r4, #0]
 800876a:	e008      	b.n	800877e <HAL_RCC_OscConfig+0x19e>
 800876c:	6822      	ldr	r2, [r4, #0]
 800876e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8008772:	6022      	str	r2, [r4, #0]
 8008774:	6822      	ldr	r2, [r4, #0]
 8008776:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800877a:	6022      	str	r2, [r4, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800877c:	b163      	cbz	r3, 8008798 <HAL_RCC_OscConfig+0x1b8>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800877e:	f7fe fc49 	bl	8007014 <HAL_GetTick>
 8008782:	4680      	mov	r8, r0

        /* Wait till HSE is ready */
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8008784:	6823      	ldr	r3, [r4, #0]
 8008786:	0398      	lsls	r0, r3, #14
 8008788:	d4cf      	bmi.n	800872a <HAL_RCC_OscConfig+0x14a>
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800878a:	f7fe fc43 	bl	8007014 <HAL_GetTick>
 800878e:	ebc8 0000 	rsb	r0, r8, r0
 8008792:	2864      	cmp	r0, #100	; 0x64
 8008794:	d9f6      	bls.n	8008784 <HAL_RCC_OscConfig+0x1a4>
 8008796:	e7a0      	b.n	80086da <HAL_RCC_OscConfig+0xfa>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8008798:	f7fe fc3c 	bl	8007014 <HAL_GetTick>
 800879c:	4680      	mov	r8, r0

        /* Wait till HSE is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 800879e:	6823      	ldr	r3, [r4, #0]
 80087a0:	0399      	lsls	r1, r3, #14
 80087a2:	d5c2      	bpl.n	800872a <HAL_RCC_OscConfig+0x14a>
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80087a4:	f7fe fc36 	bl	8007014 <HAL_GetTick>
 80087a8:	ebc8 0000 	rsb	r0, r8, r0
 80087ac:	2864      	cmp	r0, #100	; 0x64
 80087ae:	d9f6      	bls.n	800879e <HAL_RCC_OscConfig+0x1be>
 80087b0:	e793      	b.n	80086da <HAL_RCC_OscConfig+0xfa>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((sysclk_source == RCC_CFGR_SWS_HSI) ||
 80087b2:	2e04      	cmp	r6, #4
 80087b4:	d003      	beq.n	80087be <HAL_RCC_OscConfig+0x1de>
 80087b6:	2e0c      	cmp	r6, #12
 80087b8:	d110      	bne.n	80087dc <HAL_RCC_OscConfig+0x1fc>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSI)))
 80087ba:	2f02      	cmp	r7, #2
 80087bc:	d10e      	bne.n	80087dc <HAL_RCC_OscConfig+0x1fc>
    {
      /* When HSI is used as system clock it will not be disabled */
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80087be:	6823      	ldr	r3, [r4, #0]
 80087c0:	055a      	lsls	r2, r3, #21
 80087c2:	d503      	bpl.n	80087cc <HAL_RCC_OscConfig+0x1ec>
 80087c4:	68eb      	ldr	r3, [r5, #12]
 80087c6:	2b00      	cmp	r3, #0
 80087c8:	f000 81b9 	beq.w	8008b3e <HAL_RCC_OscConfig+0x55e>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80087cc:	6863      	ldr	r3, [r4, #4]
 80087ce:	692a      	ldr	r2, [r5, #16]
 80087d0:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 80087d4:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80087d8:	6063      	str	r3, [r4, #4]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((sysclk_source == RCC_CFGR_SWS_HSI) ||
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSI)))
    {
      /* When HSI is used as system clock it will not be disabled */
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80087da:	e02a      	b.n	8008832 <HAL_RCC_OscConfig+0x252>
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80087dc:	68eb      	ldr	r3, [r5, #12]
 80087de:	b1c3      	cbz	r3, 8008812 <HAL_RCC_OscConfig+0x232>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 80087e0:	6823      	ldr	r3, [r4, #0]
 80087e2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80087e6:	6023      	str	r3, [r4, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80087e8:	f7fe fc14 	bl	8007014 <HAL_GetTick>
 80087ec:	4607      	mov	r7, r0

        /* Wait till HSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 80087ee:	6823      	ldr	r3, [r4, #0]
 80087f0:	4a1e      	ldr	r2, [pc, #120]	; (800886c <HAL_RCC_OscConfig+0x28c>)
 80087f2:	055b      	lsls	r3, r3, #21
 80087f4:	d405      	bmi.n	8008802 <HAL_RCC_OscConfig+0x222>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80087f6:	f7fe fc0d 	bl	8007014 <HAL_GetTick>
 80087fa:	1bc0      	subs	r0, r0, r7
 80087fc:	2802      	cmp	r0, #2
 80087fe:	d9f6      	bls.n	80087ee <HAL_RCC_OscConfig+0x20e>
 8008800:	e76b      	b.n	80086da <HAL_RCC_OscConfig+0xfa>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8008802:	6853      	ldr	r3, [r2, #4]
 8008804:	6929      	ldr	r1, [r5, #16]
 8008806:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 800880a:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 800880e:	6053      	str	r3, [r2, #4]
 8008810:	e00f      	b.n	8008832 <HAL_RCC_OscConfig+0x252>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8008812:	6823      	ldr	r3, [r4, #0]
 8008814:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8008818:	6023      	str	r3, [r4, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800881a:	f7fe fbfb 	bl	8007014 <HAL_GetTick>
 800881e:	4607      	mov	r7, r0

        /* Wait till HSI is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8008820:	6823      	ldr	r3, [r4, #0]
 8008822:	0558      	lsls	r0, r3, #21
 8008824:	d505      	bpl.n	8008832 <HAL_RCC_OscConfig+0x252>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8008826:	f7fe fbf5 	bl	8007014 <HAL_GetTick>
 800882a:	1bc0      	subs	r0, r0, r7
 800882c:	2802      	cmp	r0, #2
 800882e:	d9f7      	bls.n	8008820 <HAL_RCC_OscConfig+0x240>
 8008830:	e753      	b.n	80086da <HAL_RCC_OscConfig+0xfa>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8008832:	682b      	ldr	r3, [r5, #0]
 8008834:	0719      	lsls	r1, r3, #28
 8008836:	d403      	bmi.n	8008840 <HAL_RCC_OscConfig+0x260>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8008838:	682b      	ldr	r3, [r5, #0]
 800883a:	075a      	lsls	r2, r3, #29
 800883c:	d431      	bmi.n	80088a2 <HAL_RCC_OscConfig+0x2c2>
 800883e:	e09d      	b.n	800897c <HAL_RCC_OscConfig+0x39c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8008840:	696b      	ldr	r3, [r5, #20]
 8008842:	b1db      	cbz	r3, 800887c <HAL_RCC_OscConfig+0x29c>
        MODIFY_REG(RCC->CSR, RCC_CSR_LSIPREDIV, RCC_OscInitStruct->LSIDiv);
      }
#endif /* RCC_CSR_LSIPREDIV */

      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8008844:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 8008848:	f043 0301 	orr.w	r3, r3, #1
 800884c:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8008850:	f7fe fbe0 	bl	8007014 <HAL_GetTick>
 8008854:	4607      	mov	r7, r0

      /* Wait till LSI is ready */
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 8008856:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 800885a:	079b      	lsls	r3, r3, #30
 800885c:	d4ec      	bmi.n	8008838 <HAL_RCC_OscConfig+0x258>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800885e:	f7fe fbd9 	bl	8007014 <HAL_GetTick>
 8008862:	1bc0      	subs	r0, r0, r7
 8008864:	2802      	cmp	r0, #2
 8008866:	d9f6      	bls.n	8008856 <HAL_RCC_OscConfig+0x276>
 8008868:	e737      	b.n	80086da <HAL_RCC_OscConfig+0xfa>
 800886a:	bf00      	nop
 800886c:	40021000 	.word	0x40021000
 8008870:	0800e728 	.word	0x0800e728
 8008874:	20000448 	.word	0x20000448
 8008878:	20000238 	.word	0x20000238
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 800887c:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 8008880:	f023 0301 	bic.w	r3, r3, #1
 8008884:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8008888:	f7fe fbc4 	bl	8007014 <HAL_GetTick>
 800888c:	4607      	mov	r7, r0

      /* Wait till LSI is disabled */
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 800888e:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 8008892:	0798      	lsls	r0, r3, #30
 8008894:	d5d0      	bpl.n	8008838 <HAL_RCC_OscConfig+0x258>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8008896:	f7fe fbbd 	bl	8007014 <HAL_GetTick>
 800889a:	1bc0      	subs	r0, r0, r7
 800889c:	2802      	cmp	r0, #2
 800889e:	d9f6      	bls.n	800888e <HAL_RCC_OscConfig+0x2ae>
 80088a0:	e71b      	b.n	80086da <HAL_RCC_OscConfig+0xfa>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 80088a2:	6da2      	ldr	r2, [r4, #88]	; 0x58
 80088a4:	4ba8      	ldr	r3, [pc, #672]	; (8008b48 <HAL_RCC_OscConfig+0x568>)
 80088a6:	00d1      	lsls	r1, r2, #3
 80088a8:	d40b      	bmi.n	80088c2 <HAL_RCC_OscConfig+0x2e2>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 80088aa:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80088ac:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80088b0:	659a      	str	r2, [r3, #88]	; 0x58
 80088b2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80088b4:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80088b8:	9301      	str	r3, [sp, #4]
 80088ba:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 80088bc:	f04f 0801 	mov.w	r8, #1
 80088c0:	e001      	b.n	80088c6 <HAL_RCC_OscConfig+0x2e6>
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
  {
    FlagStatus       pwrclkchanged = RESET;
 80088c2:	f04f 0800 	mov.w	r8, #0
    {
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }

    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80088c6:	4fa1      	ldr	r7, [pc, #644]	; (8008b4c <HAL_RCC_OscConfig+0x56c>)
 80088c8:	683b      	ldr	r3, [r7, #0]
 80088ca:	05da      	lsls	r2, r3, #23
 80088cc:	d503      	bpl.n	80088d6 <HAL_RCC_OscConfig+0x2f6>
    {
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
    }
#else
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80088ce:	68ab      	ldr	r3, [r5, #8]
 80088d0:	2b01      	cmp	r3, #1
 80088d2:	d111      	bne.n	80088f8 <HAL_RCC_OscConfig+0x318>
 80088d4:	e018      	b.n	8008908 <HAL_RCC_OscConfig+0x328>
    }

    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80088d6:	683b      	ldr	r3, [r7, #0]
 80088d8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80088dc:	603b      	str	r3, [r7, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 80088de:	f7fe fb99 	bl	8007014 <HAL_GetTick>
 80088e2:	4681      	mov	r9, r0

      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80088e4:	683b      	ldr	r3, [r7, #0]
 80088e6:	05db      	lsls	r3, r3, #23
 80088e8:	d4f1      	bmi.n	80088ce <HAL_RCC_OscConfig+0x2ee>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80088ea:	f7fe fb93 	bl	8007014 <HAL_GetTick>
 80088ee:	ebc9 0000 	rsb	r0, r9, r0
 80088f2:	2802      	cmp	r0, #2
 80088f4:	d9f6      	bls.n	80088e4 <HAL_RCC_OscConfig+0x304>
 80088f6:	e6f0      	b.n	80086da <HAL_RCC_OscConfig+0xfa>
    {
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
    }
#else
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80088f8:	2b05      	cmp	r3, #5
 80088fa:	d10c      	bne.n	8008916 <HAL_RCC_OscConfig+0x336>
 80088fc:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 8008900:	f043 0304 	orr.w	r3, r3, #4
 8008904:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
 8008908:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 800890c:	f043 0301 	orr.w	r3, r3, #1
 8008910:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
 8008914:	e00c      	b.n	8008930 <HAL_RCC_OscConfig+0x350>
 8008916:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 800891a:	f022 0201 	bic.w	r2, r2, #1
 800891e:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
 8008922:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 8008926:	f022 0204 	bic.w	r2, r2, #4
 800892a:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
#endif /* RCC_BDCR_LSESYSDIS */

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 800892e:	b173      	cbz	r3, 800894e <HAL_RCC_OscConfig+0x36e>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8008930:	f7fe fb70 	bl	8007014 <HAL_GetTick>

      /* Wait till LSE is ready */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8008934:	f241 3988 	movw	r9, #5000	; 0x1388

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8008938:	4607      	mov	r7, r0

      /* Wait till LSE is ready */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 800893a:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 800893e:	0798      	lsls	r0, r3, #30
 8008940:	d40e      	bmi.n	8008960 <HAL_RCC_OscConfig+0x380>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8008942:	f7fe fb67 	bl	8007014 <HAL_GetTick>
 8008946:	1bc0      	subs	r0, r0, r7
 8008948:	4548      	cmp	r0, r9
 800894a:	d9f6      	bls.n	800893a <HAL_RCC_OscConfig+0x35a>
 800894c:	e6c5      	b.n	80086da <HAL_RCC_OscConfig+0xfa>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800894e:	f7fe fb61 	bl	8007014 <HAL_GetTick>

      /* Wait till LSE is disabled */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8008952:	f241 3988 	movw	r9, #5000	; 0x1388
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8008956:	4607      	mov	r7, r0

      /* Wait till LSE is disabled */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8008958:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 800895c:	0799      	lsls	r1, r3, #30
 800895e:	d407      	bmi.n	8008970 <HAL_RCC_OscConfig+0x390>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSDIS);
#endif /* RCC_BDCR_LSESYSDIS */
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8008960:	f1b8 0f00 	cmp.w	r8, #0
 8008964:	d00a      	beq.n	800897c <HAL_RCC_OscConfig+0x39c>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8008966:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8008968:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800896c:	65a3      	str	r3, [r4, #88]	; 0x58
 800896e:	e005      	b.n	800897c <HAL_RCC_OscConfig+0x39c>
      tickstart = HAL_GetTick();

      /* Wait till LSE is disabled */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8008970:	f7fe fb50 	bl	8007014 <HAL_GetTick>
 8008974:	1bc0      	subs	r0, r0, r7
 8008976:	4548      	cmp	r0, r9
 8008978:	d9ee      	bls.n	8008958 <HAL_RCC_OscConfig+0x378>
 800897a:	e6ae      	b.n	80086da <HAL_RCC_OscConfig+0xfa>
      __HAL_RCC_PWR_CLK_DISABLE();
    }
  }
#if defined(RCC_HSI48_SUPPORT)
  /*------------------------------ HSI48 Configuration -----------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 800897c:	682b      	ldr	r3, [r5, #0]
 800897e:	069a      	lsls	r2, r3, #26
 8008980:	d402      	bmi.n	8008988 <HAL_RCC_OscConfig+0x3a8>
#endif /* RCC_HSI48_SUPPORT */
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8008982:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8008984:	bb43      	cbnz	r3, 80089d8 <HAL_RCC_OscConfig+0x3f8>
 8008986:	e070      	b.n	8008a6a <HAL_RCC_OscConfig+0x48a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the LSI State */
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 8008988:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800898a:	b193      	cbz	r3, 80089b2 <HAL_RCC_OscConfig+0x3d2>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 800898c:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 8008990:	f043 0301 	orr.w	r3, r3, #1
 8008994:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8008998:	f7fe fb3c 	bl	8007014 <HAL_GetTick>
 800899c:	4607      	mov	r7, r0

      /* Wait till HSI48 is ready */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 800899e:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 80089a2:	079b      	lsls	r3, r3, #30
 80089a4:	d4ed      	bmi.n	8008982 <HAL_RCC_OscConfig+0x3a2>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 80089a6:	f7fe fb35 	bl	8007014 <HAL_GetTick>
 80089aa:	1bc0      	subs	r0, r0, r7
 80089ac:	2802      	cmp	r0, #2
 80089ae:	d9f6      	bls.n	800899e <HAL_RCC_OscConfig+0x3be>
 80089b0:	e693      	b.n	80086da <HAL_RCC_OscConfig+0xfa>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
 80089b2:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 80089b6:	f023 0301 	bic.w	r3, r3, #1
 80089ba:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80089be:	f7fe fb29 	bl	8007014 <HAL_GetTick>
 80089c2:	4607      	mov	r7, r0

      /* Wait till HSI48 is disabled */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 80089c4:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 80089c8:	0798      	lsls	r0, r3, #30
 80089ca:	d5da      	bpl.n	8008982 <HAL_RCC_OscConfig+0x3a2>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 80089cc:	f7fe fb22 	bl	8007014 <HAL_GetTick>
 80089d0:	1bc0      	subs	r0, r0, r7
 80089d2:	2802      	cmp	r0, #2
 80089d4:	d9f6      	bls.n	80089c4 <HAL_RCC_OscConfig+0x3e4>
 80089d6:	e680      	b.n	80086da <HAL_RCC_OscConfig+0xfa>
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
  {
    /* PLL On ? */
    if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 80089d8:	2b02      	cmp	r3, #2
 80089da:	f040 808f 	bne.w	8008afc <HAL_RCC_OscConfig+0x51c>
#endif /* RCC_PLLP_SUPPORT */
      assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

      /* Do nothing if PLL configuration is the unchanged */
      pll_config = RCC->PLLCFGR;
 80089de:	68e3      	ldr	r3, [r4, #12]
      if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 80089e0:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
#endif /* RCC_PLLP_SUPPORT */
      assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

      /* Do nothing if PLL configuration is the unchanged */
      pll_config = RCC->PLLCFGR;
 80089e2:	4a59      	ldr	r2, [pc, #356]	; (8008b48 <HAL_RCC_OscConfig+0x568>)
      if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 80089e4:	f003 0003 	and.w	r0, r3, #3
 80089e8:	4288      	cmp	r0, r1
 80089ea:	d040      	beq.n	8008a6e <HAL_RCC_OscConfig+0x48e>
#endif
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)    != ((((RCC_OscInitStruct->PLL.PLLR) >> 1U) - 1U) << RCC_PLLCFGR_PLLR_Pos)))
      {
        /* Check if the PLL is used as system clock or not */
        if(sysclk_source != RCC_CFGR_SWS_PLL)
 80089ec:	2e0c      	cmp	r6, #12
 80089ee:	f000 80a6 	beq.w	8008b3e <HAL_RCC_OscConfig+0x55e>
        {
#if defined(RCC_PLLSAI1_SUPPORT) || defined(RCC_PLLSAI2_SUPPORT)
          /* Check if main PLL can be updated */
          /* Not possible if the source is shared by other enabled PLLSAIx */
          if((READ_BIT(RCC->CR, RCC_CR_PLLSAI1ON) != 0U)
 80089f2:	6822      	ldr	r2, [r4, #0]
 80089f4:	4b54      	ldr	r3, [pc, #336]	; (8008b48 <HAL_RCC_OscConfig+0x568>)
 80089f6:	0151      	lsls	r1, r2, #5
 80089f8:	f100 80a1 	bmi.w	8008b3e <HAL_RCC_OscConfig+0x55e>
#if defined(RCC_PLLSAI2_SUPPORT)
             || (READ_BIT(RCC->CR, RCC_CR_PLLSAI2ON) != 0U)
 80089fc:	681a      	ldr	r2, [r3, #0]
 80089fe:	00d2      	lsls	r2, r2, #3
 8008a00:	f100 809d 	bmi.w	8008b3e <HAL_RCC_OscConfig+0x55e>
          }
          else
#endif /* RCC_PLLSAI1_SUPPORT || RCC_PLLSAI2_SUPPORT */
          {
            /* Disable the main PLL. */
            __HAL_RCC_PLL_DISABLE();
 8008a04:	681a      	ldr	r2, [r3, #0]
 8008a06:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8008a0a:	601a      	str	r2, [r3, #0]

            /* Get Start Tick*/
            tickstart = HAL_GetTick();
 8008a0c:	f7fe fb02 	bl	8007014 <HAL_GetTick>
 8008a10:	4606      	mov	r6, r0

            /* Wait till PLL is ready */
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8008a12:	6823      	ldr	r3, [r4, #0]
 8008a14:	484c      	ldr	r0, [pc, #304]	; (8008b48 <HAL_RCC_OscConfig+0x568>)
 8008a16:	019f      	lsls	r7, r3, #6
 8008a18:	d44d      	bmi.n	8008ab6 <HAL_RCC_OscConfig+0x4d6>
                return HAL_TIMEOUT;
              }
            }

            /* Configure the main PLL clock source, multiplication and division factors. */
            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8008a1a:	68c2      	ldr	r2, [r0, #12]
 8008a1c:	4b4c      	ldr	r3, [pc, #304]	; (8008b50 <HAL_RCC_OscConfig+0x570>)
 8008a1e:	6b69      	ldr	r1, [r5, #52]	; 0x34
 8008a20:	4013      	ands	r3, r2
 8008a22:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8008a26:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8008a28:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 8008a2a:	430b      	orrs	r3, r1
 8008a2c:	6ba9      	ldr	r1, [r5, #56]	; 0x38
 8008a2e:	3a01      	subs	r2, #1
 8008a30:	ea43 63c1 	orr.w	r3, r3, r1, lsl #27
 8008a34:	ea43 1102 	orr.w	r1, r3, r2, lsl #4
 8008a38:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8008a3a:	085b      	lsrs	r3, r3, #1
 8008a3c:	3b01      	subs	r3, #1
 8008a3e:	ea41 5243 	orr.w	r2, r1, r3, lsl #21
 8008a42:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 8008a44:	085b      	lsrs	r3, r3, #1
 8008a46:	3b01      	subs	r3, #1
 8008a48:	ea42 6343 	orr.w	r3, r2, r3, lsl #25
 8008a4c:	60c3      	str	r3, [r0, #12]
#endif
                                 RCC_OscInitStruct->PLL.PLLQ,
                                 RCC_OscInitStruct->PLL.PLLR);

            /* Enable the main PLL. */
            __HAL_RCC_PLL_ENABLE();
 8008a4e:	6803      	ldr	r3, [r0, #0]
 8008a50:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8008a54:	6003      	str	r3, [r0, #0]

            /* Enable PLL System Clock output. */
            __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8008a56:	68c3      	ldr	r3, [r0, #12]
 8008a58:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8008a5c:	60c3      	str	r3, [r0, #12]

            /* Get Start Tick*/
            tickstart = HAL_GetTick();
 8008a5e:	f7fe fad9 	bl	8007014 <HAL_GetTick>
 8008a62:	4605      	mov	r5, r0

            /* Wait till PLL is ready */
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8008a64:	6823      	ldr	r3, [r4, #0]
 8008a66:	0198      	lsls	r0, r3, #6
 8008a68:	d52b      	bpl.n	8008ac2 <HAL_RCC_OscConfig+0x4e2>
        /* PLL is already used as System core clock */
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
 8008a6a:	2000      	movs	r0, #0
 8008a6c:	e068      	b.n	8008b40 <HAL_RCC_OscConfig+0x560>
      assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

      /* Do nothing if PLL configuration is the unchanged */
      pll_config = RCC->PLLCFGR;
      if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 8008a6e:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8008a70:	f003 01f0 	and.w	r1, r3, #240	; 0xf0
 8008a74:	3801      	subs	r0, #1
 8008a76:	ebb1 1f00 	cmp.w	r1, r0, lsl #4
 8008a7a:	d1b7      	bne.n	80089ec <HAL_RCC_OscConfig+0x40c>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8008a7c:	6b68      	ldr	r0, [r5, #52]	; 0x34
 8008a7e:	f403 41fe 	and.w	r1, r3, #32512	; 0x7f00
 8008a82:	ebb1 2f00 	cmp.w	r1, r0, lsl #8
 8008a86:	d1b1      	bne.n	80089ec <HAL_RCC_OscConfig+0x40c>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 8008a88:	6ba8      	ldr	r0, [r5, #56]	; 0x38
 8008a8a:	f003 4178 	and.w	r1, r3, #4160749568	; 0xf8000000
 8008a8e:	ebb1 6fc0 	cmp.w	r1, r0, lsl #27
 8008a92:	d1ab      	bne.n	80089ec <HAL_RCC_OscConfig+0x40c>
#if defined(RCC_PLLP_SUPPORT)
#if defined(RCC_PLLP_DIV_2_31_SUPPORT)
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLPDIV) != (RCC_OscInitStruct->PLL.PLLP << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 8008a94:	6be9      	ldr	r1, [r5, #60]	; 0x3c
 8008a96:	0849      	lsrs	r1, r1, #1
 8008a98:	f403 00c0 	and.w	r0, r3, #6291456	; 0x600000
 8008a9c:	3901      	subs	r1, #1
 8008a9e:	ebb0 5f41 	cmp.w	r0, r1, lsl #21
 8008aa2:	d1a3      	bne.n	80089ec <HAL_RCC_OscConfig+0x40c>
#else
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLP)    != ((RCC_OscInitStruct->PLL.PLLP == RCC_PLLP_DIV7) ? 0U : 1U)) ||
#endif
#endif
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8008aa4:	6c29      	ldr	r1, [r5, #64]	; 0x40
 8008aa6:	0849      	lsrs	r1, r1, #1
 8008aa8:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
 8008aac:	3901      	subs	r1, #1
 8008aae:	ebb3 6f41 	cmp.w	r3, r1, lsl #25
 8008ab2:	d19b      	bne.n	80089ec <HAL_RCC_OscConfig+0x40c>
 8008ab4:	e00b      	b.n	8008ace <HAL_RCC_OscConfig+0x4ee>
            tickstart = HAL_GetTick();

            /* Wait till PLL is ready */
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
            {
              if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8008ab6:	f7fe faad 	bl	8007014 <HAL_GetTick>
 8008aba:	1b80      	subs	r0, r0, r6
 8008abc:	2802      	cmp	r0, #2
 8008abe:	d9a8      	bls.n	8008a12 <HAL_RCC_OscConfig+0x432>
 8008ac0:	e60b      	b.n	80086da <HAL_RCC_OscConfig+0xfa>
            tickstart = HAL_GetTick();

            /* Wait till PLL is ready */
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
            {
              if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8008ac2:	f7fe faa7 	bl	8007014 <HAL_GetTick>
 8008ac6:	1b40      	subs	r0, r0, r5
 8008ac8:	2802      	cmp	r0, #2
 8008aca:	d9cb      	bls.n	8008a64 <HAL_RCC_OscConfig+0x484>
 8008acc:	e605      	b.n	80086da <HAL_RCC_OscConfig+0xfa>
      }
      else
      {
        /* PLL configuration is unchanged */
        /* Re-enable PLL if it was disabled (ie. low power mode) */
        if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8008ace:	6813      	ldr	r3, [r2, #0]
 8008ad0:	0199      	lsls	r1, r3, #6
 8008ad2:	d4ca      	bmi.n	8008a6a <HAL_RCC_OscConfig+0x48a>
        {
          /* Enable the main PLL. */
          __HAL_RCC_PLL_ENABLE();
 8008ad4:	6813      	ldr	r3, [r2, #0]
 8008ad6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8008ada:	6013      	str	r3, [r2, #0]

          /* Enable PLL System Clock output. */
          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8008adc:	68d3      	ldr	r3, [r2, #12]
 8008ade:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8008ae2:	60d3      	str	r3, [r2, #12]

          /* Get Start Tick*/
          tickstart = HAL_GetTick();
 8008ae4:	f7fe fa96 	bl	8007014 <HAL_GetTick>
 8008ae8:	4605      	mov	r5, r0

          /* Wait till PLL is ready */
          while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8008aea:	6823      	ldr	r3, [r4, #0]
 8008aec:	019a      	lsls	r2, r3, #6
 8008aee:	d4bc      	bmi.n	8008a6a <HAL_RCC_OscConfig+0x48a>
          {
            if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8008af0:	f7fe fa90 	bl	8007014 <HAL_GetTick>
 8008af4:	1b40      	subs	r0, r0, r5
 8008af6:	2802      	cmp	r0, #2
 8008af8:	d9f7      	bls.n	8008aea <HAL_RCC_OscConfig+0x50a>
 8008afa:	e5ee      	b.n	80086da <HAL_RCC_OscConfig+0xfa>
      }
    }
    else
    {
      /* Check that PLL is not used as system clock or not */
      if(sysclk_source != RCC_CFGR_SWS_PLL)
 8008afc:	2e0c      	cmp	r6, #12
 8008afe:	d01e      	beq.n	8008b3e <HAL_RCC_OscConfig+0x55e>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8008b00:	6823      	ldr	r3, [r4, #0]
 8008b02:	4a11      	ldr	r2, [pc, #68]	; (8008b48 <HAL_RCC_OscConfig+0x568>)
 8008b04:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8008b08:	6023      	str	r3, [r4, #0]

        /* Disable all PLL outputs to save power if no PLLs on */
#if defined(RCC_PLLSAI1_SUPPORT) && defined(RCC_CR_PLLSAI2RDY)
        if(READ_BIT(RCC->CR, (RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY)) == 0U)
 8008b0a:	6823      	ldr	r3, [r4, #0]
 8008b0c:	f013 5f20 	tst.w	r3, #671088640	; 0x28000000
        {
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 8008b10:	bf02      	ittt	eq
 8008b12:	68d3      	ldreq	r3, [r2, #12]
 8008b14:	f023 0303 	biceq.w	r3, r3, #3
 8008b18:	60d3      	streq	r3, [r2, #12]
#else
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
#endif /* RCC_PLLSAI1_SUPPORT && RCC_CR_PLLSAI2RDY */

#if defined(RCC_PLLSAI2_SUPPORT)
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
 8008b1a:	68e3      	ldr	r3, [r4, #12]
 8008b1c:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 8008b20:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8008b24:	60e3      	str	r3, [r4, #12]
#else
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK);
#endif /* RCC_PLLSAI2_SUPPORT */

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8008b26:	f7fe fa75 	bl	8007014 <HAL_GetTick>
 8008b2a:	4605      	mov	r5, r0

        /* Wait till PLL is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8008b2c:	6823      	ldr	r3, [r4, #0]
 8008b2e:	019b      	lsls	r3, r3, #6
 8008b30:	d59b      	bpl.n	8008a6a <HAL_RCC_OscConfig+0x48a>
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8008b32:	f7fe fa6f 	bl	8007014 <HAL_GetTick>
 8008b36:	1b40      	subs	r0, r0, r5
 8008b38:	2802      	cmp	r0, #2
 8008b3a:	d9f7      	bls.n	8008b2c <HAL_RCC_OscConfig+0x54c>
 8008b3c:	e5cd      	b.n	80086da <HAL_RCC_OscConfig+0xfa>
          }
        }
        else
        {
          /* PLL is already used as System core clock */
          return HAL_ERROR;
 8008b3e:	2001      	movs	r0, #1
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
}
 8008b40:	b003      	add	sp, #12
 8008b42:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8008b46:	bf00      	nop
 8008b48:	40021000 	.word	0x40021000
 8008b4c:	40007000 	.word	0x40007000
 8008b50:	019d800c 	.word	0x019d800c

08008b54 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8008b54:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8008b58:	460f      	mov	r7, r1
  uint32_t hpre = RCC_SYSCLK_DIV1;
#endif
  HAL_StatusTypeDef status;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 8008b5a:	4605      	mov	r5, r0
 8008b5c:	b910      	cbnz	r0, 8008b64 <HAL_RCC_ClockConfig+0x10>
  {
    return HAL_ERROR;
 8008b5e:	2001      	movs	r0, #1
 8008b60:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8008b64:	4a71      	ldr	r2, [pc, #452]	; (8008d2c <HAL_RCC_ClockConfig+0x1d8>)
 8008b66:	6813      	ldr	r3, [r2, #0]
 8008b68:	f003 030f 	and.w	r3, r3, #15
 8008b6c:	428b      	cmp	r3, r1
 8008b6e:	d304      	bcc.n	8008b7a <HAL_RCC_ClockConfig+0x26>
      return HAL_ERROR;
    }
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8008b70:	6828      	ldr	r0, [r5, #0]
 8008b72:	f010 0601 	ands.w	r6, r0, #1
 8008b76:	d10b      	bne.n	8008b90 <HAL_RCC_ClockConfig+0x3c>
 8008b78:	e08d      	b.n	8008c96 <HAL_RCC_ClockConfig+0x142>

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8008b7a:	6813      	ldr	r3, [r2, #0]
 8008b7c:	f023 030f 	bic.w	r3, r3, #15
 8008b80:	430b      	orrs	r3, r1
 8008b82:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8008b84:	6813      	ldr	r3, [r2, #0]
 8008b86:	f003 030f 	and.w	r3, r3, #15
 8008b8a:	4299      	cmp	r1, r3
 8008b8c:	d1e7      	bne.n	8008b5e <HAL_RCC_ClockConfig+0xa>
 8008b8e:	e7ef      	b.n	8008b70 <HAL_RCC_ClockConfig+0x1c>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* PLL is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8008b90:	686b      	ldr	r3, [r5, #4]
 8008b92:	4c67      	ldr	r4, [pc, #412]	; (8008d30 <HAL_RCC_ClockConfig+0x1dc>)
 8008b94:	2b03      	cmp	r3, #3
 8008b96:	d148      	bne.n	8008c2a <HAL_RCC_ClockConfig+0xd6>
    {
      /* Check the PLL ready flag */
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8008b98:	6823      	ldr	r3, [r4, #0]
 8008b9a:	019b      	lsls	r3, r3, #6
 8008b9c:	d5df      	bpl.n	8008b5e <HAL_RCC_ClockConfig+0xa>
static uint32_t RCC_GetSysClockFreqFromPLLSource(void)
{
  uint32_t msirange = 0U;
  uint32_t pllvco, pllsource, pllr, pllm, sysclockfreq;  /* no init needed */

  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)
 8008b9e:	68e3      	ldr	r3, [r4, #12]
 8008ba0:	f003 0303 	and.w	r3, r3, #3
 8008ba4:	2b01      	cmp	r3, #1
 8008ba6:	d10d      	bne.n	8008bc4 <HAL_RCC_ClockConfig+0x70>
  {
    /* Get MSI range source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 8008ba8:	6823      	ldr	r3, [r4, #0]
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 8008baa:	4a62      	ldr	r2, [pc, #392]	; (8008d34 <HAL_RCC_ClockConfig+0x1e0>)
  uint32_t pllvco, pllsource, pllr, pllm, sysclockfreq;  /* no init needed */

  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)
  {
    /* Get MSI range source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 8008bac:	071e      	lsls	r6, r3, #28
    { /* MSISRANGE from RCC_CSR applies */
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8008bae:	bf55      	itete	pl
 8008bb0:	f8d4 3094 	ldrpl.w	r3, [r4, #148]	; 0x94
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8008bb4:	6823      	ldrmi	r3, [r4, #0]
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)
  {
    /* Get MSI range source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
    { /* MSISRANGE from RCC_CSR applies */
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8008bb6:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8008bba:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 8008bbe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8008bc2:	e000      	b.n	8008bc6 <HAL_RCC_ClockConfig+0x72>
  * @brief  Compute SYSCLK frequency based on PLL SYSCLK source.
  * @retval SYSCLK frequency
  */
static uint32_t RCC_GetSysClockFreqFromPLLSource(void)
{
  uint32_t msirange = 0U;
 8008bc4:	2300      	movs	r3, #0
  }

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE) * PLLN / PLLM
     SYSCLK = PLL_VCO / PLLR
   */
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8008bc6:	68e2      	ldr	r2, [r4, #12]

  switch (pllsource)
 8008bc8:	f002 0203 	and.w	r2, r2, #3
 8008bcc:	2a02      	cmp	r2, #2
 8008bce:	d004      	beq.n	8008bda <HAL_RCC_ClockConfig+0x86>
  case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
    pllvco = HSI_VALUE;
    break;

  case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
    pllvco = HSE_VALUE;
 8008bd0:	4959      	ldr	r1, [pc, #356]	; (8008d38 <HAL_RCC_ClockConfig+0x1e4>)
 8008bd2:	2a03      	cmp	r2, #3
 8008bd4:	bf08      	it	eq
 8008bd6:	460b      	moveq	r3, r1
 8008bd8:	e000      	b.n	8008bdc <HAL_RCC_ClockConfig+0x88>
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);

  switch (pllsource)
  {
  case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
    pllvco = HSI_VALUE;
 8008bda:	4b58      	ldr	r3, [pc, #352]	; (8008d3c <HAL_RCC_ClockConfig+0x1e8>)
  case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
  default:
    pllvco = msirange;
    break;
  }
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8008bdc:	68e2      	ldr	r2, [r4, #12]
  pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 8008bde:	68e1      	ldr	r1, [r4, #12]
  case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
  default:
    pllvco = msirange;
    break;
  }
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8008be0:	4e53      	ldr	r6, [pc, #332]	; (8008d30 <HAL_RCC_ClockConfig+0x1dc>)
  pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 8008be2:	f3c1 2106 	ubfx	r1, r1, #8, #7
 8008be6:	434b      	muls	r3, r1
  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8008be8:	68e1      	ldr	r1, [r4, #12]
      }
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
    defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
      /* Undershoot management when selection PLL as SYSCLK source and frequency above 80Mhz */
      /* Compute target PLL output frequency */
      if(RCC_GetSysClockFreqFromPLLSource() > 80000000U)
 8008bea:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8008bee:	3201      	adds	r2, #1
 8008bf0:	fbb3 f2f2 	udiv	r2, r3, r2
 8008bf4:	f3c1 6341 	ubfx	r3, r1, #25, #2
 8008bf8:	3301      	adds	r3, #1
 8008bfa:	005b      	lsls	r3, r3, #1
 8008bfc:	fbb2 f3f3 	udiv	r3, r2, r3
 8008c00:	4a4f      	ldr	r2, [pc, #316]	; (8008d40 <HAL_RCC_ClockConfig+0x1ec>)
 8008c02:	4293      	cmp	r3, r2
 8008c04:	d801      	bhi.n	8008c0a <HAL_RCC_ClockConfig+0xb6>
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
  uint32_t tickstart;
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
    defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  uint32_t hpre = RCC_SYSCLK_DIV1;
 8008c06:	2600      	movs	r6, #0
 8008c08:	e02a      	b.n	8008c60 <HAL_RCC_ClockConfig+0x10c>
    defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
      /* Undershoot management when selection PLL as SYSCLK source and frequency above 80Mhz */
      /* Compute target PLL output frequency */
      if(RCC_GetSysClockFreqFromPLLSource() > 80000000U)
      {
        if(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)
 8008c0a:	68b3      	ldr	r3, [r6, #8]
 8008c0c:	f013 0ff0 	tst.w	r3, #240	; 0xf0
 8008c10:	d004      	beq.n	8008c1c <HAL_RCC_ClockConfig+0xc8>
        {
          /* Intermediate step with HCLK prescaler 2 necessary before to go over 80Mhz */
          MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
          hpre = RCC_SYSCLK_DIV2;
        }
        else if((((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK) && (RCC_ClkInitStruct->AHBCLKDivider == RCC_SYSCLK_DIV1))
 8008c12:	0781      	lsls	r1, r0, #30
 8008c14:	d5f7      	bpl.n	8008c06 <HAL_RCC_ClockConfig+0xb2>
 8008c16:	68ab      	ldr	r3, [r5, #8]
 8008c18:	2b00      	cmp	r3, #0
 8008c1a:	d1f4      	bne.n	8008c06 <HAL_RCC_ClockConfig+0xb2>
        {
          /* Intermediate step with HCLK prescaler 2 necessary before to go over 80Mhz */
          MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 8008c1c:	68b3      	ldr	r3, [r6, #8]
 8008c1e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8008c22:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8008c26:	60b3      	str	r3, [r6, #8]
 8008c28:	e019      	b.n	8008c5e <HAL_RCC_ClockConfig+0x10a>
#endif
    }
    else
    {
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8008c2a:	2b02      	cmp	r3, #2
 8008c2c:	d103      	bne.n	8008c36 <HAL_RCC_ClockConfig+0xe2>
      {
        /* Check the HSE ready flag */
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8008c2e:	6823      	ldr	r3, [r4, #0]
 8008c30:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8008c34:	e007      	b.n	8008c46 <HAL_RCC_ClockConfig+0xf2>
        {
          return HAL_ERROR;
        }
      }
      /* MSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8008c36:	b91b      	cbnz	r3, 8008c40 <HAL_RCC_ClockConfig+0xec>
      {
        /* Check the MSI ready flag */
        if(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8008c38:	6823      	ldr	r3, [r4, #0]
 8008c3a:	f013 0f02 	tst.w	r3, #2
 8008c3e:	e002      	b.n	8008c46 <HAL_RCC_ClockConfig+0xf2>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8008c40:	6823      	ldr	r3, [r4, #0]
 8008c42:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8008c46:	d08a      	beq.n	8008b5e <HAL_RCC_ClockConfig+0xa>
        }
      }
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
    defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
      /* Overshoot management when going down from PLL as SYSCLK source and frequency above 80Mhz */
      if(HAL_RCC_GetSysClockFreq() > 80000000U)
 8008c48:	f7ff fc78 	bl	800853c <HAL_RCC_GetSysClockFreq>
 8008c4c:	4b3c      	ldr	r3, [pc, #240]	; (8008d40 <HAL_RCC_ClockConfig+0x1ec>)
 8008c4e:	4298      	cmp	r0, r3
 8008c50:	d9d9      	bls.n	8008c06 <HAL_RCC_ClockConfig+0xb2>
      {
        /* Intermediate step with HCLK prescaler 2 necessary before to go under 80Mhz */
        MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 8008c52:	68a3      	ldr	r3, [r4, #8]
 8008c54:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8008c58:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8008c5c:	60a3      	str	r3, [r4, #8]
        hpre = RCC_SYSCLK_DIV2;
 8008c5e:	2680      	movs	r6, #128	; 0x80
      }
#endif

    }

    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8008c60:	68a3      	ldr	r3, [r4, #8]
 8008c62:	f023 0203 	bic.w	r2, r3, #3
 8008c66:	686b      	ldr	r3, [r5, #4]
 8008c68:	4313      	orrs	r3, r2
 8008c6a:	60a3      	str	r3, [r4, #8]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8008c6c:	f7fe f9d2 	bl	8007014 <HAL_GetTick>

    while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
    {
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8008c70:	f241 3988 	movw	r9, #5000	; 0x1388
    }

    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8008c74:	4680      	mov	r8, r0

    while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8008c76:	68a3      	ldr	r3, [r4, #8]
 8008c78:	686a      	ldr	r2, [r5, #4]
 8008c7a:	f003 030c 	and.w	r3, r3, #12
 8008c7e:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8008c82:	d008      	beq.n	8008c96 <HAL_RCC_ClockConfig+0x142>
    {
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8008c84:	f7fe f9c6 	bl	8007014 <HAL_GetTick>
 8008c88:	ebc8 0000 	rsb	r0, r8, r0
 8008c8c:	4548      	cmp	r0, r9
 8008c8e:	d9f2      	bls.n	8008c76 <HAL_RCC_ClockConfig+0x122>
      {
        return HAL_TIMEOUT;
 8008c90:	2003      	movs	r0, #3

  /* Configure the source of time base considering new system clocks settings*/
  status = HAL_InitTick(uwTickPrio);

  return status;
}
 8008c92:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      }
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8008c96:	6829      	ldr	r1, [r5, #0]
 8008c98:	078a      	lsls	r2, r1, #30
 8008c9a:	d507      	bpl.n	8008cac <HAL_RCC_ClockConfig+0x158>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8008c9c:	4824      	ldr	r0, [pc, #144]	; (8008d30 <HAL_RCC_ClockConfig+0x1dc>)
 8008c9e:	6883      	ldr	r3, [r0, #8]
 8008ca0:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8008ca4:	68ab      	ldr	r3, [r5, #8]
 8008ca6:	4313      	orrs	r3, r2
 8008ca8:	6083      	str	r3, [r0, #8]
 8008caa:	e006      	b.n	8008cba <HAL_RCC_ClockConfig+0x166>
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
    defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  else
  {
    /* Is intermediate HCLK prescaler 2 applied internally, complete with HCLK prescaler 1 */
    if(hpre == RCC_SYSCLK_DIV2)
 8008cac:	2e80      	cmp	r6, #128	; 0x80
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
 8008cae:	bf01      	itttt	eq
 8008cb0:	4a1f      	ldreq	r2, [pc, #124]	; (8008d30 <HAL_RCC_ClockConfig+0x1dc>)
 8008cb2:	6893      	ldreq	r3, [r2, #8]
 8008cb4:	f023 03f0 	biceq.w	r3, r3, #240	; 0xf0
 8008cb8:	6093      	streq	r3, [r2, #8]
    }
  }
#endif

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8008cba:	4a1c      	ldr	r2, [pc, #112]	; (8008d2c <HAL_RCC_ClockConfig+0x1d8>)
 8008cbc:	6813      	ldr	r3, [r2, #0]
 8008cbe:	f003 030f 	and.w	r3, r3, #15
 8008cc2:	429f      	cmp	r7, r3
 8008cc4:	d30a      	bcc.n	8008cdc <HAL_RCC_ClockConfig+0x188>
      return HAL_ERROR;
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8008cc6:	f011 0f04 	tst.w	r1, #4
 8008cca:	4c19      	ldr	r4, [pc, #100]	; (8008d30 <HAL_RCC_ClockConfig+0x1dc>)
 8008ccc:	d012      	beq.n	8008cf4 <HAL_RCC_ClockConfig+0x1a0>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8008cce:	68a3      	ldr	r3, [r4, #8]
 8008cd0:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 8008cd4:	68eb      	ldr	r3, [r5, #12]
 8008cd6:	4313      	orrs	r3, r2
 8008cd8:	60a3      	str	r3, [r4, #8]
 8008cda:	e00b      	b.n	8008cf4 <HAL_RCC_ClockConfig+0x1a0>

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8008cdc:	6813      	ldr	r3, [r2, #0]
 8008cde:	f023 030f 	bic.w	r3, r3, #15
 8008ce2:	433b      	orrs	r3, r7
 8008ce4:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8008ce6:	6813      	ldr	r3, [r2, #0]
 8008ce8:	f003 030f 	and.w	r3, r3, #15
 8008cec:	429f      	cmp	r7, r3
 8008cee:	f47f af36 	bne.w	8008b5e <HAL_RCC_ClockConfig+0xa>
 8008cf2:	e7e8      	b.n	8008cc6 <HAL_RCC_ClockConfig+0x172>
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8008cf4:	070b      	lsls	r3, r1, #28
 8008cf6:	d506      	bpl.n	8008d06 <HAL_RCC_ClockConfig+0x1b2>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8008cf8:	68a3      	ldr	r3, [r4, #8]
 8008cfa:	692a      	ldr	r2, [r5, #16]
 8008cfc:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8008d00:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 8008d04:	60a3      	str	r3, [r4, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8008d06:	f7ff fc19 	bl	800853c <HAL_RCC_GetSysClockFreq>
 8008d0a:	68a3      	ldr	r3, [r4, #8]
 8008d0c:	4a0d      	ldr	r2, [pc, #52]	; (8008d44 <HAL_RCC_ClockConfig+0x1f0>)
 8008d0e:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8008d12:	5cd3      	ldrb	r3, [r2, r3]
 8008d14:	f003 031f 	and.w	r3, r3, #31
 8008d18:	40d8      	lsrs	r0, r3
 8008d1a:	4b0b      	ldr	r3, [pc, #44]	; (8008d48 <HAL_RCC_ClockConfig+0x1f4>)
 8008d1c:	6018      	str	r0, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  status = HAL_InitTick(uwTickPrio);
 8008d1e:	4b0b      	ldr	r3, [pc, #44]	; (8008d4c <HAL_RCC_ClockConfig+0x1f8>)
 8008d20:	6818      	ldr	r0, [r3, #0]

  return status;
}
 8008d22:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);

  /* Configure the source of time base considering new system clocks settings*/
  status = HAL_InitTick(uwTickPrio);
 8008d26:	f7fe b977 	b.w	8007018 <HAL_InitTick>
 8008d2a:	bf00      	nop
 8008d2c:	40022000 	.word	0x40022000
 8008d30:	40021000 	.word	0x40021000
 8008d34:	0800e740 	.word	0x0800e740
 8008d38:	007a1200 	.word	0x007a1200
 8008d3c:	00f42400 	.word	0x00f42400
 8008d40:	04c4b400 	.word	0x04c4b400
 8008d44:	0800e728 	.word	0x0800e728
 8008d48:	20000448 	.word	0x20000448
 8008d4c:	20000238 	.word	0x20000238

08008d50 <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 8008d50:	4b01      	ldr	r3, [pc, #4]	; (8008d58 <HAL_RCC_GetHCLKFreq+0x8>)
 8008d52:	6818      	ldr	r0, [r3, #0]
 8008d54:	4770      	bx	lr
 8008d56:	bf00      	nop
 8008d58:	20000448 	.word	0x20000448

08008d5c <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 8008d5c:	4b05      	ldr	r3, [pc, #20]	; (8008d74 <HAL_RCC_GetPCLK1Freq+0x18>)
 8008d5e:	4a06      	ldr	r2, [pc, #24]	; (8008d78 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8008d60:	689b      	ldr	r3, [r3, #8]
 8008d62:	f3c3 2302 	ubfx	r3, r3, #8, #3
 8008d66:	5cd3      	ldrb	r3, [r2, r3]
 8008d68:	4a04      	ldr	r2, [pc, #16]	; (8008d7c <HAL_RCC_GetPCLK1Freq+0x20>)
 8008d6a:	6810      	ldr	r0, [r2, #0]
 8008d6c:	f003 031f 	and.w	r3, r3, #31
}
 8008d70:	40d8      	lsrs	r0, r3
 8008d72:	4770      	bx	lr
 8008d74:	40021000 	.word	0x40021000
 8008d78:	0800e738 	.word	0x0800e738
 8008d7c:	20000448 	.word	0x20000448

08008d80 <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 8008d80:	4b05      	ldr	r3, [pc, #20]	; (8008d98 <HAL_RCC_GetPCLK2Freq+0x18>)
 8008d82:	4a06      	ldr	r2, [pc, #24]	; (8008d9c <HAL_RCC_GetPCLK2Freq+0x1c>)
 8008d84:	689b      	ldr	r3, [r3, #8]
 8008d86:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 8008d8a:	5cd3      	ldrb	r3, [r2, r3]
 8008d8c:	4a04      	ldr	r2, [pc, #16]	; (8008da0 <HAL_RCC_GetPCLK2Freq+0x20>)
 8008d8e:	6810      	ldr	r0, [r2, #0]
 8008d90:	f003 031f 	and.w	r3, r3, #31
}
 8008d94:	40d8      	lsrs	r0, r3
 8008d96:	4770      	bx	lr
 8008d98:	40021000 	.word	0x40021000
 8008d9c:	0800e738 	.word	0x0800e738
 8008da0:	20000448 	.word	0x20000448

08008da4 <HAL_RCC_GetOscConfig>:
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != (void *)NULL);

  /* Set all possible values for the Oscillator type parameter ---------------*/
#if defined(RCC_HSI48_SUPPORT)
  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_MSI | \
 8008da4:	233f      	movs	r3, #63	; 0x3f
 8008da6:	6003      	str	r3, [r0, #0]
  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_MSI | \
                                      RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;
#endif /* RCC_HSI48_SUPPORT */

  /* Get the HSE configuration -----------------------------------------------*/
  if(READ_BIT(RCC->CR, RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
 8008da8:	4b32      	ldr	r3, [pc, #200]	; (8008e74 <HAL_RCC_GetOscConfig+0xd0>)
 8008daa:	681a      	ldr	r2, [r3, #0]
 8008dac:	0352      	lsls	r2, r2, #13
 8008dae:	d502      	bpl.n	8008db6 <HAL_RCC_GetOscConfig+0x12>
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
 8008db0:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
 8008db4:	e005      	b.n	8008dc2 <HAL_RCC_GetOscConfig+0x1e>
  }
  else if(READ_BIT(RCC->CR, RCC_CR_HSEON) == RCC_CR_HSEON)
 8008db6:	681a      	ldr	r2, [r3, #0]
 8008db8:	f412 3280 	ands.w	r2, r2, #65536	; 0x10000
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_ON;
 8008dbc:	bf18      	it	ne
 8008dbe:	f44f 3280 	movne.w	r2, #65536	; 0x10000
  }
  else
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
 8008dc2:	6042      	str	r2, [r0, #4]
  }

   /* Get the MSI configuration -----------------------------------------------*/
  if(READ_BIT(RCC->CR, RCC_CR_MSION) == RCC_CR_MSION)
 8008dc4:	681a      	ldr	r2, [r3, #0]
 8008dc6:	f012 0201 	ands.w	r2, r2, #1
  {
    RCC_OscInitStruct->MSIState = RCC_MSI_ON;
 8008dca:	bf18      	it	ne
 8008dcc:	2201      	movne	r2, #1
  }
  else
  {
    RCC_OscInitStruct->MSIState = RCC_MSI_OFF;
 8008dce:	6182      	str	r2, [r0, #24]
  }

  RCC_OscInitStruct->MSICalibrationValue = READ_BIT(RCC->ICSCR, RCC_ICSCR_MSITRIM) >> RCC_ICSCR_MSITRIM_Pos;
 8008dd0:	685a      	ldr	r2, [r3, #4]
 8008dd2:	f3c2 2207 	ubfx	r2, r2, #8, #8
 8008dd6:	61c2      	str	r2, [r0, #28]
  RCC_OscInitStruct->MSIClockRange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE);
 8008dd8:	681a      	ldr	r2, [r3, #0]
 8008dda:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8008dde:	6202      	str	r2, [r0, #32]

  /* Get the HSI configuration -----------------------------------------------*/
  if(READ_BIT(RCC->CR, RCC_CR_HSION) == RCC_CR_HSION)
 8008de0:	681a      	ldr	r2, [r3, #0]
 8008de2:	f412 7280 	ands.w	r2, r2, #256	; 0x100
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_ON;
 8008de6:	bf18      	it	ne
 8008de8:	f44f 7280 	movne.w	r2, #256	; 0x100
  }
  else
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
 8008dec:	60c2      	str	r2, [r0, #12]
  }

  RCC_OscInitStruct->HSICalibrationValue = READ_BIT(RCC->ICSCR, RCC_ICSCR_HSITRIM) >> RCC_ICSCR_HSITRIM_Pos;
 8008dee:	685a      	ldr	r2, [r3, #4]
 8008df0:	f3c2 6206 	ubfx	r2, r2, #24, #7
 8008df4:	6102      	str	r2, [r0, #16]

  /* Get the LSE configuration -----------------------------------------------*/
  if(READ_BIT(RCC->BDCR, RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
 8008df6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8008dfa:	0751      	lsls	r1, r2, #29
 8008dfc:	d501      	bpl.n	8008e02 <HAL_RCC_GetOscConfig+0x5e>
      RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS_RTC_ONLY;
    }
    else
#endif /* RCC_BDCR_LSESYSDIS */
    {
      RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
 8008dfe:	2205      	movs	r2, #5
 8008e00:	e006      	b.n	8008e10 <HAL_RCC_GetOscConfig+0x6c>
    }
  }
  else if(READ_BIT(RCC->BDCR, RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
 8008e02:	4a1c      	ldr	r2, [pc, #112]	; (8008e74 <HAL_RCC_GetOscConfig+0xd0>)
 8008e04:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 8008e08:	f012 0201 	ands.w	r2, r2, #1
      RCC_OscInitStruct->LSEState = RCC_LSE_ON_RTC_ONLY;
    }
    else
#endif /* RCC_BDCR_LSESYSDIS */
    {
      RCC_OscInitStruct->LSEState = RCC_LSE_ON;
 8008e0c:	bf18      	it	ne
 8008e0e:	2201      	movne	r2, #1
    }
  }
  else
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
 8008e10:	6082      	str	r2, [r0, #8]
  }

  /* Get the LSI configuration -----------------------------------------------*/
  if(READ_BIT(RCC->CSR, RCC_CSR_LSION) == RCC_CSR_LSION)
 8008e12:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8008e16:	f012 0201 	ands.w	r2, r2, #1
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_ON;
 8008e1a:	bf18      	it	ne
 8008e1c:	2201      	movne	r2, #1
  }
  else
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
 8008e1e:	6142      	str	r2, [r0, #20]
  }
#endif /* RCC_CSR_LSIPREDIV */

#if defined(RCC_HSI48_SUPPORT)
  /* Get the HSI48 configuration ---------------------------------------------*/
  if(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48ON) == RCC_CRRCR_HSI48ON)
 8008e20:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 8008e24:	f012 0201 	ands.w	r2, r2, #1
  {
    RCC_OscInitStruct->HSI48State = RCC_HSI48_ON;
 8008e28:	bf18      	it	ne
 8008e2a:	2201      	movne	r2, #1
  }
  else
  {
    RCC_OscInitStruct->HSI48State = RCC_HSI48_OFF;
 8008e2c:	6242      	str	r2, [r0, #36]	; 0x24
#else
  RCC_OscInitStruct->HSI48State = RCC_HSI48_OFF;
#endif /* RCC_HSI48_SUPPORT */

  /* Get the PLL configuration -----------------------------------------------*/
  if(READ_BIT(RCC->CR, RCC_CR_PLLON) == RCC_CR_PLLON)
 8008e2e:	681a      	ldr	r2, [r3, #0]
 8008e30:	01d2      	lsls	r2, r2, #7
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
 8008e32:	bf4c      	ite	mi
 8008e34:	2202      	movmi	r2, #2
  }
  else
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
 8008e36:	2201      	movpl	r2, #1
 8008e38:	6282      	str	r2, [r0, #40]	; 0x28
  }
  RCC_OscInitStruct->PLL.PLLSource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8008e3a:	68da      	ldr	r2, [r3, #12]
 8008e3c:	f002 0203 	and.w	r2, r2, #3
 8008e40:	62c2      	str	r2, [r0, #44]	; 0x2c
  RCC_OscInitStruct->PLL.PLLM = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U;
 8008e42:	68da      	ldr	r2, [r3, #12]
 8008e44:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8008e48:	3201      	adds	r2, #1
 8008e4a:	6302      	str	r2, [r0, #48]	; 0x30
  RCC_OscInitStruct->PLL.PLLN = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
 8008e4c:	68da      	ldr	r2, [r3, #12]
 8008e4e:	f3c2 2206 	ubfx	r2, r2, #8, #7
 8008e52:	6342      	str	r2, [r0, #52]	; 0x34
  RCC_OscInitStruct->PLL.PLLQ = (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U);
 8008e54:	68da      	ldr	r2, [r3, #12]
 8008e56:	f3c2 5241 	ubfx	r2, r2, #21, #2
 8008e5a:	3201      	adds	r2, #1
 8008e5c:	0052      	lsls	r2, r2, #1
 8008e5e:	63c2      	str	r2, [r0, #60]	; 0x3c
  RCC_OscInitStruct->PLL.PLLR = (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) << 1U);
 8008e60:	68da      	ldr	r2, [r3, #12]
 8008e62:	f3c2 6241 	ubfx	r2, r2, #25, #2
 8008e66:	3201      	adds	r2, #1
 8008e68:	0052      	lsls	r2, r2, #1
 8008e6a:	6402      	str	r2, [r0, #64]	; 0x40
#if defined(RCC_PLLP_SUPPORT)
#if defined(RCC_PLLP_DIV_2_31_SUPPORT)
  RCC_OscInitStruct->PLL.PLLP = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLPDIV) >> RCC_PLLCFGR_PLLPDIV_Pos;
 8008e6c:	68db      	ldr	r3, [r3, #12]
 8008e6e:	0edb      	lsrs	r3, r3, #27
 8008e70:	6383      	str	r3, [r0, #56]	; 0x38
 8008e72:	4770      	bx	lr
 8008e74:	40021000 	.word	0x40021000

08008e78 <HAL_RCC_GetClockConfig>:
  /* Check the parameters */
  assert_param(RCC_ClkInitStruct != (void  *)NULL);
  assert_param(pFLatency != (void *)NULL);

  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 8008e78:	230f      	movs	r3, #15
 8008e7a:	6003      	str	r3, [r0, #0]

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = READ_BIT(RCC->CFGR, RCC_CFGR_SW);
 8008e7c:	4b0b      	ldr	r3, [pc, #44]	; (8008eac <HAL_RCC_GetClockConfig+0x34>)
 8008e7e:	689a      	ldr	r2, [r3, #8]
 8008e80:	f002 0203 	and.w	r2, r2, #3
 8008e84:	6042      	str	r2, [r0, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = READ_BIT(RCC->CFGR, RCC_CFGR_HPRE);
 8008e86:	689a      	ldr	r2, [r3, #8]
 8008e88:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8008e8c:	6082      	str	r2, [r0, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1);
 8008e8e:	689a      	ldr	r2, [r3, #8]
 8008e90:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8008e94:	60c2      	str	r2, [r0, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> 3U);
 8008e96:	689b      	ldr	r3, [r3, #8]
 8008e98:	08db      	lsrs	r3, r3, #3
 8008e9a:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8008e9e:	6103      	str	r3, [r0, #16]

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = __HAL_FLASH_GET_LATENCY();
 8008ea0:	4b03      	ldr	r3, [pc, #12]	; (8008eb0 <HAL_RCC_GetClockConfig+0x38>)
 8008ea2:	681b      	ldr	r3, [r3, #0]
 8008ea4:	f003 030f 	and.w	r3, r3, #15
 8008ea8:	600b      	str	r3, [r1, #0]
 8008eaa:	4770      	bx	lr
 8008eac:	40021000 	.word	0x40021000
 8008eb0:	40022000 	.word	0x40022000

08008eb4 <HAL_RCC_EnableCSS>:
  * @note   The Clock Security System can only be cleared by reset.
  * @retval None
  */
void HAL_RCC_EnableCSS(void)
{
  SET_BIT(RCC->CR, RCC_CR_CSSON) ;
 8008eb4:	4a02      	ldr	r2, [pc, #8]	; (8008ec0 <HAL_RCC_EnableCSS+0xc>)
 8008eb6:	6813      	ldr	r3, [r2, #0]
 8008eb8:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8008ebc:	6013      	str	r3, [r2, #0]
 8008ebe:	4770      	bx	lr
 8008ec0:	40021000 	.word	0x40021000

08008ec4 <HAL_RCC_CSSCallback>:
/**
  * @brief  RCC Clock Security System interrupt callback.
  * @retval none
  */
__weak void HAL_RCC_CSSCallback(void)
{
 8008ec4:	4770      	bx	lr
	...

08008ec8 <HAL_RCC_NMI_IRQHandler>:
  * @brief Handle the RCC Clock Security System interrupt request.
  * @note This API should be called under the NMI_Handler().
  * @retval None
  */
void HAL_RCC_NMI_IRQHandler(void)
{
 8008ec8:	b510      	push	{r4, lr}
  /* Check RCC CSSF interrupt flag  */
  if(__HAL_RCC_GET_IT(RCC_IT_CSS))
 8008eca:	4c05      	ldr	r4, [pc, #20]	; (8008ee0 <HAL_RCC_NMI_IRQHandler+0x18>)
 8008ecc:	69e3      	ldr	r3, [r4, #28]
 8008ece:	05db      	lsls	r3, r3, #23
 8008ed0:	d504      	bpl.n	8008edc <HAL_RCC_NMI_IRQHandler+0x14>
  {
    /* RCC Clock Security System interrupt user callback */
    HAL_RCC_CSSCallback();
 8008ed2:	f7ff fff7 	bl	8008ec4 <HAL_RCC_CSSCallback>

    /* Clear RCC CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
 8008ed6:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008eda:	6223      	str	r3, [r4, #32]
 8008edc:	bd10      	pop	{r4, pc}
 8008ede:	bf00      	nop
 8008ee0:	40021000 	.word	0x40021000

08008ee4 <RCCEx_GetSAIxPeriphCLKFreq>:
#if defined(RCC_PLLP_SUPPORT)
  uint32_t pllp = 0U;
#endif /* RCC_PLLP_SUPPORT */

  /* Handle SAIs */
  if(PeriphClk == RCC_PERIPHCLK_SAI1)
 8008ee4:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
#endif /* RCC_PLLSAI2_SUPPORT */

#if defined(SAI1)

static uint32_t RCCEx_GetSAIxPeriphCLKFreq(uint32_t PeriphClk, uint32_t InputFrequency)
{
 8008ee8:	b510      	push	{r4, lr}
 8008eea:	4a3e      	ldr	r2, [pc, #248]	; (8008fe4 <RCCEx_GetSAIxPeriphCLKFreq+0x100>)
#if defined(RCC_PLLP_SUPPORT)
  uint32_t pllp = 0U;
#endif /* RCC_PLLP_SUPPORT */

  /* Handle SAIs */
  if(PeriphClk == RCC_PERIPHCLK_SAI1)
 8008eec:	d106      	bne.n	8008efc <RCCEx_GetSAIxPeriphCLKFreq+0x18>
  {
    srcclk = __HAL_RCC_GET_SAI1_SOURCE();
 8008eee:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 8008ef2:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
    if(srcclk == RCC_SAI1CLKSOURCE_PIN)
 8008ef6:	2b60      	cmp	r3, #96	; 0x60
 8008ef8:	d171      	bne.n	8008fde <RCCEx_GetSAIxPeriphCLKFreq+0xfa>
 8008efa:	e06b      	b.n	8008fd4 <RCCEx_GetSAIxPeriphCLKFreq+0xf0>
    /* Else, PLL clock output to check below */
  }
#if defined(SAI2)
  else
  {
    if(PeriphClk == RCC_PERIPHCLK_SAI2)
 8008efc:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
 8008f00:	d121      	bne.n	8008f46 <RCCEx_GetSAIxPeriphCLKFreq+0x62>
    {
      srcclk = __HAL_RCC_GET_SAI2_SOURCE();
 8008f02:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 8008f06:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
      if(srcclk == RCC_SAI2CLKSOURCE_PIN)
 8008f0a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8008f0e:	d061      	beq.n	8008fd4 <RCCEx_GetSAIxPeriphCLKFreq+0xf0>
  if(frequency == 0U)
  {
    pllvco = InputFrequency;

#if defined(SAI2)
    if((srcclk == RCC_SAI1CLKSOURCE_PLL) || (srcclk == RCC_SAI2CLKSOURCE_PLL))
 8008f10:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8008f14:	d116      	bne.n	8008f44 <RCCEx_GetSAIxPeriphCLKFreq+0x60>
    {
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY) && (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL_SAI3CLK) != 0U))
 8008f16:	6810      	ldr	r0, [r2, #0]
 8008f18:	4c32      	ldr	r4, [pc, #200]	; (8008fe4 <RCCEx_GetSAIxPeriphCLKFreq+0x100>)
 8008f1a:	f010 7000 	ands.w	r0, r0, #33554432	; 0x2000000
 8008f1e:	d060      	beq.n	8008fe2 <RCCEx_GetSAIxPeriphCLKFreq+0xfe>
 8008f20:	68e0      	ldr	r0, [r4, #12]
 8008f22:	f410 3080 	ands.w	r0, r0, #65536	; 0x10000
 8008f26:	d05c      	beq.n	8008fe2 <RCCEx_GetSAIxPeriphCLKFreq+0xfe>
      {
        /* f(PLL Source) / PLLM */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 8008f28:	68e0      	ldr	r0, [r4, #12]
        /* f(PLLSAI3CLK) = f(VCO input) * PLLN / PLLP */
        plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
 8008f2a:	68e3      	ldr	r3, [r4, #12]
    if((srcclk == RCC_SAI1CLKSOURCE_PLL) || (srcclk == RCC_SAI2CLKSOURCE_PLL))
    {
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY) && (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL_SAI3CLK) != 0U))
      {
        /* f(PLL Source) / PLLM */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 8008f2c:	f3c0 1003 	ubfx	r0, r0, #4, #4
 8008f30:	3001      	adds	r0, #1
 8008f32:	fbb1 f1f0 	udiv	r1, r1, r0
        /* f(PLLSAI3CLK) = f(VCO input) * PLLN / PLLP */
        plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
#if defined(RCC_PLLP_DIV_2_31_SUPPORT)
        pllp = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLPDIV) >> RCC_PLLCFGR_PLLPDIV_Pos;
 8008f36:	68e0      	ldr	r0, [r4, #12]
#endif
        if(pllp == 0U)
 8008f38:	0ec0      	lsrs	r0, r0, #27
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY) && (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL_SAI3CLK) != 0U))
      {
        /* f(PLL Source) / PLLM */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
        /* f(PLLSAI3CLK) = f(VCO input) * PLLN / PLLP */
        plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
 8008f3a:	f3c3 2306 	ubfx	r3, r3, #8, #7
#if defined(RCC_PLLP_DIV_2_31_SUPPORT)
        pllp = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLPDIV) >> RCC_PLLCFGR_PLLPDIV_Pos;
#endif
        if(pllp == 0U)
 8008f3e:	d145      	bne.n	8008fcc <RCCEx_GetSAIxPeriphCLKFreq+0xe8>
        {
          if(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP) != 0U)
 8008f40:	68e2      	ldr	r2, [r4, #12]
 8008f42:	e03e      	b.n	8008fc2 <RCCEx_GetSAIxPeriphCLKFreq+0xde>
          }
        }
        frequency = (pllvco * plln) / pllp;
      }
    }
    else if(srcclk == 0U)  /* RCC_SAI1CLKSOURCE_PLLSAI1 || RCC_SAI2CLKSOURCE_PLLSAI1 */
 8008f44:	b9b3      	cbnz	r3, 8008f74 <RCCEx_GetSAIxPeriphCLKFreq+0x90>
    {
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI1RDY) && (__HAL_RCC_GET_PLLSAI1CLKOUT_CONFIG(RCC_PLLSAI1_SAI1CLK) != 0U))
 8008f46:	6810      	ldr	r0, [r2, #0]
 8008f48:	4c26      	ldr	r4, [pc, #152]	; (8008fe4 <RCCEx_GetSAIxPeriphCLKFreq+0x100>)
 8008f4a:	f010 6000 	ands.w	r0, r0, #134217728	; 0x8000000
 8008f4e:	d048      	beq.n	8008fe2 <RCCEx_GetSAIxPeriphCLKFreq+0xfe>
 8008f50:	6920      	ldr	r0, [r4, #16]
 8008f52:	f410 3080 	ands.w	r0, r0, #65536	; 0x10000
 8008f56:	d044      	beq.n	8008fe2 <RCCEx_GetSAIxPeriphCLKFreq+0xfe>
      {
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
        /* PLLSAI1M exists: apply PLLSAI1M divider for PLLSAI1 output computation */
        /* f(PLLSAI1 Source) / PLLSAI1M */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U));
 8008f58:	6920      	ldr	r0, [r4, #16]
#else
        /* f(PLL Source) / PLLM */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
#endif
        /* f(PLLSAI1CLK) = f(VCOSAI1 input) * PLLSAI1N / PLLSAI1P */
        plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
 8008f5a:	6923      	ldr	r3, [r4, #16]
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI1RDY) && (__HAL_RCC_GET_PLLSAI1CLKOUT_CONFIG(RCC_PLLSAI1_SAI1CLK) != 0U))
      {
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
        /* PLLSAI1M exists: apply PLLSAI1M divider for PLLSAI1 output computation */
        /* f(PLLSAI1 Source) / PLLSAI1M */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U));
 8008f5c:	f3c0 1003 	ubfx	r0, r0, #4, #4
 8008f60:	3001      	adds	r0, #1
 8008f62:	fbb1 f1f0 	udiv	r1, r1, r0
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
#endif
        /* f(PLLSAI1CLK) = f(VCOSAI1 input) * PLLSAI1N / PLLSAI1P */
        plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
#if defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
        pllp = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1PDIV) >> RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos;
 8008f66:	6920      	ldr	r0, [r4, #16]
#endif
        if(pllp == 0U)
 8008f68:	0ec0      	lsrs	r0, r0, #27
#else
        /* f(PLL Source) / PLLM */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
#endif
        /* f(PLLSAI1CLK) = f(VCOSAI1 input) * PLLSAI1N / PLLSAI1P */
        plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
 8008f6a:	f3c3 2306 	ubfx	r3, r3, #8, #7
#if defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
        pllp = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1PDIV) >> RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos;
#endif
        if(pllp == 0U)
 8008f6e:	d12d      	bne.n	8008fcc <RCCEx_GetSAIxPeriphCLKFreq+0xe8>
        {
          if(READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1P) != 0U)
 8008f70:	6922      	ldr	r2, [r4, #16]
 8008f72:	e026      	b.n	8008fc2 <RCCEx_GetSAIxPeriphCLKFreq+0xde>
        }
        frequency = (pllvco * plln) / pllp;
      }
    }
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    else if((srcclk == RCC_SAI1CLKSOURCE_HSI) || (srcclk == RCC_SAI2CLKSOURCE_HSI))
 8008f74:	2b80      	cmp	r3, #128	; 0x80
 8008f76:	d002      	beq.n	8008f7e <RCCEx_GetSAIxPeriphCLKFreq+0x9a>
 8008f78:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8008f7c:	d106      	bne.n	8008f8c <RCCEx_GetSAIxPeriphCLKFreq+0xa8>
    {
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8008f7e:	6813      	ldr	r3, [r2, #0]
      {
        frequency = HSI_VALUE;
 8008f80:	4819      	ldr	r0, [pc, #100]	; (8008fe8 <RCCEx_GetSAIxPeriphCLKFreq+0x104>)
 8008f82:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8008f86:	bf08      	it	eq
 8008f88:	2000      	moveq	r0, #0
 8008f8a:	bd10      	pop	{r4, pc}
    }
#endif /* SAI2 */

#if defined(RCC_PLLSAI2_SUPPORT)

    else if((srcclk == RCC_SAI1CLKSOURCE_PLLSAI2) || (srcclk == RCC_SAI2CLKSOURCE_PLLSAI2))
 8008f8c:	2b20      	cmp	r3, #32
 8008f8e:	d002      	beq.n	8008f96 <RCCEx_GetSAIxPeriphCLKFreq+0xb2>
 8008f90:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008f94:	d121      	bne.n	8008fda <RCCEx_GetSAIxPeriphCLKFreq+0xf6>
    {
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI2RDY) && (__HAL_RCC_GET_PLLSAI2CLKOUT_CONFIG(RCC_PLLSAI2_SAI2CLK) != 0U))
 8008f96:	6810      	ldr	r0, [r2, #0]
 8008f98:	4c12      	ldr	r4, [pc, #72]	; (8008fe4 <RCCEx_GetSAIxPeriphCLKFreq+0x100>)
 8008f9a:	f010 5000 	ands.w	r0, r0, #536870912	; 0x20000000
 8008f9e:	d020      	beq.n	8008fe2 <RCCEx_GetSAIxPeriphCLKFreq+0xfe>
 8008fa0:	6960      	ldr	r0, [r4, #20]
 8008fa2:	f410 3080 	ands.w	r0, r0, #65536	; 0x10000
 8008fa6:	d01c      	beq.n	8008fe2 <RCCEx_GetSAIxPeriphCLKFreq+0xfe>
      {
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
        /* PLLSAI2M exists: apply PLLSAI2M divider for PLLSAI2 output computation */
        /* f(PLLSAI2 Source) / PLLSAI2M */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2M) >> RCC_PLLSAI2CFGR_PLLSAI2M_Pos) + 1U));
 8008fa8:	6960      	ldr	r0, [r4, #20]
#else
        /* f(PLL Source) / PLLM */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
#endif
        /* f(PLLSAI2CLK) = f(VCOSAI2 input) * PLLSAI2N / PLLSAI2P */
        plln = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> RCC_PLLSAI2CFGR_PLLSAI2N_Pos;
 8008faa:	6963      	ldr	r3, [r4, #20]
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI2RDY) && (__HAL_RCC_GET_PLLSAI2CLKOUT_CONFIG(RCC_PLLSAI2_SAI2CLK) != 0U))
      {
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
        /* PLLSAI2M exists: apply PLLSAI2M divider for PLLSAI2 output computation */
        /* f(PLLSAI2 Source) / PLLSAI2M */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2M) >> RCC_PLLSAI2CFGR_PLLSAI2M_Pos) + 1U));
 8008fac:	f3c0 1003 	ubfx	r0, r0, #4, #4
 8008fb0:	3001      	adds	r0, #1
 8008fb2:	fbb1 f1f0 	udiv	r1, r1, r0
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
#endif
        /* f(PLLSAI2CLK) = f(VCOSAI2 input) * PLLSAI2N / PLLSAI2P */
        plln = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> RCC_PLLSAI2CFGR_PLLSAI2N_Pos;
#if defined(RCC_PLLSAI2P_DIV_2_31_SUPPORT)
        pllp = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2PDIV) >> RCC_PLLSAI2CFGR_PLLSAI2PDIV_Pos;
 8008fb6:	6960      	ldr	r0, [r4, #20]
#endif
        if(pllp == 0U)
 8008fb8:	0ec0      	lsrs	r0, r0, #27
#else
        /* f(PLL Source) / PLLM */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
#endif
        /* f(PLLSAI2CLK) = f(VCOSAI2 input) * PLLSAI2N / PLLSAI2P */
        plln = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> RCC_PLLSAI2CFGR_PLLSAI2N_Pos;
 8008fba:	f3c3 2306 	ubfx	r3, r3, #8, #7
#if defined(RCC_PLLSAI2P_DIV_2_31_SUPPORT)
        pllp = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2PDIV) >> RCC_PLLSAI2CFGR_PLLSAI2PDIV_Pos;
#endif
        if(pllp == 0U)
 8008fbe:	d105      	bne.n	8008fcc <RCCEx_GetSAIxPeriphCLKFreq+0xe8>
        {
          if(READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2P) != 0U)
 8008fc0:	6962      	ldr	r2, [r4, #20]
          {
            pllp = 17U;
          }
          else
          {
            pllp = 7U;
 8008fc2:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8008fc6:	bf14      	ite	ne
 8008fc8:	2011      	movne	r0, #17
 8008fca:	2007      	moveq	r0, #7
          }
        }
        frequency = (pllvco * plln) / pllp;
 8008fcc:	4359      	muls	r1, r3
 8008fce:	fbb1 f0f0 	udiv	r0, r1, r0
 8008fd2:	bd10      	pop	{r4, pc}
 8008fd4:	f64b 3080 	movw	r0, #48000	; 0xbb80
 8008fd8:	bd10      	pop	{r4, pc}
 8008fda:	2000      	movs	r0, #0
 8008fdc:	bd10      	pop	{r4, pc}
  if(frequency == 0U)
  {
    pllvco = InputFrequency;

#if defined(SAI2)
    if((srcclk == RCC_SAI1CLKSOURCE_PLL) || (srcclk == RCC_SAI2CLKSOURCE_PLL))
 8008fde:	2b40      	cmp	r3, #64	; 0x40
 8008fe0:	e798      	b.n	8008f14 <RCCEx_GetSAIxPeriphCLKFreq+0x30>
    }
  }


  return frequency;
}
 8008fe2:	bd10      	pop	{r4, pc}
 8008fe4:	40021000 	.word	0x40021000
 8008fe8:	00f42400 	.word	0x00f42400

08008fec <RCCEx_PLLSAI1_Config>:
  assert_param(IS_RCC_PLLSAI1M_VALUE(PllSai1->PLLSAI1M));
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));

  /* Check that PLLSAI1 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8008fec:	4b44      	ldr	r3, [pc, #272]	; (8009100 <RCCEx_PLLSAI1_Config+0x114>)
 8008fee:	68da      	ldr	r2, [r3, #12]
 8008ff0:	f012 0f03 	tst.w	r2, #3
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_Config(RCC_PLLSAI1InitTypeDef *PllSai1, uint32_t Divider)
{
 8008ff4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008ff8:	4604      	mov	r4, r0
 8008ffa:	460f      	mov	r7, r1
 8008ffc:	461d      	mov	r5, r3
 8008ffe:	6800      	ldr	r0, [r0, #0]
  assert_param(IS_RCC_PLLSAI1M_VALUE(PllSai1->PLLSAI1M));
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));

  /* Check that PLLSAI1 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8009000:	d006      	beq.n	8009010 <RCCEx_PLLSAI1_Config+0x24>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai1->PLLSAI1Source)
 8009002:	68db      	ldr	r3, [r3, #12]
 8009004:	f003 0303 	and.w	r3, r3, #3
 8009008:	4283      	cmp	r3, r0
 800900a:	d116      	bne.n	800903a <RCCEx_PLLSAI1_Config+0x4e>
       ||
 800900c:	b1ab      	cbz	r3, 800903a <RCCEx_PLLSAI1_Config+0x4e>
 800900e:	e01c      	b.n	800904a <RCCEx_PLLSAI1_Config+0x5e>
    }
  }
  else
  {
    /* Check PLLSAI1 clock source availability */
    switch(PllSai1->PLLSAI1Source)
 8009010:	2802      	cmp	r0, #2
 8009012:	d007      	beq.n	8009024 <RCCEx_PLLSAI1_Config+0x38>
 8009014:	2803      	cmp	r0, #3
 8009016:	d009      	beq.n	800902c <RCCEx_PLLSAI1_Config+0x40>
 8009018:	2801      	cmp	r0, #1
 800901a:	d10e      	bne.n	800903a <RCCEx_PLLSAI1_Config+0x4e>
    {
    case RCC_PLLSOURCE_MSI:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 800901c:	681b      	ldr	r3, [r3, #0]
 800901e:	079e      	lsls	r6, r3, #30
 8009020:	d56b      	bpl.n	80090fa <RCCEx_PLLSAI1_Config+0x10e>
 8009022:	e00d      	b.n	8009040 <RCCEx_PLLSAI1_Config+0x54>
      {
        status = HAL_ERROR;
      }
      break;
    case RCC_PLLSOURCE_HSI:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 8009024:	681b      	ldr	r3, [r3, #0]
 8009026:	f413 6f80 	tst.w	r3, #1024	; 0x400
 800902a:	e005      	b.n	8009038 <RCCEx_PLLSAI1_Config+0x4c>
      {
        status = HAL_ERROR;
      }
      break;
    case RCC_PLLSOURCE_HSE:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
 800902c:	681a      	ldr	r2, [r3, #0]
 800902e:	0391      	lsls	r1, r2, #14
 8009030:	d406      	bmi.n	8009040 <RCCEx_PLLSAI1_Config+0x54>
      {
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 8009032:	681b      	ldr	r3, [r3, #0]
 8009034:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 8009038:	d102      	bne.n	8009040 <RCCEx_PLLSAI1_Config+0x54>
 800903a:	2001      	movs	r0, #1
 800903c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

    if(status == HAL_OK)
    {
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
      /* Set PLLSAI1 clock source */
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PllSai1->PLLSAI1Source);
 8009040:	68eb      	ldr	r3, [r5, #12]
 8009042:	f023 0303 	bic.w	r3, r3, #3
 8009046:	4318      	orrs	r0, r3
 8009048:	60e8      	str	r0, [r5, #12]
  }

  if(status == HAL_OK)
  {
    /* Disable the PLLSAI1 */
    __HAL_RCC_PLLSAI1_DISABLE();
 800904a:	682b      	ldr	r3, [r5, #0]
 800904c:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8009050:	602b      	str	r3, [r5, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8009052:	f7fd ffdf 	bl	8007014 <HAL_GetTick>
 8009056:	4680      	mov	r8, r0

    /* Wait till PLLSAI1 is ready to be updated */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 8009058:	682b      	ldr	r3, [r5, #0]
 800905a:	4e29      	ldr	r6, [pc, #164]	; (8009100 <RCCEx_PLLSAI1_Config+0x114>)
 800905c:	011a      	lsls	r2, r3, #4
 800905e:	d508      	bpl.n	8009072 <RCCEx_PLLSAI1_Config+0x86>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8009060:	f7fd ffd8 	bl	8007014 <HAL_GetTick>
 8009064:	ebc8 0000 	rsb	r0, r8, r0
 8009068:	2802      	cmp	r0, #2
 800906a:	d9f5      	bls.n	8009058 <RCCEx_PLLSAI1_Config+0x6c>
      {
        status = HAL_TIMEOUT;
 800906c:	2003      	movs	r0, #3
 800906e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009072:	f8d4 e008 	ldr.w	lr, [r4, #8]
 8009076:	6863      	ldr	r3, [r4, #4]
      }
    }

    if(status == HAL_OK)
    {
      if(Divider == DIVIDER_P_UPDATE)
 8009078:	b95f      	cbnz	r7, 8009092 <RCCEx_PLLSAI1_Config+0xa6>
        assert_param(IS_RCC_PLLSAI1P_VALUE(PllSai1->PLLSAI1P));
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)

        /* Configure the PLLSAI1 Division factor M, P and Multiplication factor N*/
#if defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
        MODIFY_REG(RCC->PLLSAI1CFGR,
 800907a:	6932      	ldr	r2, [r6, #16]
 800907c:	4821      	ldr	r0, [pc, #132]	; (8009104 <RCCEx_PLLSAI1_Config+0x118>)
 800907e:	4010      	ands	r0, r2
 8009080:	68e2      	ldr	r2, [r4, #12]
 8009082:	ea40 200e 	orr.w	r0, r0, lr, lsl #8
 8009086:	ea40 60c2 	orr.w	r0, r0, r2, lsl #27
 800908a:	3b01      	subs	r3, #1
 800908c:	ea40 1303 	orr.w	r3, r0, r3, lsl #4
 8009090:	e01c      	b.n	80090cc <RCCEx_PLLSAI1_Config+0xe0>
                   ((PllSai1->PLLSAI1P >> 4U) << RCC_PLLSAI1CFGR_PLLSAI1P_Pos));
#endif /* RCC_PLLSAI1P_DIV_2_31_SUPPORT */

#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
      }
      else if(Divider == DIVIDER_Q_UPDATE)
 8009092:	2f01      	cmp	r7, #1
 8009094:	d10d      	bne.n	80090b2 <RCCEx_PLLSAI1_Config+0xc6>
      {
        assert_param(IS_RCC_PLLSAI1Q_VALUE(PllSai1->PLLSAI1Q));
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
        /* Configure the PLLSAI1 Division factor M, Q and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8009096:	6932      	ldr	r2, [r6, #16]
 8009098:	491b      	ldr	r1, [pc, #108]	; (8009108 <RCCEx_PLLSAI1_Config+0x11c>)
 800909a:	4011      	ands	r1, r2
 800909c:	3b01      	subs	r3, #1
 800909e:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
 80090a2:	ea41 1103 	orr.w	r1, r1, r3, lsl #4
 80090a6:	6923      	ldr	r3, [r4, #16]
 80090a8:	085b      	lsrs	r3, r3, #1
 80090aa:	3b01      	subs	r3, #1
 80090ac:	ea41 5343 	orr.w	r3, r1, r3, lsl #21
 80090b0:	e00c      	b.n	80090cc <RCCEx_PLLSAI1_Config+0xe0>
      else
      {
        assert_param(IS_RCC_PLLSAI1R_VALUE(PllSai1->PLLSAI1R));
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
        /* Configure the PLLSAI1 Division factor M, R and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR,
 80090b2:	6931      	ldr	r1, [r6, #16]
 80090b4:	4a15      	ldr	r2, [pc, #84]	; (800910c <RCCEx_PLLSAI1_Config+0x120>)
 80090b6:	400a      	ands	r2, r1
 80090b8:	3b01      	subs	r3, #1
 80090ba:	ea42 220e 	orr.w	r2, r2, lr, lsl #8
 80090be:	ea42 1203 	orr.w	r2, r2, r3, lsl #4
 80090c2:	6963      	ldr	r3, [r4, #20]
 80090c4:	085b      	lsrs	r3, r3, #1
 80090c6:	3b01      	subs	r3, #1
 80090c8:	ea42 6343 	orr.w	r3, r2, r3, lsl #25
 80090cc:	6133      	str	r3, [r6, #16]
                   (((PllSai1->PLLSAI1R >> 1U) - 1U) << RCC_PLLSAI1CFGR_PLLSAI1R_Pos));
#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
      }

      /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
      __HAL_RCC_PLLSAI1_ENABLE();
 80090ce:	682b      	ldr	r3, [r5, #0]
 80090d0:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 80090d4:	602b      	str	r3, [r5, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80090d6:	f7fd ff9d 	bl	8007014 <HAL_GetTick>
 80090da:	4606      	mov	r6, r0

      /* Wait till PLLSAI1 is ready */
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 80090dc:	682b      	ldr	r3, [r5, #0]
 80090de:	4a08      	ldr	r2, [pc, #32]	; (8009100 <RCCEx_PLLSAI1_Config+0x114>)
 80090e0:	011b      	lsls	r3, r3, #4
 80090e2:	d405      	bmi.n	80090f0 <RCCEx_PLLSAI1_Config+0x104>
      {
        if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 80090e4:	f7fd ff96 	bl	8007014 <HAL_GetTick>
 80090e8:	1b80      	subs	r0, r0, r6
 80090ea:	2802      	cmp	r0, #2
 80090ec:	d9f6      	bls.n	80090dc <RCCEx_PLLSAI1_Config+0xf0>
 80090ee:	e7bd      	b.n	800906c <RCCEx_PLLSAI1_Config+0x80>
      }

      if(status == HAL_OK)
      {
        /* Configure the PLLSAI1 Clock output(s) */
        __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
 80090f0:	6911      	ldr	r1, [r2, #16]
 80090f2:	69a3      	ldr	r3, [r4, #24]
 80090f4:	430b      	orrs	r3, r1
 80090f6:	6113      	str	r3, [r2, #16]
 80090f8:	2000      	movs	r0, #0
      }
    }
  }

  return status;
}
 80090fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80090fe:	bf00      	nop
 8009100:	40021000 	.word	0x40021000
 8009104:	07ff800f 	.word	0x07ff800f
 8009108:	ff9f800f 	.word	0xff9f800f
 800910c:	f9ff800f 	.word	0xf9ff800f

08009110 <RCCEx_PLLSAI2_Config.constprop.1>:
  assert_param(IS_RCC_PLLSAI2M_VALUE(PllSai2->PLLSAI2M));
  assert_param(IS_RCC_PLLSAI2N_VALUE(PllSai2->PLLSAI2N));
  assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PllSai2->PLLSAI2ClockOut));

  /* Check that PLLSAI2 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8009110:	4b31      	ldr	r3, [pc, #196]	; (80091d8 <RCCEx_PLLSAI2_Config.constprop.1+0xc8>)
 8009112:	68da      	ldr	r2, [r3, #12]
 8009114:	f012 0f03 	tst.w	r2, #3
  *
  * @note   PLLSAI2 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI2_Config(RCC_PLLSAI2InitTypeDef *PllSai2, uint32_t Divider)
 8009118:	b570      	push	{r4, r5, r6, lr}
 800911a:	4605      	mov	r5, r0
 800911c:	461c      	mov	r4, r3
 800911e:	6800      	ldr	r0, [r0, #0]
  assert_param(IS_RCC_PLLSAI2M_VALUE(PllSai2->PLLSAI2M));
  assert_param(IS_RCC_PLLSAI2N_VALUE(PllSai2->PLLSAI2N));
  assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PllSai2->PLLSAI2ClockOut));

  /* Check that PLLSAI2 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8009120:	d006      	beq.n	8009130 <RCCEx_PLLSAI2_Config.constprop.1+0x20>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai2->PLLSAI2Source)
 8009122:	68db      	ldr	r3, [r3, #12]
 8009124:	f003 0303 	and.w	r3, r3, #3
 8009128:	4283      	cmp	r3, r0
 800912a:	d116      	bne.n	800915a <RCCEx_PLLSAI2_Config.constprop.1+0x4a>
       ||
 800912c:	b1ab      	cbz	r3, 800915a <RCCEx_PLLSAI2_Config.constprop.1+0x4a>
 800912e:	e01b      	b.n	8009168 <RCCEx_PLLSAI2_Config.constprop.1+0x58>
    }
  }
  else
  {
    /* Check PLLSAI2 clock source availability */
    switch(PllSai2->PLLSAI2Source)
 8009130:	2802      	cmp	r0, #2
 8009132:	d007      	beq.n	8009144 <RCCEx_PLLSAI2_Config.constprop.1+0x34>
 8009134:	2803      	cmp	r0, #3
 8009136:	d009      	beq.n	800914c <RCCEx_PLLSAI2_Config.constprop.1+0x3c>
 8009138:	2801      	cmp	r0, #1
 800913a:	d10e      	bne.n	800915a <RCCEx_PLLSAI2_Config.constprop.1+0x4a>
    {
    case RCC_PLLSOURCE_MSI:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 800913c:	681b      	ldr	r3, [r3, #0]
 800913e:	079e      	lsls	r6, r3, #30
 8009140:	d548      	bpl.n	80091d4 <RCCEx_PLLSAI2_Config.constprop.1+0xc4>
 8009142:	e00c      	b.n	800915e <RCCEx_PLLSAI2_Config.constprop.1+0x4e>
      {
        status = HAL_ERROR;
      }
      break;
    case RCC_PLLSOURCE_HSI:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 8009144:	681b      	ldr	r3, [r3, #0]
 8009146:	f413 6f80 	tst.w	r3, #1024	; 0x400
 800914a:	e005      	b.n	8009158 <RCCEx_PLLSAI2_Config.constprop.1+0x48>
      {
        status = HAL_ERROR;
      }
      break;
    case RCC_PLLSOURCE_HSE:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
 800914c:	681a      	ldr	r2, [r3, #0]
 800914e:	0391      	lsls	r1, r2, #14
 8009150:	d405      	bmi.n	800915e <RCCEx_PLLSAI2_Config.constprop.1+0x4e>
      {
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 8009152:	681b      	ldr	r3, [r3, #0]
 8009154:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 8009158:	d101      	bne.n	800915e <RCCEx_PLLSAI2_Config.constprop.1+0x4e>
 800915a:	2001      	movs	r0, #1
 800915c:	bd70      	pop	{r4, r5, r6, pc}

    if(status == HAL_OK)
    {
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
      /* Set PLLSAI2 clock source */
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PllSai2->PLLSAI2Source);
 800915e:	68e3      	ldr	r3, [r4, #12]
 8009160:	f023 0303 	bic.w	r3, r3, #3
 8009164:	4318      	orrs	r0, r3
 8009166:	60e0      	str	r0, [r4, #12]
  }

  if(status == HAL_OK)
  {
    /* Disable the PLLSAI2 */
    __HAL_RCC_PLLSAI2_DISABLE();
 8009168:	6823      	ldr	r3, [r4, #0]
 800916a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800916e:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8009170:	f7fd ff50 	bl	8007014 <HAL_GetTick>
 8009174:	4606      	mov	r6, r0

    /* Wait till PLLSAI2 is ready to be updated */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 8009176:	6823      	ldr	r3, [r4, #0]
 8009178:	4917      	ldr	r1, [pc, #92]	; (80091d8 <RCCEx_PLLSAI2_Config.constprop.1+0xc8>)
 800917a:	009a      	lsls	r2, r3, #2
 800917c:	d506      	bpl.n	800918c <RCCEx_PLLSAI2_Config.constprop.1+0x7c>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 800917e:	f7fd ff49 	bl	8007014 <HAL_GetTick>
 8009182:	1b80      	subs	r0, r0, r6
 8009184:	2802      	cmp	r0, #2
 8009186:	d9f6      	bls.n	8009176 <RCCEx_PLLSAI2_Config.constprop.1+0x66>
      {
        status = HAL_TIMEOUT;
 8009188:	2003      	movs	r0, #3
 800918a:	bd70      	pop	{r4, r5, r6, pc}
        assert_param(IS_RCC_PLLSAI2P_VALUE(PllSai2->PLLSAI2P));
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)

        /* Configure the PLLSAI2 Division factor M, P and Multiplication factor N*/
#if defined(RCC_PLLSAI2P_DIV_2_31_SUPPORT)
        MODIFY_REG(RCC->PLLSAI2CFGR,
 800918c:	6948      	ldr	r0, [r1, #20]
 800918e:	4b13      	ldr	r3, [pc, #76]	; (80091dc <RCCEx_PLLSAI2_Config.constprop.1+0xcc>)
 8009190:	68aa      	ldr	r2, [r5, #8]
 8009192:	4003      	ands	r3, r0
 8009194:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8009198:	68ea      	ldr	r2, [r5, #12]
 800919a:	ea43 62c2 	orr.w	r2, r3, r2, lsl #27
 800919e:	686b      	ldr	r3, [r5, #4]
 80091a0:	3b01      	subs	r3, #1
 80091a2:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
 80091a6:	614b      	str	r3, [r1, #20]
                   (((PllSai2->PLLSAI2R >> 1U) - 1U) << RCC_PLLSAI2CFGR_PLLSAI2R_Pos));
#endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
      }

      /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
      __HAL_RCC_PLLSAI2_ENABLE();
 80091a8:	680b      	ldr	r3, [r1, #0]
 80091aa:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80091ae:	600b      	str	r3, [r1, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80091b0:	f7fd ff30 	bl	8007014 <HAL_GetTick>
 80091b4:	4606      	mov	r6, r0

      /* Wait till PLLSAI2 is ready */
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
 80091b6:	6823      	ldr	r3, [r4, #0]
 80091b8:	4a07      	ldr	r2, [pc, #28]	; (80091d8 <RCCEx_PLLSAI2_Config.constprop.1+0xc8>)
 80091ba:	009b      	lsls	r3, r3, #2
 80091bc:	d405      	bmi.n	80091ca <RCCEx_PLLSAI2_Config.constprop.1+0xba>
      {
        if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 80091be:	f7fd ff29 	bl	8007014 <HAL_GetTick>
 80091c2:	1b80      	subs	r0, r0, r6
 80091c4:	2802      	cmp	r0, #2
 80091c6:	d9f6      	bls.n	80091b6 <RCCEx_PLLSAI2_Config.constprop.1+0xa6>
 80091c8:	e7de      	b.n	8009188 <RCCEx_PLLSAI2_Config.constprop.1+0x78>
      }

      if(status == HAL_OK)
      {
        /* Configure the PLLSAI2 Clock output(s) */
        __HAL_RCC_PLLSAI2CLKOUT_ENABLE(PllSai2->PLLSAI2ClockOut);
 80091ca:	6951      	ldr	r1, [r2, #20]
 80091cc:	69ab      	ldr	r3, [r5, #24]
 80091ce:	430b      	orrs	r3, r1
 80091d0:	6153      	str	r3, [r2, #20]
 80091d2:	2000      	movs	r0, #0
      }
    }
  }

  return status;
}
 80091d4:	bd70      	pop	{r4, r5, r6, pc}
 80091d6:	bf00      	nop
 80091d8:	40021000 	.word	0x40021000
 80091dc:	07ff800f 	.word	0x07ff800f

080091e0 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 80091e0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

#if defined(SAI1)

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 80091e4:	6806      	ldr	r6, [r0, #0]
 80091e6:	f416 6600 	ands.w	r6, r6, #2048	; 0x800
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 80091ea:	4604      	mov	r4, r0
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

#if defined(SAI1)

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 80091ec:	d026      	beq.n	800923c <HAL_RCCEx_PeriphCLKConfig+0x5c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLK(PeriphClkInit->Sai1ClockSelection));

    switch(PeriphClkInit->Sai1ClockSelection)
 80091ee:	6ec1      	ldr	r1, [r0, #108]	; 0x6c
 80091f0:	2940      	cmp	r1, #64	; 0x40
 80091f2:	d00c      	beq.n	800920e <HAL_RCCEx_PeriphCLKConfig+0x2e>
 80091f4:	d806      	bhi.n	8009204 <HAL_RCCEx_PeriphCLKConfig+0x24>
 80091f6:	b181      	cbz	r1, 800921a <HAL_RCCEx_PeriphCLKConfig+0x3a>
 80091f8:	2920      	cmp	r1, #32
 80091fa:	d11e      	bne.n	800923a <HAL_RCCEx_PeriphCLKConfig+0x5a>

#if defined(RCC_PLLSAI2_SUPPORT)

    case RCC_SAI1CLKSOURCE_PLLSAI2:  /* PLLSAI2 is used as clock source for SAI1*/
      /* PLLSAI2 input clock, parameters M, N & P configuration clock output (PLLSAI2ClockOut) */
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 80091fc:	3020      	adds	r0, #32
 80091fe:	f7ff ff87 	bl	8009110 <RCCEx_PLLSAI2_Config.constprop.1>
 8009202:	e00d      	b.n	8009220 <HAL_RCCEx_PeriphCLKConfig+0x40>
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLK(PeriphClkInit->Sai1ClockSelection));

    switch(PeriphClkInit->Sai1ClockSelection)
 8009204:	2960      	cmp	r1, #96	; 0x60
 8009206:	d00d      	beq.n	8009224 <HAL_RCCEx_PeriphCLKConfig+0x44>
 8009208:	2980      	cmp	r1, #128	; 0x80
 800920a:	d00b      	beq.n	8009224 <HAL_RCCEx_PeriphCLKConfig+0x44>
 800920c:	e015      	b.n	800923a <HAL_RCCEx_PeriphCLKConfig+0x5a>
    {
    case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
      /* Enable SAI Clock output generated from System PLL . */
#if defined(RCC_PLLSAI2_SUPPORT)
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 800920e:	4ab5      	ldr	r2, [pc, #724]	; (80094e4 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8009210:	68d3      	ldr	r3, [r2, #12]
 8009212:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8009216:	60d3      	str	r3, [r2, #12]
#else
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI2CLK);
#endif /* RCC_PLLSAI2_SUPPORT */
      /* SAI1 clock source config set later after clock selection check */
      break;
 8009218:	e004      	b.n	8009224 <HAL_RCCEx_PeriphCLKConfig+0x44>

    case RCC_SAI1CLKSOURCE_PLLSAI1:  /* PLLSAI1 is used as clock source for SAI1*/
      /* PLLSAI1 input clock, parameters M, N & P configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 800921a:	3004      	adds	r0, #4
 800921c:	f7ff fee6 	bl	8008fec <RCCEx_PLLSAI1_Config>

#if defined(RCC_PLLSAI2_SUPPORT)

    case RCC_SAI1CLKSOURCE_PLLSAI2:  /* PLLSAI2 is used as clock source for SAI1*/
      /* PLLSAI2 input clock, parameters M, N & P configuration clock output (PLLSAI2ClockOut) */
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8009220:	4606      	mov	r6, r0
    default:
      ret = HAL_ERROR;
      break;
    }

    if(ret == HAL_OK)
 8009222:	b958      	cbnz	r0, 800923c <HAL_RCCEx_PeriphCLKConfig+0x5c>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8009224:	49af      	ldr	r1, [pc, #700]	; (80094e4 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8009226:	f8d1 309c 	ldr.w	r3, [r1, #156]	; 0x9c
 800922a:	f023 02e0 	bic.w	r2, r3, #224	; 0xe0
 800922e:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8009230:	4313      	orrs	r3, r2
 8009232:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
 8009236:	2600      	movs	r6, #0
 8009238:	e000      	b.n	800923c <HAL_RCCEx_PeriphCLKConfig+0x5c>
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
      /* SAI1 clock source config set later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 800923a:	2601      	movs	r6, #1
#endif /* SAI1 */

#if defined(SAI2)

  /*-------------------------- SAI2 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
 800923c:	6823      	ldr	r3, [r4, #0]
 800923e:	04d8      	lsls	r0, r3, #19
 8009240:	d52c      	bpl.n	800929c <HAL_RCCEx_PeriphCLKConfig+0xbc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLK(PeriphClkInit->Sai2ClockSelection));

    switch(PeriphClkInit->Sai2ClockSelection)
 8009242:	6f21      	ldr	r1, [r4, #112]	; 0x70
 8009244:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8009248:	d010      	beq.n	800926c <HAL_RCCEx_PeriphCLKConfig+0x8c>
 800924a:	d808      	bhi.n	800925e <HAL_RCCEx_PeriphCLKConfig+0x7e>
 800924c:	b1a1      	cbz	r1, 8009278 <HAL_RCCEx_PeriphCLKConfig+0x98>
 800924e:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8009252:	d122      	bne.n	800929a <HAL_RCCEx_PeriphCLKConfig+0xba>
      /* SAI2 clock source config set later after clock selection check */
      break;

    case RCC_SAI2CLKSOURCE_PLLSAI2:  /* PLLSAI2 is used as clock source for SAI2*/
      /* PLLSAI2 input clock, parameters M, N & P configuration and clock output (PLLSAI2ClockOut) */
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8009254:	f104 0020 	add.w	r0, r4, #32
 8009258:	f7ff ff5a 	bl	8009110 <RCCEx_PLLSAI2_Config.constprop.1>
 800925c:	e00f      	b.n	800927e <HAL_RCCEx_PeriphCLKConfig+0x9e>
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLK(PeriphClkInit->Sai2ClockSelection));

    switch(PeriphClkInit->Sai2ClockSelection)
 800925e:	f5b1 7f40 	cmp.w	r1, #768	; 0x300
 8009262:	d00e      	beq.n	8009282 <HAL_RCCEx_PeriphCLKConfig+0xa2>
 8009264:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 8009268:	d00b      	beq.n	8009282 <HAL_RCCEx_PeriphCLKConfig+0xa2>
 800926a:	e016      	b.n	800929a <HAL_RCCEx_PeriphCLKConfig+0xba>
    {
    case RCC_SAI2CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
      /* Enable SAI Clock output generated from System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 800926c:	4a9d      	ldr	r2, [pc, #628]	; (80094e4 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 800926e:	68d3      	ldr	r3, [r2, #12]
 8009270:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8009274:	60d3      	str	r3, [r2, #12]
 8009276:	e004      	b.n	8009282 <HAL_RCCEx_PeriphCLKConfig+0xa2>
      /* SAI2 clock source config set later after clock selection check */
      break;

    case RCC_SAI2CLKSOURCE_PLLSAI1: /* PLLSAI1 is used as clock source for SAI2*/
      /* PLLSAI1 input clock, parameters M, N & P configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8009278:	1d20      	adds	r0, r4, #4
 800927a:	f7ff feb7 	bl	8008fec <RCCEx_PLLSAI1_Config>
      /* SAI2 clock source config set later after clock selection check */
      break;

    case RCC_SAI2CLKSOURCE_PLLSAI2:  /* PLLSAI2 is used as clock source for SAI2*/
      /* PLLSAI2 input clock, parameters M, N & P configuration and clock output (PLLSAI2ClockOut) */
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 800927e:	4605      	mov	r5, r0
      /* SAI2 clock source config set later after clock selection check */
      break;
 8009280:	e000      	b.n	8009284 <HAL_RCCEx_PeriphCLKConfig+0xa4>
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLK(PeriphClkInit->Sai2ClockSelection));

    switch(PeriphClkInit->Sai2ClockSelection)
 8009282:	4635      	mov	r5, r6
    default:
      ret = HAL_ERROR;
      break;
    }

    if(ret == HAL_OK)
 8009284:	b965      	cbnz	r5, 80092a0 <HAL_RCCEx_PeriphCLKConfig+0xc0>
    {
      /* Set the source of SAI2 clock*/
      __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8009286:	4997      	ldr	r1, [pc, #604]	; (80094e4 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8009288:	f8d1 309c 	ldr.w	r3, [r1, #156]	; 0x9c
 800928c:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 8009290:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8009292:	4313      	orrs	r3, r2
 8009294:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
 8009298:	e003      	b.n	80092a2 <HAL_RCCEx_PeriphCLKConfig+0xc2>
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
      /* SAI2 clock source config set later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 800929a:	2601      	movs	r6, #1
 800929c:	4635      	mov	r5, r6
 800929e:	e000      	b.n	80092a2 <HAL_RCCEx_PeriphCLKConfig+0xc2>
 80092a0:	462e      	mov	r6, r5
    }
  }
#endif /* SAI2 */

  /*-------------------------- RTC clock source configuration ----------------------*/
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 80092a2:	6823      	ldr	r3, [r4, #0]
 80092a4:	0399      	lsls	r1, r3, #14
 80092a6:	d554      	bpl.n	8009352 <HAL_RCCEx_PeriphCLKConfig+0x172>

    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
 80092a8:	4f8e      	ldr	r7, [pc, #568]	; (80094e4 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 80092aa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80092ac:	00da      	lsls	r2, r3, #3
 80092ae:	f140 8189 	bpl.w	80095c4 <HAL_RCCEx_PeriphCLKConfig+0x3e4>
#endif /* SAI2 */

  /*-------------------------- RTC clock source configuration ----------------------*/
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
  {
    FlagStatus       pwrclkchanged = RESET;
 80092b2:	f04f 0800 	mov.w	r8, #0
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }

    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80092b6:	f8df 9230 	ldr.w	r9, [pc, #560]	; 80094e8 <HAL_RCCEx_PeriphCLKConfig+0x308>
 80092ba:	f8d9 3000 	ldr.w	r3, [r9]
 80092be:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80092c2:	f8c9 3000 	str.w	r3, [r9]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 80092c6:	f7fd fea5 	bl	8007014 <HAL_GetTick>
 80092ca:	4682      	mov	sl, r0

    while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == 0U)
 80092cc:	f8d9 3000 	ldr.w	r3, [r9]
 80092d0:	05db      	lsls	r3, r3, #23
 80092d2:	d406      	bmi.n	80092e2 <HAL_RCCEx_PeriphCLKConfig+0x102>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80092d4:	f7fd fe9e 	bl	8007014 <HAL_GetTick>
 80092d8:	ebca 0000 	rsb	r0, sl, r0
 80092dc:	2802      	cmp	r0, #2
 80092de:	d9f5      	bls.n	80092cc <HAL_RCCEx_PeriphCLKConfig+0xec>
 80092e0:	e02e      	b.n	8009340 <HAL_RCCEx_PeriphCLKConfig+0x160>
        ret = HAL_TIMEOUT;
        break;
      }
    }

    if(ret == HAL_OK)
 80092e2:	bb75      	cbnz	r5, 8009342 <HAL_RCCEx_PeriphCLKConfig+0x162>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 80092e4:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80092e8:	4a7e      	ldr	r2, [pc, #504]	; (80094e4 <HAL_RCCEx_PeriphCLKConfig+0x304>)

      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 80092ea:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 80092ee:	d015      	beq.n	800931c <HAL_RCCEx_PeriphCLKConfig+0x13c>
 80092f0:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
 80092f4:	428b      	cmp	r3, r1
 80092f6:	d011      	beq.n	800931c <HAL_RCCEx_PeriphCLKConfig+0x13c>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 80092f8:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 80092fc:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
 8009300:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
 8009304:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 8009308:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);

      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 800930c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
        __HAL_RCC_BACKUPRESET_RELEASE();
 8009310:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 8009314:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
 8009318:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 800931c:	07dd      	lsls	r5, r3, #31
 800931e:	f140 815d 	bpl.w	80095dc <HAL_RCCEx_PeriphCLKConfig+0x3fc>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8009322:	f7fd fe77 	bl	8007014 <HAL_GetTick>

        /* Wait till LSE is ready */
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8009326:	f241 3988 	movw	r9, #5000	; 0x1388

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800932a:	4605      	mov	r5, r0

        /* Wait till LSE is ready */
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 800932c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8009330:	0798      	lsls	r0, r3, #30
 8009332:	f100 8153 	bmi.w	80095dc <HAL_RCCEx_PeriphCLKConfig+0x3fc>
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8009336:	f7fd fe6d 	bl	8007014 <HAL_GetTick>
 800933a:	1b40      	subs	r0, r0, r5
 800933c:	4548      	cmp	r0, r9
 800933e:	d9f5      	bls.n	800932c <HAL_RCCEx_PeriphCLKConfig+0x14c>

    while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == 0U)
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
      {
        ret = HAL_TIMEOUT;
 8009340:	2503      	movs	r5, #3
      /* set overall return value */
      status = ret;
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8009342:	f1b8 0f00 	cmp.w	r8, #0
 8009346:	d005      	beq.n	8009354 <HAL_RCCEx_PeriphCLKConfig+0x174>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8009348:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800934a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800934e:	65bb      	str	r3, [r7, #88]	; 0x58
 8009350:	e000      	b.n	8009354 <HAL_RCCEx_PeriphCLKConfig+0x174>
 8009352:	4635      	mov	r5, r6
    }
  }

  /*-------------------------- USART1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8009354:	6823      	ldr	r3, [r4, #0]
 8009356:	07d9      	lsls	r1, r3, #31
 8009358:	d508      	bpl.n	800936c <HAL_RCCEx_PeriphCLKConfig+0x18c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 800935a:	4862      	ldr	r0, [pc, #392]	; (80094e4 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 800935c:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8009360:	f022 0103 	bic.w	r1, r2, #3
 8009364:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8009366:	430a      	orrs	r2, r1
 8009368:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- USART2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 800936c:	079a      	lsls	r2, r3, #30
 800936e:	d508      	bpl.n	8009382 <HAL_RCCEx_PeriphCLKConfig+0x1a2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8009370:	485c      	ldr	r0, [pc, #368]	; (80094e4 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8009372:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8009376:	f022 010c 	bic.w	r1, r2, #12
 800937a:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800937c:	430a      	orrs	r2, r1
 800937e:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

#if defined(USART3)

  /*-------------------------- USART3 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8009382:	075f      	lsls	r7, r3, #29
 8009384:	d508      	bpl.n	8009398 <HAL_RCCEx_PeriphCLKConfig+0x1b8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8009386:	4857      	ldr	r0, [pc, #348]	; (80094e4 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8009388:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 800938c:	f022 0130 	bic.w	r1, r2, #48	; 0x30
 8009390:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8009392:	430a      	orrs	r2, r1
 8009394:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
#endif /* USART3 */

#if defined(UART4)

  /*-------------------------- UART4 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8009398:	071e      	lsls	r6, r3, #28
 800939a:	d508      	bpl.n	80093ae <HAL_RCCEx_PeriphCLKConfig+0x1ce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 800939c:	4851      	ldr	r0, [pc, #324]	; (80094e4 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 800939e:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 80093a2:	f022 01c0 	bic.w	r1, r2, #192	; 0xc0
 80093a6:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 80093a8:	430a      	orrs	r2, r1
 80093aa:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
#endif /* UART4 */

#if defined(UART5)

  /*-------------------------- UART5 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 80093ae:	06d8      	lsls	r0, r3, #27
 80093b0:	d508      	bpl.n	80093c4 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 80093b2:	484c      	ldr	r0, [pc, #304]	; (80094e4 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 80093b4:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 80093b8:	f422 7140 	bic.w	r1, r2, #768	; 0x300
 80093bc:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 80093be:	430a      	orrs	r2, r1
 80093c0:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

#endif /* UART5 */

  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 80093c4:	0699      	lsls	r1, r3, #26
 80093c6:	d508      	bpl.n	80093da <HAL_RCCEx_PeriphCLKConfig+0x1fa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUART1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 80093c8:	4846      	ldr	r0, [pc, #280]	; (80094e4 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 80093ca:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 80093ce:	f422 6140 	bic.w	r1, r2, #3072	; 0xc00
 80093d2:	6d22      	ldr	r2, [r4, #80]	; 0x50
 80093d4:	430a      	orrs	r2, r1
 80093d6:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- LPTIM1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 80093da:	059a      	lsls	r2, r3, #22
 80093dc:	d508      	bpl.n	80093f0 <HAL_RCCEx_PeriphCLKConfig+0x210>
  {
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 80093de:	4841      	ldr	r0, [pc, #260]	; (80094e4 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 80093e0:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 80093e4:	f422 2140 	bic.w	r1, r2, #786432	; 0xc0000
 80093e8:	6e62      	ldr	r2, [r4, #100]	; 0x64
 80093ea:	430a      	orrs	r2, r1
 80093ec:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- LPTIM2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 80093f0:	055f      	lsls	r7, r3, #21
 80093f2:	d508      	bpl.n	8009406 <HAL_RCCEx_PeriphCLKConfig+0x226>
  {
    assert_param(IS_RCC_LPTIM2CLK(PeriphClkInit->Lptim2ClockSelection));
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 80093f4:	483b      	ldr	r0, [pc, #236]	; (80094e4 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 80093f6:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 80093fa:	f422 1140 	bic.w	r1, r2, #3145728	; 0x300000
 80093fe:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 8009400:	430a      	orrs	r2, r1
 8009402:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8009406:	065e      	lsls	r6, r3, #25
 8009408:	d508      	bpl.n	800941c <HAL_RCCEx_PeriphCLKConfig+0x23c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 800940a:	4836      	ldr	r0, [pc, #216]	; (80094e4 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 800940c:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8009410:	f422 5140 	bic.w	r1, r2, #12288	; 0x3000
 8009414:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8009416:	430a      	orrs	r2, r1
 8009418:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

#if defined(I2C2)

  /*-------------------------- I2C2 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 800941c:	0618      	lsls	r0, r3, #24
 800941e:	d508      	bpl.n	8009432 <HAL_RCCEx_PeriphCLKConfig+0x252>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8009420:	4830      	ldr	r0, [pc, #192]	; (80094e4 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8009422:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8009426:	f422 4140 	bic.w	r1, r2, #49152	; 0xc000
 800942a:	6da2      	ldr	r2, [r4, #88]	; 0x58
 800942c:	430a      	orrs	r2, r1
 800942e:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

#endif /* I2C2 */

  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8009432:	05d9      	lsls	r1, r3, #23
 8009434:	d508      	bpl.n	8009448 <HAL_RCCEx_PeriphCLKConfig+0x268>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8009436:	482b      	ldr	r0, [pc, #172]	; (80094e4 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8009438:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 800943c:	f422 3140 	bic.w	r1, r2, #196608	; 0x30000
 8009440:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8009442:	430a      	orrs	r2, r1
 8009444:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

#if defined(I2C4)

  /*-------------------------- I2C4 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8009448:	02da      	lsls	r2, r3, #11
 800944a:	d508      	bpl.n	800945e <HAL_RCCEx_PeriphCLKConfig+0x27e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 800944c:	4825      	ldr	r0, [pc, #148]	; (80094e4 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 800944e:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
 8009452:	f022 0103 	bic.w	r1, r2, #3
 8009456:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8009458:	430a      	orrs	r2, r1
 800945a:	f8c0 209c 	str.w	r2, [r0, #156]	; 0x9c
#endif /* I2C4 */

#if defined(USB_OTG_FS) || defined(USB)

  /*-------------------------- USB clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 800945e:	049b      	lsls	r3, r3, #18
 8009460:	d51a      	bpl.n	8009498 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8009462:	4a20      	ldr	r2, [pc, #128]	; (80094e4 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8009464:	6f61      	ldr	r1, [r4, #116]	; 0x74
 8009466:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 800946a:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 800946e:	430b      	orrs	r3, r1

    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8009470:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000

  /*-------------------------- USB clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8009474:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8009478:	d104      	bne.n	8009484 <HAL_RCCEx_PeriphCLKConfig+0x2a4>
    {
      /* Enable PLL48M1CLK output clock */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 800947a:	68d3      	ldr	r3, [r2, #12]
 800947c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8009480:	60d3      	str	r3, [r2, #12]
 8009482:	e009      	b.n	8009498 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
    }
    else
    {
#if defined(RCC_PLLSAI1_SUPPORT)
      if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 8009484:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 8009488:	d106      	bne.n	8009498 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
      {
        /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 800948a:	2101      	movs	r1, #1
 800948c:	1d20      	adds	r0, r4, #4
 800948e:	f7ff fdad 	bl	8008fec <RCCEx_PLLSAI1_Config>
 8009492:	2800      	cmp	r0, #0
 8009494:	bf18      	it	ne
 8009496:	4605      	movne	r5, r0
#endif /* USB_OTG_FS || USB */

#if defined(SDMMC1)

  /*-------------------------- SDMMC1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
 8009498:	6823      	ldr	r3, [r4, #0]
 800949a:	031f      	lsls	r7, r3, #12
 800949c:	d530      	bpl.n	8009500 <HAL_RCCEx_PeriphCLKConfig+0x320>
  {
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 800949e:	6fa1      	ldr	r1, [r4, #120]	; 0x78
 80094a0:	4b10      	ldr	r3, [pc, #64]	; (80094e4 <HAL_RCCEx_PeriphCLKConfig+0x304>)
 80094a2:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
 80094a6:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 80094aa:	d107      	bne.n	80094bc <HAL_RCCEx_PeriphCLKConfig+0x2dc>
 80094ac:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80094b0:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
    }
#if defined(RCC_CCIPR2_SDMMCSEL)
    else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLP) /* PLL "P" ? */
    {
      /* Enable PLLSAI3CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 80094b4:	68da      	ldr	r2, [r3, #12]
 80094b6:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80094ba:	e010      	b.n	80094de <HAL_RCCEx_PeriphCLKConfig+0x2fe>

  /*-------------------------- SDMMC1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
  {
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 80094bc:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 80094c0:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
 80094c4:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80094c8:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 80094cc:	430a      	orrs	r2, r1

    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 80094ce:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000

  /*-------------------------- SDMMC1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
  {
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 80094d2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 80094d6:	d109      	bne.n	80094ec <HAL_RCCEx_PeriphCLKConfig+0x30c>
    {
      /* Enable PLL48M1CLK output clock */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 80094d8:	68da      	ldr	r2, [r3, #12]
 80094da:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 80094de:	60da      	str	r2, [r3, #12]
 80094e0:	e00e      	b.n	8009500 <HAL_RCCEx_PeriphCLKConfig+0x320>
 80094e2:	bf00      	nop
 80094e4:	40021000 	.word	0x40021000
 80094e8:	40007000 	.word	0x40007000
    {
      /* Enable PLLSAI3CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
    }
#endif
    else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
 80094ec:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 80094f0:	d106      	bne.n	8009500 <HAL_RCCEx_PeriphCLKConfig+0x320>
    {
      /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 80094f2:	2101      	movs	r1, #1
 80094f4:	1d20      	adds	r0, r4, #4
 80094f6:	f7ff fd79 	bl	8008fec <RCCEx_PLLSAI1_Config>
 80094fa:	2800      	cmp	r0, #0
 80094fc:	bf18      	it	ne
 80094fe:	4605      	movne	r5, r0
  }

#endif /* SDMMC1 */

  /*-------------------------- RNG clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8009500:	6823      	ldr	r3, [r4, #0]
 8009502:	035e      	lsls	r6, r3, #13
 8009504:	d51a      	bpl.n	800953c <HAL_RCCEx_PeriphCLKConfig+0x35c>
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8009506:	4a3d      	ldr	r2, [pc, #244]	; (80095fc <HAL_RCCEx_PeriphCLKConfig+0x41c>)
 8009508:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 800950a:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 800950e:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 8009512:	430b      	orrs	r3, r1

    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8009514:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000

  /*-------------------------- RNG clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8009518:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 800951c:	d104      	bne.n	8009528 <HAL_RCCEx_PeriphCLKConfig+0x348>
    {
      /* Enable PLL48M1CLK output clock */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 800951e:	68d3      	ldr	r3, [r2, #12]
 8009520:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8009524:	60d3      	str	r3, [r2, #12]
 8009526:	e009      	b.n	800953c <HAL_RCCEx_PeriphCLKConfig+0x35c>
    }
#if defined(RCC_PLLSAI1_SUPPORT)
    else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
 8009528:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 800952c:	d106      	bne.n	800953c <HAL_RCCEx_PeriphCLKConfig+0x35c>
    {
      /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 800952e:	2101      	movs	r1, #1
 8009530:	1d20      	adds	r0, r4, #4
 8009532:	f7ff fd5b 	bl	8008fec <RCCEx_PLLSAI1_Config>
 8009536:	2800      	cmp	r0, #0
 8009538:	bf18      	it	ne
 800953a:	4605      	movne	r5, r0
    }
  }

  /*-------------------------- ADC clock source configuration ----------------------*/
#if !defined(STM32L412xx) && !defined(STM32L422xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 800953c:	6823      	ldr	r3, [r4, #0]
 800953e:	0458      	lsls	r0, r3, #17
 8009540:	d513      	bpl.n	800956a <HAL_RCCEx_PeriphCLKConfig+0x38a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8009542:	492e      	ldr	r1, [pc, #184]	; (80095fc <HAL_RCCEx_PeriphCLKConfig+0x41c>)
 8009544:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 8009548:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 800954c:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 8009550:	4313      	orrs	r3, r2

#if defined(RCC_PLLSAI1_SUPPORT)
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8009552:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8009556:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

#if defined(RCC_PLLSAI1_SUPPORT)
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 800955a:	d106      	bne.n	800956a <HAL_RCCEx_PeriphCLKConfig+0x38a>
    {
      /* PLLSAI1 input clock, parameters M, N & R configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_R_UPDATE);
 800955c:	2102      	movs	r1, #2
 800955e:	1d20      	adds	r0, r4, #4
 8009560:	f7ff fd44 	bl	8008fec <RCCEx_PLLSAI1_Config>
 8009564:	2800      	cmp	r0, #0
 8009566:	bf18      	it	ne
 8009568:	4605      	movne	r5, r0
#endif /* SWPMI1 */

#if defined(DFSDM1_Filter0)

  /*-------------------------- DFSDM1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 800956a:	6823      	ldr	r3, [r4, #0]
 800956c:	03d9      	lsls	r1, r3, #15
 800956e:	d509      	bpl.n	8009584 <HAL_RCCEx_PeriphCLKConfig+0x3a4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 8009570:	4822      	ldr	r0, [pc, #136]	; (80095fc <HAL_RCCEx_PeriphCLKConfig+0x41c>)
 8009572:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
 8009576:	f022 0104 	bic.w	r1, r2, #4
 800957a:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
 800957e:	430a      	orrs	r2, r1
 8009580:	f8c0 209c 	str.w	r2, [r0, #156]	; 0x9c
  }

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  /*-------------------------- DFSDM1 audio clock source configuration -------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1AUDIO) == RCC_PERIPHCLK_DFSDM1AUDIO)
 8009584:	029a      	lsls	r2, r3, #10
 8009586:	d509      	bpl.n	800959c <HAL_RCCEx_PeriphCLKConfig+0x3bc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1AUDIOCLKSOURCE(PeriphClkInit->Dfsdm1AudioClockSelection));

    /* Configure the DFSDM1 interface audio clock source */
    __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);
 8009588:	481c      	ldr	r0, [pc, #112]	; (80095fc <HAL_RCCEx_PeriphCLKConfig+0x41c>)
 800958a:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
 800958e:	f022 0118 	bic.w	r1, r2, #24
 8009592:	f8d4 2088 	ldr.w	r2, [r4, #136]	; 0x88
 8009596:	430a      	orrs	r2, r1
 8009598:	f8c0 209c 	str.w	r2, [r0, #156]	; 0x9c
#endif /* DSI */

#if defined(OCTOSPI1) || defined(OCTOSPI2)

  /*-------------------------- OctoSPIx clock source configuration ----------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_OSPI) == RCC_PERIPHCLK_OSPI)
 800959c:	01db      	lsls	r3, r3, #7
 800959e:	d528      	bpl.n	80095f2 <HAL_RCCEx_PeriphCLKConfig+0x412>
  {
    /* Check the parameters */
    assert_param(IS_RCC_OSPICLKSOURCE(PeriphClkInit->OspiClockSelection));

    /* Configure the OctoSPI clock source */
    __HAL_RCC_OSPI_CONFIG(PeriphClkInit->OspiClockSelection);
 80095a0:	4a16      	ldr	r2, [pc, #88]	; (80095fc <HAL_RCCEx_PeriphCLKConfig+0x41c>)
 80095a2:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
 80095a6:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 80095aa:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 80095ae:	430b      	orrs	r3, r1

    if(PeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL)
 80095b0:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
  {
    /* Check the parameters */
    assert_param(IS_RCC_OSPICLKSOURCE(PeriphClkInit->OspiClockSelection));

    /* Configure the OctoSPI clock source */
    __HAL_RCC_OSPI_CONFIG(PeriphClkInit->OspiClockSelection);
 80095b4:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c

    if(PeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL)
 80095b8:	d11b      	bne.n	80095f2 <HAL_RCCEx_PeriphCLKConfig+0x412>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 80095ba:	68d3      	ldr	r3, [r2, #12]
 80095bc:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80095c0:	60d3      	str	r3, [r2, #12]
    }
  }

#endif /* OCTOSPI1 || OCTOSPI2 */

  return status;
 80095c2:	e016      	b.n	80095f2 <HAL_RCCEx_PeriphCLKConfig+0x412>
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 80095c4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80095c6:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80095ca:	65bb      	str	r3, [r7, #88]	; 0x58
 80095cc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80095ce:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80095d2:	9301      	str	r3, [sp, #4]
 80095d4:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 80095d6:	f04f 0801 	mov.w	r8, #1
 80095da:	e66c      	b.n	80092b6 <HAL_RCCEx_PeriphCLKConfig+0xd6>
      }

      if(ret == HAL_OK)
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80095dc:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80095e0:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 80095e4:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 80095e8:	4313      	orrs	r3, r2
 80095ea:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 80095ee:	4635      	mov	r5, r6
 80095f0:	e6a7      	b.n	8009342 <HAL_RCCEx_PeriphCLKConfig+0x162>
  }

#endif /* OCTOSPI1 || OCTOSPI2 */

  return status;
}
 80095f2:	4628      	mov	r0, r5
 80095f4:	b002      	add	sp, #8
 80095f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80095fa:	bf00      	nop
 80095fc:	40021000 	.word	0x40021000

08009600 <HAL_RCCEx_GetPeriphCLKConfig>:
                                        RCC_PERIPHCLK_SDMMC1  | RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC    | RCC_PERIPHCLK_SWPMI1 | RCC_PERIPHCLK_DFSDM1 | \
                                        RCC_PERIPHCLK_RTC ;

#elif defined(STM32L4R5xx) || defined(STM32L4S5xx)

  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART4  | RCC_PERIPHCLK_UART5  | \
 8009600:	4b5b      	ldr	r3, [pc, #364]	; (8009770 <HAL_RCCEx_GetPeriphCLKConfig+0x170>)
 8009602:	6003      	str	r3, [r0, #0]

#if defined(RCC_PLLSAI1_SUPPORT)

  /* Get the PLLSAI1 Clock configuration -----------------------------------------------*/

  PeriphClkInit->PLLSAI1.PLLSAI1Source = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC) >> RCC_PLLCFGR_PLLSRC_Pos;
 8009604:	4b5b      	ldr	r3, [pc, #364]	; (8009774 <HAL_RCCEx_GetPeriphCLKConfig+0x174>)
 8009606:	68d9      	ldr	r1, [r3, #12]
 8009608:	f001 0103 	and.w	r1, r1, #3
 800960c:	6041      	str	r1, [r0, #4]
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
  PeriphClkInit->PLLSAI1.PLLSAI1M = (READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U;
 800960e:	691a      	ldr	r2, [r3, #16]
 8009610:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8009614:	3201      	adds	r2, #1
 8009616:	6082      	str	r2, [r0, #8]
#else
  PeriphClkInit->PLLSAI1.PLLSAI1M = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U;
#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
  PeriphClkInit->PLLSAI1.PLLSAI1N = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
 8009618:	691a      	ldr	r2, [r3, #16]
 800961a:	f3c2 2206 	ubfx	r2, r2, #8, #7
 800961e:	60c2      	str	r2, [r0, #12]
  PeriphClkInit->PLLSAI1.PLLSAI1P = ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1P) >> RCC_PLLSAI1CFGR_PLLSAI1P_Pos) << 4U) + 7U;
 8009620:	691a      	ldr	r2, [r3, #16]
 8009622:	0b52      	lsrs	r2, r2, #13
 8009624:	f002 0210 	and.w	r2, r2, #16
 8009628:	3207      	adds	r2, #7
 800962a:	6102      	str	r2, [r0, #16]
  PeriphClkInit->PLLSAI1.PLLSAI1Q = ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) * 2U;
 800962c:	691a      	ldr	r2, [r3, #16]
 800962e:	f3c2 5241 	ubfx	r2, r2, #21, #2
 8009632:	3201      	adds	r2, #1
 8009634:	0052      	lsls	r2, r2, #1
 8009636:	6142      	str	r2, [r0, #20]
  PeriphClkInit->PLLSAI1.PLLSAI1R = ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1R) >> RCC_PLLSAI1CFGR_PLLSAI1R_Pos) + 1U) * 2U;
 8009638:	691a      	ldr	r2, [r3, #16]

#if defined(RCC_PLLSAI2_SUPPORT)

  /* Get the PLLSAI2 Clock configuration -----------------------------------------------*/

  PeriphClkInit->PLLSAI2.PLLSAI2Source = PeriphClkInit->PLLSAI1.PLLSAI1Source;
 800963a:	6201      	str	r1, [r0, #32]
  PeriphClkInit->PLLSAI1.PLLSAI1M = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U;
#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
  PeriphClkInit->PLLSAI1.PLLSAI1N = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
  PeriphClkInit->PLLSAI1.PLLSAI1P = ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1P) >> RCC_PLLSAI1CFGR_PLLSAI1P_Pos) << 4U) + 7U;
  PeriphClkInit->PLLSAI1.PLLSAI1Q = ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) * 2U;
  PeriphClkInit->PLLSAI1.PLLSAI1R = ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1R) >> RCC_PLLSAI1CFGR_PLLSAI1R_Pos) + 1U) * 2U;
 800963c:	f3c2 6241 	ubfx	r2, r2, #25, #2
 8009640:	3201      	adds	r2, #1
 8009642:	0052      	lsls	r2, r2, #1
 8009644:	6182      	str	r2, [r0, #24]

  /* Get the PLLSAI2 Clock configuration -----------------------------------------------*/

  PeriphClkInit->PLLSAI2.PLLSAI2Source = PeriphClkInit->PLLSAI1.PLLSAI1Source;
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
  PeriphClkInit->PLLSAI2.PLLSAI2M = (READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2M) >> RCC_PLLSAI2CFGR_PLLSAI2M_Pos) + 1U;
 8009646:	695a      	ldr	r2, [r3, #20]
 8009648:	f3c2 1203 	ubfx	r2, r2, #4, #4
 800964c:	3201      	adds	r2, #1
 800964e:	6242      	str	r2, [r0, #36]	; 0x24
#else
  PeriphClkInit->PLLSAI2.PLLSAI2M = PeriphClkInit->PLLSAI1.PLLSAI1M;
#endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
  PeriphClkInit->PLLSAI2.PLLSAI2N = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> RCC_PLLSAI2CFGR_PLLSAI2N_Pos;
 8009650:	695a      	ldr	r2, [r3, #20]
 8009652:	f3c2 2206 	ubfx	r2, r2, #8, #7
 8009656:	6282      	str	r2, [r0, #40]	; 0x28
  PeriphClkInit->PLLSAI2.PLLSAI2P = ((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2P) >> RCC_PLLSAI2CFGR_PLLSAI2P_Pos) << 4U) + 7U;
 8009658:	695a      	ldr	r2, [r3, #20]
 800965a:	0b52      	lsrs	r2, r2, #13
 800965c:	f002 0210 	and.w	r2, r2, #16
 8009660:	3207      	adds	r2, #7
 8009662:	62c2      	str	r2, [r0, #44]	; 0x2c
#if defined(RCC_PLLSAI2Q_DIV_SUPPORT)
  PeriphClkInit->PLLSAI2.PLLSAI2Q = ((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2Q) >> RCC_PLLSAI2CFGR_PLLSAI2Q_Pos) + 1U) * 2U;
 8009664:	695a      	ldr	r2, [r3, #20]
 8009666:	f3c2 5241 	ubfx	r2, r2, #21, #2
 800966a:	3201      	adds	r2, #1
 800966c:	0052      	lsls	r2, r2, #1
 800966e:	6302      	str	r2, [r0, #48]	; 0x30
#endif /* RCC_PLLSAI2Q_DIV_SUPPORT */
  PeriphClkInit->PLLSAI2.PLLSAI2R = ((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2R)>> RCC_PLLSAI2CFGR_PLLSAI2R_Pos) + 1U) * 2U;
 8009670:	695a      	ldr	r2, [r3, #20]
 8009672:	f3c2 6241 	ubfx	r2, r2, #25, #2
 8009676:	3201      	adds	r2, #1
 8009678:	0052      	lsls	r2, r2, #1
 800967a:	6342      	str	r2, [r0, #52]	; 0x34

#endif /* RCC_PLLSAI2_SUPPORT */

  /* Get the USART1 clock source ---------------------------------------------*/
  PeriphClkInit->Usart1ClockSelection  = __HAL_RCC_GET_USART1_SOURCE();
 800967c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8009680:	f002 0203 	and.w	r2, r2, #3
 8009684:	63c2      	str	r2, [r0, #60]	; 0x3c
  /* Get the USART2 clock source ---------------------------------------------*/
  PeriphClkInit->Usart2ClockSelection  = __HAL_RCC_GET_USART2_SOURCE();
 8009686:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800968a:	f002 020c 	and.w	r2, r2, #12
 800968e:	6402      	str	r2, [r0, #64]	; 0x40

#if defined(USART3)
  /* Get the USART3 clock source ---------------------------------------------*/
  PeriphClkInit->Usart3ClockSelection  = __HAL_RCC_GET_USART3_SOURCE();
 8009690:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8009694:	f002 0230 	and.w	r2, r2, #48	; 0x30
 8009698:	6442      	str	r2, [r0, #68]	; 0x44
#endif /* USART3 */

#if defined(UART4)
  /* Get the UART4 clock source ----------------------------------------------*/
  PeriphClkInit->Uart4ClockSelection   = __HAL_RCC_GET_UART4_SOURCE();
 800969a:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800969e:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
 80096a2:	6482      	str	r2, [r0, #72]	; 0x48
#endif /* UART4 */

#if defined(UART5)
  /* Get the UART5 clock source ----------------------------------------------*/
  PeriphClkInit->Uart5ClockSelection   = __HAL_RCC_GET_UART5_SOURCE();
 80096a4:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80096a8:	f402 7240 	and.w	r2, r2, #768	; 0x300
 80096ac:	64c2      	str	r2, [r0, #76]	; 0x4c
#endif /* UART5 */

  /* Get the LPUART1 clock source --------------------------------------------*/
  PeriphClkInit->Lpuart1ClockSelection = __HAL_RCC_GET_LPUART1_SOURCE();
 80096ae:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80096b2:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
 80096b6:	6502      	str	r2, [r0, #80]	; 0x50

  /* Get the I2C1 clock source -----------------------------------------------*/
  PeriphClkInit->I2c1ClockSelection    = __HAL_RCC_GET_I2C1_SOURCE();
 80096b8:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80096bc:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
 80096c0:	6542      	str	r2, [r0, #84]	; 0x54

#if defined(I2C2)
   /* Get the I2C2 clock source ----------------------------------------------*/
  PeriphClkInit->I2c2ClockSelection    = __HAL_RCC_GET_I2C2_SOURCE();
 80096c2:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80096c6:	f402 4240 	and.w	r2, r2, #49152	; 0xc000
 80096ca:	6582      	str	r2, [r0, #88]	; 0x58
#endif /* I2C2 */

  /* Get the I2C3 clock source -----------------------------------------------*/
  PeriphClkInit->I2c3ClockSelection    = __HAL_RCC_GET_I2C3_SOURCE();
 80096cc:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80096d0:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 80096d4:	65c2      	str	r2, [r0, #92]	; 0x5c

#if defined(I2C4)
  /* Get the I2C4 clock source -----------------------------------------------*/
  PeriphClkInit->I2c4ClockSelection    = __HAL_RCC_GET_I2C4_SOURCE();
 80096d6:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 80096da:	f002 0203 	and.w	r2, r2, #3
 80096de:	6602      	str	r2, [r0, #96]	; 0x60
#endif /* I2C4 */

  /* Get the LPTIM1 clock source ---------------------------------------------*/
  PeriphClkInit->Lptim1ClockSelection  = __HAL_RCC_GET_LPTIM1_SOURCE();
 80096e0:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80096e4:	f402 2240 	and.w	r2, r2, #786432	; 0xc0000
 80096e8:	6642      	str	r2, [r0, #100]	; 0x64

  /* Get the LPTIM2 clock source ---------------------------------------------*/
  PeriphClkInit->Lptim2ClockSelection  = __HAL_RCC_GET_LPTIM2_SOURCE();
 80096ea:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80096ee:	f402 1240 	and.w	r2, r2, #3145728	; 0x300000
 80096f2:	6682      	str	r2, [r0, #104]	; 0x68

#if defined(SAI1)
  /* Get the SAI1 clock source -----------------------------------------------*/
  PeriphClkInit->Sai1ClockSelection    = __HAL_RCC_GET_SAI1_SOURCE();
 80096f4:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 80096f8:	f002 02e0 	and.w	r2, r2, #224	; 0xe0
 80096fc:	66c2      	str	r2, [r0, #108]	; 0x6c
#endif /* SAI1 */

#if defined(SAI2)
  /* Get the SAI2 clock source -----------------------------------------------*/
  PeriphClkInit->Sai2ClockSelection    = __HAL_RCC_GET_SAI2_SOURCE();
 80096fe:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 8009702:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8009706:	6702      	str	r2, [r0, #112]	; 0x70
#endif /* SAI2 */

  /* Get the RTC clock source ------------------------------------------------*/
  PeriphClkInit->RTCClockSelection     = __HAL_RCC_GET_RTC_SOURCE();
 8009708:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 800970c:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8009710:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90

#if defined(USB_OTG_FS) || defined(USB)
  /* Get the USB clock source ------------------------------------------------*/
  PeriphClkInit->UsbClockSelection   = __HAL_RCC_GET_USB_SOURCE();
 8009714:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8009718:	f002 6240 	and.w	r2, r2, #201326592	; 0xc000000
 800971c:	6742      	str	r2, [r0, #116]	; 0x74
#endif /* USB_OTG_FS || USB */

#if defined(SDMMC1)
  /* Get the SDMMC1 clock source ---------------------------------------------*/
  PeriphClkInit->Sdmmc1ClockSelection   = __HAL_RCC_GET_SDMMC1_SOURCE();
 800971e:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 8009722:	0452      	lsls	r2, r2, #17
 8009724:	bf56      	itet	pl
 8009726:	f8d3 2088 	ldrpl.w	r2, [r3, #136]	; 0x88
 800972a:	f44f 4280 	movmi.w	r2, #16384	; 0x4000
 800972e:	f002 6240 	andpl.w	r2, r2, #201326592	; 0xc000000
 8009732:	6782      	str	r2, [r0, #120]	; 0x78
#endif /* SDMMC1 */

  /* Get the RNG clock source ------------------------------------------------*/
  PeriphClkInit->RngClockSelection   = __HAL_RCC_GET_RNG_SOURCE();
 8009734:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8009738:	f002 6240 	and.w	r2, r2, #201326592	; 0xc000000
 800973c:	67c2      	str	r2, [r0, #124]	; 0x7c

#if !defined(STM32L412xx) && !defined(STM32L422xx)
  /* Get the ADC clock source ------------------------------------------------*/
  PeriphClkInit->AdcClockSelection     = __HAL_RCC_GET_ADC_SOURCE();
 800973e:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8009742:	f002 5240 	and.w	r2, r2, #805306368	; 0x30000000
 8009746:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
  PeriphClkInit->Swpmi1ClockSelection  = __HAL_RCC_GET_SWPMI1_SOURCE();
#endif /* SWPMI1 */

#if defined(DFSDM1_Filter0)
  /* Get the DFSDM1 clock source ---------------------------------------------*/
  PeriphClkInit->Dfsdm1ClockSelection  = __HAL_RCC_GET_DFSDM1_SOURCE();
 800974a:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 800974e:	f002 0204 	and.w	r2, r2, #4
 8009752:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84

#if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  /* Get the DFSDM1 audio clock source ---------------------------------------*/
  PeriphClkInit->Dfsdm1AudioClockSelection  = __HAL_RCC_GET_DFSDM1AUDIO_SOURCE();
 8009756:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 800975a:	f002 0218 	and.w	r2, r2, #24
 800975e:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  PeriphClkInit->DsiClockSelection = __HAL_RCC_GET_DSI_SOURCE();
#endif /* DSI */

#if defined(OCTOSPI1) || defined(OCTOSPI2)
  /* Get the OctoSPIclock source --------------------------------------------*/
  PeriphClkInit->OspiClockSelection = __HAL_RCC_GET_OSPI_SOURCE();
 8009762:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8009766:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 800976a:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
 800976e:	4770      	bx	lr
 8009770:	013f7fff 	.word	0x013f7fff
 8009774:	40021000 	.word	0x40021000

08009778 <HAL_RCCEx_GetPeriphCLKFreq>:
#endif

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));

  if(PeriphClk == RCC_PERIPHCLK_RTC)
 8009778:	f5b0 3f00 	cmp.w	r0, #131072	; 0x20000
 800977c:	4bbc      	ldr	r3, [pc, #752]	; (8009a70 <HAL_RCCEx_GetPeriphCLKFreq+0x2f8>)
 800977e:	d112      	bne.n	80097a6 <HAL_RCCEx_GetPeriphCLKFreq+0x2e>
  {
    /* Get the current RTC source */
    srcclk = __HAL_RCC_GET_RTC_SOURCE();
 8009780:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90

    switch(srcclk)
 8009784:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8009788:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 800978c:	f000 820a 	beq.w	8009ba4 <HAL_RCCEx_GetPeriphCLKFreq+0x42c>
 8009790:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 8009794:	d002      	beq.n	800979c <HAL_RCCEx_GetPeriphCLKFreq+0x24>
 8009796:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 800979a:	e200      	b.n	8009b9e <HAL_RCCEx_GetPeriphCLKFreq+0x426>
        }
      }
      break;
    case RCC_RTCCLKSOURCE_HSE_DIV32:
      /* Check if HSE is ready */
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 800979c:	681b      	ldr	r3, [r3, #0]
      {
        frequency = HSE_VALUE / 32U;
 800979e:	48b5      	ldr	r0, [pc, #724]	; (8009a74 <HAL_RCCEx_GetPeriphCLKFreq+0x2fc>)
 80097a0:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80097a4:	e228      	b.n	8009bf8 <HAL_RCCEx_GetPeriphCLKFreq+0x480>
    }
  }
  else
  {
    /* Other external peripheral clock source than RTC */
    pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 80097a6:	68da      	ldr	r2, [r3, #12]

    /* Compute PLL clock input */
    switch(pll_oscsource)
 80097a8:	f002 0203 	and.w	r2, r2, #3
 80097ac:	2a02      	cmp	r2, #2
 80097ae:	d015      	beq.n	80097dc <HAL_RCCEx_GetPeriphCLKFreq+0x64>
 80097b0:	2a03      	cmp	r2, #3
 80097b2:	d018      	beq.n	80097e6 <HAL_RCCEx_GetPeriphCLKFreq+0x6e>
 80097b4:	2a01      	cmp	r2, #1
 80097b6:	d11d      	bne.n	80097f4 <HAL_RCCEx_GetPeriphCLKFreq+0x7c>
    {
    case RCC_PLLSOURCE_MSI:   /* MSI ? */
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIRDY))
 80097b8:	6819      	ldr	r1, [r3, #0]
 80097ba:	f011 0102 	ands.w	r1, r1, #2
 80097be:	d01a      	beq.n	80097f6 <HAL_RCCEx_GetPeriphCLKFreq+0x7e>
      {
        /*MSI frequency range in HZ*/
        pllvco = MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> 4U)];
 80097c0:	681a      	ldr	r2, [r3, #0]
 80097c2:	49ad      	ldr	r1, [pc, #692]	; (8009a78 <HAL_RCCEx_GetPeriphCLKFreq+0x300>)
 80097c4:	0712      	lsls	r2, r2, #28
 80097c6:	bf4b      	itete	mi
 80097c8:	681a      	ldrmi	r2, [r3, #0]
 80097ca:	f8d3 2094 	ldrpl.w	r2, [r3, #148]	; 0x94
 80097ce:	f3c2 1203 	ubfxmi	r2, r2, #4, #4
 80097d2:	f3c2 2203 	ubfxpl	r2, r2, #8, #4
 80097d6:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
 80097da:	e00c      	b.n	80097f6 <HAL_RCCEx_GetPeriphCLKFreq+0x7e>
      {
        pllvco = 0U;
      }
      break;
    case RCC_PLLSOURCE_HSI:   /* HSI ? */
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 80097dc:	681a      	ldr	r2, [r3, #0]
      {
        pllvco = HSI_VALUE;
 80097de:	49a7      	ldr	r1, [pc, #668]	; (8009a7c <HAL_RCCEx_GetPeriphCLKFreq+0x304>)
 80097e0:	f412 6f80 	tst.w	r2, #1024	; 0x400
 80097e4:	e003      	b.n	80097ee <HAL_RCCEx_GetPeriphCLKFreq+0x76>
      {
        pllvco = 0U;
      }
      break;
    case RCC_PLLSOURCE_HSE:   /* HSE ? */
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 80097e6:	681a      	ldr	r2, [r3, #0]
      {
        pllvco = HSE_VALUE;
 80097e8:	49a5      	ldr	r1, [pc, #660]	; (8009a80 <HAL_RCCEx_GetPeriphCLKFreq+0x308>)
 80097ea:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 80097ee:	bf08      	it	eq
 80097f0:	2100      	moveq	r1, #0
 80097f2:	e000      	b.n	80097f6 <HAL_RCCEx_GetPeriphCLKFreq+0x7e>
        pllvco = 0U;
      }
      break;
    default:
      /* No source */
      pllvco = 0U;
 80097f4:	2100      	movs	r1, #0
      break;
    }

    switch(PeriphClk)
 80097f6:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 80097fa:	f000 81db 	beq.w	8009bb4 <HAL_RCCEx_GetPeriphCLKFreq+0x43c>
 80097fe:	d826      	bhi.n	800984e <HAL_RCCEx_GetPeriphCLKFreq+0xd6>
 8009800:	2810      	cmp	r0, #16
 8009802:	f000 8123 	beq.w	8009a4c <HAL_RCCEx_GetPeriphCLKFreq+0x2d4>
 8009806:	d80e      	bhi.n	8009826 <HAL_RCCEx_GetPeriphCLKFreq+0xae>
 8009808:	2802      	cmp	r0, #2
 800980a:	f000 80ed 	beq.w	80099e8 <HAL_RCCEx_GetPeriphCLKFreq+0x270>
 800980e:	d803      	bhi.n	8009818 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
 8009810:	2801      	cmp	r0, #1
 8009812:	f000 80da 	beq.w	80099ca <HAL_RCCEx_GetPeriphCLKFreq+0x252>
 8009816:	e238      	b.n	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 8009818:	2804      	cmp	r0, #4
 800981a:	f000 80fb 	beq.w	8009a14 <HAL_RCCEx_GetPeriphCLKFreq+0x29c>
 800981e:	2808      	cmp	r0, #8
 8009820:	f000 8106 	beq.w	8009a30 <HAL_RCCEx_GetPeriphCLKFreq+0x2b8>
 8009824:	e231      	b.n	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 8009826:	2880      	cmp	r0, #128	; 0x80
 8009828:	f000 8189 	beq.w	8009b3e <HAL_RCCEx_GetPeriphCLKFreq+0x3c6>
 800982c:	d806      	bhi.n	800983c <HAL_RCCEx_GetPeriphCLKFreq+0xc4>
 800982e:	2820      	cmp	r0, #32
 8009830:	f000 812a 	beq.w	8009a88 <HAL_RCCEx_GetPeriphCLKFreq+0x310>
 8009834:	2840      	cmp	r0, #64	; 0x40
 8009836:	f000 8177 	beq.w	8009b28 <HAL_RCCEx_GetPeriphCLKFreq+0x3b0>
 800983a:	e226      	b.n	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 800983c:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 8009840:	f000 8187 	beq.w	8009b52 <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
 8009844:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8009848:	f000 819a 	beq.w	8009b80 <HAL_RCCEx_GetPeriphCLKFreq+0x408>
 800984c:	e21d      	b.n	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 800984e:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 8009852:	f000 814e 	beq.w	8009af2 <HAL_RCCEx_GetPeriphCLKFreq+0x37a>
 8009856:	d811      	bhi.n	800987c <HAL_RCCEx_GetPeriphCLKFreq+0x104>
 8009858:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
 800985c:	f000 815e 	beq.w	8009b1c <HAL_RCCEx_GetPeriphCLKFreq+0x3a4>
 8009860:	d804      	bhi.n	800986c <HAL_RCCEx_GetPeriphCLKFreq+0xf4>
 8009862:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
 8009866:	f000 8159 	beq.w	8009b1c <HAL_RCCEx_GetPeriphCLKFreq+0x3a4>
 800986a:	e20e      	b.n	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 800986c:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
 8009870:	d019      	beq.n	80098a6 <HAL_RCCEx_GetPeriphCLKFreq+0x12e>
 8009872:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
 8009876:	f000 8117 	beq.w	8009aa8 <HAL_RCCEx_GetPeriphCLKFreq+0x330>
 800987a:	e206      	b.n	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 800987c:	f5b0 1f80 	cmp.w	r0, #1048576	; 0x100000
 8009880:	f000 8172 	beq.w	8009b68 <HAL_RCCEx_GetPeriphCLKFreq+0x3f0>
 8009884:	d806      	bhi.n	8009894 <HAL_RCCEx_GetPeriphCLKFreq+0x11c>
 8009886:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
 800988a:	d00c      	beq.n	80098a6 <HAL_RCCEx_GetPeriphCLKFreq+0x12e>
 800988c:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
 8009890:	d025      	beq.n	80098de <HAL_RCCEx_GetPeriphCLKFreq+0x166>
 8009892:	e1fa      	b.n	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 8009894:	f5b0 1f00 	cmp.w	r0, #2097152	; 0x200000
 8009898:	f000 8132 	beq.w	8009b00 <HAL_RCCEx_GetPeriphCLKFreq+0x388>
 800989c:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80098a0:	f000 81b6 	beq.w	8009c10 <HAL_RCCEx_GetPeriphCLKFreq+0x498>
 80098a4:	e1f1      	b.n	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>

    case RCC_PERIPHCLK_SDMMC1:

#endif /* SDMMC1 && !RCC_CCIPR2_SDMMCSEL */
      {
        srcclk = READ_BIT(RCC->CCIPR, RCC_CCIPR_CLK48SEL);
 80098a6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80098aa:	4a71      	ldr	r2, [pc, #452]	; (8009a70 <HAL_RCCEx_GetPeriphCLKFreq+0x2f8>)

        switch(srcclk)
 80098ac:	f003 6340 	and.w	r3, r3, #201326592	; 0xc000000
 80098b0:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 80098b4:	d011      	beq.n	80098da <HAL_RCCEx_GetPeriphCLKFreq+0x162>
 80098b6:	d805      	bhi.n	80098c4 <HAL_RCCEx_GetPeriphCLKFreq+0x14c>
 80098b8:	2b00      	cmp	r3, #0
 80098ba:	f040 81e6 	bne.w	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
          }
          break;
#endif /* RCC_PLLSAI1_SUPPORT */
#if defined(RCC_HSI48_SUPPORT)
        case 0U:
          if(HAL_IS_BIT_SET(RCC->CRRCR, RCC_CRRCR_HSI48RDY)) /* HSI48 ? */
 80098be:	f8d2 3098 	ldr.w	r3, [r2, #152]	; 0x98
 80098c2:	e07e      	b.n	80099c2 <HAL_RCCEx_GetPeriphCLKFreq+0x24a>

#endif /* SDMMC1 && !RCC_CCIPR2_SDMMCSEL */
      {
        srcclk = READ_BIT(RCC->CCIPR, RCC_CCIPR_CLK48SEL);

        switch(srcclk)
 80098c4:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 80098c8:	d005      	beq.n	80098d6 <HAL_RCCEx_GetPeriphCLKFreq+0x15e>
 80098ca:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
 80098ce:	f040 81dc 	bne.w	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
        {
        case RCC_CCIPR_CLK48SEL:   /* MSI ? */
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIRDY))
 80098d2:	6810      	ldr	r0, [r2, #0]
 80098d4:	e040      	b.n	8009958 <HAL_RCCEx_GetPeriphCLKFreq+0x1e0>
            /*MSI frequency range in HZ*/
            frequency = MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> 4U)];
          }
          break;
        case RCC_CCIPR_CLK48SEL_1:  /* PLL ? */
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY))
 80098d6:	6813      	ldr	r3, [r2, #0]
 80098d8:	e046      	b.n	8009968 <HAL_RCCEx_GetPeriphCLKFreq+0x1f0>
            }
          }
          break;
#if defined(RCC_PLLSAI1_SUPPORT)
        case RCC_CCIPR_CLK48SEL_0:  /* PLLSAI1 ? */
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI1RDY))
 80098da:	6813      	ldr	r3, [r2, #0]
 80098dc:	e056      	b.n	800998c <HAL_RCCEx_GetPeriphCLKFreq+0x214>

#if defined(SDMMC1) && defined(RCC_CCIPR2_SDMMCSEL)

    case RCC_PERIPHCLK_SDMMC1:

      if(HAL_IS_BIT_SET(RCC->CCIPR2, RCC_CCIPR2_SDMMCSEL))  /* PLL "P" ? */
 80098de:	f8d3 009c 	ldr.w	r0, [r3, #156]	; 0x9c
 80098e2:	4a63      	ldr	r2, [pc, #396]	; (8009a70 <HAL_RCCEx_GetPeriphCLKFreq+0x2f8>)
 80098e4:	0440      	lsls	r0, r0, #17
 80098e6:	d51d      	bpl.n	8009924 <HAL_RCCEx_GetPeriphCLKFreq+0x1ac>
      {
        if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY))
 80098e8:	6812      	ldr	r2, [r2, #0]
 80098ea:	0192      	lsls	r2, r2, #6
 80098ec:	f140 81cd 	bpl.w	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
        {
          if(HAL_IS_BIT_SET(RCC->PLLCFGR, RCC_PLLCFGR_PLLPEN))
 80098f0:	68db      	ldr	r3, [r3, #12]
 80098f2:	4a5f      	ldr	r2, [pc, #380]	; (8009a70 <HAL_RCCEx_GetPeriphCLKFreq+0x2f8>)
 80098f4:	f413 3080 	ands.w	r0, r3, #65536	; 0x10000
 80098f8:	f000 81c8 	beq.w	8009c8c <HAL_RCCEx_GetPeriphCLKFreq+0x514>
          {
            /* f(PLL Source) * PLLN / PLLM */
            plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
 80098fc:	68d0      	ldr	r0, [r2, #12]
            pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 80098fe:	f3c0 2006 	ubfx	r0, r0, #8, #7
 8009902:	4341      	muls	r1, r0
 8009904:	68d0      	ldr	r0, [r2, #12]
 8009906:	f3c0 1003 	ubfx	r0, r0, #4, #4
 800990a:	3001      	adds	r0, #1
 800990c:	fbb1 f1f0 	udiv	r1, r1, r0
            /* f(PLLSAI3CLK) = f(VCO input) / PLLP */
            pllp = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLPDIV) >> RCC_PLLCFGR_PLLPDIV_Pos;
 8009910:	68d0      	ldr	r0, [r2, #12]
            if(pllp == 0U)
 8009912:	0ec0      	lsrs	r0, r0, #27
 8009914:	d152      	bne.n	80099bc <HAL_RCCEx_GetPeriphCLKFreq+0x244>
            {
              if(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP) != 0U)
 8009916:	68d3      	ldr	r3, [r2, #12]
              {
                pllp = 17U;
              }
              else
              {
                pllp = 7U;
 8009918:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 800991c:	bf14      	ite	ne
 800991e:	2011      	movne	r0, #17
 8009920:	2007      	moveq	r0, #7
 8009922:	e04b      	b.n	80099bc <HAL_RCCEx_GetPeriphCLKFreq+0x244>
          }
        }
      }
      else  /* 48MHz from PLL "Q" or MSI or PLLSAI1Q or HSI48 */
      {
        srcclk = READ_BIT(RCC->CCIPR, RCC_CCIPR_CLK48SEL);
 8009924:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88

        switch(srcclk)
 8009928:	f002 6240 	and.w	r2, r2, #201326592	; 0xc000000
 800992c:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
 8009930:	d02a      	beq.n	8009988 <HAL_RCCEx_GetPeriphCLKFreq+0x210>
 8009932:	d805      	bhi.n	8009940 <HAL_RCCEx_GetPeriphCLKFreq+0x1c8>
 8009934:	2a00      	cmp	r2, #0
 8009936:	f040 81a8 	bne.w	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
              frequency = (pllvco / (((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) << 1U));
            }
          }
          break;
        case 0U:
          if(HAL_IS_BIT_SET(RCC->CRRCR, RCC_CRRCR_HSI48RDY)) /* HSI48 ? */
 800993a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800993e:	e040      	b.n	80099c2 <HAL_RCCEx_GetPeriphCLKFreq+0x24a>
      }
      else  /* 48MHz from PLL "Q" or MSI or PLLSAI1Q or HSI48 */
      {
        srcclk = READ_BIT(RCC->CCIPR, RCC_CCIPR_CLK48SEL);

        switch(srcclk)
 8009940:	f1b2 6f00 	cmp.w	r2, #134217728	; 0x8000000
 8009944:	d00e      	beq.n	8009964 <HAL_RCCEx_GetPeriphCLKFreq+0x1ec>
 8009946:	f1b2 6f40 	cmp.w	r2, #201326592	; 0xc000000
 800994a:	f040 819e 	bne.w	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
        {
        case RCC_CCIPR_CLK48SEL:   /* MSI ? */
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIRDY))
 800994e:	f102 5250 	add.w	r2, r2, #872415232	; 0x34000000
 8009952:	6818      	ldr	r0, [r3, #0]
 8009954:	f502 3204 	add.w	r2, r2, #135168	; 0x21000
 8009958:	f010 0002 	ands.w	r0, r0, #2
 800995c:	f000 8196 	beq.w	8009c8c <HAL_RCCEx_GetPeriphCLKFreq+0x514>
          {
            /*MSI frequency range in HZ*/
            frequency = MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> 4U)];
 8009960:	6813      	ldr	r3, [r2, #0]
 8009962:	e169      	b.n	8009c38 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
          }
          break;
        case RCC_CCIPR_CLK48SEL_1:  /* PLL "Q" ? */
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY))
 8009964:	4a42      	ldr	r2, [pc, #264]	; (8009a70 <HAL_RCCEx_GetPeriphCLKFreq+0x2f8>)
 8009966:	681b      	ldr	r3, [r3, #0]
 8009968:	f013 7000 	ands.w	r0, r3, #33554432	; 0x2000000
 800996c:	f000 818e 	beq.w	8009c8c <HAL_RCCEx_GetPeriphCLKFreq+0x514>
          {
            if(HAL_IS_BIT_SET(RCC->PLLCFGR, RCC_PLLCFGR_PLLQEN))
 8009970:	68d3      	ldr	r3, [r2, #12]
 8009972:	f413 1080 	ands.w	r0, r3, #1048576	; 0x100000
 8009976:	f000 8189 	beq.w	8009c8c <HAL_RCCEx_GetPeriphCLKFreq+0x514>
            {
              /* f(PLL Source) * PLLN / PLLM */
              plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
 800997a:	68d0      	ldr	r0, [r2, #12]
              pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 800997c:	68d3      	ldr	r3, [r2, #12]
 800997e:	f3c0 2006 	ubfx	r0, r0, #8, #7
 8009982:	4341      	muls	r1, r0
              /* f(PLL48M1CLK) = f(VCO input) / PLLQ */
              frequency = (pllvco / (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U));
 8009984:	68d0      	ldr	r0, [r2, #12]
 8009986:	e010      	b.n	80099aa <HAL_RCCEx_GetPeriphCLKFreq+0x232>
            }
          }
          break;
        case RCC_CCIPR_CLK48SEL_0:  /* PLLSAI1 ? */
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI1RDY))
 8009988:	4a39      	ldr	r2, [pc, #228]	; (8009a70 <HAL_RCCEx_GetPeriphCLKFreq+0x2f8>)
 800998a:	681b      	ldr	r3, [r3, #0]
 800998c:	f013 6000 	ands.w	r0, r3, #134217728	; 0x8000000
 8009990:	f000 817c 	beq.w	8009c8c <HAL_RCCEx_GetPeriphCLKFreq+0x514>
          {
            if(HAL_IS_BIT_SET(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1QEN))
 8009994:	6913      	ldr	r3, [r2, #16]
 8009996:	f413 1080 	ands.w	r0, r3, #1048576	; 0x100000
 800999a:	f000 8177 	beq.w	8009c8c <HAL_RCCEx_GetPeriphCLKFreq+0x514>
            {
              /* f(PLLSAI1 Source) * PLLSAI1N / PLLSAI1M */
              plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
 800999e:	6910      	ldr	r0, [r2, #16]
              pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U));
 80099a0:	6913      	ldr	r3, [r2, #16]
 80099a2:	f3c0 2006 	ubfx	r0, r0, #8, #7
 80099a6:	4341      	muls	r1, r0
              /* f(PLL48M2CLK) = f(VCOSAI1 input) / PLLSAI1Q */
              frequency = (pllvco / (((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) << 1U));
 80099a8:	6910      	ldr	r0, [r2, #16]
 80099aa:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80099ae:	f3c0 5041 	ubfx	r0, r0, #21, #2
 80099b2:	3301      	adds	r3, #1
 80099b4:	fbb1 f1f3 	udiv	r1, r1, r3
 80099b8:	3001      	adds	r0, #1
 80099ba:	0040      	lsls	r0, r0, #1
 80099bc:	fbb1 f0f0 	udiv	r0, r1, r0
 80099c0:	4770      	bx	lr
#endif /* RCC_PLLSAI1_SUPPORT */
#if defined(RCC_HSI48_SUPPORT)
        case 0U:
          if(HAL_IS_BIT_SET(RCC->CRRCR, RCC_CRRCR_HSI48RDY)) /* HSI48 ? */
          {
            frequency = HSI48_VALUE;
 80099c2:	f013 0f02 	tst.w	r3, #2
 80099c6:	482f      	ldr	r0, [pc, #188]	; (8009a84 <HAL_RCCEx_GetPeriphCLKFreq+0x30c>)
 80099c8:	e116      	b.n	8009bf8 <HAL_RCCEx_GetPeriphCLKFreq+0x480>
#endif /* SDMMC1 && RCC_CCIPR2_SDMMCSEL */

    case RCC_PERIPHCLK_USART1:
      {
        /* Get the current USART1 source */
        srcclk = __HAL_RCC_GET_USART1_SOURCE();
 80099ca:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80099ce:	4a28      	ldr	r2, [pc, #160]	; (8009a70 <HAL_RCCEx_GetPeriphCLKFreq+0x2f8>)

        switch(srcclk)
 80099d0:	f003 0303 	and.w	r3, r3, #3
 80099d4:	2b02      	cmp	r3, #2
 80099d6:	f000 810b 	beq.w	8009bf0 <HAL_RCCEx_GetPeriphCLKFreq+0x478>
 80099da:	2b03      	cmp	r3, #3
 80099dc:	f000 810f 	beq.w	8009bfe <HAL_RCCEx_GetPeriphCLKFreq+0x486>
 80099e0:	2b01      	cmp	r3, #1
 80099e2:	f040 808b 	bne.w	8009afc <HAL_RCCEx_GetPeriphCLKFreq+0x384>
 80099e6:	e11f      	b.n	8009c28 <HAL_RCCEx_GetPeriphCLKFreq+0x4b0>
      }

    case RCC_PERIPHCLK_USART2:
      {
        /* Get the current USART2 source */
        srcclk = __HAL_RCC_GET_USART2_SOURCE();
 80099e8:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88

        switch(srcclk)
 80099ec:	f002 020c 	and.w	r2, r2, #12
 80099f0:	2a0c      	cmp	r2, #12
 80099f2:	f200 814a 	bhi.w	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 80099f6:	e8df f012 	tbh	[pc, r2, lsl #1]
 80099fa:	00f0      	.short	0x00f0
 80099fc:	01480148 	.word	0x01480148
 8009a00:	01170148 	.word	0x01170148
 8009a04:	01480148 	.word	0x01480148
 8009a08:	00d80148 	.word	0x00d80148
 8009a0c:	01480148 	.word	0x01480148
 8009a10:	00da0148 	.word	0x00da0148
#if defined(USART3)

    case RCC_PERIPHCLK_USART3:
      {
        /* Get the current USART3 source */
        srcclk = __HAL_RCC_GET_USART3_SOURCE();
 8009a14:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88

        switch(srcclk)
 8009a18:	f002 0230 	and.w	r2, r2, #48	; 0x30
 8009a1c:	2a10      	cmp	r2, #16
 8009a1e:	f000 8103 	beq.w	8009c28 <HAL_RCCEx_GetPeriphCLKFreq+0x4b0>
 8009a22:	f240 80b5 	bls.w	8009b90 <HAL_RCCEx_GetPeriphCLKFreq+0x418>
 8009a26:	2a20      	cmp	r2, #32
 8009a28:	f000 80bf 	beq.w	8009baa <HAL_RCCEx_GetPeriphCLKFreq+0x432>
 8009a2c:	2a30      	cmp	r2, #48	; 0x30
 8009a2e:	e0b6      	b.n	8009b9e <HAL_RCCEx_GetPeriphCLKFreq+0x426>
#if defined(UART4)

    case RCC_PERIPHCLK_UART4:
      {
        /* Get the current UART4 source */
        srcclk = __HAL_RCC_GET_UART4_SOURCE();
 8009a30:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88

        switch(srcclk)
 8009a34:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
 8009a38:	2a40      	cmp	r2, #64	; 0x40
 8009a3a:	f000 80f5 	beq.w	8009c28 <HAL_RCCEx_GetPeriphCLKFreq+0x4b0>
 8009a3e:	f240 80a7 	bls.w	8009b90 <HAL_RCCEx_GetPeriphCLKFreq+0x418>
 8009a42:	2a80      	cmp	r2, #128	; 0x80
 8009a44:	f000 80b1 	beq.w	8009baa <HAL_RCCEx_GetPeriphCLKFreq+0x432>
 8009a48:	2ac0      	cmp	r2, #192	; 0xc0
 8009a4a:	e0a8      	b.n	8009b9e <HAL_RCCEx_GetPeriphCLKFreq+0x426>
#if defined(UART5)

    case RCC_PERIPHCLK_UART5:
      {
        /* Get the current UART5 source */
        srcclk = __HAL_RCC_GET_UART5_SOURCE();
 8009a4c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8009a50:	4a07      	ldr	r2, [pc, #28]	; (8009a70 <HAL_RCCEx_GetPeriphCLKFreq+0x2f8>)

        switch(srcclk)
 8009a52:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8009a56:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8009a5a:	f000 80e5 	beq.w	8009c28 <HAL_RCCEx_GetPeriphCLKFreq+0x4b0>
 8009a5e:	f240 80b2 	bls.w	8009bc6 <HAL_RCCEx_GetPeriphCLKFreq+0x44e>
 8009a62:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8009a66:	f000 80c3 	beq.w	8009bf0 <HAL_RCCEx_GetPeriphCLKFreq+0x478>
 8009a6a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8009a6e:	e0b2      	b.n	8009bd6 <HAL_RCCEx_GetPeriphCLKFreq+0x45e>
 8009a70:	40021000 	.word	0x40021000
 8009a74:	0003d090 	.word	0x0003d090
 8009a78:	0800e740 	.word	0x0800e740
 8009a7c:	00f42400 	.word	0x00f42400
 8009a80:	007a1200 	.word	0x007a1200
 8009a84:	02dc6c00 	.word	0x02dc6c00
#endif /* UART5 */

    case RCC_PERIPHCLK_LPUART1:
      {
        /* Get the current LPUART1 source */
        srcclk = __HAL_RCC_GET_LPUART1_SOURCE();
 8009a88:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88

        switch(srcclk)
 8009a8c:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
 8009a90:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 8009a94:	f000 80c8 	beq.w	8009c28 <HAL_RCCEx_GetPeriphCLKFreq+0x4b0>
 8009a98:	d97a      	bls.n	8009b90 <HAL_RCCEx_GetPeriphCLKFreq+0x418>
 8009a9a:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 8009a9e:	f000 8084 	beq.w	8009baa <HAL_RCCEx_GetPeriphCLKFreq+0x432>
 8009aa2:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
 8009aa6:	e07a      	b.n	8009b9e <HAL_RCCEx_GetPeriphCLKFreq+0x426>
        break;
      }

    case RCC_PERIPHCLK_ADC:
      {
        srcclk = __HAL_RCC_GET_ADC_SOURCE();
 8009aa8:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88

        switch(srcclk)
 8009aac:	f002 5240 	and.w	r2, r2, #805306368	; 0x30000000
 8009ab0:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
 8009ab4:	d004      	beq.n	8009ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x348>
 8009ab6:	f1b2 5f40 	cmp.w	r2, #805306368	; 0x30000000
 8009aba:	f040 80e6 	bne.w	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 8009abe:	e0b3      	b.n	8009c28 <HAL_RCCEx_GetPeriphCLKFreq+0x4b0>
        case RCC_ADCCLKSOURCE_SYSCLK:
          frequency = HAL_RCC_GetSysClockFreq();
          break;
#if defined(RCC_PLLSAI1_SUPPORT)
        case RCC_ADCCLKSOURCE_PLLSAI1:
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI1RDY) && (__HAL_RCC_GET_PLLSAI1CLKOUT_CONFIG(RCC_PLLSAI1_ADC1CLK) != 0U))
 8009ac0:	4a73      	ldr	r2, [pc, #460]	; (8009c90 <HAL_RCCEx_GetPeriphCLKFreq+0x518>)
 8009ac2:	6812      	ldr	r2, [r2, #0]
 8009ac4:	0110      	lsls	r0, r2, #4
 8009ac6:	f140 80e0 	bpl.w	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 8009aca:	691b      	ldr	r3, [r3, #16]
 8009acc:	4a70      	ldr	r2, [pc, #448]	; (8009c90 <HAL_RCCEx_GetPeriphCLKFreq+0x518>)
 8009ace:	f013 7080 	ands.w	r0, r3, #16777216	; 0x1000000
 8009ad2:	f000 80db 	beq.w	8009c8c <HAL_RCCEx_GetPeriphCLKFreq+0x514>
          {
            plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
 8009ad6:	6910      	ldr	r0, [r2, #16]
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
            /* PLLSAI1M exists: apply PLLSAI1M divider for PLLSAI1 output computation */
            /* f(PLLSAI1 Source) * PLLSAI1N / PLLSAI1M */
            pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U));
 8009ad8:	6913      	ldr	r3, [r2, #16]
 8009ada:	f3c0 2006 	ubfx	r0, r0, #8, #7
 8009ade:	4341      	muls	r1, r0
#else
            /* f(PLL Source) * PLLSAI1N / PLLM */
            pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
#endif
            /* f(PLLADC1CLK) = f(VCOSAI1 input) / PLLSAI1R */
            frequency = (pllvco / (((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1R) >> RCC_PLLSAI1CFGR_PLLSAI1R_Pos) + 1U) << 1U));
 8009ae0:	6910      	ldr	r0, [r2, #16]
 8009ae2:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8009ae6:	3301      	adds	r3, #1
 8009ae8:	f3c0 6041 	ubfx	r0, r0, #25, #2
 8009aec:	fbb1 f1f3 	udiv	r1, r1, r3
 8009af0:	e762      	b.n	80099b8 <HAL_RCCEx_GetPeriphCLKFreq+0x240>
#if defined(DFSDM1_Filter0)

    case RCC_PERIPHCLK_DFSDM1:
      {
        /* Get the current DFSDM1 source */
        srcclk = __HAL_RCC_GET_DFSDM1_SOURCE();
 8009af2:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c

        if(srcclk == RCC_DFSDM1CLKSOURCE_PCLK2)
 8009af6:	0759      	lsls	r1, r3, #29
 8009af8:	f100 8096 	bmi.w	8009c28 <HAL_RCCEx_GetPeriphCLKFreq+0x4b0>
        {
          frequency = HAL_RCC_GetPCLK2Freq();
 8009afc:	f7ff b940 	b.w	8008d80 <HAL_RCC_GetPCLK2Freq>
#if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)

    case RCC_PERIPHCLK_DFSDM1AUDIO:
      {
        /* Get the current DFSDM1 audio source */
        srcclk = __HAL_RCC_GET_DFSDM1AUDIO_SOURCE();
 8009b00:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 8009b04:	4862      	ldr	r0, [pc, #392]	; (8009c90 <HAL_RCCEx_GetPeriphCLKFreq+0x518>)

        switch(srcclk)
 8009b06:	f002 0218 	and.w	r2, r2, #24
 8009b0a:	2a08      	cmp	r2, #8
 8009b0c:	d00a      	beq.n	8009b24 <HAL_RCCEx_GetPeriphCLKFreq+0x3ac>
 8009b0e:	2a10      	cmp	r2, #16
 8009b10:	d006      	beq.n	8009b20 <HAL_RCCEx_GetPeriphCLKFreq+0x3a8>
 8009b12:	2a00      	cmp	r2, #0
 8009b14:	f040 80b9 	bne.w	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
        {
        case RCC_DFSDM1AUDIOCLKSOURCE_SAI1:
          frequency = RCCEx_GetSAIxPeriphCLKFreq(RCC_PERIPHCLK_SAI1, pllvco);
 8009b18:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8009b1c:	f7ff b9e2 	b.w	8008ee4 <RCCEx_GetSAIxPeriphCLKFreq>
          break;
        case RCC_DFSDM1AUDIOCLKSOURCE_MSI:
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIRDY))
 8009b20:	6802      	ldr	r2, [r0, #0]
 8009b22:	e085      	b.n	8009c30 <HAL_RCCEx_GetPeriphCLKFreq+0x4b8>
            /*MSI frequency range in HZ*/
            frequency = MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> 4U)];
          }
          break;
        case RCC_DFSDM1AUDIOCLKSOURCE_HSI:
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8009b24:	6803      	ldr	r3, [r0, #0]
 8009b26:	e064      	b.n	8009bf2 <HAL_RCCEx_GetPeriphCLKFreq+0x47a>
#endif /* DFSDM1_Filter0 */

    case RCC_PERIPHCLK_I2C1:
      {
        /* Get the current I2C1 source */
        srcclk = __HAL_RCC_GET_I2C1_SOURCE();
 8009b28:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88

        switch(srcclk)
 8009b2c:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
 8009b30:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 8009b34:	d078      	beq.n	8009c28 <HAL_RCCEx_GetPeriphCLKFreq+0x4b0>
 8009b36:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8009b3a:	d129      	bne.n	8009b90 <HAL_RCCEx_GetPeriphCLKFreq+0x418>
 8009b3c:	e035      	b.n	8009baa <HAL_RCCEx_GetPeriphCLKFreq+0x432>
#if defined(I2C2)

    case RCC_PERIPHCLK_I2C2:
      {
        /* Get the current I2C2 source */
        srcclk = __HAL_RCC_GET_I2C2_SOURCE();
 8009b3e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88

        switch(srcclk)
 8009b42:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8009b46:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8009b4a:	d06d      	beq.n	8009c28 <HAL_RCCEx_GetPeriphCLKFreq+0x4b0>
 8009b4c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8009b50:	e008      	b.n	8009b64 <HAL_RCCEx_GetPeriphCLKFreq+0x3ec>
#endif /* I2C2 */

    case RCC_PERIPHCLK_I2C3:
      {
        /* Get the current I2C3 source */
        srcclk = __HAL_RCC_GET_I2C3_SOURCE();
 8009b52:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88

        switch(srcclk)
 8009b56:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8009b5a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8009b5e:	d063      	beq.n	8009c28 <HAL_RCCEx_GetPeriphCLKFreq+0x4b0>
 8009b60:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8009b64:	d12f      	bne.n	8009bc6 <HAL_RCCEx_GetPeriphCLKFreq+0x44e>
 8009b66:	e009      	b.n	8009b7c <HAL_RCCEx_GetPeriphCLKFreq+0x404>
#if defined(I2C4)

    case RCC_PERIPHCLK_I2C4:
      {
        /* Get the current I2C4 source */
        srcclk = __HAL_RCC_GET_I2C4_SOURCE();
 8009b68:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c

        switch(srcclk)
 8009b6c:	f003 0303 	and.w	r3, r3, #3
 8009b70:	2b01      	cmp	r3, #1
 8009b72:	d059      	beq.n	8009c28 <HAL_RCCEx_GetPeriphCLKFreq+0x4b0>
 8009b74:	d331      	bcc.n	8009bda <HAL_RCCEx_GetPeriphCLKFreq+0x462>
 8009b76:	2b02      	cmp	r3, #2
 8009b78:	f040 8087 	bne.w	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
          break;
        case RCC_I2C4CLKSOURCE_SYSCLK:
          frequency = HAL_RCC_GetSysClockFreq();
          break;
        case RCC_I2C4CLKSOURCE_HSI:
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8009b7c:	4b44      	ldr	r3, [pc, #272]	; (8009c90 <HAL_RCCEx_GetPeriphCLKFreq+0x518>)
 8009b7e:	e014      	b.n	8009baa <HAL_RCCEx_GetPeriphCLKFreq+0x432>
#endif /* I2C4 */

    case RCC_PERIPHCLK_LPTIM1:
      {
        /* Get the current LPTIM1 source */
        srcclk = __HAL_RCC_GET_LPTIM1_SOURCE();
 8009b80:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88

        switch(srcclk)
 8009b84:	f402 2240 	and.w	r2, r2, #786432	; 0xc0000
 8009b88:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
 8009b8c:	d009      	beq.n	8009ba2 <HAL_RCCEx_GetPeriphCLKFreq+0x42a>
 8009b8e:	d801      	bhi.n	8009b94 <HAL_RCCEx_GetPeriphCLKFreq+0x41c>
 8009b90:	b31a      	cbz	r2, 8009bda <HAL_RCCEx_GetPeriphCLKFreq+0x462>
 8009b92:	e07a      	b.n	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 8009b94:	f5b2 2f00 	cmp.w	r2, #524288	; 0x80000
 8009b98:	d007      	beq.n	8009baa <HAL_RCCEx_GetPeriphCLKFreq+0x432>
 8009b9a:	f5b2 2f40 	cmp.w	r2, #786432	; 0xc0000
 8009b9e:	d174      	bne.n	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 8009ba0:	e005      	b.n	8009bae <HAL_RCCEx_GetPeriphCLKFreq+0x436>
        {
        case RCC_LPTIM1CLKSOURCE_PCLK1:
          frequency = HAL_RCC_GetPCLK1Freq();
          break;
        case RCC_LPTIM1CLKSOURCE_LSI:
          if(HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY))
 8009ba2:	4b3b      	ldr	r3, [pc, #236]	; (8009c90 <HAL_RCCEx_GetPeriphCLKFreq+0x518>)
 8009ba4:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8009ba8:	e01b      	b.n	8009be2 <HAL_RCCEx_GetPeriphCLKFreq+0x46a>
              frequency = LSI_VALUE;
            }
          }
          break;
        case RCC_LPTIM1CLKSOURCE_HSI:
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8009baa:	681b      	ldr	r3, [r3, #0]
 8009bac:	e021      	b.n	8009bf2 <HAL_RCCEx_GetPeriphCLKFreq+0x47a>
          {
            frequency = HSI_VALUE;
          }
          break;
        case RCC_LPTIM1CLKSOURCE_LSE:
          if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
 8009bae:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8009bb2:	e026      	b.n	8009c02 <HAL_RCCEx_GetPeriphCLKFreq+0x48a>
      }

    case RCC_PERIPHCLK_LPTIM2:
      {
        /* Get the current LPTIM2 source */
       srcclk = __HAL_RCC_GET_LPTIM2_SOURCE();
 8009bb4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8009bb8:	4a35      	ldr	r2, [pc, #212]	; (8009c90 <HAL_RCCEx_GetPeriphCLKFreq+0x518>)

        switch(srcclk)
 8009bba:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 8009bbe:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8009bc2:	d00c      	beq.n	8009bde <HAL_RCCEx_GetPeriphCLKFreq+0x466>
 8009bc4:	d802      	bhi.n	8009bcc <HAL_RCCEx_GetPeriphCLKFreq+0x454>
 8009bc6:	2b00      	cmp	r3, #0
 8009bc8:	d15f      	bne.n	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 8009bca:	e006      	b.n	8009bda <HAL_RCCEx_GetPeriphCLKFreq+0x462>
 8009bcc:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8009bd0:	d00e      	beq.n	8009bf0 <HAL_RCCEx_GetPeriphCLKFreq+0x478>
 8009bd2:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 8009bd6:	d012      	beq.n	8009bfe <HAL_RCCEx_GetPeriphCLKFreq+0x486>
 8009bd8:	e057      	b.n	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
        {
        case RCC_LPTIM2CLKSOURCE_PCLK1:
          frequency = HAL_RCC_GetPCLK1Freq();
 8009bda:	f7ff b8bf 	b.w	8008d5c <HAL_RCC_GetPCLK1Freq>
          break;
        case RCC_LPTIM2CLKSOURCE_LSI:
          if(HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY))
 8009bde:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
              frequency = LSI_VALUE/128U;
            }
            else
#endif /* RCC_CSR_LSIPREDIV */
            {
              frequency = LSI_VALUE;
 8009be2:	f013 0f02 	tst.w	r3, #2
 8009be6:	bf0c      	ite	eq
 8009be8:	2000      	moveq	r0, #0
 8009bea:	f44f 40fa 	movne.w	r0, #32000	; 0x7d00
 8009bee:	4770      	bx	lr
              frequency = LSI_VALUE;
            }
          }
          break;
        case RCC_LPTIM2CLKSOURCE_HSI:
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8009bf0:	6813      	ldr	r3, [r2, #0]
          frequency = HAL_RCC_GetSysClockFreq();
          break;
        case RCC_USART1CLKSOURCE_HSI:
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
          {
            frequency = HSI_VALUE;
 8009bf2:	4828      	ldr	r0, [pc, #160]	; (8009c94 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
 8009bf4:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8009bf8:	bf08      	it	eq
 8009bfa:	2000      	moveq	r0, #0
 8009bfc:	4770      	bx	lr
          {
            frequency = HSI_VALUE;
          }
          break;
        case RCC_LPTIM2CLKSOURCE_LSE:
          if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
 8009bfe:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
    {
    case RCC_RTCCLKSOURCE_LSE:
      /* Check if LSE is ready */
      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
      {
        frequency = LSE_VALUE;
 8009c02:	f013 0f02 	tst.w	r3, #2
 8009c06:	bf0c      	ite	eq
 8009c08:	2000      	moveq	r0, #0
 8009c0a:	f44f 4000 	movne.w	r0, #32768	; 0x8000
 8009c0e:	4770      	bx	lr
#if defined(OCTOSPI1) || defined(OCTOSPI2)

    case RCC_PERIPHCLK_OSPI:
      {
        /* Get the current OctoSPI clock source */
        srcclk = __HAL_RCC_GET_OSPI_SOURCE();
 8009c10:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c

        switch(srcclk)
 8009c14:	f402 1240 	and.w	r2, r2, #3145728	; 0x300000
 8009c18:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
 8009c1c:	d006      	beq.n	8009c2c <HAL_RCCEx_GetPeriphCLKFreq+0x4b4>
 8009c1e:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
 8009c22:	d017      	beq.n	8009c54 <HAL_RCCEx_GetPeriphCLKFreq+0x4dc>
 8009c24:	2a00      	cmp	r2, #0
 8009c26:	d130      	bne.n	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
        {
        case RCC_OSPICLKSOURCE_SYSCLK:
          frequency = HAL_RCC_GetSysClockFreq();
 8009c28:	f7fe bc88 	b.w	800853c <HAL_RCC_GetSysClockFreq>
          break;
        case RCC_OSPICLKSOURCE_MSI:
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIRDY))
 8009c2c:	4a18      	ldr	r2, [pc, #96]	; (8009c90 <HAL_RCCEx_GetPeriphCLKFreq+0x518>)
 8009c2e:	6812      	ldr	r2, [r2, #0]
 8009c30:	0792      	lsls	r2, r2, #30
 8009c32:	d52a      	bpl.n	8009c8a <HAL_RCCEx_GetPeriphCLKFreq+0x512>
          {
            /*MSI frequency range in HZ*/
            frequency = MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> 4U)];
 8009c34:	4a16      	ldr	r2, [pc, #88]	; (8009c90 <HAL_RCCEx_GetPeriphCLKFreq+0x518>)
 8009c36:	681b      	ldr	r3, [r3, #0]
 8009c38:	071b      	lsls	r3, r3, #28
 8009c3a:	bf4c      	ite	mi
 8009c3c:	6813      	ldrmi	r3, [r2, #0]
 8009c3e:	f8d2 3094 	ldrpl.w	r3, [r2, #148]	; 0x94
 8009c42:	4a15      	ldr	r2, [pc, #84]	; (8009c98 <HAL_RCCEx_GetPeriphCLKFreq+0x520>)
 8009c44:	bf4c      	ite	mi
 8009c46:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
 8009c4a:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 8009c4e:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 8009c52:	4770      	bx	lr
          }
          break;
        case RCC_OSPICLKSOURCE_PLL:
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY))
 8009c54:	681b      	ldr	r3, [r3, #0]
 8009c56:	4a0e      	ldr	r2, [pc, #56]	; (8009c90 <HAL_RCCEx_GetPeriphCLKFreq+0x518>)
 8009c58:	f013 7000 	ands.w	r0, r3, #33554432	; 0x2000000
 8009c5c:	d016      	beq.n	8009c8c <HAL_RCCEx_GetPeriphCLKFreq+0x514>
          {
            if(HAL_IS_BIT_SET(RCC->PLLCFGR, RCC_PLLCFGR_PLLQEN))
 8009c5e:	68d3      	ldr	r3, [r2, #12]
 8009c60:	f413 1080 	ands.w	r0, r3, #1048576	; 0x100000
 8009c64:	d012      	beq.n	8009c8c <HAL_RCCEx_GetPeriphCLKFreq+0x514>
            {
              /* f(PLL Source) * PLLN / PLLM */
              plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
 8009c66:	68d0      	ldr	r0, [r2, #12]
              pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 8009c68:	f3c0 2006 	ubfx	r0, r0, #8, #7
 8009c6c:	4341      	muls	r1, r0
 8009c6e:	68d0      	ldr	r0, [r2, #12]
              /* f(PLL48M1CLK) = f(VCO input) / PLLQ */
              frequency = (pllvco / (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U));
 8009c70:	68d3      	ldr	r3, [r2, #12]
 8009c72:	f3c3 5341 	ubfx	r3, r3, #21, #2
 8009c76:	f3c0 1003 	ubfx	r0, r0, #4, #4
 8009c7a:	3301      	adds	r3, #1
 8009c7c:	005b      	lsls	r3, r3, #1
 8009c7e:	3001      	adds	r0, #1
 8009c80:	fbb1 f0f0 	udiv	r0, r1, r0
 8009c84:	fbb0 f0f3 	udiv	r0, r0, r3
 8009c88:	4770      	bx	lr
  @endif
  * @retval Frequency in Hz
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
  uint32_t frequency = 0U;
 8009c8a:	2000      	movs	r0, #0
      break;
    }
  }

  return(frequency);
}
 8009c8c:	4770      	bx	lr
 8009c8e:	bf00      	nop
 8009c90:	40021000 	.word	0x40021000
 8009c94:	00f42400 	.word	0x00f42400
 8009c98:	0800e740 	.word	0x0800e740

08009c9c <HAL_RCCEx_EnablePLLSAI1>:
  * @param  PLLSAI1Init  pointer to an RCC_PLLSAI1InitTypeDef structure that
  *         contains the configuration information for the PLLSAI1
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_EnablePLLSAI1(RCC_PLLSAI1InitTypeDef  *PLLSAI1Init)
{
 8009c9c:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_RCC_PLLSAI1Q_VALUE(PLLSAI1Init->PLLSAI1Q));
  assert_param(IS_RCC_PLLSAI1R_VALUE(PLLSAI1Init->PLLSAI1R));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PLLSAI1Init->PLLSAI1ClockOut));

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
 8009c9e:	4c21      	ldr	r4, [pc, #132]	; (8009d24 <HAL_RCCEx_EnablePLLSAI1+0x88>)
 8009ca0:	6823      	ldr	r3, [r4, #0]
 8009ca2:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8009ca6:	6023      	str	r3, [r4, #0]
  * @param  PLLSAI1Init  pointer to an RCC_PLLSAI1InitTypeDef structure that
  *         contains the configuration information for the PLLSAI1
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_EnablePLLSAI1(RCC_PLLSAI1InitTypeDef  *PLLSAI1Init)
{
 8009ca8:	4605      	mov	r5, r0

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8009caa:	f7fd f9b3 	bl	8007014 <HAL_GetTick>
 8009cae:	4606      	mov	r6, r0

  /* Wait till PLLSAI1 is ready to be updated */
  while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 8009cb0:	6823      	ldr	r3, [r4, #0]
 8009cb2:	481c      	ldr	r0, [pc, #112]	; (8009d24 <HAL_RCCEx_EnablePLLSAI1+0x88>)
 8009cb4:	011a      	lsls	r2, r3, #4
 8009cb6:	d506      	bpl.n	8009cc6 <HAL_RCCEx_EnablePLLSAI1+0x2a>
  {
    if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8009cb8:	f7fd f9ac 	bl	8007014 <HAL_GetTick>
 8009cbc:	1b80      	subs	r0, r0, r6
 8009cbe:	2802      	cmp	r0, #2
 8009cc0:	d9f6      	bls.n	8009cb0 <HAL_RCCEx_EnablePLLSAI1+0x14>
    {
      status = HAL_TIMEOUT;
 8009cc2:	2003      	movs	r0, #3
 8009cc4:	bd70      	pop	{r4, r5, r6, pc}
  if(status == HAL_OK)
  {
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
    /* Configure the PLLSAI1 Multiplication factor N */
    /* Configure the PLLSAI1 Division factors M, P, Q and R */
    __HAL_RCC_PLLSAI1_CONFIG(PLLSAI1Init->PLLSAI1M, PLLSAI1Init->PLLSAI1N, PLLSAI1Init->PLLSAI1P, PLLSAI1Init->PLLSAI1Q, PLLSAI1Init->PLLSAI1R);
 8009cc6:	6902      	ldr	r2, [r0, #16]
 8009cc8:	4b17      	ldr	r3, [pc, #92]	; (8009d28 <HAL_RCCEx_EnablePLLSAI1+0x8c>)
 8009cca:	68a9      	ldr	r1, [r5, #8]
 8009ccc:	4013      	ands	r3, r2
 8009cce:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8009cd2:	686a      	ldr	r2, [r5, #4]
 8009cd4:	68e9      	ldr	r1, [r5, #12]
 8009cd6:	3a01      	subs	r2, #1
 8009cd8:	ea43 63c1 	orr.w	r3, r3, r1, lsl #27
 8009cdc:	ea43 1102 	orr.w	r1, r3, r2, lsl #4
 8009ce0:	692b      	ldr	r3, [r5, #16]
 8009ce2:	085b      	lsrs	r3, r3, #1
 8009ce4:	3b01      	subs	r3, #1
 8009ce6:	ea41 5243 	orr.w	r2, r1, r3, lsl #21
 8009cea:	696b      	ldr	r3, [r5, #20]
 8009cec:	085b      	lsrs	r3, r3, #1
 8009cee:	3b01      	subs	r3, #1
 8009cf0:	ea42 6343 	orr.w	r3, r2, r3, lsl #25
 8009cf4:	6103      	str	r3, [r0, #16]
    /* Configure the PLLSAI1 Multiplication factor N */
    /* Configure the PLLSAI1 Division factors P, Q and R */
    __HAL_RCC_PLLSAI1_CONFIG(PLLSAI1Init->PLLSAI1N, PLLSAI1Init->PLLSAI1P, PLLSAI1Init->PLLSAI1Q, PLLSAI1Init->PLLSAI1R);
#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
    /* Configure the PLLSAI1 Clock output(s) */
    __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1Init->PLLSAI1ClockOut);
 8009cf6:	6902      	ldr	r2, [r0, #16]
 8009cf8:	69ab      	ldr	r3, [r5, #24]
 8009cfa:	4313      	orrs	r3, r2
 8009cfc:	6103      	str	r3, [r0, #16]

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();
 8009cfe:	6803      	ldr	r3, [r0, #0]
 8009d00:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8009d04:	6003      	str	r3, [r0, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8009d06:	f7fd f985 	bl	8007014 <HAL_GetTick>
 8009d0a:	4605      	mov	r5, r0

    /* Wait till PLLSAI1 is ready */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 8009d0c:	6823      	ldr	r3, [r4, #0]
 8009d0e:	011b      	lsls	r3, r3, #4
 8009d10:	d405      	bmi.n	8009d1e <HAL_RCCEx_EnablePLLSAI1+0x82>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8009d12:	f7fd f97f 	bl	8007014 <HAL_GetTick>
 8009d16:	1b40      	subs	r0, r0, r5
 8009d18:	2802      	cmp	r0, #2
 8009d1a:	d9f7      	bls.n	8009d0c <HAL_RCCEx_EnablePLLSAI1+0x70>
 8009d1c:	e7d1      	b.n	8009cc2 <HAL_RCCEx_EnablePLLSAI1+0x26>
 8009d1e:	2000      	movs	r0, #0
        break;
      }
    }
  }

  return status;
 8009d20:	bd70      	pop	{r4, r5, r6, pc}
 8009d22:	bf00      	nop
 8009d24:	40021000 	.word	0x40021000
 8009d28:	019d800f 	.word	0x019d800f

08009d2c <HAL_RCCEx_DisablePLLSAI1>:
/**
  * @brief  Disable PLLSAI1.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_DisablePLLSAI1(void)
{
 8009d2c:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
 8009d2e:	4c11      	ldr	r4, [pc, #68]	; (8009d74 <HAL_RCCEx_DisablePLLSAI1+0x48>)
 8009d30:	6823      	ldr	r3, [r4, #0]
 8009d32:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8009d36:	6023      	str	r3, [r4, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8009d38:	f7fd f96c 	bl	8007014 <HAL_GetTick>
 8009d3c:	4605      	mov	r5, r0

  /* Wait till PLLSAI1 is ready */
  while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 8009d3e:	6820      	ldr	r0, [r4, #0]
 8009d40:	f010 6000 	ands.w	r0, r0, #134217728	; 0x8000000
 8009d44:	d005      	beq.n	8009d52 <HAL_RCCEx_DisablePLLSAI1+0x26>
  {
    if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8009d46:	f7fd f965 	bl	8007014 <HAL_GetTick>
 8009d4a:	1b40      	subs	r0, r0, r5
 8009d4c:	2802      	cmp	r0, #2
 8009d4e:	d9f6      	bls.n	8009d3e <HAL_RCCEx_DisablePLLSAI1+0x12>
    {
      status = HAL_TIMEOUT;
 8009d50:	2003      	movs	r0, #3
      break;
    }
  }

  /* Disable the PLLSAI1 Clock outputs */
  __HAL_RCC_PLLSAI1CLKOUT_DISABLE(RCC_PLLSAI1CFGR_PLLSAI1PEN|RCC_PLLSAI1CFGR_PLLSAI1QEN|RCC_PLLSAI1CFGR_PLLSAI1REN);
 8009d52:	6923      	ldr	r3, [r4, #16]
 8009d54:	4a07      	ldr	r2, [pc, #28]	; (8009d74 <HAL_RCCEx_DisablePLLSAI1+0x48>)
 8009d56:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 8009d5a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8009d5e:	6123      	str	r3, [r4, #16]

  /* Reset PLL source to save power if no PLLs on */
#if defined(RCC_PLLSAI2_SUPPORT)
  if(READ_BIT(RCC->CR, (RCC_CR_PLLRDY | RCC_CR_PLLSAI2RDY)) == 0U)
 8009d60:	6823      	ldr	r3, [r4, #0]
 8009d62:	f013 5f08 	tst.w	r3, #570425344	; 0x22000000
  {
    MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 8009d66:	bf02      	ittt	eq
 8009d68:	68d3      	ldreq	r3, [r2, #12]
 8009d6a:	f023 0303 	biceq.w	r3, r3, #3
 8009d6e:	60d3      	streq	r3, [r2, #12]
    MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
  }
#endif /* RCC_PLLSAI2_SUPPORT */

  return status;
}
 8009d70:	bd38      	pop	{r3, r4, r5, pc}
 8009d72:	bf00      	nop
 8009d74:	40021000 	.word	0x40021000

08009d78 <HAL_RCCEx_EnablePLLSAI2>:
  * @param  PLLSAI2Init  pointer to an RCC_PLLSAI2InitTypeDef structure that
  *         contains the configuration information for the PLLSAI2
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_EnablePLLSAI2(RCC_PLLSAI2InitTypeDef  *PLLSAI2Init)
{
 8009d78:	b570      	push	{r4, r5, r6, lr}
#endif /* RCC_PLLSAI2Q_DIV_SUPPORT */
  assert_param(IS_RCC_PLLSAI2R_VALUE(PLLSAI2Init->PLLSAI2R));
  assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PLLSAI2Init->PLLSAI2ClockOut));

  /* Disable the PLLSAI2 */
  __HAL_RCC_PLLSAI2_DISABLE();
 8009d7a:	4c21      	ldr	r4, [pc, #132]	; (8009e00 <HAL_RCCEx_EnablePLLSAI2+0x88>)
 8009d7c:	6823      	ldr	r3, [r4, #0]
 8009d7e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8009d82:	6023      	str	r3, [r4, #0]
  * @param  PLLSAI2Init  pointer to an RCC_PLLSAI2InitTypeDef structure that
  *         contains the configuration information for the PLLSAI2
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_EnablePLLSAI2(RCC_PLLSAI2InitTypeDef  *PLLSAI2Init)
{
 8009d84:	4605      	mov	r5, r0

  /* Disable the PLLSAI2 */
  __HAL_RCC_PLLSAI2_DISABLE();

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8009d86:	f7fd f945 	bl	8007014 <HAL_GetTick>
 8009d8a:	4606      	mov	r6, r0

  /* Wait till PLLSAI2 is ready to be updated */
  while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 8009d8c:	6823      	ldr	r3, [r4, #0]
 8009d8e:	481c      	ldr	r0, [pc, #112]	; (8009e00 <HAL_RCCEx_EnablePLLSAI2+0x88>)
 8009d90:	009a      	lsls	r2, r3, #2
 8009d92:	d506      	bpl.n	8009da2 <HAL_RCCEx_EnablePLLSAI2+0x2a>
  {
    if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8009d94:	f7fd f93e 	bl	8007014 <HAL_GetTick>
 8009d98:	1b80      	subs	r0, r0, r6
 8009d9a:	2802      	cmp	r0, #2
 8009d9c:	d9f6      	bls.n	8009d8c <HAL_RCCEx_EnablePLLSAI2+0x14>
    {
      status = HAL_TIMEOUT;
 8009d9e:	2003      	movs	r0, #3
 8009da0:	bd70      	pop	{r4, r5, r6, pc}
  if(status == HAL_OK)
  {
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT) && defined(RCC_PLLSAI2Q_DIV_SUPPORT)
    /* Configure the PLLSAI2 Multiplication factor N */
    /* Configure the PLLSAI2 Division factors M, P, Q and R */
    __HAL_RCC_PLLSAI2_CONFIG(PLLSAI2Init->PLLSAI2M, PLLSAI2Init->PLLSAI2N, PLLSAI2Init->PLLSAI2P, PLLSAI2Init->PLLSAI2Q, PLLSAI2Init->PLLSAI2R);
 8009da2:	6942      	ldr	r2, [r0, #20]
 8009da4:	4b17      	ldr	r3, [pc, #92]	; (8009e04 <HAL_RCCEx_EnablePLLSAI2+0x8c>)
 8009da6:	68a9      	ldr	r1, [r5, #8]
 8009da8:	4013      	ands	r3, r2
 8009daa:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8009dae:	686a      	ldr	r2, [r5, #4]
 8009db0:	68e9      	ldr	r1, [r5, #12]
 8009db2:	3a01      	subs	r2, #1
 8009db4:	ea43 63c1 	orr.w	r3, r3, r1, lsl #27
 8009db8:	ea43 1102 	orr.w	r1, r3, r2, lsl #4
 8009dbc:	692b      	ldr	r3, [r5, #16]
 8009dbe:	085b      	lsrs	r3, r3, #1
 8009dc0:	3b01      	subs	r3, #1
 8009dc2:	ea41 5243 	orr.w	r2, r1, r3, lsl #21
 8009dc6:	696b      	ldr	r3, [r5, #20]
 8009dc8:	085b      	lsrs	r3, r3, #1
 8009dca:	3b01      	subs	r3, #1
 8009dcc:	ea42 6343 	orr.w	r3, r2, r3, lsl #25
 8009dd0:	6143      	str	r3, [r0, #20]
    /* Configure the PLLSAI2 Multiplication factor N */
    /* Configure the PLLSAI2 Division factors P and R */
    __HAL_RCC_PLLSAI2_CONFIG(PLLSAI2Init->PLLSAI2N, PLLSAI2Init->PLLSAI2P, PLLSAI2Init->PLLSAI2R);
#endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT && RCC_PLLSAI2Q_DIV_SUPPORT */
    /* Configure the PLLSAI2 Clock output(s) */
    __HAL_RCC_PLLSAI2CLKOUT_ENABLE(PLLSAI2Init->PLLSAI2ClockOut);
 8009dd2:	6942      	ldr	r2, [r0, #20]
 8009dd4:	69ab      	ldr	r3, [r5, #24]
 8009dd6:	4313      	orrs	r3, r2
 8009dd8:	6143      	str	r3, [r0, #20]

    /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
    __HAL_RCC_PLLSAI2_ENABLE();
 8009dda:	6803      	ldr	r3, [r0, #0]
 8009ddc:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8009de0:	6003      	str	r3, [r0, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8009de2:	f7fd f917 	bl	8007014 <HAL_GetTick>
 8009de6:	4605      	mov	r5, r0

    /* Wait till PLLSAI2 is ready */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
 8009de8:	6823      	ldr	r3, [r4, #0]
 8009dea:	009b      	lsls	r3, r3, #2
 8009dec:	d405      	bmi.n	8009dfa <HAL_RCCEx_EnablePLLSAI2+0x82>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8009dee:	f7fd f911 	bl	8007014 <HAL_GetTick>
 8009df2:	1b40      	subs	r0, r0, r5
 8009df4:	2802      	cmp	r0, #2
 8009df6:	d9f7      	bls.n	8009de8 <HAL_RCCEx_EnablePLLSAI2+0x70>
 8009df8:	e7d1      	b.n	8009d9e <HAL_RCCEx_EnablePLLSAI2+0x26>
 8009dfa:	2000      	movs	r0, #0
        break;
      }
    }
  }

  return status;
 8009dfc:	bd70      	pop	{r4, r5, r6, pc}
 8009dfe:	bf00      	nop
 8009e00:	40021000 	.word	0x40021000
 8009e04:	019d800f 	.word	0x019d800f

08009e08 <HAL_RCCEx_DisablePLLSAI2>:
/**
  * @brief  Disable PLLISAI2.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_DisablePLLSAI2(void)
{
 8009e08:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  /* Disable the PLLSAI2 */
  __HAL_RCC_PLLSAI2_DISABLE();
 8009e0a:	4c11      	ldr	r4, [pc, #68]	; (8009e50 <HAL_RCCEx_DisablePLLSAI2+0x48>)
 8009e0c:	6823      	ldr	r3, [r4, #0]
 8009e0e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8009e12:	6023      	str	r3, [r4, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8009e14:	f7fd f8fe 	bl	8007014 <HAL_GetTick>
 8009e18:	4605      	mov	r5, r0

  /* Wait till PLLSAI2 is ready */
  while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 8009e1a:	6820      	ldr	r0, [r4, #0]
 8009e1c:	f010 5000 	ands.w	r0, r0, #536870912	; 0x20000000
 8009e20:	d005      	beq.n	8009e2e <HAL_RCCEx_DisablePLLSAI2+0x26>
  {
    if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8009e22:	f7fd f8f7 	bl	8007014 <HAL_GetTick>
 8009e26:	1b40      	subs	r0, r0, r5
 8009e28:	2802      	cmp	r0, #2
 8009e2a:	d9f6      	bls.n	8009e1a <HAL_RCCEx_DisablePLLSAI2+0x12>
    {
      status = HAL_TIMEOUT;
 8009e2c:	2003      	movs	r0, #3
    }
  }

  /* Disable the PLLSAI2 Clock outputs */
#if defined(RCC_PLLSAI2Q_DIV_SUPPORT)
  __HAL_RCC_PLLSAI2CLKOUT_DISABLE(RCC_PLLSAI2CFGR_PLLSAI2PEN|RCC_PLLSAI2CFGR_PLLSAI2QEN|RCC_PLLSAI2CFGR_PLLSAI2REN);
 8009e2e:	6963      	ldr	r3, [r4, #20]
 8009e30:	4a07      	ldr	r2, [pc, #28]	; (8009e50 <HAL_RCCEx_DisablePLLSAI2+0x48>)
 8009e32:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 8009e36:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8009e3a:	6163      	str	r3, [r4, #20]
#else
  __HAL_RCC_PLLSAI2CLKOUT_DISABLE(RCC_PLLSAI2CFGR_PLLSAI2PEN|RCC_PLLSAI2CFGR_PLLSAI2REN);
#endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT && RCC_PLLSAI2Q_DIV_SUPPORT */

  /* Reset PLL source to save power if no PLLs on */
  if(READ_BIT(RCC->CR, (RCC_CR_PLLRDY | RCC_CR_PLLSAI1RDY)) == 0U)
 8009e3c:	6823      	ldr	r3, [r4, #0]
 8009e3e:	f013 6f20 	tst.w	r3, #167772160	; 0xa000000
  {
    MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 8009e42:	bf02      	ittt	eq
 8009e44:	68d3      	ldreq	r3, [r2, #12]
 8009e46:	f023 0303 	biceq.w	r3, r3, #3
 8009e4a:	60d3      	streq	r3, [r2, #12]
  }

  return status;
}
 8009e4c:	bd38      	pop	{r3, r4, r5, pc}
 8009e4e:	bf00      	nop
 8009e50:	40021000 	.word	0x40021000

08009e54 <HAL_RCCEx_WakeUpStopCLKConfig>:
  */
void HAL_RCCEx_WakeUpStopCLKConfig(uint32_t WakeUpClk)
{
  assert_param(IS_RCC_STOP_WAKEUPCLOCK(WakeUpClk));

  __HAL_RCC_WAKEUPSTOP_CLK_CONFIG(WakeUpClk);
 8009e54:	4a03      	ldr	r2, [pc, #12]	; (8009e64 <HAL_RCCEx_WakeUpStopCLKConfig+0x10>)
 8009e56:	6893      	ldr	r3, [r2, #8]
 8009e58:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8009e5c:	4318      	orrs	r0, r3
 8009e5e:	6090      	str	r0, [r2, #8]
 8009e60:	4770      	bx	lr
 8009e62:	bf00      	nop
 8009e64:	40021000 	.word	0x40021000

08009e68 <HAL_RCCEx_StandbyMSIRangeConfig>:
  */
void HAL_RCCEx_StandbyMSIRangeConfig(uint32_t MSIRange)
{
  assert_param(IS_RCC_MSI_STANDBY_CLOCK_RANGE(MSIRange));

  __HAL_RCC_MSI_STANDBY_RANGE_CONFIG(MSIRange);
 8009e68:	4a04      	ldr	r2, [pc, #16]	; (8009e7c <HAL_RCCEx_StandbyMSIRangeConfig+0x14>)
 8009e6a:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 8009e6e:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 8009e72:	ea43 1000 	orr.w	r0, r3, r0, lsl #4
 8009e76:	f8c2 0094 	str.w	r0, [r2, #148]	; 0x94
 8009e7a:	4770      	bx	lr
 8009e7c:	40021000 	.word	0x40021000

08009e80 <HAL_RCCEx_EnableLSECSS>:
  *         clock with HAL_RCCEx_PeriphCLKConfig().
  * @retval None
  */
void HAL_RCCEx_EnableLSECSS(void)
{
  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON);
 8009e80:	4a03      	ldr	r2, [pc, #12]	; (8009e90 <HAL_RCCEx_EnableLSECSS+0x10>)
 8009e82:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8009e86:	f043 0320 	orr.w	r3, r3, #32
 8009e8a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8009e8e:	4770      	bx	lr
 8009e90:	40021000 	.word	0x40021000

08009e94 <HAL_RCCEx_DisableLSECSS>:
  * @note   LSE Clock Security System can only be disabled after a LSE failure detection.
  * @retval None
  */
void HAL_RCCEx_DisableLSECSS(void)
{
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
 8009e94:	4b05      	ldr	r3, [pc, #20]	; (8009eac <HAL_RCCEx_DisableLSECSS+0x18>)
 8009e96:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8009e9a:	f022 0220 	bic.w	r2, r2, #32
 8009e9e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

  /* Disable LSE CSS IT if any */
  __HAL_RCC_DISABLE_IT(RCC_IT_LSECSS);
 8009ea2:	699a      	ldr	r2, [r3, #24]
 8009ea4:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8009ea8:	619a      	str	r2, [r3, #24]
 8009eaa:	4770      	bx	lr
 8009eac:	40021000 	.word	0x40021000

08009eb0 <HAL_RCCEx_EnableLSECSS_IT>:
  * @retval None
  */
void HAL_RCCEx_EnableLSECSS_IT(void)
{
  /* Enable LSE CSS */
  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
 8009eb0:	4b0a      	ldr	r3, [pc, #40]	; (8009edc <HAL_RCCEx_EnableLSECSS_IT+0x2c>)
 8009eb2:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8009eb6:	f042 0220 	orr.w	r2, r2, #32
 8009eba:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

  /* Enable LSE CSS IT */
  __HAL_RCC_ENABLE_IT(RCC_IT_LSECSS);
 8009ebe:	699a      	ldr	r2, [r3, #24]
 8009ec0:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8009ec4:	619a      	str	r2, [r3, #24]

  /* Enable IT on EXTI Line 19 */
  __HAL_RCC_LSECSS_EXTI_ENABLE_IT();
 8009ec6:	f5a3 3386 	sub.w	r3, r3, #68608	; 0x10c00
 8009eca:	681a      	ldr	r2, [r3, #0]
 8009ecc:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8009ed0:	601a      	str	r2, [r3, #0]
  __HAL_RCC_LSECSS_EXTI_ENABLE_RISING_EDGE();
 8009ed2:	689a      	ldr	r2, [r3, #8]
 8009ed4:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8009ed8:	609a      	str	r2, [r3, #8]
 8009eda:	4770      	bx	lr
 8009edc:	40021000 	.word	0x40021000

08009ee0 <HAL_RCCEx_LSECSS_Callback>:
 8009ee0:	4770      	bx	lr
	...

08009ee4 <HAL_RCCEx_LSECSS_IRQHandler>:
/**
  * @brief Handle the RCC LSE Clock Security System interrupt request.
  * @retval None
  */
void HAL_RCCEx_LSECSS_IRQHandler(void)
{
 8009ee4:	b510      	push	{r4, lr}
  /* Check RCC LSE CSSF flag  */
  if(__HAL_RCC_GET_IT(RCC_IT_LSECSS))
 8009ee6:	4c05      	ldr	r4, [pc, #20]	; (8009efc <HAL_RCCEx_LSECSS_IRQHandler+0x18>)
 8009ee8:	69e3      	ldr	r3, [r4, #28]
 8009eea:	059b      	lsls	r3, r3, #22
 8009eec:	d504      	bpl.n	8009ef8 <HAL_RCCEx_LSECSS_IRQHandler+0x14>
  {
    /* RCC LSE Clock Security System interrupt user callback */
    HAL_RCCEx_LSECSS_Callback();
 8009eee:	f7ff fff7 	bl	8009ee0 <HAL_RCCEx_LSECSS_Callback>

    /* Clear RCC LSE CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_LSECSS);
 8009ef2:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009ef6:	6223      	str	r3, [r4, #32]
 8009ef8:	bd10      	pop	{r4, pc}
 8009efa:	bf00      	nop
 8009efc:	40021000 	.word	0x40021000

08009f00 <HAL_RCCEx_EnableMSIPLLMode>:
  *         calibration LSE oscillator is to be enabled with HAL_RCC_OscConfig().
  * @retval None
  */
void HAL_RCCEx_EnableMSIPLLMode(void)
{
  SET_BIT(RCC->CR, RCC_CR_MSIPLLEN) ;
 8009f00:	4a02      	ldr	r2, [pc, #8]	; (8009f0c <HAL_RCCEx_EnableMSIPLLMode+0xc>)
 8009f02:	6813      	ldr	r3, [r2, #0]
 8009f04:	f043 0304 	orr.w	r3, r3, #4
 8009f08:	6013      	str	r3, [r2, #0]
 8009f0a:	4770      	bx	lr
 8009f0c:	40021000 	.word	0x40021000

08009f10 <HAL_RCCEx_DisableMSIPLLMode>:
  * @note   PLL-mode of the MSI is automatically reset when LSE oscillator is disabled.
  * @retval None
  */
void HAL_RCCEx_DisableMSIPLLMode(void)
{
  CLEAR_BIT(RCC->CR, RCC_CR_MSIPLLEN) ;
 8009f10:	4a02      	ldr	r2, [pc, #8]	; (8009f1c <HAL_RCCEx_DisableMSIPLLMode+0xc>)
 8009f12:	6813      	ldr	r3, [r2, #0]
 8009f14:	f023 0304 	bic.w	r3, r3, #4
 8009f18:	6013      	str	r3, [r2, #0]
 8009f1a:	4770      	bx	lr
 8009f1c:	40021000 	.word	0x40021000

08009f20 <HAL_RCCEx_OCTOSPIDelayConfig>:
void HAL_RCCEx_OCTOSPIDelayConfig(uint32_t Delay1, uint32_t Delay2)
{
  assert_param(IS_RCC_OCTOSPIDELAY(Delay1));
  assert_param(IS_RCC_OCTOSPIDELAY(Delay2));

  MODIFY_REG(RCC->DLYCFGR, RCC_DLYCFGR_OCTOSPI1_DLY|RCC_DLYCFGR_OCTOSPI2_DLY, (Delay1 | (Delay2 << RCC_DLYCFGR_OCTOSPI2_DLY_Pos))) ;
 8009f20:	4a05      	ldr	r2, [pc, #20]	; (8009f38 <HAL_RCCEx_OCTOSPIDelayConfig+0x18>)
 8009f22:	f8d2 30a4 	ldr.w	r3, [r2, #164]	; 0xa4
 8009f26:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 8009f2a:	4318      	orrs	r0, r3
 8009f2c:	ea40 1101 	orr.w	r1, r0, r1, lsl #4
 8009f30:	f8c2 10a4 	str.w	r1, [r2, #164]	; 0xa4
 8009f34:	4770      	bx	lr
 8009f36:	bf00      	nop
 8009f38:	40021000 	.word	0x40021000

08009f3c <HAL_RCCEx_CRSConfig>:
  assert_param(IS_RCC_CRS_HSI48CALIBRATION(pInit->HSI48CalibrationValue));

  /* CONFIGURATION */

  /* Before configuration, reset CRS registers to their default values*/
  __HAL_RCC_CRS_FORCE_RESET();
 8009f3c:	4b10      	ldr	r3, [pc, #64]	; (8009f80 <HAL_RCCEx_CRSConfig+0x44>)
 8009f3e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8009f40:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8009f44:	639a      	str	r2, [r3, #56]	; 0x38
  __HAL_RCC_CRS_RELEASE_RESET();
 8009f46:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8009f48:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8009f4c:	639a      	str	r2, [r3, #56]	; 0x38

  /* Set the SYNCDIV[2:0] bits according to Prescaler value */
  /* Set the SYNCSRC[1:0] bits according to Source value */
  /* Set the SYNCSPOL bit according to Polarity value */
  value = (pInit->Prescaler | pInit->Source | pInit->Polarity);
 8009f4e:	e890 000c 	ldmia.w	r0, {r2, r3}
 8009f52:	431a      	orrs	r2, r3
 8009f54:	6883      	ldr	r3, [r0, #8]
 8009f56:	431a      	orrs	r2, r3
  /* Set the RELOAD[15:0] bits according to ReloadValue value */
  value |= pInit->ReloadValue;
 8009f58:	68c3      	ldr	r3, [r0, #12]
 8009f5a:	4313      	orrs	r3, r2
  /* Set the FELIM[7:0] bits according to ErrorLimitValue value */
  value |= (pInit->ErrorLimitValue << CRS_CFGR_FELIM_Pos);
 8009f5c:	6902      	ldr	r2, [r0, #16]
 8009f5e:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
  WRITE_REG(CRS->CFGR, value);
 8009f62:	4b08      	ldr	r3, [pc, #32]	; (8009f84 <HAL_RCCEx_CRSConfig+0x48>)
 8009f64:	605a      	str	r2, [r3, #4]

  /* Adjust HSI48 oscillator smooth trimming */
  /* Set the TRIM[6:0] bits for STM32L412xx/L422xx or TRIM[5:0] bits otherwise
     according to RCC_CRS_HSI48CalibrationValue value */
  MODIFY_REG(CRS->CR, CRS_CR_TRIM, (pInit->HSI48CalibrationValue << CRS_CR_TRIM_Pos));
 8009f66:	681a      	ldr	r2, [r3, #0]
 8009f68:	6941      	ldr	r1, [r0, #20]
 8009f6a:	f422 527c 	bic.w	r2, r2, #16128	; 0x3f00
 8009f6e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8009f72:	601a      	str	r2, [r3, #0]

  /* START AUTOMATIC SYNCHRONIZATION*/

  /* Enable Automatic trimming & Frequency error counter */
  SET_BIT(CRS->CR, CRS_CR_AUTOTRIMEN | CRS_CR_CEN);
 8009f74:	681a      	ldr	r2, [r3, #0]
 8009f76:	f042 0260 	orr.w	r2, r2, #96	; 0x60
 8009f7a:	601a      	str	r2, [r3, #0]
 8009f7c:	4770      	bx	lr
 8009f7e:	bf00      	nop
 8009f80:	40021000 	.word	0x40021000
 8009f84:	40006000 	.word	0x40006000

08009f88 <HAL_RCCEx_CRSSoftwareSynchronizationGenerate>:
  * @brief  Generate the software synchronization event
  * @retval None
  */
void HAL_RCCEx_CRSSoftwareSynchronizationGenerate(void)
{
  SET_BIT(CRS->CR, CRS_CR_SWSYNC);
 8009f88:	4a02      	ldr	r2, [pc, #8]	; (8009f94 <HAL_RCCEx_CRSSoftwareSynchronizationGenerate+0xc>)
 8009f8a:	6813      	ldr	r3, [r2, #0]
 8009f8c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8009f90:	6013      	str	r3, [r2, #0]
 8009f92:	4770      	bx	lr
 8009f94:	40006000 	.word	0x40006000

08009f98 <HAL_RCCEx_CRSGetSynchronizationInfo>:
{
  /* Check the parameter */
  assert_param(pSynchroInfo != (void *)NULL);

  /* Get the reload value */
  pSynchroInfo->ReloadValue = (READ_BIT(CRS->CFGR, CRS_CFGR_RELOAD));
 8009f98:	4b07      	ldr	r3, [pc, #28]	; (8009fb8 <HAL_RCCEx_CRSGetSynchronizationInfo+0x20>)
 8009f9a:	685a      	ldr	r2, [r3, #4]
 8009f9c:	b292      	uxth	r2, r2
 8009f9e:	6002      	str	r2, [r0, #0]

  /* Get HSI48 oscillator smooth trimming */
  pSynchroInfo->HSI48CalibrationValue = (READ_BIT(CRS->CR, CRS_CR_TRIM) >> CRS_CR_TRIM_Pos);
 8009fa0:	681a      	ldr	r2, [r3, #0]
 8009fa2:	f3c2 2205 	ubfx	r2, r2, #8, #6
 8009fa6:	6042      	str	r2, [r0, #4]

  /* Get Frequency error capture */
  pSynchroInfo->FreqErrorCapture = (READ_BIT(CRS->ISR, CRS_ISR_FECAP) >> CRS_ISR_FECAP_Pos);
 8009fa8:	689a      	ldr	r2, [r3, #8]
 8009faa:	0c12      	lsrs	r2, r2, #16
 8009fac:	6082      	str	r2, [r0, #8]

  /* Get Frequency error direction */
  pSynchroInfo->FreqErrorDirection = (READ_BIT(CRS->ISR, CRS_ISR_FEDIR));
 8009fae:	689b      	ldr	r3, [r3, #8]
 8009fb0:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8009fb4:	60c3      	str	r3, [r0, #12]
 8009fb6:	4770      	bx	lr
 8009fb8:	40006000 	.word	0x40006000

08009fbc <HAL_RCCEx_CRSWaitSynchronization>:
*            @arg @ref RCC_CRS_SYNCERR
*            @arg @ref RCC_CRS_SYNCMISS
*            @arg @ref RCC_CRS_TRIMOVF
*/
uint32_t HAL_RCCEx_CRSWaitSynchronization(uint32_t Timeout)
{
 8009fbc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009fc0:	4605      	mov	r5, r0
  uint32_t crsstatus = RCC_CRS_NONE;
  uint32_t tickstart;

  /* Get timeout */
  tickstart = HAL_GetTick();
 8009fc2:	f7fd f827 	bl	8007014 <HAL_GetTick>
      {
        crsstatus = RCC_CRS_TIMEOUT;
      }
    }
    /* Check CRS SYNCOK flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCOK))
 8009fc6:	4c21      	ldr	r4, [pc, #132]	; (800a04c <HAL_RCCEx_CRSWaitSynchronization+0x90>)
{
  uint32_t crsstatus = RCC_CRS_NONE;
  uint32_t tickstart;

  /* Get timeout */
  tickstart = HAL_GetTick();
 8009fc8:	4607      	mov	r7, r0
 8009fca:	4626      	mov	r6, r4
    {
      /* CRS SYNC event OK */
      crsstatus |= RCC_CRS_SYNCOK;

      /* Clear CRS SYNC event OK bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCOK);
 8009fcc:	f04f 0801 	mov.w	r8, #1
  tickstart = HAL_GetTick();

  /* Wait for CRS flag or timeout detection */
  do
  {
    if(Timeout != HAL_MAX_DELAY)
 8009fd0:	1c68      	adds	r0, r5, #1
 8009fd2:	d101      	bne.n	8009fd8 <HAL_RCCEx_CRSWaitSynchronization+0x1c>
*            @arg @ref RCC_CRS_SYNCERR
*            @arg @ref RCC_CRS_SYNCMISS
*            @arg @ref RCC_CRS_TRIMOVF
*/
uint32_t HAL_RCCEx_CRSWaitSynchronization(uint32_t Timeout)
{
 8009fd4:	2000      	movs	r0, #0
 8009fd6:	e007      	b.n	8009fe8 <HAL_RCCEx_CRSWaitSynchronization+0x2c>
  /* Wait for CRS flag or timeout detection */
  do
  {
    if(Timeout != HAL_MAX_DELAY)
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8009fd8:	f7fd f81c 	bl	8007014 <HAL_GetTick>
 8009fdc:	1bc0      	subs	r0, r0, r7
 8009fde:	4285      	cmp	r5, r0
 8009fe0:	d301      	bcc.n	8009fe6 <HAL_RCCEx_CRSWaitSynchronization+0x2a>
 8009fe2:	2d00      	cmp	r5, #0
 8009fe4:	d1f6      	bne.n	8009fd4 <HAL_RCCEx_CRSWaitSynchronization+0x18>
      {
        crsstatus = RCC_CRS_TIMEOUT;
 8009fe6:	2001      	movs	r0, #1
      }
    }
    /* Check CRS SYNCOK flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCOK))
 8009fe8:	68a3      	ldr	r3, [r4, #8]
 8009fea:	07d9      	lsls	r1, r3, #31
    {
      /* CRS SYNC event OK */
      crsstatus |= RCC_CRS_SYNCOK;

      /* Clear CRS SYNC event OK bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCOK);
 8009fec:	bf48      	it	mi
 8009fee:	f8c4 800c 	strmi.w	r8, [r4, #12]
    }

    /* Check CRS SYNCWARN flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCWARN))
 8009ff2:	68b3      	ldr	r3, [r6, #8]
    }
    /* Check CRS SYNCOK flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCOK))
    {
      /* CRS SYNC event OK */
      crsstatus |= RCC_CRS_SYNCOK;
 8009ff4:	bf48      	it	mi
 8009ff6:	f040 0002 	orrmi.w	r0, r0, #2
      /* Clear CRS SYNC event OK bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCOK);
    }

    /* Check CRS SYNCWARN flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCWARN))
 8009ffa:	079a      	lsls	r2, r3, #30
    {
      /* CRS SYNC warning */
      crsstatus |= RCC_CRS_SYNCWARN;

      /* Clear CRS SYNCWARN bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCWARN);
 8009ffc:	bf44      	itt	mi
 8009ffe:	2302      	movmi	r3, #2
 800a000:	60e3      	strmi	r3, [r4, #12]
    }

    /* Check CRS TRIM overflow flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_TRIMOVF))
 800a002:	68a3      	ldr	r3, [r4, #8]

    /* Check CRS SYNCWARN flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCWARN))
    {
      /* CRS SYNC warning */
      crsstatus |= RCC_CRS_SYNCWARN;
 800a004:	bf48      	it	mi
 800a006:	f040 0004 	orrmi.w	r0, r0, #4
      /* Clear CRS SYNCWARN bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCWARN);
    }

    /* Check CRS TRIM overflow flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_TRIMOVF))
 800a00a:	055b      	lsls	r3, r3, #21
    {
      /* CRS SYNC Error */
      crsstatus |= RCC_CRS_TRIMOVF;

      /* Clear CRS Error bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_TRIMOVF);
 800a00c:	bf44      	itt	mi
 800a00e:	2304      	movmi	r3, #4
 800a010:	60e3      	strmi	r3, [r4, #12]
    }

    /* Check CRS Error flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCERR))
 800a012:	68b3      	ldr	r3, [r6, #8]

    /* Check CRS TRIM overflow flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_TRIMOVF))
    {
      /* CRS SYNC Error */
      crsstatus |= RCC_CRS_TRIMOVF;
 800a014:	bf48      	it	mi
 800a016:	f040 0020 	orrmi.w	r0, r0, #32
      /* Clear CRS Error bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_TRIMOVF);
    }

    /* Check CRS Error flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCERR))
 800a01a:	05d9      	lsls	r1, r3, #23
    {
      /* CRS SYNC Error */
      crsstatus |= RCC_CRS_SYNCERR;

      /* Clear CRS Error bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCERR);
 800a01c:	bf44      	itt	mi
 800a01e:	2304      	movmi	r3, #4
 800a020:	60e3      	strmi	r3, [r4, #12]
    }

    /* Check CRS SYNC Missed flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCMISS))
 800a022:	68a3      	ldr	r3, [r4, #8]

    /* Check CRS Error flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCERR))
    {
      /* CRS SYNC Error */
      crsstatus |= RCC_CRS_SYNCERR;
 800a024:	bf48      	it	mi
 800a026:	f040 0008 	orrmi.w	r0, r0, #8
      /* Clear CRS Error bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCERR);
    }

    /* Check CRS SYNC Missed flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCMISS))
 800a02a:	059a      	lsls	r2, r3, #22
    {
      /* CRS SYNC Missed */
      crsstatus |= RCC_CRS_SYNCMISS;

      /* Clear CRS SYNC Missed bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCMISS);
 800a02c:	bf44      	itt	mi
 800a02e:	2304      	movmi	r3, #4
 800a030:	60e3      	strmi	r3, [r4, #12]
    }

    /* Check CRS Expected SYNC flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_ESYNC))
 800a032:	68b3      	ldr	r3, [r6, #8]

    /* Check CRS SYNC Missed flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCMISS))
    {
      /* CRS SYNC Missed */
      crsstatus |= RCC_CRS_SYNCMISS;
 800a034:	bf48      	it	mi
 800a036:	f040 0010 	orrmi.w	r0, r0, #16
      /* Clear CRS SYNC Missed bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCMISS);
    }

    /* Check CRS Expected SYNC flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_ESYNC))
 800a03a:	071b      	lsls	r3, r3, #28
    {
      /* frequency error counter reached a zero value */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_ESYNC);
 800a03c:	bf44      	itt	mi
 800a03e:	2308      	movmi	r3, #8
 800a040:	60e3      	strmi	r3, [r4, #12]
    }
  } while(RCC_CRS_NONE == crsstatus);
 800a042:	2800      	cmp	r0, #0
 800a044:	d0c4      	beq.n	8009fd0 <HAL_RCCEx_CRSWaitSynchronization+0x14>

  return crsstatus;
}
 800a046:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800a04a:	bf00      	nop
 800a04c:	40006000 	.word	0x40006000

0800a050 <HAL_RCCEx_CRS_SyncOkCallback>:
 800a050:	4770      	bx	lr

0800a052 <HAL_RCCEx_CRS_SyncWarnCallback>:
 800a052:	4770      	bx	lr

0800a054 <HAL_RCCEx_CRS_ExpectedSyncCallback>:
/**
  * @brief  RCCEx Clock Recovery System Expected SYNC interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_CRS_ExpectedSyncCallback(void)
{
 800a054:	4770      	bx	lr

0800a056 <HAL_RCCEx_CRS_ErrorCallback>:
  *           @arg @ref RCC_CRS_SYNCMISS
  *           @arg @ref RCC_CRS_TRIMOVF
  * @retval none
  */
__weak void HAL_RCCEx_CRS_ErrorCallback(uint32_t Error)
{
 800a056:	4770      	bx	lr

0800a058 <HAL_RCCEx_CRS_IRQHandler>:
  */
void HAL_RCCEx_CRS_IRQHandler(void)
{
  uint32_t crserror = RCC_CRS_NONE;
  /* Get current IT flags and IT sources values */
  uint32_t itflags = READ_REG(CRS->ISR);
 800a058:	491d      	ldr	r1, [pc, #116]	; (800a0d0 <HAL_RCCEx_CRS_IRQHandler+0x78>)
/**
  * @brief Handle the Clock Recovery System interrupt request.
  * @retval None
  */
void HAL_RCCEx_CRS_IRQHandler(void)
{
 800a05a:	b508      	push	{r3, lr}
  uint32_t crserror = RCC_CRS_NONE;
  /* Get current IT flags and IT sources values */
  uint32_t itflags = READ_REG(CRS->ISR);
 800a05c:	688b      	ldr	r3, [r1, #8]
  uint32_t itsources = READ_REG(CRS->CR);
 800a05e:	680a      	ldr	r2, [r1, #0]

  /* Check CRS SYNCOK flag  */
  if(((itflags & RCC_CRS_FLAG_SYNCOK) != 0U) && ((itsources & RCC_CRS_IT_SYNCOK) != 0U))
 800a060:	f013 0f01 	tst.w	r3, #1
 800a064:	d007      	beq.n	800a076 <HAL_RCCEx_CRS_IRQHandler+0x1e>
 800a066:	f012 0f01 	tst.w	r2, #1
 800a06a:	d004      	beq.n	800a076 <HAL_RCCEx_CRS_IRQHandler+0x1e>
  {
    /* Clear CRS SYNC event OK flag */
    WRITE_REG(CRS->ICR, CRS_ICR_SYNCOKC);
 800a06c:	2301      	movs	r3, #1
 800a06e:	60cb      	str	r3, [r1, #12]

    /* user callback */
    HAL_RCCEx_CRS_SyncOkCallback();
 800a070:	f7ff ffee 	bl	800a050 <HAL_RCCEx_CRS_SyncOkCallback>
 800a074:	bd08      	pop	{r3, pc}
  }
  /* Check CRS SYNCWARN flag  */
  else if(((itflags & RCC_CRS_FLAG_SYNCWARN) != 0U) && ((itsources & RCC_CRS_IT_SYNCWARN) != 0U))
 800a076:	0799      	lsls	r1, r3, #30
 800a078:	d507      	bpl.n	800a08a <HAL_RCCEx_CRS_IRQHandler+0x32>
 800a07a:	0791      	lsls	r1, r2, #30
 800a07c:	d505      	bpl.n	800a08a <HAL_RCCEx_CRS_IRQHandler+0x32>
  {
    /* Clear CRS SYNCWARN flag */
    WRITE_REG(CRS->ICR, CRS_ICR_SYNCWARNC);
 800a07e:	4b14      	ldr	r3, [pc, #80]	; (800a0d0 <HAL_RCCEx_CRS_IRQHandler+0x78>)
 800a080:	2202      	movs	r2, #2
 800a082:	60da      	str	r2, [r3, #12]

    /* user callback */
    HAL_RCCEx_CRS_SyncWarnCallback();
 800a084:	f7ff ffe5 	bl	800a052 <HAL_RCCEx_CRS_SyncWarnCallback>
 800a088:	bd08      	pop	{r3, pc}
  }
  /* Check CRS Expected SYNC flag  */
  else if(((itflags & RCC_CRS_FLAG_ESYNC) != 0U) && ((itsources & RCC_CRS_IT_ESYNC) != 0U))
 800a08a:	0719      	lsls	r1, r3, #28
 800a08c:	d507      	bpl.n	800a09e <HAL_RCCEx_CRS_IRQHandler+0x46>
 800a08e:	0711      	lsls	r1, r2, #28
 800a090:	d505      	bpl.n	800a09e <HAL_RCCEx_CRS_IRQHandler+0x46>
  {
    /* frequency error counter reached a zero value */
    WRITE_REG(CRS->ICR, CRS_ICR_ESYNCC);
 800a092:	4b0f      	ldr	r3, [pc, #60]	; (800a0d0 <HAL_RCCEx_CRS_IRQHandler+0x78>)
 800a094:	2208      	movs	r2, #8
 800a096:	60da      	str	r2, [r3, #12]

    /* user callback */
    HAL_RCCEx_CRS_ExpectedSyncCallback();
 800a098:	f7ff ffdc 	bl	800a054 <HAL_RCCEx_CRS_ExpectedSyncCallback>
 800a09c:	bd08      	pop	{r3, pc}
  }
  /* Check CRS Error flags  */
  else
  {
    if(((itflags & RCC_CRS_FLAG_ERR) != 0U) && ((itsources & RCC_CRS_IT_ERR) != 0U))
 800a09e:	0759      	lsls	r1, r3, #29
 800a0a0:	d514      	bpl.n	800a0cc <HAL_RCCEx_CRS_IRQHandler+0x74>
 800a0a2:	0751      	lsls	r1, r2, #29
 800a0a4:	d512      	bpl.n	800a0cc <HAL_RCCEx_CRS_IRQHandler+0x74>
    {
      if((itflags & RCC_CRS_FLAG_SYNCERR) != 0U)
      {
        crserror |= RCC_CRS_SYNCERR;
 800a0a6:	f413 7f80 	tst.w	r3, #256	; 0x100
 800a0aa:	bf0c      	ite	eq
 800a0ac:	2000      	moveq	r0, #0
 800a0ae:	2008      	movne	r0, #8
      }
      if((itflags & RCC_CRS_FLAG_SYNCMISS) != 0U)
 800a0b0:	059a      	lsls	r2, r3, #22
      {
        crserror |= RCC_CRS_SYNCMISS;
 800a0b2:	bf48      	it	mi
 800a0b4:	f040 0010 	orrmi.w	r0, r0, #16
      }
      if((itflags & RCC_CRS_FLAG_TRIMOVF) != 0U)
 800a0b8:	055b      	lsls	r3, r3, #21
      {
        crserror |= RCC_CRS_TRIMOVF;
      }

      /* Clear CRS Error flags */
      WRITE_REG(CRS->ICR, CRS_ICR_ERRC);
 800a0ba:	4b05      	ldr	r3, [pc, #20]	; (800a0d0 <HAL_RCCEx_CRS_IRQHandler+0x78>)
 800a0bc:	f04f 0204 	mov.w	r2, #4
      {
        crserror |= RCC_CRS_SYNCMISS;
      }
      if((itflags & RCC_CRS_FLAG_TRIMOVF) != 0U)
      {
        crserror |= RCC_CRS_TRIMOVF;
 800a0c0:	bf48      	it	mi
 800a0c2:	f040 0020 	orrmi.w	r0, r0, #32
      }

      /* Clear CRS Error flags */
      WRITE_REG(CRS->ICR, CRS_ICR_ERRC);
 800a0c6:	60da      	str	r2, [r3, #12]

      /* user error callback */
      HAL_RCCEx_CRS_ErrorCallback(crserror);
 800a0c8:	f7ff ffc5 	bl	800a056 <HAL_RCCEx_CRS_ErrorCallback>
 800a0cc:	bd08      	pop	{r3, pc}
 800a0ce:	bf00      	nop
 800a0d0:	40006000 	.word	0x40006000

0800a0d4 <HASH_WriteData>:
  *         processing is suspended when possible and the Peripheral feeding point reached at
  *         suspension time is stored in the handle for resumption later on.
  * @retval HAL status
  */
static HAL_StatusTypeDef HASH_WriteData(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
 800a0d4:	b573      	push	{r0, r1, r4, r5, r6, lr}
  uint32_t buffercounter;
  __IO uint32_t inputaddr = (uint32_t) pInBuffer;
 800a0d6:	9101      	str	r1, [sp, #4]

  for(buffercounter = 0U; buffercounter < Size; buffercounter+=4U)
  {
    /* Write input data 4 bytes at a time */
    HASH->DIN = *(uint32_t*)inputaddr;
 800a0d8:	491e      	ldr	r1, [pc, #120]	; (800a154 <HASH_WriteData+0x80>)
static HAL_StatusTypeDef HASH_WriteData(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
  uint32_t buffercounter;
  __IO uint32_t inputaddr = (uint32_t) pInBuffer;

  for(buffercounter = 0U; buffercounter < Size; buffercounter+=4U)
 800a0da:	2400      	movs	r4, #0
 800a0dc:	4294      	cmp	r4, r2
 800a0de:	d235      	bcs.n	800a14c <HASH_WriteData+0x78>
  {
    /* Write input data 4 bytes at a time */
    HASH->DIN = *(uint32_t*)inputaddr;
 800a0e0:	9b01      	ldr	r3, [sp, #4]
 800a0e2:	681b      	ldr	r3, [r3, #0]
 800a0e4:	604b      	str	r3, [r1, #4]
    inputaddr+=4U;
 800a0e6:	9b01      	ldr	r3, [sp, #4]
 800a0e8:	3304      	adds	r3, #4
 800a0ea:	9301      	str	r3, [sp, #4]

    /* If the suspension flag has been raised and if the processing is not about
    to end, suspend processing */
    if ((hhash->SuspendRequest == HAL_HASH_SUSPEND) && ((buffercounter+4U) < Size))
 800a0ec:	f890 3036 	ldrb.w	r3, [r0, #54]	; 0x36
 800a0f0:	2b01      	cmp	r3, #1
 800a0f2:	f104 0504 	add.w	r5, r4, #4
 800a0f6:	d127      	bne.n	800a148 <HASH_WriteData+0x74>
 800a0f8:	42aa      	cmp	r2, r5
 800a0fa:	d925      	bls.n	800a148 <HASH_WriteData+0x74>
    {
      /* Wait for DINIS = 1, which occurs when 16 32-bit locations are free
      in the input buffer */
      if (__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))
 800a0fc:	6a4e      	ldr	r6, [r1, #36]	; 0x24
 800a0fe:	07f6      	lsls	r6, r6, #31
 800a100:	d522      	bpl.n	800a148 <HASH_WriteData+0x74>
        /* Reset SuspendRequest */
        hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;

        /* Depending whether the key or the input data were fed to the Peripheral, the feeding point
        reached at suspension time is not saved in the same handle fields */
        if ((hhash->Phase == HAL_HASH_PHASE_PROCESS) || (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_2))
 800a102:	f890 102d 	ldrb.w	r1, [r0, #45]	; 0x2d
      /* Wait for DINIS = 1, which occurs when 16 32-bit locations are free
      in the input buffer */
      if (__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))
      {
        /* Reset SuspendRequest */
        hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;
 800a106:	2500      	movs	r5, #0

        /* Depending whether the key or the input data were fed to the Peripheral, the feeding point
        reached at suspension time is not saved in the same handle fields */
        if ((hhash->Phase == HAL_HASH_PHASE_PROCESS) || (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_2))
 800a108:	2902      	cmp	r1, #2
      /* Wait for DINIS = 1, which occurs when 16 32-bit locations are free
      in the input buffer */
      if (__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))
      {
        /* Reset SuspendRequest */
        hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;
 800a10a:	f880 5036 	strb.w	r5, [r0, #54]	; 0x36

        /* Depending whether the key or the input data were fed to the Peripheral, the feeding point
        reached at suspension time is not saved in the same handle fields */
        if ((hhash->Phase == HAL_HASH_PHASE_PROCESS) || (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_2))
 800a10e:	d001      	beq.n	800a114 <HASH_WriteData+0x40>
 800a110:	2904      	cmp	r1, #4
 800a112:	d105      	bne.n	800a120 <HASH_WriteData+0x4c>
        {
          /* Save current reading and writing locations of Input and Output buffers */
          hhash->pHashInBuffPtr =  (uint8_t *)inputaddr;
 800a114:	9b01      	ldr	r3, [sp, #4]
 800a116:	60c3      	str	r3, [r0, #12]
          /* Save the number of bytes that remain to be processed at this point */
          hhash->HashInCount    =  Size - (buffercounter + 4U);
 800a118:	1f13      	subs	r3, r2, #4
 800a11a:	1b1a      	subs	r2, r3, r4
 800a11c:	6202      	str	r2, [r0, #32]
 800a11e:	e00f      	b.n	800a140 <HASH_WriteData+0x6c>
        }
        else if ((hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_1) || (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_3))
 800a120:	2903      	cmp	r1, #3
 800a122:	d001      	beq.n	800a128 <HASH_WriteData+0x54>
 800a124:	2905      	cmp	r1, #5
 800a126:	d105      	bne.n	800a134 <HASH_WriteData+0x60>
        {
          /* Save current reading and writing locations of Input and Output buffers */
          hhash->pHashKeyBuffPtr  =  (uint8_t *)inputaddr;
          /* Save the number of bytes that remain to be processed at this point */
          hhash->HashKeyCount  =  Size - (buffercounter + 4U);
 800a128:	3a04      	subs	r2, #4
          hhash->HashInCount    =  Size - (buffercounter + 4U);
        }
        else if ((hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_1) || (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_3))
        {
          /* Save current reading and writing locations of Input and Output buffers */
          hhash->pHashKeyBuffPtr  =  (uint8_t *)inputaddr;
 800a12a:	9b01      	ldr	r3, [sp, #4]
 800a12c:	6143      	str	r3, [r0, #20]
          /* Save the number of bytes that remain to be processed at this point */
          hhash->HashKeyCount  =  Size - (buffercounter + 4U);
 800a12e:	1b12      	subs	r2, r2, r4
 800a130:	6282      	str	r2, [r0, #40]	; 0x28
 800a132:	e005      	b.n	800a140 <HASH_WriteData+0x6c>
        }
        else
        {
          /* Unexpected phase: unlock process and report error */
          hhash->State = HAL_HASH_STATE_READY;
 800a134:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
          __HAL_UNLOCK(hhash);
 800a138:	f880 5034 	strb.w	r5, [r0, #52]	; 0x34
          return HAL_ERROR;
 800a13c:	4618      	mov	r0, r3
 800a13e:	e006      	b.n	800a14e <HASH_WriteData+0x7a>
        }

        /* Set the HASH state to Suspended and exit to stop entering data */
        hhash->State = HAL_HASH_STATE_SUSPENDED;
 800a140:	2308      	movs	r3, #8
 800a142:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
 800a146:	e001      	b.n	800a14c <HASH_WriteData+0x78>
static HAL_StatusTypeDef HASH_WriteData(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
  uint32_t buffercounter;
  __IO uint32_t inputaddr = (uint32_t) pInBuffer;

  for(buffercounter = 0U; buffercounter < Size; buffercounter+=4U)
 800a148:	462c      	mov	r4, r5
 800a14a:	e7c7      	b.n	800a0dc <HASH_WriteData+0x8>
      } /* if (__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))  */
    } /* if ((hhash->SuspendRequest == HAL_HASH_SUSPEND) && ((buffercounter+4) < Size)) */
  }   /* for(buffercounter = 0; buffercounter < Size; buffercounter+=4)                 */

  /* At this point, all the data have been entered to the Peripheral: exit */
  return  HAL_OK;
 800a14c:	2000      	movs	r0, #0
}
 800a14e:	b002      	add	sp, #8
 800a150:	bd70      	pop	{r4, r5, r6, pc}
 800a152:	bf00      	nop
 800a154:	50060400 	.word	0x50060400

0800a158 <HASH_GetDigest>:
  */
static void HASH_GetDigest(uint8_t *pMsgDigest, uint8_t Size)
{
  uint32_t msgdigest = (uint32_t)pMsgDigest;

  switch(Size)
 800a158:	2914      	cmp	r1, #20
 800a15a:	d016      	beq.n	800a18a <HASH_GetDigest+0x32>
 800a15c:	d802      	bhi.n	800a164 <HASH_GetDigest+0xc>
 800a15e:	2910      	cmp	r1, #16
 800a160:	d005      	beq.n	800a16e <HASH_GetDigest+0x16>
 800a162:	4770      	bx	lr
 800a164:	291c      	cmp	r1, #28
 800a166:	d021      	beq.n	800a1ac <HASH_GetDigest+0x54>
 800a168:	2920      	cmp	r1, #32
 800a16a:	d037      	beq.n	800a1dc <HASH_GetDigest+0x84>
 800a16c:	4770      	bx	lr
  {
    /* Read the message digest */
    case 16:  /* MD5 */
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[0]);
 800a16e:	4b29      	ldr	r3, [pc, #164]	; (800a214 <HASH_GetDigest+0xbc>)
 800a170:	68da      	ldr	r2, [r3, #12]
  \return               Reversed value
 */
__STATIC_FORCEINLINE uint32_t __REV(uint32_t value)
{
#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
  return __builtin_bswap32(value);
 800a172:	ba12      	rev	r2, r2
 800a174:	6002      	str	r2, [r0, #0]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[1]);
 800a176:	691a      	ldr	r2, [r3, #16]
 800a178:	ba12      	rev	r2, r2
 800a17a:	6042      	str	r2, [r0, #4]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[2]);
 800a17c:	695a      	ldr	r2, [r3, #20]
 800a17e:	ba12      	rev	r2, r2
 800a180:	6082      	str	r2, [r0, #8]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[3]);
 800a182:	699b      	ldr	r3, [r3, #24]
 800a184:	ba1b      	rev	r3, r3
 800a186:	60c3      	str	r3, [r0, #12]
    break;
 800a188:	4770      	bx	lr
    case 20:  /* SHA1 */
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[0]);
 800a18a:	4b22      	ldr	r3, [pc, #136]	; (800a214 <HASH_GetDigest+0xbc>)
 800a18c:	68da      	ldr	r2, [r3, #12]
 800a18e:	ba12      	rev	r2, r2
 800a190:	6002      	str	r2, [r0, #0]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[1]);
 800a192:	691a      	ldr	r2, [r3, #16]
 800a194:	ba12      	rev	r2, r2
 800a196:	6042      	str	r2, [r0, #4]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[2]);
 800a198:	695a      	ldr	r2, [r3, #20]
 800a19a:	ba12      	rev	r2, r2
 800a19c:	6082      	str	r2, [r0, #8]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[3]);
 800a19e:	699a      	ldr	r2, [r3, #24]
 800a1a0:	ba12      	rev	r2, r2
 800a1a2:	60c2      	str	r2, [r0, #12]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[4]);
 800a1a4:	69db      	ldr	r3, [r3, #28]
 800a1a6:	ba1b      	rev	r3, r3
 800a1a8:	6103      	str	r3, [r0, #16]
    break;
 800a1aa:	4770      	bx	lr
  case 28:  /* SHA224 */
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[0]);
 800a1ac:	4b19      	ldr	r3, [pc, #100]	; (800a214 <HASH_GetDigest+0xbc>)
 800a1ae:	68da      	ldr	r2, [r3, #12]
 800a1b0:	ba12      	rev	r2, r2
 800a1b2:	6002      	str	r2, [r0, #0]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[1]);
 800a1b4:	691a      	ldr	r2, [r3, #16]
 800a1b6:	ba12      	rev	r2, r2
 800a1b8:	6042      	str	r2, [r0, #4]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[2]);
 800a1ba:	695a      	ldr	r2, [r3, #20]
 800a1bc:	ba12      	rev	r2, r2
 800a1be:	6082      	str	r2, [r0, #8]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[3]);
 800a1c0:	699a      	ldr	r2, [r3, #24]
 800a1c2:	ba12      	rev	r2, r2
 800a1c4:	60c2      	str	r2, [r0, #12]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[4]);
 800a1c6:	69db      	ldr	r3, [r3, #28]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[5]);
 800a1c8:	4a13      	ldr	r2, [pc, #76]	; (800a218 <HASH_GetDigest+0xc0>)
 800a1ca:	ba1b      	rev	r3, r3
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[2]);
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[3]);
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[4]);
 800a1cc:	6103      	str	r3, [r0, #16]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[5]);
 800a1ce:	6953      	ldr	r3, [r2, #20]
 800a1d0:	ba1b      	rev	r3, r3
 800a1d2:	6143      	str	r3, [r0, #20]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[6]);
 800a1d4:	6993      	ldr	r3, [r2, #24]
 800a1d6:	ba1b      	rev	r3, r3
 800a1d8:	6183      	str	r3, [r0, #24]
    break;
 800a1da:	4770      	bx	lr
  case 32:   /* SHA256 */
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[0]);
 800a1dc:	4b0d      	ldr	r3, [pc, #52]	; (800a214 <HASH_GetDigest+0xbc>)
 800a1de:	68da      	ldr	r2, [r3, #12]
 800a1e0:	ba12      	rev	r2, r2
 800a1e2:	6002      	str	r2, [r0, #0]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[1]);
 800a1e4:	691a      	ldr	r2, [r3, #16]
 800a1e6:	ba12      	rev	r2, r2
 800a1e8:	6042      	str	r2, [r0, #4]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[2]);
 800a1ea:	695a      	ldr	r2, [r3, #20]
 800a1ec:	ba12      	rev	r2, r2
 800a1ee:	6082      	str	r2, [r0, #8]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[3]);
 800a1f0:	699a      	ldr	r2, [r3, #24]
 800a1f2:	ba12      	rev	r2, r2
 800a1f4:	60c2      	str	r2, [r0, #12]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[4]);
 800a1f6:	69db      	ldr	r3, [r3, #28]
 800a1f8:	ba1b      	rev	r3, r3
 800a1fa:	6103      	str	r3, [r0, #16]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[5]);
 800a1fc:	4b06      	ldr	r3, [pc, #24]	; (800a218 <HASH_GetDigest+0xc0>)
 800a1fe:	695a      	ldr	r2, [r3, #20]
 800a200:	ba12      	rev	r2, r2
 800a202:	6142      	str	r2, [r0, #20]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[6]);
 800a204:	699a      	ldr	r2, [r3, #24]
 800a206:	ba12      	rev	r2, r2
 800a208:	6182      	str	r2, [r0, #24]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[7]);
 800a20a:	69db      	ldr	r3, [r3, #28]
 800a20c:	ba1b      	rev	r3, r3
 800a20e:	61c3      	str	r3, [r0, #28]
 800a210:	4770      	bx	lr
 800a212:	bf00      	nop
 800a214:	50060400 	.word	0x50060400
 800a218:	50060710 	.word	0x50060710

0800a21c <HASH_WaitOnFlagUntilTimeout>:
  * @param  Status the Flag status (SET or RESET).
  * @param  Timeout Timeout duration.
  * @retval HAL status
  */
static HAL_StatusTypeDef HASH_WaitOnFlagUntilTimeout(HASH_HandleTypeDef *hhash, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
{
 800a21c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800a220:	4604      	mov	r4, r0
 800a222:	460d      	mov	r5, r1
 800a224:	4691      	mov	r9, r2
 800a226:	461e      	mov	r6, r3
  uint32_t tickstart = HAL_GetTick();
 800a228:	f7fc fef4 	bl	8007014 <HAL_GetTick>
 800a22c:	4f1e      	ldr	r7, [pc, #120]	; (800a2a8 <HASH_WaitOnFlagUntilTimeout+0x8c>)
 800a22e:	4680      	mov	r8, r0

  /* Wait until flag is set */
  if(Status == RESET)
 800a230:	f1b9 0f00 	cmp.w	r9, #0
 800a234:	d116      	bne.n	800a264 <HASH_WaitOnFlagUntilTimeout+0x48>
  {
    while(__HAL_HASH_GET_FLAG(Flag) == RESET)
 800a236:	2d08      	cmp	r5, #8
 800a238:	bf8c      	ite	hi
 800a23a:	683b      	ldrhi	r3, [r7, #0]
 800a23c:	6a7b      	ldrls	r3, [r7, #36]	; 0x24
 800a23e:	ea35 0303 	bics.w	r3, r5, r3
 800a242:	bf14      	ite	ne
 800a244:	2301      	movne	r3, #1
 800a246:	2300      	moveq	r3, #0
 800a248:	b1bb      	cbz	r3, 800a27a <HASH_WaitOnFlagUntilTimeout+0x5e>
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
 800a24a:	1c72      	adds	r2, r6, #1
 800a24c:	d0f3      	beq.n	800a236 <HASH_WaitOnFlagUntilTimeout+0x1a>
      {
        if(((HAL_GetTick()-tickstart) > Timeout) || (Timeout == 0U))
 800a24e:	f7fc fee1 	bl	8007014 <HAL_GetTick>
 800a252:	ebc8 0000 	rsb	r0, r8, r0
 800a256:	4286      	cmp	r6, r0
 800a258:	d318      	bcc.n	800a28c <HASH_WaitOnFlagUntilTimeout+0x70>
 800a25a:	2e00      	cmp	r6, #0
 800a25c:	d1eb      	bne.n	800a236 <HASH_WaitOnFlagUntilTimeout+0x1a>
 800a25e:	e015      	b.n	800a28c <HASH_WaitOnFlagUntilTimeout+0x70>
  else
  {
    while(__HAL_HASH_GET_FLAG(Flag) != RESET)
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
 800a260:	1c73      	adds	r3, r6, #1
 800a262:	d10d      	bne.n	800a280 <HASH_WaitOnFlagUntilTimeout+0x64>
      }
    }
  }
  else
  {
    while(__HAL_HASH_GET_FLAG(Flag) != RESET)
 800a264:	2d08      	cmp	r5, #8
 800a266:	bf8c      	ite	hi
 800a268:	683b      	ldrhi	r3, [r7, #0]
 800a26a:	6a7b      	ldrls	r3, [r7, #36]	; 0x24
 800a26c:	ea35 0303 	bics.w	r3, r5, r3
 800a270:	bf0c      	ite	eq
 800a272:	2301      	moveq	r3, #1
 800a274:	2300      	movne	r3, #0
 800a276:	2b00      	cmp	r3, #0
 800a278:	d1f2      	bne.n	800a260 <HASH_WaitOnFlagUntilTimeout+0x44>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;
 800a27a:	2000      	movs	r0, #0
 800a27c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    while(__HAL_HASH_GET_FLAG(Flag) != RESET)
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
      {
        if(((HAL_GetTick()-tickstart) > Timeout) || (Timeout == 0U))
 800a280:	f7fc fec8 	bl	8007014 <HAL_GetTick>
 800a284:	ebc8 0000 	rsb	r0, r8, r0
 800a288:	4286      	cmp	r6, r0
 800a28a:	d20a      	bcs.n	800a2a2 <HASH_WaitOnFlagUntilTimeout+0x86>
        {
          /* Set State to Ready to be able to restart later on */
          hhash->State  = HAL_HASH_STATE_READY;
 800a28c:	2301      	movs	r3, #1
 800a28e:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
          /* Store time out issue in handle status */
          hhash->Status = HAL_TIMEOUT;
 800a292:	2003      	movs	r0, #3

          /* Process Unlocked */
          __HAL_UNLOCK(hhash);
 800a294:	2300      	movs	r3, #0
        if(((HAL_GetTick()-tickstart) > Timeout) || (Timeout == 0U))
        {
          /* Set State to Ready to be able to restart later on */
          hhash->State  = HAL_HASH_STATE_READY;
          /* Store time out issue in handle status */
          hhash->Status = HAL_TIMEOUT;
 800a296:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c

          /* Process Unlocked */
          __HAL_UNLOCK(hhash);
 800a29a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

          return HAL_TIMEOUT;
 800a29e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    while(__HAL_HASH_GET_FLAG(Flag) != RESET)
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
      {
        if(((HAL_GetTick()-tickstart) > Timeout) || (Timeout == 0U))
 800a2a2:	2e00      	cmp	r6, #0
 800a2a4:	d1de      	bne.n	800a264 <HASH_WaitOnFlagUntilTimeout+0x48>
 800a2a6:	e7f1      	b.n	800a28c <HASH_WaitOnFlagUntilTimeout+0x70>
 800a2a8:	50060400 	.word	0x50060400

0800a2ac <HAL_HASH_MspInit>:
 800a2ac:	4770      	bx	lr
	...

0800a2b0 <HAL_HASH_Init>:
  *         relevant APIs manage themselves the MDMAT bit.
  * @param  hhash HASH handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASH_Init(HASH_HandleTypeDef *hhash)
{
 800a2b0:	b538      	push	{r3, r4, r5, lr}
  /* Check the hash handle allocation */
  if(hhash == NULL)
 800a2b2:	4604      	mov	r4, r0
 800a2b4:	b340      	cbz	r0, 800a308 <HAL_HASH_Init+0x58>

    /* Init the low level hardware */
    hhash->MspInitCallback(hhash);
  }
#else
  if(hhash->State == HAL_HASH_STATE_RESET)
 800a2b6:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 800a2ba:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800a2be:	b91b      	cbnz	r3, 800a2c8 <HAL_HASH_Init+0x18>
  {
    /* Allocate lock resource and initialize it */
    hhash->Lock = HAL_UNLOCKED;
 800a2c0:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34

    /* Init the low level hardware */
    HAL_HASH_MspInit(hhash);
 800a2c4:	f7ff fff2 	bl	800a2ac <HAL_HASH_MspInit>
  }
#endif /* (USE_HAL_HASH_REGISTER_CALLBACKS) */

    /* Change the HASH state */
  hhash->State = HAL_HASH_STATE_BUSY;
 800a2c8:	2302      	movs	r3, #2
 800a2ca:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

  /* Reset HashInCount, HashITCounter, HashBuffSize and NbWordsAlreadyPushed */
  hhash->HashInCount = 0;
 800a2ce:	2000      	movs	r0, #0
  hhash->Phase = HAL_HASH_PHASE_READY;
  /* Reset suspension request flag */
  hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;

  /* Set the data type bit */
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
 800a2d0:	4b0e      	ldr	r3, [pc, #56]	; (800a30c <HAL_HASH_Init+0x5c>)

    /* Change the HASH state */
  hhash->State = HAL_HASH_STATE_BUSY;

  /* Reset HashInCount, HashITCounter, HashBuffSize and NbWordsAlreadyPushed */
  hhash->HashInCount = 0;
 800a2d2:	6220      	str	r0, [r4, #32]
  hhash->HashBuffSize = 0;
 800a2d4:	61e0      	str	r0, [r4, #28]
  hhash->HashITCounter = 0;
 800a2d6:	6260      	str	r0, [r4, #36]	; 0x24
  hhash->NbWordsAlreadyPushed = 0;
 800a2d8:	63a0      	str	r0, [r4, #56]	; 0x38
  hhash->Phase = HAL_HASH_PHASE_READY;
  /* Reset suspension request flag */
  hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;

  /* Set the data type bit */
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
 800a2da:	681a      	ldr	r2, [r3, #0]
  hhash->HashInCount = 0;
  hhash->HashBuffSize = 0;
  hhash->HashITCounter = 0;
  hhash->NbWordsAlreadyPushed = 0;
  /* Reset digest calculation bridle (MDMAT bit control) */
  hhash->DigestCalculationDisable = RESET;
 800a2dc:	f884 0037 	strb.w	r0, [r4, #55]	; 0x37
  hhash->Phase = HAL_HASH_PHASE_READY;
  /* Reset suspension request flag */
  hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;

  /* Set the data type bit */
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
 800a2e0:	f022 0130 	bic.w	r1, r2, #48	; 0x30
 800a2e4:	6822      	ldr	r2, [r4, #0]
  /* Reset digest calculation bridle (MDMAT bit control) */
  hhash->DigestCalculationDisable = RESET;
  /* Set phase to READY */
  hhash->Phase = HAL_HASH_PHASE_READY;
  /* Reset suspension request flag */
  hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;
 800a2e6:	f884 0036 	strb.w	r0, [r4, #54]	; 0x36
  hhash->HashITCounter = 0;
  hhash->NbWordsAlreadyPushed = 0;
  /* Reset digest calculation bridle (MDMAT bit control) */
  hhash->DigestCalculationDisable = RESET;
  /* Set phase to READY */
  hhash->Phase = HAL_HASH_PHASE_READY;
 800a2ea:	2501      	movs	r5, #1
  /* Reset suspension request flag */
  hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;

  /* Set the data type bit */
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
 800a2ec:	430a      	orrs	r2, r1
  hhash->HashITCounter = 0;
  hhash->NbWordsAlreadyPushed = 0;
  /* Reset digest calculation bridle (MDMAT bit control) */
  hhash->DigestCalculationDisable = RESET;
  /* Set phase to READY */
  hhash->Phase = HAL_HASH_PHASE_READY;
 800a2ee:	f884 502d 	strb.w	r5, [r4, #45]	; 0x2d
  /* Reset suspension request flag */
  hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;

  /* Set the data type bit */
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
 800a2f2:	601a      	str	r2, [r3, #0]
  /* Reset MDMAT bit */
__HAL_HASH_RESET_MDMAT();
 800a2f4:	681a      	ldr	r2, [r3, #0]
 800a2f6:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800a2fa:	601a      	str	r2, [r3, #0]
  /* Reset HASH handle status */
  hhash->Status = HAL_OK;

  /* Set the HASH state to Ready */
  hhash->State = HAL_HASH_STATE_READY;
 800a2fc:	f884 5035 	strb.w	r5, [r4, #53]	; 0x35
  /* Set the data type bit */
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
  /* Reset MDMAT bit */
__HAL_HASH_RESET_MDMAT();
  /* Reset HASH handle status */
  hhash->Status = HAL_OK;
 800a300:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c

  /* Set the HASH state to Ready */
  hhash->State = HAL_HASH_STATE_READY;

  /* Initialise the error code */
  hhash->ErrorCode = HAL_HASH_ERROR_NONE;
 800a304:	63e0      	str	r0, [r4, #60]	; 0x3c

  /* Return function status */
  return HAL_OK;
 800a306:	bd38      	pop	{r3, r4, r5, pc}
HAL_StatusTypeDef HAL_HASH_Init(HASH_HandleTypeDef *hhash)
{
  /* Check the hash handle allocation */
  if(hhash == NULL)
  {
    return HAL_ERROR;
 800a308:	2001      	movs	r0, #1
  /* Initialise the error code */
  hhash->ErrorCode = HAL_HASH_ERROR_NONE;

  /* Return function status */
  return HAL_OK;
}
 800a30a:	bd38      	pop	{r3, r4, r5, pc}
 800a30c:	50060400 	.word	0x50060400

0800a310 <HAL_HASH_MspDeInit>:
 800a310:	4770      	bx	lr

0800a312 <HAL_HASH_InCpltCallback>:
 800a312:	4770      	bx	lr

0800a314 <HAL_HASH_DgstCpltCallback>:
 800a314:	4770      	bx	lr

0800a316 <HAL_HASH_ErrorCallback>:
  *         to retrieve the error type.
  * @param  hhash HASH handle.
  * @retval None
  */
__weak void HAL_HASH_ErrorCallback(HASH_HandleTypeDef *hhash)
{
 800a316:	4770      	bx	lr

0800a318 <HAL_HASH_IRQHandler>:
  *        HAL_HASH_ErrorCallback() API is called so that user code can
  *        manage the error. The error type is available in hhash->Status field.
  * @retval None
  */
void HAL_HASH_IRQHandler(HASH_HandleTypeDef *hhash)
{
 800a318:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *         suspension time is stored in the handle for resumption later on.
  * @retval HAL status
  */
static HAL_StatusTypeDef HASH_IT(HASH_HandleTypeDef *hhash)
{
  if (hhash->State == HAL_HASH_STATE_BUSY)
 800a31a:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 800a31e:	b2db      	uxtb	r3, r3
 800a320:	2b02      	cmp	r3, #2
  *        HAL_HASH_ErrorCallback() API is called so that user code can
  *        manage the error. The error type is available in hhash->Status field.
  * @retval None
  */
void HAL_HASH_IRQHandler(HASH_HandleTypeDef *hhash)
{
 800a322:	4604      	mov	r4, r0
  *         suspension time is stored in the handle for resumption later on.
  * @retval HAL status
  */
static HAL_StatusTypeDef HASH_IT(HASH_HandleTypeDef *hhash)
{
  if (hhash->State == HAL_HASH_STATE_BUSY)
 800a324:	f040 80de 	bne.w	800a4e4 <HAL_HASH_IRQHandler+0x1cc>
  {
    /* ITCounter must not be equal to 0 at this point. Report an error if this is the case. */
    if(hhash->HashITCounter == 0U)
 800a328:	6a42      	ldr	r2, [r0, #36]	; 0x24
 800a32a:	4d77      	ldr	r5, [pc, #476]	; (800a508 <HAL_HASH_IRQHandler+0x1f0>)
 800a32c:	b93a      	cbnz	r2, 800a33e <HAL_HASH_IRQHandler+0x26>
    {
      /* Disable Interrupts */
      __HAL_HASH_DISABLE_IT(HASH_IT_DINI|HASH_IT_DCI);
 800a32e:	6a2b      	ldr	r3, [r5, #32]
      /* HASH state set back to Ready to prevent any issue in user code
         present in HAL_HASH_ErrorCallback() */
      hhash->State = HAL_HASH_STATE_READY;
 800a330:	2001      	movs	r0, #1
  {
    /* ITCounter must not be equal to 0 at this point. Report an error if this is the case. */
    if(hhash->HashITCounter == 0U)
    {
      /* Disable Interrupts */
      __HAL_HASH_DISABLE_IT(HASH_IT_DINI|HASH_IT_DCI);
 800a332:	f023 0303 	bic.w	r3, r3, #3
 800a336:	622b      	str	r3, [r5, #32]
      /* HASH state set back to Ready to prevent any issue in user code
         present in HAL_HASH_ErrorCallback() */
      hhash->State = HAL_HASH_STATE_READY;
 800a338:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
 800a33c:	e0d3      	b.n	800a4e6 <HAL_HASH_IRQHandler+0x1ce>
      return HAL_ERROR;
    }
    else if (hhash->HashITCounter == 1U)
 800a33e:	6a42      	ldr	r2, [r0, #36]	; 0x24
 800a340:	2a01      	cmp	r2, #1
    }
    else
    {
      /* Cruise speed reached, HashITCounter remains equal to 3 until the end of
        the HASH processing or the end of the current step for HMAC processing. */
      hhash->HashITCounter = 3U;
 800a342:	bf18      	it	ne
 800a344:	2303      	movne	r3, #3
 800a346:	6243      	str	r3, [r0, #36]	; 0x24
    }

    /* If digest is ready */
    if (__HAL_HASH_GET_FLAG(HASH_FLAG_DCIS))
 800a348:	6a68      	ldr	r0, [r5, #36]	; 0x24
 800a34a:	4b6f      	ldr	r3, [pc, #444]	; (800a508 <HAL_HASH_IRQHandler+0x1f0>)
 800a34c:	f010 0002 	ands.w	r0, r0, #2
 800a350:	d025      	beq.n	800a39e <HAL_HASH_IRQHandler+0x86>
    {
      /* Read the digest */
      HASH_GetDigest(hhash->pHashOutBuffPtr, HASH_DIGEST_LENGTH());
 800a352:	6819      	ldr	r1, [r3, #0]
 800a354:	4a6d      	ldr	r2, [pc, #436]	; (800a50c <HAL_HASH_IRQHandler+0x1f4>)
 800a356:	6920      	ldr	r0, [r4, #16]
 800a358:	400a      	ands	r2, r1
 800a35a:	b172      	cbz	r2, 800a37a <HAL_HASH_IRQHandler+0x62>
 800a35c:	6819      	ldr	r1, [r3, #0]
 800a35e:	4a6b      	ldr	r2, [pc, #428]	; (800a50c <HAL_HASH_IRQHandler+0x1f4>)
 800a360:	400a      	ands	r2, r1
 800a362:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
 800a366:	d00a      	beq.n	800a37e <HAL_HASH_IRQHandler+0x66>
 800a368:	681a      	ldr	r2, [r3, #0]
 800a36a:	4b68      	ldr	r3, [pc, #416]	; (800a50c <HAL_HASH_IRQHandler+0x1f4>)
 800a36c:	4967      	ldr	r1, [pc, #412]	; (800a50c <HAL_HASH_IRQHandler+0x1f4>)
 800a36e:	4013      	ands	r3, r2
 800a370:	428b      	cmp	r3, r1
 800a372:	bf0c      	ite	eq
 800a374:	2120      	moveq	r1, #32
 800a376:	2110      	movne	r1, #16
 800a378:	e002      	b.n	800a380 <HAL_HASH_IRQHandler+0x68>
 800a37a:	2114      	movs	r1, #20
 800a37c:	e000      	b.n	800a380 <HAL_HASH_IRQHandler+0x68>
 800a37e:	211c      	movs	r1, #28
 800a380:	f7ff feea 	bl	800a158 <HASH_GetDigest>

      /* Disable Interrupts */
      __HAL_HASH_DISABLE_IT(HASH_IT_DINI|HASH_IT_DCI);
 800a384:	6a2b      	ldr	r3, [r5, #32]
 800a386:	f023 0303 	bic.w	r3, r3, #3
 800a38a:	622b      	str	r3, [r5, #32]
      /* Change the HASH state */
      hhash->State = HAL_HASH_STATE_READY;
 800a38c:	2301      	movs	r3, #1
 800a38e:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      /* Reset HASH state machine */
      hhash->Phase = HAL_HASH_PHASE_READY;
 800a392:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
      /* Call digest computation complete call back */
#if (USE_HAL_HASH_REGISTER_CALLBACKS == 1)
      hhash->DgstCpltCallback(hhash);
#else
      HAL_HASH_DgstCpltCallback(hhash);
 800a396:	4620      	mov	r0, r4
 800a398:	f7ff ffbc 	bl	800a314 <HAL_HASH_DgstCpltCallback>
 800a39c:	e0b1      	b.n	800a502 <HAL_HASH_IRQHandler+0x1ea>

      return HAL_OK;
    }

    /* If Peripheral ready to accept new data */
    if (__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))
 800a39e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800a3a0:	07d2      	lsls	r2, r2, #31
 800a3a2:	f140 80ae 	bpl.w	800a502 <HAL_HASH_IRQHandler+0x1ea>
    {

      /* If the suspension flag has been raised and if the processing is not about
         to end, suspend processing */
      if ( (hhash->HashInCount != 0U) &&  (hhash->SuspendRequest == HAL_HASH_SUSPEND))
 800a3a6:	6a22      	ldr	r2, [r4, #32]
 800a3a8:	b16a      	cbz	r2, 800a3c6 <HAL_HASH_IRQHandler+0xae>
 800a3aa:	f894 2036 	ldrb.w	r2, [r4, #54]	; 0x36
 800a3ae:	2a01      	cmp	r2, #1
 800a3b0:	d109      	bne.n	800a3c6 <HAL_HASH_IRQHandler+0xae>
      {
        /* Disable Interrupts */
        __HAL_HASH_DISABLE_IT(HASH_IT_DINI|HASH_IT_DCI);
 800a3b2:	6a1a      	ldr	r2, [r3, #32]
 800a3b4:	f022 0203 	bic.w	r2, r2, #3
 800a3b8:	621a      	str	r2, [r3, #32]

        /* Reset SuspendRequest */
        hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;

        /* Change the HASH state */
        hhash->State = HAL_HASH_STATE_SUSPENDED;
 800a3ba:	2308      	movs	r3, #8
      {
        /* Disable Interrupts */
        __HAL_HASH_DISABLE_IT(HASH_IT_DINI|HASH_IT_DCI);

        /* Reset SuspendRequest */
        hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;
 800a3bc:	f884 0036 	strb.w	r0, [r4, #54]	; 0x36

        /* Change the HASH state */
        hhash->State = HAL_HASH_STATE_SUSPENDED;
 800a3c0:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
 800a3c4:	e08f      	b.n	800a4e6 <HAL_HASH_IRQHandler+0x1ce>
  uint32_t buffercounter;
  uint32_t inputcounter;
  uint32_t ret = HASH_DIGEST_CALCULATION_NOT_STARTED;

  /* If there are more than 64 bytes remaining to be entered */
  if(hhash->HashInCount > 64U)
 800a3c6:	6a23      	ldr	r3, [r4, #32]
 800a3c8:	2b40      	cmp	r3, #64	; 0x40
 800a3ca:	68e3      	ldr	r3, [r4, #12]
 800a3cc:	d91e      	bls.n	800a40c <HAL_HASH_IRQHandler+0xf4>
 800a3ce:	f103 0140 	add.w	r1, r3, #64	; 0x40
  {
    inputaddr = (uint32_t)hhash->pHashInBuffPtr;
 800a3d2:	461a      	mov	r2, r3
    /* Write the Input block in the Data IN register
      (16 32-bit words, or 64 bytes are entered) */
    for(buffercounter = 0U; buffercounter < 64U; buffercounter+=4U)
    {
      HASH->DIN = *(uint32_t*)inputaddr;
 800a3d4:	f852 0b04 	ldr.w	r0, [r2], #4
 800a3d8:	6068      	str	r0, [r5, #4]
  if(hhash->HashInCount > 64U)
  {
    inputaddr = (uint32_t)hhash->pHashInBuffPtr;
    /* Write the Input block in the Data IN register
      (16 32-bit words, or 64 bytes are entered) */
    for(buffercounter = 0U; buffercounter < 64U; buffercounter+=4U)
 800a3da:	428a      	cmp	r2, r1
 800a3dc:	d1fa      	bne.n	800a3d4 <HAL_HASH_IRQHandler+0xbc>
      HASH->DIN = *(uint32_t*)inputaddr;
      inputaddr+=4U;
    }
    /* If this is the start of input data entering, an additional word
      must be entered to start up the HASH processing */
    if(hhash->HashITCounter == 2U)
 800a3de:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800a3e0:	2902      	cmp	r1, #2
 800a3e2:	d10e      	bne.n	800a402 <HAL_HASH_IRQHandler+0xea>
    {
      HASH->DIN = *(uint32_t*)inputaddr;
 800a3e4:	4a48      	ldr	r2, [pc, #288]	; (800a508 <HAL_HASH_IRQHandler+0x1f0>)
 800a3e6:	6c19      	ldr	r1, [r3, #64]	; 0x40
 800a3e8:	6051      	str	r1, [r2, #4]
      if(hhash->HashInCount >= 68U)
 800a3ea:	6a22      	ldr	r2, [r4, #32]
 800a3ec:	2a43      	cmp	r2, #67	; 0x43
      {
        /* There are still data waiting to be entered in the Peripheral.
           Decrement buffer counter and set pointer to the proper
           memory location for the next data entering round. */
        hhash->HashInCount -= 68U;
 800a3ee:	bf83      	ittte	hi
 800a3f0:	6a22      	ldrhi	r2, [r4, #32]
        hhash->pHashInBuffPtr+= 68U;
 800a3f2:	3344      	addhi	r3, #68	; 0x44
      if(hhash->HashInCount >= 68U)
      {
        /* There are still data waiting to be entered in the Peripheral.
           Decrement buffer counter and set pointer to the proper
           memory location for the next data entering round. */
        hhash->HashInCount -= 68U;
 800a3f4:	3a44      	subhi	r2, #68	; 0x44
        hhash->pHashInBuffPtr+= 68U;
      }
      else
      {
        /* All the input buffer has been fed to the HW. */
        hhash->HashInCount = 0U;
 800a3f6:	2300      	movls	r3, #0
      if(hhash->HashInCount >= 68U)
      {
        /* There are still data waiting to be entered in the Peripheral.
           Decrement buffer counter and set pointer to the proper
           memory location for the next data entering round. */
        hhash->HashInCount -= 68U;
 800a3f8:	bf86      	itte	hi
 800a3fa:	6222      	strhi	r2, [r4, #32]
        hhash->pHashInBuffPtr+= 68U;
 800a3fc:	60e3      	strhi	r3, [r4, #12]
      }
      else
      {
        /* All the input buffer has been fed to the HW. */
        hhash->HashInCount = 0U;
 800a3fe:	6223      	strls	r3, [r4, #32]
 800a400:	e07f      	b.n	800a502 <HAL_HASH_IRQHandler+0x1ea>
    else
    {
      /* 64 bytes have been entered and there are still some remaining:
         Decrement buffer counter and set pointer to the proper
        memory location for the next data entering round.*/
      hhash->HashInCount -= 64U;
 800a402:	6a23      	ldr	r3, [r4, #32]
      hhash->pHashInBuffPtr+= 64U;
 800a404:	60e2      	str	r2, [r4, #12]
    else
    {
      /* 64 bytes have been entered and there are still some remaining:
         Decrement buffer counter and set pointer to the proper
        memory location for the next data entering round.*/
      hhash->HashInCount -= 64U;
 800a406:	3b40      	subs	r3, #64	; 0x40
 800a408:	6223      	str	r3, [r4, #32]
 800a40a:	e07a      	b.n	800a502 <HAL_HASH_IRQHandler+0x1ea>
      data entering round. */

    /* Get the buffer address */
    inputaddr = (uint32_t)hhash->pHashInBuffPtr;
    /* Get the buffer counter */
    inputcounter = hhash->HashInCount;
 800a40c:	6a22      	ldr	r2, [r4, #32]
    /* Disable Interrupts */
    __HAL_HASH_DISABLE_IT(HASH_IT_DINI);
 800a40e:	6a29      	ldr	r1, [r5, #32]
 800a410:	3203      	adds	r2, #3
 800a412:	f021 0101 	bic.w	r1, r1, #1
 800a416:	f022 0203 	bic.w	r2, r2, #3
 800a41a:	6229      	str	r1, [r5, #32]
 800a41c:	441a      	add	r2, r3

    /* Write the Input block in the Data IN register */
    for(buffercounter = 0U; buffercounter < ((inputcounter+3U)/4U); buffercounter++)
 800a41e:	429a      	cmp	r2, r3
 800a420:	d003      	beq.n	800a42a <HAL_HASH_IRQHandler+0x112>
    {
      HASH->DIN = *(uint32_t*)inputaddr;
 800a422:	f853 1b04 	ldr.w	r1, [r3], #4
 800a426:	6069      	str	r1, [r5, #4]
 800a428:	e7f9      	b.n	800a41e <HAL_HASH_IRQHandler+0x106>
      inputaddr+=4U;
    }

    if (hhash->Accumulation == 1U)
 800a42a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800a42c:	2b01      	cmp	r3, #1
 800a42e:	d107      	bne.n	800a440 <HAL_HASH_IRQHandler+0x128>
    {
      /* Field accumulation is set, API only feeds data to the Peripheral and under interruption.
         The digest computation will be started when the last buffer data are entered. */

      /* Reset multi buffers accumulation flag */
      hhash->Accumulation = 0U;
 800a430:	2600      	movs	r6, #0
 800a432:	6426      	str	r6, [r4, #64]	; 0x40
      hhash->State = HAL_HASH_STATE_READY;
      /* Call Input data transfer complete call back */
#if (USE_HAL_HASH_REGISTER_CALLBACKS == 1)
        hhash->InCpltCallback(hhash);
#else
        HAL_HASH_InCpltCallback(hhash);
 800a434:	4620      	mov	r0, r4
         The digest computation will be started when the last buffer data are entered. */

      /* Reset multi buffers accumulation flag */
      hhash->Accumulation = 0U;
      /* Change the HASH state */
      hhash->State = HAL_HASH_STATE_READY;
 800a436:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      /* Call Input data transfer complete call back */
#if (USE_HAL_HASH_REGISTER_CALLBACKS == 1)
        hhash->InCpltCallback(hhash);
#else
        HAL_HASH_InCpltCallback(hhash);
 800a43a:	f7ff ff6a 	bl	800a312 <HAL_HASH_InCpltCallback>
 800a43e:	e004      	b.n	800a44a <HAL_HASH_IRQHandler+0x132>
#endif /* USE_HAL_HASH_REGISTER_CALLBACKS */
    }
    else
    {
      /* Start the Digest calculation */
      __HAL_HASH_START_DIGEST();
 800a440:	68ab      	ldr	r3, [r5, #8]
 800a442:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800a446:	60ab      	str	r3, [r5, #8]
      /* Return indication that digest calculation has started:
         this return value triggers the call to Input data transfer
         complete call back as well as the proper transition from
         one step to another in HMAC mode. */
      ret = HASH_DIGEST_CALCULATION_STARTED;
 800a448:	2601      	movs	r6, #1
    }
    /* Reset buffer counter */
    hhash->HashInCount = 0;
 800a44a:	2300      	movs	r3, #0
 800a44c:	6223      	str	r3, [r4, #32]
        return HAL_OK;
      }

      /* Enter input data in the Peripheral thru HASH_Write_Block_Data() call and
        check whether the digest calculation has been triggered */
      if (HASH_Write_Block_Data(hhash) == HASH_DIGEST_CALCULATION_STARTED)
 800a44e:	2e00      	cmp	r6, #0
 800a450:	d057      	beq.n	800a502 <HAL_HASH_IRQHandler+0x1ea>
        /* Call Input data transfer complete call back
           (called at the end of each step for HMAC) */
#if (USE_HAL_HASH_REGISTER_CALLBACKS == 1)
        hhash->InCpltCallback(hhash);
#else
        HAL_HASH_InCpltCallback(hhash);
 800a452:	4620      	mov	r0, r4
 800a454:	f7ff ff5d 	bl	800a312 <HAL_HASH_InCpltCallback>
#endif /* USE_HAL_HASH_REGISTER_CALLBACKS */

        if (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_1)
 800a458:	f894 702d 	ldrb.w	r7, [r4, #45]	; 0x2d
 800a45c:	2f03      	cmp	r7, #3
 800a45e:	d11c      	bne.n	800a49a <HAL_HASH_IRQHandler+0x182>
        {
          /* Wait until Peripheral is not busy anymore */
          if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_BUSY, SET, HASH_TIMEOUTVALUE) != HAL_OK)
 800a460:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800a464:	4632      	mov	r2, r6
 800a466:	2108      	movs	r1, #8
 800a468:	4620      	mov	r0, r4
 800a46a:	f7ff fed7 	bl	800a21c <HASH_WaitOnFlagUntilTimeout>
 800a46e:	b128      	cbz	r0, 800a47c <HAL_HASH_IRQHandler+0x164>
          {
            /* Disable Interrupts */
            __HAL_HASH_DISABLE_IT(HASH_IT_DINI|HASH_IT_DCI);
 800a470:	6a2b      	ldr	r3, [r5, #32]
 800a472:	f023 0303 	bic.w	r3, r3, #3
 800a476:	622b      	str	r3, [r5, #32]
            return HAL_TIMEOUT;
 800a478:	4638      	mov	r0, r7
 800a47a:	e034      	b.n	800a4e6 <HAL_HASH_IRQHandler+0x1ce>
          }
          /* Initialization start for HMAC STEP 2 */
          hhash->Phase = HAL_HASH_PHASE_HMAC_STEP_2;        /* Move phase from Step 1 to Step 2 */
 800a47c:	2304      	movs	r3, #4
          __HAL_HASH_SET_NBVALIDBITS(hhash->HashBuffSize);  /* Set NBLW for the input message */
 800a47e:	69e2      	ldr	r2, [r4, #28]
            /* Disable Interrupts */
            __HAL_HASH_DISABLE_IT(HASH_IT_DINI|HASH_IT_DCI);
            return HAL_TIMEOUT;
          }
          /* Initialization start for HMAC STEP 2 */
          hhash->Phase = HAL_HASH_PHASE_HMAC_STEP_2;        /* Move phase from Step 1 to Step 2 */
 800a480:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
          __HAL_HASH_SET_NBVALIDBITS(hhash->HashBuffSize);  /* Set NBLW for the input message */
 800a484:	68ab      	ldr	r3, [r5, #8]
 800a486:	f002 0103 	and.w	r1, r2, #3
 800a48a:	f023 031f 	bic.w	r3, r3, #31
 800a48e:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800a492:	60ab      	str	r3, [r5, #8]
          hhash->HashInCount = hhash->HashBuffSize;         /* Set the input data size (in bytes) */
 800a494:	6222      	str	r2, [r4, #32]
          hhash->pHashInBuffPtr = hhash->pHashMsgBuffPtr;   /* Set the input data address */
 800a496:	69a3      	ldr	r3, [r4, #24]
 800a498:	e01d      	b.n	800a4d6 <HAL_HASH_IRQHandler+0x1be>
          hhash->HashITCounter = 1;                         /* Set ITCounter to 1 to indicate the start of a new phase */
          __HAL_HASH_ENABLE_IT(HASH_IT_DINI);               /* Enable IT (was disabled in HASH_Write_Block_Data) */
        }
        else if (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_2)
 800a49a:	2f04      	cmp	r7, #4
 800a49c:	d131      	bne.n	800a502 <HAL_HASH_IRQHandler+0x1ea>
        {
          /* Wait until Peripheral is not busy anymore */
          if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_BUSY, SET, HASH_TIMEOUTVALUE) != HAL_OK)
 800a49e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800a4a2:	4632      	mov	r2, r6
 800a4a4:	2108      	movs	r1, #8
 800a4a6:	4620      	mov	r0, r4
 800a4a8:	f7ff feb8 	bl	800a21c <HASH_WaitOnFlagUntilTimeout>
 800a4ac:	b128      	cbz	r0, 800a4ba <HAL_HASH_IRQHandler+0x1a2>
          {
            /* Disable Interrupts */
            __HAL_HASH_DISABLE_IT(HASH_IT_DINI|HASH_IT_DCI);
 800a4ae:	6a2b      	ldr	r3, [r5, #32]
 800a4b0:	f023 0303 	bic.w	r3, r3, #3
 800a4b4:	622b      	str	r3, [r5, #32]
            return HAL_TIMEOUT;
 800a4b6:	2003      	movs	r0, #3
 800a4b8:	e015      	b.n	800a4e6 <HAL_HASH_IRQHandler+0x1ce>
          }
          /* Initialization start for HMAC STEP 3 */
          hhash->Phase = HAL_HASH_PHASE_HMAC_STEP_3;         /* Move phase from Step 2 to Step 3 */
 800a4ba:	2305      	movs	r3, #5
          __HAL_HASH_SET_NBVALIDBITS(hhash->Init.KeySize);   /* Set NBLW for the key */
 800a4bc:	6862      	ldr	r2, [r4, #4]
            /* Disable Interrupts */
            __HAL_HASH_DISABLE_IT(HASH_IT_DINI|HASH_IT_DCI);
            return HAL_TIMEOUT;
          }
          /* Initialization start for HMAC STEP 3 */
          hhash->Phase = HAL_HASH_PHASE_HMAC_STEP_3;         /* Move phase from Step 2 to Step 3 */
 800a4be:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
          __HAL_HASH_SET_NBVALIDBITS(hhash->Init.KeySize);   /* Set NBLW for the key */
 800a4c2:	68ab      	ldr	r3, [r5, #8]
 800a4c4:	f002 0103 	and.w	r1, r2, #3
 800a4c8:	f023 031f 	bic.w	r3, r3, #31
 800a4cc:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800a4d0:	60ab      	str	r3, [r5, #8]
          hhash->HashInCount = hhash->Init.KeySize;          /* Set the key size (in bytes) */
          hhash->pHashInBuffPtr = hhash->Init.pKey;          /* Set the key address */
 800a4d2:	68a3      	ldr	r3, [r4, #8]
            return HAL_TIMEOUT;
          }
          /* Initialization start for HMAC STEP 3 */
          hhash->Phase = HAL_HASH_PHASE_HMAC_STEP_3;         /* Move phase from Step 2 to Step 3 */
          __HAL_HASH_SET_NBVALIDBITS(hhash->Init.KeySize);   /* Set NBLW for the key */
          hhash->HashInCount = hhash->Init.KeySize;          /* Set the key size (in bytes) */
 800a4d4:	6222      	str	r2, [r4, #32]
          hhash->pHashInBuffPtr = hhash->Init.pKey;          /* Set the key address */
          hhash->HashITCounter = 1;                          /* Set ITCounter to 1 to indicate the start of a new phase */
 800a4d6:	6266      	str	r6, [r4, #36]	; 0x24
          }
          /* Initialization start for HMAC STEP 3 */
          hhash->Phase = HAL_HASH_PHASE_HMAC_STEP_3;         /* Move phase from Step 2 to Step 3 */
          __HAL_HASH_SET_NBVALIDBITS(hhash->Init.KeySize);   /* Set NBLW for the key */
          hhash->HashInCount = hhash->Init.KeySize;          /* Set the key size (in bytes) */
          hhash->pHashInBuffPtr = hhash->Init.pKey;          /* Set the key address */
 800a4d8:	60e3      	str	r3, [r4, #12]
          hhash->HashITCounter = 1;                          /* Set ITCounter to 1 to indicate the start of a new phase */
          __HAL_HASH_ENABLE_IT(HASH_IT_DINI);                /* Enable IT (was disabled in HASH_Write_Block_Data) */
 800a4da:	6a2b      	ldr	r3, [r5, #32]
 800a4dc:	f043 0301 	orr.w	r3, r3, #1
 800a4e0:	622b      	str	r3, [r5, #32]
 800a4e2:	e000      	b.n	800a4e6 <HAL_HASH_IRQHandler+0x1ce>
    /* Return function status */
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 800a4e4:	2002      	movs	r0, #2
  *        manage the error. The error type is available in hhash->Status field.
  * @retval None
  */
void HAL_HASH_IRQHandler(HASH_HandleTypeDef *hhash)
{
  hhash->Status = HASH_IT(hhash);
 800a4e6:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
  if (hhash->Status != HAL_OK)
 800a4ea:	b160      	cbz	r0, 800a506 <HAL_HASH_IRQHandler+0x1ee>
  {
    hhash->ErrorCode |= HAL_HASH_ERROR_IT;
 800a4ec:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800a4ee:	f043 0301 	orr.w	r3, r3, #1
 800a4f2:	63e3      	str	r3, [r4, #60]	; 0x3c
#if (USE_HAL_HASH_REGISTER_CALLBACKS == 1)
    hhash->ErrorCallback(hhash);
#else
    HAL_HASH_ErrorCallback(hhash);
 800a4f4:	4620      	mov	r0, r4
 800a4f6:	f7ff ff0e 	bl	800a316 <HAL_HASH_ErrorCallback>
#endif /* USE_HAL_HASH_REGISTER_CALLBACKS */
    /* After error handling by code user, reset HASH handle HAL status */
    hhash->Status = HAL_OK;
 800a4fa:	2300      	movs	r3, #0
 800a4fc:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  }
}
 800a500:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        }
      } /* if (HASH_Write_Block_Data(hhash) == HASH_DIGEST_CALCULATION_STARTED) */
    }  /* if (__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))*/

    /* Return function status */
    return HAL_OK;
 800a502:	2000      	movs	r0, #0
 800a504:	e7ef      	b.n	800a4e6 <HAL_HASH_IRQHandler+0x1ce>
 800a506:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a508:	50060400 	.word	0x50060400
 800a50c:	00040080 	.word	0x00040080

0800a510 <HAL_HASH_GetState>:
  * @param  hhash HASH handle.
  * @retval HAL HASH state
  */
HAL_HASH_StateTypeDef HAL_HASH_GetState(HASH_HandleTypeDef *hhash)
{
  return hhash->State;
 800a510:	f890 0035 	ldrb.w	r0, [r0, #53]	; 0x35
}
 800a514:	4770      	bx	lr

0800a516 <HAL_HASH_GetStatus>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASH_GetStatus(HASH_HandleTypeDef *hhash)
{
  return hhash->Status;
}
 800a516:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 800a51a:	4770      	bx	lr

0800a51c <HAL_HASH_ContextSaving>:

  /* Prevent unused argument(s) compilation warning */
  UNUSED(hhash);

  /* Save IMR register content */
  *(uint32_t*)(mem_ptr) = READ_BIT(HASH->IMR,HASH_IT_DINI|HASH_IT_DCI);
 800a51c:	4b0b      	ldr	r3, [pc, #44]	; (800a54c <HAL_HASH_ContextSaving+0x30>)
 800a51e:	6a1a      	ldr	r2, [r3, #32]
 800a520:	f002 0203 	and.w	r2, r2, #3
 800a524:	600a      	str	r2, [r1, #0]
  mem_ptr+=4U;
  /* Save STR register content */
  *(uint32_t*)(mem_ptr) = READ_BIT(HASH->STR,HASH_STR_NBLW);
 800a526:	689a      	ldr	r2, [r3, #8]
 800a528:	f002 021f 	and.w	r2, r2, #31
 800a52c:	604a      	str	r2, [r1, #4]
  mem_ptr+=4U;
  /* Save CR register content */
  *(uint32_t*)(mem_ptr) = READ_BIT(HASH->CR,HASH_CR_DMAE|HASH_CR_DATATYPE|HASH_CR_MODE|HASH_CR_ALGO|HASH_CR_LKEY|HASH_CR_MDMAT);
 800a52e:	681a      	ldr	r2, [r3, #0]
 800a530:	4b07      	ldr	r3, [pc, #28]	; (800a550 <HAL_HASH_ContextSaving+0x34>)
 800a532:	4013      	ands	r3, r2
 800a534:	608b      	str	r3, [r1, #8]
  mem_ptr+=4U;
  /* By default, save all CSRs registers */
  for (i = HASH_NUMBER_OF_CSR_REGISTERS; i >0U; i--)
 800a536:	4a07      	ldr	r2, [pc, #28]	; (800a554 <HAL_HASH_ContextSaving+0x38>)
  /* Save STR register content */
  *(uint32_t*)(mem_ptr) = READ_BIT(HASH->STR,HASH_STR_NBLW);
  mem_ptr+=4U;
  /* Save CR register content */
  *(uint32_t*)(mem_ptr) = READ_BIT(HASH->CR,HASH_CR_DMAE|HASH_CR_DATATYPE|HASH_CR_MODE|HASH_CR_ALGO|HASH_CR_LKEY|HASH_CR_MDMAT);
  mem_ptr+=4U;
 800a538:	4b07      	ldr	r3, [pc, #28]	; (800a558 <HAL_HASH_ContextSaving+0x3c>)
 800a53a:	310c      	adds	r1, #12
  /* By default, save all CSRs registers */
  for (i = HASH_NUMBER_OF_CSR_REGISTERS; i >0U; i--)
  {
    *(uint32_t*)(mem_ptr) = *(uint32_t*)(csr_ptr);
 800a53c:	f853 0f04 	ldr.w	r0, [r3, #4]!
 800a540:	f841 0b04 	str.w	r0, [r1], #4
  mem_ptr+=4U;
  /* Save CR register content */
  *(uint32_t*)(mem_ptr) = READ_BIT(HASH->CR,HASH_CR_DMAE|HASH_CR_DATATYPE|HASH_CR_MODE|HASH_CR_ALGO|HASH_CR_LKEY|HASH_CR_MDMAT);
  mem_ptr+=4U;
  /* By default, save all CSRs registers */
  for (i = HASH_NUMBER_OF_CSR_REGISTERS; i >0U; i--)
 800a544:	4293      	cmp	r3, r2
 800a546:	d1f9      	bne.n	800a53c <HAL_HASH_ContextSaving+0x20>
  {
    *(uint32_t*)(mem_ptr) = *(uint32_t*)(csr_ptr);
    mem_ptr+=4U;
    csr_ptr+=4U;
  }
}
 800a548:	4770      	bx	lr
 800a54a:	bf00      	nop
 800a54c:	50060400 	.word	0x50060400
 800a550:	000520f8 	.word	0x000520f8
 800a554:	500605cc 	.word	0x500605cc
 800a558:	500604f4 	.word	0x500604f4

0800a55c <HAL_HASH_ContextRestoring>:

  /* Prevent unused argument(s) compilation warning */
  UNUSED(hhash);

  /* Restore IMR register content */
  WRITE_REG(HASH->IMR, (*(uint32_t*)(mem_ptr)));
 800a55c:	4b0a      	ldr	r3, [pc, #40]	; (800a588 <HAL_HASH_ContextRestoring+0x2c>)
 800a55e:	680a      	ldr	r2, [r1, #0]
 800a560:	621a      	str	r2, [r3, #32]
  mem_ptr+=4U;
  /* Restore STR register content */
  WRITE_REG(HASH->STR, (*(uint32_t*)(mem_ptr)));
 800a562:	684a      	ldr	r2, [r1, #4]
 800a564:	609a      	str	r2, [r3, #8]
  mem_ptr+=4U;
  /* Restore CR register content */
  WRITE_REG(HASH->CR, (*(uint32_t*)(mem_ptr)));
 800a566:	688a      	ldr	r2, [r1, #8]
 800a568:	601a      	str	r2, [r3, #0]
  mem_ptr+=4U;

  /* Reset the HASH processor before restoring the Context
  Swap Registers (CSR) */
  __HAL_HASH_INIT();
 800a56a:	681a      	ldr	r2, [r3, #0]
 800a56c:	f042 0204 	orr.w	r2, r2, #4
 800a570:	601a      	str	r2, [r3, #0]

  /* By default, restore all CSR registers */
  for (i = HASH_NUMBER_OF_CSR_REGISTERS; i >0U; i--)
 800a572:	4a06      	ldr	r2, [pc, #24]	; (800a58c <HAL_HASH_ContextRestoring+0x30>)
  WRITE_REG(HASH->CR, (*(uint32_t*)(mem_ptr)));
  mem_ptr+=4U;

  /* Reset the HASH processor before restoring the Context
  Swap Registers (CSR) */
  __HAL_HASH_INIT();
 800a574:	3108      	adds	r1, #8
  * @retval None
  */
void HAL_HASH_ContextRestoring(HASH_HandleTypeDef *hhash, uint8_t* pMemBuffer)
{
  uint32_t mem_ptr = (uint32_t)pMemBuffer;
  uint32_t csr_ptr = (uint32_t)HASH->CSR;
 800a576:	33f8      	adds	r3, #248	; 0xf8
  __HAL_HASH_INIT();

  /* By default, restore all CSR registers */
  for (i = HASH_NUMBER_OF_CSR_REGISTERS; i >0U; i--)
  {
    WRITE_REG((*(uint32_t*)(csr_ptr)), (*(uint32_t*)(mem_ptr)));
 800a578:	f851 0f04 	ldr.w	r0, [r1, #4]!
 800a57c:	f843 0b04 	str.w	r0, [r3], #4
  /* Reset the HASH processor before restoring the Context
  Swap Registers (CSR) */
  __HAL_HASH_INIT();

  /* By default, restore all CSR registers */
  for (i = HASH_NUMBER_OF_CSR_REGISTERS; i >0U; i--)
 800a580:	4293      	cmp	r3, r2
 800a582:	d1f9      	bne.n	800a578 <HAL_HASH_ContextRestoring+0x1c>
  {
    WRITE_REG((*(uint32_t*)(csr_ptr)), (*(uint32_t*)(mem_ptr)));
    mem_ptr+=4U;
    csr_ptr+=4U;
  }
}
 800a584:	4770      	bx	lr
 800a586:	bf00      	nop
 800a588:	50060400 	.word	0x50060400
 800a58c:	500605d0 	.word	0x500605d0

0800a590 <HAL_HASH_SwFeed_ProcessSuspend>:
  * @retval None
  */
void HAL_HASH_SwFeed_ProcessSuspend(HASH_HandleTypeDef *hhash)
{
  /* Set Handle Suspend Request field */
  hhash->SuspendRequest = HAL_HASH_SUSPEND;
 800a590:	2301      	movs	r3, #1
 800a592:	f880 3036 	strb.w	r3, [r0, #54]	; 0x36
 800a596:	4770      	bx	lr

0800a598 <HAL_HASH_GetError>:
  * @retval HASH Error Code
*/
uint32_t HAL_HASH_GetError(HASH_HandleTypeDef *hhash)
{
  /* Return HASH Error Code */
  return hhash->ErrorCode;
 800a598:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
}
 800a59a:	4770      	bx	lr

0800a59c <HASH_Start>:
  * @param  Timeout Timeout value.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout, uint32_t Algorithm)
{
 800a59c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a59e:	461e      	mov	r6, r3
  uint8_t *pInBuffer_tmp;  /* input data address, input parameter of HASH_WriteData()         */
  uint32_t Size_tmp; /* input data size (in bytes), input parameter of HASH_WriteData() */
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 800a5a0:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 800a5a4:	b2db      	uxtb	r3, r3


  /* Initiate HASH processing in case of start or resumption */
if((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 800a5a6:	2b01      	cmp	r3, #1
  * @param  Timeout Timeout value.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout, uint32_t Algorithm)
{
 800a5a8:	4604      	mov	r4, r0
  uint32_t Size_tmp; /* input data size (in bytes), input parameter of HASH_WriteData() */
  HAL_HASH_StateTypeDef State_tmp = hhash->State;


  /* Initiate HASH processing in case of start or resumption */
if((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 800a5aa:	d001      	beq.n	800a5b0 <HASH_Start+0x14>
 800a5ac:	2b08      	cmp	r3, #8
 800a5ae:	d17c      	bne.n	800a6aa <HASH_Start+0x10e>
  {
    /* Check input parameters */
    if ((pInBuffer == NULL) || (pOutBuffer == NULL))
 800a5b0:	b101      	cbz	r1, 800a5b4 <HASH_Start+0x18>
 800a5b2:	b91e      	cbnz	r6, 800a5bc <HASH_Start+0x20>
    {
      hhash->State = HAL_HASH_STATE_READY;
 800a5b4:	2501      	movs	r5, #1
 800a5b6:	f884 5035 	strb.w	r5, [r4, #53]	; 0x35
      return  HAL_ERROR;
 800a5ba:	e079      	b.n	800a6b0 <HASH_Start+0x114>
    }

    /* Process Locked */
    __HAL_LOCK(hhash);
 800a5bc:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 800a5c0:	2b01      	cmp	r3, #1
 800a5c2:	d072      	beq.n	800a6aa <HASH_Start+0x10e>

    /* Check if initialization phase has not been already performed */
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 800a5c4:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
      hhash->State = HAL_HASH_STATE_READY;
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(hhash);
 800a5c8:	2501      	movs	r5, #1

    /* Check if initialization phase has not been already performed */
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 800a5ca:	42ab      	cmp	r3, r5
      hhash->State = HAL_HASH_STATE_READY;
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(hhash);
 800a5cc:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34

    /* Check if initialization phase has not been already performed */
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 800a5d0:	d118      	bne.n	800a604 <HASH_Start+0x68>
    {
      /* Change the HASH state */
      hhash->State = HAL_HASH_STATE_BUSY;

      /* Select the HASH algorithm, clear HMAC mode and long key selection bit, reset the HASH processor core */
      MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);
 800a5d2:	4d38      	ldr	r5, [pc, #224]	; (800a6b4 <HASH_Start+0x118>)
 800a5d4:	9807      	ldr	r0, [sp, #28]

    /* Check if initialization phase has not been already performed */
    if(hhash->Phase == HAL_HASH_PHASE_READY)
    {
      /* Change the HASH state */
      hhash->State = HAL_HASH_STATE_BUSY;
 800a5d6:	2702      	movs	r7, #2
 800a5d8:	f884 7035 	strb.w	r7, [r4, #53]	; 0x35

      /* Select the HASH algorithm, clear HMAC mode and long key selection bit, reset the HASH processor core */
      MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);
 800a5dc:	682b      	ldr	r3, [r5, #0]
 800a5de:	f423 23a0 	bic.w	r3, r3, #327680	; 0x50000
 800a5e2:	f023 03c4 	bic.w	r3, r3, #196	; 0xc4
 800a5e6:	f043 0304 	orr.w	r3, r3, #4
 800a5ea:	4303      	orrs	r3, r0
 800a5ec:	602b      	str	r3, [r5, #0]

      /* Configure the number of valid bits in last word of the message */
      __HAL_HASH_SET_NBVALIDBITS(Size);
 800a5ee:	68a8      	ldr	r0, [r5, #8]
 800a5f0:	f002 0303 	and.w	r3, r2, #3
 800a5f4:	f020 001f 	bic.w	r0, r0, #31
 800a5f8:	ea40 03c3 	orr.w	r3, r0, r3, lsl #3
 800a5fc:	60ab      	str	r3, [r5, #8]
      input parameters of HASH_WriteData() */
      pInBuffer_tmp = pInBuffer;   /* pInBuffer_tmp is set to the input data address */
      Size_tmp = Size;             /* Size_tmp contains the input data size in bytes */

      /* Set the phase */
      hhash->Phase = HAL_HASH_PHASE_PROCESS;
 800a5fe:	f884 702d 	strb.w	r7, [r4, #45]	; 0x2d
 800a602:	e018      	b.n	800a636 <HASH_Start+0x9a>
    }
    else if (hhash->Phase == HAL_HASH_PHASE_PROCESS)
 800a604:	2b02      	cmp	r3, #2
 800a606:	d113      	bne.n	800a630 <HASH_Start+0x94>
    {
      /* if the Peripheral has already been initialized, two cases are possible */

      /* Process resumption time ... */
      if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 800a608:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 800a60c:	2b08      	cmp	r3, #8
        /* pInBuffer_tmp and Size_tmp are initialized to be used afterwards as
        input parameters of HASH_WriteData() */
        pInBuffer_tmp = pInBuffer;
        Size_tmp = Size;
        /* Configure the number of valid bits in last word of the message */
        __HAL_HASH_SET_NBVALIDBITS(Size);
 800a60e:	bf15      	itete	ne
 800a610:	4d28      	ldrne	r5, [pc, #160]	; (800a6b4 <HASH_Start+0x118>)
      {
        /* Since this is resumption, pInBuffer_tmp and Size_tmp are not set
        to the API input parameters but to those saved beforehand by HASH_WriteData()
        when the processing was suspended */
        pInBuffer_tmp = hhash->pHashInBuffPtr;
        Size_tmp = hhash->HashInCount;
 800a612:	6a22      	ldreq	r2, [r4, #32]
        /* pInBuffer_tmp and Size_tmp are initialized to be used afterwards as
        input parameters of HASH_WriteData() */
        pInBuffer_tmp = pInBuffer;
        Size_tmp = Size;
        /* Configure the number of valid bits in last word of the message */
        __HAL_HASH_SET_NBVALIDBITS(Size);
 800a614:	68a8      	ldrne	r0, [r5, #8]
      if (hhash->State == HAL_HASH_STATE_SUSPENDED)
      {
        /* Since this is resumption, pInBuffer_tmp and Size_tmp are not set
        to the API input parameters but to those saved beforehand by HASH_WriteData()
        when the processing was suspended */
        pInBuffer_tmp = hhash->pHashInBuffPtr;
 800a616:	68e1      	ldreq	r1, [r4, #12]
        /* pInBuffer_tmp and Size_tmp are initialized to be used afterwards as
        input parameters of HASH_WriteData() */
        pInBuffer_tmp = pInBuffer;
        Size_tmp = Size;
        /* Configure the number of valid bits in last word of the message */
        __HAL_HASH_SET_NBVALIDBITS(Size);
 800a618:	bf1f      	itttt	ne
 800a61a:	f002 0303 	andne.w	r3, r2, #3
 800a61e:	f020 001f 	bicne.w	r0, r0, #31
 800a622:	ea40 03c3 	orrne.w	r3, r0, r3, lsl #3
 800a626:	60ab      	strne	r3, [r5, #8]
      }
      /* Change the HASH state */
      hhash->State = HAL_HASH_STATE_BUSY;
 800a628:	2302      	movs	r3, #2
 800a62a:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
 800a62e:	e002      	b.n	800a636 <HASH_Start+0x9a>
    }
    else
    {
      /* Phase error */
      hhash->State = HAL_HASH_STATE_READY;
 800a630:	f884 5035 	strb.w	r5, [r4, #53]	; 0x35
 800a634:	e035      	b.n	800a6a2 <HASH_Start+0x106>
      return HAL_ERROR;
    }


    /* Write input buffer in Data register */
    hhash->Status = HASH_WriteData(hhash, pInBuffer_tmp, Size_tmp);
 800a636:	4620      	mov	r0, r4
 800a638:	f7ff fd4c 	bl	800a0d4 <HASH_WriteData>
 800a63c:	4605      	mov	r5, r0
 800a63e:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
    if (hhash->Status != HAL_OK)
 800a642:	2800      	cmp	r0, #0
 800a644:	d134      	bne.n	800a6b0 <HASH_Start+0x114>
    {
      return hhash->Status;
    }

    /* If the process has not been suspended, carry on to digest calculation */
    if (hhash->State != HAL_HASH_STATE_SUSPENDED)
 800a646:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 800a64a:	2b08      	cmp	r3, #8
 800a64c:	d029      	beq.n	800a6a2 <HASH_Start+0x106>
    {
      /* Start the Digest calculation */
      __HAL_HASH_START_DIGEST();
 800a64e:	4f19      	ldr	r7, [pc, #100]	; (800a6b4 <HASH_Start+0x118>)
 800a650:	68bb      	ldr	r3, [r7, #8]
 800a652:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800a656:	60bb      	str	r3, [r7, #8]

      /* Wait for DCIS flag to be set */
      if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
 800a658:	4602      	mov	r2, r0
 800a65a:	9b06      	ldr	r3, [sp, #24]
 800a65c:	2102      	movs	r1, #2
 800a65e:	4620      	mov	r0, r4
 800a660:	f7ff fddc 	bl	800a21c <HASH_WaitOnFlagUntilTimeout>
 800a664:	bb18      	cbnz	r0, 800a6ae <HASH_Start+0x112>
      {
        return HAL_TIMEOUT;
      }

      /* Read the message digest */
      HASH_GetDigest(pOutBuffer, HASH_DIGEST_LENGTH());
 800a666:	683a      	ldr	r2, [r7, #0]
 800a668:	4b13      	ldr	r3, [pc, #76]	; (800a6b8 <HASH_Start+0x11c>)
 800a66a:	4013      	ands	r3, r2
 800a66c:	b173      	cbz	r3, 800a68c <HASH_Start+0xf0>
 800a66e:	683a      	ldr	r2, [r7, #0]
 800a670:	4b11      	ldr	r3, [pc, #68]	; (800a6b8 <HASH_Start+0x11c>)
 800a672:	4013      	ands	r3, r2
 800a674:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800a678:	d00a      	beq.n	800a690 <HASH_Start+0xf4>
 800a67a:	683a      	ldr	r2, [r7, #0]
 800a67c:	4b0e      	ldr	r3, [pc, #56]	; (800a6b8 <HASH_Start+0x11c>)
 800a67e:	490e      	ldr	r1, [pc, #56]	; (800a6b8 <HASH_Start+0x11c>)
 800a680:	4013      	ands	r3, r2
 800a682:	428b      	cmp	r3, r1
 800a684:	bf0c      	ite	eq
 800a686:	2120      	moveq	r1, #32
 800a688:	2110      	movne	r1, #16
 800a68a:	e002      	b.n	800a692 <HASH_Start+0xf6>
 800a68c:	2114      	movs	r1, #20
 800a68e:	e000      	b.n	800a692 <HASH_Start+0xf6>
 800a690:	211c      	movs	r1, #28
 800a692:	4630      	mov	r0, r6
 800a694:	f7ff fd60 	bl	800a158 <HASH_GetDigest>

      /* Change the HASH state */
      hhash->State = HAL_HASH_STATE_READY;
 800a698:	2301      	movs	r3, #1
 800a69a:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

      /* Reset HASH state machine */
      hhash->Phase = HAL_HASH_PHASE_READY;
 800a69e:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d

    }

    /* Process Unlocked */
    __HAL_UNLOCK(hhash);
 800a6a2:	2300      	movs	r3, #0
 800a6a4:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800a6a8:	e002      	b.n	800a6b0 <HASH_Start+0x114>
    return HAL_OK;

  }
  else
  {
    return HAL_BUSY;
 800a6aa:	2502      	movs	r5, #2
 800a6ac:	e000      	b.n	800a6b0 <HASH_Start+0x114>
      __HAL_HASH_START_DIGEST();

      /* Wait for DCIS flag to be set */
      if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
      {
        return HAL_TIMEOUT;
 800a6ae:	2503      	movs	r5, #3
  }
  else
  {
    return HAL_BUSY;
  }
}
 800a6b0:	4628      	mov	r0, r5
 800a6b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a6b4:	50060400 	.word	0x50060400
 800a6b8:	00040080 	.word	0x00040080

0800a6bc <HAL_HASH_MD5_Accmlt_End>:
  * @param  pOutBuffer pointer to the computed digest. Digest size is 16 bytes.
  * @param  Timeout Timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASH_MD5_Accmlt_End(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout)
{
 800a6bc:	b513      	push	{r0, r1, r4, lr}
  return HASH_Start(hhash, pInBuffer, Size, pOutBuffer, Timeout, HASH_ALGOSELECTION_MD5);
 800a6be:	2480      	movs	r4, #128	; 0x80
 800a6c0:	9401      	str	r4, [sp, #4]
 800a6c2:	9c04      	ldr	r4, [sp, #16]
 800a6c4:	9400      	str	r4, [sp, #0]
 800a6c6:	f7ff ff69 	bl	800a59c <HASH_Start>
}
 800a6ca:	b002      	add	sp, #8
 800a6cc:	bd10      	pop	{r4, pc}

0800a6ce <HAL_HASH_MD5_Start>:
 800a6ce:	f7ff bff5 	b.w	800a6bc <HAL_HASH_MD5_Accmlt_End>

0800a6d2 <HAL_HASH_SHA1_Accmlt_End>:
  * @param  pOutBuffer pointer to the computed digest. Digest size is 20 bytes.
  * @param  Timeout Timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASH_SHA1_Accmlt_End(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout)
{
 800a6d2:	b513      	push	{r0, r1, r4, lr}
  return HASH_Start(hhash, pInBuffer, Size, pOutBuffer, Timeout, HASH_ALGOSELECTION_SHA1);
 800a6d4:	2400      	movs	r4, #0
 800a6d6:	9401      	str	r4, [sp, #4]
 800a6d8:	9c04      	ldr	r4, [sp, #16]
 800a6da:	9400      	str	r4, [sp, #0]
 800a6dc:	f7ff ff5e 	bl	800a59c <HASH_Start>
}
 800a6e0:	b002      	add	sp, #8
 800a6e2:	bd10      	pop	{r4, pc}

0800a6e4 <HAL_HASH_SHA1_Start>:
 800a6e4:	f7ff bff5 	b.w	800a6d2 <HAL_HASH_SHA1_Accmlt_End>

0800a6e8 <HASH_Accumulate>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Accumulate(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint32_t Algorithm)
{
 800a6e8:	b538      	push	{r3, r4, r5, lr}
  uint8_t *pInBuffer_tmp;   /* input data address, input parameter of HASH_WriteData()         */
  uint32_t Size_tmp;  /* input data size (in bytes), input parameter of HASH_WriteData() */
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 800a6ea:	f890 5035 	ldrb.w	r5, [r0, #53]	; 0x35
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Accumulate(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint32_t Algorithm)
{
 800a6ee:	4604      	mov	r4, r0
  uint8_t *pInBuffer_tmp;   /* input data address, input parameter of HASH_WriteData()         */
  uint32_t Size_tmp;  /* input data size (in bytes), input parameter of HASH_WriteData() */
  HAL_HASH_StateTypeDef State_tmp = hhash->State;

  /* Make sure the input buffer size (in bytes) is a multiple of 4 */
  if ((Size % 4U) != 0U)
 800a6f0:	0790      	lsls	r0, r2, #30
  */
HAL_StatusTypeDef HASH_Accumulate(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint32_t Algorithm)
{
  uint8_t *pInBuffer_tmp;   /* input data address, input parameter of HASH_WriteData()         */
  uint32_t Size_tmp;  /* input data size (in bytes), input parameter of HASH_WriteData() */
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 800a6f2:	b2ed      	uxtb	r5, r5

  /* Make sure the input buffer size (in bytes) is a multiple of 4 */
  if ((Size % 4U) != 0U)
 800a6f4:	d13d      	bne.n	800a772 <HASH_Accumulate+0x8a>
  {
    return  HAL_ERROR;
  }

  /* Initiate HASH processing in case of start or resumption */
if((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 800a6f6:	2d01      	cmp	r5, #1
 800a6f8:	d001      	beq.n	800a6fe <HASH_Accumulate+0x16>
 800a6fa:	2d08      	cmp	r5, #8
 800a6fc:	d13b      	bne.n	800a776 <HASH_Accumulate+0x8e>
  {
    /* Check input parameters */
    if ((pInBuffer == NULL) || (Size == 0U))
 800a6fe:	b101      	cbz	r1, 800a702 <HASH_Accumulate+0x1a>
 800a700:	b91a      	cbnz	r2, 800a70a <HASH_Accumulate+0x22>
    {
      hhash->State = HAL_HASH_STATE_READY;
 800a702:	2001      	movs	r0, #1
 800a704:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
      return  HAL_ERROR;
 800a708:	bd38      	pop	{r3, r4, r5, pc}
    }

     /* Process Locked */
    __HAL_LOCK(hhash);
 800a70a:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 800a70e:	2801      	cmp	r0, #1
 800a710:	d031      	beq.n	800a776 <HASH_Accumulate+0x8e>
 800a712:	2001      	movs	r0, #1
 800a714:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34

    /* If resuming the HASH processing */
    if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 800a718:	f894 0035 	ldrb.w	r0, [r4, #53]	; 0x35
 800a71c:	2808      	cmp	r0, #8
 800a71e:	f04f 0002 	mov.w	r0, #2
    {
      /* Change the HASH state */
      hhash->State = HAL_HASH_STATE_BUSY;
 800a722:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35

     /* Process Locked */
    __HAL_LOCK(hhash);

    /* If resuming the HASH processing */
    if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 800a726:	d102      	bne.n	800a72e <HASH_Accumulate+0x46>
      hhash->State = HAL_HASH_STATE_BUSY;

      /* Since this is resumption, pInBuffer_tmp and Size_tmp are not set
         to the API input parameters but to those saved beforehand by HASH_WriteData()
         when the processing was suspended */
      pInBuffer_tmp = hhash->pHashInBuffPtr;  /* pInBuffer_tmp is set to the input data address */
 800a728:	68e1      	ldr	r1, [r4, #12]
      Size_tmp = hhash->HashInCount;          /* Size_tmp contains the input data size in bytes */
 800a72a:	6a22      	ldr	r2, [r4, #32]
 800a72c:	e010      	b.n	800a750 <HASH_Accumulate+0x68>
         input parameters of HASH_WriteData() */
      pInBuffer_tmp = pInBuffer;    /* pInBuffer_tmp is set to the input data address */
      Size_tmp = Size;              /* Size_tmp contains the input data size in bytes */

      /* Check if initialization phase has already be performed */
      if(hhash->Phase == HAL_HASH_PHASE_READY)
 800a72e:	f894 002d 	ldrb.w	r0, [r4, #45]	; 0x2d
 800a732:	2801      	cmp	r0, #1
 800a734:	d109      	bne.n	800a74a <HASH_Accumulate+0x62>
      {
        /* Select the HASH algorithm, clear HMAC mode and long key selection bit, reset the HASH processor core */
        MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);
 800a736:	4d11      	ldr	r5, [pc, #68]	; (800a77c <HASH_Accumulate+0x94>)
 800a738:	6828      	ldr	r0, [r5, #0]
 800a73a:	f420 20a0 	bic.w	r0, r0, #327680	; 0x50000
 800a73e:	f020 00c4 	bic.w	r0, r0, #196	; 0xc4
 800a742:	f040 0004 	orr.w	r0, r0, #4
 800a746:	4318      	orrs	r0, r3
 800a748:	6028      	str	r0, [r5, #0]
      }

      /* Set the phase */
      hhash->Phase = HAL_HASH_PHASE_PROCESS;
 800a74a:	2302      	movs	r3, #2
 800a74c:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d

    }

    /* Write input buffer in Data register */
    hhash->Status = HASH_WriteData(hhash, pInBuffer_tmp, Size_tmp);
 800a750:	4620      	mov	r0, r4
 800a752:	f7ff fcbf 	bl	800a0d4 <HASH_WriteData>
 800a756:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
    if (hhash->Status != HAL_OK)
 800a75a:	b968      	cbnz	r0, 800a778 <HASH_Accumulate+0x90>
    {
      return hhash->Status;
    }

    /* If the process has not been suspended, move the state to Ready */
    if (hhash->State != HAL_HASH_STATE_SUSPENDED)
 800a75c:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 800a760:	2b08      	cmp	r3, #8
    {
      /* Change the HASH state */
      hhash->State = HAL_HASH_STATE_READY;
 800a762:	bf1c      	itt	ne
 800a764:	2301      	movne	r3, #1
 800a766:	f884 3035 	strbne.w	r3, [r4, #53]	; 0x35
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hhash);
 800a76a:	2300      	movs	r3, #0
 800a76c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800a770:	bd38      	pop	{r3, r4, r5, pc}
  HAL_HASH_StateTypeDef State_tmp = hhash->State;

  /* Make sure the input buffer size (in bytes) is a multiple of 4 */
  if ((Size % 4U) != 0U)
  {
    return  HAL_ERROR;
 800a772:	2001      	movs	r0, #1
 800a774:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_OK;

  }
  else
  {
    return HAL_BUSY;
 800a776:	2002      	movs	r0, #2
  }


}
 800a778:	bd38      	pop	{r3, r4, r5, pc}
 800a77a:	bf00      	nop
 800a77c:	50060400 	.word	0x50060400

0800a780 <HAL_HASH_MD5_Accmlt>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASH_MD5_Accmlt(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
  return  HASH_Accumulate(hhash, pInBuffer, Size,HASH_ALGOSELECTION_MD5);
 800a780:	2380      	movs	r3, #128	; 0x80
 800a782:	f7ff bfb1 	b.w	800a6e8 <HASH_Accumulate>

0800a786 <HAL_HASH_SHA1_Accmlt>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASH_SHA1_Accmlt(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
  return  HASH_Accumulate(hhash, pInBuffer, Size,HASH_ALGOSELECTION_SHA1);
 800a786:	2300      	movs	r3, #0
 800a788:	f7ff bfae 	b.w	800a6e8 <HASH_Accumulate>

0800a78c <HASH_Accumulate_IT>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Accumulate_IT(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint32_t Algorithm)
{
 800a78c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 800a78e:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
  __IO uint32_t inputaddr = (uint32_t) pInBuffer;
 800a792:	9101      	str	r1, [sp, #4]
  uint32_t SizeVar = Size;

  /* Make sure the input buffer size (in bytes) is a multiple of 4 */
  if ((Size % 4U) != 0U)
 800a794:	0795      	lsls	r5, r2, #30
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Accumulate_IT(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint32_t Algorithm)
{
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 800a796:	b2e4      	uxtb	r4, r4
  __IO uint32_t inputaddr = (uint32_t) pInBuffer;
  uint32_t SizeVar = Size;

  /* Make sure the input buffer size (in bytes) is a multiple of 4 */
  if ((Size % 4U) != 0U)
 800a798:	d153      	bne.n	800a842 <HASH_Accumulate_IT+0xb6>
  {
    return  HAL_ERROR;
  }

  /* Initiate HASH processing in case of start or resumption */
  if((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 800a79a:	2c01      	cmp	r4, #1
 800a79c:	d001      	beq.n	800a7a2 <HASH_Accumulate_IT+0x16>
 800a79e:	2c08      	cmp	r4, #8
 800a7a0:	d151      	bne.n	800a846 <HASH_Accumulate_IT+0xba>
  {
    /* Check input parameters */
    if ((pInBuffer == NULL) || (Size == 0U))
 800a7a2:	b101      	cbz	r1, 800a7a6 <HASH_Accumulate_IT+0x1a>
 800a7a4:	b91a      	cbnz	r2, 800a7ae <HASH_Accumulate_IT+0x22>
    {
      hhash->State = HAL_HASH_STATE_READY;
 800a7a6:	2301      	movs	r3, #1
 800a7a8:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
 800a7ac:	e047      	b.n	800a83e <HASH_Accumulate_IT+0xb2>
      return  HAL_ERROR;
    }

     /* Process Locked */
    __HAL_LOCK(hhash);
 800a7ae:	f890 1034 	ldrb.w	r1, [r0, #52]	; 0x34
 800a7b2:	2901      	cmp	r1, #1
 800a7b4:	d047      	beq.n	800a846 <HASH_Accumulate_IT+0xba>
 800a7b6:	2101      	movs	r1, #1
 800a7b8:	f880 1034 	strb.w	r1, [r0, #52]	; 0x34

    /* If resuming the HASH processing */
    if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 800a7bc:	f890 1035 	ldrb.w	r1, [r0, #53]	; 0x35
 800a7c0:	4c22      	ldr	r4, [pc, #136]	; (800a84c <HASH_Accumulate_IT+0xc0>)
 800a7c2:	2908      	cmp	r1, #8
 800a7c4:	f04f 0102 	mov.w	r1, #2
    {
      /* Change the HASH state */
      hhash->State = HAL_HASH_STATE_BUSY;
 800a7c8:	f880 1035 	strb.w	r1, [r0, #53]	; 0x35

     /* Process Locked */
    __HAL_LOCK(hhash);

    /* If resuming the HASH processing */
    if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 800a7cc:	d02e      	beq.n	800a82c <HASH_Accumulate_IT+0xa0>
    {
      /* Change the HASH state */
      hhash->State = HAL_HASH_STATE_BUSY;

      /* Check if initialization phase has already be performed */
      if(hhash->Phase == HAL_HASH_PHASE_READY)
 800a7ce:	f890 502d 	ldrb.w	r5, [r0, #45]	; 0x2d
 800a7d2:	2d01      	cmp	r5, #1
 800a7d4:	d10a      	bne.n	800a7ec <HASH_Accumulate_IT+0x60>
      {
        /* Select the HASH algorithm, clear HMAC mode and long key selection bit, reset the HASH processor core */
        MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);
 800a7d6:	6821      	ldr	r1, [r4, #0]
 800a7d8:	f421 21a0 	bic.w	r1, r1, #327680	; 0x50000
 800a7dc:	f021 01c4 	bic.w	r1, r1, #196	; 0xc4
 800a7e0:	f041 0104 	orr.w	r1, r1, #4
 800a7e4:	4319      	orrs	r1, r3
 800a7e6:	6021      	str	r1, [r4, #0]
        hhash->HashITCounter = 1;
 800a7e8:	6245      	str	r5, [r0, #36]	; 0x24
 800a7ea:	e001      	b.n	800a7f0 <HASH_Accumulate_IT+0x64>
      }
      else
      {
         hhash->HashITCounter = 3; /* 'cruise-speed' reached during a previous buffer processing */
 800a7ec:	2303      	movs	r3, #3
 800a7ee:	6243      	str	r3, [r0, #36]	; 0x24
      }

      /* Set the phase */
      hhash->Phase = HAL_HASH_PHASE_PROCESS;
 800a7f0:	2302      	movs	r3, #2

      /* If DINIS is equal to 0 (for example if an incomplete block has been previously
       fed to the Peripheral), the DINIE interruption won't be triggered when DINIE is set.
       Therefore, first words are manually entered until DINIS raises, or until there
       is not more data to enter. */
      while((!(__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))) && (SizeVar > 0U))
 800a7f2:	4916      	ldr	r1, [pc, #88]	; (800a84c <HASH_Accumulate_IT+0xc0>)
      {
         hhash->HashITCounter = 3; /* 'cruise-speed' reached during a previous buffer processing */
      }

      /* Set the phase */
      hhash->Phase = HAL_HASH_PHASE_PROCESS;
 800a7f4:	f880 302d 	strb.w	r3, [r0, #45]	; 0x2d

      /* If DINIS is equal to 0 (for example if an incomplete block has been previously
       fed to the Peripheral), the DINIE interruption won't be triggered when DINIE is set.
       Therefore, first words are manually entered until DINIS raises, or until there
       is not more data to enter. */
      while((!(__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))) && (SizeVar > 0U))
 800a7f8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a7fa:	07dd      	lsls	r5, r3, #31
 800a7fc:	d408      	bmi.n	800a810 <HASH_Accumulate_IT+0x84>
 800a7fe:	b13a      	cbz	r2, 800a810 <HASH_Accumulate_IT+0x84>
      {

        /* Write input data 4 bytes at a time */
        HASH->DIN = *(uint32_t*)inputaddr;
 800a800:	9b01      	ldr	r3, [sp, #4]
 800a802:	681b      	ldr	r3, [r3, #0]
 800a804:	604b      	str	r3, [r1, #4]
        inputaddr+=4U;
 800a806:	9b01      	ldr	r3, [sp, #4]
 800a808:	3304      	adds	r3, #4
 800a80a:	9301      	str	r3, [sp, #4]
        SizeVar-=4U;
 800a80c:	3a04      	subs	r2, #4
 800a80e:	e7f3      	b.n	800a7f8 <HASH_Accumulate_IT+0x6c>
      }

      /* If DINIS is still not set or if all the data have been fed, stop here */
      if ((!(__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))) || (SizeVar == 0U))
 800a810:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a812:	07db      	lsls	r3, r3, #31
 800a814:	d500      	bpl.n	800a818 <HASH_Accumulate_IT+0x8c>
 800a816:	b932      	cbnz	r2, 800a826 <HASH_Accumulate_IT+0x9a>
      {
        /* Change the HASH state */
        hhash->State = HAL_HASH_STATE_READY;
 800a818:	2301      	movs	r3, #1
 800a81a:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35

        /* Process Unlock */
        __HAL_UNLOCK(hhash);
 800a81e:	2300      	movs	r3, #0
 800a820:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
 800a824:	e00b      	b.n	800a83e <HASH_Accumulate_IT+0xb2>
        /* Return function status */
        return HAL_OK;
      }

      /* otherwise, carry on in interrupt-mode */
      hhash->HashInCount = SizeVar;               /* Counter used to keep track of number of data
 800a826:	6202      	str	r2, [r0, #32]
                                                  to be fed to the Peripheral */
      hhash->pHashInBuffPtr = (uint8_t *)inputaddr;       /* Points at data which will be fed to the Peripheral at
 800a828:	9b01      	ldr	r3, [sp, #4]
 800a82a:	60c3      	str	r3, [r0, #12]
        correct location. */

    }

    /* Set multi buffers accumulation flag */
    hhash->Accumulation = 1U;
 800a82c:	2301      	movs	r3, #1
 800a82e:	6403      	str	r3, [r0, #64]	; 0x40

    /* Process Unlock */
    __HAL_UNLOCK(hhash);

    /* Enable Data Input interrupt */
    __HAL_HASH_ENABLE_IT(HASH_IT_DINI);
 800a830:	6a22      	ldr	r2, [r4, #32]

    /* Set multi buffers accumulation flag */
    hhash->Accumulation = 1U;

    /* Process Unlock */
    __HAL_UNLOCK(hhash);
 800a832:	2300      	movs	r3, #0

    /* Enable Data Input interrupt */
    __HAL_HASH_ENABLE_IT(HASH_IT_DINI);
 800a834:	f042 0201 	orr.w	r2, r2, #1

    /* Set multi buffers accumulation flag */
    hhash->Accumulation = 1U;

    /* Process Unlock */
    __HAL_UNLOCK(hhash);
 800a838:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34

    /* Enable Data Input interrupt */
    __HAL_HASH_ENABLE_IT(HASH_IT_DINI);
 800a83c:	6222      	str	r2, [r4, #32]

    /* Return function status */
    return HAL_OK;
 800a83e:	4618      	mov	r0, r3
 800a840:	e002      	b.n	800a848 <HASH_Accumulate_IT+0xbc>
  uint32_t SizeVar = Size;

  /* Make sure the input buffer size (in bytes) is a multiple of 4 */
  if ((Size % 4U) != 0U)
  {
    return  HAL_ERROR;
 800a842:	2001      	movs	r0, #1
 800a844:	e000      	b.n	800a848 <HASH_Accumulate_IT+0xbc>
    return HAL_OK;

  }
  else
  {
    return HAL_BUSY;
 800a846:	2002      	movs	r0, #2
  }

}
 800a848:	b003      	add	sp, #12
 800a84a:	bd30      	pop	{r4, r5, pc}
 800a84c:	50060400 	.word	0x50060400

0800a850 <HAL_HASH_MD5_Accmlt_IT>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASH_MD5_Accmlt_IT(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
  return  HASH_Accumulate_IT(hhash, pInBuffer, Size,HASH_ALGOSELECTION_MD5);
 800a850:	2380      	movs	r3, #128	; 0x80
 800a852:	f7ff bf9b 	b.w	800a78c <HASH_Accumulate_IT>

0800a856 <HAL_HASH_SHA1_Accmlt_IT>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASH_SHA1_Accmlt_IT(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
  return  HASH_Accumulate_IT(hhash, pInBuffer, Size,HASH_ALGOSELECTION_SHA1);
 800a856:	2300      	movs	r3, #0
 800a858:	f7ff bf98 	b.w	800a78c <HASH_Accumulate_IT>

0800a85c <HASH_Start_IT>:
  * @param  pOutBuffer pointer to the computed digest.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Start_IT(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Algorithm)
{
 800a85c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   HAL_HASH_StateTypeDef State_tmp = hhash->State;
 800a85e:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
  __IO uint32_t inputaddr = (uint32_t) pInBuffer;
 800a862:	9101      	str	r1, [sp, #4]
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Start_IT(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Algorithm)
{
   HAL_HASH_StateTypeDef State_tmp = hhash->State;
 800a864:	b2e4      	uxtb	r4, r4
  uint32_t polling_step = 0U;
  uint32_t initialization_skipped = 0U;
  uint32_t SizeVar = Size;

  /* If State is ready or suspended, start or resume IT-based HASH processing */
if((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 800a866:	2c01      	cmp	r4, #1
 800a868:	d002      	beq.n	800a870 <HASH_Start_IT+0x14>
 800a86a:	2c08      	cmp	r4, #8
 800a86c:	f040 8086 	bne.w	800a97c <HASH_Start_IT+0x120>
  {
    /* Check input parameters */
    if ((pInBuffer == NULL) || (Size == 0U) || (pOutBuffer == NULL))
 800a870:	b109      	cbz	r1, 800a876 <HASH_Start_IT+0x1a>
 800a872:	b102      	cbz	r2, 800a876 <HASH_Start_IT+0x1a>
 800a874:	b91b      	cbnz	r3, 800a87e <HASH_Start_IT+0x22>
    {
      hhash->State = HAL_HASH_STATE_READY;
 800a876:	2201      	movs	r2, #1
 800a878:	f880 2035 	strb.w	r2, [r0, #53]	; 0x35
 800a87c:	e07c      	b.n	800a978 <HASH_Start_IT+0x11c>
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(hhash);
 800a87e:	f890 4034 	ldrb.w	r4, [r0, #52]	; 0x34
 800a882:	2c01      	cmp	r4, #1
 800a884:	f04f 0402 	mov.w	r4, #2
 800a888:	d07a      	beq.n	800a980 <HASH_Start_IT+0x124>

    /* Change the HASH state */
    hhash->State = HAL_HASH_STATE_BUSY;
 800a88a:	f880 4035 	strb.w	r4, [r0, #53]	; 0x35

    /* Initialize IT counter */
    hhash->HashITCounter = 1;

    /* Check if initialization phase has already be performed */
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 800a88e:	f890 402d 	ldrb.w	r4, [r0, #45]	; 0x2d
      hhash->State = HAL_HASH_STATE_READY;
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(hhash);
 800a892:	2501      	movs	r5, #1

    /* Initialize IT counter */
    hhash->HashITCounter = 1;

    /* Check if initialization phase has already be performed */
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 800a894:	42ac      	cmp	r4, r5
      hhash->State = HAL_HASH_STATE_READY;
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(hhash);
 800a896:	f880 5034 	strb.w	r5, [r0, #52]	; 0x34

    /* Change the HASH state */
    hhash->State = HAL_HASH_STATE_BUSY;

    /* Initialize IT counter */
    hhash->HashITCounter = 1;
 800a89a:	6245      	str	r5, [r0, #36]	; 0x24
 800a89c:	4c3a      	ldr	r4, [pc, #232]	; (800a988 <HASH_Start_IT+0x12c>)

    /* Check if initialization phase has already be performed */
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 800a89e:	d116      	bne.n	800a8ce <HASH_Start_IT+0x72>
    {
      /* Select the HASH algorithm, clear HMAC mode and long key selection bit, reset the HASH processor core */
      MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);
 800a8a0:	6825      	ldr	r5, [r4, #0]
 800a8a2:	9e08      	ldr	r6, [sp, #32]
 800a8a4:	f425 25a0 	bic.w	r5, r5, #327680	; 0x50000
 800a8a8:	f025 05c4 	bic.w	r5, r5, #196	; 0xc4
 800a8ac:	f045 0504 	orr.w	r5, r5, #4
 800a8b0:	4335      	orrs	r5, r6
 800a8b2:	6025      	str	r5, [r4, #0]

      /* Configure the number of valid bits in last word of the message */
     __HAL_HASH_SET_NBVALIDBITS(SizeVar);
 800a8b4:	68a6      	ldr	r6, [r4, #8]
 800a8b6:	f002 0503 	and.w	r5, r2, #3
 800a8ba:	f026 061f 	bic.w	r6, r6, #31
 800a8be:	ea46 05c5 	orr.w	r5, r6, r5, lsl #3
 800a8c2:	60a5      	str	r5, [r4, #8]
HAL_StatusTypeDef HASH_Start_IT(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Algorithm)
{
   HAL_HASH_StateTypeDef State_tmp = hhash->State;
  __IO uint32_t inputaddr = (uint32_t) pInBuffer;
  uint32_t polling_step = 0U;
  uint32_t initialization_skipped = 0U;
 800a8c4:	2600      	movs	r6, #0

      /* Configure the number of valid bits in last word of the message */
     __HAL_HASH_SET_NBVALIDBITS(SizeVar);


      hhash->HashInCount = SizeVar;            /* Counter used to keep track of number of data
 800a8c6:	6202      	str	r2, [r0, #32]
                                                  to be fed to the Peripheral */
      hhash->pHashInBuffPtr = pInBuffer;       /* Points at data which will be fed to the Peripheral at
 800a8c8:	60c1      	str	r1, [r0, #12]
     /* In case of suspension, hhash->HashInCount and hhash->pHashInBuffPtr contain
        the information describing where the HASH process is stopped.
        These variables are used later on to resume the HASH processing at the
        correct location. */

      hhash->pHashOutBuffPtr = pOutBuffer;     /* Points at the computed digest */
 800a8ca:	6103      	str	r3, [r0, #16]
 800a8cc:	e000      	b.n	800a8d0 <HASH_Start_IT+0x74>
    }
    else
    {
      initialization_skipped = 1; /* info user later on in case of multi-buffer */
 800a8ce:	462e      	mov	r6, r5
    }

    /* Set the phase */
    hhash->Phase = HAL_HASH_PHASE_PROCESS;
 800a8d0:	2102      	movs	r1, #2

   /* If DINIS is equal to 0 (for example if an incomplete block has been previously
     fed to the Peripheral), the DINIE interruption won't be triggered when DINIE is set.
     Therefore, first words are manually entered until DINIS raises. */
    while((!(__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))) && (SizeVar > 3U))
 800a8d2:	4d2d      	ldr	r5, [pc, #180]	; (800a988 <HASH_Start_IT+0x12c>)
    {
      initialization_skipped = 1; /* info user later on in case of multi-buffer */
    }

    /* Set the phase */
    hhash->Phase = HAL_HASH_PHASE_PROCESS;
 800a8d4:	f880 102d 	strb.w	r1, [r0, #45]	; 0x2d
  */
HAL_StatusTypeDef HASH_Start_IT(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Algorithm)
{
   HAL_HASH_StateTypeDef State_tmp = hhash->State;
  __IO uint32_t inputaddr = (uint32_t) pInBuffer;
  uint32_t polling_step = 0U;
 800a8d8:	2100      	movs	r1, #0
    hhash->Phase = HAL_HASH_PHASE_PROCESS;

   /* If DINIS is equal to 0 (for example if an incomplete block has been previously
     fed to the Peripheral), the DINIE interruption won't be triggered when DINIE is set.
     Therefore, first words are manually entered until DINIS raises. */
    while((!(__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))) && (SizeVar > 3U))
 800a8da:	6a67      	ldr	r7, [r4, #36]	; 0x24
 800a8dc:	07ff      	lsls	r7, r7, #31
 800a8de:	d502      	bpl.n	800a8e6 <HASH_Start_IT+0x8a>
      HASH->DIN = *(uint32_t*)inputaddr;
      inputaddr+=4U;
      SizeVar-=4U;
    }

    if (polling_step == 1U)
 800a8e0:	2900      	cmp	r1, #0
 800a8e2:	d042      	beq.n	800a96a <HASH_Start_IT+0x10e>
 800a8e4:	e00a      	b.n	800a8fc <HASH_Start_IT+0xa0>
    hhash->Phase = HAL_HASH_PHASE_PROCESS;

   /* If DINIS is equal to 0 (for example if an incomplete block has been previously
     fed to the Peripheral), the DINIE interruption won't be triggered when DINIE is set.
     Therefore, first words are manually entered until DINIS raises. */
    while((!(__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))) && (SizeVar > 3U))
 800a8e6:	2a03      	cmp	r2, #3
 800a8e8:	d9fa      	bls.n	800a8e0 <HASH_Start_IT+0x84>
    {
      polling_step = 1U; /* note that some words are entered before enabling the interrupt */

      /* Write input data 4 bytes at a time */
      HASH->DIN = *(uint32_t*)inputaddr;
 800a8ea:	9901      	ldr	r1, [sp, #4]
 800a8ec:	6809      	ldr	r1, [r1, #0]
 800a8ee:	6069      	str	r1, [r5, #4]
      inputaddr+=4U;
 800a8f0:	9901      	ldr	r1, [sp, #4]
 800a8f2:	3104      	adds	r1, #4
 800a8f4:	9101      	str	r1, [sp, #4]
      SizeVar-=4U;
 800a8f6:	3a04      	subs	r2, #4
   /* If DINIS is equal to 0 (for example if an incomplete block has been previously
     fed to the Peripheral), the DINIE interruption won't be triggered when DINIE is set.
     Therefore, first words are manually entered until DINIS raises. */
    while((!(__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))) && (SizeVar > 3U))
    {
      polling_step = 1U; /* note that some words are entered before enabling the interrupt */
 800a8f8:	2101      	movs	r1, #1
 800a8fa:	e7ee      	b.n	800a8da <HASH_Start_IT+0x7e>
      SizeVar-=4U;
    }

    if (polling_step == 1U)
    {
      if (SizeVar == 0U)
 800a8fc:	b952      	cbnz	r2, 800a914 <HASH_Start_IT+0xb8>
      {
        /* If all the data have been entered at this point, it only remains to
         read the digest */
        hhash->pHashOutBuffPtr = pOutBuffer;     /* Points at the computed digest */
 800a8fe:	6103      	str	r3, [r0, #16]

        /* Start the Digest calculation */
         __HAL_HASH_START_DIGEST();
 800a900:	68a3      	ldr	r3, [r4, #8]
 800a902:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800a906:	60a3      	str	r3, [r4, #8]
        /* Process Unlock */
        __HAL_UNLOCK(hhash);

        /* Enable Interrupts */
        __HAL_HASH_ENABLE_IT(HASH_IT_DCI);
 800a908:	6a23      	ldr	r3, [r4, #32]
        hhash->pHashOutBuffPtr = pOutBuffer;     /* Points at the computed digest */

        /* Start the Digest calculation */
         __HAL_HASH_START_DIGEST();
        /* Process Unlock */
        __HAL_UNLOCK(hhash);
 800a90a:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34

        /* Enable Interrupts */
        __HAL_HASH_ENABLE_IT(HASH_IT_DCI);
 800a90e:	f043 0302 	orr.w	r3, r3, #2
 800a912:	e030      	b.n	800a976 <HASH_Start_IT+0x11a>

        /* Return function status */
        return HAL_OK;
      }
      else if (__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))
 800a914:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800a916:	4d1c      	ldr	r5, [pc, #112]	; (800a988 <HASH_Start_IT+0x12c>)
 800a918:	f011 0101 	ands.w	r1, r1, #1
 800a91c:	f002 0703 	and.w	r7, r2, #3
 800a920:	d00d      	beq.n	800a93e <HASH_Start_IT+0xe2>
      {
        /* It remains data to enter and the Peripheral is ready to trigger DINIE,
           carry on as usual.
           Update HashInCount and pHashInBuffPtr accordingly. */
        hhash->HashInCount = SizeVar;
 800a922:	6202      	str	r2, [r0, #32]
        hhash->pHashInBuffPtr = (uint8_t *)inputaddr;
 800a924:	9a01      	ldr	r2, [sp, #4]
        __HAL_HASH_SET_NBVALIDBITS(SizeVar);  /* Update the configuration of the number of valid bits in last word of the message */
 800a926:	68a9      	ldr	r1, [r5, #8]
      {
        /* It remains data to enter and the Peripheral is ready to trigger DINIE,
           carry on as usual.
           Update HashInCount and pHashInBuffPtr accordingly. */
        hhash->HashInCount = SizeVar;
        hhash->pHashInBuffPtr = (uint8_t *)inputaddr;
 800a928:	60c2      	str	r2, [r0, #12]
        __HAL_HASH_SET_NBVALIDBITS(SizeVar);  /* Update the configuration of the number of valid bits in last word of the message */
 800a92a:	f021 011f 	bic.w	r1, r1, #31
 800a92e:	ea41 02c7 	orr.w	r2, r1, r7, lsl #3
 800a932:	60aa      	str	r2, [r5, #8]
        hhash->pHashOutBuffPtr = pOutBuffer;  /* Points at the computed digest */
 800a934:	6103      	str	r3, [r0, #16]
        if (initialization_skipped == 1U)
 800a936:	b1c6      	cbz	r6, 800a96a <HASH_Start_IT+0x10e>
        {
          hhash->HashITCounter = 3; /* 'cruise-speed' reached during a previous buffer processing */
 800a938:	2303      	movs	r3, #3
 800a93a:	6243      	str	r3, [r0, #36]	; 0x24
 800a93c:	e015      	b.n	800a96a <HASH_Start_IT+0x10e>
      }
      else
      {
        /* DINIS is not set but it remains a few data to enter (not enough for a full word).
           Manually enter the last bytes before enabling DCIE. */
        __HAL_HASH_SET_NBVALIDBITS(SizeVar);
 800a93e:	68aa      	ldr	r2, [r5, #8]
 800a940:	f022 021f 	bic.w	r2, r2, #31
 800a944:	ea42 02c7 	orr.w	r2, r2, r7, lsl #3
 800a948:	60aa      	str	r2, [r5, #8]
        HASH->DIN = *(uint32_t*)inputaddr;
 800a94a:	9a01      	ldr	r2, [sp, #4]
 800a94c:	6812      	ldr	r2, [r2, #0]
 800a94e:	606a      	str	r2, [r5, #4]

         /* Start the Digest calculation */
        hhash->pHashOutBuffPtr = pOutBuffer;     /* Points at the computed digest */
 800a950:	6103      	str	r3, [r0, #16]
         __HAL_HASH_START_DIGEST();
 800a952:	68ab      	ldr	r3, [r5, #8]
 800a954:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800a958:	60ab      	str	r3, [r5, #8]
        /* Process Unlock */
        __HAL_UNLOCK(hhash);

        /* Enable Interrupts */
        __HAL_HASH_ENABLE_IT(HASH_IT_DCI);
 800a95a:	6a2b      	ldr	r3, [r5, #32]

         /* Start the Digest calculation */
        hhash->pHashOutBuffPtr = pOutBuffer;     /* Points at the computed digest */
         __HAL_HASH_START_DIGEST();
        /* Process Unlock */
        __HAL_UNLOCK(hhash);
 800a95c:	f880 1034 	strb.w	r1, [r0, #52]	; 0x34

        /* Enable Interrupts */
        __HAL_HASH_ENABLE_IT(HASH_IT_DCI);
 800a960:	f043 0302 	orr.w	r3, r3, #2
 800a964:	622b      	str	r3, [r5, #32]

        /* Return function status */
        return HAL_OK;
 800a966:	4608      	mov	r0, r1
 800a968:	e00b      	b.n	800a982 <HASH_Start_IT+0x126>

    /* Process Unlock */
    __HAL_UNLOCK(hhash);

    /* Enable Interrupts */
    __HAL_HASH_ENABLE_IT(HASH_IT_DINI|HASH_IT_DCI);
 800a96a:	6a23      	ldr	r3, [r4, #32]
      }
    } /*  if (polling_step == 1) */


    /* Process Unlock */
    __HAL_UNLOCK(hhash);
 800a96c:	2200      	movs	r2, #0
 800a96e:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34

    /* Enable Interrupts */
    __HAL_HASH_ENABLE_IT(HASH_IT_DINI|HASH_IT_DCI);
 800a972:	f043 0303 	orr.w	r3, r3, #3
 800a976:	6223      	str	r3, [r4, #32]

    /* Return function status */
    return HAL_OK;
 800a978:	4610      	mov	r0, r2
 800a97a:	e002      	b.n	800a982 <HASH_Start_IT+0x126>
  }
  else
  {
    return HAL_BUSY;
 800a97c:	2002      	movs	r0, #2
 800a97e:	e000      	b.n	800a982 <HASH_Start_IT+0x126>
 800a980:	4620      	mov	r0, r4
  }

}
 800a982:	b003      	add	sp, #12
 800a984:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a986:	bf00      	nop
 800a988:	50060400 	.word	0x50060400

0800a98c <HAL_HASH_MD5_Accmlt_End_IT>:
  * @param  Size length of the input buffer in bytes.
  * @param  pOutBuffer pointer to the computed digest. Digest size is 16 bytes.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASH_MD5_Accmlt_End_IT(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer)
{
 800a98c:	b513      	push	{r0, r1, r4, lr}
  return HASH_Start_IT(hhash, pInBuffer, Size, pOutBuffer,HASH_ALGOSELECTION_MD5);
 800a98e:	2480      	movs	r4, #128	; 0x80
 800a990:	9400      	str	r4, [sp, #0]
 800a992:	f7ff ff63 	bl	800a85c <HASH_Start_IT>
}
 800a996:	b002      	add	sp, #8
 800a998:	bd10      	pop	{r4, pc}

0800a99a <HAL_HASH_MD5_Start_IT>:
 800a99a:	f7ff bff7 	b.w	800a98c <HAL_HASH_MD5_Accmlt_End_IT>

0800a99e <HAL_HASH_SHA1_Accmlt_End_IT>:
  * @param  Size length of the input buffer in bytes.
  * @param  pOutBuffer pointer to the computed digest. Digest size is 20 bytes.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASH_SHA1_Accmlt_End_IT(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer)
{
 800a99e:	b513      	push	{r0, r1, r4, lr}
  return HASH_Start_IT(hhash, pInBuffer, Size, pOutBuffer,HASH_ALGOSELECTION_SHA1);
 800a9a0:	2400      	movs	r4, #0
 800a9a2:	9400      	str	r4, [sp, #0]
 800a9a4:	f7ff ff5a 	bl	800a85c <HASH_Start_IT>
}
 800a9a8:	b002      	add	sp, #8
 800a9aa:	bd10      	pop	{r4, pc}

0800a9ac <HAL_HASH_SHA1_Start_IT>:
 800a9ac:	f7ff bff7 	b.w	800a99e <HAL_HASH_SHA1_Accmlt_End_IT>

0800a9b0 <HASH_Finish>:
  * @param  pOutBuffer pointer to the computed digest.
  * @param  Timeout Timeout value.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Finish(HASH_HandleTypeDef *hhash, uint8_t* pOutBuffer, uint32_t Timeout)
{
 800a9b0:	b570      	push	{r4, r5, r6, lr}

  if(hhash->State == HAL_HASH_STATE_READY)
 800a9b2:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
 800a9b6:	b2e4      	uxtb	r4, r4
 800a9b8:	2c01      	cmp	r4, #1
  * @param  pOutBuffer pointer to the computed digest.
  * @param  Timeout Timeout value.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Finish(HASH_HandleTypeDef *hhash, uint8_t* pOutBuffer, uint32_t Timeout)
{
 800a9ba:	4605      	mov	r5, r0
 800a9bc:	460e      	mov	r6, r1
 800a9be:	4613      	mov	r3, r2

  if(hhash->State == HAL_HASH_STATE_READY)
 800a9c0:	d133      	bne.n	800aa2a <HASH_Finish+0x7a>
  {
    /* Check parameter */
    if (pOutBuffer == NULL)
 800a9c2:	2900      	cmp	r1, #0
 800a9c4:	d036      	beq.n	800aa34 <HASH_Finish+0x84>
    {
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(hhash);
 800a9c6:	f890 2034 	ldrb.w	r2, [r0, #52]	; 0x34
 800a9ca:	2a01      	cmp	r2, #1
 800a9cc:	f04f 0102 	mov.w	r1, #2
 800a9d0:	d02d      	beq.n	800aa2e <HASH_Finish+0x7e>
 800a9d2:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34

    /* Change the HASH state to busy */
    hhash->State = HAL_HASH_STATE_BUSY;
 800a9d6:	f880 1035 	strb.w	r1, [r0, #53]	; 0x35

    /* Wait for DCIS flag to be set */
    if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
 800a9da:	2200      	movs	r2, #0
 800a9dc:	f7ff fc1e 	bl	800a21c <HASH_WaitOnFlagUntilTimeout>
 800a9e0:	4604      	mov	r4, r0
 800a9e2:	bb30      	cbnz	r0, 800aa32 <HASH_Finish+0x82>
    {
      return HAL_TIMEOUT;
    }

    /* Read the message digest */
    HASH_GetDigest(pOutBuffer, HASH_DIGEST_LENGTH());
 800a9e4:	4b14      	ldr	r3, [pc, #80]	; (800aa38 <HASH_Finish+0x88>)
 800a9e6:	4a15      	ldr	r2, [pc, #84]	; (800aa3c <HASH_Finish+0x8c>)
 800a9e8:	6819      	ldr	r1, [r3, #0]
 800a9ea:	400a      	ands	r2, r1
 800a9ec:	b172      	cbz	r2, 800aa0c <HASH_Finish+0x5c>
 800a9ee:	6819      	ldr	r1, [r3, #0]
 800a9f0:	4a12      	ldr	r2, [pc, #72]	; (800aa3c <HASH_Finish+0x8c>)
 800a9f2:	400a      	ands	r2, r1
 800a9f4:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
 800a9f8:	d00a      	beq.n	800aa10 <HASH_Finish+0x60>
 800a9fa:	681a      	ldr	r2, [r3, #0]
 800a9fc:	4b0f      	ldr	r3, [pc, #60]	; (800aa3c <HASH_Finish+0x8c>)
 800a9fe:	490f      	ldr	r1, [pc, #60]	; (800aa3c <HASH_Finish+0x8c>)
 800aa00:	4013      	ands	r3, r2
 800aa02:	428b      	cmp	r3, r1
 800aa04:	bf0c      	ite	eq
 800aa06:	2120      	moveq	r1, #32
 800aa08:	2110      	movne	r1, #16
 800aa0a:	e002      	b.n	800aa12 <HASH_Finish+0x62>
 800aa0c:	2114      	movs	r1, #20
 800aa0e:	e000      	b.n	800aa12 <HASH_Finish+0x62>
 800aa10:	211c      	movs	r1, #28
 800aa12:	4630      	mov	r0, r6
 800aa14:	f7ff fba0 	bl	800a158 <HASH_GetDigest>

    /* Change the HASH state to ready */
    hhash->State = HAL_HASH_STATE_READY;
 800aa18:	2301      	movs	r3, #1
 800aa1a:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35

    /* Reset HASH state machine */
    hhash->Phase = HAL_HASH_PHASE_READY;
 800aa1e:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d

    /* Process UnLock */
    __HAL_UNLOCK(hhash);
 800aa22:	2300      	movs	r3, #0
 800aa24:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34

    /* Return function status */
    return HAL_OK;
 800aa28:	e004      	b.n	800aa34 <HASH_Finish+0x84>

  }
  else
  {
    return HAL_BUSY;
 800aa2a:	2402      	movs	r4, #2
 800aa2c:	e002      	b.n	800aa34 <HASH_Finish+0x84>
 800aa2e:	460c      	mov	r4, r1
 800aa30:	e000      	b.n	800aa34 <HASH_Finish+0x84>
    hhash->State = HAL_HASH_STATE_BUSY;

    /* Wait for DCIS flag to be set */
    if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
    {
      return HAL_TIMEOUT;
 800aa32:	2403      	movs	r4, #3
  else
  {
    return HAL_BUSY;
  }

}
 800aa34:	4620      	mov	r0, r4
 800aa36:	bd70      	pop	{r4, r5, r6, pc}
 800aa38:	50060400 	.word	0x50060400
 800aa3c:	00040080 	.word	0x00040080

0800aa40 <HMAC_Start>:
  * @param  Timeout Timeout value.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HMAC_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout, uint32_t Algorithm)
{
 800aa40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800aa42:	469e      	mov	lr, r3
    HAL_HASH_StateTypeDef State_tmp = hhash->State;
 800aa44:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
  * @param  Timeout Timeout value.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HMAC_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout, uint32_t Algorithm)
{
 800aa48:	f8dd c01c 	ldr.w	ip, [sp, #28]
    HAL_HASH_StateTypeDef State_tmp = hhash->State;
 800aa4c:	b2db      	uxtb	r3, r3

   /* If State is ready or suspended, start or resume polling-based HASH processing */
if((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 800aa4e:	2b01      	cmp	r3, #1
  * @param  Timeout Timeout value.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HMAC_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout, uint32_t Algorithm)
{
 800aa50:	4604      	mov	r4, r0
    HAL_HASH_StateTypeDef State_tmp = hhash->State;

   /* If State is ready or suspended, start or resume polling-based HASH processing */
if((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 800aa52:	d002      	beq.n	800aa5a <HMAC_Start+0x1a>
 800aa54:	2b08      	cmp	r3, #8
 800aa56:	f040 80ed 	bne.w	800ac34 <HMAC_Start+0x1f4>
  {
    /* Check input parameters */
    if ((pInBuffer == NULL) || /*(Size == 0U) ||*/ (hhash->Init.pKey == NULL) || (hhash->Init.KeySize == 0U) || (pOutBuffer == NULL))
 800aa5a:	b131      	cbz	r1, 800aa6a <HMAC_Start+0x2a>
 800aa5c:	68a3      	ldr	r3, [r4, #8]
 800aa5e:	b123      	cbz	r3, 800aa6a <HMAC_Start+0x2a>
 800aa60:	6866      	ldr	r6, [r4, #4]
 800aa62:	b116      	cbz	r6, 800aa6a <HMAC_Start+0x2a>
 800aa64:	f1be 0f00 	cmp.w	lr, #0
 800aa68:	d103      	bne.n	800aa72 <HMAC_Start+0x32>
    {
      hhash->State = HAL_HASH_STATE_READY;
 800aa6a:	2001      	movs	r0, #1
 800aa6c:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
      return  HAL_ERROR;
 800aa70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }

    /* Process Locked */
    __HAL_LOCK(hhash);
 800aa72:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 800aa76:	2801      	cmp	r0, #1
 800aa78:	f04f 0002 	mov.w	r0, #2
 800aa7c:	f000 80db 	beq.w	800ac36 <HMAC_Start+0x1f6>

    /* Change the HASH state */
    hhash->State = HAL_HASH_STATE_BUSY;
 800aa80:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35

    /* Check if initialization phase has already be performed */
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 800aa84:	f894 002d 	ldrb.w	r0, [r4, #45]	; 0x2d
      hhash->State = HAL_HASH_STATE_READY;
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(hhash);
 800aa88:	2501      	movs	r5, #1

    /* Change the HASH state */
    hhash->State = HAL_HASH_STATE_BUSY;

    /* Check if initialization phase has already be performed */
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 800aa8a:	42a8      	cmp	r0, r5
      hhash->State = HAL_HASH_STATE_READY;
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(hhash);
 800aa8c:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34

    /* Change the HASH state */
    hhash->State = HAL_HASH_STATE_BUSY;

    /* Check if initialization phase has already be performed */
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 800aa90:	d122      	bne.n	800aad8 <HMAC_Start+0x98>
 800aa92:	4f69      	ldr	r7, [pc, #420]	; (800ac38 <HMAC_Start+0x1f8>)
    {
      /* Check if key size is larger than 64 bytes, accordingly set LKEY and the other setting bits */
      if(hhash->Init.KeySize > 64U)
 800aa94:	2e40      	cmp	r6, #64	; 0x40
      {
        MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_ALGOMODE_HMAC | HASH_HMAC_KEYTYPE_LONGKEY | HASH_CR_INIT);
 800aa96:	683d      	ldr	r5, [r7, #0]

    /* Check if initialization phase has already be performed */
    if(hhash->Phase == HAL_HASH_PHASE_READY)
    {
      /* Check if key size is larger than 64 bytes, accordingly set LKEY and the other setting bits */
      if(hhash->Init.KeySize > 64U)
 800aa98:	d90b      	bls.n	800aab2 <HMAC_Start+0x72>
      {
        MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_ALGOMODE_HMAC | HASH_HMAC_KEYTYPE_LONGKEY | HASH_CR_INIT);
 800aa9a:	f425 20a0 	bic.w	r0, r5, #327680	; 0x50000
 800aa9e:	f020 00c4 	bic.w	r0, r0, #196	; 0xc4
 800aaa2:	f440 3080 	orr.w	r0, r0, #65536	; 0x10000
 800aaa6:	f040 0044 	orr.w	r0, r0, #68	; 0x44
 800aaaa:	ea40 000c 	orr.w	r0, r0, ip
 800aaae:	6038      	str	r0, [r7, #0]
 800aab0:	e008      	b.n	800aac4 <HMAC_Start+0x84>
      }
      else
      {
        MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_ALGOMODE_HMAC | HASH_CR_INIT);
 800aab2:	f425 25a0 	bic.w	r5, r5, #327680	; 0x50000
 800aab6:	f025 05c4 	bic.w	r5, r5, #196	; 0xc4
 800aaba:	f045 0544 	orr.w	r5, r5, #68	; 0x44
 800aabe:	ea45 050c 	orr.w	r5, r5, ip
 800aac2:	603d      	str	r5, [r7, #0]
      }
      /* Set the phase to Step 1 */
      hhash->Phase = HAL_HASH_PHASE_HMAC_STEP_1;
 800aac4:	2003      	movs	r0, #3
      /* Resort to hhash internal fields to feed the Peripheral.
         Parameters will be updated in case of suspension to contain the proper
         information at resumption time. */
      hhash->pHashOutBuffPtr  = pOutBuffer;            /* Output digest address                                              */
      hhash->pHashInBuffPtr   = pInBuffer;             /* Input data address, HMAC_Processing input parameter for Step 2     */
      hhash->HashInCount      = Size;                  /* Input data size, HMAC_Processing input parameter for Step 2        */
 800aac6:	6222      	str	r2, [r4, #32]
      else
      {
        MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_ALGOMODE_HMAC | HASH_CR_INIT);
      }
      /* Set the phase to Step 1 */
      hhash->Phase = HAL_HASH_PHASE_HMAC_STEP_1;
 800aac8:	f884 002d 	strb.w	r0, [r4, #45]	; 0x2d
      /* Resort to hhash internal fields to feed the Peripheral.
         Parameters will be updated in case of suspension to contain the proper
         information at resumption time. */
      hhash->pHashOutBuffPtr  = pOutBuffer;            /* Output digest address                                              */
 800aacc:	f8c4 e010 	str.w	lr, [r4, #16]
      hhash->pHashInBuffPtr   = pInBuffer;             /* Input data address, HMAC_Processing input parameter for Step 2     */
 800aad0:	60e1      	str	r1, [r4, #12]
      hhash->HashInCount      = Size;                  /* Input data size, HMAC_Processing input parameter for Step 2        */
      hhash->HashBuffSize     = Size;                  /* Store the input buffer size for the whole HMAC process             */
 800aad2:	61e2      	str	r2, [r4, #28]
      hhash->pHashKeyBuffPtr  = hhash->Init.pKey;      /* Key address, HMAC_Processing input parameter for Step 1 and Step 3 */
 800aad4:	6163      	str	r3, [r4, #20]
      hhash->HashKeyCount     = hhash->Init.KeySize;   /* Key size, HMAC_Processing input parameter for Step 1 and Step 3    */
 800aad6:	62a6      	str	r6, [r4, #40]	; 0x28
  * @retval HAL status
  */
static HAL_StatusTypeDef HMAC_Processing(HASH_HandleTypeDef *hhash, uint32_t Timeout)
{
  /* Ensure first that Phase is correct */
  if ((hhash->Phase != HAL_HASH_PHASE_HMAC_STEP_1) && (hhash->Phase != HAL_HASH_PHASE_HMAC_STEP_2) && (hhash->Phase != HAL_HASH_PHASE_HMAC_STEP_3))
 800aad8:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
 800aadc:	1eda      	subs	r2, r3, #3
 800aade:	2a02      	cmp	r2, #2
 800aae0:	d906      	bls.n	800aaf0 <HMAC_Start+0xb0>
  {
    /* Change the HASH state */
    hhash->State = HAL_HASH_STATE_READY;
 800aae2:	2001      	movs	r0, #1

    /* Process Unlock */
    __HAL_UNLOCK(hhash);
 800aae4:	2300      	movs	r3, #0
{
  /* Ensure first that Phase is correct */
  if ((hhash->Phase != HAL_HASH_PHASE_HMAC_STEP_1) && (hhash->Phase != HAL_HASH_PHASE_HMAC_STEP_2) && (hhash->Phase != HAL_HASH_PHASE_HMAC_STEP_3))
  {
    /* Change the HASH state */
    hhash->State = HAL_HASH_STATE_READY;
 800aae6:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35

    /* Process Unlock */
    __HAL_UNLOCK(hhash);
 800aaea:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800aaee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    /* Return function status */
    return HAL_ERROR;
  }

  /* HMAC Step 1 processing */
  if (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_1)
 800aaf0:	2b03      	cmp	r3, #3
 800aaf2:	d127      	bne.n	800ab44 <HMAC_Start+0x104>
  {
    /************************** STEP 1 ******************************************/
    /* Configure the Number of valid bits in last word of the message */
    __HAL_HASH_SET_NBVALIDBITS(hhash->Init.KeySize);
 800aaf4:	4d50      	ldr	r5, [pc, #320]	; (800ac38 <HMAC_Start+0x1f8>)

    /* Write input buffer in Data register */
    hhash->Status = HASH_WriteData(hhash, hhash->pHashKeyBuffPtr, hhash->HashKeyCount);
 800aaf6:	6961      	ldr	r1, [r4, #20]
  /* HMAC Step 1 processing */
  if (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_1)
  {
    /************************** STEP 1 ******************************************/
    /* Configure the Number of valid bits in last word of the message */
    __HAL_HASH_SET_NBVALIDBITS(hhash->Init.KeySize);
 800aaf8:	68ab      	ldr	r3, [r5, #8]
 800aafa:	f006 0603 	and.w	r6, r6, #3
 800aafe:	f023 031f 	bic.w	r3, r3, #31
 800ab02:	ea43 06c6 	orr.w	r6, r3, r6, lsl #3
 800ab06:	60ae      	str	r6, [r5, #8]

    /* Write input buffer in Data register */
    hhash->Status = HASH_WriteData(hhash, hhash->pHashKeyBuffPtr, hhash->HashKeyCount);
 800ab08:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800ab0a:	4620      	mov	r0, r4
 800ab0c:	f7ff fae2 	bl	800a0d4 <HASH_WriteData>
 800ab10:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
    if (hhash->Status != HAL_OK)
 800ab14:	2800      	cmp	r0, #0
 800ab16:	f040 808e 	bne.w	800ac36 <HMAC_Start+0x1f6>
    {
      return hhash->Status;
    }

    /* Check whether or not key entering process has been suspended */
    if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 800ab1a:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 800ab1e:	2b08      	cmp	r3, #8
 800ab20:	f000 8084 	beq.w	800ac2c <HMAC_Start+0x1ec>
      /* Stop right there and return function status */
      return HAL_OK;
    }

    /* No processing suspension at this point: set DCAL bit. */
    __HAL_HASH_START_DIGEST();
 800ab24:	68ab      	ldr	r3, [r5, #8]
 800ab26:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800ab2a:	60ab      	str	r3, [r5, #8]

    /* Wait for BUSY flag to be cleared */
    if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_BUSY, SET, Timeout) != HAL_OK)
 800ab2c:	9b06      	ldr	r3, [sp, #24]
 800ab2e:	2201      	movs	r2, #1
 800ab30:	2108      	movs	r1, #8
 800ab32:	4620      	mov	r0, r4
 800ab34:	f7ff fb72 	bl	800a21c <HASH_WaitOnFlagUntilTimeout>
 800ab38:	b108      	cbz	r0, 800ab3e <HMAC_Start+0xfe>
    {
      return HAL_TIMEOUT;
 800ab3a:	2003      	movs	r0, #3
 800ab3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }

    /* Move from Step 1 to Step 2 */
    hhash->Phase = HAL_HASH_PHASE_HMAC_STEP_2;
 800ab3e:	2304      	movs	r3, #4
 800ab40:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
  /* HMAC Step 2 processing.
     After phase check, HMAC_Processing() may
     - directly start up from this point in resumption case
       if the same Step 2 processing was suspended previously
    - or fall through from the Step 1 processing carried out hereabove */
  if (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_2)
 800ab44:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
 800ab48:	2b04      	cmp	r3, #4
 800ab4a:	d129      	bne.n	800aba0 <HMAC_Start+0x160>
  {
    /************************** STEP 2 ******************************************/
    /* Configure the Number of valid bits in last word of the message */
    __HAL_HASH_SET_NBVALIDBITS(hhash->HashBuffSize);
 800ab4c:	4d3a      	ldr	r5, [pc, #232]	; (800ac38 <HMAC_Start+0x1f8>)
 800ab4e:	69e2      	ldr	r2, [r4, #28]
 800ab50:	68ab      	ldr	r3, [r5, #8]

    /* Write input buffer in Data register */
    hhash->Status = HASH_WriteData(hhash, hhash->pHashInBuffPtr, hhash->HashInCount);
 800ab52:	68e1      	ldr	r1, [r4, #12]
    - or fall through from the Step 1 processing carried out hereabove */
  if (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_2)
  {
    /************************** STEP 2 ******************************************/
    /* Configure the Number of valid bits in last word of the message */
    __HAL_HASH_SET_NBVALIDBITS(hhash->HashBuffSize);
 800ab54:	f002 0203 	and.w	r2, r2, #3
 800ab58:	f023 031f 	bic.w	r3, r3, #31
 800ab5c:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 800ab60:	60ab      	str	r3, [r5, #8]

    /* Write input buffer in Data register */
    hhash->Status = HASH_WriteData(hhash, hhash->pHashInBuffPtr, hhash->HashInCount);
 800ab62:	6a22      	ldr	r2, [r4, #32]
 800ab64:	4620      	mov	r0, r4
 800ab66:	f7ff fab5 	bl	800a0d4 <HASH_WriteData>
 800ab6a:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
    if (hhash->Status != HAL_OK)
 800ab6e:	2800      	cmp	r0, #0
 800ab70:	d161      	bne.n	800ac36 <HMAC_Start+0x1f6>
    {
      return hhash->Status;
    }

    /* Check whether or not data entering process has been suspended */
    if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 800ab72:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 800ab76:	2b08      	cmp	r3, #8
 800ab78:	d058      	beq.n	800ac2c <HMAC_Start+0x1ec>
      /* Stop right there and return function status */
      return HAL_OK;
    }

    /* No processing suspension at this point: set DCAL bit. */
    __HAL_HASH_START_DIGEST();
 800ab7a:	68ab      	ldr	r3, [r5, #8]
 800ab7c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800ab80:	60ab      	str	r3, [r5, #8]

    /* Wait for BUSY flag to be cleared */
    if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_BUSY, SET, Timeout) != HAL_OK)
 800ab82:	9b06      	ldr	r3, [sp, #24]
 800ab84:	2201      	movs	r2, #1
 800ab86:	2108      	movs	r1, #8
 800ab88:	4620      	mov	r0, r4
 800ab8a:	f7ff fb47 	bl	800a21c <HASH_WaitOnFlagUntilTimeout>
 800ab8e:	2800      	cmp	r0, #0
 800ab90:	d1d3      	bne.n	800ab3a <HMAC_Start+0xfa>
    {
      return HAL_TIMEOUT;
    }

    /* Move from Step 2 to Step 3 */
    hhash->Phase = HAL_HASH_PHASE_HMAC_STEP_3;
 800ab92:	2305      	movs	r3, #5
 800ab94:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
    /* In case Step 1 phase was suspended then resumed,
       set again Key input buffers and size before moving to
       next step */
    hhash->pHashKeyBuffPtr = hhash->Init.pKey;
 800ab98:	68a3      	ldr	r3, [r4, #8]
 800ab9a:	6163      	str	r3, [r4, #20]
    hhash->HashKeyCount    = hhash->Init.KeySize;
 800ab9c:	6863      	ldr	r3, [r4, #4]
 800ab9e:	62a3      	str	r3, [r4, #40]	; 0x28
 /* HMAC Step 3 processing.
     After phase check, HMAC_Processing() may
     - directly start up from this point in resumption case
       if the same Step 3 processing was suspended previously
    - or fall through from the Step 2 processing carried out hereabove */
  if (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_3)
 800aba0:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
 800aba4:	2b05      	cmp	r3, #5
 800aba6:	d13e      	bne.n	800ac26 <HMAC_Start+0x1e6>
  {
    /************************** STEP 3 ******************************************/
    /* Configure the Number of valid bits in last word of the message */
    __HAL_HASH_SET_NBVALIDBITS(hhash->Init.KeySize);
 800aba8:	4d23      	ldr	r5, [pc, #140]	; (800ac38 <HMAC_Start+0x1f8>)
 800abaa:	6862      	ldr	r2, [r4, #4]
 800abac:	68ab      	ldr	r3, [r5, #8]

    /* Write input buffer in Data register */
    hhash->Status = HASH_WriteData(hhash, hhash->pHashKeyBuffPtr, hhash->HashKeyCount);
 800abae:	6961      	ldr	r1, [r4, #20]
    - or fall through from the Step 2 processing carried out hereabove */
  if (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_3)
  {
    /************************** STEP 3 ******************************************/
    /* Configure the Number of valid bits in last word of the message */
    __HAL_HASH_SET_NBVALIDBITS(hhash->Init.KeySize);
 800abb0:	f002 0203 	and.w	r2, r2, #3
 800abb4:	f023 031f 	bic.w	r3, r3, #31
 800abb8:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 800abbc:	60ab      	str	r3, [r5, #8]

    /* Write input buffer in Data register */
    hhash->Status = HASH_WriteData(hhash, hhash->pHashKeyBuffPtr, hhash->HashKeyCount);
 800abbe:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800abc0:	4620      	mov	r0, r4
 800abc2:	f7ff fa87 	bl	800a0d4 <HASH_WriteData>
 800abc6:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
    if (hhash->Status != HAL_OK)
 800abca:	2800      	cmp	r0, #0
 800abcc:	d133      	bne.n	800ac36 <HMAC_Start+0x1f6>
    {
      return hhash->Status;
    }

    /* Check whether or not key entering process has been suspended */
    if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 800abce:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 800abd2:	2b08      	cmp	r3, #8
 800abd4:	d02a      	beq.n	800ac2c <HMAC_Start+0x1ec>
      /* Stop right there and return function status */
      return HAL_OK;
    }

    /* No processing suspension at this point: start the Digest calculation. */
    __HAL_HASH_START_DIGEST();
 800abd6:	68ab      	ldr	r3, [r5, #8]
 800abd8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800abdc:	60ab      	str	r3, [r5, #8]

    /* Wait for DCIS flag to be set */
     if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
 800abde:	4602      	mov	r2, r0
 800abe0:	9b06      	ldr	r3, [sp, #24]
 800abe2:	2102      	movs	r1, #2
 800abe4:	4620      	mov	r0, r4
 800abe6:	f7ff fb19 	bl	800a21c <HASH_WaitOnFlagUntilTimeout>
 800abea:	2800      	cmp	r0, #0
 800abec:	d1a5      	bne.n	800ab3a <HMAC_Start+0xfa>
    {
      return HAL_TIMEOUT;
    }

    /* Read the message digest */
    HASH_GetDigest(hhash->pHashOutBuffPtr, HASH_DIGEST_LENGTH());
 800abee:	682a      	ldr	r2, [r5, #0]
 800abf0:	4b12      	ldr	r3, [pc, #72]	; (800ac3c <HMAC_Start+0x1fc>)
 800abf2:	6920      	ldr	r0, [r4, #16]
 800abf4:	4013      	ands	r3, r2
 800abf6:	b173      	cbz	r3, 800ac16 <HMAC_Start+0x1d6>
 800abf8:	682a      	ldr	r2, [r5, #0]
 800abfa:	4b10      	ldr	r3, [pc, #64]	; (800ac3c <HMAC_Start+0x1fc>)
 800abfc:	4013      	ands	r3, r2
 800abfe:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800ac02:	d00a      	beq.n	800ac1a <HMAC_Start+0x1da>
 800ac04:	682a      	ldr	r2, [r5, #0]
 800ac06:	4b0d      	ldr	r3, [pc, #52]	; (800ac3c <HMAC_Start+0x1fc>)
 800ac08:	490c      	ldr	r1, [pc, #48]	; (800ac3c <HMAC_Start+0x1fc>)
 800ac0a:	4013      	ands	r3, r2
 800ac0c:	428b      	cmp	r3, r1
 800ac0e:	bf0c      	ite	eq
 800ac10:	2120      	moveq	r1, #32
 800ac12:	2110      	movne	r1, #16
 800ac14:	e002      	b.n	800ac1c <HMAC_Start+0x1dc>
 800ac16:	2114      	movs	r1, #20
 800ac18:	e000      	b.n	800ac1c <HMAC_Start+0x1dc>
 800ac1a:	211c      	movs	r1, #28
 800ac1c:	f7ff fa9c 	bl	800a158 <HASH_GetDigest>

    /* Reset HASH state machine */
    hhash->Phase = HAL_HASH_PHASE_READY;
 800ac20:	2301      	movs	r3, #1
 800ac22:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
  }

   /* Change the HASH state */
   hhash->State = HAL_HASH_STATE_READY;
 800ac26:	2301      	movs	r3, #1
 800ac28:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

   /* Process Unlock */
   __HAL_UNLOCK(hhash);
 800ac2c:	2000      	movs	r0, #0
 800ac2e:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
 800ac32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HMAC_Processing(hhash, Timeout);

  }
  else
  {
    return HAL_BUSY;
 800ac34:	2002      	movs	r0, #2
  }
}
 800ac36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ac38:	50060400 	.word	0x50060400
 800ac3c:	00040080 	.word	0x00040080

0800ac40 <OSPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart : Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef OSPI_WaitFlagStateUntilTimeout(OSPI_HandleTypeDef *hospi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
 800ac40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800ac44:	9d06      	ldr	r5, [sp, #24]
 800ac46:	4604      	mov	r4, r0
 800ac48:	460f      	mov	r7, r1
 800ac4a:	4616      	mov	r6, r2
 800ac4c:	4698      	mov	r8, r3
  /* Wait until flag is in expected state */
  while((__HAL_OSPI_GET_FLAG(hospi, Flag)) != State)
 800ac4e:	6821      	ldr	r1, [r4, #0]
 800ac50:	6a0a      	ldr	r2, [r1, #32]
 800ac52:	423a      	tst	r2, r7
 800ac54:	bf14      	ite	ne
 800ac56:	2201      	movne	r2, #1
 800ac58:	2200      	moveq	r2, #0
 800ac5a:	42b2      	cmp	r2, r6
 800ac5c:	d013      	beq.n	800ac86 <OSPI_WaitFlagStateUntilTimeout+0x46>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800ac5e:	1c6b      	adds	r3, r5, #1
 800ac60:	d0f6      	beq.n	800ac50 <OSPI_WaitFlagStateUntilTimeout+0x10>
    {
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800ac62:	f7fc f9d7 	bl	8007014 <HAL_GetTick>
 800ac66:	ebc8 0000 	rsb	r0, r8, r0
 800ac6a:	4285      	cmp	r5, r0
 800ac6c:	d301      	bcc.n	800ac72 <OSPI_WaitFlagStateUntilTimeout+0x32>
 800ac6e:	2d00      	cmp	r5, #0
 800ac70:	d1ed      	bne.n	800ac4e <OSPI_WaitFlagStateUntilTimeout+0xe>
      {
        hospi->State     = HAL_OSPI_STATE_ERROR;
 800ac72:	f44f 7300 	mov.w	r3, #512	; 0x200
 800ac76:	6463      	str	r3, [r4, #68]	; 0x44
        hospi->ErrorCode |= HAL_OSPI_ERROR_TIMEOUT;
 800ac78:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800ac7a:	f043 0301 	orr.w	r3, r3, #1
 800ac7e:	64a3      	str	r3, [r4, #72]	; 0x48
 800ac80:	2001      	movs	r0, #1
 800ac82:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
 800ac86:	2000      	movs	r0, #0
}
 800ac88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800ac8c <HAL_OSPI_MspInit>:
  * @brief  Initialize the OSPI MSP.
  * @param  hospi : OSPI handle
  * @retval None
  */
__weak void HAL_OSPI_MspInit(OSPI_HandleTypeDef *hospi)
{
 800ac8c:	4770      	bx	lr
	...

0800ac90 <HAL_OSPI_Init>:
  *         in the OSPI_InitTypeDef and initialize the associated handle.
  * @param  hospi : OSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_Init (OSPI_HandleTypeDef *hospi)
{
 800ac90:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800ac92:	4604      	mov	r4, r0
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tickstart = HAL_GetTick();
 800ac94:	f7fc f9be 	bl	8007014 <HAL_GetTick>
 800ac98:	4607      	mov	r7, r0

  /* Check the OSPI handle allocation */
  if (hospi == NULL)
 800ac9a:	2c00      	cmp	r4, #0
 800ac9c:	d05c      	beq.n	800ad58 <HAL_OSPI_Init+0xc8>
#if   defined (OCTOSPI_DCR3_MAXTRAN)
    assert_param(IS_OSPI_MAXTRAN        (hospi->Init.MaxTran));
#endif

    /* Initialize error code */
    hospi->ErrorCode = HAL_OSPI_ERROR_NONE;
 800ac9e:	2000      	movs	r0, #0
 800aca0:	64a0      	str	r0, [r4, #72]	; 0x48

    /* Check if the state is the reset state */
    if (hospi->State == HAL_OSPI_STATE_RESET)
 800aca2:	6c66      	ldr	r6, [r4, #68]	; 0x44
 800aca4:	2e00      	cmp	r6, #0
 800aca6:	d158      	bne.n	800ad5a <HAL_OSPI_Init+0xca>

      /* Init the low level hardware */
      hospi->MspInitCallback(hospi);
#else
      /* Initialization of the low level hardware */
      HAL_OSPI_MspInit(hospi);
 800aca8:	4620      	mov	r0, r4
 800acaa:	f7ff ffef 	bl	800ac8c <HAL_OSPI_MspInit>

      /* Configure the default timeout for the OSPI memory access */
      (void)HAL_OSPI_SetTimeout(hospi, HAL_OSPI_TIMEOUT_DEFAULT_VALUE);

      /* Configure memory type, device size, chip select high time, delay block bypass, free running clock, clock mode */
      MODIFY_REG(hospi->Instance->DCR1,
 800acae:	68e0      	ldr	r0, [r4, #12]
 800acb0:	6b21      	ldr	r1, [r4, #48]	; 0x30
 800acb2:	6825      	ldr	r5, [r4, #0]
 800acb4:	4301      	orrs	r1, r0
 800acb6:	69e0      	ldr	r0, [r4, #28]
 800acb8:	68ab      	ldr	r3, [r5, #8]
 800acba:	4308      	orrs	r0, r1
 800acbc:	4928      	ldr	r1, [pc, #160]	; (800ad60 <HAL_OSPI_Init+0xd0>)
 800acbe:	4019      	ands	r1, r3
 800acc0:	4301      	orrs	r1, r0
 800acc2:	6920      	ldr	r0, [r4, #16]
#if   defined (OCTOSPI_DCR3_MAXTRAN)
      /* Configure chip select boundary and maximun transfer */
      hospi->Instance->DCR3 = ((hospi->Init.ChipSelectBoundary << OCTOSPI_DCR3_CSBOUND_Pos) | (hospi->Init.MaxTran << OCTOSPI_DCR3_MAXTRAN_Pos));
#else
      /* Configure chip select boundary */
      hospi->Instance->DCR3 = (hospi->Init.ChipSelectBoundary << OCTOSPI_DCR3_CSBOUND_Pos);
 800acc4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c

      /* Configure the default timeout for the OSPI memory access */
      (void)HAL_OSPI_SetTimeout(hospi, HAL_OSPI_TIMEOUT_DEFAULT_VALUE);

      /* Configure memory type, device size, chip select high time, delay block bypass, free running clock, clock mode */
      MODIFY_REG(hospi->Instance->DCR1,
 800acc6:	3801      	subs	r0, #1
 800acc8:	ea41 4000 	orr.w	r0, r1, r0, lsl #16
 800accc:	6961      	ldr	r1, [r4, #20]
 800acce:	3901      	subs	r1, #1
  * @param  Timeout : Timeout for the memory access.
  * @retval None
  */
HAL_StatusTypeDef HAL_OSPI_SetTimeout(OSPI_HandleTypeDef *hospi, uint32_t Timeout)
{
  hospi->Timeout = Timeout;
 800acd0:	f241 3288 	movw	r2, #5000	; 0x1388

      /* Configure the default timeout for the OSPI memory access */
      (void)HAL_OSPI_SetTimeout(hospi, HAL_OSPI_TIMEOUT_DEFAULT_VALUE);

      /* Configure memory type, device size, chip select high time, delay block bypass, free running clock, clock mode */
      MODIFY_REG(hospi->Instance->DCR1,
 800acd4:	ea40 2101 	orr.w	r1, r0, r1, lsl #8
#if   defined (OCTOSPI_DCR3_MAXTRAN)
      /* Configure chip select boundary and maximun transfer */
      hospi->Instance->DCR3 = ((hospi->Init.ChipSelectBoundary << OCTOSPI_DCR3_CSBOUND_Pos) | (hospi->Init.MaxTran << OCTOSPI_DCR3_MAXTRAN_Pos));
#else
      /* Configure chip select boundary */
      hospi->Instance->DCR3 = (hospi->Init.ChipSelectBoundary << OCTOSPI_DCR3_CSBOUND_Pos);
 800acd8:	041b      	lsls	r3, r3, #16
  * @param  Timeout : Timeout for the memory access.
  * @retval None
  */
HAL_StatusTypeDef HAL_OSPI_SetTimeout(OSPI_HandleTypeDef *hospi, uint32_t Timeout)
{
  hospi->Timeout = Timeout;
 800acda:	64e2      	str	r2, [r4, #76]	; 0x4c

      /* Configure the default timeout for the OSPI memory access */
      (void)HAL_OSPI_SetTimeout(hospi, HAL_OSPI_TIMEOUT_DEFAULT_VALUE);

      /* Configure memory type, device size, chip select high time, delay block bypass, free running clock, clock mode */
      MODIFY_REG(hospi->Instance->DCR1,
 800acdc:	60a9      	str	r1, [r5, #8]
#if   defined (OCTOSPI_DCR3_MAXTRAN)
      /* Configure chip select boundary and maximun transfer */
      hospi->Instance->DCR3 = ((hospi->Init.ChipSelectBoundary << OCTOSPI_DCR3_CSBOUND_Pos) | (hospi->Init.MaxTran << OCTOSPI_DCR3_MAXTRAN_Pos));
#else
      /* Configure chip select boundary */
      hospi->Instance->DCR3 = (hospi->Init.ChipSelectBoundary << OCTOSPI_DCR3_CSBOUND_Pos);
 800acde:	612b      	str	r3, [r5, #16]
      /* Configure refresh */
      hospi->Instance->DCR4 = hospi->Init.Refresh;
#endif

      /* Configure FIFO threshold */
      MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FTHRES, ((hospi->Init.FifoThreshold - 1U) << OCTOSPI_CR_FTHRES_Pos));
 800ace0:	6829      	ldr	r1, [r5, #0]
 800ace2:	6863      	ldr	r3, [r4, #4]
 800ace4:	f421 51f8 	bic.w	r1, r1, #7936	; 0x1f00
 800ace8:	3b01      	subs	r3, #1
 800acea:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
 800acee:	6029      	str	r1, [r5, #0]

      /* Wait till busy flag is reset */
      status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);
 800acf0:	463b      	mov	r3, r7
 800acf2:	9200      	str	r2, [sp, #0]
 800acf4:	2120      	movs	r1, #32
 800acf6:	4632      	mov	r2, r6
 800acf8:	4620      	mov	r0, r4
 800acfa:	f7ff ffa1 	bl	800ac40 <OSPI_WaitFlagStateUntilTimeout>

      if (status == HAL_OK)
 800acfe:	2800      	cmp	r0, #0
 800ad00:	d12b      	bne.n	800ad5a <HAL_OSPI_Init+0xca>
      {
        /* Configure clock prescaler */
        MODIFY_REG(hospi->Instance->DCR2, OCTOSPI_DCR2_PRESCALER, ((hospi->Init.ClockPrescaler - 1U) << OCTOSPI_DCR2_PRESCALER_Pos));
 800ad02:	6823      	ldr	r3, [r4, #0]
 800ad04:	6a21      	ldr	r1, [r4, #32]
 800ad06:	68da      	ldr	r2, [r3, #12]

        /* Configure Dual Quad mode */
        MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_DQM, hospi->Init.DualQuad);

        /* Configure sample shifting and delay hold quarter cycle */
        MODIFY_REG(hospi->Instance->TCR, (OCTOSPI_TCR_SSHIFT | OCTOSPI_TCR_DHQC), (hospi->Init.SampleShifting | hospi->Init.DelayHoldQuarterCycle));
 800ad08:	6a65      	ldr	r5, [r4, #36]	; 0x24
      status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);

      if (status == HAL_OK)
      {
        /* Configure clock prescaler */
        MODIFY_REG(hospi->Instance->DCR2, OCTOSPI_DCR2_PRESCALER, ((hospi->Init.ClockPrescaler - 1U) << OCTOSPI_DCR2_PRESCALER_Pos));
 800ad0a:	3901      	subs	r1, #1
 800ad0c:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 800ad10:	430a      	orrs	r2, r1
 800ad12:	60da      	str	r2, [r3, #12]

        /* Configure Dual Quad mode */
        MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_DQM, hospi->Init.DualQuad);
 800ad14:	681a      	ldr	r2, [r3, #0]
 800ad16:	f022 0140 	bic.w	r1, r2, #64	; 0x40
 800ad1a:	68a2      	ldr	r2, [r4, #8]
 800ad1c:	430a      	orrs	r2, r1
 800ad1e:	601a      	str	r2, [r3, #0]

        /* Configure sample shifting and delay hold quarter cycle */
        MODIFY_REG(hospi->Instance->TCR, (OCTOSPI_TCR_SSHIFT | OCTOSPI_TCR_DHQC), (hospi->Init.SampleShifting | hospi->Init.DelayHoldQuarterCycle));
 800ad20:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
 800ad24:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800ad26:	f022 42a0 	bic.w	r2, r2, #1342177280	; 0x50000000
 800ad2a:	4329      	orrs	r1, r5
 800ad2c:	430a      	orrs	r2, r1
 800ad2e:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108

        /* Enable OctoSPI */
        __HAL_OSPI_ENABLE(hospi);
 800ad32:	681a      	ldr	r2, [r3, #0]
 800ad34:	f042 0201 	orr.w	r2, r2, #1
 800ad38:	601a      	str	r2, [r3, #0]

        /* Enable free running clock if needed : must be done after OSPI enable */
        if (hospi->Init.FreeRunningClock == HAL_OSPI_FREERUNCLK_ENABLE)
 800ad3a:	69a2      	ldr	r2, [r4, #24]
 800ad3c:	2a02      	cmp	r2, #2
        {
          SET_BIT(hospi->Instance->DCR1, OCTOSPI_DCR1_FRCK);
 800ad3e:	bf02      	ittt	eq
 800ad40:	689a      	ldreq	r2, [r3, #8]
 800ad42:	f042 0202 	orreq.w	r2, r2, #2
 800ad46:	609a      	streq	r2, [r3, #8]
        }

        /* Initialize the OSPI state */
        if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
 800ad48:	68e3      	ldr	r3, [r4, #12]
 800ad4a:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
        {
          hospi->State = HAL_OSPI_STATE_HYPERBUS_INIT;
 800ad4e:	bf0c      	ite	eq
 800ad50:	2301      	moveq	r3, #1
        }
        else
        {
          hospi->State = HAL_OSPI_STATE_READY;
 800ad52:	2302      	movne	r3, #2
 800ad54:	6463      	str	r3, [r4, #68]	; 0x44
 800ad56:	e000      	b.n	800ad5a <HAL_OSPI_Init+0xca>
  uint32_t tickstart = HAL_GetTick();

  /* Check the OSPI handle allocation */
  if (hospi == NULL)
  {
    status = HAL_ERROR;
 800ad58:	2001      	movs	r0, #1
    }
  }

  /* Return function status */
  return status;
}
 800ad5a:	b003      	add	sp, #12
 800ad5c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800ad5e:	bf00      	nop
 800ad60:	f8e0f8f4 	.word	0xf8e0f8f4

0800ad64 <HAL_OSPI_Command>:
  * @param  cmd     : structure that contains the command configuration information
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_Command(OSPI_HandleTypeDef *hospi, OSPI_RegularCmdTypeDef *cmd, uint32_t Timeout)
{
 800ad64:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ad68:	4605      	mov	r5, r0
 800ad6a:	460c      	mov	r4, r1
 800ad6c:	4691      	mov	r9, r2
  HAL_StatusTypeDef status;
  uint32_t state;
  uint32_t tickstart = HAL_GetTick();
 800ad6e:	f7fc f951 	bl	8007014 <HAL_GetTick>

  assert_param(IS_OSPI_DQS_MODE (cmd->DQSMode));
  assert_param(IS_OSPI_SIOO_MODE(cmd->SIOOMode));

  /* Check the state of the driver */
  state = hospi->State;
 800ad72:	6c6b      	ldr	r3, [r5, #68]	; 0x44
  if (((state == HAL_OSPI_STATE_READY)         && (hospi->Init.MemoryType != HAL_OSPI_MEMTYPE_HYPERBUS)) ||
 800ad74:	2b02      	cmp	r3, #2
  */
HAL_StatusTypeDef HAL_OSPI_Command(OSPI_HandleTypeDef *hospi, OSPI_RegularCmdTypeDef *cmd, uint32_t Timeout)
{
  HAL_StatusTypeDef status;
  uint32_t state;
  uint32_t tickstart = HAL_GetTick();
 800ad76:	4680      	mov	r8, r0
  assert_param(IS_OSPI_DQS_MODE (cmd->DQSMode));
  assert_param(IS_OSPI_SIOO_MODE(cmd->SIOOMode));

  /* Check the state of the driver */
  state = hospi->State;
  if (((state == HAL_OSPI_STATE_READY)         && (hospi->Init.MemoryType != HAL_OSPI_MEMTYPE_HYPERBUS)) ||
 800ad78:	d104      	bne.n	800ad84 <HAL_OSPI_Command+0x20>
 800ad7a:	68eb      	ldr	r3, [r5, #12]
 800ad7c:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 800ad80:	d10c      	bne.n	800ad9c <HAL_OSPI_Command+0x38>
 800ad82:	e0f5      	b.n	800af70 <HAL_OSPI_Command+0x20c>
 800ad84:	2b14      	cmp	r3, #20
 800ad86:	d102      	bne.n	800ad8e <HAL_OSPI_Command+0x2a>
      ((state == HAL_OSPI_STATE_READ_CMD_CFG)  && (cmd->OperationType == HAL_OSPI_OPTYPE_WRITE_CFG))     ||
 800ad88:	6823      	ldr	r3, [r4, #0]
 800ad8a:	2b02      	cmp	r3, #2
 800ad8c:	e004      	b.n	800ad98 <HAL_OSPI_Command+0x34>
 800ad8e:	2b24      	cmp	r3, #36	; 0x24
 800ad90:	f040 80ee 	bne.w	800af70 <HAL_OSPI_Command+0x20c>
      ((state == HAL_OSPI_STATE_WRITE_CMD_CFG) && (cmd->OperationType == HAL_OSPI_OPTYPE_READ_CFG)))
 800ad94:	6823      	ldr	r3, [r4, #0]
 800ad96:	2b01      	cmp	r3, #1
 800ad98:	f040 80ea 	bne.w	800af70 <HAL_OSPI_Command+0x20c>
  {
    /* Wait till busy flag is reset */
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, Timeout);
 800ad9c:	f8cd 9000 	str.w	r9, [sp]
 800ada0:	4643      	mov	r3, r8
 800ada2:	2200      	movs	r2, #0
 800ada4:	2120      	movs	r1, #32
 800ada6:	4628      	mov	r0, r5
 800ada8:	f7ff ff4a 	bl	800ac40 <OSPI_WaitFlagStateUntilTimeout>

    if (status == HAL_OK)
 800adac:	2800      	cmp	r0, #0
 800adae:	f040 8100 	bne.w	800afb2 <HAL_OSPI_Command+0x24e>
{
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t *ccr_reg, *tcr_reg, *ir_reg, *abr_reg;

  /* Re-initialize the value of the functional mode */
  MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, 0U);
 800adb2:	682a      	ldr	r2, [r5, #0]
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, Timeout);

    if (status == HAL_OK)
    {
      /* Initialize error code */
      hospi->ErrorCode = HAL_OSPI_ERROR_NONE;
 800adb4:	64a8      	str	r0, [r5, #72]	; 0x48
{
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t *ccr_reg, *tcr_reg, *ir_reg, *abr_reg;

  /* Re-initialize the value of the functional mode */
  MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, 0U);
 800adb6:	6813      	ldr	r3, [r2, #0]
 800adb8:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 800adbc:	6013      	str	r3, [r2, #0]

  /* Configure the flash ID */
  if (hospi->Init.DualQuad == HAL_OSPI_DUALQUAD_DISABLE)
 800adbe:	68ab      	ldr	r3, [r5, #8]
 800adc0:	b92b      	cbnz	r3, 800adce <HAL_OSPI_Command+0x6a>
  {
    MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FSEL, cmd->FlashId);
 800adc2:	6813      	ldr	r3, [r2, #0]
 800adc4:	f023 0180 	bic.w	r1, r3, #128	; 0x80
 800adc8:	6863      	ldr	r3, [r4, #4]
 800adca:	430b      	orrs	r3, r1
 800adcc:	6013      	str	r3, [r2, #0]
  }

  if (cmd->OperationType == HAL_OSPI_OPTYPE_WRITE_CFG)
 800adce:	6823      	ldr	r3, [r4, #0]
    ir_reg  = &(hospi->Instance->IR);
    abr_reg = &(hospi->Instance->ABR);
  }

  /* Configure the CCR register with DQS and SIOO modes */
  *ccr_reg = (cmd->DQSMode | cmd->SIOOMode);
 800add0:	6ca7      	ldr	r7, [r4, #72]	; 0x48
 800add2:	6ce6      	ldr	r6, [r4, #76]	; 0x4c
  if (hospi->Init.DualQuad == HAL_OSPI_DUALQUAD_DISABLE)
  {
    MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FSEL, cmd->FlashId);
  }

  if (cmd->OperationType == HAL_OSPI_OPTYPE_WRITE_CFG)
 800add4:	2b02      	cmp	r3, #2
  {
    ccr_reg = &(hospi->Instance->WCCR);
 800add6:	bf0c      	ite	eq
 800add8:	f502 73c0 	addeq.w	r3, r2, #384	; 0x180
    ir_reg  = &(hospi->Instance->WIR);
    abr_reg = &(hospi->Instance->WABR);
  }
  else
  {
    ccr_reg = &(hospi->Instance->CCR);
 800addc:	f502 7380 	addne.w	r3, r2, #256	; 0x100
    ir_reg  = &(hospi->Instance->IR);
    abr_reg = &(hospi->Instance->ABR);
  }

  /* Configure the CCR register with DQS and SIOO modes */
  *ccr_reg = (cmd->DQSMode | cmd->SIOOMode);
 800ade0:	ea46 0607 	orr.w	r6, r6, r7
 800ade4:	601e      	str	r6, [r3, #0]

  if (cmd->AlternateBytesMode != HAL_OSPI_ALTERNATE_BYTES_NONE)
 800ade6:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  }

  if (cmd->OperationType == HAL_OSPI_OPTYPE_WRITE_CFG)
  {
    ccr_reg = &(hospi->Instance->WCCR);
    tcr_reg = &(hospi->Instance->WTCR);
 800ade8:	bf03      	ittte	eq
 800adea:	f502 7ec4 	addeq.w	lr, r2, #392	; 0x188
    ir_reg  = &(hospi->Instance->WIR);
 800adee:	f502 71c8 	addeq.w	r1, r2, #400	; 0x190
    abr_reg = &(hospi->Instance->WABR);
 800adf2:	f502 7cd0 	addeq.w	ip, r2, #416	; 0x1a0
  }
  else
  {
    ccr_reg = &(hospi->Instance->CCR);
    tcr_reg = &(hospi->Instance->TCR);
 800adf6:	f502 7e84 	addne.w	lr, r2, #264	; 0x108
    ir_reg  = &(hospi->Instance->IR);
 800adfa:	bf1c      	itt	ne
 800adfc:	f502 7188 	addne.w	r1, r2, #272	; 0x110
    abr_reg = &(hospi->Instance->ABR);
 800ae00:	f502 7c90 	addne.w	ip, r2, #288	; 0x120
  }

  /* Configure the CCR register with DQS and SIOO modes */
  *ccr_reg = (cmd->DQSMode | cmd->SIOOMode);

  if (cmd->AlternateBytesMode != HAL_OSPI_ALTERNATE_BYTES_NONE)
 800ae04:	b176      	cbz	r6, 800ae24 <HAL_OSPI_Command+0xc0>
  {
    /* Configure the ABR register with alternate bytes value */
    *abr_reg = cmd->AlternateBytes;
 800ae06:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 800ae08:	f8cc 6000 	str.w	r6, [ip]

    /* Configure the CCR register with alternate bytes communication parameters */
    MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ABMODE | OCTOSPI_CCR_ABDTR | OCTOSPI_CCR_ABSIZE),
 800ae0c:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 800ae0e:	6b66      	ldr	r6, [r4, #52]	; 0x34
 800ae10:	f8d3 c000 	ldr.w	ip, [r3]
 800ae14:	433e      	orrs	r6, r7
 800ae16:	6b27      	ldr	r7, [r4, #48]	; 0x30
 800ae18:	f42c 1c7c 	bic.w	ip, ip, #4128768	; 0x3f0000
 800ae1c:	433e      	orrs	r6, r7
 800ae1e:	ea46 060c 	orr.w	r6, r6, ip
 800ae22:	601e      	str	r6, [r3, #0]
                           (cmd->AlternateBytesMode | cmd->AlternateBytesDtrMode | cmd->AlternateBytesSize));
  }

  /* Configure the TCR register with the number of dummy cycles */
  MODIFY_REG((*tcr_reg), OCTOSPI_TCR_DCYC, cmd->DummyCycles);
 800ae24:	f8de 6000 	ldr.w	r6, [lr]
 800ae28:	f026 071f 	bic.w	r7, r6, #31
 800ae2c:	6c66      	ldr	r6, [r4, #68]	; 0x44
 800ae2e:	433e      	orrs	r6, r7
 800ae30:	f8ce 6000 	str.w	r6, [lr]

  if (cmd->DataMode != HAL_OSPI_DATA_NONE)
 800ae34:	f8d4 c038 	ldr.w	ip, [r4, #56]	; 0x38
 800ae38:	f1bc 0f00 	cmp.w	ip, #0
 800ae3c:	d004      	beq.n	800ae48 <HAL_OSPI_Command+0xe4>
  {
    if (cmd->OperationType == HAL_OSPI_OPTYPE_COMMON_CFG)
 800ae3e:	6826      	ldr	r6, [r4, #0]
 800ae40:	b916      	cbnz	r6, 800ae48 <HAL_OSPI_Command+0xe4>
    {
      /* Configure the DLR register with the number of data */
      hospi->Instance->DLR = (cmd->NbData - 1U);
 800ae42:	6be6      	ldr	r6, [r4, #60]	; 0x3c
 800ae44:	3e01      	subs	r6, #1
 800ae46:	6416      	str	r6, [r2, #64]	; 0x40
    }
  }

  if (cmd->InstructionMode != HAL_OSPI_INSTRUCTION_NONE)
 800ae48:	68e7      	ldr	r7, [r4, #12]
 800ae4a:	69e6      	ldr	r6, [r4, #28]
 800ae4c:	2f00      	cmp	r7, #0
 800ae4e:	d06a      	beq.n	800af26 <HAL_OSPI_Command+0x1c2>
 800ae50:	f8d4 b014 	ldr.w	fp, [r4, #20]
 800ae54:	f8d4 a010 	ldr.w	sl, [r4, #16]
  {
    if (cmd->AddressMode != HAL_OSPI_ADDRESS_NONE)
 800ae58:	2e00      	cmp	r6, #0
 800ae5a:	d038      	beq.n	800aece <HAL_OSPI_Command+0x16a>
      if (cmd->DataMode != HAL_OSPI_DATA_NONE)
      {
        /* ---- Command with instruction, address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE  | OCTOSPI_CCR_IDTR  | OCTOSPI_CCR_ISIZE  |
 800ae5c:	f8d3 e000 	ldr.w	lr, [r3]

  if (cmd->InstructionMode != HAL_OSPI_INSTRUCTION_NONE)
  {
    if (cmd->AddressMode != HAL_OSPI_ADDRESS_NONE)
    {
      if (cmd->DataMode != HAL_OSPI_DATA_NONE)
 800ae60:	f1bc 0f00 	cmp.w	ip, #0
 800ae64:	d013      	beq.n	800ae8e <HAL_OSPI_Command+0x12a>
      {
        /* ---- Command with instruction, address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE  | OCTOSPI_CCR_IDTR  | OCTOSPI_CCR_ISIZE  |
 800ae66:	ea4c 0707 	orr.w	r7, ip, r7
 800ae6a:	433e      	orrs	r6, r7
 800ae6c:	ea46 0b0b 	orr.w	fp, r6, fp
 800ae70:	6a67      	ldr	r7, [r4, #36]	; 0x24
 800ae72:	6a26      	ldr	r6, [r4, #32]
 800ae74:	ea4b 0a0a 	orr.w	sl, fp, sl
 800ae78:	ea4a 0707 	orr.w	r7, sl, r7
 800ae7c:	4337      	orrs	r7, r6
 800ae7e:	6c26      	ldr	r6, [r4, #64]	; 0x40
 800ae80:	433e      	orrs	r6, r7
 800ae82:	4f4d      	ldr	r7, [pc, #308]	; (800afb8 <HAL_OSPI_Command+0x254>)
 800ae84:	ea0e 0707 	and.w	r7, lr, r7
 800ae88:	4337      	orrs	r7, r6
 800ae8a:	601f      	str	r7, [r3, #0]
 800ae8c:	e01c      	b.n	800aec8 <HAL_OSPI_Command+0x164>
      else
      {
        /* ---- Command with instruction and address ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE  | OCTOSPI_CCR_IDTR  | OCTOSPI_CCR_ISIZE  |
 800ae8e:	4337      	orrs	r7, r6
 800ae90:	ea47 0b0b 	orr.w	fp, r7, fp
 800ae94:	6a66      	ldr	r6, [r4, #36]	; 0x24
 800ae96:	ea4b 0a0a 	orr.w	sl, fp, sl
 800ae9a:	ea4a 0a06 	orr.w	sl, sl, r6
 800ae9e:	6a26      	ldr	r6, [r4, #32]
 800aea0:	f42e 5e7c 	bic.w	lr, lr, #16128	; 0x3f00
 800aea4:	ea4a 0606 	orr.w	r6, sl, r6
 800aea8:	f02e 0e3f 	bic.w	lr, lr, #63	; 0x3f
 800aeac:	ea46 060e 	orr.w	r6, r6, lr
 800aeb0:	601e      	str	r6, [r3, #0]
                                OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE),
                               (cmd->InstructionMode | cmd->InstructionDtrMode | cmd->InstructionSize |
                                cmd->AddressMode     | cmd->AddressDtrMode     | cmd->AddressSize));

        /* The DHQC bit is linked with DDTR bit which should be activated */
        if ((hospi->Init.DelayHoldQuarterCycle == HAL_OSPI_DHQC_ENABLE) &&
 800aeb2:	6aae      	ldr	r6, [r5, #40]	; 0x28
 800aeb4:	f1b6 5f80 	cmp.w	r6, #268435456	; 0x10000000
 800aeb8:	d106      	bne.n	800aec8 <HAL_OSPI_Command+0x164>
 800aeba:	6966      	ldr	r6, [r4, #20]
 800aebc:	2e08      	cmp	r6, #8
            (cmd->InstructionDtrMode == HAL_OSPI_INSTRUCTION_DTR_ENABLE))
        {
          MODIFY_REG((*ccr_reg), OCTOSPI_CCR_DDTR, HAL_OSPI_DATA_DTR_ENABLE);
 800aebe:	bf02      	ittt	eq
 800aec0:	681e      	ldreq	r6, [r3, #0]
 800aec2:	f046 6600 	orreq.w	r6, r6, #134217728	; 0x8000000
 800aec6:	601e      	streq	r6, [r3, #0]
        }
      }

      /* Configure the IR register with the instruction value */
      *ir_reg = cmd->Instruction;
 800aec8:	68a3      	ldr	r3, [r4, #8]
 800aeca:	600b      	str	r3, [r1, #0]
 800aecc:	e04b      	b.n	800af66 <HAL_OSPI_Command+0x202>
      /* Configure the AR register with the address value */
      hospi->Instance->AR = cmd->Address;
    }
    else
    {
      if (cmd->DataMode != HAL_OSPI_DATA_NONE)
 800aece:	f1bc 0f00 	cmp.w	ip, #0
 800aed2:	d010      	beq.n	800aef6 <HAL_OSPI_Command+0x192>
      {
        /* ---- Command with instruction and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE | OCTOSPI_CCR_IDTR | OCTOSPI_CCR_ISIZE |
 800aed4:	ea4c 0707 	orr.w	r7, ip, r7
 800aed8:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800aeda:	681e      	ldr	r6, [r3, #0]
 800aedc:	ea47 0b0b 	orr.w	fp, r7, fp
 800aee0:	ea4b 0a0a 	orr.w	sl, fp, sl
 800aee4:	ea4a 0a02 	orr.w	sl, sl, r2
 800aee8:	f026 6270 	bic.w	r2, r6, #251658240	; 0xf000000
 800aeec:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 800aef0:	ea4a 0202 	orr.w	r2, sl, r2
 800aef4:	e013      	b.n	800af1e <HAL_OSPI_Command+0x1ba>
      else
      {
        /* ---- Command with only instruction ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE | OCTOSPI_CCR_IDTR | OCTOSPI_CCR_ISIZE),
 800aef6:	681a      	ldr	r2, [r3, #0]
 800aef8:	ea47 070b 	orr.w	r7, r7, fp
 800aefc:	ea47 0a0a 	orr.w	sl, r7, sl
 800af00:	f022 073f 	bic.w	r7, r2, #63	; 0x3f
 800af04:	ea4a 0707 	orr.w	r7, sl, r7
 800af08:	601f      	str	r7, [r3, #0]
                               (cmd->InstructionMode | cmd->InstructionDtrMode | cmd->InstructionSize));

        /* The DHQC bit is linked with DDTR bit which should be activated */
        if ((hospi->Init.DelayHoldQuarterCycle == HAL_OSPI_DHQC_ENABLE) &&
 800af0a:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 800af0c:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
 800af10:	d106      	bne.n	800af20 <HAL_OSPI_Command+0x1bc>
 800af12:	6962      	ldr	r2, [r4, #20]
 800af14:	2a08      	cmp	r2, #8
 800af16:	d103      	bne.n	800af20 <HAL_OSPI_Command+0x1bc>
            (cmd->InstructionDtrMode == HAL_OSPI_INSTRUCTION_DTR_ENABLE))
        {
          MODIFY_REG((*ccr_reg), OCTOSPI_CCR_DDTR, HAL_OSPI_DATA_DTR_ENABLE);
 800af18:	681a      	ldr	r2, [r3, #0]
 800af1a:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 800af1e:	601a      	str	r2, [r3, #0]
        }
      }

      /* Configure the IR register with the instruction value */
      *ir_reg = cmd->Instruction;
 800af20:	68a3      	ldr	r3, [r4, #8]
 800af22:	600b      	str	r3, [r1, #0]
 800af24:	e028      	b.n	800af78 <HAL_OSPI_Command+0x214>

    }
  }
  else
  {
    if (cmd->AddressMode != HAL_OSPI_ADDRESS_NONE)
 800af26:	b30e      	cbz	r6, 800af6c <HAL_OSPI_Command+0x208>
 800af28:	6a67      	ldr	r7, [r4, #36]	; 0x24
 800af2a:	6a21      	ldr	r1, [r4, #32]
      if (cmd->DataMode != HAL_OSPI_DATA_NONE)
      {
        /* ---- Command with address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE |
 800af2c:	f8d3 e000 	ldr.w	lr, [r3]
  }
  else
  {
    if (cmd->AddressMode != HAL_OSPI_ADDRESS_NONE)
    {
      if (cmd->DataMode != HAL_OSPI_DATA_NONE)
 800af30:	f1bc 0f00 	cmp.w	ip, #0
 800af34:	d010      	beq.n	800af58 <HAL_OSPI_Command+0x1f4>
      {
        /* ---- Command with address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE |
 800af36:	ea4c 0c06 	orr.w	ip, ip, r6
 800af3a:	ea4c 0c07 	orr.w	ip, ip, r7
 800af3e:	ea4c 0c01 	orr.w	ip, ip, r1
 800af42:	6c21      	ldr	r1, [r4, #64]	; 0x40
 800af44:	f02e 6e70 	bic.w	lr, lr, #251658240	; 0xf000000
 800af48:	ea4c 0101 	orr.w	r1, ip, r1
 800af4c:	f42e 5e7c 	bic.w	lr, lr, #16128	; 0x3f00
 800af50:	ea41 010e 	orr.w	r1, r1, lr
 800af54:	6019      	str	r1, [r3, #0]
 800af56:	e006      	b.n	800af66 <HAL_OSPI_Command+0x202>
      else
      {
        /* ---- Command with only address ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE),
 800af58:	4337      	orrs	r7, r6
 800af5a:	430f      	orrs	r7, r1
 800af5c:	f42e 5e7c 	bic.w	lr, lr, #16128	; 0x3f00
 800af60:	ea47 070e 	orr.w	r7, r7, lr
 800af64:	601f      	str	r7, [r3, #0]
                               (cmd->AddressMode | cmd->AddressDtrMode | cmd->AddressSize));
      }

      /* Configure the AR register with the instruction value */
      hospi->Instance->AR = cmd->Address;
 800af66:	69a3      	ldr	r3, [r4, #24]
 800af68:	6493      	str	r3, [r2, #72]	; 0x48
 800af6a:	e005      	b.n	800af78 <HAL_OSPI_Command+0x214>
    }
    else
    {
      /* ---- Invalid command configuration (no instruction, no address) ---- */
      status = HAL_ERROR;
      hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
 800af6c:	2308      	movs	r3, #8
 800af6e:	e000      	b.n	800af72 <HAL_OSPI_Command+0x20e>
    }
  }
  else
  {
    status = HAL_ERROR;
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 800af70:	2310      	movs	r3, #16
 800af72:	64ab      	str	r3, [r5, #72]	; 0x48
      }
    }
  }
  else
  {
    status = HAL_ERROR;
 800af74:	2001      	movs	r0, #1
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
  }

  /* Return function status */
  return status;
 800af76:	e01c      	b.n	800afb2 <HAL_OSPI_Command+0x24e>
      /* Configure the registers */
      status = OSPI_ConfigCmd(hospi, cmd);

      if (status == HAL_OK)
      {
        if (cmd->DataMode == HAL_OSPI_DATA_NONE)
 800af78:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800af7a:	b95b      	cbnz	r3, 800af94 <HAL_OSPI_Command+0x230>
        {
          /* When there is no data phase, the transfer start as soon as the configuration is done
             so wait until TC flag is set to go back in idle state */
          status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_TC, SET, tickstart, Timeout);
 800af7c:	4643      	mov	r3, r8
 800af7e:	2201      	movs	r2, #1
 800af80:	f8cd 9000 	str.w	r9, [sp]
 800af84:	2102      	movs	r1, #2
 800af86:	4628      	mov	r0, r5
 800af88:	f7ff fe5a 	bl	800ac40 <OSPI_WaitFlagStateUntilTimeout>

          __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
 800af8c:	682b      	ldr	r3, [r5, #0]
 800af8e:	2202      	movs	r2, #2
 800af90:	625a      	str	r2, [r3, #36]	; 0x24
 800af92:	e00e      	b.n	800afb2 <HAL_OSPI_Command+0x24e>
        }
        else
        {
          /* Update the state */
          if (cmd->OperationType == HAL_OSPI_OPTYPE_COMMON_CFG)
 800af94:	6823      	ldr	r3, [r4, #0]
 800af96:	b143      	cbz	r3, 800afaa <HAL_OSPI_Command+0x246>
          {
            hospi->State = HAL_OSPI_STATE_CMD_CFG;
          }
          else if (cmd->OperationType == HAL_OSPI_OPTYPE_READ_CFG)
 800af98:	2b01      	cmp	r3, #1
          {
            if (hospi->State == HAL_OSPI_STATE_WRITE_CMD_CFG)
 800af9a:	6c6b      	ldr	r3, [r5, #68]	; 0x44
          /* Update the state */
          if (cmd->OperationType == HAL_OSPI_OPTYPE_COMMON_CFG)
          {
            hospi->State = HAL_OSPI_STATE_CMD_CFG;
          }
          else if (cmd->OperationType == HAL_OSPI_OPTYPE_READ_CFG)
 800af9c:	d103      	bne.n	800afa6 <HAL_OSPI_Command+0x242>
          {
            if (hospi->State == HAL_OSPI_STATE_WRITE_CMD_CFG)
 800af9e:	2b24      	cmp	r3, #36	; 0x24
 800afa0:	d003      	beq.n	800afaa <HAL_OSPI_Command+0x246>
            {
              hospi->State = HAL_OSPI_STATE_CMD_CFG;
            }
            else
            {
              hospi->State = HAL_OSPI_STATE_READ_CMD_CFG;
 800afa2:	2314      	movs	r3, #20
 800afa4:	e004      	b.n	800afb0 <HAL_OSPI_Command+0x24c>
            }
          }
          else
          {
            if (hospi->State == HAL_OSPI_STATE_READ_CMD_CFG)
 800afa6:	2b14      	cmp	r3, #20
 800afa8:	d101      	bne.n	800afae <HAL_OSPI_Command+0x24a>
            {
              hospi->State = HAL_OSPI_STATE_CMD_CFG;
 800afaa:	2304      	movs	r3, #4
 800afac:	e000      	b.n	800afb0 <HAL_OSPI_Command+0x24c>
            }
            else
            {
              hospi->State = HAL_OSPI_STATE_WRITE_CMD_CFG;
 800afae:	2324      	movs	r3, #36	; 0x24
 800afb0:	646b      	str	r3, [r5, #68]	; 0x44
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
  }

  /* Return function status */
  return status;
}
 800afb2:	b003      	add	sp, #12
 800afb4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800afb8:	f0ffc0c0 	.word	0xf0ffc0c0

0800afbc <HAL_OSPI_Receive>:
  * @param  Timeout : Timeout duration
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_Receive(OSPI_HandleTypeDef *hospi, uint8_t *pData, uint32_t Timeout)
{
 800afbc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 800afc0:	4604      	mov	r4, r0
 800afc2:	4688      	mov	r8, r1
 800afc4:	4617      	mov	r7, r2
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
 800afc6:	f7fc f825 	bl	8007014 <HAL_GetTick>
  __IO uint32_t *data_reg = &hospi->Instance->DR;
 800afca:	6825      	ldr	r5, [r4, #0]
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_Receive(OSPI_HandleTypeDef *hospi, uint8_t *pData, uint32_t Timeout)
{
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
 800afcc:	4606      	mov	r6, r0
  __IO uint32_t *data_reg = &hospi->Instance->DR;
  uint32_t addr_reg = hospi->Instance->AR;
 800afce:	6caa      	ldr	r2, [r5, #72]	; 0x48
  uint32_t ir_reg = hospi->Instance->IR;
 800afd0:	f8d5 1110 	ldr.w	r1, [r5, #272]	; 0x110

  /* Check the data pointer allocation */
  if (pData == NULL)
 800afd4:	f1b8 0f00 	cmp.w	r8, #0
 800afd8:	d101      	bne.n	800afde <HAL_OSPI_Receive+0x22>
  {
    status = HAL_ERROR;
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
 800afda:	2308      	movs	r3, #8
 800afdc:	e033      	b.n	800b046 <HAL_OSPI_Receive+0x8a>
  }
  else
  {
    /* Check the state */
    if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
 800afde:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800afe0:	2b04      	cmp	r3, #4
 800afe2:	d12f      	bne.n	800b044 <HAL_OSPI_Receive+0x88>
    {
      /* Configure counters and size */
      hospi->XferCount = READ_REG(hospi->Instance->DLR) + 1U;
 800afe4:	6c2b      	ldr	r3, [r5, #64]	; 0x40
      hospi->XferSize  = hospi->XferCount;
      hospi->pBuffPtr  = pData;
 800afe6:	f8c4 8034 	str.w	r8, [r4, #52]	; 0x34
  {
    /* Check the state */
    if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
    {
      /* Configure counters and size */
      hospi->XferCount = READ_REG(hospi->Instance->DLR) + 1U;
 800afea:	3301      	adds	r3, #1
 800afec:	63e3      	str	r3, [r4, #60]	; 0x3c
      hospi->XferSize  = hospi->XferCount;
 800afee:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800aff0:	63a3      	str	r3, [r4, #56]	; 0x38
      hospi->pBuffPtr  = pData;

      /* Configure CR register with functional mode as indirect read */
      MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, OSPI_FUNCTIONAL_MODE_INDIRECT_READ);
 800aff2:	682b      	ldr	r3, [r5, #0]
 800aff4:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 800aff8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800affc:	602b      	str	r3, [r5, #0]

      /* Trig the transfer by re-writing address or instruction register */
      if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
 800affe:	68e3      	ldr	r3, [r4, #12]
 800b000:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 800b004:	d004      	beq.n	800b010 <HAL_OSPI_Receive+0x54>
      {
        WRITE_REG(hospi->Instance->AR, addr_reg);
      }
      else
      {
        if (READ_BIT(hospi->Instance->CCR, OCTOSPI_CCR_ADMODE) != HAL_OSPI_ADDRESS_NONE)
 800b006:	f8d5 3100 	ldr.w	r3, [r5, #256]	; 0x100
 800b00a:	f413 6fe0 	tst.w	r3, #1792	; 0x700
 800b00e:	d001      	beq.n	800b014 <HAL_OSPI_Receive+0x58>
        {
          WRITE_REG(hospi->Instance->AR, addr_reg);
 800b010:	64aa      	str	r2, [r5, #72]	; 0x48
 800b012:	e001      	b.n	800b018 <HAL_OSPI_Receive+0x5c>
        }
        else
        {
          WRITE_REG(hospi->Instance->IR, ir_reg);
 800b014:	f8c5 1110 	str.w	r1, [r5, #272]	; 0x110
      }

      do
      {
        /* Wait till fifo threshold or transfer complete flags are set to read received data */
        status = OSPI_WaitFlagStateUntilTimeout(hospi, (HAL_OSPI_FLAG_FT | HAL_OSPI_FLAG_TC), SET, tickstart, Timeout);
 800b018:	9700      	str	r7, [sp, #0]
 800b01a:	4633      	mov	r3, r6
 800b01c:	2201      	movs	r2, #1
 800b01e:	2106      	movs	r1, #6
 800b020:	4620      	mov	r0, r4
 800b022:	f7ff fe0d 	bl	800ac40 <OSPI_WaitFlagStateUntilTimeout>

        if (status != HAL_OK)
 800b026:	b9e8      	cbnz	r0, 800b064 <HAL_OSPI_Receive+0xa8>
        {
          break;
        }

        *hospi->pBuffPtr = *((__IO uint8_t *)data_reg);
 800b028:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800b02a:	f895 2050 	ldrb.w	r2, [r5, #80]	; 0x50
 800b02e:	701a      	strb	r2, [r3, #0]
        hospi->pBuffPtr++;
 800b030:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800b032:	3301      	adds	r3, #1
 800b034:	6363      	str	r3, [r4, #52]	; 0x34
        hospi->XferCount--;
 800b036:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800b038:	3b01      	subs	r3, #1
 800b03a:	63e3      	str	r3, [r4, #60]	; 0x3c
      } while(hospi->XferCount > 0U);
 800b03c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800b03e:	2b00      	cmp	r3, #0
 800b040:	d1ea      	bne.n	800b018 <HAL_OSPI_Receive+0x5c>
 800b042:	e003      	b.n	800b04c <HAL_OSPI_Receive+0x90>
      }
    }
    else
    {
      status = HAL_ERROR;
      hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 800b044:	2310      	movs	r3, #16
 800b046:	64a3      	str	r3, [r4, #72]	; 0x48
        }
      }
    }
    else
    {
      status = HAL_ERROR;
 800b048:	2001      	movs	r0, #1
 800b04a:	e00b      	b.n	800b064 <HAL_OSPI_Receive+0xa8>
      } while(hospi->XferCount > 0U);

      if (status == HAL_OK)
      {
        /* Wait till transfer complete flag is set to go back in idle state */
        status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_TC, SET, tickstart, Timeout);
 800b04c:	9700      	str	r7, [sp, #0]
 800b04e:	4633      	mov	r3, r6
 800b050:	2201      	movs	r2, #1
 800b052:	2102      	movs	r1, #2
 800b054:	4620      	mov	r0, r4
 800b056:	f7ff fdf3 	bl	800ac40 <OSPI_WaitFlagStateUntilTimeout>

        if (status == HAL_OK)
 800b05a:	b918      	cbnz	r0, 800b064 <HAL_OSPI_Receive+0xa8>
        {
          /* Clear transfer complete flag */
          __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
 800b05c:	6822      	ldr	r2, [r4, #0]
 800b05e:	2302      	movs	r3, #2
 800b060:	6253      	str	r3, [r2, #36]	; 0x24

          /* Update state */
          hospi->State = HAL_OSPI_STATE_READY;
 800b062:	6463      	str	r3, [r4, #68]	; 0x44
    }
  }

  /* Return function status */
  return status;
}
 800b064:	b002      	add	sp, #8
 800b066:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800b06a <HAL_OSPI_AutoPolling>:
  * @note   This function is used only in Automatic Polling Mode
  * @note   This function should not be used when the memory is in octal mode (see Errata Sheet)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_AutoPolling(OSPI_HandleTypeDef *hospi, OSPI_AutoPollingTypeDef *cfg, uint32_t Timeout)
{
 800b06a:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 800b06e:	4604      	mov	r4, r0
 800b070:	460d      	mov	r5, r1
 800b072:	4617      	mov	r7, r2
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
 800b074:	f7fb ffce 	bl	8007014 <HAL_GetTick>
  uint32_t addr_reg = hospi->Instance->AR;
 800b078:	6823      	ldr	r3, [r4, #0]
 800b07a:	f8d3 8048 	ldr.w	r8, [r3, #72]	; 0x48
  uint32_t ir_reg = hospi->Instance->IR;
 800b07e:	f8d3 9110 	ldr.w	r9, [r3, #272]	; 0x110
  assert_param(IS_OSPI_AUTOMATIC_STOP   (cfg->AutomaticStop));
  assert_param(IS_OSPI_INTERVAL         (cfg->Interval));
  assert_param(IS_OSPI_STATUS_BYTES_SIZE(dlr_reg+1U));

  /* Check the state */
  if ((hospi->State == HAL_OSPI_STATE_CMD_CFG) && (cfg->AutomaticStop == HAL_OSPI_AUTOMATIC_STOP_ENABLE))
 800b082:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800b084:	2b04      	cmp	r3, #4
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_AutoPolling(OSPI_HandleTypeDef *hospi, OSPI_AutoPollingTypeDef *cfg, uint32_t Timeout)
{
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
 800b086:	4606      	mov	r6, r0
  assert_param(IS_OSPI_AUTOMATIC_STOP   (cfg->AutomaticStop));
  assert_param(IS_OSPI_INTERVAL         (cfg->Interval));
  assert_param(IS_OSPI_STATUS_BYTES_SIZE(dlr_reg+1U));

  /* Check the state */
  if ((hospi->State == HAL_OSPI_STATE_CMD_CFG) && (cfg->AutomaticStop == HAL_OSPI_AUTOMATIC_STOP_ENABLE))
 800b088:	d13c      	bne.n	800b104 <HAL_OSPI_AutoPolling+0x9a>
 800b08a:	68eb      	ldr	r3, [r5, #12]
 800b08c:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800b090:	d138      	bne.n	800b104 <HAL_OSPI_AutoPolling+0x9a>
  {
    /* Wait till busy flag is reset */
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, Timeout);
 800b092:	4603      	mov	r3, r0
 800b094:	9700      	str	r7, [sp, #0]
 800b096:	2200      	movs	r2, #0
 800b098:	2120      	movs	r1, #32
 800b09a:	4620      	mov	r0, r4
 800b09c:	f7ff fdd0 	bl	800ac40 <OSPI_WaitFlagStateUntilTimeout>

    if (status == HAL_OK)
 800b0a0:	2800      	cmp	r0, #0
 800b0a2:	d132      	bne.n	800b10a <HAL_OSPI_AutoPolling+0xa0>
    {
      /* Configure registers */
      WRITE_REG (hospi->Instance->PSMAR, cfg->Match);
 800b0a4:	6823      	ldr	r3, [r4, #0]
 800b0a6:	682a      	ldr	r2, [r5, #0]
 800b0a8:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
      WRITE_REG (hospi->Instance->PSMKR, cfg->Mask);
 800b0ac:	686a      	ldr	r2, [r5, #4]
 800b0ae:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
      WRITE_REG (hospi->Instance->PIR,   cfg->Interval);
 800b0b2:	692a      	ldr	r2, [r5, #16]
 800b0b4:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
      MODIFY_REG(hospi->Instance->CR,    (OCTOSPI_CR_PMM | OCTOSPI_CR_APMS | OCTOSPI_CR_FMODE),
 800b0b8:	68a8      	ldr	r0, [r5, #8]
 800b0ba:	68e9      	ldr	r1, [r5, #12]
 800b0bc:	681a      	ldr	r2, [r3, #0]
 800b0be:	4301      	orrs	r1, r0
 800b0c0:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
 800b0c4:	f022 5243 	bic.w	r2, r2, #817889280	; 0x30c00000
 800b0c8:	430a      	orrs	r2, r1
 800b0ca:	601a      	str	r2, [r3, #0]
                 (cfg->MatchMode | cfg->AutomaticStop | OSPI_FUNCTIONAL_MODE_AUTO_POLLING));

      /* Trig the transfer by re-writing address or instruction register */
      if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
 800b0cc:	68e2      	ldr	r2, [r4, #12]
 800b0ce:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
 800b0d2:	d004      	beq.n	800b0de <HAL_OSPI_AutoPolling+0x74>
      {
        WRITE_REG(hospi->Instance->AR, addr_reg);
      }
      else
      {
        if (READ_BIT(hospi->Instance->CCR, OCTOSPI_CCR_ADMODE) != HAL_OSPI_ADDRESS_NONE)
 800b0d4:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 800b0d8:	f412 6fe0 	tst.w	r2, #1792	; 0x700
 800b0dc:	d002      	beq.n	800b0e4 <HAL_OSPI_AutoPolling+0x7a>
        {
          WRITE_REG(hospi->Instance->AR, addr_reg);
 800b0de:	f8c3 8048 	str.w	r8, [r3, #72]	; 0x48
 800b0e2:	e001      	b.n	800b0e8 <HAL_OSPI_AutoPolling+0x7e>
        }
        else
        {
          WRITE_REG(hospi->Instance->IR, ir_reg);
 800b0e4:	f8c3 9110 	str.w	r9, [r3, #272]	; 0x110
        }
      }

      /* Wait till status match flag is set to go back in idle state */
      status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_SM, SET, tickstart, Timeout);
 800b0e8:	9700      	str	r7, [sp, #0]
 800b0ea:	4633      	mov	r3, r6
 800b0ec:	2201      	movs	r2, #1
 800b0ee:	2108      	movs	r1, #8
 800b0f0:	4620      	mov	r0, r4
 800b0f2:	f7ff fda5 	bl	800ac40 <OSPI_WaitFlagStateUntilTimeout>

      if (status == HAL_OK)
 800b0f6:	b940      	cbnz	r0, 800b10a <HAL_OSPI_AutoPolling+0xa0>
      {
        /* Clear status match flag */
        __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_SM);
 800b0f8:	6823      	ldr	r3, [r4, #0]
 800b0fa:	2208      	movs	r2, #8
 800b0fc:	625a      	str	r2, [r3, #36]	; 0x24

        /* Update state */
        hospi->State = HAL_OSPI_STATE_READY;
 800b0fe:	2302      	movs	r3, #2
 800b100:	6463      	str	r3, [r4, #68]	; 0x44
 800b102:	e002      	b.n	800b10a <HAL_OSPI_AutoPolling+0xa0>
    }
  }
  else
  {
    status = HAL_ERROR;
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 800b104:	2310      	movs	r3, #16
 800b106:	64a3      	str	r3, [r4, #72]	; 0x48
      }
    }
  }
  else
  {
    status = HAL_ERROR;
 800b108:	2001      	movs	r0, #1
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
  }

  /* Return function status */
  return status;
}
 800b10a:	b003      	add	sp, #12
 800b10c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800b110 <HAL_OSPI_AutoPolling_IT>:
  * @note   This function is used only in Automatic Polling Mode
  * @note   This function should not be used when the memory is in octal mode (see Errata Sheet)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_AutoPolling_IT(OSPI_HandleTypeDef *hospi, OSPI_AutoPollingTypeDef *cfg)
{
 800b110:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800b112:	4604      	mov	r4, r0
 800b114:	460f      	mov	r7, r1
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
 800b116:	f7fb ff7d 	bl	8007014 <HAL_GetTick>
  uint32_t addr_reg = hospi->Instance->AR;
 800b11a:	6822      	ldr	r2, [r4, #0]
 800b11c:	6c95      	ldr	r5, [r2, #72]	; 0x48
  uint32_t ir_reg = hospi->Instance->IR;
 800b11e:	f8d2 6110 	ldr.w	r6, [r2, #272]	; 0x110
  assert_param(IS_OSPI_AUTOMATIC_STOP   (cfg->AutomaticStop));
  assert_param(IS_OSPI_INTERVAL         (cfg->Interval));
  assert_param(IS_OSPI_STATUS_BYTES_SIZE(dlr_reg+1U));

  /* Check the state */
  if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
 800b122:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800b124:	2a04      	cmp	r2, #4
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_AutoPolling_IT(OSPI_HandleTypeDef *hospi, OSPI_AutoPollingTypeDef *cfg)
{
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
 800b126:	4603      	mov	r3, r0
  assert_param(IS_OSPI_AUTOMATIC_STOP   (cfg->AutomaticStop));
  assert_param(IS_OSPI_INTERVAL         (cfg->Interval));
  assert_param(IS_OSPI_STATUS_BYTES_SIZE(dlr_reg+1U));

  /* Check the state */
  if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
 800b128:	d133      	bne.n	800b192 <HAL_OSPI_AutoPolling_IT+0x82>
  {
    /* Wait till busy flag is reset */
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);
 800b12a:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 800b12c:	9200      	str	r2, [sp, #0]
 800b12e:	2120      	movs	r1, #32
 800b130:	2200      	movs	r2, #0
 800b132:	4620      	mov	r0, r4
 800b134:	f7ff fd84 	bl	800ac40 <OSPI_WaitFlagStateUntilTimeout>

    if (status == HAL_OK)
 800b138:	bb70      	cbnz	r0, 800b198 <HAL_OSPI_AutoPolling_IT+0x88>
    {
      /* Configure registers */
      WRITE_REG (hospi->Instance->PSMAR, cfg->Match);
 800b13a:	6823      	ldr	r3, [r4, #0]
 800b13c:	683a      	ldr	r2, [r7, #0]
 800b13e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
      WRITE_REG (hospi->Instance->PSMKR, cfg->Mask);
 800b142:	687a      	ldr	r2, [r7, #4]
 800b144:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
      WRITE_REG (hospi->Instance->PIR,   cfg->Interval);
 800b148:	693a      	ldr	r2, [r7, #16]
 800b14a:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
      MODIFY_REG(hospi->Instance->CR,    (OCTOSPI_CR_PMM | OCTOSPI_CR_APMS | OCTOSPI_CR_FMODE),
 800b14e:	f8d7 e008 	ldr.w	lr, [r7, #8]
 800b152:	68f9      	ldr	r1, [r7, #12]
 800b154:	681a      	ldr	r2, [r3, #0]
 800b156:	ea4e 0101 	orr.w	r1, lr, r1
 800b15a:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
 800b15e:	f022 5243 	bic.w	r2, r2, #817889280	; 0x30c00000
 800b162:	430a      	orrs	r2, r1
 800b164:	601a      	str	r2, [r3, #0]
                 (cfg->MatchMode | cfg->AutomaticStop | OSPI_FUNCTIONAL_MODE_AUTO_POLLING));

      /* Clear flags related to interrupt */
      __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TE | HAL_OSPI_FLAG_SM);
 800b166:	2209      	movs	r2, #9
 800b168:	625a      	str	r2, [r3, #36]	; 0x24

      /* Update state */
      hospi->State = HAL_OSPI_STATE_BUSY_AUTO_POLLING;
 800b16a:	2248      	movs	r2, #72	; 0x48
 800b16c:	6462      	str	r2, [r4, #68]	; 0x44

      /* Enable the status match and transfer error interrupts */
      __HAL_OSPI_ENABLE_IT(hospi, HAL_OSPI_IT_SM | HAL_OSPI_IT_TE);
 800b16e:	681a      	ldr	r2, [r3, #0]
 800b170:	f442 2210 	orr.w	r2, r2, #589824	; 0x90000
 800b174:	601a      	str	r2, [r3, #0]

      /* Trig the transfer by re-writing address or instruction register */
      if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
 800b176:	68e2      	ldr	r2, [r4, #12]
 800b178:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
 800b17c:	d004      	beq.n	800b188 <HAL_OSPI_AutoPolling_IT+0x78>
      {
        WRITE_REG(hospi->Instance->AR, addr_reg);
      }
      else
      {
        if (READ_BIT(hospi->Instance->CCR, OCTOSPI_CCR_ADMODE) != HAL_OSPI_ADDRESS_NONE)
 800b17e:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 800b182:	f412 6fe0 	tst.w	r2, #1792	; 0x700
 800b186:	d001      	beq.n	800b18c <HAL_OSPI_AutoPolling_IT+0x7c>
        {
          WRITE_REG(hospi->Instance->AR, addr_reg);
 800b188:	649d      	str	r5, [r3, #72]	; 0x48
 800b18a:	e005      	b.n	800b198 <HAL_OSPI_AutoPolling_IT+0x88>
        }
        else
        {
          WRITE_REG(hospi->Instance->IR, ir_reg);
 800b18c:	f8c3 6110 	str.w	r6, [r3, #272]	; 0x110
 800b190:	e002      	b.n	800b198 <HAL_OSPI_AutoPolling_IT+0x88>
    }
  }
  else
  {
    status = HAL_ERROR;
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 800b192:	2310      	movs	r3, #16
 800b194:	64a3      	str	r3, [r4, #72]	; 0x48
      }
    }
  }
  else
  {
    status = HAL_ERROR;
 800b196:	2001      	movs	r0, #1
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
  }

  /* Return function status */
  return status;
}
 800b198:	b003      	add	sp, #12
 800b19a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800b19c <HAL_OSPI_MemoryMapped>:
  * @param  cfg   : structure that contains the memory mapped configuration information.
  * @note   This function is used only in Memory mapped Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_MemoryMapped(OSPI_HandleTypeDef *hospi, OSPI_MemoryMappedTypeDef *cfg)
{
 800b19c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800b19e:	4604      	mov	r4, r0
 800b1a0:	460d      	mov	r5, r1
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
 800b1a2:	f7fb ff37 	bl	8007014 <HAL_GetTick>

  /* Check the parameters of the memory-mapped configuration structure */
  assert_param(IS_OSPI_TIMEOUT_ACTIVATION(cfg->TimeOutActivation));

  /* Check the state */
  if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
 800b1a6:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800b1a8:	2a04      	cmp	r2, #4
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_MemoryMapped(OSPI_HandleTypeDef *hospi, OSPI_MemoryMappedTypeDef *cfg)
{
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
 800b1aa:	4603      	mov	r3, r0

  /* Check the parameters of the memory-mapped configuration structure */
  assert_param(IS_OSPI_TIMEOUT_ACTIVATION(cfg->TimeOutActivation));

  /* Check the state */
  if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
 800b1ac:	d120      	bne.n	800b1f0 <HAL_OSPI_MemoryMapped+0x54>
  {
    /* Wait till busy flag is reset */
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);
 800b1ae:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 800b1b0:	9200      	str	r2, [sp, #0]
 800b1b2:	2120      	movs	r1, #32
 800b1b4:	2200      	movs	r2, #0
 800b1b6:	4620      	mov	r0, r4
 800b1b8:	f7ff fd42 	bl	800ac40 <OSPI_WaitFlagStateUntilTimeout>

    if (status == HAL_OK)
 800b1bc:	b9d8      	cbnz	r0, 800b1f6 <HAL_OSPI_MemoryMapped+0x5a>
    {
      /* Update state */
      hospi->State = HAL_OSPI_STATE_BUSY_MEM_MAPPED;

      if (cfg->TimeOutActivation == HAL_OSPI_TIMEOUT_COUNTER_ENABLE)
 800b1be:	682a      	ldr	r2, [r5, #0]
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);

    if (status == HAL_OK)
    {
      /* Update state */
      hospi->State = HAL_OSPI_STATE_BUSY_MEM_MAPPED;
 800b1c0:	2388      	movs	r3, #136	; 0x88

      if (cfg->TimeOutActivation == HAL_OSPI_TIMEOUT_COUNTER_ENABLE)
 800b1c2:	2a08      	cmp	r2, #8
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);

    if (status == HAL_OK)
    {
      /* Update state */
      hospi->State = HAL_OSPI_STATE_BUSY_MEM_MAPPED;
 800b1c4:	6463      	str	r3, [r4, #68]	; 0x44
 800b1c6:	6823      	ldr	r3, [r4, #0]

      if (cfg->TimeOutActivation == HAL_OSPI_TIMEOUT_COUNTER_ENABLE)
 800b1c8:	d108      	bne.n	800b1dc <HAL_OSPI_MemoryMapped+0x40>
      {
        assert_param(IS_OSPI_TIMEOUT_PERIOD(cfg->TimeOutPeriod));

        /* Configure register */
        WRITE_REG(hospi->Instance->LPTR, cfg->TimeOutPeriod);
 800b1ca:	6869      	ldr	r1, [r5, #4]
 800b1cc:	f8c3 1130 	str.w	r1, [r3, #304]	; 0x130

        /* Clear flags related to interrupt */
        __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TO);
 800b1d0:	2110      	movs	r1, #16
 800b1d2:	6259      	str	r1, [r3, #36]	; 0x24

        /* Enable the timeout interrupt */
        __HAL_OSPI_ENABLE_IT(hospi, HAL_OSPI_IT_TO);
 800b1d4:	6819      	ldr	r1, [r3, #0]
 800b1d6:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800b1da:	6019      	str	r1, [r3, #0]
      }

      /* Configure CR register with functional mode as memory-mapped */
      MODIFY_REG(hospi->Instance->CR, (OCTOSPI_CR_TCEN | OCTOSPI_CR_FMODE),
 800b1dc:	6819      	ldr	r1, [r3, #0]
 800b1de:	f021 5140 	bic.w	r1, r1, #805306368	; 0x30000000
 800b1e2:	f021 0108 	bic.w	r1, r1, #8
 800b1e6:	f042 5240 	orr.w	r2, r2, #805306368	; 0x30000000
 800b1ea:	430a      	orrs	r2, r1
 800b1ec:	601a      	str	r2, [r3, #0]
 800b1ee:	e002      	b.n	800b1f6 <HAL_OSPI_MemoryMapped+0x5a>
    }
  }
  else
  {
    status = HAL_ERROR;
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 800b1f0:	2310      	movs	r3, #16
 800b1f2:	64a3      	str	r3, [r4, #72]	; 0x48
                 (cfg->TimeOutActivation | OSPI_FUNCTIONAL_MODE_MEMORY_MAPPED));
    }
  }
  else
  {
    status = HAL_ERROR;
 800b1f4:	2001      	movs	r0, #1
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
  }

  /* Return function status */
  return status;
}
 800b1f6:	b003      	add	sp, #12
 800b1f8:	bd30      	pop	{r4, r5, pc}

0800b1fa <HAL_OSPI_SetFifoThreshold>:
HAL_StatusTypeDef HAL_OSPI_SetFifoThreshold(OSPI_HandleTypeDef *hospi, uint32_t Threshold)
{
  HAL_StatusTypeDef status = HAL_OK;

  /* Check the state */
  if ((hospi->State & OSPI_BUSY_STATE_MASK) == 0U)
 800b1fa:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800b1fc:	f013 0308 	ands.w	r3, r3, #8
 800b200:	d10a      	bne.n	800b218 <HAL_OSPI_SetFifoThreshold+0x1e>
  {
    /* Synchronize initialization structure with the new fifo threshold value */
    hospi->Init.FifoThreshold = Threshold;
 800b202:	6041      	str	r1, [r0, #4]

    /* Configure new fifo threshold */
    MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FTHRES, ((hospi->Init.FifoThreshold-1U) << OCTOSPI_CR_FTHRES_Pos));
 800b204:	6800      	ldr	r0, [r0, #0]
 800b206:	6802      	ldr	r2, [r0, #0]
 800b208:	3901      	subs	r1, #1
 800b20a:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
 800b20e:	ea42 2101 	orr.w	r1, r2, r1, lsl #8
 800b212:	6001      	str	r1, [r0, #0]
  * @param  Threshold : Threshold of the Fifo.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_SetFifoThreshold(OSPI_HandleTypeDef *hospi, uint32_t Threshold)
{
  HAL_StatusTypeDef status = HAL_OK;
 800b214:	4618      	mov	r0, r3
 800b216:	4770      	bx	lr

  }
  else
  {
    status = HAL_ERROR;
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 800b218:	2310      	movs	r3, #16
 800b21a:	6483      	str	r3, [r0, #72]	; 0x48
    MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FTHRES, ((hospi->Init.FifoThreshold-1U) << OCTOSPI_CR_FTHRES_Pos));

  }
  else
  {
    status = HAL_ERROR;
 800b21c:	2001      	movs	r0, #1
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
  }

  /* Return function status */
  return status;
}
 800b21e:	4770      	bx	lr

0800b220 <HAL_OSPI_GetFifoThreshold>:
  * @param  hospi : OSPI handle.
  * @retval Fifo threshold
  */
uint32_t HAL_OSPI_GetFifoThreshold(OSPI_HandleTypeDef *hospi)
{
  return ((READ_BIT(hospi->Instance->CR, OCTOSPI_CR_FTHRES) >> OCTOSPI_CR_FTHRES_Pos) + 1U);
 800b220:	6803      	ldr	r3, [r0, #0]
 800b222:	6818      	ldr	r0, [r3, #0]
 800b224:	f3c0 2004 	ubfx	r0, r0, #8, #5
}
 800b228:	3001      	adds	r0, #1
 800b22a:	4770      	bx	lr

0800b22c <HAL_OSPI_SetTimeout>:
  * @param  Timeout : Timeout for the memory access.
  * @retval None
  */
HAL_StatusTypeDef HAL_OSPI_SetTimeout(OSPI_HandleTypeDef *hospi, uint32_t Timeout)
{
  hospi->Timeout = Timeout;
 800b22c:	64c1      	str	r1, [r0, #76]	; 0x4c
  return HAL_OK;
}
 800b22e:	2000      	movs	r0, #0
 800b230:	4770      	bx	lr

0800b232 <HAL_OSPI_GetError>:
* @param  hospi : OSPI handle
* @retval OSPI Error Code
*/
uint32_t HAL_OSPI_GetError(OSPI_HandleTypeDef *hospi)
{
  return hospi->ErrorCode;
 800b232:	6c80      	ldr	r0, [r0, #72]	; 0x48
}
 800b234:	4770      	bx	lr

0800b236 <HAL_OSPI_GetState>:
  * @retval HAL state
  */
uint32_t HAL_OSPI_GetState(OSPI_HandleTypeDef *hospi)
{
  /* Return OSPI handle state */
  return hospi->State;
 800b236:	6c40      	ldr	r0, [r0, #68]	; 0x44
}
 800b238:	4770      	bx	lr
	...

0800b23c <HAL_OSPIM_Config>:
  * @param  cfg     : Configuration of the IO Manager for the instance
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPIM_Config(OSPI_HandleTypeDef *hospi, OSPIM_CfgTypeDef *cfg, uint32_t Timeout)
{
 800b23c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    other_instance = 1U;
  }
  else
  {
    instance = 1U;
    other_instance = 0U;
 800b240:	4bb7      	ldr	r3, [pc, #732]	; (800b520 <HAL_OSPIM_Config+0x2e4>)
  assert_param(IS_OSPIM_IO_PORT(cfg->IOHighPort));
#if   defined (OCTOSPIM_CR_MUXEN)
  assert_param(IS_OSPIM_REQ2ACKTIME(cfg->Req2AckTime));
#endif

  if (hospi->Instance == OCTOSPI1)
 800b242:	6802      	ldr	r2, [r0, #0]
    {
#if   defined (OCTOSPIM_CR_MUXEN)
      if ((OCTOSPIM->CR & OCTOSPIM_CR_MUXEN) == 0U)
      {
#endif
        value = (OCTOSPIM_PCR_CLKSRC | OCTOSPIM_PCR_DQSSRC | OCTOSPIM_PCR_NCSSRC | OCTOSPIM_PCR_IOLSRC_1 | OCTOSPIM_PCR_IOHSRC_1);
 800b244:	f8df 92e4 	ldr.w	r9, [pc, #740]	; 800b52c <HAL_OSPIM_Config+0x2f0>
    other_instance = 1U;
  }
  else
  {
    instance = 1U;
    other_instance = 0U;
 800b248:	429a      	cmp	r2, r3
  }

  /**************** Get current configuration of the instances ****************/
  for (index = 0U; index < OSPI_NB_INSTANCE; index++)
 800b24a:	f04f 0400 	mov.w	r4, #0
  * @param  cfg     : Configuration of the IO Manager for the instance
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPIM_Config(OSPI_HandleTypeDef *hospi, OSPIM_CfgTypeDef *cfg, uint32_t Timeout)
{
 800b24e:	b08a      	sub	sp, #40	; 0x28
    other_instance = 1U;
  }
  else
  {
    instance = 1U;
    other_instance = 0U;
 800b250:	bf0b      	itete	eq
 800b252:	2701      	moveq	r7, #1
 800b254:	2700      	movne	r7, #0
 800b256:	2500      	moveq	r5, #0
 800b258:	2501      	movne	r5, #1
 800b25a:	ab01      	add	r3, sp, #4
    status = HAL_ERROR;
  }
  else
  {
    /* Initialize the structure */
    cfg->ClkPort    = 0U;
 800b25c:	46a6      	mov	lr, r4
 800b25e:	46a0      	mov	r8, r4
  }

  /**************** Get current configuration of the instances ****************/
  for (index = 0U; index < OSPI_NB_INSTANCE; index++)
  {
    if (OSPIM_GetConfig(index+1U, &(IOM_cfg[index])) != HAL_OK)
 800b260:	3401      	adds	r4, #1
 800b262:	b2e4      	uxtb	r4, r4
    {
#if   defined (OCTOSPIM_CR_MUXEN)
      if ((OCTOSPIM->CR & OCTOSPIM_CR_MUXEN) == 0U)
      {
#endif
        value = (OCTOSPIM_PCR_CLKSRC | OCTOSPIM_PCR_DQSSRC | OCTOSPIM_PCR_NCSSRC | OCTOSPIM_PCR_IOLSRC_1 | OCTOSPIM_PCR_IOHSRC_1);
 800b264:	2c02      	cmp	r4, #2
    status = HAL_ERROR;
  }
  else
  {
    /* Initialize the structure */
    cfg->ClkPort    = 0U;
 800b266:	f843 ec04 	str.w	lr, [r3, #-4]
    cfg->DQSPort    = 0U;
 800b26a:	f8c3 e000 	str.w	lr, [r3]
    cfg->NCSPort    = 0U;
 800b26e:	f8c3 e004 	str.w	lr, [r3, #4]
    cfg->IOLowPort  = 0U;
 800b272:	f8c3 e008 	str.w	lr, [r3, #8]
    {
#if   defined (OCTOSPIM_CR_MUXEN)
      if ((OCTOSPIM->CR & OCTOSPIM_CR_MUXEN) == 0U)
      {
#endif
        value = (OCTOSPIM_PCR_CLKSRC | OCTOSPIM_PCR_DQSSRC | OCTOSPIM_PCR_NCSSRC | OCTOSPIM_PCR_IOLSRC_1 | OCTOSPIM_PCR_IOHSRC_1);
 800b276:	bf14      	ite	ne
 800b278:	2600      	movne	r6, #0
 800b27a:	464e      	moveq	r6, r9
    /* Initialize the structure */
    cfg->ClkPort    = 0U;
    cfg->DQSPort    = 0U;
    cfg->NCSPort    = 0U;
    cfg->IOLowPort  = 0U;
    cfg->IOHighPort = 0U;
 800b27c:	f8c3 800c 	str.w	r8, [r3, #12]
 800b280:	2001      	movs	r0, #1
    }

    /* Get the information about the instance */
    for (index = 0U; index < OSPI_IOM_NB_PORTS; index ++)
    {
      reg = OCTOSPIM->PCR[index];
 800b282:	ea4f 0c80 	mov.w	ip, r0, lsl #2
 800b286:	4aa7      	ldr	r2, [pc, #668]	; (800b524 <HAL_OSPIM_Config+0x2e8>)
 800b288:	f852 200c 	ldr.w	r2, [r2, ip]

      if ((reg & OCTOSPIM_PCR_CLKEN) != 0U)
 800b28c:	f012 0f01 	tst.w	r2, #1
 800b290:	d006      	beq.n	800b2a0 <HAL_OSPIM_Config+0x64>
      {
        /* The clock is enabled on this port */
        if ((reg & OCTOSPIM_PCR_CLKSRC) == (value & OCTOSPIM_PCR_CLKSRC))
 800b292:	ea82 0c06 	eor.w	ip, r2, r6
 800b296:	f01c 0f02 	tst.w	ip, #2
        {
          /* The clock correspond to the instance passed as parameter */
          cfg->ClkPort = index+1U;
 800b29a:	bf08      	it	eq
 800b29c:	f843 0c04 	streq.w	r0, [r3, #-4]
        }
      }

      if ((reg & OCTOSPIM_PCR_DQSEN) != 0U)
 800b2a0:	f012 0f10 	tst.w	r2, #16
 800b2a4:	d005      	beq.n	800b2b2 <HAL_OSPIM_Config+0x76>
      {
        /* The DQS is enabled on this port */
        if ((reg & OCTOSPIM_PCR_DQSSRC) == (value & OCTOSPIM_PCR_DQSSRC))
 800b2a6:	ea82 0c06 	eor.w	ip, r2, r6
 800b2aa:	f01c 0f20 	tst.w	ip, #32
        {
          /* The DQS correspond to the instance passed as parameter */
          cfg->DQSPort = index+1U;
 800b2ae:	bf08      	it	eq
 800b2b0:	6018      	streq	r0, [r3, #0]
        }
      }

      if ((reg & OCTOSPIM_PCR_NCSEN) != 0U)
 800b2b2:	f412 7f80 	tst.w	r2, #256	; 0x100
 800b2b6:	d005      	beq.n	800b2c4 <HAL_OSPIM_Config+0x88>
      {
        /* The nCS is enabled on this port */
        if ((reg & OCTOSPIM_PCR_NCSSRC) == (value & OCTOSPIM_PCR_NCSSRC))
 800b2b8:	ea82 0c06 	eor.w	ip, r2, r6
 800b2bc:	f41c 7f00 	tst.w	ip, #512	; 0x200
        {
          /* The nCS correspond to the instance passed as parameter */
          cfg->NCSPort = index+1U;
 800b2c0:	bf08      	it	eq
 800b2c2:	6058      	streq	r0, [r3, #4]
        }
      }

      if ((reg & OCTOSPIM_PCR_IOLEN) != 0U)
 800b2c4:	f412 3f80 	tst.w	r2, #65536	; 0x10000
 800b2c8:	d00d      	beq.n	800b2e6 <HAL_OSPIM_Config+0xaa>
      {
        /* The IO Low is enabled on this port */
        if ((reg & OCTOSPIM_PCR_IOLSRC_1) == (value & OCTOSPIM_PCR_IOLSRC_1))
 800b2ca:	ea82 0c06 	eor.w	ip, r2, r6
 800b2ce:	f41c 2f80 	tst.w	ip, #262144	; 0x40000
 800b2d2:	d108      	bne.n	800b2e6 <HAL_OSPIM_Config+0xaa>
        {
          /* The IO Low correspond to the instance passed as parameter */
          if ((reg & OCTOSPIM_PCR_IOLSRC_0) == 0U)
 800b2d4:	f412 3f00 	tst.w	r2, #131072	; 0x20000
          {
            cfg->IOLowPort = (OCTOSPIM_PCR_IOLEN | (index+1U));
 800b2d8:	bf0c      	ite	eq
 800b2da:	f440 3c80 	orreq.w	ip, r0, #65536	; 0x10000
          }
          else
          {
            cfg->IOLowPort = (OCTOSPIM_PCR_IOHEN | (index+1U));
 800b2de:	f040 7c80 	orrne.w	ip, r0, #16777216	; 0x1000000
 800b2e2:	f8c3 c008 	str.w	ip, [r3, #8]
          }
        }
      }

      if ((reg & OCTOSPIM_PCR_IOHEN) != 0U)
 800b2e6:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
 800b2ea:	d00b      	beq.n	800b304 <HAL_OSPIM_Config+0xc8>
      {
        /* The IO High is enabled on this port */
        if ((reg & OCTOSPIM_PCR_IOHSRC_1) == (value & OCTOSPIM_PCR_IOHSRC_1))
 800b2ec:	ea82 0c06 	eor.w	ip, r2, r6
 800b2f0:	f01c 6f80 	tst.w	ip, #67108864	; 0x4000000
 800b2f4:	d106      	bne.n	800b304 <HAL_OSPIM_Config+0xc8>
        {
          /* The IO High correspond to the instance passed as parameter */
          if ((reg & OCTOSPIM_PCR_IOHSRC_0) == 0U)
 800b2f6:	0192      	lsls	r2, r2, #6
          {
            cfg->IOHighPort = (OCTOSPIM_PCR_IOLEN | (index+1U));
 800b2f8:	bf54      	ite	pl
 800b2fa:	f440 3280 	orrpl.w	r2, r0, #65536	; 0x10000
          }
          else
          {
            cfg->IOHighPort = (OCTOSPIM_PCR_IOHEN | (index+1U));
 800b2fe:	f040 7280 	orrmi.w	r2, r0, #16777216	; 0x1000000
 800b302:	60da      	str	r2, [r3, #12]
 800b304:	3001      	adds	r0, #1
      }
#endif
    }

    /* Get the information about the instance */
    for (index = 0U; index < OSPI_IOM_NB_PORTS; index ++)
 800b306:	2803      	cmp	r0, #3
 800b308:	d1bb      	bne.n	800b282 <HAL_OSPIM_Config+0x46>
    instance = 1U;
    other_instance = 0U;
  }

  /**************** Get current configuration of the instances ****************/
  for (index = 0U; index < OSPI_NB_INSTANCE; index++)
 800b30a:	2c02      	cmp	r4, #2
 800b30c:	f103 0314 	add.w	r3, r3, #20
 800b310:	d1a6      	bne.n	800b260 <HAL_OSPIM_Config+0x24>
  }

  if (status == HAL_OK)
  {
    /********** Disable both OctoSPI to configure OctoSPI IO Manager **********/
    if ((OCTOSPI1->CR & OCTOSPI_CR_EN) != 0U)
 800b312:	4b83      	ldr	r3, [pc, #524]	; (800b520 <HAL_OSPIM_Config+0x2e4>)
 800b314:	4883      	ldr	r0, [pc, #524]	; (800b524 <HAL_OSPIM_Config+0x2e8>)
 800b316:	681c      	ldr	r4, [r3, #0]
 800b318:	f014 0401 	ands.w	r4, r4, #1
    {
      CLEAR_BIT(OCTOSPI1->CR, OCTOSPI_CR_EN);
 800b31c:	bf1e      	ittt	ne
 800b31e:	681a      	ldrne	r2, [r3, #0]
 800b320:	f022 0201 	bicne.w	r2, r2, #1
 800b324:	601a      	strne	r2, [r3, #0]
      ospi_enabled |= 0x1U;
    }
    if ((OCTOSPI2->CR & OCTOSPI_CR_EN) != 0U)
 800b326:	4b80      	ldr	r3, [pc, #512]	; (800b528 <HAL_OSPIM_Config+0x2ec>)
 800b328:	681a      	ldr	r2, [r3, #0]
  {
    /********** Disable both OctoSPI to configure OctoSPI IO Manager **********/
    if ((OCTOSPI1->CR & OCTOSPI_CR_EN) != 0U)
    {
      CLEAR_BIT(OCTOSPI1->CR, OCTOSPI_CR_EN);
      ospi_enabled |= 0x1U;
 800b32a:	bf18      	it	ne
 800b32c:	2401      	movne	r4, #1
    }
    if ((OCTOSPI2->CR & OCTOSPI_CR_EN) != 0U)
 800b32e:	07d6      	lsls	r6, r2, #31
    {
      CLEAR_BIT(OCTOSPI2->CR, OCTOSPI_CR_EN);
 800b330:	bf42      	ittt	mi
 800b332:	681a      	ldrmi	r2, [r3, #0]
 800b334:	f022 0201 	bicmi.w	r2, r2, #1
 800b338:	601a      	strmi	r2, [r3, #0]
      ospi_enabled |= 0x2U;
    }

    /***************** Deactivation of previous configuration *****************/
    CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[instance].NCSPort-1U)], OCTOSPIM_PCR_NCSEN);
 800b33a:	aa0a      	add	r2, sp, #40	; 0x28
 800b33c:	f04f 0314 	mov.w	r3, #20
 800b340:	fb03 2305 	mla	r3, r3, r5, r2
      ospi_enabled |= 0x1U;
    }
    if ((OCTOSPI2->CR & OCTOSPI_CR_EN) != 0U)
    {
      CLEAR_BIT(OCTOSPI2->CR, OCTOSPI_CR_EN);
      ospi_enabled |= 0x2U;
 800b344:	bf48      	it	mi
 800b346:	f044 0402 	orrmi.w	r4, r4, #2
 800b34a:	f853 6c20 	ldr.w	r6, [r3, #-32]
    }

    /***************** Deactivation of previous configuration *****************/
    CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[instance].NCSPort-1U)], OCTOSPIM_PCR_NCSEN);
 800b34e:	f850 2026 	ldr.w	r2, [r0, r6, lsl #2]
 800b352:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800b356:	f840 2026 	str.w	r2, [r0, r6, lsl #2]
      }
    }
    else
    {
#endif
      if (IOM_cfg[instance].ClkPort != 0U)
 800b35a:	f853 2c28 	ldr.w	r2, [r3, #-40]
 800b35e:	b382      	cbz	r2, 800b3c2 <HAL_OSPIM_Config+0x186>
      {
        CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[instance].ClkPort-1U)], OCTOSPIM_PCR_CLKEN);
 800b360:	f850 6022 	ldr.w	r6, [r0, r2, lsl #2]
        if (IOM_cfg[instance].DQSPort != 0U)
 800b364:	f853 3c24 	ldr.w	r3, [r3, #-36]
    else
    {
#endif
      if (IOM_cfg[instance].ClkPort != 0U)
      {
        CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[instance].ClkPort-1U)], OCTOSPIM_PCR_CLKEN);
 800b368:	f026 0601 	bic.w	r6, r6, #1
 800b36c:	f840 6022 	str.w	r6, [r0, r2, lsl #2]
        if (IOM_cfg[instance].DQSPort != 0U)
 800b370:	b12b      	cbz	r3, 800b37e <HAL_OSPIM_Config+0x142>
        {
          CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[instance].DQSPort-1U)], OCTOSPIM_PCR_DQSEN);
 800b372:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
 800b376:	f022 0210 	bic.w	r2, r2, #16
 800b37a:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
        }
        if (IOM_cfg[instance].IOLowPort != HAL_OSPIM_IOPORT_NONE)
 800b37e:	2314      	movs	r3, #20
 800b380:	aa0a      	add	r2, sp, #40	; 0x28
 800b382:	fb03 2305 	mla	r3, r3, r5, r2
 800b386:	f853 3c1c 	ldr.w	r3, [r3, #-28]
 800b38a:	b14b      	cbz	r3, 800b3a0 <HAL_OSPIM_Config+0x164>
 800b38c:	3b01      	subs	r3, #1
 800b38e:	f003 0301 	and.w	r3, r3, #1
 800b392:	4a64      	ldr	r2, [pc, #400]	; (800b524 <HAL_OSPIM_Config+0x2e8>)
 800b394:	009b      	lsls	r3, r3, #2
 800b396:	441a      	add	r2, r3
        {
          CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[instance].IOLowPort-1U)& OSPI_IOM_PORT_MASK)], OCTOSPIM_PCR_IOLEN);
 800b398:	6853      	ldr	r3, [r2, #4]
 800b39a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800b39e:	6053      	str	r3, [r2, #4]
        }
        if (IOM_cfg[instance].IOHighPort != HAL_OSPIM_IOPORT_NONE)
 800b3a0:	2314      	movs	r3, #20
 800b3a2:	aa0a      	add	r2, sp, #40	; 0x28
 800b3a4:	fb03 2305 	mla	r3, r3, r5, r2
 800b3a8:	f853 3c18 	ldr.w	r3, [r3, #-24]
 800b3ac:	b14b      	cbz	r3, 800b3c2 <HAL_OSPIM_Config+0x186>
 800b3ae:	3b01      	subs	r3, #1
 800b3b0:	f003 0301 	and.w	r3, r3, #1
 800b3b4:	4a5b      	ldr	r2, [pc, #364]	; (800b524 <HAL_OSPIM_Config+0x2e8>)
 800b3b6:	009b      	lsls	r3, r3, #2
 800b3b8:	441a      	add	r2, r3
        {
          CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[instance].IOHighPort-1U)& OSPI_IOM_PORT_MASK)], OCTOSPIM_PCR_IOHEN);
 800b3ba:	6853      	ldr	r3, [r2, #4]
 800b3bc:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800b3c0:	6053      	str	r3, [r2, #4]
#if   defined (OCTOSPIM_CR_MUXEN)
    }
#endif

    /********************* Deactivation of other instance *********************/
    if ((cfg->ClkPort == IOM_cfg[other_instance].ClkPort) || (cfg->DQSPort == IOM_cfg[other_instance].DQSPort)     ||
 800b3c2:	ab0a      	add	r3, sp, #40	; 0x28
 800b3c4:	2614      	movs	r6, #20
 800b3c6:	fb06 3607 	mla	r6, r6, r7, r3
 800b3ca:	f8d1 c000 	ldr.w	ip, [r1]
 800b3ce:	f856 9c28 	ldr.w	r9, [r6, #-40]
 800b3d2:	f8d1 e004 	ldr.w	lr, [r1, #4]
 800b3d6:	f8d1 8008 	ldr.w	r8, [r1, #8]
 800b3da:	68ca      	ldr	r2, [r1, #12]
 800b3dc:	690b      	ldr	r3, [r1, #16]
 800b3de:	45cc      	cmp	ip, r9
 800b3e0:	d00f      	beq.n	800b402 <HAL_OSPIM_Config+0x1c6>
 800b3e2:	f856 1c24 	ldr.w	r1, [r6, #-36]
 800b3e6:	458e      	cmp	lr, r1
 800b3e8:	d00b      	beq.n	800b402 <HAL_OSPIM_Config+0x1c6>
 800b3ea:	f856 1c20 	ldr.w	r1, [r6, #-32]
 800b3ee:	4588      	cmp	r8, r1
 800b3f0:	d007      	beq.n	800b402 <HAL_OSPIM_Config+0x1c6>
        (cfg->NCSPort == IOM_cfg[other_instance].NCSPort) || (cfg->IOLowPort == IOM_cfg[other_instance].IOLowPort) ||
 800b3f2:	f856 1c1c 	ldr.w	r1, [r6, #-28]
 800b3f6:	428a      	cmp	r2, r1
 800b3f8:	d003      	beq.n	800b402 <HAL_OSPIM_Config+0x1c6>
 800b3fa:	f856 1c18 	ldr.w	r1, [r6, #-24]
 800b3fe:	428b      	cmp	r3, r1
 800b400:	d13d      	bne.n	800b47e <HAL_OSPIM_Config+0x242>
        SET_BIT(OCTOSPIM->CR, OCTOSPIM_CR_MUXEN);
      }
      else
      {
#endif
        CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].ClkPort-1U)], OCTOSPIM_PCR_CLKEN);
 800b402:	f850 1029 	ldr.w	r1, [r0, r9, lsl #2]
 800b406:	f8df a11c 	ldr.w	sl, [pc, #284]	; 800b524 <HAL_OSPIM_Config+0x2e8>
 800b40a:	f021 0101 	bic.w	r1, r1, #1
 800b40e:	f840 1029 	str.w	r1, [r0, r9, lsl #2]
        if (IOM_cfg[other_instance].DQSPort != 0U)
 800b412:	ae0a      	add	r6, sp, #40	; 0x28
 800b414:	2114      	movs	r1, #20
 800b416:	fb01 6607 	mla	r6, r1, r7, r6
 800b41a:	f856 6c24 	ldr.w	r6, [r6, #-36]
 800b41e:	b12e      	cbz	r6, 800b42c <HAL_OSPIM_Config+0x1f0>
        {
          CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].DQSPort-1U)], OCTOSPIM_PCR_DQSEN);
 800b420:	f85a 9026 	ldr.w	r9, [sl, r6, lsl #2]
 800b424:	f029 0910 	bic.w	r9, r9, #16
 800b428:	f84a 9026 	str.w	r9, [sl, r6, lsl #2]
        }
        CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].NCSPort-1U)], OCTOSPIM_PCR_NCSEN);
 800b42c:	ae0a      	add	r6, sp, #40	; 0x28
 800b42e:	fb01 6107 	mla	r1, r1, r7, r6
 800b432:	f851 9c20 	ldr.w	r9, [r1, #-32]
        if (IOM_cfg[other_instance].IOLowPort != HAL_OSPIM_IOPORT_NONE)
 800b436:	f851 1c1c 	ldr.w	r1, [r1, #-28]
        CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].ClkPort-1U)], OCTOSPIM_PCR_CLKEN);
        if (IOM_cfg[other_instance].DQSPort != 0U)
        {
          CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].DQSPort-1U)], OCTOSPIM_PCR_DQSEN);
        }
        CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].NCSPort-1U)], OCTOSPIM_PCR_NCSEN);
 800b43a:	f850 6029 	ldr.w	r6, [r0, r9, lsl #2]
 800b43e:	f426 7680 	bic.w	r6, r6, #256	; 0x100
 800b442:	f840 6029 	str.w	r6, [r0, r9, lsl #2]
        if (IOM_cfg[other_instance].IOLowPort != HAL_OSPIM_IOPORT_NONE)
 800b446:	b149      	cbz	r1, 800b45c <HAL_OSPIM_Config+0x220>
 800b448:	3901      	subs	r1, #1
 800b44a:	f001 0101 	and.w	r1, r1, #1
 800b44e:	4e35      	ldr	r6, [pc, #212]	; (800b524 <HAL_OSPIM_Config+0x2e8>)
 800b450:	0089      	lsls	r1, r1, #2
 800b452:	440e      	add	r6, r1
        {
          CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[other_instance].IOLowPort-1U)& OSPI_IOM_PORT_MASK)], OCTOSPIM_PCR_IOLEN);
 800b454:	6871      	ldr	r1, [r6, #4]
 800b456:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 800b45a:	6071      	str	r1, [r6, #4]
        }
        if (IOM_cfg[other_instance].IOHighPort != HAL_OSPIM_IOPORT_NONE)
 800b45c:	2114      	movs	r1, #20
 800b45e:	ae0a      	add	r6, sp, #40	; 0x28
 800b460:	fb01 6707 	mla	r7, r1, r7, r6
 800b464:	f857 1c18 	ldr.w	r1, [r7, #-24]
 800b468:	b149      	cbz	r1, 800b47e <HAL_OSPIM_Config+0x242>
 800b46a:	3901      	subs	r1, #1
 800b46c:	f001 0101 	and.w	r1, r1, #1
 800b470:	4e2c      	ldr	r6, [pc, #176]	; (800b524 <HAL_OSPIM_Config+0x2e8>)
 800b472:	0089      	lsls	r1, r1, #2
 800b474:	440e      	add	r6, r1
        {
          CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[other_instance].IOHighPort-1U)& OSPI_IOM_PORT_MASK)], OCTOSPIM_PCR_IOHEN);
 800b476:	6871      	ldr	r1, [r6, #4]
 800b478:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
 800b47c:	6071      	str	r1, [r6, #4]
      }
#endif
    }

    /******************** Activation of new configuration *********************/
    MODIFY_REG(OCTOSPIM->PCR[(cfg->NCSPort-1U)], (OCTOSPIM_PCR_NCSEN | OCTOSPIM_PCR_NCSSRC), (OCTOSPIM_PCR_NCSEN | (instance << OCTOSPIM_PCR_NCSSRC_Pos)));
 800b47e:	f850 1028 	ldr.w	r1, [r0, r8, lsl #2]
 800b482:	4e28      	ldr	r6, [pc, #160]	; (800b524 <HAL_OSPIM_Config+0x2e8>)
 800b484:	f421 7140 	bic.w	r1, r1, #768	; 0x300
 800b488:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 800b48c:	ea41 2145 	orr.w	r1, r1, r5, lsl #9
 800b490:	f840 1028 	str.w	r1, [r0, r8, lsl #2]
      }
    }
    else
    {
#endif
      MODIFY_REG(OCTOSPIM->PCR[(cfg->ClkPort-1U)], (OCTOSPIM_PCR_CLKEN | OCTOSPIM_PCR_CLKSRC), (OCTOSPIM_PCR_CLKEN | (instance << OCTOSPIM_PCR_CLKSRC_Pos)));
 800b494:	f850 102c 	ldr.w	r1, [r0, ip, lsl #2]
 800b498:	f021 0103 	bic.w	r1, r1, #3
 800b49c:	f041 0101 	orr.w	r1, r1, #1
 800b4a0:	ea41 0145 	orr.w	r1, r1, r5, lsl #1
 800b4a4:	f840 102c 	str.w	r1, [r0, ip, lsl #2]
      if (cfg->DQSPort != 0U)
 800b4a8:	f1be 0f00 	cmp.w	lr, #0
 800b4ac:	d009      	beq.n	800b4c2 <HAL_OSPIM_Config+0x286>
      {
        MODIFY_REG(OCTOSPIM->PCR[(cfg->DQSPort-1U)], (OCTOSPIM_PCR_DQSEN | OCTOSPIM_PCR_DQSSRC), (OCTOSPIM_PCR_DQSEN | (instance << OCTOSPIM_PCR_DQSSRC_Pos)));
 800b4ae:	f856 102e 	ldr.w	r1, [r6, lr, lsl #2]
 800b4b2:	f021 0130 	bic.w	r1, r1, #48	; 0x30
 800b4b6:	f041 0110 	orr.w	r1, r1, #16
 800b4ba:	ea41 1145 	orr.w	r1, r1, r5, lsl #5
 800b4be:	f846 102e 	str.w	r1, [r6, lr, lsl #2]
      }

      if ((cfg->IOLowPort & OCTOSPIM_PCR_IOLEN) != 0U)
 800b4c2:	03d0      	lsls	r0, r2, #15
 800b4c4:	d50d      	bpl.n	800b4e2 <HAL_OSPIM_Config+0x2a6>
 800b4c6:	3a01      	subs	r2, #1
 800b4c8:	f002 0201 	and.w	r2, r2, #1
 800b4cc:	4915      	ldr	r1, [pc, #84]	; (800b524 <HAL_OSPIM_Config+0x2e8>)
 800b4ce:	0092      	lsls	r2, r2, #2
 800b4d0:	4411      	add	r1, r2
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOLowPort-1U)& OSPI_IOM_PORT_MASK)], (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC),
 800b4d2:	684a      	ldr	r2, [r1, #4]
 800b4d4:	f422 22e0 	bic.w	r2, r2, #458752	; 0x70000
 800b4d8:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800b4dc:	ea42 4285 	orr.w	r2, r2, r5, lsl #18
 800b4e0:	e00d      	b.n	800b4fe <HAL_OSPIM_Config+0x2c2>
                   (OCTOSPIM_PCR_IOLEN | (instance << (OCTOSPIM_PCR_IOLSRC_Pos+1U))));
      }
      else if (cfg->IOLowPort != HAL_OSPIM_IOPORT_NONE)
 800b4e2:	b16a      	cbz	r2, 800b500 <HAL_OSPIM_Config+0x2c4>
 800b4e4:	3a01      	subs	r2, #1
 800b4e6:	f002 0201 	and.w	r2, r2, #1
 800b4ea:	490e      	ldr	r1, [pc, #56]	; (800b524 <HAL_OSPIM_Config+0x2e8>)
 800b4ec:	0092      	lsls	r2, r2, #2
 800b4ee:	4411      	add	r1, r2
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOLowPort-1U)& OSPI_IOM_PORT_MASK)], (OCTOSPIM_PCR_IOHEN | OCTOSPIM_PCR_IOHSRC),
 800b4f0:	684a      	ldr	r2, [r1, #4]
 800b4f2:	f022 62e0 	bic.w	r2, r2, #117440512	; 0x7000000
 800b4f6:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800b4fa:	ea42 6285 	orr.w	r2, r2, r5, lsl #26
 800b4fe:	604a      	str	r2, [r1, #4]
      else
      {
         /* Nothing to do */
      }

      if ((cfg->IOHighPort & OCTOSPIM_PCR_IOLEN) != 0U)
 800b500:	03d9      	lsls	r1, r3, #15
 800b502:	d515      	bpl.n	800b530 <HAL_OSPIM_Config+0x2f4>
 800b504:	3b01      	subs	r3, #1
 800b506:	f003 0301 	and.w	r3, r3, #1
 800b50a:	4a06      	ldr	r2, [pc, #24]	; (800b524 <HAL_OSPIM_Config+0x2e8>)
 800b50c:	009b      	lsls	r3, r3, #2
 800b50e:	441a      	add	r2, r3
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOHighPort-1U)& OSPI_IOM_PORT_MASK)], (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC),
 800b510:	6853      	ldr	r3, [r2, #4]
 800b512:	f423 23e0 	bic.w	r3, r3, #458752	; 0x70000
 800b516:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
 800b51a:	ea43 4585 	orr.w	r5, r3, r5, lsl #18
 800b51e:	e015      	b.n	800b54c <HAL_OSPIM_Config+0x310>
 800b520:	a0001000 	.word	0xa0001000
 800b524:	50061c00 	.word	0x50061c00
 800b528:	a0001400 	.word	0xa0001400
 800b52c:	04040222 	.word	0x04040222
                   (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC_0 | (instance << (OCTOSPIM_PCR_IOLSRC_Pos+1U))));
      }
      else if (cfg->IOHighPort != HAL_OSPIM_IOPORT_NONE)
 800b530:	b16b      	cbz	r3, 800b54e <HAL_OSPIM_Config+0x312>
 800b532:	3b01      	subs	r3, #1
 800b534:	f003 0301 	and.w	r3, r3, #1
 800b538:	4a0f      	ldr	r2, [pc, #60]	; (800b578 <HAL_OSPIM_Config+0x33c>)
 800b53a:	009b      	lsls	r3, r3, #2
 800b53c:	441a      	add	r2, r3
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOHighPort-1U)& OSPI_IOM_PORT_MASK)], (OCTOSPIM_PCR_IOHEN | OCTOSPIM_PCR_IOHSRC),
 800b53e:	6853      	ldr	r3, [r2, #4]
 800b540:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 800b544:	f043 7340 	orr.w	r3, r3, #50331648	; 0x3000000
 800b548:	ea43 6585 	orr.w	r5, r3, r5, lsl #26
 800b54c:	6055      	str	r5, [r2, #4]
#if   defined (OCTOSPIM_CR_MUXEN)
    }
#endif

    /******* Re-enable both OctoSPI after configure OctoSPI IO Manager ********/
    if ((ospi_enabled & 0x1U) != 0U)
 800b54e:	07e2      	lsls	r2, r4, #31
    {
      SET_BIT(OCTOSPI1->CR, OCTOSPI_CR_EN);
 800b550:	bf41      	itttt	mi
 800b552:	4a0a      	ldrmi	r2, [pc, #40]	; (800b57c <HAL_OSPIM_Config+0x340>)
 800b554:	6813      	ldrmi	r3, [r2, #0]
 800b556:	f043 0301 	orrmi.w	r3, r3, #1
 800b55a:	6013      	strmi	r3, [r2, #0]
    }
    if ((ospi_enabled & 0x2U) != 0U)
 800b55c:	07a3      	lsls	r3, r4, #30
    {
      SET_BIT(OCTOSPI2->CR, OCTOSPI_CR_EN);
 800b55e:	bf44      	itt	mi
 800b560:	4a07      	ldrmi	r2, [pc, #28]	; (800b580 <HAL_OSPIM_Config+0x344>)
 800b562:	6813      	ldrmi	r3, [r2, #0]
    }
  }

  /* Return function status */
  return status;
}
 800b564:	f04f 0000 	mov.w	r0, #0
    {
      SET_BIT(OCTOSPI1->CR, OCTOSPI_CR_EN);
    }
    if ((ospi_enabled & 0x2U) != 0U)
    {
      SET_BIT(OCTOSPI2->CR, OCTOSPI_CR_EN);
 800b568:	bf44      	itt	mi
 800b56a:	f043 0301 	orrmi.w	r3, r3, #1
 800b56e:	6013      	strmi	r3, [r2, #0]
    }
  }

  /* Return function status */
  return status;
}
 800b570:	b00a      	add	sp, #40	; 0x28
 800b572:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800b576:	bf00      	nop
 800b578:	50061c00 	.word	0x50061c00
 800b57c:	a0001000 	.word	0xa0001000
 800b580:	a0001400 	.word	0xa0001400

0800b584 <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
 800b584:	b530      	push	{r4, r5, lr}
 800b586:	9c03      	ldr	r4, [sp, #12]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2,
 800b588:	6805      	ldr	r5, [r0, #0]
 800b58a:	4323      	orrs	r3, r4
 800b58c:	0d64      	lsrs	r4, r4, #21
 800b58e:	f404 6480 	and.w	r4, r4, #1024	; 0x400
 800b592:	f044 747f 	orr.w	r4, r4, #66846720	; 0x3fc0000
 800b596:	f444 3458 	orr.w	r4, r4, #221184	; 0x36000
 800b59a:	6868      	ldr	r0, [r5, #4]
 800b59c:	f3c1 0109 	ubfx	r1, r1, #0, #10
 800b5a0:	f444 747f 	orr.w	r4, r4, #1020	; 0x3fc
 800b5a4:	430b      	orrs	r3, r1
 800b5a6:	f044 0403 	orr.w	r4, r4, #3
 800b5aa:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 800b5ae:	ea20 0404 	bic.w	r4, r0, r4
 800b5b2:	4314      	orrs	r4, r2
 800b5b4:	606c      	str	r4, [r5, #4]
 800b5b6:	bd30      	pop	{r4, r5, pc}

0800b5b8 <I2C_IsAcknowledgeFailed>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 800b5b8:	6803      	ldr	r3, [r0, #0]
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 800b5ba:	b570      	push	{r4, r5, r6, lr}
 800b5bc:	4604      	mov	r4, r0
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 800b5be:	6998      	ldr	r0, [r3, #24]
 800b5c0:	f010 0010 	ands.w	r0, r0, #16
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 800b5c4:	460d      	mov	r5, r1
 800b5c6:	4616      	mov	r6, r2
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 800b5c8:	d10b      	bne.n	800b5e2 <I2C_IsAcknowledgeFailed+0x2a>
 800b5ca:	bd70      	pop	{r4, r5, r6, pc}
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 800b5cc:	6999      	ldr	r1, [r3, #24]
 800b5ce:	0688      	lsls	r0, r1, #26
 800b5d0:	d40d      	bmi.n	800b5ee <I2C_IsAcknowledgeFailed+0x36>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
 800b5d2:	1c6a      	adds	r2, r5, #1
 800b5d4:	d0fa      	beq.n	800b5cc <I2C_IsAcknowledgeFailed+0x14>
      {
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800b5d6:	f7fb fd1d 	bl	8007014 <HAL_GetTick>
 800b5da:	1b80      	subs	r0, r0, r6
 800b5dc:	4285      	cmp	r5, r0
 800b5de:	d302      	bcc.n	800b5e6 <I2C_IsAcknowledgeFailed+0x2e>
 800b5e0:	b10d      	cbz	r5, 800b5e6 <I2C_IsAcknowledgeFailed+0x2e>
{
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 800b5e2:	6823      	ldr	r3, [r4, #0]
 800b5e4:	e7f2      	b.n	800b5cc <I2C_IsAcknowledgeFailed+0x14>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800b5e6:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800b5e8:	f043 0320 	orr.w	r3, r3, #32
 800b5ec:	e016      	b.n	800b61c <I2C_IsAcknowledgeFailed+0x64>
        }
      }
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800b5ee:	2210      	movs	r2, #16
 800b5f0:	61da      	str	r2, [r3, #28]

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800b5f2:	2220      	movs	r2, #32
 800b5f4:	61da      	str	r2, [r3, #28]
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 800b5f6:	699a      	ldr	r2, [r3, #24]
 800b5f8:	0791      	lsls	r1, r2, #30
  {
    hi2c->Instance->TXDR = 0x00U;
 800b5fa:	bf44      	itt	mi
 800b5fc:	2200      	movmi	r2, #0
 800b5fe:	629a      	strmi	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 800b600:	699a      	ldr	r2, [r3, #24]
 800b602:	07d2      	lsls	r2, r2, #31
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 800b604:	bf5e      	ittt	pl
 800b606:	699a      	ldrpl	r2, [r3, #24]
 800b608:	f042 0201 	orrpl.w	r2, r2, #1
 800b60c:	619a      	strpl	r2, [r3, #24]

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800b60e:	6859      	ldr	r1, [r3, #4]
 800b610:	4a08      	ldr	r2, [pc, #32]	; (800b634 <I2C_IsAcknowledgeFailed+0x7c>)
 800b612:	400a      	ands	r2, r1
 800b614:	605a      	str	r2, [r3, #4]

    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 800b616:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800b618:	f043 0304 	orr.w	r3, r3, #4
 800b61c:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 800b61e:	2320      	movs	r3, #32
 800b620:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 800b624:	2300      	movs	r3, #0
 800b626:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800b62a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40

    return HAL_ERROR;
 800b62e:	2001      	movs	r0, #1
  }
  return HAL_OK;
}
 800b630:	bd70      	pop	{r4, r5, r6, pc}
 800b632:	bf00      	nop
 800b634:	fe00e800 	.word	0xfe00e800

0800b638 <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 800b638:	b570      	push	{r4, r5, r6, lr}
 800b63a:	4604      	mov	r4, r0
 800b63c:	460d      	mov	r5, r1
 800b63e:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 800b640:	6823      	ldr	r3, [r4, #0]
 800b642:	699b      	ldr	r3, [r3, #24]
 800b644:	069b      	lsls	r3, r3, #26
 800b646:	d419      	bmi.n	800b67c <I2C_WaitOnSTOPFlagUntilTimeout+0x44>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 800b648:	4632      	mov	r2, r6
 800b64a:	4629      	mov	r1, r5
 800b64c:	4620      	mov	r0, r4
 800b64e:	f7ff ffb3 	bl	800b5b8 <I2C_IsAcknowledgeFailed>
 800b652:	b9a8      	cbnz	r0, 800b680 <I2C_WaitOnSTOPFlagUntilTimeout+0x48>
    {
      return HAL_ERROR;
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800b654:	f7fb fcde 	bl	8007014 <HAL_GetTick>
 800b658:	1b80      	subs	r0, r0, r6
 800b65a:	4285      	cmp	r5, r0
 800b65c:	d301      	bcc.n	800b662 <I2C_WaitOnSTOPFlagUntilTimeout+0x2a>
 800b65e:	2d00      	cmp	r5, #0
 800b660:	d1ee      	bne.n	800b640 <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800b662:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800b664:	f043 0320 	orr.w	r3, r3, #32
 800b668:	6463      	str	r3, [r4, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 800b66a:	2320      	movs	r3, #32
 800b66c:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
 800b670:	2300      	movs	r3, #0
 800b672:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 800b676:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 800b67a:	e001      	b.n	800b680 <I2C_WaitOnSTOPFlagUntilTimeout+0x48>

      return HAL_ERROR;
    }
  }
  return HAL_OK;
 800b67c:	2000      	movs	r0, #0
 800b67e:	bd70      	pop	{r4, r5, r6, pc}
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
    {
      return HAL_ERROR;
 800b680:	2001      	movs	r0, #1

      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 800b682:	bd70      	pop	{r4, r5, r6, pc}

0800b684 <I2C_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
                                                    uint32_t Timeout, uint32_t Tickstart)
{
 800b684:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b688:	9f06      	ldr	r7, [sp, #24]
 800b68a:	4604      	mov	r4, r0
 800b68c:	4688      	mov	r8, r1
 800b68e:	4616      	mov	r6, r2
 800b690:	461d      	mov	r5, r3
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 800b692:	6822      	ldr	r2, [r4, #0]
 800b694:	6993      	ldr	r3, [r2, #24]
 800b696:	ea38 0303 	bics.w	r3, r8, r3
 800b69a:	bf0c      	ite	eq
 800b69c:	2301      	moveq	r3, #1
 800b69e:	2300      	movne	r3, #0
 800b6a0:	42b3      	cmp	r3, r6
 800b6a2:	d117      	bne.n	800b6d4 <I2C_WaitOnFlagUntilTimeout+0x50>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800b6a4:	1c6b      	adds	r3, r5, #1
 800b6a6:	d0f5      	beq.n	800b694 <I2C_WaitOnFlagUntilTimeout+0x10>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800b6a8:	f7fb fcb4 	bl	8007014 <HAL_GetTick>
 800b6ac:	1bc0      	subs	r0, r0, r7
 800b6ae:	4285      	cmp	r5, r0
 800b6b0:	d301      	bcc.n	800b6b6 <I2C_WaitOnFlagUntilTimeout+0x32>
 800b6b2:	2d00      	cmp	r5, #0
 800b6b4:	d1ed      	bne.n	800b692 <I2C_WaitOnFlagUntilTimeout+0xe>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800b6b6:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800b6b8:	f043 0320 	orr.w	r3, r3, #32
 800b6bc:	6463      	str	r3, [r4, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 800b6be:	2320      	movs	r3, #32
 800b6c0:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
 800b6c4:	2300      	movs	r3, #0
 800b6c6:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 800b6ca:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 800b6ce:	2001      	movs	r0, #1
 800b6d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        __HAL_UNLOCK(hi2c);
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
 800b6d4:	2000      	movs	r0, #0
}
 800b6d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800b6da <HAL_I2C_MspInit>:
 800b6da:	4770      	bx	lr

0800b6dc <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 800b6dc:	b510      	push	{r4, lr}
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 800b6de:	4604      	mov	r4, r0
 800b6e0:	2800      	cmp	r0, #0
 800b6e2:	d04a      	beq.n	800b77a <HAL_I2C_Init+0x9e>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
 800b6e4:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 800b6e8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800b6ec:	b91b      	cbnz	r3, 800b6f6 <HAL_I2C_Init+0x1a>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 800b6ee:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
 800b6f2:	f7ff fff2 	bl	800b6da <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 800b6f6:	2324      	movs	r3, #36	; 0x24
 800b6f8:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 800b6fc:	6823      	ldr	r3, [r4, #0]
  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800b6fe:	68e1      	ldr	r1, [r4, #12]
  }

  hi2c->State = HAL_I2C_STATE_BUSY;

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 800b700:	681a      	ldr	r2, [r3, #0]
 800b702:	f022 0201 	bic.w	r2, r2, #1
 800b706:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 800b708:	6862      	ldr	r2, [r4, #4]
 800b70a:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 800b70e:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 800b710:	689a      	ldr	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800b712:	2901      	cmp	r1, #1
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 800b714:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800b718:	609a      	str	r2, [r3, #8]
 800b71a:	68a2      	ldr	r2, [r4, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800b71c:	d103      	bne.n	800b726 <HAL_I2C_Init+0x4a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 800b71e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800b722:	609a      	str	r2, [r3, #8]
 800b724:	e007      	b.n	800b736 <HAL_I2C_Init+0x5a>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 800b726:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 800b72a:	2902      	cmp	r1, #2
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 800b72c:	609a      	str	r2, [r3, #8]

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 800b72e:	bf04      	itt	eq
 800b730:	f44f 6200 	moveq.w	r2, #2048	; 0x800
 800b734:	605a      	streq	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 800b736:	685a      	ldr	r2, [r3, #4]
  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 800b738:	6921      	ldr	r1, [r4, #16]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 800b73a:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 800b73e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800b742:	605a      	str	r2, [r3, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 800b744:	68da      	ldr	r2, [r3, #12]
 800b746:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800b74a:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 800b74c:	6962      	ldr	r2, [r4, #20]
 800b74e:	430a      	orrs	r2, r1
 800b750:	69a1      	ldr	r1, [r4, #24]
 800b752:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800b756:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 800b758:	69e1      	ldr	r1, [r4, #28]
 800b75a:	6a22      	ldr	r2, [r4, #32]
 800b75c:	430a      	orrs	r2, r1
 800b75e:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 800b760:	681a      	ldr	r2, [r3, #0]
 800b762:	f042 0201 	orr.w	r2, r2, #1
 800b766:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800b768:	2000      	movs	r0, #0
  hi2c->State = HAL_I2C_STATE_READY;
 800b76a:	2320      	movs	r3, #32
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800b76c:	6460      	str	r0, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 800b76e:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 800b772:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 800b774:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42

  return HAL_OK;
 800b778:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
  {
    return HAL_ERROR;
 800b77a:	2001      	movs	r0, #1
  hi2c->State = HAL_I2C_STATE_READY;
  hi2c->PreviousState = I2C_STATE_NONE;
  hi2c->Mode = HAL_I2C_MODE_NONE;

  return HAL_OK;
}
 800b77c:	bd10      	pop	{r4, pc}

0800b77e <HAL_I2C_MspDeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
{
 800b77e:	4770      	bx	lr

0800b780 <HAL_I2C_Master_Transmit>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size,
                                          uint32_t Timeout)
{
 800b780:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 800b784:	4699      	mov	r9, r3
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
 800b786:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size,
                                          uint32_t Timeout)
{
 800b78a:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
 800b78c:	2b20      	cmp	r3, #32
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size,
                                          uint32_t Timeout)
{
 800b78e:	4604      	mov	r4, r0
 800b790:	460f      	mov	r7, r1
 800b792:	4692      	mov	sl, r2
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
 800b794:	f040 8099 	bne.w	800b8ca <HAL_I2C_Master_Transmit+0x14a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 800b798:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 800b79c:	2b01      	cmp	r3, #1
 800b79e:	f000 8094 	beq.w	800b8ca <HAL_I2C_Master_Transmit+0x14a>
 800b7a2:	f04f 0801 	mov.w	r8, #1
 800b7a6:	f880 8040 	strb.w	r8, [r0, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 800b7aa:	f7fb fc33 	bl	8007014 <HAL_GetTick>

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800b7ae:	2319      	movs	r3, #25
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 800b7b0:	4606      	mov	r6, r0

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800b7b2:	9000      	str	r0, [sp, #0]
 800b7b4:	4642      	mov	r2, r8
 800b7b6:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800b7ba:	4620      	mov	r0, r4
 800b7bc:	f7ff ff62 	bl	800b684 <I2C_WaitOnFlagUntilTimeout>
 800b7c0:	2800      	cmp	r0, #0
 800b7c2:	f040 8084 	bne.w	800b8ce <HAL_I2C_Master_Transmit+0x14e>
    {
      return HAL_ERROR;
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 800b7c6:	2321      	movs	r3, #33	; 0x21
 800b7c8:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 800b7cc:	2310      	movs	r3, #16
 800b7ce:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800b7d2:	6460      	str	r0, [r4, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
    hi2c->XferCount = Size;
 800b7d4:	f8a4 902a 	strh.w	r9, [r4, #42]	; 0x2a
    hi2c->XferISR   = NULL;

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800b7d8:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 800b7da:	f8c4 a024 	str.w	sl, [r4, #36]	; 0x24
    hi2c->XferCount = Size;
    hi2c->XferISR   = NULL;

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800b7de:	b29b      	uxth	r3, r3
 800b7e0:	2bff      	cmp	r3, #255	; 0xff
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
    hi2c->XferCount = Size;
    hi2c->XferISR   = NULL;
 800b7e2:	6360      	str	r0, [r4, #52]	; 0x34
 800b7e4:	4b3c      	ldr	r3, [pc, #240]	; (800b8d8 <HAL_I2C_Master_Transmit+0x158>)

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800b7e6:	d903      	bls.n	800b7f0 <HAL_I2C_Master_Transmit+0x70>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 800b7e8:	22ff      	movs	r2, #255	; 0xff
 800b7ea:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 800b7ec:	9300      	str	r3, [sp, #0]
 800b7ee:	e031      	b.n	800b854 <HAL_I2C_Master_Transmit+0xd4>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 800b7f0:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
 800b7f2:	9300      	str	r3, [sp, #0]
      hi2c->XferSize = MAX_NBYTE_SIZE;
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 800b7f4:	b292      	uxth	r2, r2
 800b7f6:	8522      	strh	r2, [r4, #40]	; 0x28
 800b7f8:	e033      	b.n	800b862 <HAL_I2C_Master_Transmit+0xe2>
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 800b7fa:	4632      	mov	r2, r6
 800b7fc:	4629      	mov	r1, r5
 800b7fe:	4620      	mov	r0, r4
 800b800:	f7ff feda 	bl	800b5b8 <I2C_IsAcknowledgeFailed>
 800b804:	2800      	cmp	r0, #0
 800b806:	d162      	bne.n	800b8ce <HAL_I2C_Master_Transmit+0x14e>
    {
      return HAL_ERROR;
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800b808:	1c6a      	adds	r2, r5, #1
 800b80a:	d136      	bne.n	800b87a <HAL_I2C_Master_Transmit+0xfa>
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 800b80c:	6822      	ldr	r2, [r4, #0]
 800b80e:	6993      	ldr	r3, [r2, #24]
 800b810:	079b      	lsls	r3, r3, #30
 800b812:	d5f2      	bpl.n	800b7fa <HAL_I2C_Master_Transmit+0x7a>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
      {
        return HAL_ERROR;
      }
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 800b814:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800b816:	f813 1b01 	ldrb.w	r1, [r3], #1
 800b81a:	6291      	str	r1, [r2, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 800b81c:	6263      	str	r3, [r4, #36]	; 0x24

      hi2c->XferCount--;
 800b81e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 800b820:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;

      hi2c->XferCount--;
 800b822:	3b01      	subs	r3, #1
 800b824:	b29b      	uxth	r3, r3
 800b826:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800b828:	8d63      	ldrh	r3, [r4, #42]	; 0x2a

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;

      hi2c->XferCount--;
      hi2c->XferSize--;
 800b82a:	3a01      	subs	r2, #1
 800b82c:	b292      	uxth	r2, r2

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800b82e:	b29b      	uxth	r3, r3

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;

      hi2c->XferCount--;
      hi2c->XferSize--;
 800b830:	8522      	strh	r2, [r4, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800b832:	b1eb      	cbz	r3, 800b870 <HAL_I2C_Master_Transmit+0xf0>
 800b834:	b9e2      	cbnz	r2, 800b870 <HAL_I2C_Master_Transmit+0xf0>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 800b836:	9600      	str	r6, [sp, #0]
 800b838:	462b      	mov	r3, r5
 800b83a:	2180      	movs	r1, #128	; 0x80
 800b83c:	4620      	mov	r0, r4
 800b83e:	f7ff ff21 	bl	800b684 <I2C_WaitOnFlagUntilTimeout>
 800b842:	2800      	cmp	r0, #0
 800b844:	d143      	bne.n	800b8ce <HAL_I2C_Master_Transmit+0x14e>
        {
          return HAL_ERROR;
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800b846:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800b848:	b29b      	uxth	r3, r3
 800b84a:	2bff      	cmp	r3, #255	; 0xff
 800b84c:	d905      	bls.n	800b85a <HAL_I2C_Master_Transmit+0xda>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 800b84e:	22ff      	movs	r2, #255	; 0xff
 800b850:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 800b852:	9000      	str	r0, [sp, #0]
 800b854:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800b858:	e006      	b.n	800b868 <HAL_I2C_Master_Transmit+0xe8>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 800b85a:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 800b85c:	9000      	str	r0, [sp, #0]
          hi2c->XferSize = MAX_NBYTE_SIZE;
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 800b85e:	b292      	uxth	r2, r2
 800b860:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 800b862:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800b866:	b2d2      	uxtb	r2, r2
 800b868:	4639      	mov	r1, r7
 800b86a:	4620      	mov	r0, r4
 800b86c:	f7ff fe8a 	bl	800b584 <I2C_TransferConfig>
    {
      hi2c->XferSize = hi2c->XferCount;
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
    }

    while (hi2c->XferCount > 0U)
 800b870:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800b872:	b29b      	uxth	r3, r3
 800b874:	2b00      	cmp	r3, #0
 800b876:	d1c9      	bne.n	800b80c <HAL_I2C_Master_Transmit+0x8c>
 800b878:	e013      	b.n	800b8a2 <HAL_I2C_Master_Transmit+0x122>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800b87a:	f7fb fbcb 	bl	8007014 <HAL_GetTick>
 800b87e:	1b80      	subs	r0, r0, r6
 800b880:	4285      	cmp	r5, r0
 800b882:	d301      	bcc.n	800b888 <HAL_I2C_Master_Transmit+0x108>
 800b884:	2d00      	cmp	r5, #0
 800b886:	d1c1      	bne.n	800b80c <HAL_I2C_Master_Transmit+0x8c>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800b888:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800b88a:	f043 0320 	orr.w	r3, r3, #32
 800b88e:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 800b890:	2320      	movs	r3, #32
 800b892:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 800b896:	2300      	movs	r3, #0
 800b898:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 800b89c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 800b8a0:	e015      	b.n	800b8ce <HAL_I2C_Master_Transmit+0x14e>
      }
    }

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800b8a2:	4632      	mov	r2, r6
 800b8a4:	4629      	mov	r1, r5
 800b8a6:	4620      	mov	r0, r4
 800b8a8:	f7ff fec6 	bl	800b638 <I2C_WaitOnSTOPFlagUntilTimeout>
 800b8ac:	b978      	cbnz	r0, 800b8ce <HAL_I2C_Master_Transmit+0x14e>
    {
      return HAL_ERROR;
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800b8ae:	6823      	ldr	r3, [r4, #0]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800b8b0:	4a0a      	ldr	r2, [pc, #40]	; (800b8dc <HAL_I2C_Master_Transmit+0x15c>)
    {
      return HAL_ERROR;
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800b8b2:	2120      	movs	r1, #32
 800b8b4:	61d9      	str	r1, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800b8b6:	685d      	ldr	r5, [r3, #4]
 800b8b8:	402a      	ands	r2, r5
 800b8ba:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 800b8bc:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800b8c0:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 800b8c4:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);

    return HAL_OK;
 800b8c8:	e002      	b.n	800b8d0 <HAL_I2C_Master_Transmit+0x150>
  }
  else
  {
    return HAL_BUSY;
 800b8ca:	2002      	movs	r0, #2
 800b8cc:	e000      	b.n	800b8d0 <HAL_I2C_Master_Transmit+0x150>
    while (hi2c->XferCount > 0U)
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
      {
        return HAL_ERROR;
 800b8ce:	2001      	movs	r0, #1
  }
  else
  {
    return HAL_BUSY;
  }
}
 800b8d0:	b002      	add	sp, #8
 800b8d2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800b8d6:	bf00      	nop
 800b8d8:	80002000 	.word	0x80002000
 800b8dc:	fe00e800 	.word	0xfe00e800

0800b8e0 <HAL_I2C_Master_Receive>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size,
                                         uint32_t Timeout)
{
 800b8e0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 800b8e4:	4699      	mov	r9, r3
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
 800b8e6:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size,
                                         uint32_t Timeout)
{
 800b8ea:	9e0a      	ldr	r6, [sp, #40]	; 0x28
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
 800b8ec:	2b20      	cmp	r3, #32
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size,
                                         uint32_t Timeout)
{
 800b8ee:	4604      	mov	r4, r0
 800b8f0:	460f      	mov	r7, r1
 800b8f2:	4692      	mov	sl, r2
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
 800b8f4:	f040 80ae 	bne.w	800ba54 <HAL_I2C_Master_Receive+0x174>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 800b8f8:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 800b8fc:	2b01      	cmp	r3, #1
 800b8fe:	f000 80a9 	beq.w	800ba54 <HAL_I2C_Master_Receive+0x174>
 800b902:	f04f 0801 	mov.w	r8, #1
 800b906:	f880 8040 	strb.w	r8, [r0, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 800b90a:	f7fb fb83 	bl	8007014 <HAL_GetTick>

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800b90e:	2319      	movs	r3, #25
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 800b910:	4605      	mov	r5, r0

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800b912:	9000      	str	r0, [sp, #0]
 800b914:	4642      	mov	r2, r8
 800b916:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800b91a:	4620      	mov	r0, r4
 800b91c:	f7ff feb2 	bl	800b684 <I2C_WaitOnFlagUntilTimeout>
 800b920:	2800      	cmp	r0, #0
 800b922:	f040 8099 	bne.w	800ba58 <HAL_I2C_Master_Receive+0x178>
    {
      return HAL_ERROR;
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 800b926:	2322      	movs	r3, #34	; 0x22
 800b928:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 800b92c:	2310      	movs	r3, #16
 800b92e:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800b932:	6460      	str	r0, [r4, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
    hi2c->XferCount = Size;
 800b934:	f8a4 902a 	strh.w	r9, [r4, #42]	; 0x2a
    hi2c->XferISR   = NULL;

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800b938:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 800b93a:	f8c4 a024 	str.w	sl, [r4, #36]	; 0x24
    hi2c->XferCount = Size;
    hi2c->XferISR   = NULL;

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800b93e:	b29b      	uxth	r3, r3
 800b940:	2bff      	cmp	r3, #255	; 0xff
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
    hi2c->XferCount = Size;
    hi2c->XferISR   = NULL;
 800b942:	6360      	str	r0, [r4, #52]	; 0x34
 800b944:	4b46      	ldr	r3, [pc, #280]	; (800ba60 <HAL_I2C_Master_Receive+0x180>)

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800b946:	d903      	bls.n	800b950 <HAL_I2C_Master_Receive+0x70>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 800b948:	22ff      	movs	r2, #255	; 0xff
 800b94a:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 800b94c:	9300      	str	r3, [sp, #0]
 800b94e:	e042      	b.n	800b9d6 <HAL_I2C_Master_Receive+0xf6>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 800b950:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
 800b952:	9300      	str	r3, [sp, #0]
      hi2c->XferSize = MAX_NBYTE_SIZE;
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 800b954:	b292      	uxth	r2, r2
 800b956:	8522      	strh	r2, [r4, #40]	; 0x28
 800b958:	e044      	b.n	800b9e4 <HAL_I2C_Master_Receive+0x104>
        return HAL_ERROR;
      }
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800b95a:	f7fb fb5b 	bl	8007014 <HAL_GetTick>
 800b95e:	1b40      	subs	r0, r0, r5
 800b960:	4286      	cmp	r6, r0
 800b962:	d358      	bcc.n	800ba16 <HAL_I2C_Master_Receive+0x136>
 800b964:	2e00      	cmp	r6, #0
 800b966:	d056      	beq.n	800ba16 <HAL_I2C_Master_Receive+0x136>
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 800b968:	6823      	ldr	r3, [r4, #0]
 800b96a:	699b      	ldr	r3, [r3, #24]
 800b96c:	075b      	lsls	r3, r3, #29
 800b96e:	d410      	bmi.n	800b992 <HAL_I2C_Master_Receive+0xb2>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 800b970:	462a      	mov	r2, r5
 800b972:	4631      	mov	r1, r6
 800b974:	4620      	mov	r0, r4
 800b976:	f7ff fe1f 	bl	800b5b8 <I2C_IsAcknowledgeFailed>
 800b97a:	2800      	cmp	r0, #0
 800b97c:	d16c      	bne.n	800ba58 <HAL_I2C_Master_Receive+0x178>
    {
      return HAL_ERROR;
    }

    /* Check if a STOPF is detected */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
 800b97e:	6823      	ldr	r3, [r4, #0]
 800b980:	699a      	ldr	r2, [r3, #24]
 800b982:	0691      	lsls	r1, r2, #26
 800b984:	d5e9      	bpl.n	800b95a <HAL_I2C_Master_Receive+0x7a>
    {
      /* Check if an RXNE is pending */
      /* Store Last receive data if any */
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && (hi2c->XferSize > 0U))
 800b986:	699a      	ldr	r2, [r3, #24]
 800b988:	0752      	lsls	r2, r2, #29
 800b98a:	d537      	bpl.n	800b9fc <HAL_I2C_Master_Receive+0x11c>
 800b98c:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 800b98e:	2a00      	cmp	r2, #0
 800b990:	d034      	beq.n	800b9fc <HAL_I2C_Master_Receive+0x11c>
      {
        return HAL_ERROR;
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 800b992:	6822      	ldr	r2, [r4, #0]
 800b994:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800b996:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800b998:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 800b99a:	6a63      	ldr	r3, [r4, #36]	; 0x24

      hi2c->XferSize--;
 800b99c:	8d22      	ldrh	r2, [r4, #40]	; 0x28

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 800b99e:	3301      	adds	r3, #1
 800b9a0:	6263      	str	r3, [r4, #36]	; 0x24

      hi2c->XferSize--;
      hi2c->XferCount--;
 800b9a2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800b9a4:	3b01      	subs	r3, #1
 800b9a6:	b29b      	uxth	r3, r3
 800b9a8:	8563      	strh	r3, [r4, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800b9aa:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;

      hi2c->XferSize--;
 800b9ac:	3a01      	subs	r2, #1
 800b9ae:	b292      	uxth	r2, r2
      hi2c->XferCount--;

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800b9b0:	b29b      	uxth	r3, r3
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;

      hi2c->XferSize--;
 800b9b2:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800b9b4:	b1eb      	cbz	r3, 800b9f2 <HAL_I2C_Master_Receive+0x112>
 800b9b6:	b9e2      	cbnz	r2, 800b9f2 <HAL_I2C_Master_Receive+0x112>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 800b9b8:	9500      	str	r5, [sp, #0]
 800b9ba:	4633      	mov	r3, r6
 800b9bc:	2180      	movs	r1, #128	; 0x80
 800b9be:	4620      	mov	r0, r4
 800b9c0:	f7ff fe60 	bl	800b684 <I2C_WaitOnFlagUntilTimeout>
 800b9c4:	2800      	cmp	r0, #0
 800b9c6:	d147      	bne.n	800ba58 <HAL_I2C_Master_Receive+0x178>
        {
          return HAL_ERROR;
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800b9c8:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800b9ca:	b29b      	uxth	r3, r3
 800b9cc:	2bff      	cmp	r3, #255	; 0xff
 800b9ce:	d905      	bls.n	800b9dc <HAL_I2C_Master_Receive+0xfc>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 800b9d0:	22ff      	movs	r2, #255	; 0xff
 800b9d2:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 800b9d4:	9000      	str	r0, [sp, #0]
 800b9d6:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800b9da:	e006      	b.n	800b9ea <HAL_I2C_Master_Receive+0x10a>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 800b9dc:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 800b9de:	9000      	str	r0, [sp, #0]
          hi2c->XferSize = MAX_NBYTE_SIZE;
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 800b9e0:	b292      	uxth	r2, r2
 800b9e2:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 800b9e4:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800b9e8:	b2d2      	uxtb	r2, r2
 800b9ea:	4639      	mov	r1, r7
 800b9ec:	4620      	mov	r0, r4
 800b9ee:	f7ff fdc9 	bl	800b584 <I2C_TransferConfig>
    {
      hi2c->XferSize = hi2c->XferCount;
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
    }

    while (hi2c->XferCount > 0U)
 800b9f2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800b9f4:	b29b      	uxth	r3, r3
 800b9f6:	2b00      	cmp	r3, #0
 800b9f8:	d1b6      	bne.n	800b968 <HAL_I2C_Master_Receive+0x88>
 800b9fa:	e017      	b.n	800ba2c <HAL_I2C_Master_Receive+0x14c>
        return HAL_OK;
      }
      else
      {
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800b9fc:	2120      	movs	r1, #32
 800b9fe:	61d9      	str	r1, [r3, #28]

        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
 800ba00:	6858      	ldr	r0, [r3, #4]
 800ba02:	4a18      	ldr	r2, [pc, #96]	; (800ba64 <HAL_I2C_Master_Receive+0x184>)
 800ba04:	4002      	ands	r2, r0
 800ba06:	605a      	str	r2, [r3, #4]

        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800ba08:	2300      	movs	r3, #0
 800ba0a:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 800ba0c:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 800ba10:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 800ba14:	e007      	b.n	800ba26 <HAL_I2C_Master_Receive+0x146>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800ba16:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800ba18:	f043 0320 	orr.w	r3, r3, #32
 800ba1c:	6463      	str	r3, [r4, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 800ba1e:	2320      	movs	r3, #32
 800ba20:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 800ba24:	2300      	movs	r3, #0
 800ba26:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 800ba2a:	e015      	b.n	800ba58 <HAL_I2C_Master_Receive+0x178>
      }
    }

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800ba2c:	462a      	mov	r2, r5
 800ba2e:	4631      	mov	r1, r6
 800ba30:	4620      	mov	r0, r4
 800ba32:	f7ff fe01 	bl	800b638 <I2C_WaitOnSTOPFlagUntilTimeout>
 800ba36:	b978      	cbnz	r0, 800ba58 <HAL_I2C_Master_Receive+0x178>
    {
      return HAL_ERROR;
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800ba38:	6823      	ldr	r3, [r4, #0]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800ba3a:	4a0a      	ldr	r2, [pc, #40]	; (800ba64 <HAL_I2C_Master_Receive+0x184>)
    {
      return HAL_ERROR;
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800ba3c:	2120      	movs	r1, #32
 800ba3e:	61d9      	str	r1, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800ba40:	685d      	ldr	r5, [r3, #4]
 800ba42:	402a      	ands	r2, r5
 800ba44:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 800ba46:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800ba4a:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 800ba4e:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);

    return HAL_OK;
 800ba52:	e002      	b.n	800ba5a <HAL_I2C_Master_Receive+0x17a>
  }
  else
  {
    return HAL_BUSY;
 800ba54:	2002      	movs	r0, #2
 800ba56:	e000      	b.n	800ba5a <HAL_I2C_Master_Receive+0x17a>
    while (hi2c->XferCount > 0U)
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
      {
        return HAL_ERROR;
 800ba58:	2001      	movs	r0, #1
  }
  else
  {
    return HAL_BUSY;
  }
}
 800ba5a:	b002      	add	sp, #8
 800ba5c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800ba60:	80002400 	.word	0x80002400
 800ba64:	fe00e800 	.word	0xfe00e800

0800ba68 <SD_FindSCR>:
  * @param  hsd Pointer to SD handle
  * @param  pSCR pointer to the buffer that will contain the SCR value
  * @retval error state
  */
static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
 800ba68:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800ba6c:	b087      	sub	sp, #28
 800ba6e:	4604      	mov	r4, r0
 800ba70:	460d      	mov	r5, r1
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 800ba72:	f7fb facf 	bl	8007014 <HAL_GetTick>
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0UL, 0UL};
  uint32_t *scr = pSCR;

  /* Set Block Size To 8 Bytes */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
 800ba76:	2108      	movs	r1, #8
  */
static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 800ba78:	4607      	mov	r7, r0
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0UL, 0UL};
  uint32_t *scr = pSCR;

  /* Set Block Size To 8 Bytes */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
 800ba7a:	6820      	ldr	r0, [r4, #0]
 800ba7c:	f001 f9a4 	bl	800cdc8 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800ba80:	2800      	cmp	r0, #0
 800ba82:	d154      	bne.n	800bb2e <SD_FindSCR+0xc6>
  {
    return errorstate;
  }

  /* Send CMD55 APP_CMD with argument as card's RCA */
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)((hsd->SdCard.RelCardAdd) << 16U));
 800ba84:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800ba86:	6820      	ldr	r0, [r4, #0]
 800ba88:	0409      	lsls	r1, r1, #16
 800ba8a:	f001 fad6 	bl	800d03a <SDMMC_CmdAppCommand>
  if(errorstate != HAL_SD_ERROR_NONE)
 800ba8e:	2800      	cmp	r0, #0
 800ba90:	d14d      	bne.n	800bb2e <SD_FindSCR+0xc6>
  }

  config.DataTimeOut   = SDMMC_DATATIMEOUT;
  config.DataLength    = 8U;
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_8B;
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800ba92:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800ba96:	f04f 0c30 	mov.w	ip, #48	; 0x30
 800ba9a:	f04f 0e02 	mov.w	lr, #2
 800ba9e:	2608      	movs	r6, #8
 800baa0:	e88d 5048 	stmia.w	sp, {r3, r6, ip, lr}
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800baa4:	9004      	str	r0, [sp, #16]
  config.DPSM          = SDMMC_DPSM_ENABLE;
 800baa6:	2301      	movs	r3, #1
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 800baa8:	4669      	mov	r1, sp
 800baaa:	6820      	ldr	r0, [r4, #0]
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
  config.DataLength    = 8U;
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_8B;
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
  config.DPSM          = SDMMC_DPSM_ENABLE;
 800baac:	9305      	str	r3, [sp, #20]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 800baae:	f001 f8af 	bl	800cc10 <SDMMC_ConfigData>

  /* Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
  errorstate = SDMMC_CmdSendSCR(hsd->Instance);
 800bab2:	6820      	ldr	r0, [r4, #0]
 800bab4:	f001 fada 	bl	800d06c <SDMMC_CmdSendSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
 800bab8:	2800      	cmp	r0, #0
 800baba:	d138      	bne.n	800bb2e <SD_FindSCR+0xc6>
 800babc:	4606      	mov	r6, r0
 800babe:	4680      	mov	r8, r0
 800bac0:	4681      	mov	r9, r0
  {
    return errorstate;
  }

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND | SDMMC_FLAG_DATAEND))
 800bac2:	6822      	ldr	r2, [r4, #0]
 800bac4:	6b51      	ldr	r1, [r2, #52]	; 0x34
 800bac6:	f240 532a 	movw	r3, #1322	; 0x52a
 800baca:	400b      	ands	r3, r1
 800bacc:	b9bb      	cbnz	r3, 800bafe <SD_FindSCR+0x96>
  {
    if((!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOE)) && (index == 0U))
 800bace:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800bad0:	0318      	lsls	r0, r3, #12
 800bad2:	d40c      	bmi.n	800baee <SD_FindSCR+0x86>
 800bad4:	f1b9 0f00 	cmp.w	r9, #0
 800bad8:	d107      	bne.n	800baea <SD_FindSCR+0x82>
    {
      tempscr[0] = SDMMC_ReadFIFO(hsd->Instance);
 800bada:	4610      	mov	r0, r2
 800badc:	f001 f85c 	bl	800cb98 <SDMMC_ReadFIFO>
 800bae0:	4680      	mov	r8, r0
      tempscr[1] = SDMMC_ReadFIFO(hsd->Instance);
 800bae2:	6820      	ldr	r0, [r4, #0]
 800bae4:	f001 f858 	bl	800cb98 <SDMMC_ReadFIFO>
 800bae8:	4606      	mov	r6, r0
 800baea:	f04f 0901 	mov.w	r9, #1
      index++;
    }


    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 800baee:	f7fb fa91 	bl	8007014 <HAL_GetTick>
 800baf2:	1bc0      	subs	r0, r0, r7
 800baf4:	3001      	adds	r0, #1
 800baf6:	d1e4      	bne.n	800bac2 <SD_FindSCR+0x5a>
    {
      return HAL_SD_ERROR_TIMEOUT;
 800baf8:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800bafc:	e017      	b.n	800bb2e <SD_FindSCR+0xc6>
      return HAL_SD_ERROR_TIMEOUT;
    }
  }
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 800bafe:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800bb00:	0719      	lsls	r1, r3, #28
 800bb02:	d501      	bpl.n	800bb08 <SD_FindSCR+0xa0>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
 800bb04:	2008      	movs	r0, #8
 800bb06:	e009      	b.n	800bb1c <SD_FindSCR+0xb4>

    return HAL_SD_ERROR_DATA_TIMEOUT;
  }
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800bb08:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800bb0a:	079b      	lsls	r3, r3, #30
 800bb0c:	d501      	bpl.n	800bb12 <SD_FindSCR+0xaa>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
 800bb0e:	2002      	movs	r0, #2
 800bb10:	e004      	b.n	800bb1c <SD_FindSCR+0xb4>

    return HAL_SD_ERROR_DATA_CRC_FAIL;
  }
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 800bb12:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800bb14:	f013 0020 	ands.w	r0, r3, #32
 800bb18:	d002      	beq.n	800bb20 <SD_FindSCR+0xb8>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
 800bb1a:	2020      	movs	r0, #32
 800bb1c:	6390      	str	r0, [r2, #56]	; 0x38

    return HAL_SD_ERROR_RX_OVERRUN;
 800bb1e:	e006      	b.n	800bb2e <SD_FindSCR+0xc6>
  }
  else
  {
    /* No error flag set */
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800bb20:	4b04      	ldr	r3, [pc, #16]	; (800bb34 <SD_FindSCR+0xcc>)
 800bb22:	6393      	str	r3, [r2, #56]	; 0x38
 800bb24:	ba36      	rev	r6, r6
 800bb26:	fa98 f388 	rev.w	r3, r8

    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8) |\
 800bb2a:	602e      	str	r6, [r5, #0]
            ((tempscr[1] & SDMMC_16TO23BITS) >> 8) | ((tempscr[1] & SDMMC_24TO31BITS) >> 24));
    scr++;
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8) |\
 800bb2c:	606b      	str	r3, [r5, #4]
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24));

  }

  return HAL_SD_ERROR_NONE;
}
 800bb2e:	b007      	add	sp, #28
 800bb30:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800bb34:	18000f3a 	.word	0x18000f3a

0800bb38 <SD_UltraHighSpeed>:
  *         of PLL to have SDMMCCK clock between 50 and 120 MHz
  * @param  hsd SD handle
  * @retval SD Card error state
  */
static uint32_t SD_UltraHighSpeed(SD_HandleTypeDef *hsd)
{
 800bb38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t errorstate = HAL_SD_ERROR_NONE;
  SDMMC_DataInitTypeDef sdmmc_datainitstructure;
  uint32_t SD_hs[16]  = {0};
 800bb3c:	2440      	movs	r4, #64	; 0x40
  *         of PLL to have SDMMCCK clock between 50 and 120 MHz
  * @param  hsd SD handle
  * @retval SD Card error state
  */
static uint32_t SD_UltraHighSpeed(SD_HandleTypeDef *hsd)
{
 800bb3e:	b096      	sub	sp, #88	; 0x58
 800bb40:	4606      	mov	r6, r0
  uint32_t errorstate = HAL_SD_ERROR_NONE;
  SDMMC_DataInitTypeDef sdmmc_datainitstructure;
  uint32_t SD_hs[16]  = {0};
 800bb42:	4622      	mov	r2, r4
 800bb44:	2100      	movs	r1, #0
 800bb46:	a806      	add	r0, sp, #24
 800bb48:	f001 fcc1 	bl	800d4ce <memset>
  uint32_t count, loop = 0 ;
  uint32_t Timeout = HAL_GetTick();
 800bb4c:	f7fb fa62 	bl	8007014 <HAL_GetTick>

  if(hsd->SdCard.CardSpeed == CARD_NORMAL_SPEED)
 800bb50:	6df3      	ldr	r3, [r6, #92]	; 0x5c
{
  uint32_t errorstate = HAL_SD_ERROR_NONE;
  SDMMC_DataInitTypeDef sdmmc_datainitstructure;
  uint32_t SD_hs[16]  = {0};
  uint32_t count, loop = 0 ;
  uint32_t Timeout = HAL_GetTick();
 800bb52:	4607      	mov	r7, r0

  if(hsd->SdCard.CardSpeed == CARD_NORMAL_SPEED)
 800bb54:	2b00      	cmp	r3, #0
 800bb56:	d061      	beq.n	800bc1c <SD_UltraHighSpeed+0xe4>
  {
     /* Standard Speed Card <= 12.5Mhz  */
     return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
  }

  if((hsd->SdCard.CardSpeed == CARD_ULTRA_HIGH_SPEED) &&
 800bb58:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800bb5c:	d161      	bne.n	800bc22 <SD_UltraHighSpeed+0xea>
 800bb5e:	69b5      	ldr	r5, [r6, #24]
 800bb60:	2d01      	cmp	r5, #1
 800bb62:	d15e      	bne.n	800bc22 <SD_UltraHighSpeed+0xea>
     (hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE))
  {
    /* Initialize the Data control register */
    hsd->Instance->DCTRL = 0;
 800bb64:	6830      	ldr	r0, [r6, #0]
 800bb66:	2300      	movs	r3, #0
 800bb68:	62c3      	str	r3, [r0, #44]	; 0x2c
    errorstate = SDMMC_CmdBlockLength(hsd->Instance, 64U);
 800bb6a:	4621      	mov	r1, r4
 800bb6c:	f001 f92c 	bl	800cdc8 <SDMMC_CmdBlockLength>

    if (errorstate != HAL_SD_ERROR_NONE)
 800bb70:	2800      	cmp	r0, #0
 800bb72:	d158      	bne.n	800bc26 <SD_UltraHighSpeed+0xee>
    {
      return errorstate;
    }

    /* Configure the SD DPSM (Data Path State Machine) */
    sdmmc_datainitstructure.DataTimeOut   = SDMMC_DATATIMEOUT;
 800bb74:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    sdmmc_datainitstructure.DataLength    = 64U;
 800bb78:	e88d 0018 	stmia.w	sp, {r3, r4}
    sdmmc_datainitstructure.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B ;
 800bb7c:	2360      	movs	r3, #96	; 0x60
 800bb7e:	9302      	str	r3, [sp, #8]
    sdmmc_datainitstructure.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
    sdmmc_datainitstructure.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800bb80:	9004      	str	r0, [sp, #16]

    /* Configure the SD DPSM (Data Path State Machine) */
    sdmmc_datainitstructure.DataTimeOut   = SDMMC_DATATIMEOUT;
    sdmmc_datainitstructure.DataLength    = 64U;
    sdmmc_datainitstructure.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B ;
    sdmmc_datainitstructure.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800bb82:	2302      	movs	r3, #2
    sdmmc_datainitstructure.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
    sdmmc_datainitstructure.DPSM          = SDMMC_DPSM_ENABLE;

    if ( SDMMC_ConfigData(hsd->Instance, &sdmmc_datainitstructure) != HAL_OK)
 800bb84:	4669      	mov	r1, sp
 800bb86:	6830      	ldr	r0, [r6, #0]

    /* Configure the SD DPSM (Data Path State Machine) */
    sdmmc_datainitstructure.DataTimeOut   = SDMMC_DATATIMEOUT;
    sdmmc_datainitstructure.DataLength    = 64U;
    sdmmc_datainitstructure.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B ;
    sdmmc_datainitstructure.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800bb88:	9303      	str	r3, [sp, #12]
    sdmmc_datainitstructure.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
    sdmmc_datainitstructure.DPSM          = SDMMC_DPSM_ENABLE;
 800bb8a:	9505      	str	r5, [sp, #20]

    if ( SDMMC_ConfigData(hsd->Instance, &sdmmc_datainitstructure) != HAL_OK)
 800bb8c:	f001 f840 	bl	800cc10 <SDMMC_ConfigData>
 800bb90:	2800      	cmp	r0, #0
 800bb92:	d14a      	bne.n	800bc2a <SD_UltraHighSpeed+0xf2>
    {
      return (HAL_SD_ERROR_GENERAL_UNKNOWN_ERR);
    }

    errorstate = SDMMC_CmdSwitch(hsd->Instance, SDMMC_SDR104_SWITCH_PATTERN);
 800bb94:	4929      	ldr	r1, [pc, #164]	; (800bc3c <SD_UltraHighSpeed+0x104>)
 800bb96:	6830      	ldr	r0, [r6, #0]
 800bb98:	f001 facd 	bl	800d136 <SDMMC_CmdSwitch>
 800bb9c:	4604      	mov	r4, r0
    if(errorstate != HAL_SD_ERROR_NONE)
 800bb9e:	2800      	cmp	r0, #0
 800bba0:	d148      	bne.n	800bc34 <SD_UltraHighSpeed+0xfc>
    {
      return errorstate;
    }

    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND| SDMMC_FLAG_DATAEND ))
 800bba2:	6833      	ldr	r3, [r6, #0]
 800bba4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800bba6:	f240 552a 	movw	r5, #1322	; 0x52a
 800bbaa:	4015      	ands	r5, r2
 800bbac:	b9d5      	cbnz	r5, 800bbe4 <SD_UltraHighSpeed+0xac>
    {
      if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
 800bbae:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800bbb0:	0418      	lsls	r0, r3, #16
 800bbb2:	d50b      	bpl.n	800bbcc <SD_UltraHighSpeed+0x94>
 800bbb4:	ab06      	add	r3, sp, #24
 800bbb6:	eb03 1844 	add.w	r8, r3, r4, lsl #5
      {
        for (count = 0U; count < 8U; count++)
        {
          SD_hs[(8U*loop)+count]  = SDMMC_ReadFIFO(hsd->Instance);
 800bbba:	6830      	ldr	r0, [r6, #0]
 800bbbc:	f000 ffec 	bl	800cb98 <SDMMC_ReadFIFO>
 800bbc0:	f848 0025 	str.w	r0, [r8, r5, lsl #2]

    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND| SDMMC_FLAG_DATAEND ))
    {
      if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
      {
        for (count = 0U; count < 8U; count++)
 800bbc4:	3501      	adds	r5, #1
 800bbc6:	2d08      	cmp	r5, #8
 800bbc8:	d1f7      	bne.n	800bbba <SD_UltraHighSpeed+0x82>
        {
          SD_hs[(8U*loop)+count]  = SDMMC_ReadFIFO(hsd->Instance);
        }
        loop ++;
 800bbca:	3401      	adds	r4, #1
      }

      if((HAL_GetTick()-Timeout) >=  SDMMC_DATATIMEOUT)
 800bbcc:	f7fb fa22 	bl	8007014 <HAL_GetTick>
 800bbd0:	1bc0      	subs	r0, r0, r7
 800bbd2:	3001      	adds	r0, #1
 800bbd4:	d1e5      	bne.n	800bba2 <SD_UltraHighSpeed+0x6a>
      {
        hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
 800bbd6:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
        hsd->State= HAL_SD_STATE_READY;
 800bbda:	2301      	movs	r3, #1
        loop ++;
      }

      if((HAL_GetTick()-Timeout) >=  SDMMC_DATATIMEOUT)
      {
        hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
 800bbdc:	63b4      	str	r4, [r6, #56]	; 0x38
        hsd->State= HAL_SD_STATE_READY;
 800bbde:	f886 3034 	strb.w	r3, [r6, #52]	; 0x34
        return HAL_SD_ERROR_TIMEOUT;
 800bbe2:	e027      	b.n	800bc34 <SD_UltraHighSpeed+0xfc>
      }
    }

    if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 800bbe4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800bbe6:	0711      	lsls	r1, r2, #28
 800bbe8:	d502      	bpl.n	800bbf0 <SD_UltraHighSpeed+0xb8>
    {
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
 800bbea:	2208      	movs	r2, #8
 800bbec:	639a      	str	r2, [r3, #56]	; 0x38
 800bbee:	e018      	b.n	800bc22 <SD_UltraHighSpeed+0xea>

      return errorstate;
    }
    else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800bbf0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800bbf2:	0792      	lsls	r2, r2, #30
 800bbf4:	d501      	bpl.n	800bbfa <SD_UltraHighSpeed+0xc2>
    {
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
 800bbf6:	2402      	movs	r4, #2
 800bbf8:	e004      	b.n	800bc04 <SD_UltraHighSpeed+0xcc>

      errorstate = SDMMC_ERROR_DATA_CRC_FAIL;

      return errorstate;
    }
    else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 800bbfa:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 800bbfc:	f014 0420 	ands.w	r4, r4, #32
 800bc00:	d002      	beq.n	800bc08 <SD_UltraHighSpeed+0xd0>
    {
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
 800bc02:	2420      	movs	r4, #32
 800bc04:	639c      	str	r4, [r3, #56]	; 0x38

      errorstate = SDMMC_ERROR_RX_OVERRUN;

      return errorstate;
 800bc06:	e015      	b.n	800bc34 <SD_UltraHighSpeed+0xfc>
    {
      /* No error flag set */
    }

    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800bc08:	4a0d      	ldr	r2, [pc, #52]	; (800bc40 <SD_UltraHighSpeed+0x108>)
 800bc0a:	639a      	str	r2, [r3, #56]	; 0x38

    /* Test if the switch mode HS is ok */
    if ((((uint8_t*)SD_hs)[13] & 2U) != 2U)
 800bc0c:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
 800bc10:	079b      	lsls	r3, r3, #30
 800bc12:	d50d      	bpl.n	800bc30 <SD_UltraHighSpeed+0xf8>
    else
    {
#if defined (USE_HAL_SD_REGISTER_CALLBACKS) && (USE_HAL_SD_REGISTER_CALLBACKS == 1U)
      hsd->DriveTransceiver_1_8V_Callback(SET);
#else
      HAL_SDEx_DriveTransceiver_1_8V_Callback(SET);
 800bc14:	2001      	movs	r0, #1
 800bc16:	f7fb fa6d 	bl	80070f4 <HAL_SDEx_DriveTransceiver_1_8V_Callback>
 800bc1a:	e00b      	b.n	800bc34 <SD_UltraHighSpeed+0xfc>
  uint32_t Timeout = HAL_GetTick();

  if(hsd->SdCard.CardSpeed == CARD_NORMAL_SPEED)
  {
     /* Standard Speed Card <= 12.5Mhz  */
     return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 800bc1c:	f04f 6480 	mov.w	r4, #67108864	; 0x4000000
 800bc20:	e008      	b.n	800bc34 <SD_UltraHighSpeed+0xfc>
  * @param  hsd SD handle
  * @retval SD Card error state
  */
static uint32_t SD_UltraHighSpeed(SD_HandleTypeDef *hsd)
{
  uint32_t errorstate = HAL_SD_ERROR_NONE;
 800bc22:	2400      	movs	r4, #0
 800bc24:	e006      	b.n	800bc34 <SD_UltraHighSpeed+0xfc>
 800bc26:	4604      	mov	r4, r0
 800bc28:	e004      	b.n	800bc34 <SD_UltraHighSpeed+0xfc>
    sdmmc_datainitstructure.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
    sdmmc_datainitstructure.DPSM          = SDMMC_DPSM_ENABLE;

    if ( SDMMC_ConfigData(hsd->Instance, &sdmmc_datainitstructure) != HAL_OK)
    {
      return (HAL_SD_ERROR_GENERAL_UNKNOWN_ERR);
 800bc2a:	f44f 3480 	mov.w	r4, #65536	; 0x10000
 800bc2e:	e001      	b.n	800bc34 <SD_UltraHighSpeed+0xfc>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);

    /* Test if the switch mode HS is ok */
    if ((((uint8_t*)SD_hs)[13] & 2U) != 2U)
    {
      errorstate = SDMMC_ERROR_UNSUPPORTED_FEATURE;
 800bc30:	f04f 5480 	mov.w	r4, #268435456	; 0x10000000
#endif /* (DLYB_SDMMC1) || (DLYB_SDMMC2) */
    }
  }

  return errorstate;
}
 800bc34:	4620      	mov	r0, r4
 800bc36:	b016      	add	sp, #88	; 0x58
 800bc38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800bc3c:	80ff1f03 	.word	0x80ff1f03
 800bc40:	18000f3a 	.word	0x18000f3a

0800bc44 <HAL_SD_MspInit>:
 800bc44:	4770      	bx	lr

0800bc46 <HAL_SD_MspDeInit>:
 800bc46:	4770      	bx	lr

0800bc48 <HAL_SD_DeInit>:
  * @brief  De-Initializes the SD card.
  * @param  hsd Pointer to SD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_DeInit(SD_HandleTypeDef *hsd)
{
 800bc48:	b510      	push	{r4, lr}
  /* Check the SD handle allocation */
  if(hsd == NULL)
 800bc4a:	4604      	mov	r4, r0
 800bc4c:	b198      	cbz	r0, 800bc76 <HAL_SD_DeInit+0x2e>
  }

  /* Check the parameters */
  assert_param(IS_SDMMC_ALL_INSTANCE(hsd->Instance));

  hsd->State = HAL_SD_STATE_BUSY;
 800bc4e:	2303      	movs	r3, #3
 800bc50:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  /* Desactivate the 1.8V Mode */
  if(hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE)
 800bc54:	6983      	ldr	r3, [r0, #24]
 800bc56:	2b01      	cmp	r3, #1
 800bc58:	d102      	bne.n	800bc60 <HAL_SD_DeInit+0x18>
    {
      hsd->DriveTransceiver_1_8V_Callback = HAL_SDEx_DriveTransceiver_1_8V_Callback;
    }
    hsd->DriveTransceiver_1_8V_Callback(RESET);
#else
    HAL_SDEx_DriveTransceiver_1_8V_Callback(RESET);
 800bc5a:	2000      	movs	r0, #0
 800bc5c:	f7fb fa4a 	bl	80070f4 <HAL_SDEx_DriveTransceiver_1_8V_Callback>
  * @retval None
  */
static void SD_PowerOFF(SD_HandleTypeDef *hsd)
{
  /* Set Power State to OFF */
  (void)SDMMC_PowerState_OFF(hsd->Instance);
 800bc60:	6820      	ldr	r0, [r4, #0]
 800bc62:	f000 ffb1 	bl	800cbc8 <SDMMC_PowerState_OFF>

  /* DeInit the low level hardware */
  hsd->MspDeInitCallback(hsd);
#else
  /* De-Initialize the MSP layer */
  HAL_SD_MspDeInit(hsd);
 800bc66:	4620      	mov	r0, r4
 800bc68:	f7ff ffed 	bl	800bc46 <HAL_SD_MspDeInit>
#endif /* USE_HAL_SD_REGISTER_CALLBACKS */

  hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800bc6c:	2000      	movs	r0, #0
 800bc6e:	63a0      	str	r0, [r4, #56]	; 0x38
  hsd->State = HAL_SD_STATE_RESET;
 800bc70:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34

  return HAL_OK;
 800bc74:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_SD_DeInit(SD_HandleTypeDef *hsd)
{
  /* Check the SD handle allocation */
  if(hsd == NULL)
  {
    return HAL_ERROR;
 800bc76:	2001      	movs	r0, #1

  hsd->ErrorCode = HAL_SD_ERROR_NONE;
  hsd->State = HAL_SD_STATE_RESET;

  return HAL_OK;
}
 800bc78:	bd10      	pop	{r4, pc}
	...

0800bc7c <HAL_SD_ReadBlocks>:
  * @param  NumberOfBlocks Number of SD blocks to read
  * @param  Timeout Specify timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks, uint32_t Timeout)
{
 800bc7c:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
 800bc80:	b086      	sub	sp, #24
 800bc82:	4604      	mov	r4, r0
 800bc84:	460f      	mov	r7, r1
 800bc86:	4616      	mov	r6, r2
 800bc88:	4698      	mov	r8, r3
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 800bc8a:	f7fb f9c3 	bl	8007014 <HAL_GetTick>
 800bc8e:	4681      	mov	r9, r0
  uint32_t count, data, dataremaining;
  uint32_t add = BlockAdd;
  uint8_t *tempbuff = pData;

  if(NULL == pData)
 800bc90:	b91f      	cbnz	r7, 800bc9a <HAL_SD_ReadBlocks+0x1e>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800bc92:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bc94:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 800bc98:	e0c5      	b.n	800be26 <HAL_SD_ReadBlocks+0x1aa>
    return HAL_ERROR;
  }

  if(hsd->State == HAL_SD_STATE_READY)
 800bc9a:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 800bc9e:	b2c0      	uxtb	r0, r0
 800bca0:	2801      	cmp	r0, #1
 800bca2:	f040 80bd 	bne.w	800be20 <HAL_SD_ReadBlocks+0x1a4>
  {
    hsd->ErrorCode = HAL_SD_ERROR_NONE;

    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800bca6:	6d62      	ldr	r2, [r4, #84]	; 0x54
 800bca8:	eb06 0308 	add.w	r3, r6, r8
    return HAL_ERROR;
  }

  if(hsd->State == HAL_SD_STATE_READY)
  {
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800bcac:	2100      	movs	r1, #0

    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800bcae:	4293      	cmp	r3, r2
    return HAL_ERROR;
  }

  if(hsd->State == HAL_SD_STATE_READY)
  {
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800bcb0:	63a1      	str	r1, [r4, #56]	; 0x38

    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800bcb2:	d904      	bls.n	800bcbe <HAL_SD_ReadBlocks+0x42>
    {
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 800bcb4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bcb6:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800bcba:	63a3      	str	r3, [r4, #56]	; 0x38
      return HAL_ERROR;
 800bcbc:	e0b5      	b.n	800be2a <HAL_SD_ReadBlocks+0x1ae>
    }

    hsd->State = HAL_SD_STATE_BUSY;
 800bcbe:	2303      	movs	r3, #3
 800bcc0:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;

    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 800bcc4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    }

    hsd->State = HAL_SD_STATE_BUSY;

    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;
 800bcc6:	6820      	ldr	r0, [r4, #0]

    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 800bcc8:	2b01      	cmp	r3, #1
    {
      add *= 512U;
    }

    /* Configure the SD DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800bcca:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800bcce:	9300      	str	r3, [sp, #0]
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
 800bcd0:	ea4f 2348 	mov.w	r3, r8, lsl #9
 800bcd4:	9301      	str	r3, [sp, #4]
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 800bcd6:	f04f 0390 	mov.w	r3, #144	; 0x90
    }

    hsd->State = HAL_SD_STATE_BUSY;

    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;
 800bcda:	62c1      	str	r1, [r0, #44]	; 0x2c
    }

    /* Configure the SD DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 800bcdc:	9302      	str	r3, [sp, #8]
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800bcde:	f04f 0502 	mov.w	r5, #2
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800bce2:	f04f 0300 	mov.w	r3, #0
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    config.DPSM          = SDMMC_DPSM_DISABLE;
#else
    config.DPSM          = SDMMC_DPSM_ENABLE;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 800bce6:	4669      	mov	r1, sp
    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;

    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
    {
      add *= 512U;
 800bce8:	bf18      	it	ne
 800bcea:	0276      	lslne	r6, r6, #9
    /* Configure the SD DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800bcec:	9304      	str	r3, [sp, #16]
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    config.DPSM          = SDMMC_DPSM_DISABLE;
 800bcee:	9305      	str	r3, [sp, #20]

    /* Configure the SD DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800bcf0:	9503      	str	r5, [sp, #12]
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    config.DPSM          = SDMMC_DPSM_DISABLE;
#else
    config.DPSM          = SDMMC_DPSM_ENABLE;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 800bcf2:	f000 ff8d 	bl	800cc10 <SDMMC_ConfigData>
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
 800bcf6:	6820      	ldr	r0, [r4, #0]
 800bcf8:	68c3      	ldr	r3, [r0, #12]
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

    /* Read block(s) in polling mode */
    if(NumberOfBlocks > 1U)
 800bcfa:	f1b8 0f01 	cmp.w	r8, #1
#else
    config.DPSM          = SDMMC_DPSM_ENABLE;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
    (void)SDMMC_ConfigData(hsd->Instance, &config);
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
 800bcfe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800bd02:	60c3      	str	r3, [r0, #12]
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

    /* Read block(s) in polling mode */
    if(NumberOfBlocks > 1U)
 800bd04:	d904      	bls.n	800bd10 <HAL_SD_ReadBlocks+0x94>
    {
      hsd->Context = SD_CONTEXT_READ_MULTIPLE_BLOCK;
 800bd06:	6325      	str	r5, [r4, #48]	; 0x30

      /* Read Multi Block command */
      errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
 800bd08:	4631      	mov	r1, r6
 800bd0a:	f001 f88f 	bl	800ce2c <SDMMC_CmdReadMultiBlock>
 800bd0e:	e004      	b.n	800bd1a <HAL_SD_ReadBlocks+0x9e>
    }
    else
    {
      hsd->Context = SD_CONTEXT_READ_SINGLE_BLOCK;
 800bd10:	2301      	movs	r3, #1
 800bd12:	6323      	str	r3, [r4, #48]	; 0x30

      /* Read Single Block command */
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
 800bd14:	4631      	mov	r1, r6
 800bd16:	f001 f870 	bl	800cdfa <SDMMC_CmdReadSingleBlock>
    }
    if(errorstate != HAL_SD_ERROR_NONE)
 800bd1a:	2800      	cmp	r0, #0
 800bd1c:	d144      	bne.n	800bda8 <HAL_SD_ReadBlocks+0x12c>
      hsd->Context = SD_CONTEXT_NONE;
      return HAL_ERROR;
    }

    /* Poll on SDMMC flags */
    dataremaining = config.DataLength;
 800bd1e:	9d01      	ldr	r5, [sp, #4]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 800bd20:	6820      	ldr	r0, [r4, #0]
 800bd22:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800bd24:	f413 7f95 	tst.w	r3, #298	; 0x12a
 800bd28:	d12e      	bne.n	800bd88 <HAL_SD_ReadBlocks+0x10c>
    {
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF) && (dataremaining > 0U))
 800bd2a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800bd2c:	041a      	lsls	r2, r3, #16
 800bd2e:	d516      	bpl.n	800bd5e <HAL_SD_ReadBlocks+0xe2>
 800bd30:	b1ad      	cbz	r5, 800bd5e <HAL_SD_ReadBlocks+0xe2>
 800bd32:	1d3e      	adds	r6, r7, #4
 800bd34:	f107 0b24 	add.w	fp, r7, #36	; 0x24
      {
        /* Read data from SDMMC Rx FIFO */
        for(count = 0U; count < 8U; count++)
        {
          data = SDMMC_ReadFIFO(hsd->Instance);
 800bd38:	6820      	ldr	r0, [r4, #0]
 800bd3a:	f000 ff2d 	bl	800cb98 <SDMMC_ReadFIFO>
          *tempbuff = (uint8_t)(data & 0xFFU);
          tempbuff++;
          dataremaining--;
          *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
 800bd3e:	0a03      	lsrs	r3, r0, #8
      {
        /* Read data from SDMMC Rx FIFO */
        for(count = 0U; count < 8U; count++)
        {
          data = SDMMC_ReadFIFO(hsd->Instance);
          *tempbuff = (uint8_t)(data & 0xFFU);
 800bd40:	f806 0c04 	strb.w	r0, [r6, #-4]
          tempbuff++;
          dataremaining--;
          *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
 800bd44:	f806 3c03 	strb.w	r3, [r6, #-3]
          tempbuff++;
          dataremaining--;
          *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
 800bd48:	0c03      	lsrs	r3, r0, #16
          tempbuff++;
          dataremaining--;
          *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
 800bd4a:	0e00      	lsrs	r0, r0, #24
          tempbuff++;
          dataremaining--;
          *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
          tempbuff++;
          dataremaining--;
          *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
 800bd4c:	f806 3c02 	strb.w	r3, [r6, #-2]
          tempbuff++;
          dataremaining--;
          *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
 800bd50:	f806 0c01 	strb.w	r0, [r6, #-1]
 800bd54:	3604      	adds	r6, #4
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
    {
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF) && (dataremaining > 0U))
      {
        /* Read data from SDMMC Rx FIFO */
        for(count = 0U; count < 8U; count++)
 800bd56:	45b3      	cmp	fp, r6
 800bd58:	d1ee      	bne.n	800bd38 <HAL_SD_ReadBlocks+0xbc>
 800bd5a:	3720      	adds	r7, #32
 800bd5c:	3d20      	subs	r5, #32
          tempbuff++;
          dataremaining--;
        }
      }

      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
 800bd5e:	f7fb f959 	bl	8007014 <HAL_GetTick>
 800bd62:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800bd64:	ebc9 0000 	rsb	r0, r9, r0
 800bd68:	4298      	cmp	r0, r3
 800bd6a:	d3d9      	bcc.n	800bd20 <HAL_SD_ReadBlocks+0xa4>
      {
        /* Clear all the static flags */
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bd6c:	6823      	ldr	r3, [r4, #0]
 800bd6e:	4a30      	ldr	r2, [pc, #192]	; (800be30 <HAL_SD_ReadBlocks+0x1b4>)
 800bd70:	639a      	str	r2, [r3, #56]	; 0x38
        hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
 800bd72:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bd74:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800bd78:	63a3      	str	r3, [r4, #56]	; 0x38
        hsd->State= HAL_SD_STATE_READY;
 800bd7a:	2301      	movs	r3, #1
 800bd7c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
 800bd80:	2300      	movs	r3, #0
 800bd82:	6323      	str	r3, [r4, #48]	; 0x30
        return HAL_TIMEOUT;
 800bd84:	2003      	movs	r0, #3
 800bd86:	e050      	b.n	800be2a <HAL_SD_ReadBlocks+0x1ae>
      }
    }
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    __SDMMC_CMDTRANS_DISABLE( hsd->Instance);
 800bd88:	68c3      	ldr	r3, [r0, #12]
 800bd8a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800bd8e:	60c3      	str	r3, [r0, #12]
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

    /* Send stop transmission command in case of multiblock read */
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 800bd90:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800bd92:	05db      	lsls	r3, r3, #23
 800bd94:	d50f      	bpl.n	800bdb6 <HAL_SD_ReadBlocks+0x13a>
 800bd96:	f1b8 0f01 	cmp.w	r8, #1
 800bd9a:	d90c      	bls.n	800bdb6 <HAL_SD_ReadBlocks+0x13a>
    {
      if(hsd->SdCard.CardType != CARD_SECURED)
 800bd9c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800bd9e:	2b03      	cmp	r3, #3
 800bda0:	d009      	beq.n	800bdb6 <HAL_SD_ReadBlocks+0x13a>
      {
        /* Send stop transmission command */
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 800bda2:	f001 f90b 	bl	800cfbc <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
 800bda6:	b130      	cbz	r0, 800bdb6 <HAL_SD_ReadBlocks+0x13a>
        {
          /* Clear all the static flags */
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bda8:	6823      	ldr	r3, [r4, #0]
 800bdaa:	4a21      	ldr	r2, [pc, #132]	; (800be30 <HAL_SD_ReadBlocks+0x1b4>)
 800bdac:	639a      	str	r2, [r3, #56]	; 0x38
          hsd->ErrorCode |= errorstate;
 800bdae:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bdb0:	4318      	orrs	r0, r3
 800bdb2:	63a0      	str	r0, [r4, #56]	; 0x38
 800bdb4:	e00a      	b.n	800bdcc <HAL_SD_ReadBlocks+0x150>
        }
      }
    }

    /* Get error state */
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 800bdb6:	6823      	ldr	r3, [r4, #0]
 800bdb8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800bdba:	f012 0108 	ands.w	r1, r2, #8
 800bdbe:	d00b      	beq.n	800bdd8 <HAL_SD_ReadBlocks+0x15c>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bdc0:	4a1b      	ldr	r2, [pc, #108]	; (800be30 <HAL_SD_ReadBlocks+0x1b4>)
 800bdc2:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
 800bdc4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bdc6:	f043 0308 	orr.w	r3, r3, #8
 800bdca:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800bdcc:	2001      	movs	r0, #1
      hsd->Context = SD_CONTEXT_NONE;
 800bdce:	2300      	movs	r3, #0
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
      hsd->State = HAL_SD_STATE_READY;
 800bdd0:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800bdd4:	6323      	str	r3, [r4, #48]	; 0x30
      return HAL_ERROR;
 800bdd6:	e028      	b.n	800be2a <HAL_SD_ReadBlocks+0x1ae>
    }
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800bdd8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800bdda:	f012 0202 	ands.w	r2, r2, #2
 800bdde:	d00a      	beq.n	800bdf6 <HAL_SD_ReadBlocks+0x17a>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bde0:	4a13      	ldr	r2, [pc, #76]	; (800be30 <HAL_SD_ReadBlocks+0x1b4>)
 800bde2:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 800bde4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800bde6:	2001      	movs	r0, #1
    }
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 800bde8:	f043 0302 	orr.w	r3, r3, #2
 800bdec:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800bdee:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800bdf2:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
 800bdf4:	e019      	b.n	800be2a <HAL_SD_ReadBlocks+0x1ae>
    }
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 800bdf6:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800bdf8:	f010 0020 	ands.w	r0, r0, #32
 800bdfc:	d00a      	beq.n	800be14 <HAL_SD_ReadBlocks+0x198>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bdfe:	490c      	ldr	r1, [pc, #48]	; (800be30 <HAL_SD_ReadBlocks+0x1b4>)
 800be00:	6399      	str	r1, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
 800be02:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800be04:	2001      	movs	r0, #1
    }
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
 800be06:	f043 0320 	orr.w	r3, r3, #32
 800be0a:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800be0c:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800be10:	6322      	str	r2, [r4, #48]	; 0x30
      return HAL_ERROR;
 800be12:	e00a      	b.n	800be2a <HAL_SD_ReadBlocks+0x1ae>
      }
    }
#endif /* !STM32L4P5xx && !STM32L4Q5xx && !STM32L4R5xx && !STM32L4R7xx && !STM32L4R9xx && !STM32L4S5xx && !STM32L4S7xx && !STM32L4S9xx */

    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800be14:	4a07      	ldr	r2, [pc, #28]	; (800be34 <HAL_SD_ReadBlocks+0x1b8>)
 800be16:	639a      	str	r2, [r3, #56]	; 0x38

    hsd->State = HAL_SD_STATE_READY;
 800be18:	2301      	movs	r3, #1
 800be1a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

    return HAL_OK;
 800be1e:	e004      	b.n	800be2a <HAL_SD_ReadBlocks+0x1ae>
  }
  else
  {
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
 800be20:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800be22:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800be26:	63a3      	str	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
 800be28:	2001      	movs	r0, #1
  }
}
 800be2a:	b006      	add	sp, #24
 800be2c:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
 800be30:	1fe00fff 	.word	0x1fe00fff
 800be34:	18000f3a 	.word	0x18000f3a

0800be38 <HAL_SD_WriteBlocks>:
  * @param  NumberOfBlocks Number of SD blocks to write
  * @param  Timeout Specify timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_WriteBlocks(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks, uint32_t Timeout)
{
 800be38:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800be3c:	b088      	sub	sp, #32
 800be3e:	4604      	mov	r4, r0
 800be40:	460e      	mov	r6, r1
 800be42:	4691      	mov	r9, r2
 800be44:	461f      	mov	r7, r3
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 800be46:	f7fb f8e5 	bl	8007014 <HAL_GetTick>
 800be4a:	4680      	mov	r8, r0
  uint32_t count, data, dataremaining;
  uint32_t add = BlockAdd;
  uint8_t *tempbuff = pData;

  if(NULL == pData)
 800be4c:	b91e      	cbnz	r6, 800be56 <HAL_SD_WriteBlocks+0x1e>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800be4e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800be50:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 800be54:	e0b7      	b.n	800bfc6 <HAL_SD_WriteBlocks+0x18e>
    return HAL_ERROR;
  }

  if(hsd->State == HAL_SD_STATE_READY)
 800be56:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 800be5a:	b2c0      	uxtb	r0, r0
 800be5c:	2801      	cmp	r0, #1
 800be5e:	f040 80af 	bne.w	800bfc0 <HAL_SD_WriteBlocks+0x188>
  {
    hsd->ErrorCode = HAL_SD_ERROR_NONE;

    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800be62:	6d62      	ldr	r2, [r4, #84]	; 0x54
 800be64:	eb09 0307 	add.w	r3, r9, r7
    return HAL_ERROR;
  }

  if(hsd->State == HAL_SD_STATE_READY)
  {
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800be68:	2100      	movs	r1, #0

    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800be6a:	4293      	cmp	r3, r2
    return HAL_ERROR;
  }

  if(hsd->State == HAL_SD_STATE_READY)
  {
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800be6c:	63a1      	str	r1, [r4, #56]	; 0x38

    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800be6e:	d904      	bls.n	800be7a <HAL_SD_WriteBlocks+0x42>
    {
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 800be70:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800be72:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800be76:	63a3      	str	r3, [r4, #56]	; 0x38
      return HAL_ERROR;
 800be78:	e0a7      	b.n	800bfca <HAL_SD_WriteBlocks+0x192>
    }

    hsd->State = HAL_SD_STATE_BUSY;
 800be7a:	2303      	movs	r3, #3
 800be7c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;

    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 800be80:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    }

    hsd->State = HAL_SD_STATE_BUSY;

    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;
 800be82:	6820      	ldr	r0, [r4, #0]

    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 800be84:	2b01      	cmp	r3, #1
    {
      add *= 512U;
    }

    /* Configure the SD DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800be86:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800be8a:	9302      	str	r3, [sp, #8]
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
 800be8c:	ea4f 2347 	mov.w	r3, r7, lsl #9
 800be90:	9303      	str	r3, [sp, #12]
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 800be92:	f04f 0390 	mov.w	r3, #144	; 0x90
    }

    hsd->State = HAL_SD_STATE_BUSY;

    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;
 800be96:	62c1      	str	r1, [r0, #44]	; 0x2c
    }

    /* Configure the SD DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 800be98:	9304      	str	r3, [sp, #16]
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    config.DPSM          = SDMMC_DPSM_DISABLE;
#else
    config.DPSM          = SDMMC_DPSM_ENABLE;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 800be9a:	a902      	add	r1, sp, #8

    /* Configure the SD DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
 800be9c:	f04f 0300 	mov.w	r3, #0
    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;

    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
    {
      add *= 512U;
 800bea0:	bf18      	it	ne
 800bea2:	ea4f 2949 	movne.w	r9, r9, lsl #9

    /* Configure the SD DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
 800bea6:	9305      	str	r3, [sp, #20]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800bea8:	9306      	str	r3, [sp, #24]
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    config.DPSM          = SDMMC_DPSM_DISABLE;
 800beaa:	9307      	str	r3, [sp, #28]
#else
    config.DPSM          = SDMMC_DPSM_ENABLE;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 800beac:	f000 feb0 	bl	800cc10 <SDMMC_ConfigData>
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
 800beb0:	6820      	ldr	r0, [r4, #0]
 800beb2:	68c3      	ldr	r3, [r0, #12]
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

    /* Write Blocks in Polling mode */
    if(NumberOfBlocks > 1U)
 800beb4:	2f01      	cmp	r7, #1
#else
    config.DPSM          = SDMMC_DPSM_ENABLE;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
    (void)SDMMC_ConfigData(hsd->Instance, &config);
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
 800beb6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800beba:	60c3      	str	r3, [r0, #12]
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

    /* Write Blocks in Polling mode */
    if(NumberOfBlocks > 1U)
 800bebc:	d905      	bls.n	800beca <HAL_SD_WriteBlocks+0x92>
    {
      hsd->Context = SD_CONTEXT_WRITE_MULTIPLE_BLOCK;
 800bebe:	2320      	movs	r3, #32
 800bec0:	6323      	str	r3, [r4, #48]	; 0x30

      /* Write Multi Block command */
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
 800bec2:	4649      	mov	r1, r9
 800bec4:	f000 ffe4 	bl	800ce90 <SDMMC_CmdWriteMultiBlock>
 800bec8:	e004      	b.n	800bed4 <HAL_SD_WriteBlocks+0x9c>
    }
    else
    {
      hsd->Context = SD_CONTEXT_WRITE_SINGLE_BLOCK;
 800beca:	2310      	movs	r3, #16
 800becc:	6323      	str	r3, [r4, #48]	; 0x30

      /* Write Single Block command */
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
 800bece:	4649      	mov	r1, r9
 800bed0:	f000 ffc5 	bl	800ce5e <SDMMC_CmdWriteSingleBlock>
    }
    if(errorstate != HAL_SD_ERROR_NONE)
 800bed4:	2800      	cmp	r0, #0
 800bed6:	d137      	bne.n	800bf48 <HAL_SD_WriteBlocks+0x110>
      hsd->Context = SD_CONTEXT_NONE;
      return HAL_ERROR;
    }

    /* Write block(s) in polling mode */
    dataremaining = config.DataLength;
 800bed8:	9d03      	ldr	r5, [sp, #12]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 800beda:	6820      	ldr	r0, [r4, #0]
 800bedc:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800bede:	f413 7f8d 	tst.w	r3, #282	; 0x11a
 800bee2:	d122      	bne.n	800bf2a <HAL_SD_WriteBlocks+0xf2>
    {
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE) && (dataremaining > 0U))
 800bee4:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800bee6:	045a      	lsls	r2, r3, #17
 800bee8:	d50c      	bpl.n	800bf04 <HAL_SD_WriteBlocks+0xcc>
 800beea:	b15d      	cbz	r5, 800bf04 <HAL_SD_WriteBlocks+0xcc>
 800beec:	f106 0a20 	add.w	sl, r6, #32
          tempbuff++;
          dataremaining--;
          data |= ((uint32_t)(*tempbuff) << 16U);
          tempbuff++;
          dataremaining--;
          data |= ((uint32_t)(*tempbuff) << 24U);
 800bef0:	f856 3b04 	ldr.w	r3, [r6], #4
          tempbuff++;
          dataremaining--;
          (void)SDMMC_WriteFIFO(hsd->Instance, &data);
 800bef4:	6820      	ldr	r0, [r4, #0]
          tempbuff++;
          dataremaining--;
          data |= ((uint32_t)(*tempbuff) << 16U);
          tempbuff++;
          dataremaining--;
          data |= ((uint32_t)(*tempbuff) << 24U);
 800bef6:	9301      	str	r3, [sp, #4]
          tempbuff++;
          dataremaining--;
          (void)SDMMC_WriteFIFO(hsd->Instance, &data);
 800bef8:	a901      	add	r1, sp, #4
 800befa:	f000 fe50 	bl	800cb9e <SDMMC_WriteFIFO>
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
    {
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE) && (dataremaining > 0U))
      {
        /* Write data to SDMMC Tx FIFO */
        for(count = 0U; count < 8U; count++)
 800befe:	45b2      	cmp	sl, r6
 800bf00:	d1f6      	bne.n	800bef0 <HAL_SD_WriteBlocks+0xb8>
 800bf02:	3d20      	subs	r5, #32
          dataremaining--;
          (void)SDMMC_WriteFIFO(hsd->Instance, &data);
        }
      }

      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
 800bf04:	f7fb f886 	bl	8007014 <HAL_GetTick>
 800bf08:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800bf0a:	ebc8 0000 	rsb	r0, r8, r0
 800bf0e:	4298      	cmp	r0, r3
 800bf10:	d3e3      	bcc.n	800beda <HAL_SD_WriteBlocks+0xa2>
      {
        /* Clear all the static flags */
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bf12:	6823      	ldr	r3, [r4, #0]
 800bf14:	4a2e      	ldr	r2, [pc, #184]	; (800bfd0 <HAL_SD_WriteBlocks+0x198>)
 800bf16:	639a      	str	r2, [r3, #56]	; 0x38
        hsd->ErrorCode |= errorstate;
 800bf18:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bf1a:	63a3      	str	r3, [r4, #56]	; 0x38
        hsd->State = HAL_SD_STATE_READY;
 800bf1c:	2301      	movs	r3, #1
 800bf1e:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
 800bf22:	2300      	movs	r3, #0
 800bf24:	6323      	str	r3, [r4, #48]	; 0x30
        return HAL_TIMEOUT;
 800bf26:	2003      	movs	r0, #3
 800bf28:	e04f      	b.n	800bfca <HAL_SD_WriteBlocks+0x192>
      }
    }
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    __SDMMC_CMDTRANS_DISABLE( hsd->Instance);
 800bf2a:	68c3      	ldr	r3, [r0, #12]
 800bf2c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800bf30:	60c3      	str	r3, [r0, #12]
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

    /* Send stop transmission command in case of multiblock write */
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 800bf32:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800bf34:	05db      	lsls	r3, r3, #23
 800bf36:	d50e      	bpl.n	800bf56 <HAL_SD_WriteBlocks+0x11e>
 800bf38:	2f01      	cmp	r7, #1
 800bf3a:	d90c      	bls.n	800bf56 <HAL_SD_WriteBlocks+0x11e>
    {
      if(hsd->SdCard.CardType != CARD_SECURED)
 800bf3c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800bf3e:	2b03      	cmp	r3, #3
 800bf40:	d009      	beq.n	800bf56 <HAL_SD_WriteBlocks+0x11e>
      {
        /* Send stop transmission command */
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 800bf42:	f001 f83b 	bl	800cfbc <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
 800bf46:	b130      	cbz	r0, 800bf56 <HAL_SD_WriteBlocks+0x11e>
        {
          /* Clear all the static flags */
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bf48:	6823      	ldr	r3, [r4, #0]
 800bf4a:	4a21      	ldr	r2, [pc, #132]	; (800bfd0 <HAL_SD_WriteBlocks+0x198>)
 800bf4c:	639a      	str	r2, [r3, #56]	; 0x38
          hsd->ErrorCode |= errorstate;
 800bf4e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bf50:	4318      	orrs	r0, r3
 800bf52:	63a0      	str	r0, [r4, #56]	; 0x38
 800bf54:	e00a      	b.n	800bf6c <HAL_SD_WriteBlocks+0x134>
        }
      }
    }

    /* Get error state */
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 800bf56:	6823      	ldr	r3, [r4, #0]
 800bf58:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800bf5a:	f012 0108 	ands.w	r1, r2, #8
 800bf5e:	d00b      	beq.n	800bf78 <HAL_SD_WriteBlocks+0x140>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bf60:	4a1b      	ldr	r2, [pc, #108]	; (800bfd0 <HAL_SD_WriteBlocks+0x198>)
 800bf62:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
 800bf64:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bf66:	f043 0308 	orr.w	r3, r3, #8
 800bf6a:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800bf6c:	2001      	movs	r0, #1
      hsd->Context = SD_CONTEXT_NONE;
 800bf6e:	2300      	movs	r3, #0
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
      hsd->State = HAL_SD_STATE_READY;
 800bf70:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800bf74:	6323      	str	r3, [r4, #48]	; 0x30
      return HAL_ERROR;
 800bf76:	e028      	b.n	800bfca <HAL_SD_WriteBlocks+0x192>
    }
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800bf78:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800bf7a:	f012 0202 	ands.w	r2, r2, #2
 800bf7e:	d00a      	beq.n	800bf96 <HAL_SD_WriteBlocks+0x15e>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bf80:	4a13      	ldr	r2, [pc, #76]	; (800bfd0 <HAL_SD_WriteBlocks+0x198>)
 800bf82:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 800bf84:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800bf86:	2001      	movs	r0, #1
    }
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 800bf88:	f043 0302 	orr.w	r3, r3, #2
 800bf8c:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800bf8e:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800bf92:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
 800bf94:	e019      	b.n	800bfca <HAL_SD_WriteBlocks+0x192>
    }
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR))
 800bf96:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800bf98:	f010 0010 	ands.w	r0, r0, #16
 800bf9c:	d00a      	beq.n	800bfb4 <HAL_SD_WriteBlocks+0x17c>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bf9e:	490c      	ldr	r1, [pc, #48]	; (800bfd0 <HAL_SD_WriteBlocks+0x198>)
 800bfa0:	6399      	str	r1, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
 800bfa2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800bfa4:	2001      	movs	r0, #1
    }
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR))
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
 800bfa6:	f043 0310 	orr.w	r3, r3, #16
 800bfaa:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800bfac:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800bfb0:	6322      	str	r2, [r4, #48]	; 0x30
      return HAL_ERROR;
 800bfb2:	e00a      	b.n	800bfca <HAL_SD_WriteBlocks+0x192>
    {
      /* Nothing to do */
    }

    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800bfb4:	4a07      	ldr	r2, [pc, #28]	; (800bfd4 <HAL_SD_WriteBlocks+0x19c>)
 800bfb6:	639a      	str	r2, [r3, #56]	; 0x38

    hsd->State = HAL_SD_STATE_READY;
 800bfb8:	2301      	movs	r3, #1
 800bfba:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

    return HAL_OK;
 800bfbe:	e004      	b.n	800bfca <HAL_SD_WriteBlocks+0x192>
  }
  else
  {
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
 800bfc0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bfc2:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800bfc6:	63a3      	str	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
 800bfc8:	2001      	movs	r0, #1
  }
}
 800bfca:	b008      	add	sp, #32
 800bfcc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800bfd0:	1fe00fff 	.word	0x1fe00fff
 800bfd4:	18000f3a 	.word	0x18000f3a

0800bfd8 <HAL_SD_GetState>:
  * @param hsd Pointer to sd handle
  * @retval HAL state
  */
HAL_SD_StateTypeDef HAL_SD_GetState(SD_HandleTypeDef *hsd)
{
  return hsd->State;
 800bfd8:	f890 0034 	ldrb.w	r0, [r0, #52]	; 0x34
}
 800bfdc:	4770      	bx	lr

0800bfde <HAL_SD_GetError>:
  *              the configuration information.
* @retval SD Error Code
*/
uint32_t HAL_SD_GetError(SD_HandleTypeDef *hsd)
{
  return hsd->ErrorCode;
 800bfde:	6b80      	ldr	r0, [r0, #56]	; 0x38
}
 800bfe0:	4770      	bx	lr

0800bfe2 <HAL_SD_TxCpltCallback>:
 800bfe2:	4770      	bx	lr

0800bfe4 <HAL_SD_RxCpltCallback>:
 800bfe4:	4770      	bx	lr

0800bfe6 <HAL_SD_ErrorCallback>:
 800bfe6:	4770      	bx	lr

0800bfe8 <HAL_SD_AbortCallback>:
  * @brief SD Abort callbacks
  * @param hsd Pointer SD handle
  * @retval None
  */
__weak void HAL_SD_AbortCallback(SD_HandleTypeDef *hsd)
{
 800bfe8:	4770      	bx	lr
	...

0800bfec <HAL_SD_GetCardCSD>:
  *         contains all CSD register parameters
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_GetCardCSD(SD_HandleTypeDef *hsd, HAL_SD_CardCSDTypeDef *pCSD)
{
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
 800bfec:	6e03      	ldr	r3, [r0, #96]	; 0x60
 800bfee:	0f9b      	lsrs	r3, r3, #30
 800bff0:	700b      	strb	r3, [r1, #0]

  pCSD->SysSpecVersion = (uint8_t)((hsd->CSD[0] & 0x3C000000U) >> 26U);
 800bff2:	6e03      	ldr	r3, [r0, #96]	; 0x60
 800bff4:	f3c3 6383 	ubfx	r3, r3, #26, #4
 800bff8:	704b      	strb	r3, [r1, #1]

  pCSD->Reserved1 = (uint8_t)((hsd->CSD[0] & 0x03000000U) >> 24U);
 800bffa:	f890 3063 	ldrb.w	r3, [r0, #99]	; 0x63
 800bffe:	f003 0303 	and.w	r3, r3, #3
 800c002:	708b      	strb	r3, [r1, #2]

  pCSD->TAAC = (uint8_t)((hsd->CSD[0] & 0x00FF0000U) >> 16U);
 800c004:	f890 3062 	ldrb.w	r3, [r0, #98]	; 0x62
 800c008:	70cb      	strb	r3, [r1, #3]

  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
 800c00a:	f890 3061 	ldrb.w	r3, [r0, #97]	; 0x61
 800c00e:	710b      	strb	r3, [r1, #4]

  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
 800c010:	f890 3060 	ldrb.w	r3, [r0, #96]	; 0x60
 800c014:	714b      	strb	r3, [r1, #5]

  pCSD->CardComdClasses = (uint16_t)((hsd->CSD[1] & 0xFFF00000U) >> 20U);
 800c016:	6e43      	ldr	r3, [r0, #100]	; 0x64
 800c018:	0d1a      	lsrs	r2, r3, #20

  pCSD->RdBlockLen = (uint8_t)((hsd->CSD[1] & 0x000F0000U) >> 16U);
 800c01a:	f3c3 4303 	ubfx	r3, r3, #16, #4

  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);

  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);

  pCSD->CardComdClasses = (uint16_t)((hsd->CSD[1] & 0xFFF00000U) >> 20U);
 800c01e:	80ca      	strh	r2, [r1, #6]

  pCSD->RdBlockLen = (uint8_t)((hsd->CSD[1] & 0x000F0000U) >> 16U);
 800c020:	720b      	strb	r3, [r1, #8]

  pCSD->PartBlockRead   = (uint8_t)((hsd->CSD[1] & 0x00008000U) >> 15U);
 800c022:	6e43      	ldr	r3, [r0, #100]	; 0x64
 800c024:	f3c3 33c0 	ubfx	r3, r3, #15, #1
 800c028:	724b      	strb	r3, [r1, #9]

  pCSD->WrBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00004000U) >> 14U);
 800c02a:	6e43      	ldr	r3, [r0, #100]	; 0x64
 800c02c:	f3c3 3380 	ubfx	r3, r3, #14, #1
 800c030:	728b      	strb	r3, [r1, #10]

  pCSD->RdBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00002000U) >> 13U);
 800c032:	6e43      	ldr	r3, [r0, #100]	; 0x64
 800c034:	f3c3 3340 	ubfx	r3, r3, #13, #1
 800c038:	72cb      	strb	r3, [r1, #11]

  pCSD->DSRImpl = (uint8_t)((hsd->CSD[1] & 0x00001000U) >> 12U);
 800c03a:	6e43      	ldr	r3, [r0, #100]	; 0x64
 800c03c:	f3c3 3300 	ubfx	r3, r3, #12, #1
 800c040:	730b      	strb	r3, [r1, #12]

  pCSD->Reserved2 = 0U; /*!< Reserved */
 800c042:	2300      	movs	r3, #0
 800c044:	734b      	strb	r3, [r1, #13]

  if(hsd->SdCard.CardType == CARD_SDSC)
 800c046:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
  * @param  pCSD Pointer to a HAL_SD_CardCSDTypeDef structure that
  *         contains all CSD register parameters
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_GetCardCSD(SD_HandleTypeDef *hsd, HAL_SD_CardCSDTypeDef *pCSD)
{
 800c048:	b510      	push	{r4, lr}

  pCSD->DSRImpl = (uint8_t)((hsd->CSD[1] & 0x00001000U) >> 12U);

  pCSD->Reserved2 = 0U; /*!< Reserved */

  if(hsd->SdCard.CardType == CARD_SDSC)
 800c04a:	2b00      	cmp	r3, #0
 800c04c:	d134      	bne.n	800c0b8 <HAL_SD_GetCardCSD+0xcc>
  {
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
 800c04e:	6e43      	ldr	r3, [r0, #100]	; 0x64
 800c050:	6e82      	ldr	r2, [r0, #104]	; 0x68
 800c052:	009c      	lsls	r4, r3, #2
 800c054:	f640 73fc 	movw	r3, #4092	; 0xffc
 800c058:	4023      	ands	r3, r4
 800c05a:	ea43 7392 	orr.w	r3, r3, r2, lsr #30

    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
 800c05e:	f3c2 62c2 	ubfx	r2, r2, #27, #3

  pCSD->Reserved2 = 0U; /*!< Reserved */

  if(hsd->SdCard.CardType == CARD_SDSC)
  {
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
 800c062:	610b      	str	r3, [r1, #16]

    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
 800c064:	750a      	strb	r2, [r1, #20]

    pCSD->MaxRdCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x07000000U) >> 24U);
 800c066:	f890 306b 	ldrb.w	r3, [r0, #107]	; 0x6b
 800c06a:	f003 0307 	and.w	r3, r3, #7
 800c06e:	754b      	strb	r3, [r1, #21]

    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x00E00000U) >> 21U);
 800c070:	6e83      	ldr	r3, [r0, #104]	; 0x68
 800c072:	f3c3 5342 	ubfx	r3, r3, #21, #3
 800c076:	758b      	strb	r3, [r1, #22]

    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
 800c078:	6e83      	ldr	r3, [r0, #104]	; 0x68
 800c07a:	f3c3 4382 	ubfx	r3, r3, #18, #3
 800c07e:	75cb      	strb	r3, [r1, #23]

    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
 800c080:	6e83      	ldr	r3, [r0, #104]	; 0x68
 800c082:	f3c3 33c2 	ubfx	r3, r3, #15, #3
 800c086:	760b      	strb	r3, [r1, #24]

    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
 800c088:	690b      	ldr	r3, [r1, #16]
 800c08a:	1c5a      	adds	r2, r3, #1
 800c08c:	64c2      	str	r2, [r0, #76]	; 0x4c
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
 800c08e:	7e0b      	ldrb	r3, [r1, #24]
 800c090:	f003 0307 	and.w	r3, r3, #7
 800c094:	2401      	movs	r4, #1
 800c096:	3302      	adds	r3, #2
 800c098:	fa04 f303 	lsl.w	r3, r4, r3
 800c09c:	4353      	muls	r3, r2
 800c09e:	64c3      	str	r3, [r0, #76]	; 0x4c
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
 800c0a0:	7a0a      	ldrb	r2, [r1, #8]
 800c0a2:	f002 020f 	and.w	r2, r2, #15
 800c0a6:	fa04 f202 	lsl.w	r2, r4, r2
 800c0aa:	6502      	str	r2, [r0, #80]	; 0x50

    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U);
 800c0ac:	0a52      	lsrs	r2, r2, #9
 800c0ae:	4353      	muls	r3, r2
 800c0b0:	6543      	str	r3, [r0, #84]	; 0x54
    hsd->SdCard.LogBlockSize = 512U;
 800c0b2:	f44f 7300 	mov.w	r3, #512	; 0x200
 800c0b6:	e011      	b.n	800c0dc <HAL_SD_GetCardCSD+0xf0>
  }
  else if(hsd->SdCard.CardType == CARD_SDHC_SDXC)
 800c0b8:	2b01      	cmp	r3, #1
 800c0ba:	d160      	bne.n	800c17e <HAL_SD_GetCardCSD+0x192>
  {
    /* Byte 7 */
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
 800c0bc:	6e43      	ldr	r3, [r0, #100]	; 0x64
 800c0be:	f8b0 206a 	ldrh.w	r2, [r0, #106]	; 0x6a
 800c0c2:	041b      	lsls	r3, r3, #16
 800c0c4:	f403 137c 	and.w	r3, r3, #4128768	; 0x3f0000
 800c0c8:	4313      	orrs	r3, r2
 800c0ca:	610b      	str	r3, [r1, #16]

    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
 800c0cc:	690b      	ldr	r3, [r1, #16]
 800c0ce:	3301      	adds	r3, #1
 800c0d0:	029b      	lsls	r3, r3, #10
 800c0d2:	64c3      	str	r3, [r0, #76]	; 0x4c
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr;
 800c0d4:	6543      	str	r3, [r0, #84]	; 0x54
    hsd->SdCard.BlockSize = 512U;
 800c0d6:	f44f 7300 	mov.w	r3, #512	; 0x200
 800c0da:	6503      	str	r3, [r0, #80]	; 0x50
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize;
 800c0dc:	6583      	str	r3, [r0, #88]	; 0x58
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
    hsd->State = HAL_SD_STATE_READY;
    return HAL_ERROR;
  }

  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
 800c0de:	6e83      	ldr	r3, [r0, #104]	; 0x68
 800c0e0:	f3c3 3380 	ubfx	r3, r3, #14, #1
 800c0e4:	764b      	strb	r3, [r1, #25]

  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
 800c0e6:	6e83      	ldr	r3, [r0, #104]	; 0x68
 800c0e8:	f3c3 13c6 	ubfx	r3, r3, #7, #7
 800c0ec:	768b      	strb	r3, [r1, #26]

  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
 800c0ee:	6e83      	ldr	r3, [r0, #104]	; 0x68
 800c0f0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800c0f4:	76cb      	strb	r3, [r1, #27]

  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
 800c0f6:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 800c0f8:	0fdb      	lsrs	r3, r3, #31
 800c0fa:	770b      	strb	r3, [r1, #28]

  pCSD->ManDeflECC = (uint8_t)((hsd->CSD[3] & 0x60000000U) >> 29U);
 800c0fc:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 800c0fe:	f3c3 7341 	ubfx	r3, r3, #29, #2
 800c102:	774b      	strb	r3, [r1, #29]

  pCSD->WrSpeedFact = (uint8_t)((hsd->CSD[3] & 0x1C000000U) >> 26U);
 800c104:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 800c106:	f3c3 6382 	ubfx	r3, r3, #26, #3
 800c10a:	778b      	strb	r3, [r1, #30]

  pCSD->MaxWrBlockLen= (uint8_t)((hsd->CSD[3] & 0x03C00000U) >> 22U);
 800c10c:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 800c10e:	f3c3 5383 	ubfx	r3, r3, #22, #4
 800c112:	77cb      	strb	r3, [r1, #31]

  pCSD->WriteBlockPaPartial = (uint8_t)((hsd->CSD[3] & 0x00200000U) >> 21U);
 800c114:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 800c116:	f3c3 5340 	ubfx	r3, r3, #21, #1
 800c11a:	f881 3020 	strb.w	r3, [r1, #32]

  pCSD->Reserved3 = 0;
 800c11e:	2300      	movs	r3, #0
 800c120:	f881 3021 	strb.w	r3, [r1, #33]	; 0x21

  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
 800c124:	f8b0 206e 	ldrh.w	r2, [r0, #110]	; 0x6e
 800c128:	f002 0201 	and.w	r2, r2, #1
 800c12c:	f881 2022 	strb.w	r2, [r1, #34]	; 0x22

  pCSD->FileFormatGroup = (uint8_t)((hsd->CSD[3] & 0x00008000U) >> 15U);
 800c130:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 800c132:	f3c2 32c0 	ubfx	r2, r2, #15, #1
 800c136:	f881 2023 	strb.w	r2, [r1, #35]	; 0x23

  pCSD->CopyFlag = (uint8_t)((hsd->CSD[3] & 0x00004000U) >> 14U);
 800c13a:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 800c13c:	f3c2 3280 	ubfx	r2, r2, #14, #1
 800c140:	f881 2024 	strb.w	r2, [r1, #36]	; 0x24

  pCSD->PermWrProtect = (uint8_t)((hsd->CSD[3] & 0x00002000U) >> 13U);
 800c144:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 800c146:	f3c2 3240 	ubfx	r2, r2, #13, #1
 800c14a:	f881 2025 	strb.w	r2, [r1, #37]	; 0x25

  pCSD->TempWrProtect = (uint8_t)((hsd->CSD[3] & 0x00001000U) >> 12U);
 800c14e:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 800c150:	f3c2 3200 	ubfx	r2, r2, #12, #1
 800c154:	f881 2026 	strb.w	r2, [r1, #38]	; 0x26

  pCSD->FileFormat = (uint8_t)((hsd->CSD[3] & 0x00000C00U) >> 10U);
 800c158:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 800c15a:	f3c2 2281 	ubfx	r2, r2, #10, #2
 800c15e:	f881 2027 	strb.w	r2, [r1, #39]	; 0x27

  pCSD->ECC= (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
 800c162:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 800c164:	f3c2 2201 	ubfx	r2, r2, #8, #2
 800c168:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28

  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
 800c16c:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 800c16e:	f3c2 0246 	ubfx	r2, r2, #1, #7
 800c172:	f881 2029 	strb.w	r2, [r1, #41]	; 0x29

  pCSD->Reserved4 = 1;
 800c176:	2201      	movs	r2, #1
 800c178:	f881 202a 	strb.w	r2, [r1, #42]	; 0x2a
 800c17c:	e009      	b.n	800c192 <HAL_SD_GetCardCSD+0x1a6>
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize;
  }
  else
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800c17e:	6803      	ldr	r3, [r0, #0]
 800c180:	4a05      	ldr	r2, [pc, #20]	; (800c198 <HAL_SD_GetCardCSD+0x1ac>)
 800c182:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800c184:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800c186:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800c18a:	6383      	str	r3, [r0, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800c18c:	2301      	movs	r3, #1
 800c18e:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34

  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);

  pCSD->Reserved4 = 1;

  return HAL_OK;
 800c192:	4618      	mov	r0, r3
}
 800c194:	bd10      	pop	{r4, pc}
 800c196:	bf00      	nop
 800c198:	1fe00fff 	.word	0x1fe00fff

0800c19c <HAL_SD_InitCard>:
  * @note   This function initializes the SD card. It could be used when a card
            re-initialization is needed.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_InitCard(SD_HandleTypeDef *hsd)
{
 800c19c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c19e:	b099      	sub	sp, #100	; 0x64
  HAL_StatusTypeDef status;
  SD_InitTypeDef Init;
  uint32_t sdmmc_clk;

  /* Default SDMMC peripheral configuration for SD card initialization */
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
 800c1a0:	2300      	movs	r3, #0
  * @note   This function initializes the SD card. It could be used when a card
            re-initialization is needed.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_InitCard(SD_HandleTypeDef *hsd)
{
 800c1a2:	4604      	mov	r4, r0
  Init.ClockPowerSave      = SDMMC_CLOCK_POWER_SAVE_DISABLE;
  Init.BusWide             = SDMMC_BUS_WIDE_1B;
  Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;

  /* Init Clock should be less or equal to 400Khz*/
  sdmmc_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC1);
 800c1a4:	f44f 2000 	mov.w	r0, #524288	; 0x80000
  HAL_StatusTypeDef status;
  SD_InitTypeDef Init;
  uint32_t sdmmc_clk;

  /* Default SDMMC peripheral configuration for SD card initialization */
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
 800c1a8:	9307      	str	r3, [sp, #28]
#if !defined(STM32L4P5xx) && !defined(STM32L4Q5xx) && !defined(STM32L4R5xx) && !defined(STM32L4R7xx) && !defined(STM32L4R9xx) && !defined(STM32L4S5xx) && !defined(STM32L4S7xx) && !defined(STM32L4S9xx)
  Init.ClockBypass         = SDMMC_CLOCK_BYPASS_DISABLE;
#endif /* !STM32L4P5xx && !STM32L4Q5xx && !STM32L4R5xx && !STM32L4R7xx && !STM32L4R9xx && !STM32L4S5xx && !STM32L4S7xx && !STM32L4S9xx */
  Init.ClockPowerSave      = SDMMC_CLOCK_POWER_SAVE_DISABLE;
 800c1aa:	9308      	str	r3, [sp, #32]
  Init.BusWide             = SDMMC_BUS_WIDE_1B;
 800c1ac:	9309      	str	r3, [sp, #36]	; 0x24
  Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
 800c1ae:	930a      	str	r3, [sp, #40]	; 0x28

  /* Init Clock should be less or equal to 400Khz*/
  sdmmc_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC1);
 800c1b0:	f7fd fae2 	bl	8009778 <HAL_RCCEx_GetPeriphCLKFreq>
  if (sdmmc_clk == 0U)
 800c1b4:	4606      	mov	r6, r0
 800c1b6:	b928      	cbnz	r0, 800c1c4 <HAL_SD_InitCard+0x28>
  {
      hsd->State = HAL_SD_STATE_READY;
 800c1b8:	2001      	movs	r0, #1
 800c1ba:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
      hsd->ErrorCode = SDMMC_ERROR_INVALID_PARAMETER;
 800c1be:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800c1c2:	e0d4      	b.n	800c36e <HAL_SD_InitCard+0x1d2>
#else
  Init.ClockDiv = sdmmc_clk / (2U * SD_INIT_FREQ);
#endif

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  Init.Transceiver = hsd->Init.Transceiver;
 800c1c4:	69a3      	ldr	r3, [r4, #24]
 800c1c6:	6827      	ldr	r7, [r4, #0]
 800c1c8:	930c      	str	r3, [sp, #48]	; 0x30
  if(hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE)
 800c1ca:	2b01      	cmp	r3, #1
  {
    /* Set Transceiver polarity */
    hsd->Instance->POWER |= SDMMC_POWER_DIRPOL;
 800c1cc:	bf08      	it	eq
 800c1ce:	683b      	ldreq	r3, [r7, #0]
      return HAL_ERROR;
  }
#if !defined(STM32L4P5xx) && !defined(STM32L4Q5xx) && !defined(STM32L4R5xx) && !defined(STM32L4R7xx) && !defined(STM32L4R9xx) && !defined(STM32L4S5xx) && !defined(STM32L4S7xx) && !defined(STM32L4S9xx)
  Init.ClockDiv = ((sdmmc_clk / SD_INIT_FREQ) - 2U);
#else
  Init.ClockDiv = sdmmc_clk / (2U * SD_INIT_FREQ);
 800c1d0:	4d9e      	ldr	r5, [pc, #632]	; (800c44c <HAL_SD_InitCard+0x2b0>)
 800c1d2:	fbb0 f5f5 	udiv	r5, r0, r5
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  Init.Transceiver = hsd->Init.Transceiver;
  if(hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE)
  {
    /* Set Transceiver polarity */
    hsd->Instance->POWER |= SDMMC_POWER_DIRPOL;
 800c1d6:	bf04      	itt	eq
 800c1d8:	f043 0310 	orreq.w	r3, r3, #16
 800c1dc:	603b      	streq	r3, [r7, #0]
  }
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

  /* Initialize SDMMC peripheral interface with default configuration */
  status = SDMMC_Init(hsd->Instance, Init);
 800c1de:	950b      	str	r5, [sp, #44]	; 0x2c
 800c1e0:	ab0a      	add	r3, sp, #40	; 0x28
 800c1e2:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800c1e6:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 800c1ea:	ab07      	add	r3, sp, #28
 800c1ec:	cb0e      	ldmia	r3, {r1, r2, r3}
 800c1ee:	4638      	mov	r0, r7
 800c1f0:	f000 fcb8 	bl	800cb64 <SDMMC_Init>
  if(status != HAL_OK)
 800c1f4:	b108      	cbz	r0, 800c1fa <HAL_SD_InitCard+0x5e>
  {
    return HAL_ERROR;
 800c1f6:	2001      	movs	r0, #1
 800c1f8:	e125      	b.n	800c446 <HAL_SD_InitCard+0x2aa>
  /* Disable SDMMC Clock */
  __HAL_SD_DISABLE(hsd);
#endif /* !STM32L4P5xx && !STM32L4Q5xx && !STM32L4R5xx && !STM32L4R7xx && !STM32L4R9xx && !STM32L4S5xx && !STM32L4S7xx && !STM32L4S9xx */

  /* Set Power State to ON */
  status = SDMMC_PowerState_ON(hsd->Instance);
 800c1fa:	6820      	ldr	r0, [r4, #0]
 800c1fc:	f000 fcd4 	bl	800cba8 <SDMMC_PowerState_ON>
  if(status != HAL_OK)
 800c200:	4607      	mov	r7, r0
 800c202:	2800      	cmp	r0, #0
 800c204:	d1f7      	bne.n	800c1f6 <HAL_SD_InitCard+0x5a>
#if !defined(STM32L4P5xx) && !defined(STM32L4Q5xx) && !defined(STM32L4R5xx) && !defined(STM32L4R7xx) && !defined(STM32L4R9xx) && !defined(STM32L4S5xx) && !defined(STM32L4S7xx) && !defined(STM32L4S9xx)
  sdmmc_clk = sdmmc_clk/(Init.ClockDiv + 2U);
#else
  sdmmc_clk = sdmmc_clk/(2U*Init.ClockDiv);
#endif
  HAL_Delay(1U+ (74U*1000U/(sdmmc_clk)));
 800c206:	006d      	lsls	r5, r5, #1
 800c208:	4891      	ldr	r0, [pc, #580]	; (800c450 <HAL_SD_InitCard+0x2b4>)
 800c20a:	fbb6 f5f5 	udiv	r5, r6, r5
 800c20e:	fbb0 f0f5 	udiv	r0, r0, r5
 800c212:	3001      	adds	r0, #1
 800c214:	f7f7 fb4a 	bl	80038ac <HAL_Delay>
  * @param  hsd Pointer to SD handle
  * @retval error state
  */
static uint32_t SD_PowerON(SD_HandleTypeDef *hsd)
{
  __IO uint32_t count = 0U;
 800c218:	9706      	str	r7, [sp, #24]
  uint32_t response = 0U, validvoltage = 0U;
  uint32_t errorstate;
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  uint32_t tickstart = HAL_GetTick();
 800c21a:	f7fa fefb 	bl	8007014 <HAL_GetTick>
 800c21e:	4606      	mov	r6, r0
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

  /* CMD0: GO_IDLE_STATE */
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 800c220:	6820      	ldr	r0, [r4, #0]
 800c222:	f000 fd15 	bl	800cc50 <SDMMC_CmdGoIdleState>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c226:	4605      	mov	r5, r0
 800c228:	2800      	cmp	r0, #0
 800c22a:	f040 80a2 	bne.w	800c372 <HAL_SD_InitCard+0x1d6>
  {
    return errorstate;
  }

  /* CMD8: SEND_IF_COND: Command available only on V2.0 cards */
  errorstate = SDMMC_CmdOperCond(hsd->Instance);
 800c22e:	6820      	ldr	r0, [r4, #0]
 800c230:	f001 f900 	bl	800d434 <SDMMC_CmdOperCond>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c234:	b128      	cbz	r0, 800c242 <HAL_SD_InitCard+0xa6>
  {
    hsd->SdCard.CardVersion = CARD_V1_X;
 800c236:	6425      	str	r5, [r4, #64]	; 0x40
    /* CMD0: GO_IDLE_STATE */
    errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 800c238:	6820      	ldr	r0, [r4, #0]
 800c23a:	f000 fd09 	bl	800cc50 <SDMMC_CmdGoIdleState>
    if(errorstate != HAL_SD_ERROR_NONE)
 800c23e:	b110      	cbz	r0, 800c246 <HAL_SD_InitCard+0xaa>
 800c240:	e097      	b.n	800c372 <HAL_SD_InitCard+0x1d6>
    }

  }
  else
  {
    hsd->SdCard.CardVersion = CARD_V2_X;
 800c242:	2301      	movs	r3, #1
 800c244:	6423      	str	r3, [r4, #64]	; 0x40
  }

  if( hsd->SdCard.CardVersion == CARD_V2_X)
 800c246:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800c248:	2b01      	cmp	r3, #1
 800c24a:	d004      	beq.n	800c256 <HAL_SD_InitCard+0xba>
  * @note   This function initializes the SD card. It could be used when a card
            re-initialization is needed.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_InitCard(SD_HandleTypeDef *hsd)
{
 800c24c:	2500      	movs	r5, #0
 800c24e:	4628      	mov	r0, r5
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
    }
  }
  /* SD CARD */
  /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 800c250:	f64f 77fe 	movw	r7, #65534	; 0xfffe
 800c254:	e01d      	b.n	800c292 <HAL_SD_InitCard+0xf6>
  }

  if( hsd->SdCard.CardVersion == CARD_V2_X)
  {
    /* SEND CMD55 APP_CMD with RCA as 0 */
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 800c256:	2100      	movs	r1, #0
 800c258:	6820      	ldr	r0, [r4, #0]
 800c25a:	f000 feee 	bl	800d03a <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 800c25e:	2800      	cmp	r0, #0
 800c260:	d0f4      	beq.n	800c24c <HAL_SD_InitCard+0xb0>
    {
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800c262:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 800c266:	e084      	b.n	800c372 <HAL_SD_InitCard+0x1d6>
    }
  }
  /* SD CARD */
  /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 800c268:	b9b5      	cbnz	r5, 800c298 <HAL_SD_InitCard+0xfc>
  {
    /* SEND CMD55 APP_CMD with RCA as 0 */
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 800c26a:	4629      	mov	r1, r5
 800c26c:	6820      	ldr	r0, [r4, #0]
 800c26e:	f000 fee4 	bl	800d03a <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 800c272:	2800      	cmp	r0, #0
 800c274:	d17d      	bne.n	800c372 <HAL_SD_InitCard+0x1d6>
    {
      return errorstate;
    }

    /* Send CMD41 */
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
 800c276:	4977      	ldr	r1, [pc, #476]	; (800c454 <HAL_SD_InitCard+0x2b8>)
 800c278:	6820      	ldr	r0, [r4, #0]
 800c27a:	f001 f825 	bl	800d2c8 <SDMMC_CmdAppOperCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 800c27e:	2800      	cmp	r0, #0
 800c280:	d1ef      	bne.n	800c262 <HAL_SD_InitCard+0xc6>
    {
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
    }

    /* Get command response */
    response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800c282:	4629      	mov	r1, r5
 800c284:	6820      	ldr	r0, [r4, #0]
 800c286:	f000 fcc0 	bl	800cc0a <SDMMC_GetResponse>

    /* Get operating voltage*/
    validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);

    count++;
 800c28a:	9b06      	ldr	r3, [sp, #24]
 800c28c:	3301      	adds	r3, #1

    /* Get command response */
    response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);

    /* Get operating voltage*/
    validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
 800c28e:	0fc5      	lsrs	r5, r0, #31

    count++;
 800c290:	9306      	str	r3, [sp, #24]
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
    }
  }
  /* SD CARD */
  /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 800c292:	9b06      	ldr	r3, [sp, #24]
 800c294:	42bb      	cmp	r3, r7
 800c296:	d9e7      	bls.n	800c268 <HAL_SD_InitCard+0xcc>
    validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);

    count++;
  }

  if(count >= SDMMC_MAX_VOLT_TRIAL)
 800c298:	9a06      	ldr	r2, [sp, #24]
 800c29a:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 800c29e:	429a      	cmp	r2, r3
 800c2a0:	d902      	bls.n	800c2a8 <HAL_SD_InitCard+0x10c>
  {
    return HAL_SD_ERROR_INVALID_VOLTRANGE;
 800c2a2:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
 800c2a6:	e064      	b.n	800c372 <HAL_SD_InitCard+0x1d6>
  }

  if((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
 800c2a8:	f010 4380 	ands.w	r3, r0, #1073741824	; 0x40000000
 800c2ac:	d042      	beq.n	800c334 <HAL_SD_InitCard+0x198>
  {
    hsd->SdCard.CardType = CARD_SDHC_SDXC;
 800c2ae:	2301      	movs	r3, #1
 800c2b0:	63e3      	str	r3, [r4, #60]	; 0x3c
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    if(hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE)
 800c2b2:	69a3      	ldr	r3, [r4, #24]
 800c2b4:	2b01      	cmp	r3, #1
 800c2b6:	d13e      	bne.n	800c336 <HAL_SD_InitCard+0x19a>
    {
      if((response & SD_SWITCH_1_8V_CAPACITY) == SD_SWITCH_1_8V_CAPACITY)
 800c2b8:	01c7      	lsls	r7, r0, #7
 800c2ba:	d53c      	bpl.n	800c336 <HAL_SD_InitCard+0x19a>
      {
        hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;

        /* Start switching procedue */
        hsd->Instance->POWER |= SDMMC_POWER_VSWITCHEN;
 800c2bc:	6820      	ldr	r0, [r4, #0]
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    if(hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE)
    {
      if((response & SD_SWITCH_1_8V_CAPACITY) == SD_SWITCH_1_8V_CAPACITY)
      {
        hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
 800c2be:	f44f 7300 	mov.w	r3, #512	; 0x200
 800c2c2:	65e3      	str	r3, [r4, #92]	; 0x5c

        /* Start switching procedue */
        hsd->Instance->POWER |= SDMMC_POWER_VSWITCHEN;
 800c2c4:	6803      	ldr	r3, [r0, #0]
 800c2c6:	f043 0308 	orr.w	r3, r3, #8
 800c2ca:	6003      	str	r3, [r0, #0]

        /* Send CMD11 to switch 1.8V mode */
        errorstate = SDMMC_CmdVoltageSwitch(hsd->Instance);
 800c2cc:	f000 ff4e 	bl	800d16c <SDMMC_CmdVoltageSwitch>
        if(errorstate != HAL_SD_ERROR_NONE)
 800c2d0:	2800      	cmp	r0, #0
 800c2d2:	d14e      	bne.n	800c372 <HAL_SD_InitCard+0x1d6>
        {
          return errorstate;
        }

        /* Check to CKSTOP */
        while(( hsd->Instance->STA & SDMMC_FLAG_CKSTOP) != SDMMC_FLAG_CKSTOP)
 800c2d4:	6823      	ldr	r3, [r4, #0]
 800c2d6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c2d8:	0155      	lsls	r5, r2, #5
 800c2da:	d407      	bmi.n	800c2ec <HAL_SD_InitCard+0x150>
        {
          if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 800c2dc:	f7fa fe9a 	bl	8007014 <HAL_GetTick>
 800c2e0:	1b80      	subs	r0, r0, r6
 800c2e2:	3001      	adds	r0, #1
 800c2e4:	d1f6      	bne.n	800c2d4 <HAL_SD_InitCard+0x138>
          {
            return HAL_SD_ERROR_TIMEOUT;
 800c2e6:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800c2ea:	e042      	b.n	800c372 <HAL_SD_InitCard+0x1d6>
          }
        }

        /* Clear CKSTOP Flag */
        hsd->Instance->ICR = SDMMC_FLAG_CKSTOP;
 800c2ec:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 800c2f0:	639a      	str	r2, [r3, #56]	; 0x38

        /* Check to BusyD0 */
        if(( hsd->Instance->STA & SDMMC_FLAG_BUSYD0) != SDMMC_FLAG_BUSYD0)
 800c2f2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800c2f4:	02d8      	lsls	r0, r3, #11
 800c2f6:	d5b4      	bpl.n	800c262 <HAL_SD_InitCard+0xc6>
        {
          /* Enable Transceiver Switch PIN */
#if defined (USE_HAL_SD_REGISTER_CALLBACKS) && (USE_HAL_SD_REGISTER_CALLBACKS == 1U)
          hsd->DriveTransceiver_1_8V_Callback(SET);
#else
          HAL_SDEx_DriveTransceiver_1_8V_Callback(SET);
 800c2f8:	2001      	movs	r0, #1
 800c2fa:	f7fa fefb 	bl	80070f4 <HAL_SDEx_DriveTransceiver_1_8V_Callback>
#endif

          /* Switch ready */
          hsd->Instance->POWER |= SDMMC_POWER_VSWITCH;
 800c2fe:	6822      	ldr	r2, [r4, #0]
 800c300:	6813      	ldr	r3, [r2, #0]
 800c302:	f043 0304 	orr.w	r3, r3, #4
 800c306:	6013      	str	r3, [r2, #0]

          /* Check VSWEND Flag */
          while(( hsd->Instance->STA & SDMMC_FLAG_VSWEND) != SDMMC_FLAG_VSWEND)
 800c308:	6823      	ldr	r3, [r4, #0]
 800c30a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c30c:	0191      	lsls	r1, r2, #6
 800c30e:	d405      	bmi.n	800c31c <HAL_SD_InitCard+0x180>
          {
            if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 800c310:	f7fa fe80 	bl	8007014 <HAL_GetTick>
 800c314:	1b80      	subs	r0, r0, r6
 800c316:	3001      	adds	r0, #1
 800c318:	d1f6      	bne.n	800c308 <HAL_SD_InitCard+0x16c>
 800c31a:	e7e4      	b.n	800c2e6 <HAL_SD_InitCard+0x14a>
              return HAL_SD_ERROR_TIMEOUT;
            }
          }

          /* Clear VSWEND Flag */
          hsd->Instance->ICR = SDMMC_FLAG_VSWEND;
 800c31c:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 800c320:	639a      	str	r2, [r3, #56]	; 0x38

          /* Check BusyD0 status */
          if(( hsd->Instance->STA & SDMMC_FLAG_BUSYD0) == SDMMC_FLAG_BUSYD0)
 800c322:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c324:	02d2      	lsls	r2, r2, #11
 800c326:	d4bc      	bmi.n	800c2a2 <HAL_SD_InitCard+0x106>
            return HAL_SD_ERROR_INVALID_VOLTRANGE;
          }
          /* Switch to 1.8V OK */

          /* Disable VSWITCH FLAG from SDMMC Peripheral */
          hsd->Instance->POWER = 0x13U;
 800c328:	2213      	movs	r2, #19
 800c32a:	601a      	str	r2, [r3, #0]

          /* Clean Status flags */
          hsd->Instance->ICR = 0xFFFFFFFFU;
 800c32c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800c330:	639a      	str	r2, [r3, #56]	; 0x38
 800c332:	e000      	b.n	800c336 <HAL_SD_InitCard+0x19a>
    }
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
  }
  else
  {
    hsd->SdCard.CardType = CARD_SDSC;
 800c334:	63e3      	str	r3, [r4, #60]	; 0x3c
  */
static uint32_t SD_InitCard(SD_HandleTypeDef *hsd)
{
  HAL_SD_CardCSDTypeDef CSD;
  uint32_t errorstate;
  uint16_t sd_rca = 1U;
 800c336:	2301      	movs	r3, #1

  /* Check the power State */
  if(SDMMC_GetPowerState(hsd->Instance) == 0U)
 800c338:	6820      	ldr	r0, [r4, #0]
  */
static uint32_t SD_InitCard(SD_HandleTypeDef *hsd)
{
  HAL_SD_CardCSDTypeDef CSD;
  uint32_t errorstate;
  uint16_t sd_rca = 1U;
 800c33a:	f8ad 3016 	strh.w	r3, [sp, #22]

  /* Check the power State */
  if(SDMMC_GetPowerState(hsd->Instance) == 0U)
 800c33e:	f000 fc49 	bl	800cbd4 <SDMMC_GetPowerState>
 800c342:	2800      	cmp	r0, #0
 800c344:	d06c      	beq.n	800c420 <HAL_SD_InitCard+0x284>
  {
    /* Power off */
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
  }

  if(hsd->SdCard.CardType != CARD_SECURED)
 800c346:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800c348:	2b03      	cmp	r3, #3
 800c34a:	d11a      	bne.n	800c382 <HAL_SD_InitCard+0x1e6>
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
    }
  }

  if(hsd->SdCard.CardType != CARD_SECURED)
 800c34c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800c34e:	2b03      	cmp	r3, #3
 800c350:	d031      	beq.n	800c3b6 <HAL_SD_InitCard+0x21a>
  {
    /* Send CMD3 SET_REL_ADDR with argument 0 */
    /* SD Card publishes its RCA. */
    errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
 800c352:	f10d 0116 	add.w	r1, sp, #22
 800c356:	6820      	ldr	r0, [r4, #0]
 800c358:	f001 f824 	bl	800d3a4 <SDMMC_CmdSetRelAdd>
    if(errorstate != HAL_SD_ERROR_NONE)
 800c35c:	b358      	cbz	r0, 800c3b6 <HAL_SD_InitCard+0x21a>
    /* Get the SD card RCA */
    hsd->SdCard.RelCardAdd = sd_rca;

    /* Send CMD9 SEND_CSD with argument as card's RCA */
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
    if(errorstate != HAL_SD_ERROR_NONE)
 800c35e:	4605      	mov	r5, r0
    return HAL_ERROR;
  }

  /* Card initialization */
  errorstate = SD_InitCard(hsd);
  if(errorstate != HAL_SD_ERROR_NONE)
 800c360:	2800      	cmp	r0, #0
 800c362:	d060      	beq.n	800c426 <HAL_SD_InitCard+0x28a>
  {
    hsd->State = HAL_SD_STATE_READY;
 800c364:	2001      	movs	r0, #1
 800c366:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
 800c36a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c36c:	432b      	orrs	r3, r5
 800c36e:	63a3      	str	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
 800c370:	e069      	b.n	800c446 <HAL_SD_InitCard+0x2aa>

  /* Identify card operating voltage */
  errorstate = SD_PowerON(hsd);
  if(errorstate != HAL_SD_ERROR_NONE)
  {
    hsd->State = HAL_SD_STATE_READY;
 800c372:	2501      	movs	r5, #1
 800c374:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
 800c378:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c37a:	4318      	orrs	r0, r3
 800c37c:	63a0      	str	r0, [r4, #56]	; 0x38
    return HAL_ERROR;
 800c37e:	4628      	mov	r0, r5
 800c380:	e061      	b.n	800c446 <HAL_SD_InitCard+0x2aa>
  }

  if(hsd->SdCard.CardType != CARD_SECURED)
  {
    /* Send CMD2 ALL_SEND_CID */
    errorstate = SDMMC_CmdSendCID(hsd->Instance);
 800c382:	6820      	ldr	r0, [r4, #0]
 800c384:	f000 ff4e 	bl	800d224 <SDMMC_CmdSendCID>
    if(errorstate != HAL_SD_ERROR_NONE)
 800c388:	2800      	cmp	r0, #0
 800c38a:	d1e8      	bne.n	800c35e <HAL_SD_InitCard+0x1c2>
      return errorstate;
    }
    else
    {
      /* Get Card identification number data */
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800c38c:	4601      	mov	r1, r0
 800c38e:	6820      	ldr	r0, [r4, #0]
 800c390:	f000 fc3b 	bl	800cc0a <SDMMC_GetResponse>
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800c394:	2104      	movs	r1, #4
      return errorstate;
    }
    else
    {
      /* Get Card identification number data */
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800c396:	6720      	str	r0, [r4, #112]	; 0x70
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800c398:	6820      	ldr	r0, [r4, #0]
 800c39a:	f000 fc36 	bl	800cc0a <SDMMC_GetResponse>
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800c39e:	2108      	movs	r1, #8
    }
    else
    {
      /* Get Card identification number data */
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800c3a0:	6760      	str	r0, [r4, #116]	; 0x74
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800c3a2:	6820      	ldr	r0, [r4, #0]
 800c3a4:	f000 fc31 	bl	800cc0a <SDMMC_GetResponse>
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 800c3a8:	210c      	movs	r1, #12
    else
    {
      /* Get Card identification number data */
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800c3aa:	67a0      	str	r0, [r4, #120]	; 0x78
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 800c3ac:	6820      	ldr	r0, [r4, #0]
 800c3ae:	f000 fc2c 	bl	800cc0a <SDMMC_GetResponse>
 800c3b2:	67e0      	str	r0, [r4, #124]	; 0x7c
 800c3b4:	e7ca      	b.n	800c34c <HAL_SD_InitCard+0x1b0>
    if(errorstate != HAL_SD_ERROR_NONE)
    {
      return errorstate;
    }
  }
  if(hsd->SdCard.CardType != CARD_SECURED)
 800c3b6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800c3b8:	2b03      	cmp	r3, #3
 800c3ba:	d01c      	beq.n	800c3f6 <HAL_SD_InitCard+0x25a>
  {
    /* Get the SD card RCA */
    hsd->SdCard.RelCardAdd = sd_rca;
 800c3bc:	f8bd 1016 	ldrh.w	r1, [sp, #22]
 800c3c0:	64a1      	str	r1, [r4, #72]	; 0x48

    /* Send CMD9 SEND_CSD with argument as card's RCA */
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800c3c2:	6820      	ldr	r0, [r4, #0]
 800c3c4:	0409      	lsls	r1, r1, #16
 800c3c6:	f000 ff43 	bl	800d250 <SDMMC_CmdSendCSD>
    if(errorstate != HAL_SD_ERROR_NONE)
 800c3ca:	2800      	cmp	r0, #0
 800c3cc:	d1c7      	bne.n	800c35e <HAL_SD_InitCard+0x1c2>
      return errorstate;
    }
    else
    {
      /* Get Card Specific Data */
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800c3ce:	4601      	mov	r1, r0
 800c3d0:	6820      	ldr	r0, [r4, #0]
 800c3d2:	f000 fc1a 	bl	800cc0a <SDMMC_GetResponse>
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800c3d6:	2104      	movs	r1, #4
      return errorstate;
    }
    else
    {
      /* Get Card Specific Data */
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800c3d8:	6620      	str	r0, [r4, #96]	; 0x60
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800c3da:	6820      	ldr	r0, [r4, #0]
 800c3dc:	f000 fc15 	bl	800cc0a <SDMMC_GetResponse>
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800c3e0:	2108      	movs	r1, #8
    }
    else
    {
      /* Get Card Specific Data */
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800c3e2:	6660      	str	r0, [r4, #100]	; 0x64
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800c3e4:	6820      	ldr	r0, [r4, #0]
 800c3e6:	f000 fc10 	bl	800cc0a <SDMMC_GetResponse>
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 800c3ea:	210c      	movs	r1, #12
    else
    {
      /* Get Card Specific Data */
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800c3ec:	66a0      	str	r0, [r4, #104]	; 0x68
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 800c3ee:	6820      	ldr	r0, [r4, #0]
 800c3f0:	f000 fc0b 	bl	800cc0a <SDMMC_GetResponse>
 800c3f4:	66e0      	str	r0, [r4, #108]	; 0x6c
    }
  }

  /* Get the Card Class */
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
 800c3f6:	2104      	movs	r1, #4
 800c3f8:	6820      	ldr	r0, [r4, #0]
 800c3fa:	f000 fc06 	bl	800cc0a <SDMMC_GetResponse>
 800c3fe:	0d00      	lsrs	r0, r0, #20
 800c400:	6460      	str	r0, [r4, #68]	; 0x44

  /* Get CSD parameters */
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
 800c402:	a90d      	add	r1, sp, #52	; 0x34
 800c404:	4620      	mov	r0, r4
 800c406:	f7ff fdf1 	bl	800bfec <HAL_SD_GetCardCSD>
 800c40a:	4603      	mov	r3, r0
 800c40c:	b928      	cbnz	r0, 800c41a <HAL_SD_InitCard+0x27e>
  {
    return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
  }

  /* Select the Card */
  errorstate = SDMMC_CmdSelDesel(hsd->Instance, (uint32_t)(((uint32_t)hsd->SdCard.RelCardAdd) << 16U));
 800c40e:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 800c410:	6820      	ldr	r0, [r4, #0]
 800c412:	0412      	lsls	r2, r2, #16
 800c414:	f000 fdf8 	bl	800d008 <SDMMC_CmdSelDesel>
 800c418:	e7a1      	b.n	800c35e <HAL_SD_InitCard+0x1c2>
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);

  /* Get CSD parameters */
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
  {
    return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800c41a:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 800c41e:	e7a1      	b.n	800c364 <HAL_SD_InitCard+0x1c8>

  /* Check the power State */
  if(SDMMC_GetPowerState(hsd->Instance) == 0U)
  {
    /* Power off */
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 800c420:	f04f 6580 	mov.w	r5, #67108864	; 0x4000000
 800c424:	e79e      	b.n	800c364 <HAL_SD_InitCard+0x1c8>
    hsd->ErrorCode |= errorstate;
    return HAL_ERROR;
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 800c426:	f44f 7100 	mov.w	r1, #512	; 0x200
 800c42a:	6820      	ldr	r0, [r4, #0]
 800c42c:	f000 fccc 	bl	800cdc8 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c430:	2800      	cmp	r0, #0
 800c432:	d0a4      	beq.n	800c37e <HAL_SD_InitCard+0x1e2>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800c434:	6823      	ldr	r3, [r4, #0]
 800c436:	4a08      	ldr	r2, [pc, #32]	; (800c458 <HAL_SD_InitCard+0x2bc>)
 800c438:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
 800c43a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c43c:	4318      	orrs	r0, r3
 800c43e:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800c440:	2001      	movs	r0, #1
 800c442:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    return HAL_ERROR;
  }

  return HAL_OK;
}
 800c446:	b019      	add	sp, #100	; 0x64
 800c448:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800c44a:	bf00      	nop
 800c44c:	000c3500 	.word	0x000c3500
 800c450:	00012110 	.word	0x00012110
 800c454:	c1100000 	.word	0xc1100000
 800c458:	1fe00fff 	.word	0x1fe00fff

0800c45c <HAL_SD_GetCardStatus>:
  * @param  pStatus Pointer to the HAL_SD_CardStatusTypeDef structure that
  *         will contain the SD card status information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_GetCardStatus(SD_HandleTypeDef *hsd, HAL_SD_CardStatusTypeDef *pStatus)
{
 800c45c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c460:	b096      	sub	sp, #88	; 0x58
 800c462:	4604      	mov	r4, r0
 800c464:	460d      	mov	r5, r1
  */
static uint32_t SD_SendSDStatus(SD_HandleTypeDef *hsd, uint32_t *pSDstatus)
{
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 800c466:	f7fa fdd5 	bl	8007014 <HAL_GetTick>
  uint32_t count;
  uint32_t *pData = pSDstatus;

  /* Check SD response */
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800c46a:	2100      	movs	r1, #0
  */
static uint32_t SD_SendSDStatus(SD_HandleTypeDef *hsd, uint32_t *pSDstatus)
{
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 800c46c:	4607      	mov	r7, r0
  uint32_t count;
  uint32_t *pData = pSDstatus;

  /* Check SD response */
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800c46e:	6820      	ldr	r0, [r4, #0]
 800c470:	f000 fbcb 	bl	800cc0a <SDMMC_GetResponse>
 800c474:	0183      	lsls	r3, r0, #6
 800c476:	d455      	bmi.n	800c524 <HAL_SD_GetCardStatus+0xc8>
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
  }

  /* Set block size for card if it is not equal to current block size for card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 64U);
 800c478:	2140      	movs	r1, #64	; 0x40
 800c47a:	6820      	ldr	r0, [r4, #0]
 800c47c:	f000 fca4 	bl	800cdc8 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c480:	b9b8      	cbnz	r0, 800c4b2 <HAL_SD_GetCardStatus+0x56>
    hsd->ErrorCode |= HAL_SD_ERROR_NONE;
    return errorstate;
  }

  /* Send CMD55 */
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800c482:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800c484:	6820      	ldr	r0, [r4, #0]
 800c486:	0409      	lsls	r1, r1, #16
 800c488:	f000 fdd7 	bl	800d03a <SDMMC_CmdAppCommand>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c48c:	b988      	cbnz	r0, 800c4b2 <HAL_SD_GetCardStatus+0x56>

  /* Configure the SD DPSM (Data Path State Machine) */
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
  config.DataLength    = 64U;
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B;
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800c48e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800c492:	2240      	movs	r2, #64	; 0x40
 800c494:	2360      	movs	r3, #96	; 0x60
 800c496:	2602      	movs	r6, #2
 800c498:	e88d 004e 	stmia.w	sp, {r1, r2, r3, r6}
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800c49c:	9004      	str	r0, [sp, #16]
  config.DPSM          = SDMMC_DPSM_ENABLE;
 800c49e:	2301      	movs	r3, #1
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 800c4a0:	4669      	mov	r1, sp
 800c4a2:	6820      	ldr	r0, [r4, #0]
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
  config.DataLength    = 64U;
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B;
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
  config.DPSM          = SDMMC_DPSM_ENABLE;
 800c4a4:	9305      	str	r3, [sp, #20]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 800c4a6:	f000 fbb3 	bl	800cc10 <SDMMC_ConfigData>

  /* Send ACMD13 (SD_APP_STAUS)  with argument as card's RCA */
  errorstate = SDMMC_CmdStatusRegister(hsd->Instance);
 800c4aa:	6820      	ldr	r0, [r4, #0]
 800c4ac:	f000 fe2a 	bl	800d104 <SDMMC_CmdStatusRegister>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c4b0:	b120      	cbz	r0, 800c4bc <HAL_SD_GetCardStatus+0x60>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_NONE;
 800c4b2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c4b4:	63a3      	str	r3, [r4, #56]	; 0x38
  uint32_t sd_status[16];
  uint32_t errorstate;
  HAL_StatusTypeDef status = HAL_OK;

  errorstate = SD_SendSDStatus(hsd, sd_status);
  if(errorstate != HAL_SD_ERROR_NONE)
 800c4b6:	2800      	cmp	r0, #0
 800c4b8:	d046      	beq.n	800c548 <HAL_SD_GetCardStatus+0xec>
 800c4ba:	e03b      	b.n	800c534 <HAL_SD_GetCardStatus+0xd8>
  config.DPSM          = SDMMC_DPSM_ENABLE;
  (void)SDMMC_ConfigData(hsd->Instance, &config);

  /* Send ACMD13 (SD_APP_STAUS)  with argument as card's RCA */
  errorstate = SDMMC_CmdStatusRegister(hsd->Instance);
  if(errorstate != HAL_SD_ERROR_NONE)
 800c4bc:	ae06      	add	r6, sp, #24
    return errorstate;
  }

  /* Get status data */
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 800c4be:	6823      	ldr	r3, [r4, #0]
 800c4c0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c4c2:	f412 7f95 	tst.w	r2, #298	; 0x12a
 800c4c6:	d113      	bne.n	800c4f0 <HAL_SD_GetCardStatus+0x94>
#else
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND))
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
  {
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
 800c4c8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800c4ca:	041b      	lsls	r3, r3, #16
 800c4cc:	d508      	bpl.n	800c4e0 <HAL_SD_GetCardStatus+0x84>
 800c4ce:	f106 0820 	add.w	r8, r6, #32
    {
      for(count = 0U; count < 8U; count++)
      {
        *pData = SDMMC_ReadFIFO(hsd->Instance);
 800c4d2:	6820      	ldr	r0, [r4, #0]
 800c4d4:	f000 fb60 	bl	800cb98 <SDMMC_ReadFIFO>
 800c4d8:	f846 0b04 	str.w	r0, [r6], #4
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND))
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
  {
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
    {
      for(count = 0U; count < 8U; count++)
 800c4dc:	4546      	cmp	r6, r8
 800c4de:	d1f8      	bne.n	800c4d2 <HAL_SD_GetCardStatus+0x76>
        *pData = SDMMC_ReadFIFO(hsd->Instance);
        pData++;
      }
    }

    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 800c4e0:	f7fa fd98 	bl	8007014 <HAL_GetTick>
 800c4e4:	1bc0      	subs	r0, r0, r7
 800c4e6:	3001      	adds	r0, #1
 800c4e8:	d1e9      	bne.n	800c4be <HAL_SD_GetCardStatus+0x62>
    {
      return HAL_SD_ERROR_TIMEOUT;
 800c4ea:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800c4ee:	e021      	b.n	800c534 <HAL_SD_GetCardStatus+0xd8>
    }
  }

  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 800c4f0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c4f2:	0710      	lsls	r0, r2, #28
 800c4f4:	d419      	bmi.n	800c52a <HAL_SD_GetCardStatus+0xce>
  {
    return HAL_SD_ERROR_DATA_TIMEOUT;
  }
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800c4f6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c4f8:	0791      	lsls	r1, r2, #30
 800c4fa:	d418      	bmi.n	800c52e <HAL_SD_GetCardStatus+0xd2>
  {
    return HAL_SD_ERROR_DATA_CRC_FAIL;
  }
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 800c4fc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800c4fe:	069a      	lsls	r2, r3, #26
 800c500:	d417      	bmi.n	800c532 <HAL_SD_GetCardStatus+0xd6>
  {
    /* Nothing to do */
  }

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DPSMACT)))
 800c502:	6820      	ldr	r0, [r4, #0]
 800c504:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800c506:	04db      	lsls	r3, r3, #19
 800c508:	d509      	bpl.n	800c51e <HAL_SD_GetCardStatus+0xc2>
#else
  while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXDAVL)))
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
  {
    *pData = SDMMC_ReadFIFO(hsd->Instance);
 800c50a:	f000 fb45 	bl	800cb98 <SDMMC_ReadFIFO>
 800c50e:	f846 0b04 	str.w	r0, [r6], #4
    pData++;

    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 800c512:	f7fa fd7f 	bl	8007014 <HAL_GetTick>
 800c516:	1bc0      	subs	r0, r0, r7
 800c518:	3001      	adds	r0, #1
 800c51a:	d1f2      	bne.n	800c502 <HAL_SD_GetCardStatus+0xa6>
 800c51c:	e7e5      	b.n	800c4ea <HAL_SD_GetCardStatus+0x8e>
      return HAL_SD_ERROR_TIMEOUT;
    }
  }

  /* Clear all the static status flags*/
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800c51e:	4b2b      	ldr	r3, [pc, #172]	; (800c5cc <HAL_SD_GetCardStatus+0x170>)
 800c520:	6383      	str	r3, [r0, #56]	; 0x38
 800c522:	e011      	b.n	800c548 <HAL_SD_GetCardStatus+0xec>
  uint32_t *pData = pSDstatus;

  /* Check SD response */
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 800c524:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800c528:	e004      	b.n	800c534 <HAL_SD_GetCardStatus+0xd8>
    }
  }

  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
  {
    return HAL_SD_ERROR_DATA_TIMEOUT;
 800c52a:	2008      	movs	r0, #8
 800c52c:	e002      	b.n	800c534 <HAL_SD_GetCardStatus+0xd8>
  }
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
  {
    return HAL_SD_ERROR_DATA_CRC_FAIL;
 800c52e:	2002      	movs	r0, #2
 800c530:	e000      	b.n	800c534 <HAL_SD_GetCardStatus+0xd8>
  }
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
  {
    return HAL_SD_ERROR_RX_OVERRUN;
 800c532:	2020      	movs	r0, #32

  errorstate = SD_SendSDStatus(hsd, sd_status);
  if(errorstate != HAL_SD_ERROR_NONE)
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800c534:	6823      	ldr	r3, [r4, #0]
 800c536:	4a26      	ldr	r2, [pc, #152]	; (800c5d0 <HAL_SD_GetCardStatus+0x174>)
 800c538:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
 800c53a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800c53c:	2501      	movs	r5, #1
  errorstate = SD_SendSDStatus(hsd, sd_status);
  if(errorstate != HAL_SD_ERROR_NONE)
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
    hsd->ErrorCode |= errorstate;
 800c53e:	4318      	orrs	r0, r3
 800c540:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800c542:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
 800c546:	e030      	b.n	800c5aa <HAL_SD_GetCardStatus+0x14e>
    status = HAL_ERROR;
  }
  else
  {
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
 800c548:	9a06      	ldr	r2, [sp, #24]
 800c54a:	f3c2 1381 	ubfx	r3, r2, #6, #2
 800c54e:	702b      	strb	r3, [r5, #0]

    pStatus->SecuredMode = (uint8_t)((sd_status[0] & 0x20U) >> 5U);
 800c550:	f3c2 1340 	ubfx	r3, r2, #5, #1
 800c554:	706b      	strb	r3, [r5, #1]

    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
 800c556:	0a13      	lsrs	r3, r2, #8
 800c558:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 800c55c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800c560:	b29b      	uxth	r3, r3
 800c562:	806b      	strh	r3, [r5, #2]
 800c564:	9b07      	ldr	r3, [sp, #28]
 800c566:	ba1b      	rev	r3, r3

    pStatus->ProtectedAreaSize = (((sd_status[1] & 0xFFU) << 24U)    | ((sd_status[1] & 0xFF00U) << 8U) |
 800c568:	606b      	str	r3, [r5, #4]
                                  ((sd_status[1] & 0xFF0000U) >> 8U) | ((sd_status[1] & 0xFF000000U) >> 24U));

    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
 800c56a:	9b08      	ldr	r3, [sp, #32]
 800c56c:	b2da      	uxtb	r2, r3
 800c56e:	722a      	strb	r2, [r5, #8]

    pStatus->PerformanceMove = (uint8_t)((sd_status[2] & 0xFF00U) >> 8U);
 800c570:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800c574:	726a      	strb	r2, [r5, #9]

    pStatus->AllocationUnitSize = (uint8_t)((sd_status[2] & 0xF00000U) >> 20U);
 800c576:	f3c3 5203 	ubfx	r2, r3, #20, #4
 800c57a:	72aa      	strb	r2, [r5, #10]

    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
 800c57c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800c57e:	0c1b      	lsrs	r3, r3, #16
 800c580:	b2d1      	uxtb	r1, r2
 800c582:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 800c586:	430b      	orrs	r3, r1
 800c588:	81ab      	strh	r3, [r5, #12]

    pStatus->EraseTimeout = (uint8_t)((sd_status[3] & 0xFC00U) >> 10U);
 800c58a:	f3c2 2385 	ubfx	r3, r2, #10, #6
 800c58e:	73ab      	strb	r3, [r5, #14]

    pStatus->EraseOffset = (uint8_t)((sd_status[3] & 0x0300U) >> 8U);
 800c590:	f3c2 2301 	ubfx	r3, r2, #8, #2
 800c594:	73eb      	strb	r3, [r5, #15]

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    pStatus->UhsSpeedGrade = (uint8_t)((sd_status[3] & 0x00F0U) >> 4U);
 800c596:	f3c2 1303 	ubfx	r3, r2, #4, #4
 800c59a:	742b      	strb	r3, [r5, #16]
    pStatus->UhsAllocationUnitSize = (uint8_t)(sd_status[3] & 0x000FU) ;
 800c59c:	f002 020f 	and.w	r2, r2, #15
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
 800c5a0:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b

    pStatus->EraseOffset = (uint8_t)((sd_status[3] & 0x0300U) >> 8U);

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    pStatus->UhsSpeedGrade = (uint8_t)((sd_status[3] & 0x00F0U) >> 4U);
    pStatus->UhsAllocationUnitSize = (uint8_t)(sd_status[3] & 0x000FU) ;
 800c5a4:	746a      	strb	r2, [r5, #17]
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
 800c5a6:	74ab      	strb	r3, [r5, #18]
  */
HAL_StatusTypeDef HAL_SD_GetCardStatus(SD_HandleTypeDef *hsd, HAL_SD_CardStatusTypeDef *pStatus)
{
  uint32_t sd_status[16];
  uint32_t errorstate;
  HAL_StatusTypeDef status = HAL_OK;
 800c5a8:	2500      	movs	r5, #0
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
#endif
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 800c5aa:	f44f 7100 	mov.w	r1, #512	; 0x200
 800c5ae:	6820      	ldr	r0, [r4, #0]
 800c5b0:	f000 fc0a 	bl	800cdc8 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c5b4:	b130      	cbz	r0, 800c5c4 <HAL_SD_GetCardStatus+0x168>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800c5b6:	6823      	ldr	r3, [r4, #0]
 800c5b8:	4a05      	ldr	r2, [pc, #20]	; (800c5d0 <HAL_SD_GetCardStatus+0x174>)
 800c5ba:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode = errorstate;
    hsd->State = HAL_SD_STATE_READY;
 800c5bc:	2501      	movs	r5, #1
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
  if(errorstate != HAL_SD_ERROR_NONE)
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
    hsd->ErrorCode = errorstate;
 800c5be:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800c5c0:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
    status = HAL_ERROR;
  }

  return status;
}
 800c5c4:	4628      	mov	r0, r5
 800c5c6:	b016      	add	sp, #88	; 0x58
 800c5c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c5cc:	18000f3a 	.word	0x18000f3a
 800c5d0:	1fe00fff 	.word	0x1fe00fff

0800c5d4 <HAL_SD_GetCardInfo>:
  *         will contain the SD card status information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_GetCardInfo(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypeDef *pCardInfo)
{
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
 800c5d4:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 800c5d6:	600b      	str	r3, [r1, #0]
  pCardInfo->CardVersion  = (uint32_t)(hsd->SdCard.CardVersion);
 800c5d8:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800c5da:	604b      	str	r3, [r1, #4]
  pCardInfo->Class        = (uint32_t)(hsd->SdCard.Class);
 800c5dc:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800c5de:	608b      	str	r3, [r1, #8]
  pCardInfo->RelCardAdd   = (uint32_t)(hsd->SdCard.RelCardAdd);
 800c5e0:	6c83      	ldr	r3, [r0, #72]	; 0x48
 800c5e2:	60cb      	str	r3, [r1, #12]
  pCardInfo->BlockNbr     = (uint32_t)(hsd->SdCard.BlockNbr);
 800c5e4:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 800c5e6:	610b      	str	r3, [r1, #16]
  pCardInfo->BlockSize    = (uint32_t)(hsd->SdCard.BlockSize);
 800c5e8:	6d03      	ldr	r3, [r0, #80]	; 0x50
 800c5ea:	614b      	str	r3, [r1, #20]
  pCardInfo->LogBlockNbr  = (uint32_t)(hsd->SdCard.LogBlockNbr);
 800c5ec:	6d43      	ldr	r3, [r0, #84]	; 0x54
 800c5ee:	618b      	str	r3, [r1, #24]
  pCardInfo->LogBlockSize = (uint32_t)(hsd->SdCard.LogBlockSize);
 800c5f0:	6d83      	ldr	r3, [r0, #88]	; 0x58
 800c5f2:	61cb      	str	r3, [r1, #28]

  return HAL_OK;
}
 800c5f4:	2000      	movs	r0, #0
 800c5f6:	4770      	bx	lr

0800c5f8 <HAL_SD_ConfigWideBusOperation>:
  *            @arg SDMMC_BUS_WIDE_4B: 4-bit data transfer
  *            @arg SDMMC_BUS_WIDE_1B: 1-bit data transfer
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_ConfigWideBusOperation(SD_HandleTypeDef *hsd, uint32_t WideMode)
{
 800c5f8:	b530      	push	{r4, r5, lr}

  /* Check the parameters */
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));

  /* Change State */
  hsd->State = HAL_SD_STATE_BUSY;
 800c5fa:	2303      	movs	r3, #3
 800c5fc:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34

  if(hsd->SdCard.CardType != CARD_SECURED)
 800c600:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 800c602:	2b03      	cmp	r3, #3
  *            @arg SDMMC_BUS_WIDE_4B: 4-bit data transfer
  *            @arg SDMMC_BUS_WIDE_1B: 1-bit data transfer
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_ConfigWideBusOperation(SD_HandleTypeDef *hsd, uint32_t WideMode)
{
 800c604:	b08b      	sub	sp, #44	; 0x2c
 800c606:	4604      	mov	r4, r0
 800c608:	460d      	mov	r5, r1
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));

  /* Change State */
  hsd->State = HAL_SD_STATE_BUSY;

  if(hsd->SdCard.CardType != CARD_SECURED)
 800c60a:	d045      	beq.n	800c698 <HAL_SD_ConfigWideBusOperation+0xa0>
  {
    if(WideMode == SDMMC_BUS_WIDE_8B)
 800c60c:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 800c610:	d042      	beq.n	800c698 <HAL_SD_ConfigWideBusOperation+0xa0>
    {
      hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
    }
    else if(WideMode == SDMMC_BUS_WIDE_4B)
 800c612:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
 800c616:	d117      	bne.n	800c648 <HAL_SD_ConfigWideBusOperation+0x50>
  * @param  hsd pointer to SD handle
  * @retval error state
  */
static uint32_t SD_WideBus_Enable(SD_HandleTypeDef *hsd)
{
  uint32_t scr[2U] = {0UL, 0UL};
 800c618:	2100      	movs	r1, #0
  uint32_t errorstate;

  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800c61a:	6800      	ldr	r0, [r0, #0]
  * @param  hsd pointer to SD handle
  * @retval error state
  */
static uint32_t SD_WideBus_Enable(SD_HandleTypeDef *hsd)
{
  uint32_t scr[2U] = {0UL, 0UL};
 800c61c:	9104      	str	r1, [sp, #16]
 800c61e:	9105      	str	r1, [sp, #20]
  uint32_t errorstate;

  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800c620:	f000 faf3 	bl	800cc0a <SDMMC_GetResponse>
 800c624:	0180      	lsls	r0, r0, #6
 800c626:	d42a      	bmi.n	800c67e <HAL_SD_ConfigWideBusOperation+0x86>
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
  }

  /* Get SCR Register */
  errorstate = SD_FindSCR(hsd, scr);
 800c628:	a904      	add	r1, sp, #16
 800c62a:	4620      	mov	r0, r4
 800c62c:	f7ff fa1c 	bl	800ba68 <SD_FindSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c630:	bb50      	cbnz	r0, 800c688 <HAL_SD_ConfigWideBusOperation+0x90>
  {
    return errorstate;
  }

  /* If requested card supports wide bus operation */
  if((scr[1U] & SDMMC_WIDE_BUS_SUPPORT) != SDMMC_ALLZERO)
 800c632:	9b05      	ldr	r3, [sp, #20]
 800c634:	0359      	lsls	r1, r3, #13
 800c636:	d525      	bpl.n	800c684 <HAL_SD_ConfigWideBusOperation+0x8c>
  {
    /* Send CMD55 APP_CMD with argument as card's RCA.*/
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800c638:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800c63a:	6820      	ldr	r0, [r4, #0]
 800c63c:	0409      	lsls	r1, r1, #16
 800c63e:	f000 fcfc 	bl	800d03a <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 800c642:	bb08      	cbnz	r0, 800c688 <HAL_SD_ConfigWideBusOperation+0x90>
    {
      return errorstate;
    }

    /* Send ACMD6 APP_CMD with argument as 2 for wide bus mode */
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 2U);
 800c644:	2102      	movs	r1, #2
 800c646:	e016      	b.n	800c676 <HAL_SD_ConfigWideBusOperation+0x7e>
    {
      errorstate = SD_WideBus_Enable(hsd);

      hsd->ErrorCode |= errorstate;
    }
    else if(WideMode == SDMMC_BUS_WIDE_1B)
 800c648:	bb11      	cbnz	r1, 800c690 <HAL_SD_ConfigWideBusOperation+0x98>
static uint32_t SD_WideBus_Disable(SD_HandleTypeDef *hsd)
{
  uint32_t scr[2U] = {0UL, 0UL};
  uint32_t errorstate;

  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800c64a:	6800      	ldr	r0, [r0, #0]
  * @param  hsd Pointer to SD handle
  * @retval error state
  */
static uint32_t SD_WideBus_Disable(SD_HandleTypeDef *hsd)
{
  uint32_t scr[2U] = {0UL, 0UL};
 800c64c:	9104      	str	r1, [sp, #16]
 800c64e:	9105      	str	r1, [sp, #20]
  uint32_t errorstate;

  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800c650:	f000 fadb 	bl	800cc0a <SDMMC_GetResponse>
 800c654:	0182      	lsls	r2, r0, #6
 800c656:	d412      	bmi.n	800c67e <HAL_SD_ConfigWideBusOperation+0x86>
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
  }

  /* Get SCR Register */
  errorstate = SD_FindSCR(hsd, scr);
 800c658:	a904      	add	r1, sp, #16
 800c65a:	4620      	mov	r0, r4
 800c65c:	f7ff fa04 	bl	800ba68 <SD_FindSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c660:	b990      	cbnz	r0, 800c688 <HAL_SD_ConfigWideBusOperation+0x90>
  {
    return errorstate;
  }

  /* If requested card supports 1 bit mode operation */
  if((scr[1U] & SDMMC_SINGLE_BUS_SUPPORT) != SDMMC_ALLZERO)
 800c662:	9b05      	ldr	r3, [sp, #20]
 800c664:	03db      	lsls	r3, r3, #15
 800c666:	d50d      	bpl.n	800c684 <HAL_SD_ConfigWideBusOperation+0x8c>
  {
    /* Send CMD55 APP_CMD with argument as card's RCA */
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800c668:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800c66a:	6820      	ldr	r0, [r4, #0]
 800c66c:	0409      	lsls	r1, r1, #16
 800c66e:	f000 fce4 	bl	800d03a <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 800c672:	b948      	cbnz	r0, 800c688 <HAL_SD_ConfigWideBusOperation+0x90>
    {
      return errorstate;
    }

    /* Send ACMD6 APP_CMD with argument as 0 for single bus mode */
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 0U);
 800c674:	4629      	mov	r1, r5
 800c676:	6820      	ldr	r0, [r4, #0]
 800c678:	f000 fd76 	bl	800d168 <SDMMC_CmdBusWidth>
 800c67c:	e004      	b.n	800c688 <HAL_SD_ConfigWideBusOperation+0x90>
  uint32_t scr[2U] = {0UL, 0UL};
  uint32_t errorstate;

  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 800c67e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800c682:	e001      	b.n	800c688 <HAL_SD_ConfigWideBusOperation+0x90>

    return HAL_SD_ERROR_NONE;
  }
  else
  {
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 800c684:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
    }
    else if(WideMode == SDMMC_BUS_WIDE_1B)
    {
      errorstate = SD_WideBus_Disable(hsd);

      hsd->ErrorCode |= errorstate;
 800c688:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c68a:	4318      	orrs	r0, r3
 800c68c:	63a0      	str	r0, [r4, #56]	; 0x38
 800c68e:	e007      	b.n	800c6a0 <HAL_SD_ConfigWideBusOperation+0xa8>
    }
    else
    {
      /* WideMode is not a valid argument*/
      hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800c690:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800c692:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 800c696:	e002      	b.n	800c69e <HAL_SD_ConfigWideBusOperation+0xa6>
    }
  }
  else
  {
    /* MMC Card does not support this feature */
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800c698:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c69a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800c69e:	63a3      	str	r3, [r4, #56]	; 0x38
  }

  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
 800c6a0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c6a2:	b11b      	cbz	r3, 800c6ac <HAL_SD_ConfigWideBusOperation+0xb4>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800c6a4:	6823      	ldr	r3, [r4, #0]
 800c6a6:	4a2f      	ldr	r2, [pc, #188]	; (800c764 <HAL_SD_ConfigWideBusOperation+0x16c>)
 800c6a8:	639a      	str	r2, [r3, #56]	; 0x38
 800c6aa:	e047      	b.n	800c73c <HAL_SD_ConfigWideBusOperation+0x144>
    status = HAL_ERROR;
  }
  else
  {
    sdmmc_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC1);
 800c6ac:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800c6b0:	f7fd f862 	bl	8009778 <HAL_RCCEx_GetPeriphCLKFreq>
    if (sdmmc_clk != 0U)
 800c6b4:	2800      	cmp	r0, #0
 800c6b6:	d03d      	beq.n	800c734 <HAL_SD_ConfigWideBusOperation+0x13c>
    {
      /* Configure the SDMMC peripheral */
      Init.ClockEdge           = hsd->Init.ClockEdge;
 800c6b8:	6863      	ldr	r3, [r4, #4]
 800c6ba:	9304      	str	r3, [sp, #16]
#if !defined(STM32L4P5xx) && !defined(STM32L4Q5xx) && !defined(STM32L4R5xx) && !defined(STM32L4R7xx) && !defined(STM32L4R9xx) && !defined(STM32L4S5xx) && !defined(STM32L4S7xx) && !defined(STM32L4S9xx)
      Init.ClockBypass         = hsd->Init.ClockBypass;
#endif /* !STM32L4P5xx && !STM32L4Q5xx && !STM32L4R5xx && !STM32L4R7xx && !STM32L4R9xx && !STM32L4S5xx && !STM32L4S7xx && !STM32L4S9xx */
      Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
 800c6bc:	68a3      	ldr	r3, [r4, #8]
 800c6be:	9305      	str	r3, [sp, #20]
      Init.BusWide             = WideMode;
      Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
 800c6c0:	6923      	ldr	r3, [r4, #16]
 800c6c2:	9307      	str	r3, [sp, #28]

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
      /* Check if user Clock div < Normal speed 25Mhz, no change in Clockdiv */
      if (hsd->Init.ClockDiv >= (sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ)))
 800c6c4:	6963      	ldr	r3, [r4, #20]
 800c6c6:	4928      	ldr	r1, [pc, #160]	; (800c768 <HAL_SD_ConfigWideBusOperation+0x170>)
 800c6c8:	fbb0 f2f1 	udiv	r2, r0, r1
 800c6cc:	4293      	cmp	r3, r2
      Init.ClockEdge           = hsd->Init.ClockEdge;
#if !defined(STM32L4P5xx) && !defined(STM32L4Q5xx) && !defined(STM32L4R5xx) && !defined(STM32L4R7xx) && !defined(STM32L4R9xx) && !defined(STM32L4S5xx) && !defined(STM32L4S7xx) && !defined(STM32L4S9xx)
      Init.ClockBypass         = hsd->Init.ClockBypass;
#endif /* !STM32L4P5xx && !STM32L4Q5xx && !STM32L4R5xx && !STM32L4R7xx && !STM32L4R9xx && !STM32L4S5xx && !STM32L4S7xx && !STM32L4S9xx */
      Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
      Init.BusWide             = WideMode;
 800c6ce:	9506      	str	r5, [sp, #24]
      Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
      /* Check if user Clock div < Normal speed 25Mhz, no change in Clockdiv */
      if (hsd->Init.ClockDiv >= (sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ)))
 800c6d0:	d221      	bcs.n	800c716 <HAL_SD_ConfigWideBusOperation+0x11e>
      {
        Init.ClockDiv = hsd->Init.ClockDiv;
      }
      else if (hsd->SdCard.CardSpeed == CARD_ULTRA_HIGH_SPEED)
 800c6d2:	6de5      	ldr	r5, [r4, #92]	; 0x5c
 800c6d4:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
 800c6d8:	d01d      	beq.n	800c716 <HAL_SD_ConfigWideBusOperation+0x11e>
      {
        /* UltraHigh speed SD card,user Clock div */
        Init.ClockDiv = hsd->Init.ClockDiv;
      }
      else if (hsd->SdCard.CardSpeed == CARD_HIGH_SPEED)
 800c6da:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 800c6de:	d10e      	bne.n	800c6fe <HAL_SD_ConfigWideBusOperation+0x106>
      {
        /* High speed SD card, Max Frequency = 50Mhz */
        if (hsd->Init.ClockDiv == 0U)
 800c6e0:	b91b      	cbnz	r3, 800c6ea <HAL_SD_ConfigWideBusOperation+0xf2>
        {
          if (sdmmc_clk > SD_HIGH_SPEED_FREQ)
 800c6e2:	4288      	cmp	r0, r1
 800c6e4:	d806      	bhi.n	800c6f4 <HAL_SD_ConfigWideBusOperation+0xfc>
          {
            Init.ClockDiv = sdmmc_clk / (2U * SD_HIGH_SPEED_FREQ);
          }
          else
          {
            Init.ClockDiv = hsd->Init.ClockDiv;
 800c6e6:	2300      	movs	r3, #0
 800c6e8:	e015      	b.n	800c716 <HAL_SD_ConfigWideBusOperation+0x11e>
          }
        }
        else
        {
          if ((sdmmc_clk/(2U * hsd->Init.ClockDiv)) > SD_HIGH_SPEED_FREQ)
 800c6ea:	005a      	lsls	r2, r3, #1
 800c6ec:	fbb0 f2f2 	udiv	r2, r0, r2
 800c6f0:	428a      	cmp	r2, r1
 800c6f2:	d910      	bls.n	800c716 <HAL_SD_ConfigWideBusOperation+0x11e>
          {
            Init.ClockDiv = sdmmc_clk / (2U * SD_HIGH_SPEED_FREQ);
 800c6f4:	4b1d      	ldr	r3, [pc, #116]	; (800c76c <HAL_SD_ConfigWideBusOperation+0x174>)
 800c6f6:	fbb0 f0f3 	udiv	r0, r0, r3
 800c6fa:	9008      	str	r0, [sp, #32]
 800c6fc:	e00c      	b.n	800c718 <HAL_SD_ConfigWideBusOperation+0x120>
 800c6fe:	491c      	ldr	r1, [pc, #112]	; (800c770 <HAL_SD_ConfigWideBusOperation+0x178>)
        }
      }
      else
      {
        /* No High speed SD card, Max Frequency = 25Mhz */
        if (hsd->Init.ClockDiv == 0U)
 800c700:	b91b      	cbnz	r3, 800c70a <HAL_SD_ConfigWideBusOperation+0x112>
        {
          if (sdmmc_clk > SD_NORMAL_SPEED_FREQ)
 800c702:	4288      	cmp	r0, r1
 800c704:	d9ef      	bls.n	800c6e6 <HAL_SD_ConfigWideBusOperation+0xee>
          {
            Init.ClockDiv = sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ);
 800c706:	9208      	str	r2, [sp, #32]
 800c708:	e006      	b.n	800c718 <HAL_SD_ConfigWideBusOperation+0x120>
            Init.ClockDiv = hsd->Init.ClockDiv;
          }
        }
        else
        {
          if ((sdmmc_clk/(2U * hsd->Init.ClockDiv)) > SD_NORMAL_SPEED_FREQ)
 800c70a:	005d      	lsls	r5, r3, #1
 800c70c:	fbb0 f0f5 	udiv	r0, r0, r5
          {
            Init.ClockDiv = sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ);
 800c710:	4288      	cmp	r0, r1
 800c712:	bf88      	it	hi
 800c714:	4613      	movhi	r3, r2
 800c716:	9308      	str	r3, [sp, #32]
            Init.ClockDiv = hsd->Init.ClockDiv;
          }
        }
      }

      Init.Transceiver = hsd->Init.Transceiver;
 800c718:	69a3      	ldr	r3, [r4, #24]
 800c71a:	9309      	str	r3, [sp, #36]	; 0x24
      {
        Init.ClockDiv = hsd->Init.ClockDiv;
      }
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

      (void)SDMMC_Init(hsd->Instance, Init);
 800c71c:	ab0a      	add	r3, sp, #40	; 0x28
 800c71e:	e913 0007 	ldmdb	r3, {r0, r1, r2}
 800c722:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 800c726:	ab04      	add	r3, sp, #16
 800c728:	cb0e      	ldmia	r3, {r1, r2, r3}
 800c72a:	6820      	ldr	r0, [r4, #0]
 800c72c:	f000 fa1a 	bl	800cb64 <SDMMC_Init>
HAL_StatusTypeDef HAL_SD_ConfigWideBusOperation(SD_HandleTypeDef *hsd, uint32_t WideMode)
{
  SDMMC_InitTypeDef Init;
  uint32_t errorstate;
  uint32_t sdmmc_clk;
  HAL_StatusTypeDef status = HAL_OK;
 800c730:	2500      	movs	r5, #0
 800c732:	e004      	b.n	800c73e <HAL_SD_ConfigWideBusOperation+0x146>

      (void)SDMMC_Init(hsd->Instance, Init);
    }
    else
    {
      hsd->ErrorCode |= SDMMC_ERROR_INVALID_PARAMETER;
 800c734:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c736:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 800c73a:	63a3      	str	r3, [r4, #56]	; 0x38
      status = HAL_ERROR;
 800c73c:	2501      	movs	r5, #1
    }
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 800c73e:	f44f 7100 	mov.w	r1, #512	; 0x200
 800c742:	6820      	ldr	r0, [r4, #0]
 800c744:	f000 fb40 	bl	800cdc8 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c748:	b130      	cbz	r0, 800c758 <HAL_SD_ConfigWideBusOperation+0x160>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800c74a:	6823      	ldr	r3, [r4, #0]
 800c74c:	4a05      	ldr	r2, [pc, #20]	; (800c764 <HAL_SD_ConfigWideBusOperation+0x16c>)
 800c74e:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
 800c750:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c752:	4318      	orrs	r0, r3
 800c754:	63a0      	str	r0, [r4, #56]	; 0x38
    status = HAL_ERROR;
 800c756:	2501      	movs	r5, #1
  }

  /* Change State */
  hsd->State = HAL_SD_STATE_READY;
 800c758:	2301      	movs	r3, #1

  return status;
}
 800c75a:	4628      	mov	r0, r5
    hsd->ErrorCode |= errorstate;
    status = HAL_ERROR;
  }

  /* Change State */
  hsd->State = HAL_SD_STATE_READY;
 800c75c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

  return status;
}
 800c760:	b00b      	add	sp, #44	; 0x2c
 800c762:	bd30      	pop	{r4, r5, pc}
 800c764:	1fe00fff 	.word	0x1fe00fff
 800c768:	02faf080 	.word	0x02faf080
 800c76c:	05f5e100 	.word	0x05f5e100
 800c770:	017d7840 	.word	0x017d7840

0800c774 <HAL_SD_GetCardState>:
  {
    return HAL_SD_ERROR_PARAM;
  }

  /* Send Status command */
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800c774:	6c81      	ldr	r1, [r0, #72]	; 0x48
  * @brief  Gets the current sd card data state.
  * @param  hsd pointer to SD handle
  * @retval Card state
  */
HAL_SD_CardStateTypeDef HAL_SD_GetCardState(SD_HandleTypeDef *hsd)
{
 800c776:	b510      	push	{r4, lr}
  {
    return HAL_SD_ERROR_PARAM;
  }

  /* Send Status command */
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800c778:	0409      	lsls	r1, r1, #16
  * @brief  Gets the current sd card data state.
  * @param  hsd pointer to SD handle
  * @retval Card state
  */
HAL_SD_CardStateTypeDef HAL_SD_GetCardState(SD_HandleTypeDef *hsd)
{
 800c77a:	4604      	mov	r4, r0
  {
    return HAL_SD_ERROR_PARAM;
  }

  /* Send Status command */
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800c77c:	6800      	ldr	r0, [r0, #0]
 800c77e:	f000 fca8 	bl	800d0d2 <SDMMC_CmdSendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c782:	4601      	mov	r1, r0
 800c784:	b918      	cbnz	r0, 800c78e <HAL_SD_GetCardState+0x1a>
  {
    return errorstate;
  }

  /* Get SD card status */
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800c786:	6820      	ldr	r0, [r4, #0]
 800c788:	f000 fa3f 	bl	800cc0a <SDMMC_GetResponse>
 800c78c:	e003      	b.n	800c796 <HAL_SD_GetCardState+0x22>
  uint32_t resp1 = 0;

  errorstate = SD_SendStatus(hsd, &resp1);
  if(errorstate != HAL_SD_ERROR_NONE)
  {
    hsd->ErrorCode |= errorstate;
 800c78e:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800c790:	4301      	orrs	r1, r0
 800c792:	63a1      	str	r1, [r4, #56]	; 0x38
  */
HAL_SD_CardStateTypeDef HAL_SD_GetCardState(SD_HandleTypeDef *hsd)
{
  uint32_t cardstate;
  uint32_t errorstate;
  uint32_t resp1 = 0;
 800c794:	2000      	movs	r0, #0
    hsd->ErrorCode |= errorstate;
  }

  cardstate = ((resp1 >> 9U) & 0x0FU);

  return (HAL_SD_CardStateTypeDef)cardstate;
 800c796:	f3c0 2043 	ubfx	r0, r0, #9, #4
}
 800c79a:	bd10      	pop	{r4, pc}

0800c79c <HAL_SD_Init>:
            SD_HandleTypeDef and create the associated handle.
  * @param  hsd Pointer to the SD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_Init(SD_HandleTypeDef *hsd)
{
 800c79c:	b570      	push	{r4, r5, r6, lr}
  uint32_t speedgrade, unitsize;
  uint32_t tickstart;
#endif

  /* Check the SD handle allocation */
  if(hsd == NULL)
 800c79e:	4604      	mov	r4, r0
            SD_HandleTypeDef and create the associated handle.
  * @param  hsd Pointer to the SD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_Init(SD_HandleTypeDef *hsd)
{
 800c7a0:	b086      	sub	sp, #24
  uint32_t speedgrade, unitsize;
  uint32_t tickstart;
#endif

  /* Check the SD handle allocation */
  if(hsd == NULL)
 800c7a2:	b908      	cbnz	r0, 800c7a8 <HAL_SD_Init+0xc>
  {
    return HAL_ERROR;
 800c7a4:	2501      	movs	r5, #1
 800c7a6:	e04c      	b.n	800c842 <HAL_SD_Init+0xa6>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
  assert_param(IS_SDMMC_BUS_WIDE(hsd->Init.BusWide));
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
  assert_param(IS_SDMMC_CLKDIV(hsd->Init.ClockDiv));

  if(hsd->State == HAL_SD_STATE_RESET)
 800c7a8:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 800c7ac:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800c7b0:	b913      	cbnz	r3, 800c7b8 <HAL_SD_Init+0x1c>
  {
    /* Allocate lock resource and initialize it */
    hsd->Lock = HAL_UNLOCKED;
 800c7b2:	7702      	strb	r2, [r0, #28]

    /* Init the low level hardware */
    hsd->MspInitCallback(hsd);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_SD_MspInit(hsd);
 800c7b4:	f7ff fa46 	bl	800bc44 <HAL_SD_MspInit>
#endif /* USE_HAL_SD_REGISTER_CALLBACKS */
  }

  hsd->State = HAL_SD_STATE_BUSY;
 800c7b8:	2303      	movs	r3, #3
 800c7ba:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

  /* Initialize the Card parameters */
  if (HAL_SD_InitCard(hsd) != HAL_OK)
 800c7be:	4620      	mov	r0, r4
 800c7c0:	f7ff fcec 	bl	800c19c <HAL_SD_InitCard>
 800c7c4:	2800      	cmp	r0, #0
 800c7c6:	d1ed      	bne.n	800c7a4 <HAL_SD_Init+0x8>
  {
    return HAL_ERROR;
  }

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  if( HAL_SD_GetCardStatus(hsd, &CardStatus) != HAL_OK)
 800c7c8:	a901      	add	r1, sp, #4
 800c7ca:	4620      	mov	r0, r4
 800c7cc:	f7ff fe46 	bl	800c45c <HAL_SD_GetCardStatus>
 800c7d0:	2800      	cmp	r0, #0
 800c7d2:	d1e7      	bne.n	800c7a4 <HAL_SD_Init+0x8>
    return HAL_ERROR;
  }
  /* Get Initial Card Speed from Card Status*/
  speedgrade = CardStatus.UhsSpeedGrade;
  unitsize = CardStatus.UhsAllocationUnitSize;
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
 800c7d4:	6be1      	ldr	r1, [r4, #60]	; 0x3c
  if( HAL_SD_GetCardStatus(hsd, &CardStatus) != HAL_OK)
  {
    return HAL_ERROR;
  }
  /* Get Initial Card Speed from Card Status*/
  speedgrade = CardStatus.UhsSpeedGrade;
 800c7d6:	f89d 2014 	ldrb.w	r2, [sp, #20]
  unitsize = CardStatus.UhsAllocationUnitSize;
 800c7da:	f89d 3015 	ldrb.w	r3, [sp, #21]
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
 800c7de:	2901      	cmp	r1, #1
  if( HAL_SD_GetCardStatus(hsd, &CardStatus) != HAL_OK)
  {
    return HAL_ERROR;
  }
  /* Get Initial Card Speed from Card Status*/
  speedgrade = CardStatus.UhsSpeedGrade;
 800c7e0:	b2d2      	uxtb	r2, r2
  unitsize = CardStatus.UhsAllocationUnitSize;
 800c7e2:	b2db      	uxtb	r3, r3
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
 800c7e4:	d108      	bne.n	800c7f8 <HAL_SD_Init+0x5c>
 800c7e6:	b902      	cbnz	r2, 800c7ea <HAL_SD_Init+0x4e>
 800c7e8:	b113      	cbz	r3, 800c7f0 <HAL_SD_Init+0x54>
  {
    hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
 800c7ea:	f44f 7300 	mov.w	r3, #512	; 0x200
 800c7ee:	e001      	b.n	800c7f4 <HAL_SD_Init+0x58>
  }
  else
  {
    if (hsd->SdCard.CardType == CARD_SDHC_SDXC)
    {
      hsd->SdCard.CardSpeed  = CARD_HIGH_SPEED;
 800c7f0:	f44f 7380 	mov.w	r3, #256	; 0x100
 800c7f4:	65e3      	str	r3, [r4, #92]	; 0x5c
 800c7f6:	e000      	b.n	800c7fa <HAL_SD_Init+0x5e>
    }
    else
    {
      hsd->SdCard.CardSpeed  = CARD_NORMAL_SPEED;
 800c7f8:	65e0      	str	r0, [r4, #92]	; 0x5c
    }

  }
  /* Configure the bus wide */
  if(HAL_SD_ConfigWideBusOperation(hsd, hsd->Init.BusWide) != HAL_OK)
 800c7fa:	68e1      	ldr	r1, [r4, #12]
 800c7fc:	4620      	mov	r0, r4
 800c7fe:	f7ff fefb 	bl	800c5f8 <HAL_SD_ConfigWideBusOperation>
 800c802:	4605      	mov	r5, r0
 800c804:	2800      	cmp	r0, #0
 800c806:	d1cd      	bne.n	800c7a4 <HAL_SD_Init+0x8>
  {
    return HAL_ERROR;
  }

  /* Verify that SD card is ready to use after Initialization */
  tickstart = HAL_GetTick();
 800c808:	f7fa fc04 	bl	8007014 <HAL_GetTick>
 800c80c:	4606      	mov	r6, r0
  while((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
 800c80e:	4620      	mov	r0, r4
 800c810:	f7ff ffb0 	bl	800c774 <HAL_SD_GetCardState>
 800c814:	2804      	cmp	r0, #4
 800c816:	d00e      	beq.n	800c836 <HAL_SD_Init+0x9a>
  {
    if((HAL_GetTick()-tickstart) >=  SDMMC_DATATIMEOUT)
 800c818:	f7fa fbfc 	bl	8007014 <HAL_GetTick>
 800c81c:	1b80      	subs	r0, r0, r6
 800c81e:	3001      	adds	r0, #1
 800c820:	d1f5      	bne.n	800c80e <HAL_SD_Init+0x72>
    {
      hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
 800c822:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 800c826:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State= HAL_SD_STATE_READY;
 800c828:	2301      	movs	r3, #1
 800c82a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800c82e:	2300      	movs	r3, #0
 800c830:	6323      	str	r3, [r4, #48]	; 0x30
      return HAL_TIMEOUT;
 800c832:	2503      	movs	r5, #3
 800c834:	e005      	b.n	800c842 <HAL_SD_Init+0xa6>
    }
  }
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

  /* Initialize the error code */
  hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800c836:	2300      	movs	r3, #0
 800c838:	63a3      	str	r3, [r4, #56]	; 0x38

  /* Initialize the SD operation */
  hsd->Context = SD_CONTEXT_NONE;
 800c83a:	6323      	str	r3, [r4, #48]	; 0x30

  /* Initialize the SD state */
  hsd->State = HAL_SD_STATE_READY;
 800c83c:	2301      	movs	r3, #1
 800c83e:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

  return HAL_OK;
}
 800c842:	4628      	mov	r0, r5
 800c844:	b006      	add	sp, #24
 800c846:	bd70      	pop	{r4, r5, r6, pc}

0800c848 <SD_HighSpeed>:
  *         of PLL to have SDMMCCK clock between 50 and 120 MHz
  * @param  hsd SD handle
  * @retval SD Card error state
  */
uint32_t SD_HighSpeed(SD_HandleTypeDef *hsd)
{
 800c848:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t errorstate = HAL_SD_ERROR_NONE;
  SDMMC_DataInitTypeDef sdmmc_datainitstructure;
  uint32_t SD_hs[16]  = {0};
 800c84c:	2440      	movs	r4, #64	; 0x40
  *         of PLL to have SDMMCCK clock between 50 and 120 MHz
  * @param  hsd SD handle
  * @retval SD Card error state
  */
uint32_t SD_HighSpeed(SD_HandleTypeDef *hsd)
{
 800c84e:	b096      	sub	sp, #88	; 0x58
 800c850:	4606      	mov	r6, r0
  uint32_t errorstate = HAL_SD_ERROR_NONE;
  SDMMC_DataInitTypeDef sdmmc_datainitstructure;
  uint32_t SD_hs[16]  = {0};
 800c852:	4622      	mov	r2, r4
 800c854:	2100      	movs	r1, #0
 800c856:	a806      	add	r0, sp, #24
 800c858:	f000 fe39 	bl	800d4ce <memset>
  uint32_t count, loop = 0 ;
  uint32_t Timeout = HAL_GetTick();
 800c85c:	f7fa fbda 	bl	8007014 <HAL_GetTick>

  if(hsd->SdCard.CardSpeed == CARD_NORMAL_SPEED)
 800c860:	6df3      	ldr	r3, [r6, #92]	; 0x5c
{
  uint32_t errorstate = HAL_SD_ERROR_NONE;
  SDMMC_DataInitTypeDef sdmmc_datainitstructure;
  uint32_t SD_hs[16]  = {0};
  uint32_t count, loop = 0 ;
  uint32_t Timeout = HAL_GetTick();
 800c862:	4607      	mov	r7, r0

  if(hsd->SdCard.CardSpeed == CARD_NORMAL_SPEED)
 800c864:	2b00      	cmp	r3, #0
 800c866:	d05e      	beq.n	800c926 <SD_HighSpeed+0xde>
  {
     /* Standard Speed Card <= 12.5Mhz  */
     return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
  }

  if(hsd->SdCard.CardSpeed == CARD_HIGH_SPEED)
 800c868:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800c86c:	d145      	bne.n	800c8fa <SD_HighSpeed+0xb2>
  {
    /* Initialize the Data control register */
    hsd->Instance->DCTRL = 0;
 800c86e:	6830      	ldr	r0, [r6, #0]
 800c870:	2300      	movs	r3, #0
 800c872:	62c3      	str	r3, [r0, #44]	; 0x2c
    errorstate = SDMMC_CmdBlockLength(hsd->Instance, 64U);
 800c874:	4621      	mov	r1, r4
 800c876:	f000 faa7 	bl	800cdc8 <SDMMC_CmdBlockLength>

    if (errorstate != HAL_SD_ERROR_NONE)
 800c87a:	2800      	cmp	r0, #0
 800c87c:	d158      	bne.n	800c930 <SD_HighSpeed+0xe8>
    {
      return errorstate;
    }

    /* Configure the SD DPSM (Data Path State Machine) */
    sdmmc_datainitstructure.DataTimeOut   = SDMMC_DATATIMEOUT;
 800c87e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    sdmmc_datainitstructure.DataLength    = 64U;
 800c882:	e88d 0018 	stmia.w	sp, {r3, r4}
    sdmmc_datainitstructure.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B ;
 800c886:	2360      	movs	r3, #96	; 0x60
 800c888:	9302      	str	r3, [sp, #8]
    sdmmc_datainitstructure.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800c88a:	2302      	movs	r3, #2
 800c88c:	9303      	str	r3, [sp, #12]
    sdmmc_datainitstructure.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800c88e:	9004      	str	r0, [sp, #16]
    sdmmc_datainitstructure.DPSM          = SDMMC_DPSM_ENABLE;
 800c890:	2301      	movs	r3, #1

    if ( SDMMC_ConfigData(hsd->Instance, &sdmmc_datainitstructure) != HAL_OK)
 800c892:	4669      	mov	r1, sp
 800c894:	6830      	ldr	r0, [r6, #0]
    sdmmc_datainitstructure.DataTimeOut   = SDMMC_DATATIMEOUT;
    sdmmc_datainitstructure.DataLength    = 64U;
    sdmmc_datainitstructure.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B ;
    sdmmc_datainitstructure.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
    sdmmc_datainitstructure.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
    sdmmc_datainitstructure.DPSM          = SDMMC_DPSM_ENABLE;
 800c896:	9305      	str	r3, [sp, #20]

    if ( SDMMC_ConfigData(hsd->Instance, &sdmmc_datainitstructure) != HAL_OK)
 800c898:	f000 f9ba 	bl	800cc10 <SDMMC_ConfigData>
 800c89c:	2800      	cmp	r0, #0
 800c89e:	d145      	bne.n	800c92c <SD_HighSpeed+0xe4>
    {
      return (HAL_SD_ERROR_GENERAL_UNKNOWN_ERR);
    }


    errorstate = SDMMC_CmdSwitch(hsd->Instance,SDMMC_SDR25_SWITCH_PATTERN);
 800c8a0:	4925      	ldr	r1, [pc, #148]	; (800c938 <SD_HighSpeed+0xf0>)
 800c8a2:	6830      	ldr	r0, [r6, #0]
 800c8a4:	f000 fc47 	bl	800d136 <SDMMC_CmdSwitch>
    if(errorstate != HAL_SD_ERROR_NONE)
 800c8a8:	2800      	cmp	r0, #0
 800c8aa:	d141      	bne.n	800c930 <SD_HighSpeed+0xe8>
 800c8ac:	4604      	mov	r4, r0
    {
      return errorstate;
    }

    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND| SDMMC_FLAG_DATAEND ))
 800c8ae:	6833      	ldr	r3, [r6, #0]
 800c8b0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c8b2:	f240 552a 	movw	r5, #1322	; 0x52a
 800c8b6:	4015      	ands	r5, r2
 800c8b8:	b9d5      	cbnz	r5, 800c8f0 <SD_HighSpeed+0xa8>
    {
      if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
 800c8ba:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800c8bc:	041b      	lsls	r3, r3, #16
 800c8be:	d50b      	bpl.n	800c8d8 <SD_HighSpeed+0x90>
 800c8c0:	ab06      	add	r3, sp, #24
 800c8c2:	eb03 1844 	add.w	r8, r3, r4, lsl #5
      {
        for (count = 0U; count < 8U; count++)
        {
          SD_hs[(8U*loop)+count]  = SDMMC_ReadFIFO(hsd->Instance);
 800c8c6:	6830      	ldr	r0, [r6, #0]
 800c8c8:	f000 f966 	bl	800cb98 <SDMMC_ReadFIFO>
 800c8cc:	f848 0025 	str.w	r0, [r8, r5, lsl #2]

    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND| SDMMC_FLAG_DATAEND ))
    {
      if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
      {
        for (count = 0U; count < 8U; count++)
 800c8d0:	3501      	adds	r5, #1
 800c8d2:	2d08      	cmp	r5, #8
 800c8d4:	d1f7      	bne.n	800c8c6 <SD_HighSpeed+0x7e>
        {
          SD_hs[(8U*loop)+count]  = SDMMC_ReadFIFO(hsd->Instance);
        }
        loop ++;
 800c8d6:	3401      	adds	r4, #1
      }

      if((HAL_GetTick()-Timeout) >=  SDMMC_DATATIMEOUT)
 800c8d8:	f7fa fb9c 	bl	8007014 <HAL_GetTick>
 800c8dc:	1bc0      	subs	r0, r0, r7
 800c8de:	3001      	adds	r0, #1
 800c8e0:	d1e5      	bne.n	800c8ae <SD_HighSpeed+0x66>
      {
        hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
 800c8e2:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
        hsd->State= HAL_SD_STATE_READY;
 800c8e6:	2301      	movs	r3, #1
        loop ++;
      }

      if((HAL_GetTick()-Timeout) >=  SDMMC_DATATIMEOUT)
      {
        hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
 800c8e8:	63b0      	str	r0, [r6, #56]	; 0x38
        hsd->State= HAL_SD_STATE_READY;
 800c8ea:	f886 3034 	strb.w	r3, [r6, #52]	; 0x34
        return HAL_SD_ERROR_TIMEOUT;
 800c8ee:	e01f      	b.n	800c930 <SD_HighSpeed+0xe8>
      }
    }

    if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 800c8f0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c8f2:	0710      	lsls	r0, r2, #28
 800c8f4:	d503      	bpl.n	800c8fe <SD_HighSpeed+0xb6>
    {
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
 800c8f6:	2208      	movs	r2, #8
 800c8f8:	639a      	str	r2, [r3, #56]	; 0x38

      return errorstate;
 800c8fa:	2000      	movs	r0, #0
 800c8fc:	e018      	b.n	800c930 <SD_HighSpeed+0xe8>
    }
    else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800c8fe:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c900:	0791      	lsls	r1, r2, #30
 800c902:	d501      	bpl.n	800c908 <SD_HighSpeed+0xc0>
    {
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
 800c904:	2002      	movs	r0, #2
 800c906:	e003      	b.n	800c910 <SD_HighSpeed+0xc8>

      errorstate = SDMMC_ERROR_DATA_CRC_FAIL;

      return errorstate;
    }
    else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 800c908:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c90a:	0692      	lsls	r2, r2, #26
 800c90c:	d502      	bpl.n	800c914 <SD_HighSpeed+0xcc>
    {
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
 800c90e:	2020      	movs	r0, #32
 800c910:	6398      	str	r0, [r3, #56]	; 0x38

      errorstate = SDMMC_ERROR_RX_OVERRUN;

      return errorstate;
 800c912:	e00d      	b.n	800c930 <SD_HighSpeed+0xe8>
    {
      /* No error flag set */
    }

    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800c914:	4a09      	ldr	r2, [pc, #36]	; (800c93c <SD_HighSpeed+0xf4>)
 800c916:	639a      	str	r2, [r3, #56]	; 0x38

    /* Test if the switch mode HS is ok */
    if ((((uint8_t*)SD_hs)[13] & 2U) != 2U)
 800c918:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
 800c91c:	079b      	lsls	r3, r3, #30
 800c91e:	d4ec      	bmi.n	800c8fa <SD_HighSpeed+0xb2>
    {
      errorstate = SDMMC_ERROR_UNSUPPORTED_FEATURE;
 800c920:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 800c924:	e004      	b.n	800c930 <SD_HighSpeed+0xe8>
  uint32_t Timeout = HAL_GetTick();

  if(hsd->SdCard.CardSpeed == CARD_NORMAL_SPEED)
  {
     /* Standard Speed Card <= 12.5Mhz  */
     return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 800c926:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 800c92a:	e001      	b.n	800c930 <SD_HighSpeed+0xe8>
    sdmmc_datainitstructure.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
    sdmmc_datainitstructure.DPSM          = SDMMC_DPSM_ENABLE;

    if ( SDMMC_ConfigData(hsd->Instance, &sdmmc_datainitstructure) != HAL_OK)
    {
      return (HAL_SD_ERROR_GENERAL_UNKNOWN_ERR);
 800c92c:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    }

  }

  return errorstate;
}
 800c930:	b016      	add	sp, #88	; 0x58
 800c932:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c936:	bf00      	nop
 800c938:	80ffff01 	.word	0x80ffff01
 800c93c:	18000f3a 	.word	0x18000f3a

0800c940 <HAL_SD_ConfigSpeedBusOperation>:
  *            @arg SDMMC_SPEED_MODE_ULTRA: Ultra high speed mode
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_SD_ConfigSpeedBusOperation(SD_HandleTypeDef *hsd, uint32_t SpeedMode)
{
 800c940:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  HAL_StatusTypeDef status = HAL_OK;

  /* Check the parameters */
  assert_param(IS_SDMMC_SPEED_MODE(SpeedMode));
  /* Change State */
  hsd->State = HAL_SD_STATE_BUSY;
 800c944:	2303      	movs	r3, #3
 800c946:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34

  if(hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE)
 800c94a:	6983      	ldr	r3, [r0, #24]
 800c94c:	2b01      	cmp	r3, #1
  *            @arg SDMMC_SPEED_MODE_ULTRA: Ultra high speed mode
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_SD_ConfigSpeedBusOperation(SD_HandleTypeDef *hsd, uint32_t SpeedMode)
{
 800c94e:	b096      	sub	sp, #88	; 0x58
 800c950:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_SDMMC_SPEED_MODE(SpeedMode));
  /* Change State */
  hsd->State = HAL_SD_STATE_BUSY;

  if(hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE)
 800c952:	f040 80ae 	bne.w	800cab2 <HAL_SD_ConfigSpeedBusOperation+0x172>
  {
    switch (SpeedMode)
 800c956:	2904      	cmp	r1, #4
 800c958:	f200 80ce 	bhi.w	800caf8 <HAL_SD_ConfigSpeedBusOperation+0x1b8>
 800c95c:	e8df f011 	tbh	[pc, r1, lsl #1]
 800c960:	00d20005 	.word	0x00d20005
 800c964:	001b00ba 	.word	0x001b00ba
 800c968:	002c      	.short	0x002c
    {
      case SDMMC_SPEED_MODE_AUTO:
      {
        if ((hsd->SdCard.CardSpeed  == CARD_ULTRA_HIGH_SPEED) ||
 800c96a:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 800c96c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800c970:	d002      	beq.n	800c978 <HAL_SD_ConfigSpeedBusOperation+0x38>
 800c972:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 800c974:	2a01      	cmp	r2, #1
 800c976:	d10b      	bne.n	800c990 <HAL_SD_ConfigSpeedBusOperation+0x50>
            (hsd->SdCard.CardType == CARD_SDHC_SDXC))
        {
          hsd->Instance->CLKCR |= 0x00100000U;
 800c978:	6822      	ldr	r2, [r4, #0]
 800c97a:	6853      	ldr	r3, [r2, #4]
 800c97c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800c980:	6053      	str	r3, [r2, #4]
          /* Enable Ultra High Speed */
          if (SD_UltraHighSpeed(hsd) != HAL_SD_ERROR_NONE)
 800c982:	4620      	mov	r0, r4
 800c984:	f7ff f8d8 	bl	800bb38 <SD_UltraHighSpeed>
 800c988:	2800      	cmp	r0, #0
 800c98a:	f000 80bb 	beq.w	800cb04 <HAL_SD_ConfigSpeedBusOperation+0x1c4>
 800c98e:	e0ab      	b.n	800cae8 <HAL_SD_ConfigSpeedBusOperation+0x1a8>
              hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
              status = HAL_ERROR;
            }
          }
        }
        else if (hsd->SdCard.CardSpeed  == CARD_HIGH_SPEED)
 800c990:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800c994:	e09c      	b.n	800cad0 <HAL_SD_ConfigSpeedBusOperation+0x190>
        break;
      }

      case SDMMC_SPEED_MODE_ULTRA:
      {
        if ((hsd->SdCard.CardSpeed  == CARD_ULTRA_HIGH_SPEED) ||
 800c996:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 800c998:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800c99c:	d003      	beq.n	800c9a6 <HAL_SD_ConfigSpeedBusOperation+0x66>
 800c99e:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 800c9a0:	2b01      	cmp	r3, #1
 800c9a2:	f040 80a5 	bne.w	800caf0 <HAL_SD_ConfigSpeedBusOperation+0x1b0>
            (hsd->SdCard.CardType == CARD_SDHC_SDXC))
        {
          hsd->Instance->CLKCR |= 0x00100000U;
 800c9a6:	6822      	ldr	r2, [r4, #0]
 800c9a8:	6853      	ldr	r3, [r2, #4]
 800c9aa:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800c9ae:	6053      	str	r3, [r2, #4]
          /* Enable UltraHigh Speed */
          if (SD_UltraHighSpeed(hsd) != HAL_SD_ERROR_NONE)
 800c9b0:	4620      	mov	r0, r4
 800c9b2:	f7ff f8c1 	bl	800bb38 <SD_UltraHighSpeed>
 800c9b6:	e09a      	b.n	800caee <HAL_SD_ConfigSpeedBusOperation+0x1ae>
        break;
      }

      case SDMMC_SPEED_MODE_DDR:
      {
        if ((hsd->SdCard.CardSpeed  == CARD_ULTRA_HIGH_SPEED) ||
 800c9b8:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 800c9ba:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800c9be:	d003      	beq.n	800c9c8 <HAL_SD_ConfigSpeedBusOperation+0x88>
 800c9c0:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 800c9c2:	2b01      	cmp	r3, #1
 800c9c4:	f040 8094 	bne.w	800caf0 <HAL_SD_ConfigSpeedBusOperation+0x1b0>
            (hsd->SdCard.CardType == CARD_SDHC_SDXC))
        {
          hsd->Instance->CLKCR |= 0x00100000U;
 800c9c8:	6822      	ldr	r2, [r4, #0]
 800c9ca:	6853      	ldr	r3, [r2, #4]
  */
static uint32_t SD_DDR_Mode(SD_HandleTypeDef *hsd)
{
  uint32_t errorstate = HAL_SD_ERROR_NONE;
  SDMMC_DataInitTypeDef sdmmc_datainitstructure;
  uint32_t SD_hs[16]  = {0};
 800c9cc:	2540      	movs	r5, #64	; 0x40
      case SDMMC_SPEED_MODE_DDR:
      {
        if ((hsd->SdCard.CardSpeed  == CARD_ULTRA_HIGH_SPEED) ||
            (hsd->SdCard.CardType == CARD_SDHC_SDXC))
        {
          hsd->Instance->CLKCR |= 0x00100000U;
 800c9ce:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800c9d2:	6053      	str	r3, [r2, #4]
  */
static uint32_t SD_DDR_Mode(SD_HandleTypeDef *hsd)
{
  uint32_t errorstate = HAL_SD_ERROR_NONE;
  SDMMC_DataInitTypeDef sdmmc_datainitstructure;
  uint32_t SD_hs[16]  = {0};
 800c9d4:	2100      	movs	r1, #0
 800c9d6:	462a      	mov	r2, r5
 800c9d8:	a806      	add	r0, sp, #24
 800c9da:	f000 fd78 	bl	800d4ce <memset>
  uint32_t count, loop = 0 ;
  uint32_t Timeout = HAL_GetTick();
 800c9de:	f7fa fb19 	bl	8007014 <HAL_GetTick>

  if(hsd->SdCard.CardSpeed == CARD_NORMAL_SPEED)
 800c9e2:	6de3      	ldr	r3, [r4, #92]	; 0x5c
{
  uint32_t errorstate = HAL_SD_ERROR_NONE;
  SDMMC_DataInitTypeDef sdmmc_datainitstructure;
  uint32_t SD_hs[16]  = {0};
  uint32_t count, loop = 0 ;
  uint32_t Timeout = HAL_GetTick();
 800c9e4:	4607      	mov	r7, r0

  if(hsd->SdCard.CardSpeed == CARD_NORMAL_SPEED)
 800c9e6:	2b00      	cmp	r3, #0
 800c9e8:	f000 8082 	beq.w	800caf0 <HAL_SD_ConfigSpeedBusOperation+0x1b0>
  {
     /* Standard Speed Card <= 12.5Mhz  */
     return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
  }

  if((hsd->SdCard.CardSpeed == CARD_ULTRA_HIGH_SPEED) &&
 800c9ec:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800c9f0:	f040 8088 	bne.w	800cb04 <HAL_SD_ConfigSpeedBusOperation+0x1c4>
 800c9f4:	69a6      	ldr	r6, [r4, #24]
 800c9f6:	2e01      	cmp	r6, #1
 800c9f8:	f040 8084 	bne.w	800cb04 <HAL_SD_ConfigSpeedBusOperation+0x1c4>
     (hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE))
  {
    /* Initialize the Data control register */
    hsd->Instance->DCTRL = 0;
 800c9fc:	6820      	ldr	r0, [r4, #0]
 800c9fe:	2300      	movs	r3, #0
 800ca00:	62c3      	str	r3, [r0, #44]	; 0x2c
    errorstate = SDMMC_CmdBlockLength(hsd->Instance, 64U);
 800ca02:	4629      	mov	r1, r5
 800ca04:	f000 f9e0 	bl	800cdc8 <SDMMC_CmdBlockLength>

    if (errorstate != HAL_SD_ERROR_NONE)
 800ca08:	2800      	cmp	r0, #0
 800ca0a:	d170      	bne.n	800caee <HAL_SD_ConfigSpeedBusOperation+0x1ae>
    {
      return errorstate;
    }

    /* Configure the SD DPSM (Data Path State Machine) */
    sdmmc_datainitstructure.DataTimeOut   = SDMMC_DATATIMEOUT;
 800ca0c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    sdmmc_datainitstructure.DataLength    = 64U;
 800ca10:	e88d 0028 	stmia.w	sp, {r3, r5}
    sdmmc_datainitstructure.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B ;
 800ca14:	2360      	movs	r3, #96	; 0x60
 800ca16:	9302      	str	r3, [sp, #8]
    sdmmc_datainitstructure.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
    sdmmc_datainitstructure.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800ca18:	9004      	str	r0, [sp, #16]

    /* Configure the SD DPSM (Data Path State Machine) */
    sdmmc_datainitstructure.DataTimeOut   = SDMMC_DATATIMEOUT;
    sdmmc_datainitstructure.DataLength    = 64U;
    sdmmc_datainitstructure.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B ;
    sdmmc_datainitstructure.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800ca1a:	2302      	movs	r3, #2
    sdmmc_datainitstructure.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
    sdmmc_datainitstructure.DPSM          = SDMMC_DPSM_ENABLE;

    if ( SDMMC_ConfigData(hsd->Instance, &sdmmc_datainitstructure) != HAL_OK)
 800ca1c:	4669      	mov	r1, sp
 800ca1e:	6820      	ldr	r0, [r4, #0]

    /* Configure the SD DPSM (Data Path State Machine) */
    sdmmc_datainitstructure.DataTimeOut   = SDMMC_DATATIMEOUT;
    sdmmc_datainitstructure.DataLength    = 64U;
    sdmmc_datainitstructure.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B ;
    sdmmc_datainitstructure.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800ca20:	9303      	str	r3, [sp, #12]
    sdmmc_datainitstructure.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
    sdmmc_datainitstructure.DPSM          = SDMMC_DPSM_ENABLE;
 800ca22:	9605      	str	r6, [sp, #20]

    if ( SDMMC_ConfigData(hsd->Instance, &sdmmc_datainitstructure) != HAL_OK)
 800ca24:	f000 f8f4 	bl	800cc10 <SDMMC_ConfigData>
 800ca28:	2800      	cmp	r0, #0
 800ca2a:	d161      	bne.n	800caf0 <HAL_SD_ConfigSpeedBusOperation+0x1b0>
    {
      return (HAL_SD_ERROR_GENERAL_UNKNOWN_ERR);
    }

    errorstate = SDMMC_CmdSwitch(hsd->Instance, SDMMC_DDR50_SWITCH_PATTERN);
 800ca2c:	494a      	ldr	r1, [pc, #296]	; (800cb58 <HAL_SD_ConfigSpeedBusOperation+0x218>)
 800ca2e:	6820      	ldr	r0, [r4, #0]
 800ca30:	f000 fb81 	bl	800d136 <SDMMC_CmdSwitch>
    if(errorstate != HAL_SD_ERROR_NONE)
 800ca34:	2800      	cmp	r0, #0
 800ca36:	d15a      	bne.n	800caee <HAL_SD_ConfigSpeedBusOperation+0x1ae>
 800ca38:	4605      	mov	r5, r0
    {
      return errorstate;
    }

    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND| SDMMC_FLAG_DATAEND ))
 800ca3a:	6823      	ldr	r3, [r4, #0]
 800ca3c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800ca3e:	f240 562a 	movw	r6, #1322	; 0x52a
 800ca42:	4016      	ands	r6, r2
 800ca44:	b9d6      	cbnz	r6, 800ca7c <HAL_SD_ConfigSpeedBusOperation+0x13c>
    {
      if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
 800ca46:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ca48:	041b      	lsls	r3, r3, #16
 800ca4a:	d50b      	bpl.n	800ca64 <HAL_SD_ConfigSpeedBusOperation+0x124>
 800ca4c:	ab06      	add	r3, sp, #24
 800ca4e:	eb03 1845 	add.w	r8, r3, r5, lsl #5
      {
        for (count = 0U; count < 8U; count++)
        {
          SD_hs[(8U*loop)+count]  = SDMMC_ReadFIFO(hsd->Instance);
 800ca52:	6820      	ldr	r0, [r4, #0]
 800ca54:	f000 f8a0 	bl	800cb98 <SDMMC_ReadFIFO>
 800ca58:	f848 0026 	str.w	r0, [r8, r6, lsl #2]

    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND| SDMMC_FLAG_DATAEND ))
    {
      if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
      {
        for (count = 0U; count < 8U; count++)
 800ca5c:	3601      	adds	r6, #1
 800ca5e:	2e08      	cmp	r6, #8
 800ca60:	d1f7      	bne.n	800ca52 <HAL_SD_ConfigSpeedBusOperation+0x112>
        {
          SD_hs[(8U*loop)+count]  = SDMMC_ReadFIFO(hsd->Instance);
        }
        loop ++;
 800ca62:	3501      	adds	r5, #1
      }

      if((HAL_GetTick()-Timeout) >=  SDMMC_DATATIMEOUT)
 800ca64:	f7fa fad6 	bl	8007014 <HAL_GetTick>
 800ca68:	1bc0      	subs	r0, r0, r7
 800ca6a:	3001      	adds	r0, #1
 800ca6c:	d1e5      	bne.n	800ca3a <HAL_SD_ConfigSpeedBusOperation+0xfa>
      {
        hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
 800ca6e:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 800ca72:	63a3      	str	r3, [r4, #56]	; 0x38
        hsd->State= HAL_SD_STATE_READY;
 800ca74:	2301      	movs	r3, #1
 800ca76:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800ca7a:	e039      	b.n	800caf0 <HAL_SD_ConfigSpeedBusOperation+0x1b0>
        return HAL_SD_ERROR_TIMEOUT;
      }
    }

    if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 800ca7c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800ca7e:	0710      	lsls	r0, r2, #28
 800ca80:	d502      	bpl.n	800ca88 <HAL_SD_ConfigSpeedBusOperation+0x148>
    {
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
 800ca82:	2208      	movs	r2, #8
 800ca84:	639a      	str	r2, [r3, #56]	; 0x38
 800ca86:	e03d      	b.n	800cb04 <HAL_SD_ConfigSpeedBusOperation+0x1c4>

      return errorstate;
    }
    else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800ca88:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800ca8a:	0791      	lsls	r1, r2, #30
 800ca8c:	d501      	bpl.n	800ca92 <HAL_SD_ConfigSpeedBusOperation+0x152>
    {
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
 800ca8e:	2202      	movs	r2, #2
 800ca90:	e003      	b.n	800ca9a <HAL_SD_ConfigSpeedBusOperation+0x15a>

      errorstate = SDMMC_ERROR_DATA_CRC_FAIL;

      return errorstate;
    }
    else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 800ca92:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800ca94:	0692      	lsls	r2, r2, #26
 800ca96:	d502      	bpl.n	800ca9e <HAL_SD_ConfigSpeedBusOperation+0x15e>
    {
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
 800ca98:	2220      	movs	r2, #32
 800ca9a:	639a      	str	r2, [r3, #56]	; 0x38
 800ca9c:	e028      	b.n	800caf0 <HAL_SD_ConfigSpeedBusOperation+0x1b0>
    {
      /* No error flag set */
    }

    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800ca9e:	4a2f      	ldr	r2, [pc, #188]	; (800cb5c <HAL_SD_ConfigSpeedBusOperation+0x21c>)
 800caa0:	639a      	str	r2, [r3, #56]	; 0x38

    /* Test if the switch mode  is ok */
    if ((((uint8_t*)SD_hs)[13] & 2U) != 2U)
 800caa2:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
 800caa6:	079b      	lsls	r3, r3, #30
 800caa8:	d522      	bpl.n	800caf0 <HAL_SD_ConfigSpeedBusOperation+0x1b0>
    else
    {
#if defined (USE_HAL_SD_REGISTER_CALLBACKS) && (USE_HAL_SD_REGISTER_CALLBACKS == 1U)
      hsd->DriveTransceiver_1_8V_Callback(SET);
#else
      HAL_SDEx_DriveTransceiver_1_8V_Callback(SET);
 800caaa:	2001      	movs	r0, #1
 800caac:	f7fa fb22 	bl	80070f4 <HAL_SDEx_DriveTransceiver_1_8V_Callback>
 800cab0:	e028      	b.n	800cb04 <HAL_SD_ConfigSpeedBusOperation+0x1c4>
        break;
    }
  }
  else
  {
    switch (SpeedMode)
 800cab2:	2901      	cmp	r1, #1
 800cab4:	d026      	beq.n	800cb04 <HAL_SD_ConfigSpeedBusOperation+0x1c4>
 800cab6:	d302      	bcc.n	800cabe <HAL_SD_ConfigSpeedBusOperation+0x17e>
 800cab8:	2902      	cmp	r1, #2
 800caba:	d00b      	beq.n	800cad4 <HAL_SD_ConfigSpeedBusOperation+0x194>
 800cabc:	e01c      	b.n	800caf8 <HAL_SD_ConfigSpeedBusOperation+0x1b8>
    {
      case SDMMC_SPEED_MODE_AUTO:
      {
        if ((hsd->SdCard.CardSpeed  == CARD_ULTRA_HIGH_SPEED) ||
 800cabe:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 800cac0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800cac4:	d010      	beq.n	800cae8 <HAL_SD_ConfigSpeedBusOperation+0x1a8>
 800cac6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800caca:	d00d      	beq.n	800cae8 <HAL_SD_ConfigSpeedBusOperation+0x1a8>
            (hsd->SdCard.CardSpeed  == CARD_HIGH_SPEED) ||
 800cacc:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 800cace:	2b01      	cmp	r3, #1
 800cad0:	d118      	bne.n	800cb04 <HAL_SD_ConfigSpeedBusOperation+0x1c4>
 800cad2:	e009      	b.n	800cae8 <HAL_SD_ConfigSpeedBusOperation+0x1a8>
        break;
      }

      case SDMMC_SPEED_MODE_HIGH:
      {
        if ((hsd->SdCard.CardSpeed  == CARD_ULTRA_HIGH_SPEED) ||
 800cad4:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800cad6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800cada:	d005      	beq.n	800cae8 <HAL_SD_ConfigSpeedBusOperation+0x1a8>
 800cadc:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800cae0:	d002      	beq.n	800cae8 <HAL_SD_ConfigSpeedBusOperation+0x1a8>
            (hsd->SdCard.CardSpeed  == CARD_HIGH_SPEED) ||
 800cae2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800cae4:	2b01      	cmp	r3, #1
 800cae6:	d103      	bne.n	800caf0 <HAL_SD_ConfigSpeedBusOperation+0x1b0>
            (hsd->SdCard.CardType == CARD_SDHC_SDXC))
        {
          /* Enable High Speed */
          if (SD_HighSpeed(hsd) != HAL_SD_ERROR_NONE)
 800cae8:	4620      	mov	r0, r4
 800caea:	f7ff fead 	bl	800c848 <SD_HighSpeed>
 800caee:	b148      	cbz	r0, 800cb04 <HAL_SD_ConfigSpeedBusOperation+0x1c4>
            status = HAL_ERROR;
          }
        }
        else
        {
          hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800caf0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800caf2:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800caf6:	e002      	b.n	800cafe <HAL_SD_ConfigSpeedBusOperation+0x1be>
      case SDMMC_SPEED_MODE_DEFAULT:
        break;

      case SDMMC_SPEED_MODE_ULTRA: /*not valid without transceiver*/
      default:
        hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800caf8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800cafa:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 800cafe:	63a3      	str	r3, [r4, #56]	; 0x38
        status = HAL_ERROR;
 800cb00:	2501      	movs	r5, #1
        break;
 800cb02:	e000      	b.n	800cb06 <HAL_SD_ConfigSpeedBusOperation+0x1c6>

HAL_StatusTypeDef HAL_SD_ConfigSpeedBusOperation(SD_HandleTypeDef *hsd, uint32_t SpeedMode)
{
  uint32_t tickstart;
  uint32_t errorstate;
  HAL_StatusTypeDef status = HAL_OK;
 800cb04:	2500      	movs	r5, #0
        break;
    }
  }

  /* Verify that SD card is ready to use after Speed mode switch*/
  tickstart = HAL_GetTick();
 800cb06:	f7fa fa85 	bl	8007014 <HAL_GetTick>
 800cb0a:	4606      	mov	r6, r0
  while ((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
 800cb0c:	4620      	mov	r0, r4
 800cb0e:	f7ff fe31 	bl	800c774 <HAL_SD_GetCardState>
 800cb12:	2804      	cmp	r0, #4
 800cb14:	d00c      	beq.n	800cb30 <HAL_SD_ConfigSpeedBusOperation+0x1f0>
  {
    if ((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 800cb16:	f7fa fa7d 	bl	8007014 <HAL_GetTick>
 800cb1a:	1b80      	subs	r0, r0, r6
 800cb1c:	3001      	adds	r0, #1
 800cb1e:	d1f5      	bne.n	800cb0c <HAL_SD_ConfigSpeedBusOperation+0x1cc>
    {
      hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
 800cb20:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 800cb24:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800cb26:	2301      	movs	r3, #1
 800cb28:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      return HAL_TIMEOUT;
 800cb2c:	2003      	movs	r0, #3
 800cb2e:	e010      	b.n	800cb52 <HAL_SD_ConfigSpeedBusOperation+0x212>
    }
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 800cb30:	f44f 7100 	mov.w	r1, #512	; 0x200
 800cb34:	6820      	ldr	r0, [r4, #0]
 800cb36:	f000 f947 	bl	800cdc8 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800cb3a:	b130      	cbz	r0, 800cb4a <HAL_SD_ConfigSpeedBusOperation+0x20a>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cb3c:	6823      	ldr	r3, [r4, #0]
 800cb3e:	4a08      	ldr	r2, [pc, #32]	; (800cb60 <HAL_SD_ConfigSpeedBusOperation+0x220>)
 800cb40:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
 800cb42:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800cb44:	4318      	orrs	r0, r3
 800cb46:	63a0      	str	r0, [r4, #56]	; 0x38
    status = HAL_ERROR;
 800cb48:	2501      	movs	r5, #1
  }

  /* Change State */
  hsd->State = HAL_SD_STATE_READY;
 800cb4a:	2301      	movs	r3, #1
 800cb4c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  return status;
 800cb50:	4628      	mov	r0, r5
}
 800cb52:	b016      	add	sp, #88	; 0x58
 800cb54:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800cb58:	80ffff04 	.word	0x80ffff04
 800cb5c:	18000f3a 	.word	0x18000f3a
 800cb60:	1fe00fff 	.word	0x1fe00fff

0800cb64 <SDMMC_Init>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Init SDMMC initialization structure
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_Init(SDMMC_TypeDef *SDMMCx, SDMMC_InitTypeDef Init)
{
 800cb64:	b084      	sub	sp, #16
 800cb66:	b510      	push	{r4, lr}
 800cb68:	ac03      	add	r4, sp, #12
 800cb6a:	e884 000e 	stmia.w	r4, {r1, r2, r3}
             Init.HardwareFlowControl |\
             Init.ClockDiv
             );

  /* Write to SDMMC CLKCR */
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
 800cb6e:	9b04      	ldr	r3, [sp, #16]
 800cb70:	9a03      	ldr	r2, [sp, #12]
 800cb72:	6841      	ldr	r1, [r0, #4]
 800cb74:	431a      	orrs	r2, r3
 800cb76:	9b05      	ldr	r3, [sp, #20]
 800cb78:	431a      	orrs	r2, r3
 800cb7a:	9b06      	ldr	r3, [sp, #24]
 800cb7c:	431a      	orrs	r2, r3
 800cb7e:	9b07      	ldr	r3, [sp, #28]

  return HAL_OK;
}
 800cb80:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
             Init.HardwareFlowControl |\
             Init.ClockDiv
             );

  /* Write to SDMMC CLKCR */
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
 800cb84:	431a      	orrs	r2, r3
 800cb86:	4b03      	ldr	r3, [pc, #12]	; (800cb94 <SDMMC_Init+0x30>)
 800cb88:	400b      	ands	r3, r1
 800cb8a:	4313      	orrs	r3, r2
 800cb8c:	6043      	str	r3, [r0, #4]

  return HAL_OK;
}
 800cb8e:	b004      	add	sp, #16
 800cb90:	2000      	movs	r0, #0
 800cb92:	4770      	bx	lr
 800cb94:	ffc02c00 	.word	0xffc02c00

0800cb98 <SDMMC_ReadFIFO>:
 800cb98:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 800cb9c:	4770      	bx	lr

0800cb9e <SDMMC_WriteFIFO>:
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_WriteFIFO(SDMMC_TypeDef *SDMMCx, uint32_t *pWriteData)
{
  /* Write data to FIFO */
  SDMMCx->FIFO = *pWriteData;
 800cb9e:	680b      	ldr	r3, [r1, #0]
 800cba0:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80

  return HAL_OK;
}
 800cba4:	2000      	movs	r0, #0
 800cba6:	4770      	bx	lr

0800cba8 <SDMMC_PowerState_ON>:
  * @brief  Set SDMMC Power state to ON.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_PowerState_ON(SDMMC_TypeDef *SDMMCx)
{
 800cba8:	b508      	push	{r3, lr}
  /* Set power state to ON */
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  SDMMCx->POWER |= SDMMC_POWER_PWRCTRL;
 800cbaa:	6803      	ldr	r3, [r0, #0]
 800cbac:	f043 0303 	orr.w	r3, r3, #3
 800cbb0:	6003      	str	r3, [r0, #0]
  SDMMCx->POWER = SDMMC_POWER_PWRCTRL;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

  /* 1ms: required power up waiting time before starting the SD initialization
  sequence */
  HAL_Delay(2);
 800cbb2:	2002      	movs	r0, #2
 800cbb4:	f7f6 fe7a 	bl	80038ac <HAL_Delay>

  return HAL_OK;
}
 800cbb8:	2000      	movs	r0, #0
 800cbba:	bd08      	pop	{r3, pc}

0800cbbc <SDMMC_PowerState_Cycle>:
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_PowerState_Cycle(SDMMC_TypeDef *SDMMCx)
{
  /* Set power state to Power Cycle*/
  SDMMCx->POWER |= SDMMC_POWER_PWRCTRL_1;
 800cbbc:	6803      	ldr	r3, [r0, #0]
 800cbbe:	f043 0302 	orr.w	r3, r3, #2
 800cbc2:	6003      	str	r3, [r0, #0]

  return HAL_OK;
}
 800cbc4:	2000      	movs	r0, #0
 800cbc6:	4770      	bx	lr

0800cbc8 <SDMMC_PowerState_OFF>:
  */
HAL_StatusTypeDef SDMMC_PowerState_OFF(SDMMC_TypeDef *SDMMCx)
{
  /* Set power state to OFF */
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  SDMMCx->POWER &= ~(SDMMC_POWER_PWRCTRL);
 800cbc8:	6803      	ldr	r3, [r0, #0]
 800cbca:	f023 0303 	bic.w	r3, r3, #3
 800cbce:	6003      	str	r3, [r0, #0]
#else
  SDMMCx->POWER = (uint32_t)0x00000000;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

  return HAL_OK;
}
 800cbd0:	2000      	movs	r0, #0
 800cbd2:	4770      	bx	lr

0800cbd4 <SDMMC_GetPowerState>:
  *            - 0x02: Power UP
  *            - 0x03: Power ON
  */
uint32_t SDMMC_GetPowerState(SDMMC_TypeDef *SDMMCx)
{
  return (SDMMCx->POWER & SDMMC_POWER_PWRCTRL);
 800cbd4:	6800      	ldr	r0, [r0, #0]
}
 800cbd6:	f000 0003 	and.w	r0, r0, #3
 800cbda:	4770      	bx	lr

0800cbdc <SDMMC_SendCommand>:
  assert_param(IS_SDMMC_RESPONSE(Command->Response));
  assert_param(IS_SDMMC_WAIT(Command->WaitForInterrupt));
  assert_param(IS_SDMMC_CPSM(Command->CPSM));

  /* Set the SDMMC Argument value */
  SDMMCx->ARG = Command->Argument;
 800cbdc:	680b      	ldr	r3, [r1, #0]
                       Command->Response         |\
                       Command->WaitForInterrupt |\
                       Command->CPSM);

  /* Write to SDMMC CMD register */
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800cbde:	684a      	ldr	r2, [r1, #4]
  * @param  Command pointer to a SDMMC_CmdInitTypeDef structure that contains
  *         the configuration information for the SDMMC command
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_SendCommand(SDMMC_TypeDef *SDMMCx, SDMMC_CmdInitTypeDef *Command)
{
 800cbe0:	b510      	push	{r4, lr}
  assert_param(IS_SDMMC_RESPONSE(Command->Response));
  assert_param(IS_SDMMC_WAIT(Command->WaitForInterrupt));
  assert_param(IS_SDMMC_CPSM(Command->CPSM));

  /* Set the SDMMC Argument value */
  SDMMCx->ARG = Command->Argument;
 800cbe2:	6083      	str	r3, [r0, #8]
                       Command->Response         |\
                       Command->WaitForInterrupt |\
                       Command->CPSM);

  /* Write to SDMMC CMD register */
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800cbe4:	688b      	ldr	r3, [r1, #8]
 800cbe6:	68c4      	ldr	r4, [r0, #12]
 800cbe8:	431a      	orrs	r2, r3
 800cbea:	68cb      	ldr	r3, [r1, #12]
 800cbec:	4313      	orrs	r3, r2
 800cbee:	690a      	ldr	r2, [r1, #16]
 800cbf0:	431a      	orrs	r2, r3
 800cbf2:	4b03      	ldr	r3, [pc, #12]	; (800cc00 <SDMMC_SendCommand+0x24>)
 800cbf4:	4023      	ands	r3, r4
 800cbf6:	4313      	orrs	r3, r2
 800cbf8:	60c3      	str	r3, [r0, #12]

  return HAL_OK;
}
 800cbfa:	2000      	movs	r0, #0
 800cbfc:	bd10      	pop	{r4, pc}
 800cbfe:	bf00      	nop
 800cc00:	fffee0c0 	.word	0xfffee0c0

0800cc04 <SDMMC_GetCommandResponse>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval Command index of the last command response received
  */
uint8_t SDMMC_GetCommandResponse(SDMMC_TypeDef *SDMMCx)
{
  return (uint8_t)(SDMMCx->RESPCMD);
 800cc04:	6900      	ldr	r0, [r0, #16]
}
 800cc06:	b2c0      	uxtb	r0, r0
 800cc08:	4770      	bx	lr

0800cc0a <SDMMC_GetResponse>:

  /* Check the parameters */
  assert_param(IS_SDMMC_RESP(Response));

  /* Get the response */
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;
 800cc0a:	3014      	adds	r0, #20

  return (*(__IO uint32_t *) tmp);
 800cc0c:	5840      	ldr	r0, [r0, r1]
}
 800cc0e:	4770      	bx	lr

0800cc10 <SDMMC_ConfigData>:
  * @param  Data : pointer to a SDMMC_DataInitTypeDef structure
  *         that contains the configuration information for the SDMMC data.
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_ConfigData(SDMMC_TypeDef *SDMMCx, SDMMC_DataInitTypeDef* Data)
{
 800cc10:	b510      	push	{r4, lr}
                       Data->TransferDir   |\
                       Data->TransferMode  |\
                       Data->DPSM);

  /* Write to SDMMC DCTRL */
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 800cc12:	68ca      	ldr	r2, [r1, #12]
 800cc14:	688c      	ldr	r4, [r1, #8]
  assert_param(IS_SDMMC_TRANSFER_DIR(Data->TransferDir));
  assert_param(IS_SDMMC_TRANSFER_MODE(Data->TransferMode));
  assert_param(IS_SDMMC_DPSM(Data->DPSM));

  /* Set the SDMMC Data TimeOut value */
  SDMMCx->DTIMER = Data->DataTimeOut;
 800cc16:	680b      	ldr	r3, [r1, #0]
 800cc18:	6243      	str	r3, [r0, #36]	; 0x24
                       Data->TransferDir   |\
                       Data->TransferMode  |\
                       Data->DPSM);

  /* Write to SDMMC DCTRL */
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 800cc1a:	4314      	orrs	r4, r2

  /* Set the SDMMC Data TimeOut value */
  SDMMCx->DTIMER = Data->DataTimeOut;

  /* Set the SDMMC DataLength value */
  SDMMCx->DLEN = Data->DataLength;
 800cc1c:	684b      	ldr	r3, [r1, #4]
                       Data->TransferDir   |\
                       Data->TransferMode  |\
                       Data->DPSM);

  /* Write to SDMMC DCTRL */
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 800cc1e:	690a      	ldr	r2, [r1, #16]

  /* Set the SDMMC Data TimeOut value */
  SDMMCx->DTIMER = Data->DataTimeOut;

  /* Set the SDMMC DataLength value */
  SDMMCx->DLEN = Data->DataLength;
 800cc20:	6283      	str	r3, [r0, #40]	; 0x28
                       Data->TransferDir   |\
                       Data->TransferMode  |\
                       Data->DPSM);

  /* Write to SDMMC DCTRL */
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 800cc22:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800cc24:	4314      	orrs	r4, r2
 800cc26:	694a      	ldr	r2, [r1, #20]
 800cc28:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 800cc2c:	4322      	orrs	r2, r4
 800cc2e:	4313      	orrs	r3, r2
 800cc30:	62c3      	str	r3, [r0, #44]	; 0x2c

  return HAL_OK;

}
 800cc32:	2000      	movs	r0, #0
 800cc34:	bd10      	pop	{r4, pc}

0800cc36 <SDMMC_GetDataCounter>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval Number of remaining data bytes to be transferred
  */
uint32_t SDMMC_GetDataCounter(SDMMC_TypeDef *SDMMCx)
{
  return (SDMMCx->DCOUNT);
 800cc36:	6b00      	ldr	r0, [r0, #48]	; 0x30
}
 800cc38:	4770      	bx	lr

0800cc3a <SDMMC_GetFIFOCount>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval Data received
  */
uint32_t SDMMC_GetFIFOCount(SDMMC_TypeDef *SDMMCx)
{
  return (SDMMCx->FIFO);
 800cc3a:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
}
 800cc3e:	4770      	bx	lr

0800cc40 <SDMMC_SetSDMMCReadWaitMode>:
{
  /* Check the parameters */
  assert_param(IS_SDMMC_READWAIT_MODE(SDMMC_ReadWaitMode));

  /* Set SDMMC read wait mode */
  MODIFY_REG(SDMMCx->DCTRL, SDMMC_DCTRL_RWMOD, SDMMC_ReadWaitMode);
 800cc40:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800cc42:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800cc46:	4319      	orrs	r1, r3
 800cc48:	62c1      	str	r1, [r0, #44]	; 0x2c

  return HAL_OK;
}
 800cc4a:	2000      	movs	r0, #0
 800cc4c:	4770      	bx	lr
	...

0800cc50 <SDMMC_CmdGoIdleState>:
  * @brief  Send the Go Idle State command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdGoIdleState(SDMMC_TypeDef *SDMMCx)
{
 800cc50:	b510      	push	{r4, lr}
 800cc52:	b086      	sub	sp, #24
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0U;
 800cc54:	2300      	movs	r3, #0
 800cc56:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_GO_IDLE_STATE;
 800cc58:	9302      	str	r3, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_NO;
 800cc5a:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cc5c:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cc5e:	a901      	add	r1, sp, #4

  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_GO_IDLE_STATE;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_NO;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800cc60:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800cc64:	9305      	str	r3, [sp, #20]
  * @brief  Send the Go Idle State command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdGoIdleState(SDMMC_TypeDef *SDMMCx)
{
 800cc66:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_GO_IDLE_STATE;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_NO;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cc68:	f7ff ffb8 	bl	800cbdc <SDMMC_SendCommand>
  */
static uint32_t SDMMC_GetCmdError(SDMMC_TypeDef *SDMMCx)
{
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800cc6c:	4b0b      	ldr	r3, [pc, #44]	; (800cc9c <SDMMC_CmdGoIdleState+0x4c>)
 800cc6e:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
 800cc72:	681b      	ldr	r3, [r3, #0]
 800cc74:	fbb3 f2f2 	udiv	r2, r3, r2
 800cc78:	f241 3388 	movw	r3, #5000	; 0x1388
 800cc7c:	4353      	muls	r3, r2

  do
  {
    if (count-- == 0U)
 800cc7e:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800cc82:	d306      	bcc.n	800cc92 <SDMMC_CmdGoIdleState+0x42>
    {
      return SDMMC_ERROR_TIMEOUT;
    }

  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDSENT));
 800cc84:	6b62      	ldr	r2, [r4, #52]	; 0x34
 800cc86:	0612      	lsls	r2, r2, #24
 800cc88:	d5f9      	bpl.n	800cc7e <SDMMC_CmdGoIdleState+0x2e>

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800cc8a:	4b05      	ldr	r3, [pc, #20]	; (800cca0 <SDMMC_CmdGoIdleState+0x50>)
 800cc8c:	63a3      	str	r3, [r4, #56]	; 0x38

  return SDMMC_ERROR_NONE;
 800cc8e:	2000      	movs	r0, #0
 800cc90:	e001      	b.n	800cc96 <SDMMC_CmdGoIdleState+0x46>

  do
  {
    if (count-- == 0U)
    {
      return SDMMC_ERROR_TIMEOUT;
 800cc92:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdError(SDMMCx);

  return errorstate;
}
 800cc96:	b006      	add	sp, #24
 800cc98:	bd10      	pop	{r4, pc}
 800cc9a:	bf00      	nop
 800cc9c:	20000448 	.word	0x20000448
 800cca0:	002000c5 	.word	0x002000c5

0800cca4 <SDMMC_GetCmdResp1>:
  uint32_t response_r1;
  uint32_t sta_reg;

  /* 8 is the number of required instructions cycles for the below loop statement.
  The Timeout is expressed in ms */
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800cca4:	4b44      	ldr	r3, [pc, #272]	; (800cdb8 <SDMMC_GetCmdResp1+0x114>)
  * @param  hsd SD handle
  * @param  SD_CMD The sent command index
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp1(SDMMC_TypeDef *SDMMCx, uint8_t SD_CMD, uint32_t Timeout)
{
 800cca6:	b510      	push	{r4, lr}
  uint32_t response_r1;
  uint32_t sta_reg;

  /* 8 is the number of required instructions cycles for the below loop statement.
  The Timeout is expressed in ms */
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800cca8:	681b      	ldr	r3, [r3, #0]
 800ccaa:	f44f 54fa 	mov.w	r4, #8000	; 0x1f40
 800ccae:	fbb3 f3f4 	udiv	r3, r3, r4
 800ccb2:	435a      	muls	r2, r3

  do
  {
    if (count-- == 0U)
 800ccb4:	2a00      	cmp	r2, #0
 800ccb6:	d048      	beq.n	800cd4a <SDMMC_GetCmdResp1+0xa6>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
 800ccb8:	6b44      	ldr	r4, [r0, #52]	; 0x34
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800ccba:	4b40      	ldr	r3, [pc, #256]	; (800cdbc <SDMMC_GetCmdResp1+0x118>)
 800ccbc:	4023      	ands	r3, r4
 800ccbe:	b90b      	cbnz	r3, 800ccc4 <SDMMC_GetCmdResp1+0x20>
 800ccc0:	3a01      	subs	r2, #1
 800ccc2:	e7f7      	b.n	800ccb4 <SDMMC_GetCmdResp1+0x10>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800ccc4:	04a4      	lsls	r4, r4, #18
 800ccc6:	d4fb      	bmi.n	800ccc0 <SDMMC_GetCmdResp1+0x1c>
#else
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800ccc8:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800ccca:	075b      	lsls	r3, r3, #29
 800cccc:	d501      	bpl.n	800ccd2 <SDMMC_GetCmdResp1+0x2e>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800ccce:	2304      	movs	r3, #4
 800ccd0:	e003      	b.n	800ccda <SDMMC_GetCmdResp1+0x36>

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800ccd2:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800ccd4:	07dc      	lsls	r4, r3, #31
 800ccd6:	d503      	bpl.n	800cce0 <SDMMC_GetCmdResp1+0x3c>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800ccd8:	2301      	movs	r3, #1
 800ccda:	6383      	str	r3, [r0, #56]	; 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
 800ccdc:	4618      	mov	r0, r3
 800ccde:	bd10      	pop	{r4, pc}
  {
    /* Nothing to do */
  }

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800cce0:	4b37      	ldr	r3, [pc, #220]	; (800cdc0 <SDMMC_GetCmdResp1+0x11c>)
 800cce2:	6383      	str	r3, [r0, #56]	; 0x38
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval Command index of the last command response received
  */
uint8_t SDMMC_GetCommandResponse(SDMMC_TypeDef *SDMMCx)
{
  return (uint8_t)(SDMMCx->RESPCMD);
 800cce4:	6903      	ldr	r3, [r0, #16]

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);

  /* Check response received is of desired command */
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800cce6:	b2db      	uxtb	r3, r3
 800cce8:	4299      	cmp	r1, r3
 800ccea:	d131      	bne.n	800cd50 <SDMMC_GetCmdResp1+0xac>
  assert_param(IS_SDMMC_RESP(Response));

  /* Get the response */
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;

  return (*(__IO uint32_t *) tmp);
 800ccec:	6943      	ldr	r3, [r0, #20]
  }

  /* We have received response, retrieve it for analysis  */
  response_r1 = SDMMC_GetResponse(SDMMCx, SDMMC_RESP1);

  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 800ccee:	4835      	ldr	r0, [pc, #212]	; (800cdc4 <SDMMC_GetCmdResp1+0x120>)
 800ccf0:	4018      	ands	r0, r3
 800ccf2:	2800      	cmp	r0, #0
 800ccf4:	d05e      	beq.n	800cdb4 <SDMMC_GetCmdResp1+0x110>
  {
    return SDMMC_ERROR_NONE;
  }
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 800ccf6:	2b00      	cmp	r3, #0
 800ccf8:	db2c      	blt.n	800cd54 <SDMMC_GetCmdResp1+0xb0>
  {
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
  }
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 800ccfa:	005a      	lsls	r2, r3, #1
 800ccfc:	d42d      	bmi.n	800cd5a <SDMMC_GetCmdResp1+0xb6>
  {
    return SDMMC_ERROR_ADDR_MISALIGNED;
  }
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 800ccfe:	009c      	lsls	r4, r3, #2
 800cd00:	d42d      	bmi.n	800cd5e <SDMMC_GetCmdResp1+0xba>
  {
    return SDMMC_ERROR_BLOCK_LEN_ERR;
  }
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 800cd02:	00d9      	lsls	r1, r3, #3
 800cd04:	d42d      	bmi.n	800cd62 <SDMMC_GetCmdResp1+0xbe>
  {
    return SDMMC_ERROR_ERASE_SEQ_ERR;
  }
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 800cd06:	011a      	lsls	r2, r3, #4
 800cd08:	d42e      	bmi.n	800cd68 <SDMMC_GetCmdResp1+0xc4>
  {
    return SDMMC_ERROR_BAD_ERASE_PARAM;
  }
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 800cd0a:	015c      	lsls	r4, r3, #5
 800cd0c:	d42f      	bmi.n	800cd6e <SDMMC_GetCmdResp1+0xca>
  {
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
  }
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 800cd0e:	01d9      	lsls	r1, r3, #7
 800cd10:	d430      	bmi.n	800cd74 <SDMMC_GetCmdResp1+0xd0>
  {
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 800cd12:	021a      	lsls	r2, r3, #8
 800cd14:	d431      	bmi.n	800cd7a <SDMMC_GetCmdResp1+0xd6>
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 800cd16:	025c      	lsls	r4, r3, #9
 800cd18:	d432      	bmi.n	800cd80 <SDMMC_GetCmdResp1+0xdc>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 800cd1a:	0299      	lsls	r1, r3, #10
 800cd1c:	d433      	bmi.n	800cd86 <SDMMC_GetCmdResp1+0xe2>
  {
    return SDMMC_ERROR_CARD_ECC_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 800cd1e:	02da      	lsls	r2, r3, #11
 800cd20:	d434      	bmi.n	800cd8c <SDMMC_GetCmdResp1+0xe8>
  {
    return SDMMC_ERROR_CC_ERR;
  }
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 800cd22:	035c      	lsls	r4, r3, #13
 800cd24:	d435      	bmi.n	800cd92 <SDMMC_GetCmdResp1+0xee>
  {
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
  }
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 800cd26:	0399      	lsls	r1, r3, #14
 800cd28:	d436      	bmi.n	800cd98 <SDMMC_GetCmdResp1+0xf4>
  {
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
  }
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 800cd2a:	03da      	lsls	r2, r3, #15
 800cd2c:	d437      	bmi.n	800cd9e <SDMMC_GetCmdResp1+0xfa>
  {
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
  }
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 800cd2e:	041c      	lsls	r4, r3, #16
 800cd30:	d438      	bmi.n	800cda4 <SDMMC_GetCmdResp1+0x100>
  {
    return SDMMC_ERROR_WP_ERASE_SKIP;
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 800cd32:	0459      	lsls	r1, r3, #17
 800cd34:	d439      	bmi.n	800cdaa <SDMMC_GetCmdResp1+0x106>
  {
    return SDMMC_ERROR_CARD_ECC_DISABLED;
  }
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 800cd36:	049a      	lsls	r2, r3, #18
 800cd38:	d43a      	bmi.n	800cdb0 <SDMMC_GetCmdResp1+0x10c>
  {
    return SDMMC_ERROR_ERASE_RESET;
  }
  else if((response_r1 & SDMMC_OCR_AKE_SEQ_ERROR) == SDMMC_OCR_AKE_SEQ_ERROR)
  {
    return SDMMC_ERROR_AKE_SEQ_ERR;
 800cd3a:	f013 0f08 	tst.w	r3, #8
 800cd3e:	bf0c      	ite	eq
 800cd40:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
 800cd44:	f44f 0000 	movne.w	r0, #8388608	; 0x800000
 800cd48:	bd10      	pop	{r4, pc}

  do
  {
    if (count-- == 0U)
    {
      return SDMMC_ERROR_TIMEOUT;
 800cd4a:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800cd4e:	bd10      	pop	{r4, pc}
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);

  /* Check response received is of desired command */
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
  {
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800cd50:	2001      	movs	r0, #1
 800cd52:	bd10      	pop	{r4, pc}
  {
    return SDMMC_ERROR_NONE;
  }
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
  {
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 800cd54:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 800cd58:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
  {
    return SDMMC_ERROR_ADDR_MISALIGNED;
 800cd5a:	2040      	movs	r0, #64	; 0x40
 800cd5c:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
  {
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 800cd5e:	2080      	movs	r0, #128	; 0x80
 800cd60:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
  {
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 800cd62:	f44f 7080 	mov.w	r0, #256	; 0x100
 800cd66:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
  {
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 800cd68:	f44f 7000 	mov.w	r0, #512	; 0x200
 800cd6c:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
  {
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 800cd6e:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800cd72:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
  {
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 800cd74:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800cd78:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
 800cd7a:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800cd7e:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
 800cd80:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 800cd84:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
  {
    return SDMMC_ERROR_CARD_ECC_FAILED;
 800cd86:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800cd8a:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
  {
    return SDMMC_ERROR_CC_ERR;
 800cd8c:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800cd90:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
  {
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 800cd92:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800cd96:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
  {
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 800cd98:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800cd9c:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
  {
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 800cd9e:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800cda2:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
  {
    return SDMMC_ERROR_WP_ERASE_SKIP;
 800cda4:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800cda8:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
  {
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 800cdaa:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 800cdae:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
  {
    return SDMMC_ERROR_ERASE_RESET;
 800cdb0:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
  }
}
 800cdb4:	bd10      	pop	{r4, pc}
 800cdb6:	bf00      	nop
 800cdb8:	20000448 	.word	0x20000448
 800cdbc:	00200045 	.word	0x00200045
 800cdc0:	002000c5 	.word	0x002000c5
 800cdc4:	fdffe008 	.word	0xfdffe008

0800cdc8 <SDMMC_CmdBlockLength>:
  * @brief  Send the Data Block Lenght command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdBlockLength(SDMMC_TypeDef *SDMMCx, uint32_t BlockSize)
{
 800cdc8:	b530      	push	{r4, r5, lr}
 800cdca:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)BlockSize;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_BLOCKLEN;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800cdcc:	f44f 7380 	mov.w	r3, #256	; 0x100
 800cdd0:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cdd2:	2300      	movs	r3, #0
  * @brief  Send the Data Block Lenght command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdBlockLength(SDMMC_TypeDef *SDMMCx, uint32_t BlockSize)
{
 800cdd4:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)BlockSize;
 800cdd6:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_BLOCKLEN;
 800cdd8:	2410      	movs	r4, #16
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cdda:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cddc:	a901      	add	r1, sp, #4
  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)BlockSize;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_BLOCKLEN;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800cdde:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800cde2:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)BlockSize;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_BLOCKLEN;
 800cde4:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cde6:	f7ff fef9 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SET_BLOCKLEN, SDMMC_CMDTIMEOUT);
 800cdea:	f241 3288 	movw	r2, #5000	; 0x1388
 800cdee:	4621      	mov	r1, r4
 800cdf0:	4628      	mov	r0, r5
 800cdf2:	f7ff ff57 	bl	800cca4 <SDMMC_GetCmdResp1>

  return errorstate;
}
 800cdf6:	b007      	add	sp, #28
 800cdf8:	bd30      	pop	{r4, r5, pc}

0800cdfa <SDMMC_CmdReadSingleBlock>:
  * @brief  Send the Read Single Block command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdReadSingleBlock(SDMMC_TypeDef *SDMMCx, uint32_t ReadAdd)
{
 800cdfa:	b530      	push	{r4, r5, lr}
 800cdfc:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_SINGLE_BLOCK;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800cdfe:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ce02:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800ce04:	2300      	movs	r3, #0
  * @brief  Send the Read Single Block command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdReadSingleBlock(SDMMC_TypeDef *SDMMCx, uint32_t ReadAdd)
{
 800ce06:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
 800ce08:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_SINGLE_BLOCK;
 800ce0a:	2411      	movs	r4, #17
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800ce0c:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800ce0e:	a901      	add	r1, sp, #4
  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_SINGLE_BLOCK;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800ce10:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800ce14:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_SINGLE_BLOCK;
 800ce16:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800ce18:	f7ff fee0 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
 800ce1c:	f241 3288 	movw	r2, #5000	; 0x1388
 800ce20:	4621      	mov	r1, r4
 800ce22:	4628      	mov	r0, r5
 800ce24:	f7ff ff3e 	bl	800cca4 <SDMMC_GetCmdResp1>

  return errorstate;
}
 800ce28:	b007      	add	sp, #28
 800ce2a:	bd30      	pop	{r4, r5, pc}

0800ce2c <SDMMC_CmdReadMultiBlock>:
  * @brief  Send the Read Multi Block command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdReadMultiBlock(SDMMC_TypeDef *SDMMCx, uint32_t ReadAdd)
{
 800ce2c:	b530      	push	{r4, r5, lr}
 800ce2e:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_MULT_BLOCK;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800ce30:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ce34:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800ce36:	2300      	movs	r3, #0
  * @brief  Send the Read Multi Block command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdReadMultiBlock(SDMMC_TypeDef *SDMMCx, uint32_t ReadAdd)
{
 800ce38:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
 800ce3a:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_MULT_BLOCK;
 800ce3c:	2412      	movs	r4, #18
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800ce3e:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800ce40:	a901      	add	r1, sp, #4
  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_MULT_BLOCK;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800ce42:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800ce46:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_MULT_BLOCK;
 800ce48:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800ce4a:	f7ff fec7 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_MULT_BLOCK, SDMMC_CMDTIMEOUT);
 800ce4e:	f241 3288 	movw	r2, #5000	; 0x1388
 800ce52:	4621      	mov	r1, r4
 800ce54:	4628      	mov	r0, r5
 800ce56:	f7ff ff25 	bl	800cca4 <SDMMC_GetCmdResp1>

  return errorstate;
}
 800ce5a:	b007      	add	sp, #28
 800ce5c:	bd30      	pop	{r4, r5, pc}

0800ce5e <SDMMC_CmdWriteSingleBlock>:
  * @brief  Send the Write Single Block command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdWriteSingleBlock(SDMMC_TypeDef *SDMMCx, uint32_t WriteAdd)
{
 800ce5e:	b530      	push	{r4, r5, lr}
 800ce60:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_SINGLE_BLOCK;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800ce62:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ce66:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800ce68:	2300      	movs	r3, #0
  * @brief  Send the Write Single Block command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdWriteSingleBlock(SDMMC_TypeDef *SDMMCx, uint32_t WriteAdd)
{
 800ce6a:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
 800ce6c:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_SINGLE_BLOCK;
 800ce6e:	2418      	movs	r4, #24
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800ce70:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800ce72:	a901      	add	r1, sp, #4
  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_SINGLE_BLOCK;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800ce74:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800ce78:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_SINGLE_BLOCK;
 800ce7a:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800ce7c:	f7ff feae 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
 800ce80:	f241 3288 	movw	r2, #5000	; 0x1388
 800ce84:	4621      	mov	r1, r4
 800ce86:	4628      	mov	r0, r5
 800ce88:	f7ff ff0c 	bl	800cca4 <SDMMC_GetCmdResp1>

  return errorstate;
}
 800ce8c:	b007      	add	sp, #28
 800ce8e:	bd30      	pop	{r4, r5, pc}

0800ce90 <SDMMC_CmdWriteMultiBlock>:
  * @brief  Send the Write Multi Block command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdWriteMultiBlock(SDMMC_TypeDef *SDMMCx, uint32_t WriteAdd)
{
 800ce90:	b530      	push	{r4, r5, lr}
 800ce92:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_MULT_BLOCK;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800ce94:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ce98:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800ce9a:	2300      	movs	r3, #0
  * @brief  Send the Write Multi Block command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdWriteMultiBlock(SDMMC_TypeDef *SDMMCx, uint32_t WriteAdd)
{
 800ce9c:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
 800ce9e:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_MULT_BLOCK;
 800cea0:	2419      	movs	r4, #25
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cea2:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cea4:	a901      	add	r1, sp, #4
  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_MULT_BLOCK;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800cea6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800ceaa:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_MULT_BLOCK;
 800ceac:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800ceae:	f7ff fe95 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_MULT_BLOCK, SDMMC_CMDTIMEOUT);
 800ceb2:	f241 3288 	movw	r2, #5000	; 0x1388
 800ceb6:	4621      	mov	r1, r4
 800ceb8:	4628      	mov	r0, r5
 800ceba:	f7ff fef3 	bl	800cca4 <SDMMC_GetCmdResp1>

  return errorstate;
}
 800cebe:	b007      	add	sp, #28
 800cec0:	bd30      	pop	{r4, r5, pc}

0800cec2 <SDMMC_CmdSDEraseStartAdd>:
  * @brief  Send the Start Address Erase command for SD and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSDEraseStartAdd(SDMMC_TypeDef *SDMMCx, uint32_t StartAdd)
{
 800cec2:	b530      	push	{r4, r5, lr}
 800cec4:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)StartAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_ERASE_GRP_START;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800cec6:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ceca:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cecc:	2300      	movs	r3, #0
  * @brief  Send the Start Address Erase command for SD and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSDEraseStartAdd(SDMMC_TypeDef *SDMMCx, uint32_t StartAdd)
{
 800cece:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)StartAdd;
 800ced0:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_ERASE_GRP_START;
 800ced2:	2420      	movs	r4, #32
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800ced4:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800ced6:	a901      	add	r1, sp, #4
  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)StartAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_ERASE_GRP_START;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800ced8:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800cedc:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)StartAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_ERASE_GRP_START;
 800cede:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cee0:	f7ff fe7c 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_ERASE_GRP_START, SDMMC_CMDTIMEOUT);
 800cee4:	f241 3288 	movw	r2, #5000	; 0x1388
 800cee8:	4621      	mov	r1, r4
 800ceea:	4628      	mov	r0, r5
 800ceec:	f7ff feda 	bl	800cca4 <SDMMC_GetCmdResp1>

  return errorstate;
}
 800cef0:	b007      	add	sp, #28
 800cef2:	bd30      	pop	{r4, r5, pc}

0800cef4 <SDMMC_CmdSDEraseEndAdd>:
  * @brief  Send the End Address Erase command for SD and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSDEraseEndAdd(SDMMC_TypeDef *SDMMCx, uint32_t EndAdd)
{
 800cef4:	b530      	push	{r4, r5, lr}
 800cef6:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)EndAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_ERASE_GRP_END;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800cef8:	f44f 7380 	mov.w	r3, #256	; 0x100
 800cefc:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cefe:	2300      	movs	r3, #0
  * @brief  Send the End Address Erase command for SD and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSDEraseEndAdd(SDMMC_TypeDef *SDMMCx, uint32_t EndAdd)
{
 800cf00:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)EndAdd;
 800cf02:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_ERASE_GRP_END;
 800cf04:	2421      	movs	r4, #33	; 0x21
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cf06:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cf08:	a901      	add	r1, sp, #4
  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)EndAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_ERASE_GRP_END;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800cf0a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800cf0e:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)EndAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_ERASE_GRP_END;
 800cf10:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cf12:	f7ff fe63 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_ERASE_GRP_END, SDMMC_CMDTIMEOUT);
 800cf16:	f241 3288 	movw	r2, #5000	; 0x1388
 800cf1a:	4621      	mov	r1, r4
 800cf1c:	4628      	mov	r0, r5
 800cf1e:	f7ff fec1 	bl	800cca4 <SDMMC_GetCmdResp1>

  return errorstate;
}
 800cf22:	b007      	add	sp, #28
 800cf24:	bd30      	pop	{r4, r5, pc}

0800cf26 <SDMMC_CmdEraseStartAdd>:
  * @brief  Send the Start Address Erase command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdEraseStartAdd(SDMMC_TypeDef *SDMMCx, uint32_t StartAdd)
{
 800cf26:	b530      	push	{r4, r5, lr}
 800cf28:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)StartAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE_GRP_START;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800cf2a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800cf2e:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cf30:	2300      	movs	r3, #0
  * @brief  Send the Start Address Erase command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdEraseStartAdd(SDMMC_TypeDef *SDMMCx, uint32_t StartAdd)
{
 800cf32:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)StartAdd;
 800cf34:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE_GRP_START;
 800cf36:	2423      	movs	r4, #35	; 0x23
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cf38:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cf3a:	a901      	add	r1, sp, #4
  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)StartAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE_GRP_START;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800cf3c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800cf40:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)StartAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE_GRP_START;
 800cf42:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cf44:	f7ff fe4a 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_ERASE_GRP_START, SDMMC_CMDTIMEOUT);
 800cf48:	f241 3288 	movw	r2, #5000	; 0x1388
 800cf4c:	4621      	mov	r1, r4
 800cf4e:	4628      	mov	r0, r5
 800cf50:	f7ff fea8 	bl	800cca4 <SDMMC_GetCmdResp1>

  return errorstate;
}
 800cf54:	b007      	add	sp, #28
 800cf56:	bd30      	pop	{r4, r5, pc}

0800cf58 <SDMMC_CmdEraseEndAdd>:
  * @brief  Send the End Address Erase command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdEraseEndAdd(SDMMC_TypeDef *SDMMCx, uint32_t EndAdd)
{
 800cf58:	b530      	push	{r4, r5, lr}
 800cf5a:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)EndAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE_GRP_END;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800cf5c:	f44f 7380 	mov.w	r3, #256	; 0x100
 800cf60:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cf62:	2300      	movs	r3, #0
  * @brief  Send the End Address Erase command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdEraseEndAdd(SDMMC_TypeDef *SDMMCx, uint32_t EndAdd)
{
 800cf64:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)EndAdd;
 800cf66:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE_GRP_END;
 800cf68:	2424      	movs	r4, #36	; 0x24
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cf6a:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cf6c:	a901      	add	r1, sp, #4
  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)EndAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE_GRP_END;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800cf6e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800cf72:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)EndAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE_GRP_END;
 800cf74:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cf76:	f7ff fe31 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_ERASE_GRP_END, SDMMC_CMDTIMEOUT);
 800cf7a:	f241 3288 	movw	r2, #5000	; 0x1388
 800cf7e:	4621      	mov	r1, r4
 800cf80:	4628      	mov	r0, r5
 800cf82:	f7ff fe8f 	bl	800cca4 <SDMMC_GetCmdResp1>

  return errorstate;
}
 800cf86:	b007      	add	sp, #28
 800cf88:	bd30      	pop	{r4, r5, pc}

0800cf8a <SDMMC_CmdErase>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  EraseType Type of erase to be performed
  * @retval HAL status
  */
uint32_t SDMMC_CmdErase(SDMMC_TypeDef *SDMMCx, uint32_t EraseType)
{
 800cf8a:	b530      	push	{r4, r5, lr}
 800cf8c:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = EraseType;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800cf8e:	f44f 7380 	mov.w	r3, #256	; 0x100
 800cf92:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cf94:	2300      	movs	r3, #0
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  EraseType Type of erase to be performed
  * @retval HAL status
  */
uint32_t SDMMC_CmdErase(SDMMC_TypeDef *SDMMCx, uint32_t EraseType)
{
 800cf96:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = EraseType;
 800cf98:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE;
 800cf9a:	2426      	movs	r4, #38	; 0x26
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cf9c:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cf9e:	a901      	add	r1, sp, #4
  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = EraseType;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800cfa0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800cfa4:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = EraseType;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE;
 800cfa6:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cfa8:	f7ff fe18 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_ERASE, SDMMC_MAXERASETIMEOUT);
 800cfac:	f24f 6218 	movw	r2, #63000	; 0xf618
 800cfb0:	4621      	mov	r1, r4
 800cfb2:	4628      	mov	r0, r5
 800cfb4:	f7ff fe76 	bl	800cca4 <SDMMC_GetCmdResp1>

  return errorstate;
}
 800cfb8:	b007      	add	sp, #28
 800cfba:	bd30      	pop	{r4, r5, pc}

0800cfbc <SDMMC_CmdStopTransfer>:
  * @brief  Send the Stop Transfer command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdStopTransfer(SDMMC_TypeDef *SDMMCx)
{
 800cfbc:	b530      	push	{r4, r5, lr}
 800cfbe:	b087      	sub	sp, #28
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD12 STOP_TRANSMISSION  */
  sdmmc_cmdinit.Argument         = 0U;
 800cfc0:	2300      	movs	r3, #0
 800cfc2:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cfc4:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800cfc6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800cfca:	9305      	str	r3, [sp, #20]

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
 800cfcc:	68c3      	ldr	r3, [r0, #12]
 800cfce:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800cfd2:	60c3      	str	r3, [r0, #12]
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
 800cfd4:	68c3      	ldr	r3, [r0, #12]
 800cfd6:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  * @brief  Send the Stop Transfer command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdStopTransfer(SDMMC_TypeDef *SDMMCx)
{
 800cfda:	4604      	mov	r4, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD12 STOP_TRANSMISSION  */
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
 800cfdc:	250c      	movs	r5, #12
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800cfde:	f44f 7280 	mov.w	r2, #256	; 0x100
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
 800cfe2:	60c3      	str	r3, [r0, #12]
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cfe4:	a901      	add	r1, sp, #4
  uint32_t errorstate;

  /* Send CMD12 STOP_TRANSMISSION  */
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800cfe6:	9203      	str	r2, [sp, #12]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD12 STOP_TRANSMISSION  */
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
 800cfe8:	9502      	str	r5, [sp, #8]
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cfea:	f7ff fdf7 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_STOP_TRANSMISSION, SDMMC_STOPTRANSFERTIMEOUT);
 800cfee:	4a05      	ldr	r2, [pc, #20]	; (800d004 <SDMMC_CmdStopTransfer+0x48>)
 800cff0:	4629      	mov	r1, r5
 800cff2:	4620      	mov	r0, r4
 800cff4:	f7ff fe56 	bl	800cca4 <SDMMC_GetCmdResp1>

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
 800cff8:	68e3      	ldr	r3, [r4, #12]
 800cffa:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800cffe:	60e3      	str	r3, [r4, #12]
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

  return errorstate;
}
 800d000:	b007      	add	sp, #28
 800d002:	bd30      	pop	{r4, r5, pc}
 800d004:	05f5e100 	.word	0x05f5e100

0800d008 <SDMMC_CmdSelDesel>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  addr Address of the card to be selected
  * @retval HAL status
  */
uint32_t SDMMC_CmdSelDesel(SDMMC_TypeDef *SDMMCx, uint64_t Addr)
{
 800d008:	b530      	push	{r4, r5, lr}
 800d00a:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Send CMD7 SDMMC_SEL_DESEL_CARD */
  sdmmc_cmdinit.Argument         = (uint32_t)Addr;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d00c:	f44f 7380 	mov.w	r3, #256	; 0x100
 800d010:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d012:	2300      	movs	r3, #0
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  addr Address of the card to be selected
  * @retval HAL status
  */
uint32_t SDMMC_CmdSelDesel(SDMMC_TypeDef *SDMMCx, uint64_t Addr)
{
 800d014:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD7 SDMMC_SEL_DESEL_CARD */
  sdmmc_cmdinit.Argument         = (uint32_t)Addr;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
 800d016:	2407      	movs	r4, #7
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d018:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d01a:	a901      	add	r1, sp, #4
  /* Send CMD7 SDMMC_SEL_DESEL_CARD */
  sdmmc_cmdinit.Argument         = (uint32_t)Addr;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d01c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
{
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD7 SDMMC_SEL_DESEL_CARD */
  sdmmc_cmdinit.Argument         = (uint32_t)Addr;
 800d020:	9201      	str	r2, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d022:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD7 SDMMC_SEL_DESEL_CARD */
  sdmmc_cmdinit.Argument         = (uint32_t)Addr;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
 800d024:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d026:	f7ff fdd9 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEL_DESEL_CARD, SDMMC_CMDTIMEOUT);
 800d02a:	f241 3288 	movw	r2, #5000	; 0x1388
 800d02e:	4621      	mov	r1, r4
 800d030:	4628      	mov	r0, r5
 800d032:	f7ff fe37 	bl	800cca4 <SDMMC_GetCmdResp1>

  return errorstate;
}
 800d036:	b007      	add	sp, #28
 800d038:	bd30      	pop	{r4, r5, pc}

0800d03a <SDMMC_CmdAppCommand>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Argument Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdAppCommand(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d03a:	b530      	push	{r4, r5, lr}
 800d03c:	b087      	sub	sp, #28
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = (uint32_t)Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_CMD;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d03e:	f44f 7380 	mov.w	r3, #256	; 0x100
 800d042:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d044:	2300      	movs	r3, #0
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Argument Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdAppCommand(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d046:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = (uint32_t)Argument;
 800d048:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_CMD;
 800d04a:	2437      	movs	r4, #55	; 0x37
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d04c:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d04e:	a901      	add	r1, sp, #4

  sdmmc_cmdinit.Argument         = (uint32_t)Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_CMD;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d050:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800d054:	9305      	str	r3, [sp, #20]
{
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = (uint32_t)Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_CMD;
 800d056:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d058:	f7ff fdc0 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  /* If there is a HAL_ERROR, it is a MMC card, else
  it is a SD card: SD card 2.0 (voltage range mismatch)
     or SD card 1.x */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_APP_CMD, SDMMC_CMDTIMEOUT);
 800d05c:	f241 3288 	movw	r2, #5000	; 0x1388
 800d060:	4621      	mov	r1, r4
 800d062:	4628      	mov	r0, r5
 800d064:	f7ff fe1e 	bl	800cca4 <SDMMC_GetCmdResp1>

  return errorstate;
}
 800d068:	b007      	add	sp, #28
 800d06a:	bd30      	pop	{r4, r5, pc}

0800d06c <SDMMC_CmdSendSCR>:
  * @brief  Send the Send SCR command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendSCR(SDMMC_TypeDef *SDMMCx)
{
 800d06c:	b530      	push	{r4, r5, lr}
 800d06e:	b087      	sub	sp, #28
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD51 SD_APP_SEND_SCR */
  sdmmc_cmdinit.Argument         = 0U;
 800d070:	2300      	movs	r3, #0
  * @brief  Send the Send SCR command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendSCR(SDMMC_TypeDef *SDMMCx)
{
 800d072:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD51 SD_APP_SEND_SCR */
  sdmmc_cmdinit.Argument         = 0U;
 800d074:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
 800d076:	2433      	movs	r4, #51	; 0x33
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d078:	f44f 7280 	mov.w	r2, #256	; 0x100
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d07c:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d07e:	a901      	add	r1, sp, #4
  /* Send CMD51 SD_APP_SEND_SCR */
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d080:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  uint32_t errorstate;

  /* Send CMD51 SD_APP_SEND_SCR */
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d084:	9203      	str	r2, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d086:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD51 SD_APP_SEND_SCR */
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
 800d088:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d08a:	f7ff fda7 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_APP_SEND_SCR, SDMMC_CMDTIMEOUT);
 800d08e:	f241 3288 	movw	r2, #5000	; 0x1388
 800d092:	4621      	mov	r1, r4
 800d094:	4628      	mov	r0, r5
 800d096:	f7ff fe05 	bl	800cca4 <SDMMC_GetCmdResp1>

  return errorstate;
}
 800d09a:	b007      	add	sp, #28
 800d09c:	bd30      	pop	{r4, r5, pc}

0800d09e <SDMMC_CmdSetRelAddMmc>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  RCA Card RCA
  * @retval HAL status
  */
uint32_t SDMMC_CmdSetRelAddMmc(SDMMC_TypeDef *SDMMCx, uint16_t RCA)
{
 800d09e:	b530      	push	{r4, r5, lr}
 800d0a0:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = ((uint32_t)RCA << 16U);
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d0a2:	f44f 7380 	mov.w	r3, #256	; 0x100
 800d0a6:	9303      	str	r3, [sp, #12]
{
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = ((uint32_t)RCA << 16U);
 800d0a8:	0409      	lsls	r1, r1, #16
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d0aa:	2300      	movs	r3, #0
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  RCA Card RCA
  * @retval HAL status
  */
uint32_t SDMMC_CmdSetRelAddMmc(SDMMC_TypeDef *SDMMCx, uint16_t RCA)
{
 800d0ac:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = ((uint32_t)RCA << 16U);
 800d0ae:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
 800d0b0:	2403      	movs	r4, #3
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d0b2:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d0b4:	a901      	add	r1, sp, #4
  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = ((uint32_t)RCA << 16U);
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d0b6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800d0ba:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = ((uint32_t)RCA << 16U);
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
 800d0bc:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d0be:	f7ff fd8d 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SET_REL_ADDR, SDMMC_CMDTIMEOUT);
 800d0c2:	f241 3288 	movw	r2, #5000	; 0x1388
 800d0c6:	4621      	mov	r1, r4
 800d0c8:	4628      	mov	r0, r5
 800d0ca:	f7ff fdeb 	bl	800cca4 <SDMMC_GetCmdResp1>

  return errorstate;
}
 800d0ce:	b007      	add	sp, #28
 800d0d0:	bd30      	pop	{r4, r5, pc}

0800d0d2 <SDMMC_CmdSendStatus>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Argument Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendStatus(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d0d2:	b530      	push	{r4, r5, lr}
 800d0d4:	b087      	sub	sp, #28
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_STATUS;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d0d6:	f44f 7380 	mov.w	r3, #256	; 0x100
 800d0da:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d0dc:	2300      	movs	r3, #0
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Argument Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendStatus(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d0de:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = Argument;
 800d0e0:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_STATUS;
 800d0e2:	240d      	movs	r4, #13
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d0e4:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d0e6:	a901      	add	r1, sp, #4

  sdmmc_cmdinit.Argument         = Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_STATUS;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d0e8:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800d0ec:	9305      	str	r3, [sp, #20]
{
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_STATUS;
 800d0ee:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d0f0:	f7ff fd74 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEND_STATUS, SDMMC_CMDTIMEOUT);
 800d0f4:	f241 3288 	movw	r2, #5000	; 0x1388
 800d0f8:	4621      	mov	r1, r4
 800d0fa:	4628      	mov	r0, r5
 800d0fc:	f7ff fdd2 	bl	800cca4 <SDMMC_GetCmdResp1>

  return errorstate;
}
 800d100:	b007      	add	sp, #28
 800d102:	bd30      	pop	{r4, r5, pc}

0800d104 <SDMMC_CmdStatusRegister>:
  * @brief  Send the Status register command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdStatusRegister(SDMMC_TypeDef *SDMMCx)
{
 800d104:	b530      	push	{r4, r5, lr}
 800d106:	b087      	sub	sp, #28
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0U;
 800d108:	2300      	movs	r3, #0
  * @brief  Send the Status register command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdStatusRegister(SDMMC_TypeDef *SDMMCx)
{
 800d10a:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0U;
 800d10c:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_STATUS;
 800d10e:	240d      	movs	r4, #13
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d110:	f44f 7280 	mov.w	r2, #256	; 0x100
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d114:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d116:	a901      	add	r1, sp, #4

  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_STATUS;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d118:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_STATUS;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d11c:	9203      	str	r2, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d11e:	9305      	str	r3, [sp, #20]
{
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_STATUS;
 800d120:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d122:	f7ff fd5b 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_APP_STATUS, SDMMC_CMDTIMEOUT);
 800d126:	f241 3288 	movw	r2, #5000	; 0x1388
 800d12a:	4621      	mov	r1, r4
 800d12c:	4628      	mov	r0, r5
 800d12e:	f7ff fdb9 	bl	800cca4 <SDMMC_GetCmdResp1>

  return errorstate;
}
 800d132:	b007      	add	sp, #28
 800d134:	bd30      	pop	{r4, r5, pc}

0800d136 <SDMMC_CmdSwitch>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @parame Argument: Argument used for the command
  * @retval HAL status
  */
uint32_t SDMMC_CmdSwitch(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d136:	b530      	push	{r4, r5, lr}
 800d138:	b087      	sub	sp, #28

  /* Send CMD6 to activate SDR50 Mode and Power Limit 1.44W */
  /* CMD Response: R1 */
  sdmmc_cmdinit.Argument         = Argument; /* SDMMC_SDR25_SWITCH_PATTERN;*/
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SWITCH;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d13a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800d13e:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d140:	2300      	movs	r3, #0
  * @param  SDMMCx Pointer to SDMMC register base
  * @parame Argument: Argument used for the command
  * @retval HAL status
  */
uint32_t SDMMC_CmdSwitch(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d142:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD6 to activate SDR50 Mode and Power Limit 1.44W */
  /* CMD Response: R1 */
  sdmmc_cmdinit.Argument         = Argument; /* SDMMC_SDR25_SWITCH_PATTERN;*/
 800d144:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SWITCH;
 800d146:	2406      	movs	r4, #6
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d148:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d14a:	a901      	add	r1, sp, #4
  /* CMD Response: R1 */
  sdmmc_cmdinit.Argument         = Argument; /* SDMMC_SDR25_SWITCH_PATTERN;*/
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SWITCH;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d14c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800d150:	9305      	str	r3, [sp, #20]
  uint32_t errorstate;

  /* Send CMD6 to activate SDR50 Mode and Power Limit 1.44W */
  /* CMD Response: R1 */
  sdmmc_cmdinit.Argument         = Argument; /* SDMMC_SDR25_SWITCH_PATTERN;*/
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SWITCH;
 800d152:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d154:	f7ff fd42 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_HS_SWITCH, SDMMC_CMDTIMEOUT);
 800d158:	f241 3288 	movw	r2, #5000	; 0x1388
 800d15c:	4621      	mov	r1, r4
 800d15e:	4628      	mov	r0, r5
 800d160:	f7ff fda0 	bl	800cca4 <SDMMC_GetCmdResp1>

  return errorstate;
}
 800d164:	b007      	add	sp, #28
 800d166:	bd30      	pop	{r4, r5, pc}

0800d168 <SDMMC_CmdBusWidth>:
 800d168:	f7ff bfe5 	b.w	800d136 <SDMMC_CmdSwitch>

0800d16c <SDMMC_CmdVoltageSwitch>:
  *         condition register (OCR)
  * @param  None
  * @retval HAL status
  */
uint32_t SDMMC_CmdVoltageSwitch(SDMMC_TypeDef *SDMMCx)
{
 800d16c:	b530      	push	{r4, r5, lr}
 800d16e:	b087      	sub	sp, #28
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0x00000000;
 800d170:	2300      	movs	r3, #0
  *         condition register (OCR)
  * @param  None
  * @retval HAL status
  */
uint32_t SDMMC_CmdVoltageSwitch(SDMMC_TypeDef *SDMMCx)
{
 800d172:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0x00000000;
 800d174:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_VOLTAGE_SWITCH;
 800d176:	240b      	movs	r4, #11
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d178:	f44f 7280 	mov.w	r2, #256	; 0x100
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d17c:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d17e:	a901      	add	r1, sp, #4

  sdmmc_cmdinit.Argument         = 0x00000000;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_VOLTAGE_SWITCH;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d180:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0x00000000;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_VOLTAGE_SWITCH;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d184:	9203      	str	r2, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d186:	9305      	str	r3, [sp, #20]
{
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0x00000000;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_VOLTAGE_SWITCH;
 800d188:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d18a:	f7ff fd27 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_VOLTAGE_SWITCH, SDMMC_CMDTIMEOUT);
 800d18e:	f241 3288 	movw	r2, #5000	; 0x1388
 800d192:	4621      	mov	r1, r4
 800d194:	4628      	mov	r0, r5
 800d196:	f7ff fd85 	bl	800cca4 <SDMMC_GetCmdResp1>

  return errorstate;
}
 800d19a:	b007      	add	sp, #28
 800d19c:	bd30      	pop	{r4, r5, pc}

0800d19e <SDMMC_CmdSendEXTCSD>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Argument Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendEXTCSD(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d19e:	b530      	push	{r4, r5, lr}
 800d1a0:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d1a2:	f44f 7380 	mov.w	r3, #256	; 0x100
 800d1a6:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d1a8:	2300      	movs	r3, #0
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Argument Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendEXTCSD(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d1aa:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
 800d1ac:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
 800d1ae:	2408      	movs	r4, #8
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d1b0:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d1b2:	a901      	add	r1, sp, #4
  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d1b4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800d1b8:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
 800d1ba:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d1bc:	f7ff fd0e 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_HS_SEND_EXT_CSD,SDMMC_CMDTIMEOUT);
 800d1c0:	f241 3288 	movw	r2, #5000	; 0x1388
 800d1c4:	4621      	mov	r1, r4
 800d1c6:	4628      	mov	r0, r5
 800d1c8:	f7ff fd6c 	bl	800cca4 <SDMMC_GetCmdResp1>

  return errorstate;
}
 800d1cc:	b007      	add	sp, #28
 800d1ce:	bd30      	pop	{r4, r5, pc}

0800d1d0 <SDMMC_GetCmdResp2>:
uint32_t SDMMC_GetCmdResp2(SDMMC_TypeDef *SDMMCx)
{
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800d1d0:	4b12      	ldr	r3, [pc, #72]	; (800d21c <SDMMC_GetCmdResp2+0x4c>)
 800d1d2:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
 800d1d6:	681b      	ldr	r3, [r3, #0]
 800d1d8:	fbb3 f1f1 	udiv	r1, r3, r1
 800d1dc:	f241 3388 	movw	r3, #5000	; 0x1388
  * @brief  Checks for error conditions for R2 (CID or CSD) response.
  * @param  hsd SD handle
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp2(SDMMC_TypeDef *SDMMCx)
{
 800d1e0:	4602      	mov	r2, r0
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800d1e2:	434b      	muls	r3, r1

  do
  {
    if (count-- == 0U)
 800d1e4:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800d1e8:	d315      	bcc.n	800d216 <SDMMC_GetCmdResp2+0x46>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
 800d1ea:	6b51      	ldr	r1, [r2, #52]	; 0x34
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800d1ec:	f011 0f45 	tst.w	r1, #69	; 0x45
 800d1f0:	d0f8      	beq.n	800d1e4 <SDMMC_GetCmdResp2+0x14>
    if (count-- == 0U)
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 800d1f2:	0489      	lsls	r1, r1, #18
 800d1f4:	d4f6      	bmi.n	800d1e4 <SDMMC_GetCmdResp2+0x14>
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800d1f6:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800d1f8:	075b      	lsls	r3, r3, #29
 800d1fa:	d501      	bpl.n	800d200 <SDMMC_GetCmdResp2+0x30>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800d1fc:	2304      	movs	r3, #4
 800d1fe:	e004      	b.n	800d20a <SDMMC_GetCmdResp2+0x3a>

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800d200:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800d202:	f013 0001 	ands.w	r0, r3, #1
 800d206:	d003      	beq.n	800d210 <SDMMC_GetCmdResp2+0x40>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800d208:	2301      	movs	r3, #1
 800d20a:	6393      	str	r3, [r2, #56]	; 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
 800d20c:	4618      	mov	r0, r3
 800d20e:	4770      	bx	lr
  }
  else
  {
    /* No error flag set */
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800d210:	4b03      	ldr	r3, [pc, #12]	; (800d220 <SDMMC_GetCmdResp2+0x50>)
 800d212:	6393      	str	r3, [r2, #56]	; 0x38
 800d214:	4770      	bx	lr

  do
  {
    if (count-- == 0U)
    {
      return SDMMC_ERROR_TIMEOUT;
 800d216:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
  }

  return SDMMC_ERROR_NONE;
}
 800d21a:	4770      	bx	lr
 800d21c:	20000448 	.word	0x20000448
 800d220:	002000c5 	.word	0x002000c5

0800d224 <SDMMC_CmdSendCID>:
  * @brief  Send the Send CID command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendCID(SDMMC_TypeDef *SDMMCx)
{
 800d224:	b510      	push	{r4, lr}
 800d226:	b086      	sub	sp, #24
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD2 ALL_SEND_CID */
  sdmmc_cmdinit.Argument         = 0U;
 800d228:	2300      	movs	r3, #0
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
 800d22a:	2202      	movs	r2, #2
  * @brief  Send the Send CID command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendCID(SDMMC_TypeDef *SDMMCx)
{
 800d22c:	4604      	mov	r4, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD2 ALL_SEND_CID */
  sdmmc_cmdinit.Argument         = 0U;
 800d22e:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
 800d230:	9202      	str	r2, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d232:	9304      	str	r3, [sp, #16]
  uint32_t errorstate;

  /* Send CMD2 ALL_SEND_CID */
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
 800d234:	f44f 7240 	mov.w	r2, #768	; 0x300
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d238:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d23c:	a901      	add	r1, sp, #4
  uint32_t errorstate;

  /* Send CMD2 ALL_SEND_CID */
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
 800d23e:	9203      	str	r2, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d240:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d242:	f7ff fccb 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
 800d246:	4620      	mov	r0, r4
 800d248:	f7ff ffc2 	bl	800d1d0 <SDMMC_GetCmdResp2>

  return errorstate;
}
 800d24c:	b006      	add	sp, #24
 800d24e:	bd10      	pop	{r4, pc}

0800d250 <SDMMC_CmdSendCSD>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Argument Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendCSD(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d250:	b510      	push	{r4, lr}
 800d252:	b086      	sub	sp, #24
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_CSD;
 800d254:	2309      	movs	r3, #9
 800d256:	9302      	str	r3, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
 800d258:	f44f 7340 	mov.w	r3, #768	; 0x300
 800d25c:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d25e:	2300      	movs	r3, #0
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Argument Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendCSD(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d260:	4604      	mov	r4, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
 800d262:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_CSD;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d264:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d266:	a901      	add	r1, sp, #4
  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_CSD;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d268:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800d26c:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d26e:	f7ff fcb5 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
 800d272:	4620      	mov	r0, r4
 800d274:	f7ff ffac 	bl	800d1d0 <SDMMC_GetCmdResp2>

  return errorstate;
}
 800d278:	b006      	add	sp, #24
 800d27a:	bd10      	pop	{r4, pc}

0800d27c <SDMMC_GetCmdResp3>:
uint32_t SDMMC_GetCmdResp3(SDMMC_TypeDef *SDMMCx)
{
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800d27c:	4b10      	ldr	r3, [pc, #64]	; (800d2c0 <SDMMC_GetCmdResp3+0x44>)
 800d27e:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
 800d282:	681b      	ldr	r3, [r3, #0]
 800d284:	fbb3 f1f1 	udiv	r1, r3, r1
 800d288:	f241 3388 	movw	r3, #5000	; 0x1388
  * @brief  Checks for error conditions for R3 (OCR) response.
  * @param  hsd SD handle
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp3(SDMMC_TypeDef *SDMMCx)
{
 800d28c:	4602      	mov	r2, r0
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800d28e:	434b      	muls	r3, r1

  do
  {
    if (count-- == 0U)
 800d290:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800d294:	d310      	bcc.n	800d2b8 <SDMMC_GetCmdResp3+0x3c>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
 800d296:	6b51      	ldr	r1, [r2, #52]	; 0x34
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800d298:	f011 0f45 	tst.w	r1, #69	; 0x45
 800d29c:	d0f8      	beq.n	800d290 <SDMMC_GetCmdResp3+0x14>
    if (count-- == 0U)
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 800d29e:	0489      	lsls	r1, r1, #18
 800d2a0:	d4f6      	bmi.n	800d290 <SDMMC_GetCmdResp3+0x14>
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800d2a2:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800d2a4:	f013 0004 	ands.w	r0, r3, #4
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800d2a8:	bf17      	itett	ne
 800d2aa:	2304      	movne	r3, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }
  else
  {
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800d2ac:	4b05      	ldreq	r3, [pc, #20]	; (800d2c4 <SDMMC_GetCmdResp3+0x48>)
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800d2ae:	6393      	strne	r3, [r2, #56]	; 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800d2b0:	4618      	movne	r0, r3
  }
  else
  {
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800d2b2:	bf08      	it	eq
 800d2b4:	6393      	streq	r3, [r2, #56]	; 0x38
 800d2b6:	4770      	bx	lr

  do
  {
    if (count-- == 0U)
    {
      return SDMMC_ERROR_TIMEOUT;
 800d2b8:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
  }

  return SDMMC_ERROR_NONE;
}
 800d2bc:	4770      	bx	lr
 800d2be:	bf00      	nop
 800d2c0:	20000448 	.word	0x20000448
 800d2c4:	002000c5 	.word	0x002000c5

0800d2c8 <SDMMC_CmdAppOperCommand>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Argument Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdAppOperCommand(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d2c8:	b510      	push	{r4, lr}
 800d2ca:	b086      	sub	sp, #24
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  sdmmc_cmdinit.Argument         = Argument;
#else
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | Argument;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_OP_COND;
 800d2cc:	2329      	movs	r3, #41	; 0x29
 800d2ce:	9302      	str	r3, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d2d0:	f44f 7380 	mov.w	r3, #256	; 0x100
 800d2d4:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d2d6:	2300      	movs	r3, #0
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Argument Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdAppOperCommand(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d2d8:	4604      	mov	r4, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  sdmmc_cmdinit.Argument         = Argument;
 800d2da:	9101      	str	r1, [sp, #4]
#else
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | Argument;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_OP_COND;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d2dc:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d2de:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | Argument;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_OP_COND;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d2e0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800d2e4:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d2e6:	f7ff fc79 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp3(SDMMCx);
 800d2ea:	4620      	mov	r0, r4
 800d2ec:	f7ff ffc6 	bl	800d27c <SDMMC_GetCmdResp3>

  return errorstate;
}
 800d2f0:	b006      	add	sp, #24
 800d2f2:	bd10      	pop	{r4, pc}

0800d2f4 <SDMMC_CmdOpCondition>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @parame Argument: Argument used for the command
  * @retval HAL status
  */
uint32_t SDMMC_CmdOpCondition(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d2f4:	b510      	push	{r4, lr}
 800d2f6:	b086      	sub	sp, #24
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_OP_COND;
 800d2f8:	2301      	movs	r3, #1
 800d2fa:	9302      	str	r3, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d2fc:	f44f 7380 	mov.w	r3, #256	; 0x100
 800d300:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d302:	2300      	movs	r3, #0
  * @param  SDMMCx Pointer to SDMMC register base
  * @parame Argument: Argument used for the command
  * @retval HAL status
  */
uint32_t SDMMC_CmdOpCondition(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d304:	4604      	mov	r4, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = Argument;
 800d306:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_OP_COND;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d308:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d30a:	a901      	add	r1, sp, #4

  sdmmc_cmdinit.Argument         = Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_OP_COND;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d30c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800d310:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d312:	f7ff fc63 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp3(SDMMCx);
 800d316:	4620      	mov	r0, r4
 800d318:	f7ff ffb0 	bl	800d27c <SDMMC_GetCmdResp3>

  return errorstate;
}
 800d31c:	b006      	add	sp, #24
 800d31e:	bd10      	pop	{r4, pc}

0800d320 <SDMMC_GetCmdResp6>:
  uint32_t response_r1;
  uint32_t sta_reg;

  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800d320:	4b1e      	ldr	r3, [pc, #120]	; (800d39c <SDMMC_GetCmdResp6+0x7c>)
  * @param  pRCA Pointer to the variable that will contain the SD card relative
  *         address RCA
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp6(SDMMC_TypeDef *SDMMCx, uint8_t SD_CMD, uint16_t *pRCA)
{
 800d322:	b510      	push	{r4, lr}
  uint32_t response_r1;
  uint32_t sta_reg;

  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800d324:	681b      	ldr	r3, [r3, #0]
 800d326:	f44f 54fa 	mov.w	r4, #8000	; 0x1f40
 800d32a:	fbb3 f4f4 	udiv	r4, r3, r4
 800d32e:	f241 3388 	movw	r3, #5000	; 0x1388
 800d332:	4363      	muls	r3, r4

  do
  {
    if (count-- == 0U)
 800d334:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800d338:	d328      	bcc.n	800d38c <SDMMC_GetCmdResp6+0x6c>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
 800d33a:	6b44      	ldr	r4, [r0, #52]	; 0x34
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800d33c:	f014 0f45 	tst.w	r4, #69	; 0x45
 800d340:	d0f8      	beq.n	800d334 <SDMMC_GetCmdResp6+0x14>
    if (count-- == 0U)
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 800d342:	04a4      	lsls	r4, r4, #18
 800d344:	d4f6      	bmi.n	800d334 <SDMMC_GetCmdResp6+0x14>
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800d346:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800d348:	075b      	lsls	r3, r3, #29
 800d34a:	d501      	bpl.n	800d350 <SDMMC_GetCmdResp6+0x30>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800d34c:	2304      	movs	r3, #4
 800d34e:	e003      	b.n	800d358 <SDMMC_GetCmdResp6+0x38>

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800d350:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800d352:	07dc      	lsls	r4, r3, #31
 800d354:	d503      	bpl.n	800d35e <SDMMC_GetCmdResp6+0x3e>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800d356:	2301      	movs	r3, #1
 800d358:	6383      	str	r3, [r0, #56]	; 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
 800d35a:	4618      	mov	r0, r3
 800d35c:	bd10      	pop	{r4, pc}
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval Command index of the last command response received
  */
uint8_t SDMMC_GetCommandResponse(SDMMC_TypeDef *SDMMCx)
{
  return (uint8_t)(SDMMCx->RESPCMD);
 800d35e:	6903      	ldr	r3, [r0, #16]
  {
    /* Nothing to do */
  }

  /* Check response received is of desired command */
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800d360:	b2db      	uxtb	r3, r3
 800d362:	4299      	cmp	r1, r3
 800d364:	d115      	bne.n	800d392 <SDMMC_GetCmdResp6+0x72>
  {
    return SDMMC_ERROR_CMD_CRC_FAIL;
  }

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800d366:	4b0e      	ldr	r3, [pc, #56]	; (800d3a0 <SDMMC_GetCmdResp6+0x80>)
 800d368:	6383      	str	r3, [r0, #56]	; 0x38
  assert_param(IS_SDMMC_RESP(Response));

  /* Get the response */
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;

  return (*(__IO uint32_t *) tmp);
 800d36a:	6943      	ldr	r3, [r0, #20]
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);

  /* We have received response, retrieve it.  */
  response_r1 = SDMMC_GetResponse(SDMMCx, SDMMC_RESP1);

  if((response_r1 & (SDMMC_R6_GENERAL_UNKNOWN_ERROR | SDMMC_R6_ILLEGAL_CMD | SDMMC_R6_COM_CRC_FAILED)) == SDMMC_ALLZERO)
 800d36c:	f413 4060 	ands.w	r0, r3, #57344	; 0xe000
 800d370:	d102      	bne.n	800d378 <SDMMC_GetCmdResp6+0x58>
  {
    *pRCA = (uint16_t) (response_r1 >> 16);
 800d372:	0c1b      	lsrs	r3, r3, #16
 800d374:	8013      	strh	r3, [r2, #0]
 800d376:	bd10      	pop	{r4, pc}

    return SDMMC_ERROR_NONE;
  }
  else if((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
 800d378:	045a      	lsls	r2, r3, #17
 800d37a:	d40c      	bmi.n	800d396 <SDMMC_GetCmdResp6+0x76>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
  }
  else if((response_r1 & SDMMC_R6_COM_CRC_FAILED) == SDMMC_R6_COM_CRC_FAILED)
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
 800d37c:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 800d380:	bf0c      	ite	eq
 800d382:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
 800d386:	f44f 5080 	movne.w	r0, #4096	; 0x1000
 800d38a:	bd10      	pop	{r4, pc}

  do
  {
    if (count-- == 0U)
    {
      return SDMMC_ERROR_TIMEOUT;
 800d38c:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800d390:	bd10      	pop	{r4, pc}
  }

  /* Check response received is of desired command */
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
  {
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800d392:	2001      	movs	r0, #1
 800d394:	bd10      	pop	{r4, pc}

    return SDMMC_ERROR_NONE;
  }
  else if((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
 800d396:	f44f 5000 	mov.w	r0, #8192	; 0x2000
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
  }
}
 800d39a:	bd10      	pop	{r4, pc}
 800d39c:	20000448 	.word	0x20000448
 800d3a0:	002000c5 	.word	0x002000c5

0800d3a4 <SDMMC_CmdSetRelAdd>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  pRCA Card RCA
  * @retval HAL status
  */
uint32_t SDMMC_CmdSetRelAdd(SDMMC_TypeDef *SDMMCx, uint16_t *pRCA)
{
 800d3a4:	b570      	push	{r4, r5, r6, lr}
 800d3a6:	b086      	sub	sp, #24
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = 0U;
 800d3a8:	2300      	movs	r3, #0
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  pRCA Card RCA
  * @retval HAL status
  */
uint32_t SDMMC_CmdSetRelAdd(SDMMC_TypeDef *SDMMCx, uint16_t *pRCA)
{
 800d3aa:	4605      	mov	r5, r0
 800d3ac:	460e      	mov	r6, r1
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = 0U;
 800d3ae:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
 800d3b0:	2403      	movs	r4, #3
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d3b2:	f44f 7280 	mov.w	r2, #256	; 0x100
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d3b6:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d3b8:	a901      	add	r1, sp, #4
  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d3ba:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  uint32_t errorstate;

  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d3be:	9203      	str	r2, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d3c0:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
 800d3c2:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d3c4:	f7ff fc0a 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp6(SDMMCx, SDMMC_CMD_SET_REL_ADDR, pRCA);
 800d3c8:	4632      	mov	r2, r6
 800d3ca:	4621      	mov	r1, r4
 800d3cc:	4628      	mov	r0, r5
 800d3ce:	f7ff ffa7 	bl	800d320 <SDMMC_GetCmdResp6>

  return errorstate;
}
 800d3d2:	b006      	add	sp, #24
 800d3d4:	bd70      	pop	{r4, r5, r6, pc}
	...

0800d3d8 <SDMMC_GetCmdResp7>:
uint32_t SDMMC_GetCmdResp7(SDMMC_TypeDef *SDMMCx)
{
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800d3d8:	4b15      	ldr	r3, [pc, #84]	; (800d430 <SDMMC_GetCmdResp7+0x58>)
 800d3da:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
 800d3de:	681b      	ldr	r3, [r3, #0]
 800d3e0:	fbb3 f1f1 	udiv	r1, r3, r1
 800d3e4:	f241 3388 	movw	r3, #5000	; 0x1388
  * @brief  Checks for error conditions for R7 response.
  * @param  hsd SD handle
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp7(SDMMC_TypeDef *SDMMCx)
{
 800d3e8:	4602      	mov	r2, r0
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800d3ea:	434b      	muls	r3, r1

  do
  {
    if (count-- == 0U)
 800d3ec:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800d3f0:	d31a      	bcc.n	800d428 <SDMMC_GetCmdResp7+0x50>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
 800d3f2:	6b51      	ldr	r1, [r2, #52]	; 0x34
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800d3f4:	f011 0f45 	tst.w	r1, #69	; 0x45
 800d3f8:	d0f8      	beq.n	800d3ec <SDMMC_GetCmdResp7+0x14>
    if (count-- == 0U)
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 800d3fa:	0489      	lsls	r1, r1, #18
 800d3fc:	d4f6      	bmi.n	800d3ec <SDMMC_GetCmdResp7+0x14>
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800d3fe:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800d400:	075b      	lsls	r3, r3, #29
 800d402:	d501      	bpl.n	800d408 <SDMMC_GetCmdResp7+0x30>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800d404:	2304      	movs	r3, #4
 800d406:	e004      	b.n	800d412 <SDMMC_GetCmdResp7+0x3a>

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }

  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800d408:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800d40a:	f013 0101 	ands.w	r1, r3, #1
 800d40e:	d003      	beq.n	800d418 <SDMMC_GetCmdResp7+0x40>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800d410:	2301      	movs	r3, #1
 800d412:	6393      	str	r3, [r2, #56]	; 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
 800d414:	4618      	mov	r0, r3
 800d416:	4770      	bx	lr
  else
  {
    /* Nothing to do */
  }

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDREND))
 800d418:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800d41a:	f013 0040 	ands.w	r0, r3, #64	; 0x40
 800d41e:	d005      	beq.n	800d42c <SDMMC_GetCmdResp7+0x54>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
 800d420:	2340      	movs	r3, #64	; 0x40
 800d422:	6393      	str	r3, [r2, #56]	; 0x38
 800d424:	4608      	mov	r0, r1
 800d426:	4770      	bx	lr

  do
  {
    if (count-- == 0U)
    {
      return SDMMC_ERROR_TIMEOUT;
 800d428:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
  }

  return SDMMC_ERROR_NONE;

}
 800d42c:	4770      	bx	lr
 800d42e:	bf00      	nop
 800d430:	20000448 	.word	0x20000448

0800d434 <SDMMC_CmdOperCond>:
  * @brief  Send the Operating Condition command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdOperCond(SDMMC_TypeDef *SDMMCx)
{
 800d434:	b510      	push	{r4, lr}
 800d436:	b086      	sub	sp, #24
  /* Send CMD8 to verify SD card interface operating condition */
  /* Argument: - [31:12]: Reserved (shall be set to '0')
  - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
  - [7:0]: Check Pattern (recommended 0xAA) */
  /* CMD Response: R7 */
  sdmmc_cmdinit.Argument         = SDMMC_CHECK_PATTERN;
 800d438:	f44f 73d5 	mov.w	r3, #426	; 0x1aa
 800d43c:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
 800d43e:	2308      	movs	r3, #8
 800d440:	9302      	str	r3, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d442:	f44f 7380 	mov.w	r3, #256	; 0x100
 800d446:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d448:	2300      	movs	r3, #0
  * @brief  Send the Operating Condition command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdOperCond(SDMMC_TypeDef *SDMMCx)
{
 800d44a:	4604      	mov	r4, r0
  - [7:0]: Check Pattern (recommended 0xAA) */
  /* CMD Response: R7 */
  sdmmc_cmdinit.Argument         = SDMMC_CHECK_PATTERN;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d44c:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d44e:	a901      	add	r1, sp, #4
  /* CMD Response: R7 */
  sdmmc_cmdinit.Argument         = SDMMC_CHECK_PATTERN;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d450:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800d454:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d456:	f7ff fbc1 	bl	800cbdc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp7(SDMMCx);
 800d45a:	4620      	mov	r0, r4
 800d45c:	f7ff ffbc 	bl	800d3d8 <SDMMC_GetCmdResp7>

  return errorstate;
}
 800d460:	b006      	add	sp, #24
 800d462:	bd10      	pop	{r4, pc}

0800d464 <memcmp>:
 800d464:	b510      	push	{r4, lr}
 800d466:	3901      	subs	r1, #1
 800d468:	4402      	add	r2, r0
 800d46a:	4290      	cmp	r0, r2
 800d46c:	d007      	beq.n	800d47e <memcmp+0x1a>
 800d46e:	f810 3b01 	ldrb.w	r3, [r0], #1
 800d472:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 800d476:	42a3      	cmp	r3, r4
 800d478:	d0f7      	beq.n	800d46a <memcmp+0x6>
 800d47a:	1b18      	subs	r0, r3, r4
 800d47c:	bd10      	pop	{r4, pc}
 800d47e:	2000      	movs	r0, #0
 800d480:	bd10      	pop	{r4, pc}

0800d482 <memcpy>:
 800d482:	b510      	push	{r4, lr}
 800d484:	1e43      	subs	r3, r0, #1
 800d486:	440a      	add	r2, r1
 800d488:	4291      	cmp	r1, r2
 800d48a:	d004      	beq.n	800d496 <memcpy+0x14>
 800d48c:	f811 4b01 	ldrb.w	r4, [r1], #1
 800d490:	f803 4f01 	strb.w	r4, [r3, #1]!
 800d494:	e7f8      	b.n	800d488 <memcpy+0x6>
 800d496:	bd10      	pop	{r4, pc}

0800d498 <memmove>:
 800d498:	4288      	cmp	r0, r1
 800d49a:	b510      	push	{r4, lr}
 800d49c:	eb01 0302 	add.w	r3, r1, r2
 800d4a0:	d801      	bhi.n	800d4a6 <memmove+0xe>
 800d4a2:	1e42      	subs	r2, r0, #1
 800d4a4:	e00b      	b.n	800d4be <memmove+0x26>
 800d4a6:	4298      	cmp	r0, r3
 800d4a8:	d2fb      	bcs.n	800d4a2 <memmove+0xa>
 800d4aa:	1881      	adds	r1, r0, r2
 800d4ac:	1ad2      	subs	r2, r2, r3
 800d4ae:	42d3      	cmn	r3, r2
 800d4b0:	d004      	beq.n	800d4bc <memmove+0x24>
 800d4b2:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 800d4b6:	f801 4d01 	strb.w	r4, [r1, #-1]!
 800d4ba:	e7f8      	b.n	800d4ae <memmove+0x16>
 800d4bc:	bd10      	pop	{r4, pc}
 800d4be:	4299      	cmp	r1, r3
 800d4c0:	d004      	beq.n	800d4cc <memmove+0x34>
 800d4c2:	f811 4b01 	ldrb.w	r4, [r1], #1
 800d4c6:	f802 4f01 	strb.w	r4, [r2, #1]!
 800d4ca:	e7f8      	b.n	800d4be <memmove+0x26>
 800d4cc:	bd10      	pop	{r4, pc}

0800d4ce <memset>:
 800d4ce:	4402      	add	r2, r0
 800d4d0:	4603      	mov	r3, r0
 800d4d2:	4293      	cmp	r3, r2
 800d4d4:	d002      	beq.n	800d4dc <memset+0xe>
 800d4d6:	f803 1b01 	strb.w	r1, [r3], #1
 800d4da:	e7fa      	b.n	800d4d2 <memset+0x4>
 800d4dc:	4770      	bx	lr
	...

0800d4e0 <setjmp>:
 800d4e0:	46ec      	mov	ip, sp
 800d4e2:	e8a0 5ff0 	stmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
 800d4e6:	f04f 0000 	mov.w	r0, #0
 800d4ea:	4770      	bx	lr

0800d4ec <longjmp>:
 800d4ec:	e8b0 5ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
 800d4f0:	46e5      	mov	sp, ip
 800d4f2:	0008      	movs	r0, r1
 800d4f4:	bf08      	it	eq
 800d4f6:	2001      	moveq	r0, #1
 800d4f8:	4770      	bx	lr
 800d4fa:	bf00      	nop

0800d4fc <strlcpy>:
 800d4fc:	b510      	push	{r4, lr}
 800d4fe:	460b      	mov	r3, r1
 800d500:	b152      	cbz	r2, 800d518 <strlcpy+0x1c>
 800d502:	3a01      	subs	r2, #1
 800d504:	d006      	beq.n	800d514 <strlcpy+0x18>
 800d506:	f813 4b01 	ldrb.w	r4, [r3], #1
 800d50a:	f800 4b01 	strb.w	r4, [r0], #1
 800d50e:	2c00      	cmp	r4, #0
 800d510:	d1f7      	bne.n	800d502 <strlcpy+0x6>
 800d512:	e005      	b.n	800d520 <strlcpy+0x24>
 800d514:	2200      	movs	r2, #0
 800d516:	7002      	strb	r2, [r0, #0]
 800d518:	f813 2b01 	ldrb.w	r2, [r3], #1
 800d51c:	2a00      	cmp	r2, #0
 800d51e:	d1fb      	bne.n	800d518 <strlcpy+0x1c>
 800d520:	1a58      	subs	r0, r3, r1
 800d522:	3801      	subs	r0, #1
 800d524:	bd10      	pop	{r4, pc}

0800d526 <strlen>:
 800d526:	4603      	mov	r3, r0
 800d528:	f813 2b01 	ldrb.w	r2, [r3], #1
 800d52c:	2a00      	cmp	r2, #0
 800d52e:	d1fb      	bne.n	800d528 <strlen+0x2>
 800d530:	1a18      	subs	r0, r3, r0
 800d532:	3801      	subs	r0, #1
 800d534:	4770      	bx	lr
	...

0800d538 <__flash_burn_veneer>:
 800d538:	b401      	push	{r0}
 800d53a:	4802      	ldr	r0, [pc, #8]	; (800d544 <__flash_burn_veneer+0xc>)
 800d53c:	4684      	mov	ip, r0
 800d53e:	bc01      	pop	{r0}
 800d540:	4760      	bx	ip
 800d542:	bf00      	nop
 800d544:	20000001 	.word	0x20000001

0800d548 <__flash_page_erase_veneer>:
 800d548:	b401      	push	{r0}
 800d54a:	4802      	ldr	r0, [pc, #8]	; (800d554 <__flash_page_erase_veneer+0xc>)
 800d54c:	4684      	mov	ip, r0
 800d54e:	bc01      	pop	{r0}
 800d550:	4760      	bx	ip
 800d552:	bf00      	nop
 800d554:	20000095 	.word	0x20000095
 800d558:	65737361 	.word	0x65737361
 800d55c:	69007472 	.word	0x69007472
 800d560:	6e6f636e 	.word	0x6e6f636e
 800d564:	00          	.byte	0x00
 800d565:	44          	.byte	0x44
 800d566:	6569      	.short	0x6569
 800d568:	4644203a 	.word	0x4644203a
 800d56c:	69440055 	.word	0x69440055
 800d570:	44203a65 	.word	0x44203a65
 800d574:	676e776f 	.word	0x676e776f
 800d578:	65646172 	.word	0x65646172
 800d57c:	65694400 	.word	0x65694400
 800d580:	6c42203a 	.word	0x6c42203a
 800d584:	696b6e61 	.word	0x696b6e61
 800d588:	44006873 	.word	0x44006873
 800d58c:	203a6569 	.word	0x203a6569
 800d590:	63697242 	.word	0x63697242
 800d594:	6f42006b 	.word	0x6f42006b
 800d598:	4432746f 	.word	0x4432746f
 800d59c:	4c005546 	.word	0x4c005546
 800d5a0:	0052      	.short	0x0052
 800d5a2:	6e65      	.short	0x6e65
 800d5a4:	5f726574 	.word	0x5f726574
 800d5a8:	28756664 	.word	0x28756664
 800d5ac:	0a0d0029 	.word	0x0a0d0029
 800d5b0:	346b4d0a 	.word	0x346b4d0a
 800d5b4:	6f6f4220 	.word	0x6f6f4220
 800d5b8:	616f6c74 	.word	0x616f6c74
 800d5bc:	3a726564 	.word	0x3a726564
 800d5c0:	45530020 	.word	0x45530020
 800d5c4:	65732031 	.word	0x65732031
 800d5c8:	3a707574 	.word	0x3a707574
 800d5cc:	6f640020 	.word	0x6f640020
 800d5d0:	5300656e 	.word	0x5300656e
 800d5d4:	73203245 	.word	0x73203245
 800d5d8:	70757465 	.word	0x70757465
 800d5dc:	5600203a 	.word	0x5600203a
 800d5e0:	66697265 	.word	0x66697265
 800d5e4:	00203a79 	.word	0x00203a79
 800d5e8:	00000150 	.word	0x00000150
 800d5ec:	00000001 	.word	0x00000001
 800d5f0:	00000000 	.word	0x00000000
 800d5f4:	00000001 	.word	0x00000001
 800d5f8:	00000000 	.word	0x00000000

0800d5fc <before_show>:
 800d5fc:	227f0021 00210700                                !.."..

0800d602 <setup.9057>:
 800d602:	227f0021 262e0707                                !.."..

0800d608 <animate.9058>:
 800d608:	0700262e ff000707 0020ae2f                       .&....../

0800d611 <reset_commands>:
 800d611:	400020ae c83fa8a1 12da00d3 f1d980d5     . .@..?.........
 800d621:	ff8130db 148da6a4 3a007faf                       .0.......

0800d62a <screen_verify>:
 800d62a:	003a007f c0c08083 c003e006 006f8081     ..:...........o.
 800d63a:	fefcf095 0103071f fc808081 010100fc     ................
 800d64a:	fe7f0f03 006bc0f8 3f1f0788 c0e0f07c     ......k....?|...
 800d65a:	898104c1 e0c0c080 0f3f7ff8 82007001     ..........?..p..
 800d66a:	03070101 5c010182 04f88100 00f88300     .......\........
 800d67a:	84400480 80c00080 80864003 40400000     ..@......@....@@
 800d68a:	810004d8 830803f0 04c00010 00c08600     ................
 800d69a:	d8404000 c0820003 83400380 03800080     .@@.......@.....
 800d6aa:	c0808240 01880042 06181806 040f0001     @...B...........
 800d6ba:	00138312 8100091f 8200031f 01031f01     ................
 800d6ca:	47000083 84828803 8100047f 8100031f     ...G............
 800d6da:	8300041f 0347001f 7f848288 0022007f     ......G.......".
	...

0800d6eb <screen_corrupt>:
 800d6eb:	003b007f c0878003 60604040 c0044040     ..;.....@@``@@..
 800d6fb:	006c8081 1cf8c087 01010306 0f83000b     ..l.............
 800d70b:	006bc0ff 00ffff83 00038004 c0868004     ..k.............
 800d71b:	1e3870e0 81006c07 81030301 82030801     .p8..l..........
 800d72b:	005d0101 8804f881 00000886 03d84040     ..].........@@..
 800d73b:	80c08200 808a4003 4040c000 00804080     .....@....@@.@..
 800d74b:	830004c0 040000c0 00808440 400380c0     ........@......@
 800d75b:	80008083 80874004 88080800 00433048     .....@......H0C.
 800d76b:	00091f81 00031f81 00061f81 00001f8f     ................
 800d77b:	001f0007 0f08100f 0e000f10 09841103     ................
 800d78b:	061f001f 040f8100 00138412 007f1b00     ................
 800d79b:	7f000026                                         &..

0800d79e <screen_devmode>:
 800d79e:	0037007f 2090b085 001040f0 05e08082     ..7.... .@......
 800d7ae:	f0f884f0 004d80e0 70e08088 e6ce8c18     ......M....p....
 800d7be:	81fe05f6 86fe04fc 0000019b 000e0101     ................
 800d7ce:	fff3b18f f3e3f3ff f3e3e3ff b1f3f7ff     ................
 800d7de:	1f82004b 82ff0f7f 00111f7f ff05fc81     K...............
 800d7ee:	f180fc87 fec0e1ff f881ff05 0182004c     ............L...
 800d7fe:	82070903 00150103 030f0181 00330181     ..............3.
 800d80e:	0803f881 00e01084 84400400 80c00080     ..........@.....
 800d81e:	80834003 40038000 00c08084 84400480     .@.....@......@.
 800d82e:	80c00080 80814003 f8810003 f081000b     .....@..........
 800d83e:	30830804 0004c000 8000c083 80844004     ...0.........@..
 800d84e:	03f04000 00008340 88400480 40c00080     .@..@.....@....@
 800d85e:	80408040 f8810003 1f81001b 08841003     @.@.............
 800d86e:	030e0007 1f098411 00041f00 47001f83     ...............G
 800d87e:	84848803 040f007f 00138312 8100081f     ................
 800d88e:	81000b1b 8310040f 030f000c 1f088410     ................
 800d89e:	12040900 00000c84 8310030f 040f0008     ................
 800d8ae:	000f8810 0700001f 00031f00 007f1b81     ................
 800d8be:	7f000010                                         ...

0800d8c1 <screen_downgrade>:
 800d8c1:	0036007f 80c0c085 c0038000 c084e005     ..6.............
 800d8d1:	6f8080c0 8f3f0600 0101113b 0101f9f8     ...o..?.;.......
 800d8e1:	ff1f0703 6dc0f8fe 70208600 e3e0f0f8     .......m.. p....
 800d8f1:	c089c304 7cf0e0e0 010f1f7f 01090071     .......|....q...
 800d901:	f881005a 10840803 048000e0 00808340     Z...........@...
 800d911:	840004c0 80c000c0 80834003 40038000     .........@.....@
 800d921:	00c08085 400380c0 00008083 80834004     .......@.....@..
 800d931:	40038000 00f88084 87400480 08080080     ...@......@.....
 800d941:	3c304888 031f8100 07088410 10040f00     .H0<............
 800d951:	0f000f8a 100f0810 041f000f 001f8300     ................
 800d961:	84880347 1f007f84 0e810006 09841103     G...............
 800d971:	030f001f 1f088410 12040f00 00001384     ................
 800d981:	22007f1b 007f0000                                ..."..

0800d987 <screen_logout>:
 800d987:	0038007f 00778007 03fffe82 04f10301     ..8...w.........
 800d997:	ffff89f0 f0f8fcfe 6b80c0e0 7f3f8200     ...........k..?.
 800d9a7:	c703c003 07038781 3f7fff88 03070f1f     ...........?....
 800d9b7:	52007f01 06f88100 04808100 00808340     ...R........@...
 800d9c7:	84400380 8000c080 80834004 0004c000     ..@......@......
 800d9d7:	4000c084 094003f0 03f88100 e0108408     ...@..@.........
 800d9e7:	40048000 c0008084 83400380 04800080     ...@......@.....
 800d9f7:	34808140 051f8100 0f008210 0f831004     @..4............
 800da07:	88034700 007f8484 8310040f 030f000f     .G..............
 800da17:	1f088510 030f0000 08088110 031f8100     ................
 800da27:	07088410 10040f00 1f000f83 1f830004     ................
 800da37:	12040f00 007f1381 7f00001b                       ...........

0800da42 <screen_se2_issue>:
 800da42:	0038007f 00048081 04e0c082 c0e082f0     ..8.............
 800da52:	80840072 05fe8783 0c0c82fc fe85fc05     r...............
 800da62:	80818387 0103006a 03e78182 ffff867f     ....j...........
 800da72:	ffff0000 ef857f03 010181c1 0182006c     ............l...
 800da82:	82000e01 00630101 0004f881 f800f883     ......c.........
 800da92:	88824804 89800600 88887000 00100808     .H.......p......
 800daa2:	838804f8 03300008 70888208 0f810057     ......0....pW...
 800dab2:	0f831004 10040800 06000f82 08008904     ................
 800dac2:	11111010 051f000e 18008710 10111214     ................
 800dad2:	2c007f10 007f0000                                ...,..

0800dad8 <screen_red_light>:
 800dad8:	0037007f 2090b085 001040f0 05e08082     ..7.... .@......
 800dae8:	f0f884f0 004d80e0 70e08088 e6ce8c18     ......M....p....
 800daf8:	81fe05f6 86fe04fc 0000019b 000e0101     ................
 800db08:	fff3b18f f3e3f3ff f3e3e3ff b1f3f7ff     ................
 800db18:	1f82004b 82ff0f7f 00111f7f ff05fc81     K...............
 800db28:	f180fc87 fec0e1ff f881ff05 0182004c     ............L...
 800db38:	82070903 00150103 030f0181 00300181     ..............0.
 800db48:	0803f881 00e01084 84400400 80c00080     ..........@.....
 800db58:	80834003 40038000 00c08084 84400480     .@.....@......@.
 800db68:	80c00080 80814003 f8810003 f081000b     .....@..........
 800db78:	30830804 40040000 c0008083 c0840004     ...0...@........
 800db88:	03f04000 83000340 03d84040 04808100     .@..@...@@......
 800db98:	00808440 400380c0 00038081 0014f881     @......@........
 800dba8:	10031f81 00070884 8411030e 1f001f09     ................
 800dbb8:	1f830004 88034700 007f8484 8312040f     .....G..........
 800dbc8:	081f0013 0b1b8100 040f8100 000c8310     ................
 800dbd8:	8411030e 0f001f09 08851003 0f00001f     ................
 800dbe8:	08811003 1f810004 0f810003 0f831004     ................
 800dbf8:	00041f00 00031f81 007f1b81 7f00000c              ...............

0800dc07 <screen_upgrading>:
 800dc07:	0033007f 11e0e082 66800700 ffff8200     ..3........f....
 800dc17:	80920006 e0f0e0c0 e0c080c0 7ffcf8f0     ................
 800dc27:	1f0f1f3f 8d00661f 1000ffff 1f3e7c38     ?....f......8|>.
 800dc37:	0303070f 830f0307 6d010307 54031b00     ...........m...T
 800dc47:	04f88100 00f88400 400380c0 80008083     ...........@....
 800dc57:	80854003 80c000c0 80834003 40040000     .@.......@.....@
 800dc67:	80008083 80874003 400000f8 0003d840     .....@.....@@...
 800dc77:	0380c082 00808340 82400380 0042c080     ....@.....@...B.
 800dc87:	10040f81 7f000f84 83080304 03470007     ..............G.
 800dc97:	7f848488 00061f00 11030e81 001f0984     ................
 800dca7:	8210030f 00041f08 00031f81 00041f81     ................
 800dcb7:	47001f83 84828803 22007f7f 007f0000              ...G......."..

0800dcc5 <screen_fatal>:
 800dcc5:	007f007f 0036007f 90fc9089 0090fc90     ......6.........
 800dcd5:	4203fc40 f000048b 00c00000 fc4000f0     @..B..........@.
 800dce5:	04814203 03840066 03030000 05078100     .B..f...........
 800dcf5:	04038900 03040302 7f070000 7f007f00     ................
 800dd05:	00003900                                .9..

0800dd09 <screen_blankish>:
 800dd09:	007f007f 0034007f 000d8081 000d8081     ......4.........
 800dd19:	00628081 01030183 0183000b 000b0103     ..b.............
 800dd29:	01030183 007f007f 0034007f 39007f00              ..........4..

0800dd36 <screen_wiped>:
 800dd36:	0039007f 00878004 f0f8f800 80030000     ..9.............
 800dd46:	f089006f 073ffffc 00000103 00897f03     o.....?.........
 800dd56:	0f070300 c0f8feff 0388006b f87f3f1f     ........k....?..
 800dd66:	05e0e0f0 e0e087c0 1f3f7cf0 0900720f     .........|?..r..
 800dd76:	88005a01 08888870 80001008 80834004     .Z..p........@..
 800dd86:	40048000 80008083 80824003 810008f8     ...@.....@......
 800dd96:	860004f8 400000f8 0003d840 0380c082     .......@@.......
 800dda6:	00808340 83400480 03800080 f8808240     @.....@.....@...
 800ddb6:	0888003b 11111010 040f000e 00138312     ;...............
 800ddc6:	8312040f 030f0013 1f088210 07860008     ................
 800ddd6:	18070718 81000407 8200031f 0803047f     ................
 800dde6:	0f000783 13831204 10030f00 7f1f0882     ................
 800ddf6:	00001e00                                ....

0800ddfa <screen_replug>:
 800ddfa:	007f007f 002f007f 0804f881 8000f083     ....../.........
 800de0a:	80844004 0380c000 00808440 0005f800     .@......@.......
 800de1a:	0004c081 8000c083 80824003 880057c0     .........@...W..
 800de2a:	0503011f 0f001009 13841204 03047f00     ................
 800de3a:	00078408 10030f00 0f000083 08841003     ................
 800de4a:	0347001f 7f848288 007f007f 002e007f     ..G.............
	...

0800de5b <screen_brick>:
 800de5b:	007f007f 002b007f 8803f881 0000f085     ......+.........
 800de6b:	400380c0 00008086 03d84040 04808100     ...@....@@......
 800de7b:	00808a40 800000f8 80000040 80834004     @.......@....@..
 800de8b:	40038000 50f88082 041f8100 000f8310     ...@...P........
 800de9b:	8100091f 8100031f 8a10040f 021f0008     ................
 800deab:	10080403 12040f00 0f001383 08821003     ................
 800debb:	7f007f1f 2b007f00 007f0000                       .......+..

0800dec5 <screen_search>:
 800dec5:	002b007f c0c08083 c003e006 000c8081     ..+.............
 800ded5:	60e0e083 6003e006 60e0e085 005380c0     ...`...`...`..S.
 800dee5:	fffef886 0303071f 03008101 07038601     ................
 800def5:	f0fcffff ff840009 051f00ff 8930033f     ............?.0.
 800df05:	00001f3f fc060301 86004ff8 3f1f0f03     ?........O.....?
 800df15:	f003787c f0f0e08c 7f7c7870 c0e1f7ff     |x......px|.....
 800df25:	85000780 fc00ffff 86060afe 0000fefe     ................
 800df35:	0060ffff 03030182 81000607 81031301     ..`.............
 800df45:	88003f01 08888870 80001008 80834004     .?..p........@..
 800df55:	40040000 c0008084 83400380 04800080     ...@......@.....
 800df65:	00808440 400380f8 00008086 03d84040     @......@....@@..
 800df75:	80c08200 80834003 40038000 42c08082     .....@.....@...B
 800df85:	10088800 0e111110 12040f00 0e001383     ................
 800df95:	09841103 061f001f 040f8100 00088310     ................
 800dfa5:	8100041f 8100041f 8100031f 8300041f     ................
 800dfb5:	0347001f 7f848788 38100000 83000410     ..G........8....
 800dfc5:	04103810 38108300 19007f10 007f0000              .8.....8......

0800dfd3 <screen_mitm>:
 800dfd3:	007f007f 0043007f 0c30c083 01060073     ......C...0.s...
 800dfe3:	0c300084 06000403 7f007f01 39007f00     ..0............9
	...

0800dff5 <screen_recovery>:
 800dff5:	0030007f c0c08084 83001080 0660e0e0     ..0...........`.
 800e005:	856003e0 c060e0e0 07005480 c7c38cc0     ..`...`..T......
 800e015:	feffdfcf e0f0f8fc 000880c0 00ffff84     ................
 800e025:	033f051f 1f3f8930 03010000 50f8fc06     ..?.0.?........P
 800e035:	83070700 03f7e7c7 3f7f87ff 03070f1f     ...........?....
 800e045:	85000701 fc00ffff 86060afe 0000fefe     ................
 800e055:	0057ffff 07070385 000f0103 03130181     ..W.............
 800e065:	00420181 f8080889 00000808 400380c0     ..B............@
 800e075:	80008083 80834004 40048000 c0008084     .....@.....@....
 800e085:	84400380 f0400080 00094003 0804f081     ..@...@..@......
 800e095:	00003083 80844004 0380c000 00808340     .0...@......@...
 800e0a5:	82400380 0034f880 1f101088 00001010     ..@...4.........
 800e0b5:	8300041f 0409001f 000c8312 8312040f     ................
 800e0c5:	071f0013 030f8100 08088110 040f8100     ................
 800e0d5:	000c8310 8411030e 1f001f09 0f810006     ................
 800e0e5:	08821003 1b007f1f 007f0000                       ..........

0800e0ef <screen_se1_issue>:
 800e0ef:	0038007f 00048081 04e0c082 c0e082f0     ..8.............
 800e0ff:	80840072 05fe8783 0c0c82fc fe85fc05     r...............
 800e10f:	80818387 0103006a 03e78182 ffff867f     ....j...........
 800e11f:	ffff0000 ef857f03 010181c1 0182006c     ............l...
 800e12f:	82000e01 00630101 0004f881 0000f889     ......c.........
 800e13f:	f80830c0 80060000 88700089 10080888     .0........p.....
 800e14f:	8804f800 40000886 59f81020 040f8100     .......@ ..Y....
 800e15f:	000f8310 83020303 0600021f 08008904     ................
 800e16f:	11111010 051f000e 81000410 2e007f1f     ................
 800e17f:	6f640000 72676e77 00656461 20676973     ..downgrade.sig 
 800e18f:	6c696166 52415700 52203a4e 6c206465     fail.WARN: Red l
 800e19f:	74686769 52415700 55203a4e 6769736e     ight.WARN: Unsig
 800e1af:	2064656e 6d726966 65726177 6f6f4700     ned firmware.Goo
 800e1bf:	69662064 61776d72 63006572 7572726f     d firmware.corru
 800e1cf:	66207470 776d7269 00657261 66206f6e     pt firmware.no f
 800e1df:	776d7269 00657261                       irmware.

0800e1e7 <approved_pubkeys>:
 800e1e7:	2641cbb4 f36ce1f7 71b4f28f 0123fb1d     ..A&..l....q..#.
 800e1f7:	66d6760d 6ca38aa7 f6f9539b 0518587b     .v.f...l.S..{X..
 800e207:	e93b0b58 b89fc431 113c0444 470f0896     X.;.1...D.<....G
 800e217:	37ed2581 4a9e237a 3818b7af da0438ba     .%.7z#.J...8.8..
 800e227:	1dc8a2d6 df5e811c 6d290ca6 8d8f57b8     ......^...)m.W..
 800e237:	9269295e c178d1ce 31d7207b b596a17b     ^)i...x.{ .1{...
 800e247:	0c1bef3d c31a79aa c8c45845 ffeb2d8a     =....y..EX...-..
 800e257:	01829bfe bc5e5f87 4fe5a596 9ffe68c7     ....._^....O.h..
 800e267:	0166ef42 95cfc456 38f0b5f4 c5261164     B.f.V......8d.&.
 800e277:	66c13999 14120632 689c254c bad38c35     .9.f2...L%.h5...
 800e287:	8cde7824 6cdfab52 7809bfb8 3a63bb03     $x..R..l...x..c:
 800e297:	0ed90111 8f737aa4 7f3b18bf c87b0af0     .....zs...;...{.
 800e2a7:	56546067 c5ec0c82 0882bc1d ef39c116     g`TV..........9.
 800e2b7:	32babff5 e35fce7c d7621e74 4cc5fce9     ...2|._.t.b....L
 800e2c7:	8d11e88a 13c2adc3 2a4f2992 a4f8d2ea     .........)O*....
 800e2d7:	fe7cd5c4 3b450512 07598954 88d7d6da     ..|...E;T.Y.....
 800e2e7:	37cfb143 1f897cd2 f3acfe5b 95fc33ba     C..7.|..[....3..
 800e2f7:	dde7d981 14ef9525 bb97efdd a7d8f333     ....%.......3...
 800e307:	977a2b34 73aab3ba 32419de7 17a1fcd8     4+z....s..A2....
 800e317:	fe0bb566 89214063 8e7b92c9 590bdf72     f...c@!...{.r..Y
	...
 800e367:	20314553 666e6f63 66206769 006c6961     SE1 config fail.
 800e377:	6c706572 72206775 69757165 00646572     replug required.
 800e387:	72726f63 20747075 72696170 63657320     corrupt pair sec
 800e397:	206b6d00 6c6c7566 73616600 72622074     .mk full.fast br
 800e3a7:	08006b63 00000141 00000000 00000000     ck..A...........
 800e3b7:	01ee0000 706f4323 67697279 32207468     ....#Copyright 2
 800e3c7:	2d383130 20796220 6e696f43 6574696b     018- by Coinkite
 800e3d7:	636e4920 6f6e002e 72657320 206b7700      Inc..no ser.wk 
 800e3e7:	02006c66                                         fl.

0800e3ea <config_2.9778>:
 800e3ea:	00001502 003c0000 01bc005c 01bc01fc     ......<.\.......
 800e3fa:	019c019c 03dc03d1 03dc03dc 03dc03dc     ................
 800e40a:	01dc03dc 00e1003c                                ....<.

0800e410 <config_1.9777>:
 800e410:	006100e1 808f0000 438f808f 430080af     ..a........C...C
 800e420:	20834300 43c343c3 43c343c3 43c343c3     .C. .C.C.C.C.C.C
 800e430:	0000438f ffffffff 00000000 ffffffff     .C..............
	...
 800e448:	000000f0 00000000 00000000 00000001     ................
 800e458:	00000012 00000000 00000001 00000008     ................
 800e468:	00000200 00000002 00000000 00000001     ................
 800e478:	00000007                                ....

0800e47c <CSWTCH.23>:
 800e47c:	0d0c0b09                                ....

0800e480 <version_string>:
 800e480:	2e302e33 69742030 323d656d 30323230     3.0.0 time=20220
 800e490:	2e373131 32303131 67203731 6d3d7469     117.110217 git=m
 800e4a0:	3340346b 36656663 0d006665 3130000a              k4@3cfe6ef....

0800e4ae <hexmap>:
 800e4ae:	33323130 37363534 62613938 66656463     0123456789abcdef

0800e4be <CSWTCH.73>:
 800e4be:	08020401                                ....

0800e4c2 <CSWTCH.74>:
 800e4c2:	10101000 10101004 10101002 fc000008     ................
 800e4d2:	00020000 00000000 00030000 000a0000     ................
 800e4e2:	00080000 00100000 53500000 204d4152     ..........PSRAM 
 800e4f2:	6c696166 52535000 616e203a 50006164     fail.PSR: nada.P
 800e502:	203a5253 65686321 50006b63 203a5253     SR: !check.PSR: 
 800e512:	73726576 006e6f69 1f000000 00020000     version.........
 800e522:	00010000 00030000 000c0000 00040000     ................
 800e532:	00020000 00010000 00030000 000c0000     ................
 800e542:	46440000 61702055 20657372 6c696166     ..DFU parse fail
 800e552:	6f6f6700 69662064 61776d72 77006572     .good firmware.w
 800e562:	676e6f72 726f7720 5300646c 72614344     rong world.SDCar
 800e572:	00203a64 74696e69 69616620 7073006c     d: .init fail.sp
 800e582:	00646565 65646977 69736200 003f657a     eed.wide.bsize?.
 800e592:	66006b6f 206c6961 64616572 75664400     ok.fail read.Dfu
 800e5a2:	66006553 646e756f 00204020 6f636552     Se.found @ .Reco
 800e5b2:	79726576 646f6d20 00002e65 20080000              very mode.....

0800e5c0 <curve_secp256k1>:
 800e5c0:	01002008 fffffc2f fffffffe ffffffff     . ../...........
 800e5d0:	ffffffff ffffffff ffffffff ffffffff     ................
 800e5e0:	ffffffff d0364141 bfd25e8c af48a03b     ....AA6..^..;.H.
 800e5f0:	baaedce6 fffffffe ffffffff ffffffff     ................
 800e600:	ffffffff 16f81798 59f2815b 2dce28d9     ........[..Y.(.-
 800e610:	029bfcdb ce870b07 55a06295 f9dcbbac     .........b.U....
 800e620:	79be667e fb10d4b8 9c47d08f a6855419     ~f.y......G..T..
 800e630:	fd17b448 0e1108a8 5da4fbfc 26a3c465     H..........]e..&
 800e640:	483ada77 00000007 00000000 00000000     w.:H............
	...
 800e664:	080066e1 0800599b 08005bc7 08005d8d     .f...Y...[...]..

0800e674 <curve_secp256r1>:
 800e674:	01002008 ffffffff ffffffff ffffffff     . ..............
	...
 800e690:	00000001 ffffffff fc632551 f3b9cac2     ........Q%c.....
 800e6a0:	a7179e84 bce6faad ffffffff ffffffff     ................
 800e6b0:	00000000 ffffffff d898c296 f4a13945     ............E9..
 800e6c0:	2deb33a0 77037d81 63a440f2 f8bce6e5     .3.-.}.w.@.c....
 800e6d0:	e12c4247 6b17d1f2 37bf51f5 cbb64068     GB,....k.Q.7h@..
 800e6e0:	6b315ece 2bce3357 7c0f9e16 8ee7eb4a     .^1kW3.+...|J...
 800e6f0:	fe1a7f9b 4fe342e2 27d2604b 3bce3c3e     .....B.OK`.'><.;
 800e700:	cc53b0f6 651d06b0 769886bc b3ebbd55     ..S....e...vU...
 800e710:	aa3a93e7 5ac635d8 08005ea9 0800599b     ..:..5.Z.^...Y..
 800e720:	08005ff3 08005bf5                       ._...[..

0800e728 <AHBPrescTable>:
	...
 800e730:	04030201 09080706                       ........

0800e738 <APBPrescTable>:
 800e738:	00000000 04030201                       ........

0800e740 <MSIRangeTable>:
 800e740:	000186a0 00030d40 00061a80 000c3500     ....@........5..
 800e750:	000f4240 001e8480 003d0900 007a1200     @B........=...z.
 800e760:	00f42400 016e3600 01e84800 02dc6c00     .$...6n..H...l..
 800e770:	00006000 00000012 00000000 00000003     .`..............
 800e780:	00000004 00007021                                ....!p.

0800e787 <DEV_MANID>:
 800e787:	00008000 00000000                                .....

Disassembly of section .relocate:

20000000 <flash_burn>:
//
    __attribute__((section(".ramfunc")))
    __attribute__((noinline))
    int
flash_burn(uint32_t address, uint64_t val)
{
20000000:	b530      	push	{r4, r5, lr}
    __attribute__((section(".ramfunc")))
    __attribute__((always_inline))
    static inline uint32_t
_flash_wait_done(void)
{
    while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) {
20000002:	4d22      	ldr	r5, [pc, #136]	; (2000008c <BL_SRAM_BASE+0x8c>)
20000004:	692c      	ldr	r4, [r5, #16]
20000006:	4921      	ldr	r1, [pc, #132]	; (2000008c <BL_SRAM_BASE+0x8c>)
20000008:	03e4      	lsls	r4, r4, #15
2000000a:	d4fb      	bmi.n	20000004 <flash_burn+0x4>
        // busy wait
    }

    uint32_t error = (FLASH->SR & FLASH_FLAG_SR_ERRORS);
2000000c:	690d      	ldr	r5, [r1, #16]
    if(error) {
2000000e:	4c20      	ldr	r4, [pc, #128]	; (20000090 <BL_SRAM_BASE+0x90>)
20000010:	402c      	ands	r4, r5
20000012:	b924      	cbnz	r4, 2000001e <flash_burn+0x1e>
        // Save an error code; somewhat random, depends on chip details
        return error;
    }

    // Check FLASH End of Operation flag
    if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP)) {
20000014:	690c      	ldr	r4, [r1, #16]
20000016:	07e4      	lsls	r4, r4, #31
        // Clear FLASH End of Operation pending bit
        __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
20000018:	bf44      	itt	mi
2000001a:	2401      	movmi	r4, #1
2000001c:	610c      	strmi	r4, [r1, #16]

    // just in case?
    _flash_wait_done();

    // clear any and all errors, including PEMPTY
    FLASH->SR = FLASH->SR & FLASH_FLAG_SR_ERRORS;
2000001e:	491b      	ldr	r1, [pc, #108]	; (2000008c <BL_SRAM_BASE+0x8c>)
20000020:	4c1b      	ldr	r4, [pc, #108]	; (20000090 <BL_SRAM_BASE+0x90>)
20000022:	690d      	ldr	r5, [r1, #16]
20000024:	402c      	ands	r4, r5
20000026:	610c      	str	r4, [r1, #16]

    // disable data cache
    __HAL_FLASH_DATA_CACHE_DISABLE();
20000028:	680c      	ldr	r4, [r1, #0]
2000002a:	f424 6480 	bic.w	r4, r4, #1024	; 0x400
2000002e:	600c      	str	r4, [r1, #0]

    // Program double-word (64-bit) at a specified address
    // see FLASH_Program_DoubleWord(Address, Data);

    // Set PG bit
    CLEAR_BIT(FLASH->CR, (FLASH_CR_PG | FLASH_CR_MER1 | FLASH_CR_PER | FLASH_CR_PNB));      // added
20000030:	694c      	ldr	r4, [r1, #20]
20000032:	f424 64ff 	bic.w	r4, r4, #2040	; 0x7f8
20000036:	f024 0407 	bic.w	r4, r4, #7
2000003a:	614c      	str	r4, [r1, #20]
    SET_BIT(FLASH->CR, FLASH_CR_PG);
2000003c:	694c      	ldr	r4, [r1, #20]
2000003e:	f044 0401 	orr.w	r4, r4, #1
20000042:	614c      	str	r4, [r1, #20]

    // Program a double word
    *(__IO uint32_t *)(address) = (uint32_t)val;
20000044:	6002      	str	r2, [r0, #0]
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__STATIC_FORCEINLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
20000046:	f3bf 8f6f 	isb	sy
    __ISB();                                        // instruction-order barrier
    *(__IO uint32_t *)(address+4) = (uint32_t)(val >> 32);
2000004a:	6043      	str	r3, [r0, #4]
    __attribute__((section(".ramfunc")))
    __attribute__((always_inline))
    static inline uint32_t
_flash_wait_done(void)
{
    while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) {
2000004c:	690a      	ldr	r2, [r1, #16]
2000004e:	4b0f      	ldr	r3, [pc, #60]	; (2000008c <BL_SRAM_BASE+0x8c>)
20000050:	03d0      	lsls	r0, r2, #15
20000052:	d4fb      	bmi.n	2000004c <flash_burn+0x4c>
        // busy wait
    }

    uint32_t error = (FLASH->SR & FLASH_FLAG_SR_ERRORS);
20000054:	691a      	ldr	r2, [r3, #16]
20000056:	480e      	ldr	r0, [pc, #56]	; (20000090 <BL_SRAM_BASE+0x90>)
20000058:	4010      	ands	r0, r2
    if(error) {
2000005a:	b9b0      	cbnz	r0, 2000008a <flash_burn+0x8a>
        // Save an error code; somewhat random, depends on chip details
        return error;
    }

    // Check FLASH End of Operation flag
    if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP)) {
2000005c:	691a      	ldr	r2, [r3, #16]
2000005e:	07d2      	lsls	r2, r2, #31
        // Clear FLASH End of Operation pending bit
        __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
20000060:	bf44      	itt	mi
20000062:	2201      	movmi	r2, #1
20000064:	611a      	strmi	r2, [r3, #16]

    rv = _flash_wait_done();
    if(rv) return rv;

    // If the program operation is completed, disable the PG or FSTPG Bit
    CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
20000066:	4b09      	ldr	r3, [pc, #36]	; (2000008c <BL_SRAM_BASE+0x8c>)
20000068:	695a      	ldr	r2, [r3, #20]
2000006a:	f022 0201 	bic.w	r2, r2, #1
2000006e:	615a      	str	r2, [r3, #20]

    // Flush the caches to be sure of data consistency, and reenable.
    __HAL_FLASH_DATA_CACHE_RESET();
20000070:	681a      	ldr	r2, [r3, #0]
20000072:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
20000076:	601a      	str	r2, [r3, #0]
20000078:	681a      	ldr	r2, [r3, #0]
2000007a:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
2000007e:	601a      	str	r2, [r3, #0]
    __HAL_FLASH_DATA_CACHE_ENABLE();
20000080:	681a      	ldr	r2, [r3, #0]
20000082:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
20000086:	601a      	str	r2, [r3, #0]

    return 0;
20000088:	2000      	movs	r0, #0
}
2000008a:	bd30      	pop	{r4, r5, pc}
2000008c:	40022000 	.word	0x40022000
20000090:	0002c3fa 	.word	0x0002c3fa

20000094 <flash_page_erase>:
//
    __attribute__((section(".ramfunc")))
    __attribute__((noinline))
    int
flash_page_erase(uint32_t address)
{
20000094:	0b00      	lsrs	r0, r0, #12
    uint32_t    page_num = (address & 0x7ffffff) / FLASH_PAGE_SIZE;
20000096:	f3c0 010e 	ubfx	r1, r0, #0, #15

    // protect ourselves!
    if(page_num < ((BL_FLASH_SIZE + BL_NVROM_SIZE) / FLASH_PAGE_SIZE)) {
2000009a:	291f      	cmp	r1, #31
//
    __attribute__((section(".ramfunc")))
    __attribute__((noinline))
    int
flash_page_erase(uint32_t address)
{
2000009c:	b510      	push	{r4, lr}
    uint32_t    page_num = (address & 0x7ffffff) / FLASH_PAGE_SIZE;

    // protect ourselves!
    if(page_num < ((BL_FLASH_SIZE + BL_NVROM_SIZE) / FLASH_PAGE_SIZE)) {
2000009e:	d95a      	bls.n	20000156 <flash_page_erase+0xc2>
    __attribute__((section(".ramfunc")))
    __attribute__((always_inline))
    static inline uint32_t
_flash_wait_done(void)
{
    while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) {
200000a0:	4c2e      	ldr	r4, [pc, #184]	; (2000015c <flash_page_erase+0xc8>)
        return 1;
    }

    // always operate on both banks.
    bool bank2 = (page_num >= 256);
    page_num &= 0xff;
200000a2:	b2c0      	uxtb	r0, r0
    __attribute__((section(".ramfunc")))
    __attribute__((always_inline))
    static inline uint32_t
_flash_wait_done(void)
{
    while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) {
200000a4:	6922      	ldr	r2, [r4, #16]
200000a6:	4b2d      	ldr	r3, [pc, #180]	; (2000015c <flash_page_erase+0xc8>)
200000a8:	03d2      	lsls	r2, r2, #15
200000aa:	d4fb      	bmi.n	200000a4 <flash_page_erase+0x10>
        // busy wait
    }

    uint32_t error = (FLASH->SR & FLASH_FLAG_SR_ERRORS);
200000ac:	691c      	ldr	r4, [r3, #16]
    if(error) {
200000ae:	4a2c      	ldr	r2, [pc, #176]	; (20000160 <flash_page_erase+0xcc>)
200000b0:	4022      	ands	r2, r4
200000b2:	b922      	cbnz	r2, 200000be <flash_page_erase+0x2a>
        // Save an error code; somewhat random, depends on chip details
        return error;
    }

    // Check FLASH End of Operation flag
    if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP)) {
200000b4:	691a      	ldr	r2, [r3, #16]
200000b6:	07d4      	lsls	r4, r2, #31
        // Clear FLASH End of Operation pending bit
        __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
200000b8:	bf44      	itt	mi
200000ba:	2201      	movmi	r2, #1
200000bc:	611a      	strmi	r2, [r3, #16]

    // just in case?
    _flash_wait_done();

    // clear any and all errors
    FLASH->SR = FLASH->SR & 0xffff;
200000be:	4b27      	ldr	r3, [pc, #156]	; (2000015c <flash_page_erase+0xc8>)
200000c0:	691a      	ldr	r2, [r3, #16]
200000c2:	b292      	uxth	r2, r2
200000c4:	611a      	str	r2, [r3, #16]

    // disable data cache
    __HAL_FLASH_DATA_CACHE_DISABLE();
200000c6:	681a      	ldr	r2, [r3, #0]
200000c8:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
200000cc:	601a      	str	r2, [r3, #0]

    // choose appropriate bank to work on.
    if(bank2) {
        SET_BIT(FLASH->CR, FLASH_CR_BKER);
200000ce:	695a      	ldr	r2, [r3, #20]

    // disable data cache
    __HAL_FLASH_DATA_CACHE_DISABLE();

    // choose appropriate bank to work on.
    if(bank2) {
200000d0:	29ff      	cmp	r1, #255	; 0xff
        SET_BIT(FLASH->CR, FLASH_CR_BKER);
200000d2:	bf8c      	ite	hi
200000d4:	f442 6200 	orrhi.w	r2, r2, #2048	; 0x800
    } else {
        CLEAR_BIT(FLASH->CR, FLASH_CR_BKER);
200000d8:	f422 6200 	bicls.w	r2, r2, #2048	; 0x800
200000dc:	615a      	str	r2, [r3, #20]
    }

    // Proceed to erase the page
    MODIFY_REG(FLASH->CR, FLASH_CR_PNB, (page_num << POSITION_VAL(FLASH_CR_PNB)));
200000de:	695a      	ldr	r2, [r3, #20]
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
200000e0:	f44f 63ff 	mov.w	r3, #2040	; 0x7f8
200000e4:	f422 62ff 	bic.w	r2, r2, #2040	; 0x7f8
200000e8:	fa93 f3a3 	rbit	r3, r3
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
200000ec:	b113      	cbz	r3, 200000f4 <flash_page_erase+0x60>
  {
    return 32U;
  }
  return __builtin_clz(value);
200000ee:	fab3 f383 	clz	r3, r3
200000f2:	e000      	b.n	200000f6 <flash_page_erase+0x62>
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
  {
    return 32U;
200000f4:	2320      	movs	r3, #32
200000f6:	fa00 f303 	lsl.w	r3, r0, r3
200000fa:	ea43 0002 	orr.w	r0, r3, r2
200000fe:	4b17      	ldr	r3, [pc, #92]	; (2000015c <flash_page_erase+0xc8>)
20000100:	6158      	str	r0, [r3, #20]
    SET_BIT(FLASH->CR, FLASH_CR_PER);
20000102:	695a      	ldr	r2, [r3, #20]
20000104:	f042 0202 	orr.w	r2, r2, #2
20000108:	615a      	str	r2, [r3, #20]
    SET_BIT(FLASH->CR, FLASH_CR_STRT);
2000010a:	695a      	ldr	r2, [r3, #20]
2000010c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
20000110:	615a      	str	r2, [r3, #20]
    __attribute__((section(".ramfunc")))
    __attribute__((always_inline))
    static inline uint32_t
_flash_wait_done(void)
{
    while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) {
20000112:	6919      	ldr	r1, [r3, #16]
20000114:	4a11      	ldr	r2, [pc, #68]	; (2000015c <flash_page_erase+0xc8>)
20000116:	03c9      	lsls	r1, r1, #15
20000118:	d4fb      	bmi.n	20000112 <flash_page_erase+0x7e>
        // busy wait
    }

    uint32_t error = (FLASH->SR & FLASH_FLAG_SR_ERRORS);
2000011a:	6911      	ldr	r1, [r2, #16]
    if(error) {
2000011c:	4b10      	ldr	r3, [pc, #64]	; (20000160 <flash_page_erase+0xcc>)
2000011e:	400b      	ands	r3, r1
20000120:	b923      	cbnz	r3, 2000012c <flash_page_erase+0x98>
        // Save an error code; somewhat random, depends on chip details
        return error;
    }

    // Check FLASH End of Operation flag
    if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP)) {
20000122:	6913      	ldr	r3, [r2, #16]
20000124:	07db      	lsls	r3, r3, #31
        // Clear FLASH End of Operation pending bit
        __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
20000126:	bf44      	itt	mi
20000128:	2301      	movmi	r3, #1
2000012a:	6113      	strmi	r3, [r2, #16]

    // Wait til done
    _flash_wait_done();

    // If the erase operation is completed, disable the PER Bit
    CLEAR_BIT(FLASH->CR, (FLASH_CR_PER | FLASH_CR_PNB));
2000012c:	4b0b      	ldr	r3, [pc, #44]	; (2000015c <flash_page_erase+0xc8>)
2000012e:	695a      	ldr	r2, [r3, #20]
20000130:	f422 62ff 	bic.w	r2, r2, #2040	; 0x7f8
20000134:	f022 0202 	bic.w	r2, r2, #2
20000138:	615a      	str	r2, [r3, #20]

    // Flush the caches to be sure of data consistency, and reenable.
    __HAL_FLASH_DATA_CACHE_RESET();
2000013a:	681a      	ldr	r2, [r3, #0]
2000013c:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
20000140:	601a      	str	r2, [r3, #0]
20000142:	681a      	ldr	r2, [r3, #0]
20000144:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
20000148:	601a      	str	r2, [r3, #0]
    __HAL_FLASH_DATA_CACHE_ENABLE();
2000014a:	681a      	ldr	r2, [r3, #0]
2000014c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
20000150:	601a      	str	r2, [r3, #0]

    return 0;
20000152:	2000      	movs	r0, #0
20000154:	bd10      	pop	{r4, pc}
{
    uint32_t    page_num = (address & 0x7ffffff) / FLASH_PAGE_SIZE;

    // protect ourselves!
    if(page_num < ((BL_FLASH_SIZE + BL_NVROM_SIZE) / FLASH_PAGE_SIZE)) {
        return 1;
20000156:	2001      	movs	r0, #1
    // Flush the caches to be sure of data consistency, and reenable.
    __HAL_FLASH_DATA_CACHE_RESET();
    __HAL_FLASH_DATA_CACHE_ENABLE();

    return 0;
}
20000158:	bd10      	pop	{r4, pc}
2000015a:	bf00      	nop
2000015c:	40022000 	.word	0x40022000
20000160:	0002c3fa 	.word	0x0002c3fa
