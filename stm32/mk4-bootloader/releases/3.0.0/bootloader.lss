
bootloader.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000e784  08000000  08000000  00010000  2**8
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000164  20000000  0800e784  00020000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002e8  20000164  0800e8e8  00020164  2**2
                  ALLOC
  3 .stack        00000804  2000044c  0800ebd0  00020164  2**0
                  ALLOC
  4 .debug_info   000278ed  00000000  00000000  00020164  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 000053de  00000000  00000000  00047a51  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00010327  00000000  00000000  0004ce2f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00001070  00000000  00000000  0005d156  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_ranges 000017d8  00000000  00000000  0005e1c6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_macro  00031f2c  00000000  00000000  0005f99e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   0001380c  00000000  00000000  000918ca  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0011bdd5  00000000  00000000  000a50d6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000006e  00000000  00000000  001c0eab  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000037  00000000  00000000  001c0f19  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00003454  00000000  00000000  001c0f50  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000000 <_sfixed>:
 8000000:	20001c00 	.word	0x20001c00
 8000004:	080000b5 	.word	0x080000b5
 8000008:	0800001d 	.word	0x0800001d
 800000c:	0800001f 	.word	0x0800001f
 8000010:	08000021 	.word	0x08000021
 8000014:	08000023 	.word	0x08000023
 8000018:	08000025 	.word	0x08000025

0800001c <NMI_Handler>:
 800001c:	be01      	bkpt	0x0001

0800001e <HardFault_Handler>:
 800001e:	be02      	bkpt	0x0002

08000020 <MemManage_Handler>:
 8000020:	be03      	bkpt	0x0003

08000022 <BusFault_Handler>:
 8000022:	be04      	bkpt	0x0004

08000024 <UsageFault_Handler>:
 8000024:	be05      	bkpt	0x0005
 8000026:	e7fe      	b.n	8000026 <UsageFault_Handler+0x2>

08000028 <bootloader_info>:
	...
 8000040:	08000305 	.word	0x08000305

08000044 <my_version_code>:
 8000044:	00000100 	.word	0x00000100
	...
 8000060:	20296328 	.word	0x20296328
 8000064:	79706f43 	.word	0x79706f43
 8000068:	68676972 	.word	0x68676972
 800006c:	30322074 	.word	0x30322074
 8000070:	322d3831 	.word	0x322d3831
 8000074:	20323230 	.word	0x20323230
 8000078:	43207962 	.word	0x43207962
 800007c:	6b6e696f 	.word	0x6b6e696f
 8000080:	20657469 	.word	0x20657469
 8000084:	2e636e49 	.word	0x2e636e49
 8000088:	0a200a20 	.word	0x0a200a20
 800008c:	73696854 	.word	0x73696854
 8000090:	61707320 	.word	0x61707320
 8000094:	66206563 	.word	0x66206563
 8000098:	7220726f 	.word	0x7220726f
 800009c:	21746e65 	.word	0x21746e65
 80000a0:	73754a20 	.word	0x73754a20
 80000a4:	42312074 	.word	0x42312074
 80000a8:	792f4354 	.word	0x792f4354
 80000ac:	2e726165 	.word	0x2e726165
 80000b0:	0a200a20 	.word	0x0a200a20

080000b4 <reset_entry>:
 80000b4:	f000 f816 	bl	80000e4 <firewall_setup>
 80000b8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80000bc:	f04f 0100 	mov.w	r1, #0
 80000c0:	f04f 0200 	mov.w	r2, #0
 80000c4:	f04f 0300 	mov.w	r3, #0
 80000c8:	f000 f91c 	bl	8000304 <callgate_entry0>
 80000cc:	f248 0120 	movw	r1, #32800	; 0x8020
 80000d0:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80000d4:	6808      	ldr	r0, [r1, #0]
 80000d6:	4685      	mov	sp, r0
 80000d8:	f04f 0001 	mov.w	r0, #1
 80000dc:	f8d1 e004 	ldr.w	lr, [r1, #4]
 80000e0:	4770      	bx	lr
	...

080000e4 <firewall_setup>:
    void
firewall_setup(void)
{
    // This is critical: without the clock enabled to "SYSCFG" we
    // can't tell the FW is enabled or not! Enabling it would also not work
    __HAL_RCC_SYSCFG_CLK_ENABLE();
 80000e4:	4b23      	ldr	r3, [pc, #140]	; (8000174 <firewall_setup+0x90>)
// It's best if this is outside the firewall. After we return, we'll
// jump into setup code contained inside the firewall. Called from startup.S
//
    void
firewall_setup(void)
{
 80000e6:	b500      	push	{lr}
    // This is critical: without the clock enabled to "SYSCFG" we
    // can't tell the FW is enabled or not! Enabling it would also not work
    __HAL_RCC_SYSCFG_CLK_ENABLE();
 80000e8:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80000ea:	f042 0201 	orr.w	r2, r2, #1
 80000ee:	661a      	str	r2, [r3, #96]	; 0x60
 80000f0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
// It's best if this is outside the firewall. After we return, we'll
// jump into setup code contained inside the firewall. Called from startup.S
//
    void
firewall_setup(void)
{
 80000f2:	b08b      	sub	sp, #44	; 0x2c
    // This is critical: without the clock enabled to "SYSCFG" we
    // can't tell the FW is enabled or not! Enabling it would also not work
    __HAL_RCC_SYSCFG_CLK_ENABLE();
 80000f4:	f003 0301 	and.w	r3, r3, #1
 80000f8:	9300      	str	r3, [sp, #0]
 80000fa:	9b00      	ldr	r3, [sp, #0]

    if(__HAL_FIREWALL_IS_ENABLED()) {
 80000fc:	4b1e      	ldr	r3, [pc, #120]	; (8000178 <firewall_setup+0x94>)
 80000fe:	685b      	ldr	r3, [r3, #4]
 8000100:	07db      	lsls	r3, r3, #31
 8000102:	d533      	bpl.n	800016c <firewall_setup+0x88>
    // REMINDERS: 
    // - cannot debug anything in boot loader w/ firewall enabled (no readback, no bkpt)
    // - when RDP=2, this protection still important or else python can read pairing secret
    // - in factory mode (RDP!=2), it's nice to have this disabled so we can debug still
    // - could look at RDP level here, but it would be harder to completely reset the bag number!
    if(check_all_ones(rom_secrets->bag_number, sizeof(rom_secrets->bag_number))) {
 8000104:	2120      	movs	r1, #32
 8000106:	481d      	ldr	r0, [pc, #116]	; (800017c <firewall_setup+0x98>)
 8000108:	f002 fa8e 	bl	8002628 <check_all_ones>
 800010c:	2800      	cmp	r0, #0
 800010e:	d12d      	bne.n	800016c <firewall_setup+0x88>
    // for debug builds, never enable firewall
    return;
#endif

    extern int firewall_starts;       // see startup.S ... aligned@256 (0x08000300)
    uint32_t    start = (uint32_t)&firewall_starts;
 8000110:	491b      	ldr	r1, [pc, #108]	; (8000180 <firewall_setup+0x9c>)
    uint32_t    len = BL_FLASH_SIZE - (start - BL_FLASH_BASE);
 8000112:	f1c1 6300 	rsb	r3, r1, #134217728	; 0x8000000

#if 1
    ASSERT(start);
    ASSERT(!(start & 0xff));
 8000116:	f011 0fff 	tst.w	r1, #255	; 0xff
    return;
#endif

    extern int firewall_starts;       // see startup.S ... aligned@256 (0x08000300)
    uint32_t    start = (uint32_t)&firewall_starts;
    uint32_t    len = BL_FLASH_SIZE - (start - BL_FLASH_BASE);
 800011a:	f503 33f0 	add.w	r3, r3, #122880	; 0x1e000

#if 1
    ASSERT(start);
    ASSERT(!(start & 0xff));
 800011e:	d001      	beq.n	8000124 <firewall_setup+0x40>
 8000120:	4818      	ldr	r0, [pc, #96]	; (8000184 <firewall_setup+0xa0>)
 8000122:	e015      	b.n	8000150 <firewall_setup+0x6c>
    ASSERT(len>256);
 8000124:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8000128:	d9fa      	bls.n	8000120 <firewall_setup+0x3c>
    ASSERT(!(len & 0xff));
 800012a:	f013 02ff 	ands.w	r2, r3, #255	; 0xff
 800012e:	d1f7      	bne.n	8000120 <firewall_setup+0x3c>
    //   but sensitive stuff is still there (which would allow bypass)
    // - so it's important to enable option bytes to set write-protect on entire bootloader
    // - to disable debug and complete protection, must enable write-protect "level 2"
    //

    FIREWALL_InitTypeDef init = {
 8000130:	9303      	str	r3, [sp, #12]
 8000132:	4b15      	ldr	r3, [pc, #84]	; (8000188 <firewall_setup+0xa4>)
 8000134:	9304      	str	r3, [sp, #16]
        .VDataSegmentLength = 0,
        .VolatileDataExecution = 0,
        .VolatileDataShared = 0,
    };

    int rv = HAL_FIREWALL_Config((FIREWALL_InitTypeDef *)&init);
 8000136:	a802      	add	r0, sp, #8
    //   but sensitive stuff is still there (which would allow bypass)
    // - so it's important to enable option bytes to set write-protect on entire bootloader
    // - to disable debug and complete protection, must enable write-protect "level 2"
    //

    FIREWALL_InitTypeDef init = {
 8000138:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800013c:	9102      	str	r1, [sp, #8]
 800013e:	9305      	str	r3, [sp, #20]
 8000140:	9206      	str	r2, [sp, #24]
 8000142:	9207      	str	r2, [sp, #28]
 8000144:	9208      	str	r2, [sp, #32]
 8000146:	9209      	str	r2, [sp, #36]	; 0x24
        .VDataSegmentLength = 0,
        .VolatileDataExecution = 0,
        .VolatileDataShared = 0,
    };

    int rv = HAL_FIREWALL_Config((FIREWALL_InitTypeDef *)&init);
 8000148:	f000 f824 	bl	8000194 <HAL_FIREWALL_Config>
    if(rv) {
 800014c:	b110      	cbz	r0, 8000154 <firewall_setup+0x70>
        INCONSISTENT("fw");
 800014e:	480f      	ldr	r0, [pc, #60]	; (800018c <firewall_setup+0xa8>)
 8000150:	f000 fc44 	bl	80009dc <fatal_error>
    }

    __HAL_FIREWALL_PREARM_DISABLE();
 8000154:	4b0e      	ldr	r3, [pc, #56]	; (8000190 <firewall_setup+0xac>)
 8000156:	6a1a      	ldr	r2, [r3, #32]
 8000158:	f022 0201 	bic.w	r2, r2, #1
 800015c:	621a      	str	r2, [r3, #32]
 800015e:	6a1b      	ldr	r3, [r3, #32]
 8000160:	f003 0301 	and.w	r3, r3, #1
 8000164:	9301      	str	r3, [sp, #4]
 8000166:	9b01      	ldr	r3, [sp, #4]
    HAL_FIREWALL_EnableFirewall();
 8000168:	f000 f894 	bl	8000294 <HAL_FIREWALL_EnableFirewall>
}
 800016c:	b00b      	add	sp, #44	; 0x2c
 800016e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000172:	bf00      	nop
 8000174:	40021000 	.word	0x40021000
 8000178:	40010000 	.word	0x40010000
 800017c:	0801e050 	.word	0x0801e050
 8000180:	08000300 	.word	0x08000300
 8000184:	0800d550 	.word	0x0800d550
 8000188:	0801e000 	.word	0x0801e000
 800018c:	0800d557 	.word	0x0800d557
 8000190:	40011c00 	.word	0x40011c00

08000194 <HAL_FIREWALL_Config>:
  * @param fw_init: Firewall initialization structure
  * @note  The API returns HAL_ERROR if the Firewall is already enabled.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_FIREWALL_Config(FIREWALL_InitTypeDef * fw_init)
{
 8000194:	b513      	push	{r0, r1, r4, lr}
  /* Check the Firewall initialization structure allocation */
  if(fw_init == NULL)
 8000196:	b908      	cbnz	r0, 800019c <HAL_FIREWALL_Config+0x8>
  {
    return HAL_ERROR;
 8000198:	2001      	movs	r0, #1
 800019a:	e037      	b.n	800020c <HAL_FIREWALL_Config+0x78>
  }

  /* Enable Firewall clock */
  __HAL_RCC_FIREWALL_CLK_ENABLE();
 800019c:	4b1c      	ldr	r3, [pc, #112]	; (8000210 <HAL_FIREWALL_Config+0x7c>)
 800019e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80001a0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80001a4:	661a      	str	r2, [r3, #96]	; 0x60
 80001a6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80001a8:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80001ac:	9301      	str	r3, [sp, #4]
 80001ae:	9b01      	ldr	r3, [sp, #4]

  /* Make sure that Firewall is not enabled already */
  if (__HAL_FIREWALL_IS_ENABLED() != RESET)
 80001b0:	4b18      	ldr	r3, [pc, #96]	; (8000214 <HAL_FIREWALL_Config+0x80>)
 80001b2:	685b      	ldr	r3, [r3, #4]
 80001b4:	07db      	lsls	r3, r3, #31
 80001b6:	d5ef      	bpl.n	8000198 <HAL_FIREWALL_Config+0x4>
    return HAL_ERROR;
  }

  /* Check Firewall configuration addresses and lengths when segment is protected */
  /* Code segment */
  if (fw_init->CodeSegmentLength != 0U)
 80001b8:	6841      	ldr	r1, [r0, #4]
 80001ba:	b111      	cbz	r1, 80001c2 <HAL_FIREWALL_Config+0x2e>
  {
    assert_param(IS_FIREWALL_CODE_SEGMENT_ADDRESS(fw_init->CodeSegmentStartAddress));
    assert_param(IS_FIREWALL_CODE_SEGMENT_LENGTH(fw_init->CodeSegmentStartAddress, fw_init->CodeSegmentLength));
    /* Make sure that NonVDataSegmentLength is properly set to prevent code segment access */
    if (fw_init->NonVDataSegmentLength < 0x100U)
 80001bc:	68c3      	ldr	r3, [r0, #12]
 80001be:	2bff      	cmp	r3, #255	; 0xff
 80001c0:	d9ea      	bls.n	8000198 <HAL_FIREWALL_Config+0x4>


   /* Configuration */

  /* Protected code segment start address configuration */
  WRITE_REG(FIREWALL->CSSA, (FW_CSSA_ADD & fw_init->CodeSegmentStartAddress));
 80001c2:	6802      	ldr	r2, [r0, #0]
 80001c4:	4b14      	ldr	r3, [pc, #80]	; (8000218 <HAL_FIREWALL_Config+0x84>)
 80001c6:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 80001ca:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 80001ce:	601a      	str	r2, [r3, #0]
	/* Protected code segment length configuration */
  WRITE_REG(FIREWALL->CSL, (FW_CSL_LENG & fw_init->CodeSegmentLength));
 80001d0:	4a12      	ldr	r2, [pc, #72]	; (800021c <HAL_FIREWALL_Config+0x88>)
 80001d2:	400a      	ands	r2, r1
 80001d4:	605a      	str	r2, [r3, #4]

  /* Protected non volatile data segment start address configuration */
  WRITE_REG(FIREWALL->NVDSSA, (FW_NVDSSA_ADD & fw_init->NonVDataSegmentStartAddress));
 80001d6:	6882      	ldr	r2, [r0, #8]
 80001d8:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 80001dc:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 80001e0:	609a      	str	r2, [r3, #8]
	/* Protected non volatile data segment length configuration */
  WRITE_REG(FIREWALL->NVDSL, (FW_NVDSL_LENG & fw_init->NonVDataSegmentLength));
 80001e2:	68c1      	ldr	r1, [r0, #12]
 80001e4:	4a0d      	ldr	r2, [pc, #52]	; (800021c <HAL_FIREWALL_Config+0x88>)
 80001e6:	400a      	ands	r2, r1
 80001e8:	60da      	str	r2, [r3, #12]

  /* Protected volatile data segment start address configuration */
  WRITE_REG(FIREWALL->VDSSA, (FW_VDSSA_ADD & fw_init->VDataSegmentStartAddress));
 80001ea:	6901      	ldr	r1, [r0, #16]
 80001ec:	4a0c      	ldr	r2, [pc, #48]	; (8000220 <HAL_FIREWALL_Config+0x8c>)
 80001ee:	400a      	ands	r2, r1
 80001f0:	611a      	str	r2, [r3, #16]
	/* Protected volatile data segment length configuration */
  WRITE_REG(FIREWALL->VDSL, (FW_VDSL_LENG & fw_init->VDataSegmentLength));
 80001f2:	6941      	ldr	r1, [r0, #20]
 80001f4:	4a0a      	ldr	r2, [pc, #40]	; (8000220 <HAL_FIREWALL_Config+0x8c>)
 80001f6:	400a      	ands	r2, r1
 80001f8:	615a      	str	r2, [r3, #20]

  /* Set Firewall Configuration Register VDE and VDS bits
     (volatile data execution and shared configuration) */
  MODIFY_REG(FIREWALL->CR, FW_CR_VDS|FW_CR_VDE, fw_init->VolatileDataExecution|fw_init->VolatileDataShared);
 80001fa:	6984      	ldr	r4, [r0, #24]
 80001fc:	69c1      	ldr	r1, [r0, #28]
 80001fe:	6a1a      	ldr	r2, [r3, #32]
 8000200:	4321      	orrs	r1, r4
 8000202:	f022 0206 	bic.w	r2, r2, #6
 8000206:	430a      	orrs	r2, r1
 8000208:	621a      	str	r2, [r3, #32]

  return HAL_OK;
 800020a:	2000      	movs	r0, #0
}
 800020c:	b002      	add	sp, #8
 800020e:	bd10      	pop	{r4, pc}
 8000210:	40021000 	.word	0x40021000
 8000214:	40010000 	.word	0x40010000
 8000218:	40011c00 	.word	0x40011c00
 800021c:	003fff00 	.word	0x003fff00
 8000220:	0003ffc0 	.word	0x0003ffc0

08000224 <HAL_FIREWALL_GetConfig>:
void HAL_FIREWALL_GetConfig(FIREWALL_InitTypeDef * fw_config)
{

  /* Enable Firewall clock, in case no Firewall configuration has been carried
     out up to this point */
  __HAL_RCC_FIREWALL_CLK_ENABLE();
 8000224:	4b17      	ldr	r3, [pc, #92]	; (8000284 <HAL_FIREWALL_GetConfig+0x60>)

  /* Retrieve code segment protection setting */
  fw_config->CodeSegmentStartAddress = (READ_REG(FIREWALL->CSSA) & FW_CSSA_ADD);
  fw_config->CodeSegmentLength = (READ_REG(FIREWALL->CSL) & FW_CSL_LENG);
 8000226:	4918      	ldr	r1, [pc, #96]	; (8000288 <HAL_FIREWALL_GetConfig+0x64>)
void HAL_FIREWALL_GetConfig(FIREWALL_InitTypeDef * fw_config)
{

  /* Enable Firewall clock, in case no Firewall configuration has been carried
     out up to this point */
  __HAL_RCC_FIREWALL_CLK_ENABLE();
 8000228:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800022a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800022e:	661a      	str	r2, [r3, #96]	; 0x60
 8000230:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  *       is defined, this API can't be executed when the Firewall is enabled.
  * @note User should resort to __HAL_FIREWALL_GET_PREARM() macro to retrieve FPA bit status
  * @retval None
  */
void HAL_FIREWALL_GetConfig(FIREWALL_InitTypeDef * fw_config)
{
 8000232:	b082      	sub	sp, #8

  /* Enable Firewall clock, in case no Firewall configuration has been carried
     out up to this point */
  __HAL_RCC_FIREWALL_CLK_ENABLE();
 8000234:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000238:	9301      	str	r3, [sp, #4]
 800023a:	9b01      	ldr	r3, [sp, #4]

  /* Retrieve code segment protection setting */
  fw_config->CodeSegmentStartAddress = (READ_REG(FIREWALL->CSSA) & FW_CSSA_ADD);
 800023c:	4b13      	ldr	r3, [pc, #76]	; (800028c <HAL_FIREWALL_GetConfig+0x68>)
 800023e:	681a      	ldr	r2, [r3, #0]
 8000240:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8000244:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 8000248:	6002      	str	r2, [r0, #0]
  fw_config->CodeSegmentLength = (READ_REG(FIREWALL->CSL) & FW_CSL_LENG);
 800024a:	685a      	ldr	r2, [r3, #4]
 800024c:	400a      	ands	r2, r1
 800024e:	6042      	str	r2, [r0, #4]

  /* Retrieve non volatile data segment protection setting */
  fw_config->NonVDataSegmentStartAddress = (READ_REG(FIREWALL->NVDSSA) & FW_NVDSSA_ADD);
 8000250:	689a      	ldr	r2, [r3, #8]
 8000252:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8000256:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 800025a:	6082      	str	r2, [r0, #8]
  fw_config->NonVDataSegmentLength = (READ_REG(FIREWALL->NVDSL) & FW_NVDSL_LENG);
 800025c:	68da      	ldr	r2, [r3, #12]
 800025e:	4011      	ands	r1, r2
 8000260:	60c1      	str	r1, [r0, #12]

  /* Retrieve volatile data segment protection setting */
  fw_config->VDataSegmentStartAddress = (READ_REG(FIREWALL->VDSSA) & FW_VDSSA_ADD);
 8000262:	6919      	ldr	r1, [r3, #16]
 8000264:	4a0a      	ldr	r2, [pc, #40]	; (8000290 <HAL_FIREWALL_GetConfig+0x6c>)
 8000266:	4011      	ands	r1, r2
 8000268:	6101      	str	r1, [r0, #16]
  fw_config->VDataSegmentLength = (READ_REG(FIREWALL->VDSL) & FW_VDSL_LENG);
 800026a:	6959      	ldr	r1, [r3, #20]
 800026c:	400a      	ands	r2, r1
 800026e:	6142      	str	r2, [r0, #20]

  /* Retrieve volatile data execution setting */
  fw_config->VolatileDataExecution = (READ_REG(FIREWALL->CR) & FW_CR_VDE);
 8000270:	6a1a      	ldr	r2, [r3, #32]
 8000272:	f002 0204 	and.w	r2, r2, #4
 8000276:	6182      	str	r2, [r0, #24]

  /* Retrieve volatile data shared setting */
  fw_config->VolatileDataShared = (READ_REG(FIREWALL->CR) & FW_CR_VDS);
 8000278:	6a1b      	ldr	r3, [r3, #32]
 800027a:	f003 0302 	and.w	r3, r3, #2
 800027e:	61c3      	str	r3, [r0, #28]

  return;
}
 8000280:	b002      	add	sp, #8
 8000282:	4770      	bx	lr
 8000284:	40021000 	.word	0x40021000
 8000288:	003fff00 	.word	0x003fff00
 800028c:	40011c00 	.word	0x40011c00
 8000290:	0003ffc0 	.word	0x0003ffc0

08000294 <HAL_FIREWALL_EnableFirewall>:
  * @retval None
  */
void HAL_FIREWALL_EnableFirewall(void)
{
  /* Clears FWDIS bit of SYSCFG CFGR1 register */
  CLEAR_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_FWDIS);
 8000294:	4a02      	ldr	r2, [pc, #8]	; (80002a0 <HAL_FIREWALL_EnableFirewall+0xc>)
 8000296:	6853      	ldr	r3, [r2, #4]
 8000298:	f023 0301 	bic.w	r3, r3, #1
 800029c:	6053      	str	r3, [r2, #4]
 800029e:	4770      	bx	lr
 80002a0:	40010000 	.word	0x40010000

080002a4 <HAL_FIREWALL_EnablePreArmFlag>:
  * @retval None
  */
void HAL_FIREWALL_EnablePreArmFlag(void)
{
  /* Set FPA bit */
  SET_BIT(FIREWALL->CR, FW_CR_FPA);
 80002a4:	4a02      	ldr	r2, [pc, #8]	; (80002b0 <HAL_FIREWALL_EnablePreArmFlag+0xc>)
 80002a6:	6a13      	ldr	r3, [r2, #32]
 80002a8:	f043 0301 	orr.w	r3, r3, #1
 80002ac:	6213      	str	r3, [r2, #32]
 80002ae:	4770      	bx	lr
 80002b0:	40011c00 	.word	0x40011c00

080002b4 <HAL_FIREWALL_DisablePreArmFlag>:
  * @retval None
  */
void HAL_FIREWALL_DisablePreArmFlag(void)
{
  /* Clear FPA bit */
  CLEAR_BIT(FIREWALL->CR, FW_CR_FPA);
 80002b4:	4a02      	ldr	r2, [pc, #8]	; (80002c0 <HAL_FIREWALL_DisablePreArmFlag+0xc>)
 80002b6:	6a13      	ldr	r3, [r2, #32]
 80002b8:	f023 0301 	bic.w	r3, r3, #1
 80002bc:	6213      	str	r3, [r2, #32]
 80002be:	4770      	bx	lr
 80002c0:	40011c00 	.word	0x40011c00
	...

08000300 <_firewall_start>:
 8000300:	0f193a11 	.word	0x0f193a11

08000304 <callgate_entry0>:
 8000304:	f240 0900 	movw	r9, #0
 8000308:	f2c2 0900 	movt	r9, #8192	; 0x2000
 800030c:	f44f 5ae0 	mov.w	sl, #7168	; 0x1c00
 8000310:	44ca      	add	sl, r9

08000312 <wipe_loop1>:
 8000312:	f849 ab04 	str.w	sl, [r9], #4
 8000316:	45d1      	cmp	r9, sl
 8000318:	d1fb      	bne.n	8000312 <wipe_loop1>
 800031a:	46ea      	mov	sl, sp
 800031c:	46cd      	mov	sp, r9
 800031e:	e92d 4400 	stmdb	sp!, {sl, lr}

08000322 <dispatcher>:
 8000322:	f000 f843 	bl	80003ac <firewall_dispatch>
 8000326:	e8bd 4400 	ldmia.w	sp!, {sl, lr}
 800032a:	46d5      	mov	sp, sl
 800032c:	f240 0900 	movw	r9, #0
 8000330:	f2c2 0900 	movt	r9, #8192	; 0x2000
 8000334:	f44f 5ae0 	mov.w	sl, #7168	; 0x1c00
 8000338:	44ca      	add	sl, r9

0800033a <wipe_loop2>:
 800033a:	f849 0b04 	str.w	r0, [r9], #4
 800033e:	45d1      	cmp	r9, sl
 8000340:	d1fb      	bne.n	800033a <wipe_loop2>
 8000342:	4770      	bx	lr

08000344 <__NVIC_SystemReset>:
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8000344:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8000348:	4905      	ldr	r1, [pc, #20]	; (8000360 <__NVIC_SystemReset+0x1c>)
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800034a:	4b06      	ldr	r3, [pc, #24]	; (8000364 <__NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800034c:	68ca      	ldr	r2, [r1, #12]
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800034e:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8000352:	4313      	orrs	r3, r2
 8000354:	60cb      	str	r3, [r1, #12]
 8000356:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 800035a:	bf00      	nop
 800035c:	e7fd      	b.n	800035a <__NVIC_SystemReset+0x16>
 800035e:	bf00      	nop
 8000360:	e000ed00 	.word	0xe000ed00
 8000364:	05fa0004 	.word	0x05fa0004

08000368 <good_addr>:
    static int
good_addr(const uint8_t *b, int minlen, int len, bool readonly)
{
    uint32_t x = (uint32_t)b;

    if(minlen) {
 8000368:	b111      	cbz	r1, 8000370 <good_addr+0x8>
        if(!b) return EFAULT;               // gave no buffer
 800036a:	b198      	cbz	r0, 8000394 <good_addr+0x2c>
        if(len < minlen) return ERANGE;     // too small
 800036c:	4291      	cmp	r1, r2
 800036e:	dc13      	bgt.n	8000398 <good_addr+0x30>
    STATIC_ASSERT(SRAM1_BASE == BL_SRAM_BASE);

    const uint32_t sram_start = BL_SRAM_BASE + BL_SRAM_SIZE;
    const uint32_t sram_end = SRAM3_BASE + SRAM3_SIZE;

    if((x >= sram_start) && ((x+len) <= sram_end)) {
 8000370:	490c      	ldr	r1, [pc, #48]	; (80003a4 <good_addr+0x3c>)
 8000372:	4288      	cmp	r0, r1
 8000374:	d903      	bls.n	800037e <good_addr+0x16>
 8000376:	490c      	ldr	r1, [pc, #48]	; (80003a8 <good_addr+0x40>)
 8000378:	4402      	add	r2, r0
 800037a:	428a      	cmp	r2, r1
 800037c:	d90e      	bls.n	800039c <good_addr+0x34>
        // inside the 3 SRAM areas
        return 0;
    }

    if(!readonly) {
 800037e:	b17b      	cbz	r3, 80003a0 <good_addr+0x38>
        return EPERM;
    }

    if((x >= FIRMWARE_START) && (x - FIRMWARE_START) < FW_MAX_LENGTH) {
 8000380:	f100 4077 	add.w	r0, r0, #4143972352	; 0xf7000000
 8000384:	f500 007e 	add.w	r0, r0, #16646144	; 0xfe0000
        // inside flash of main firmware (happens for QSTR's)
        return 0;
    }

    return EACCES;
 8000388:	f5b0 2f78 	cmp.w	r0, #1015808	; 0xf8000
 800038c:	bf34      	ite	cc
 800038e:	2000      	movcc	r0, #0
 8000390:	200d      	movcs	r0, #13
 8000392:	4770      	bx	lr
good_addr(const uint8_t *b, int minlen, int len, bool readonly)
{
    uint32_t x = (uint32_t)b;

    if(minlen) {
        if(!b) return EFAULT;               // gave no buffer
 8000394:	200e      	movs	r0, #14
 8000396:	4770      	bx	lr
        if(len < minlen) return ERANGE;     // too small
 8000398:	2022      	movs	r0, #34	; 0x22
 800039a:	4770      	bx	lr
    const uint32_t sram_start = BL_SRAM_BASE + BL_SRAM_SIZE;
    const uint32_t sram_end = SRAM3_BASE + SRAM3_SIZE;

    if((x >= sram_start) && ((x+len) <= sram_end)) {
        // inside the 3 SRAM areas
        return 0;
 800039c:	2000      	movs	r0, #0
 800039e:	4770      	bx	lr
    }

    if(!readonly) {
        return EPERM;
 80003a0:	2001      	movs	r0, #1
        // inside flash of main firmware (happens for QSTR's)
        return 0;
    }

    return EACCES;
}
 80003a2:	4770      	bx	lr
 80003a4:	20001bff 	.word	0x20001bff
 80003a8:	200a0000 	.word	0x200a0000

080003ac <firewall_dispatch>:
//
    __attribute__ ((used))
    int
firewall_dispatch(int method_num, uint8_t *buf_io, int len_in,
                        uint32_t arg2, uint32_t incoming_sp, uint32_t incoming_lr)
{
 80003ac:	b570      	push	{r4, r5, r6, lr}
 80003ae:	b09e      	sub	sp, #120	; 0x78
 80003b0:	460d      	mov	r5, r1
 80003b2:	4616      	mov	r6, r2
 80003b4:	9301      	str	r3, [sp, #4]
 80003b6:	9923      	ldr	r1, [sp, #140]	; 0x8c
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80003b8:	b672      	cpsid	i
    __disable_irq();
#endif

    // "1=any code executed outside the protected segment will close the Firewall"
    // "0=.. will reset the processor"
    __HAL_FIREWALL_PREARM_DISABLE();
 80003ba:	4bb1      	ldr	r3, [pc, #708]	; (8000680 <firewall_dispatch+0x2d4>)
 80003bc:	6a1a      	ldr	r2, [r3, #32]
 80003be:	f022 0201 	bic.w	r2, r2, #1
 80003c2:	621a      	str	r2, [r3, #32]
 80003c4:	6a1b      	ldr	r3, [r3, #32]
 80003c6:	f003 0301 	and.w	r3, r3, #1
 80003ca:	9302      	str	r3, [sp, #8]
    //   using read/write in place.
    // - use arg2 use when a simple number is needed; never a pointer!
    // - mpy may provide a pointer to flash if we give it a qstr or small value, and if
    //   we're reading only, that's fine.

    if(len_in > 1024) {     // arbitrary max, increase as needed
 80003cc:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
    __disable_irq();
#endif

    // "1=any code executed outside the protected segment will close the Firewall"
    // "0=.. will reset the processor"
    __HAL_FIREWALL_PREARM_DISABLE();
 80003d0:	9b02      	ldr	r3, [sp, #8]
    //   using read/write in place.
    // - use arg2 use when a simple number is needed; never a pointer!
    // - mpy may provide a pointer to flash if we give it a qstr or small value, and if
    //   we're reading only, that's fine.

    if(len_in > 1024) {     // arbitrary max, increase as needed
 80003d2:	f300 829d 	bgt.w	8000910 <firewall_dispatch+0x564>

    // Use these macros
#define REQUIRE_IN_ONLY(x)   if((rv = good_addr(buf_io, (x), len_in, true))) { goto fail; }
#define REQUIRE_OUT(x)       if((rv = good_addr(buf_io, (x), len_in, false))) { goto fail; }

    switch(method_num) {
 80003d6:	3001      	adds	r0, #1
 80003d8:	281a      	cmp	r0, #26
 80003da:	f200 829b 	bhi.w	8000914 <firewall_dispatch+0x568>
 80003de:	e8df f010 	tbh	[pc, r0, lsl #1]
 80003e2:	028a      	.short	0x028a
 80003e4:	0033001b 	.word	0x0033001b
 80003e8:	008d0052 	.word	0x008d0052
 80003ec:	00c400a2 	.word	0x00c400a2
 80003f0:	02990295 	.word	0x02990295
 80003f4:	02990299 	.word	0x02990299
 80003f8:	02990299 	.word	0x02990299
 80003fc:	029900cc 	.word	0x029900cc
 8000400:	00d80299 	.word	0x00d80299
 8000404:	010700f3 	.word	0x010700f3
 8000408:	017a011b 	.word	0x017a011b
 800040c:	01c501b1 	.word	0x01c501b1
 8000410:	02610223 	.word	0x02610223
 8000414:	027d0275 	.word	0x027d0275
        case 0: {
            REQUIRE_OUT(64);
 8000418:	2300      	movs	r3, #0
 800041a:	4632      	mov	r2, r6
 800041c:	2140      	movs	r1, #64	; 0x40
 800041e:	4628      	mov	r0, r5
 8000420:	f7ff ffa2 	bl	8000368 <good_addr>
 8000424:	4604      	mov	r4, r0
 8000426:	2800      	cmp	r0, #0
 8000428:	f040 8279 	bne.w	800091e <firewall_dispatch+0x572>

            // Return my version string
            memset(buf_io, 0, len_in);
 800042c:	4632      	mov	r2, r6
 800042e:	4601      	mov	r1, r0
 8000430:	4628      	mov	r0, r5
 8000432:	f00d f848 	bl	800d4c6 <memset>
            strlcpy((char *)buf_io, version_string, len_in);
 8000436:	4632      	mov	r2, r6
 8000438:	4992      	ldr	r1, [pc, #584]	; (8000684 <firewall_dispatch+0x2d8>)
 800043a:	4628      	mov	r0, r5
 800043c:	f00d f85a 	bl	800d4f4 <strlcpy>

            rv = strlen(version_string);
 8000440:	4890      	ldr	r0, [pc, #576]	; (8000684 <firewall_dispatch+0x2d8>)
 8000442:	f00d f86c 	bl	800d51e <strlen>
 8000446:	e07b      	b.n	8000540 <firewall_dispatch+0x194>
        }

        case 1: {
            // Perform SHA256 over ourselves, with 32-bits of salt, to imply we 
            // haven't stored valid responses.
            REQUIRE_OUT(32);
 8000448:	2300      	movs	r3, #0
 800044a:	4632      	mov	r2, r6
 800044c:	2120      	movs	r1, #32
 800044e:	4628      	mov	r0, r5
 8000450:	f7ff ff8a 	bl	8000368 <good_addr>
 8000454:	4604      	mov	r4, r0
 8000456:	2800      	cmp	r0, #0
 8000458:	f040 8261 	bne.w	800091e <firewall_dispatch+0x572>

            SHA256_CTX  ctx;
            sha256_init(&ctx);
 800045c:	a80b      	add	r0, sp, #44	; 0x2c
 800045e:	f004 ff77 	bl	8005350 <sha256_init>
            sha256_update(&ctx, (void *)&arg2, 4);
 8000462:	2204      	movs	r2, #4
 8000464:	eb0d 0102 	add.w	r1, sp, r2
 8000468:	a80b      	add	r0, sp, #44	; 0x2c
 800046a:	f004 ff81 	bl	8005370 <sha256_update>
            sha256_update(&ctx, (void *)BL_FLASH_BASE, BL_FLASH_SIZE);
 800046e:	a80b      	add	r0, sp, #44	; 0x2c
 8000470:	f44f 32f0 	mov.w	r2, #122880	; 0x1e000
 8000474:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
 8000478:	f004 ff7a 	bl	8005370 <sha256_update>
            sha256_final(&ctx, buf_io);
 800047c:	4629      	mov	r1, r5
 800047e:	a80b      	add	r0, sp, #44	; 0x2c
 8000480:	f004 ffbc 	bl	80053fc <sha256_final>
 8000484:	e24b      	b.n	800091e <firewall_dispatch+0x572>
// Write bag number (probably a string)
void flash_save_bag_number(const uint8_t new_number[32]);

// Are we operating in level2?
static inline bool flash_is_security_level2(void) {
    rng_delay();
 8000486:	f002 f956 	bl	8002736 <rng_delay>
    return ((FLASH->OPTR & FLASH_OPTR_RDP_Msk) == 0xCC);
 800048a:	4b7f      	ldr	r3, [pc, #508]	; (8000688 <firewall_dispatch+0x2dc>)
 800048c:	6a1b      	ldr	r3, [r3, #32]
 800048e:	b2db      	uxtb	r3, r3
 8000490:	f1a3 02cc 	sub.w	r2, r3, #204	; 0xcc
 8000494:	4255      	negs	r5, r2
 8000496:	4155      	adcs	r5, r2
            bool secure = flash_is_security_level2();

            // Go into DFU mode. It's a one-way trip.
            // Also used to show some "fatal" screens w/ memory wipe.

            switch(arg2) {
 8000498:	9a01      	ldr	r2, [sp, #4]
 800049a:	2a02      	cmp	r2, #2
 800049c:	d010      	beq.n	80004c0 <firewall_dispatch+0x114>
 800049e:	2a03      	cmp	r2, #3
 80004a0:	d013      	beq.n	80004ca <firewall_dispatch+0x11e>
 80004a2:	2a01      	cmp	r2, #1
 80004a4:	d007      	beq.n	80004b6 <firewall_dispatch+0x10a>
                default:
                case 0:
                    // enter DFU for firmware upgrades
                    if(secure) {
 80004a6:	2bcc      	cmp	r3, #204	; 0xcc
 80004a8:	f000 8238 	beq.w	800091c <firewall_dispatch+0x570>
                        // we cannot support DFU in secure mode anymore
                        rv = EPERM;
                        goto fail;
                    }
                    puts("Die: DFU");
 80004ac:	4877      	ldr	r0, [pc, #476]	; (800068c <firewall_dispatch+0x2e0>)
 80004ae:	f004 fc01 	bl	8004cb4 <puts>
            break;
        }

        case 2: {
            const uint8_t   *scr;
            bool secure = flash_is_security_level2();
 80004b2:	2500      	movs	r5, #0
 80004b4:	e002      	b.n	80004bc <firewall_dispatch+0x110>
                    scr = screen_downgrade;         // was screen_dfu
                    break;
                case 1:
                    // in case some way for Micropython to detect it.
                    scr = screen_downgrade;
                    puts("Die: Downgrade");
 80004b6:	4876      	ldr	r0, [pc, #472]	; (8000690 <firewall_dispatch+0x2e4>)
 80004b8:	f004 fbfc 	bl	8004cb4 <puts>
                    puts("Die: DFU");
                    scr = screen_downgrade;         // was screen_dfu
                    break;
                case 1:
                    // in case some way for Micropython to detect it.
                    scr = screen_downgrade;
 80004bc:	4c75      	ldr	r4, [pc, #468]	; (8000694 <firewall_dispatch+0x2e8>)
                    puts("Die: Downgrade");
                    break;
 80004be:	e009      	b.n	80004d4 <firewall_dispatch+0x128>
                case 2:
                    scr = screen_blankish;
                    puts("Die: Blankish");
 80004c0:	4875      	ldr	r0, [pc, #468]	; (8000698 <firewall_dispatch+0x2ec>)
                    // in case some way for Micropython to detect it.
                    scr = screen_downgrade;
                    puts("Die: Downgrade");
                    break;
                case 2:
                    scr = screen_blankish;
 80004c2:	4c76      	ldr	r4, [pc, #472]	; (800069c <firewall_dispatch+0x2f0>)
                    puts("Die: Blankish");
 80004c4:	f004 fbf6 	bl	8004cb4 <puts>
                    break;
 80004c8:	e004      	b.n	80004d4 <firewall_dispatch+0x128>
                case 3:
                    scr = screen_brick;
                    puts("Die: Brick");
 80004ca:	4875      	ldr	r0, [pc, #468]	; (80006a0 <firewall_dispatch+0x2f4>)
                case 2:
                    scr = screen_blankish;
                    puts("Die: Blankish");
                    break;
                case 3:
                    scr = screen_brick;
 80004cc:	4c75      	ldr	r4, [pc, #468]	; (80006a4 <firewall_dispatch+0x2f8>)
                    puts("Die: Brick");
 80004ce:	f004 fbf1 	bl	8004cb4 <puts>
                    secure = true;      // no point going into DFU, if even possible
 80004d2:	2501      	movs	r5, #1
                    break;
            }

            oled_setup();
 80004d4:	f000 fbfe 	bl	8000cd4 <oled_setup>
            oled_show(scr);
 80004d8:	4620      	mov	r0, r4
 80004da:	f000 fc8b 	bl	8000df4 <oled_show>

            wipe_all_sram();
 80004de:	f000 fa5b 	bl	8000998 <wipe_all_sram>
            psram_wipe();
 80004e2:	f004 fd11 	bl	8004f08 <psram_wipe>

            if(secure) {
 80004e6:	b10d      	cbz	r5, 80004ec <firewall_dispatch+0x140>
                // just die with that message shown; can't start DFU
                LOCKUP_FOREVER();
 80004e8:	bf30      	wfi
 80004ea:	e7fd      	b.n	80004e8 <firewall_dispatch+0x13c>
            } else {
                // Cannot just call enter_dfu() because it doesn't work well
                // once Micropython has configured so much stuff in the chip.

                // Leave a reminder to ourselves
                memcpy(dfu_flag->magic, REBOOT_TO_DFU, sizeof(dfu_flag->magic));
 80004ec:	496e      	ldr	r1, [pc, #440]	; (80006a8 <firewall_dispatch+0x2fc>)
 80004ee:	4a6f      	ldr	r2, [pc, #444]	; (80006ac <firewall_dispatch+0x300>)
 80004f0:	6808      	ldr	r0, [r1, #0]
 80004f2:	6849      	ldr	r1, [r1, #4]
 80004f4:	4613      	mov	r3, r2
 80004f6:	c303      	stmia	r3!, {r0, r1}
                dfu_flag->screen = scr;
 80004f8:	6094      	str	r4, [r2, #8]
 80004fa:	e010      	b.n	800051e <firewall_dispatch+0x172>
            break;
        }

        case 3:
            // logout: wipe all of memory and lock up. Must powercycle to recover.
            switch(arg2) { 
 80004fc:	9b01      	ldr	r3, [sp, #4]
 80004fe:	b10b      	cbz	r3, 8000504 <firewall_dispatch+0x158>
 8000500:	2b02      	cmp	r3, #2
 8000502:	d102      	bne.n	800050a <firewall_dispatch+0x15e>
                case 0:
                case 2:
                    oled_show(screen_logout);
 8000504:	486a      	ldr	r0, [pc, #424]	; (80006b0 <firewall_dispatch+0x304>)
 8000506:	f000 fc75 	bl	8000df4 <oled_show>
                case 1:
                    // leave screen untouched
                    break;
            }

            wipe_all_sram();
 800050a:	f000 fa45 	bl	8000998 <wipe_all_sram>
            psram_wipe();
 800050e:	f004 fcfb 	bl	8004f08 <psram_wipe>

            if(arg2 == 2) {
 8000512:	9b01      	ldr	r3, [sp, #4]
 8000514:	2b02      	cmp	r3, #2
 8000516:	d104      	bne.n	8000522 <firewall_dispatch+0x176>
                // need some time to show OLED contents
                delay_ms(100);
 8000518:	2064      	movs	r0, #100	; 0x64
 800051a:	f003 f9b5 	bl	8003888 <delay_ms>

                // reboot so we can "login" again
                NVIC_SystemReset();
 800051e:	f7ff ff11 	bl	8000344 <__NVIC_SystemReset>

                // NOT-REACHED (but ok if it does)
            }

            // wait for an interrupt which will never happen (ie. sleep)
            LOCKUP_FOREVER()
 8000522:	bf30      	wfi
 8000524:	e7fd      	b.n	8000522 <firewall_dispatch+0x176>
            break;

        case 4:
            // attempt to control the GPIO (won't work for 1)
            ae_setup();
 8000526:	f002 fa3b 	bl	80029a0 <ae_setup>
            ae_keep_alive();
 800052a:	f002 fa6d 	bl	8002a08 <ae_keep_alive>
            switch(arg2) {
 800052e:	9b01      	ldr	r3, [sp, #4]
 8000530:	2b02      	cmp	r3, #2
 8000532:	d009      	beq.n	8000548 <firewall_dispatch+0x19c>
 8000534:	2b03      	cmp	r3, #3
 8000536:	d00b      	beq.n	8000550 <firewall_dispatch+0x1a4>
 8000538:	2b01      	cmp	r3, #1
 800053a:	d003      	beq.n	8000544 <firewall_dispatch+0x198>
                default:
                case 0:     // read state
                    rv = ae_get_gpio();
 800053c:	f002 ffbb 	bl	80034b6 <ae_get_gpio>
 8000540:	4604      	mov	r4, r0
                    break;
 8000542:	e1ec      	b.n	800091e <firewall_dispatch+0x572>
                case 1:     // clear it (can work anytime)
                    rv = ae_set_gpio(0);
 8000544:	2000      	movs	r0, #0
 8000546:	e000      	b.n	800054a <firewall_dispatch+0x19e>
                    break;
                case 2:     // set it (will always fail)
                    rv = ae_set_gpio(1);
 8000548:	2001      	movs	r0, #1
 800054a:	f002 ff85 	bl	8003458 <ae_set_gpio>
 800054e:	e7f7      	b.n	8000540 <firewall_dispatch+0x194>

                case 3: {     // do a verify and see if it maybe goes green
                    uint8_t fw_digest[32], world_digest[32];

                    // takes time, shows progress bar
                    checksum_flash(fw_digest, world_digest, 0);
 8000550:	2200      	movs	r2, #0
 8000552:	a90b      	add	r1, sp, #44	; 0x2c
 8000554:	a803      	add	r0, sp, #12
 8000556:	f001 fa8f 	bl	8001a78 <checksum_flash>

                    rv = ae_set_gpio_secure(world_digest);
 800055a:	a80b      	add	r0, sp, #44	; 0x2c
 800055c:	f002 ff93 	bl	8003486 <ae_set_gpio_secure>
 8000560:	4604      	mov	r4, r0

                    oled_show(screen_blankish);
 8000562:	484e      	ldr	r0, [pc, #312]	; (800069c <firewall_dispatch+0x2f0>)
 8000564:	f000 fc46 	bl	8000df4 <oled_show>
 8000568:	e1d9      	b.n	800091e <firewall_dispatch+0x572>
        case 5:     
            // Are we a brick?
            // if the pairing secret doesn't work anymore, that
            // means we've been bricked.
            // TODO: also report hardware issue, and non-configured states
            ae_setup();
 800056a:	f002 fa19 	bl	80029a0 <ae_setup>
            rv = (ae_pair_unlock() != 0);
 800056e:	f002 fc17 	bl	8002da0 <ae_pair_unlock>
 8000572:	1c04      	adds	r4, r0, #0
 8000574:	bf18      	it	ne
 8000576:	2401      	movne	r4, #1
            break;
 8000578:	e1d1      	b.n	800091e <firewall_dispatch+0x572>
            #endif
            break;

        case 12:
            // read the DFU button (used for selftest at least)
            REQUIRE_OUT(1);
 800057a:	2300      	movs	r3, #0
 800057c:	4632      	mov	r2, r6
 800057e:	2101      	movs	r1, #1
 8000580:	4628      	mov	r0, r5
 8000582:	f7ff fef1 	bl	8000368 <good_addr>
 8000586:	4604      	mov	r4, r0
 8000588:	2800      	cmp	r0, #0
 800058a:	f040 81c8 	bne.w	800091e <firewall_dispatch+0x572>
            buf_io[0] = 0;          // NOT SUPPORTED on Mk4
 800058e:	7028      	strb	r0, [r5, #0]
            break;
 8000590:	e1c5      	b.n	800091e <firewall_dispatch+0x572>

        case 15: {
            // Read a dataslot directly. Will fail on 
            // encrypted slots.
            if(len_in != 4 && len_in != 32 && len_in != 72) {
 8000592:	2e04      	cmp	r6, #4
 8000594:	d004      	beq.n	80005a0 <firewall_dispatch+0x1f4>
 8000596:	2e20      	cmp	r6, #32
 8000598:	d002      	beq.n	80005a0 <firewall_dispatch+0x1f4>
 800059a:	2e48      	cmp	r6, #72	; 0x48
 800059c:	f040 81b8 	bne.w	8000910 <firewall_dispatch+0x564>
                rv = ERANGE;
            } else {
                REQUIRE_OUT(4);
 80005a0:	2300      	movs	r3, #0
 80005a2:	4632      	mov	r2, r6
 80005a4:	2104      	movs	r1, #4
 80005a6:	4628      	mov	r0, r5
 80005a8:	f7ff fede 	bl	8000368 <good_addr>
 80005ac:	4604      	mov	r4, r0
 80005ae:	2800      	cmp	r0, #0
 80005b0:	f040 81b5 	bne.w	800091e <firewall_dispatch+0x572>

                ae_setup();
 80005b4:	f002 f9f4 	bl	80029a0 <ae_setup>
                if(ae_read_data_slot(arg2 & 0xf, buf_io, len_in)) {
 80005b8:	9801      	ldr	r0, [sp, #4]
 80005ba:	4632      	mov	r2, r6
 80005bc:	4629      	mov	r1, r5
 80005be:	f000 000f 	and.w	r0, r0, #15
 80005c2:	f002 ff05 	bl	80033d0 <ae_read_data_slot>
 80005c6:	e0cc      	b.n	8000762 <firewall_dispatch+0x3b6>
            break;
        }

        case 16: {
            // Provide the 2 words for anti-phishing.
            REQUIRE_OUT(MAX_PIN_LEN);
 80005c8:	2300      	movs	r3, #0
 80005ca:	4632      	mov	r2, r6
 80005cc:	2120      	movs	r1, #32
 80005ce:	4628      	mov	r0, r5
 80005d0:	f7ff feca 	bl	8000368 <good_addr>
 80005d4:	4604      	mov	r4, r0
 80005d6:	2800      	cmp	r0, #0
 80005d8:	f040 81a1 	bne.w	800091e <firewall_dispatch+0x572>

            // arg2: length of pin.
            if((arg2 < 1) || (arg2 > MAX_PIN_LEN)) {
 80005dc:	9901      	ldr	r1, [sp, #4]
 80005de:	1e4b      	subs	r3, r1, #1
 80005e0:	2b1f      	cmp	r3, #31
 80005e2:	f200 8195 	bhi.w	8000910 <firewall_dispatch+0x564>
                rv = ERANGE;
            } else {
                if(pin_prefix_words((char *)buf_io, arg2, (uint32_t *)buf_io)) {
 80005e6:	462a      	mov	r2, r5
 80005e8:	4628      	mov	r0, r5
 80005ea:	f003 fc03 	bl	8003df4 <pin_prefix_words>
 80005ee:	e0b8      	b.n	8000762 <firewall_dispatch+0x3b6>
            break;
        }

        case 17:
            // test rng
            REQUIRE_OUT(32);
 80005f0:	2300      	movs	r3, #0
 80005f2:	4632      	mov	r2, r6
 80005f4:	2120      	movs	r1, #32
 80005f6:	4628      	mov	r0, r5
 80005f8:	f7ff feb6 	bl	8000368 <good_addr>
 80005fc:	4604      	mov	r4, r0
 80005fe:	2800      	cmp	r0, #0
 8000600:	f040 818d 	bne.w	800091e <firewall_dispatch+0x572>
            memset(buf_io, 0x55, 32);       // to help show errors
 8000604:	2220      	movs	r2, #32
 8000606:	2155      	movs	r1, #85	; 0x55
 8000608:	4628      	mov	r0, r5
 800060a:	f00c ff5c 	bl	800d4c6 <memset>
            rng_buffer(buf_io, 32);
 800060e:	2120      	movs	r1, #32
 8000610:	4628      	mov	r0, r5
 8000612:	f002 f879 	bl	8002708 <rng_buffer>
            break;
 8000616:	e182      	b.n	800091e <firewall_dispatch+0x572>

        case 18: {
            // Try login w/ PIN.
            REQUIRE_OUT(PIN_ATTEMPT_SIZE_V2);
 8000618:	2300      	movs	r3, #0
 800061a:	4632      	mov	r2, r6
 800061c:	f44f 718c 	mov.w	r1, #280	; 0x118
 8000620:	4628      	mov	r0, r5
 8000622:	f7ff fea1 	bl	8000368 <good_addr>
 8000626:	4604      	mov	r4, r0
 8000628:	2800      	cmp	r0, #0
 800062a:	f040 8178 	bne.w	800091e <firewall_dispatch+0x572>
            pinAttempt_t *args = (pinAttempt_t *)buf_io;

            switch(arg2) {
 800062e:	9b01      	ldr	r3, [sp, #4]
 8000630:	2b08      	cmp	r3, #8
 8000632:	f200 816f 	bhi.w	8000914 <firewall_dispatch+0x568>
 8000636:	e8df f003 	tbb	[pc, r3]
 800063a:	0905      	.short	0x0905
 800063c:	1915110d 	.word	0x1915110d
 8000640:	1f1d      	.short	0x1f1d
 8000642:	3d          	.byte	0x3d
 8000643:	00          	.byte	0x00
                case 0:
                    rv = pin_setup_attempt(args);
 8000644:	4628      	mov	r0, r5
 8000646:	f003 fbf3 	bl	8003e30 <pin_setup_attempt>
 800064a:	e779      	b.n	8000540 <firewall_dispatch+0x194>
                    break;
                case 1:
                    rv = pin_delay(args);
 800064c:	4628      	mov	r0, r5
 800064e:	f003 fc61 	bl	8003f14 <pin_delay>
 8000652:	e775      	b.n	8000540 <firewall_dispatch+0x194>
                    break;
                case 2:
                    rv = pin_login_attempt(args);
 8000654:	4628      	mov	r0, r5
 8000656:	f003 fc5f 	bl	8003f18 <pin_login_attempt>
 800065a:	e771      	b.n	8000540 <firewall_dispatch+0x194>
                    break;
                case 3:
                    rv = pin_change(args);
 800065c:	4628      	mov	r0, r5
 800065e:	f003 fd83 	bl	8004168 <pin_change>
 8000662:	e76d      	b.n	8000540 <firewall_dispatch+0x194>
                    break;
                case 4:
                    rv = pin_fetch_secret(args);
 8000664:	4628      	mov	r0, r5
 8000666:	f003 fe39 	bl	80042dc <pin_fetch_secret>
 800066a:	e769      	b.n	8000540 <firewall_dispatch+0x194>
                    break;

                case 5:
                    rv = pin_firmware_greenlight(args);
 800066c:	4628      	mov	r0, r5
 800066e:	f003 ffcb 	bl	8004608 <pin_firmware_greenlight>
 8000672:	e765      	b.n	8000540 <firewall_dispatch+0x194>
                    break;

                case 6:         // new for v2
                    rv = pin_long_secret(args, NULL);
 8000674:	2100      	movs	r1, #0
 8000676:	e02a      	b.n	80006ce <firewall_dispatch+0x322>
                    break;

                case 7:         // new for Mk4
                    rv = pin_firmware_upgrade(args);
 8000678:	4628      	mov	r0, r5
 800067a:	f004 f807 	bl	800468c <pin_firmware_upgrade>
 800067e:	e75f      	b.n	8000540 <firewall_dispatch+0x194>
 8000680:	40011c00 	.word	0x40011c00
 8000684:	0800e478 	.word	0x0800e478
 8000688:	40022000 	.word	0x40022000
 800068c:	0800d55d 	.word	0x0800d55d
 8000690:	0800d566 	.word	0x0800d566
 8000694:	0800d8b9 	.word	0x0800d8b9
 8000698:	0800d575 	.word	0x0800d575
 800069c:	0800dd01 	.word	0x0800dd01
 80006a0:	0800d583 	.word	0x0800d583
 80006a4:	0800de53 	.word	0x0800de53
 80006a8:	0800d58e 	.word	0x0800d58e
 80006ac:	20008000 	.word	0x20008000
 80006b0:	0800d97f 	.word	0x0800d97f
                    break;

                case 8:         // new for Mk4: faster for reading only tho
                    REQUIRE_OUT(PIN_ATTEMPT_SIZE_V2 + AE_LONG_SECRET_LEN);
 80006b4:	2300      	movs	r3, #0
 80006b6:	4632      	mov	r2, r6
 80006b8:	f44f 712e 	mov.w	r1, #696	; 0x2b8
 80006bc:	4628      	mov	r0, r5
 80006be:	f7ff fe53 	bl	8000368 <good_addr>
 80006c2:	4604      	mov	r4, r0
 80006c4:	2800      	cmp	r0, #0
 80006c6:	f040 812a 	bne.w	800091e <firewall_dispatch+0x572>
                    rv = pin_long_secret(args, &buf_io[PIN_ATTEMPT_SIZE_V2]);
 80006ca:	f505 718c 	add.w	r1, r5, #280	; 0x118
 80006ce:	4628      	mov	r0, r5
 80006d0:	f003 fede 	bl	8004490 <pin_long_secret>
 80006d4:	e734      	b.n	8000540 <firewall_dispatch+0x194>
            break;
        }


        case 19: {   // bag number stuff
            switch(arg2) {
 80006d6:	9b01      	ldr	r3, [sp, #4]
 80006d8:	2b64      	cmp	r3, #100	; 0x64
 80006da:	d02d      	beq.n	8000738 <firewall_dispatch+0x38c>
 80006dc:	d803      	bhi.n	80006e6 <firewall_dispatch+0x33a>
 80006de:	b14b      	cbz	r3, 80006f4 <firewall_dispatch+0x348>
 80006e0:	2b01      	cmp	r3, #1
 80006e2:	d01c      	beq.n	800071e <firewall_dispatch+0x372>
 80006e4:	e116      	b.n	8000914 <firewall_dispatch+0x568>
 80006e6:	2b65      	cmp	r3, #101	; 0x65
 80006e8:	d028      	beq.n	800073c <firewall_dispatch+0x390>
 80006ea:	2b66      	cmp	r3, #102	; 0x66
 80006ec:	f040 8112 	bne.w	8000914 <firewall_dispatch+0x568>
                case 101:
                    flash_lockdown_hard(OB_RDP_LEVEL_1);        // Can only do 0->1 (experiments)
                    break;
                case 102:
                    // production units will be:
                    flash_lockdown_hard(OB_RDP_LEVEL_2);        // No change possible after this.
 80006f0:	20cc      	movs	r0, #204	; 0xcc
 80006f2:	e024      	b.n	800073e <firewall_dispatch+0x392>

        case 19: {   // bag number stuff
            switch(arg2) {
                case 0:
                    // read out number
                    REQUIRE_OUT(32);
 80006f4:	4632      	mov	r2, r6
 80006f6:	2120      	movs	r1, #32
 80006f8:	4628      	mov	r0, r5
 80006fa:	f7ff fe35 	bl	8000368 <good_addr>
 80006fe:	4604      	mov	r4, r0
 8000700:	2800      	cmp	r0, #0
 8000702:	f040 810c 	bne.w	800091e <firewall_dispatch+0x572>
                    memcpy(buf_io, rom_secrets->bag_number, 32);
 8000706:	4a9e      	ldr	r2, [pc, #632]	; (8000980 <firewall_dispatch+0x5d4>)
 8000708:	4e9e      	ldr	r6, [pc, #632]	; (8000984 <firewall_dispatch+0x5d8>)
 800070a:	4613      	mov	r3, r2
 800070c:	cb03      	ldmia	r3!, {r0, r1}
 800070e:	42b3      	cmp	r3, r6
 8000710:	6028      	str	r0, [r5, #0]
 8000712:	6069      	str	r1, [r5, #4]
 8000714:	461a      	mov	r2, r3
 8000716:	f105 0508 	add.w	r5, r5, #8
 800071a:	d1f6      	bne.n	800070a <firewall_dispatch+0x35e>
 800071c:	e0ff      	b.n	800091e <firewall_dispatch+0x572>
                    break;

                case 1:
                    // set the bag number, and (should) do lock down
                    REQUIRE_IN_ONLY(32);
 800071e:	4632      	mov	r2, r6
 8000720:	2120      	movs	r1, #32
 8000722:	4628      	mov	r0, r5
 8000724:	f7ff fe20 	bl	8000368 <good_addr>
 8000728:	4604      	mov	r4, r0
 800072a:	2800      	cmp	r0, #0
 800072c:	f040 80f7 	bne.w	800091e <firewall_dispatch+0x572>

                    flash_save_bag_number(buf_io);
 8000730:	4628      	mov	r0, r5
 8000732:	f001 fd3b 	bl	80021ac <flash_save_bag_number>
                    break;
 8000736:	e0f2      	b.n	800091e <firewall_dispatch+0x572>

                case 100:
                    flash_lockdown_hard(OB_RDP_LEVEL_0);        // wipes contents of flash (1->0)
 8000738:	20aa      	movs	r0, #170	; 0xaa
 800073a:	e000      	b.n	800073e <firewall_dispatch+0x392>
                    break;
                case 101:
                    flash_lockdown_hard(OB_RDP_LEVEL_1);        // Can only do 0->1 (experiments)
 800073c:	20bb      	movs	r0, #187	; 0xbb
                    break;
                case 102:
                    // production units will be:
                    flash_lockdown_hard(OB_RDP_LEVEL_2);        // No change possible after this.
 800073e:	f001 fe33 	bl	80023a8 <flash_lockdown_hard>
 8000742:	e0e3      	b.n	800090c <firewall_dispatch+0x560>
            break;
        }
            
        case 20:
            // Read out entire config dataspace
            REQUIRE_OUT(128);
 8000744:	2300      	movs	r3, #0
 8000746:	4632      	mov	r2, r6
 8000748:	2180      	movs	r1, #128	; 0x80
 800074a:	4628      	mov	r0, r5
 800074c:	f7ff fe0c 	bl	8000368 <good_addr>
 8000750:	4604      	mov	r4, r0
 8000752:	2800      	cmp	r0, #0
 8000754:	f040 80e3 	bne.w	800091e <firewall_dispatch+0x572>

            ae_setup();
 8000758:	f002 f922 	bl	80029a0 <ae_setup>
            rv = ae_config_read(buf_io);
 800075c:	4628      	mov	r0, r5
 800075e:	f002 fefe 	bl	800355e <ae_config_read>
            if(rv) {
 8000762:	2800      	cmp	r0, #0
 8000764:	f000 80d2 	beq.w	800090c <firewall_dispatch+0x560>
                rv = EIO;
 8000768:	2405      	movs	r4, #5
 800076a:	e0d8      	b.n	800091e <firewall_dispatch+0x572>
            } 
            break;

        case 21:
            // read OTP / downgrade protection
            switch(arg2) {
 800076c:	9b01      	ldr	r3, [sp, #4]
 800076e:	2b03      	cmp	r3, #3
 8000770:	f200 80d0 	bhi.w	8000914 <firewall_dispatch+0x568>
 8000774:	e8df f003 	tbb	[pc, r3]
 8000778:	471f1002 	.word	0x471f1002
                case 0:
                    REQUIRE_OUT(8);
 800077c:	2300      	movs	r3, #0
 800077e:	4632      	mov	r2, r6
 8000780:	2108      	movs	r1, #8
 8000782:	4628      	mov	r0, r5
 8000784:	f7ff fdf0 	bl	8000368 <good_addr>
 8000788:	4604      	mov	r4, r0
 800078a:	2800      	cmp	r0, #0
 800078c:	f040 80c7 	bne.w	800091e <firewall_dispatch+0x572>
                    get_min_version(buf_io);
 8000790:	4628      	mov	r0, r5
 8000792:	f001 fa01 	bl	8001b98 <get_min_version>
                    break;
 8000796:	e0c2      	b.n	800091e <firewall_dispatch+0x572>

                case 1:
                    REQUIRE_IN_ONLY(8);
 8000798:	2301      	movs	r3, #1
 800079a:	4632      	mov	r2, r6
 800079c:	2108      	movs	r1, #8
 800079e:	4628      	mov	r0, r5
 80007a0:	f7ff fde2 	bl	8000368 <good_addr>
 80007a4:	4604      	mov	r4, r0
 80007a6:	2800      	cmp	r0, #0
 80007a8:	f040 80b9 	bne.w	800091e <firewall_dispatch+0x572>
                    rv = check_is_downgrade(buf_io, NULL);
 80007ac:	4601      	mov	r1, r0
 80007ae:	4628      	mov	r0, r5
 80007b0:	f001 fa12 	bl	8001bd8 <check_is_downgrade>
 80007b4:	e6c4      	b.n	8000540 <firewall_dispatch+0x194>
                    break;

                case 2:
                    REQUIRE_IN_ONLY(8);
 80007b6:	2301      	movs	r3, #1
 80007b8:	4632      	mov	r2, r6
 80007ba:	2108      	movs	r1, #8
 80007bc:	4628      	mov	r0, r5
 80007be:	f7ff fdd3 	bl	8000368 <good_addr>
 80007c2:	4604      	mov	r4, r0
 80007c4:	2800      	cmp	r0, #0
 80007c6:	f040 80aa 	bne.w	800091e <firewall_dispatch+0x572>

                    if(buf_io[0] < 0x10 || buf_io[0] >= 0x40) {
 80007ca:	782b      	ldrb	r3, [r5, #0]
 80007cc:	3b10      	subs	r3, #16
                        // bad data
                        rv = ERANGE;
 80007ce:	2b2f      	cmp	r3, #47	; 0x2f
                    } if(check_is_downgrade(buf_io, NULL)) {
 80007d0:	4601      	mov	r1, r0
 80007d2:	4628      	mov	r0, r5
                case 2:
                    REQUIRE_IN_ONLY(8);

                    if(buf_io[0] < 0x10 || buf_io[0] >= 0x40) {
                        // bad data
                        rv = ERANGE;
 80007d4:	bf88      	it	hi
 80007d6:	2422      	movhi	r4, #34	; 0x22
                    } if(check_is_downgrade(buf_io, NULL)) {
 80007d8:	f001 f9fe 	bl	8001bd8 <check_is_downgrade>
 80007dc:	2800      	cmp	r0, #0
 80007de:	f040 809b 	bne.w	8000918 <firewall_dispatch+0x56c>
                        // already at a higher version?
                        rv = EAGAIN;
                    } else {
                        uint8_t min[8];
                        get_min_version(min);
 80007e2:	a80b      	add	r0, sp, #44	; 0x2c
 80007e4:	f001 f9d8 	bl	8001b98 <get_min_version>

                        if(memcmp(min, buf_io, 8) == 0) {
 80007e8:	2208      	movs	r2, #8
 80007ea:	4629      	mov	r1, r5
 80007ec:	a80b      	add	r0, sp, #44	; 0x2c
 80007ee:	f00c fe35 	bl	800d45c <memcmp>
 80007f2:	2800      	cmp	r0, #0
 80007f4:	f000 8090 	beq.w	8000918 <firewall_dispatch+0x56c>
                            // dupe
                            rv = EAGAIN;
                        } else {
                            // save it, but might be "full" already
                            if(record_highwater_version(buf_io)) {
 80007f8:	4628      	mov	r0, r5
 80007fa:	f001 fdef 	bl	80023dc <record_highwater_version>
                                rv = ENOMEM;
 80007fe:	2800      	cmp	r0, #0
 8000800:	bf18      	it	ne
 8000802:	240c      	movne	r4, #12
 8000804:	e08b      	b.n	800091e <firewall_dispatch+0x572>
                    }
                    break;

                case 3:
                    // read raw counter0 value (max is 0x1fffff)
                    REQUIRE_OUT(4);
 8000806:	2300      	movs	r3, #0
 8000808:	4632      	mov	r2, r6
 800080a:	2104      	movs	r1, #4
 800080c:	4628      	mov	r0, r5
 800080e:	f7ff fdab 	bl	8000368 <good_addr>
 8000812:	4604      	mov	r4, r0
 8000814:	2800      	cmp	r0, #0
 8000816:	f040 8082 	bne.w	800091e <firewall_dispatch+0x572>
                    ae_setup();
 800081a:	f002 f8c1 	bl	80029a0 <ae_setup>
                    rv = ae_get_counter((uint32_t *)buf_io, 0) ? EIO: 0;
 800081e:	4621      	mov	r1, r4
 8000820:	4628      	mov	r0, r5
 8000822:	f002 fc92 	bl	800314a <ae_get_counter>
 8000826:	e79c      	b.n	8000762 <firewall_dispatch+0x3b6>
            }
            break;

        case 22: {          // Mk4+ only
            // Trick pin managment: needs pin change args, plus slot data after that!
            REQUIRE_OUT(PIN_ATTEMPT_SIZE_V2 + sizeof(trick_slot_t));
 8000828:	2300      	movs	r3, #0
 800082a:	4632      	mov	r2, r6
 800082c:	f44f 71cc 	mov.w	r1, #408	; 0x198
 8000830:	4628      	mov	r0, r5
 8000832:	f7ff fd99 	bl	8000368 <good_addr>
 8000836:	4604      	mov	r4, r0
 8000838:	2800      	cmp	r0, #0
 800083a:	d170      	bne.n	800091e <firewall_dispatch+0x572>
            const pinAttempt_t *args = (pinAttempt_t *)buf_io;
            trick_slot_t *slot = (trick_slot_t *)(&buf_io[PIN_ATTEMPT_SIZE_V2]);

            // Verify we know the main PIN, but don't do anything
            bool trick_mode;
            rv = pin_check_logged_in(args, &trick_mode);
 800083c:	a90b      	add	r1, sp, #44	; 0x2c
 800083e:	4628      	mov	r0, r5
 8000840:	f003 fc5c 	bl	80040fc <pin_check_logged_in>

        case 22: {          // Mk4+ only
            // Trick pin managment: needs pin change args, plus slot data after that!
            REQUIRE_OUT(PIN_ATTEMPT_SIZE_V2 + sizeof(trick_slot_t));
            const pinAttempt_t *args = (pinAttempt_t *)buf_io;
            trick_slot_t *slot = (trick_slot_t *)(&buf_io[PIN_ATTEMPT_SIZE_V2]);
 8000844:	f505 768c 	add.w	r6, r5, #280	; 0x118

            // Verify we know the main PIN, but don't do anything
            bool trick_mode;
            rv = pin_check_logged_in(args, &trick_mode);
            if(rv) goto fail;
 8000848:	4604      	mov	r4, r0
 800084a:	2800      	cmp	r0, #0
 800084c:	d167      	bne.n	800091e <firewall_dispatch+0x572>

            if(trick_mode) {
 800084e:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
 8000852:	b10b      	cbz	r3, 8000858 <firewall_dispatch+0x4ac>
                // Already logged in via a trick PIN, so clear the seed to protect 
                // it (we have a smart one here) and continue.
                mcu_key_clear(NULL);
 8000854:	f001 fe10 	bl	8002478 <mcu_key_clear>
            }

            switch(arg2) {
 8000858:	9b01      	ldr	r3, [sp, #4]
 800085a:	2b01      	cmp	r3, #1
 800085c:	d00a      	beq.n	8000874 <firewall_dispatch+0x4c8>
 800085e:	d302      	bcc.n	8000866 <firewall_dispatch+0x4ba>
 8000860:	2b02      	cmp	r3, #2
 8000862:	d017      	beq.n	8000894 <firewall_dispatch+0x4e8>
 8000864:	e056      	b.n	8000914 <firewall_dispatch+0x568>
                case 0:     // clear all
                    if(!trick_mode) {
 8000866:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
 800086a:	2b00      	cmp	r3, #0
 800086c:	d157      	bne.n	800091e <firewall_dispatch+0x572>
                        se2_clear_tricks();
 800086e:	f007 f9e7 	bl	8007c40 <se2_clear_tricks>
 8000872:	e054      	b.n	800091e <firewall_dispatch+0x572>
                    }
                    break;
                case 1:     // get by pin
                    if(trick_mode) {
 8000874:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
 8000878:	2a00      	cmp	r2, #0
 800087a:	d14b      	bne.n	8000914 <firewall_dispatch+0x568>
                        // never finds anything
                        rv = ENOENT;
                    } else {
                        // lookup and return value
                        if(slot->pin_len > 16) {
 800087c:	f8d5 1170 	ldr.w	r1, [r5, #368]	; 0x170
 8000880:	2910      	cmp	r1, #16
 8000882:	dc45      	bgt.n	8000910 <firewall_dispatch+0x564>
                            rv = ERANGE;
                            goto fail;
                        }
                        if(se2_test_trick_pin(slot->pin, slot->pin_len, slot, true)) {
 8000884:	4632      	mov	r2, r6
 8000886:	f505 70b0 	add.w	r0, r5, #352	; 0x160
 800088a:	f007 fa41 	bl	8007d10 <se2_test_trick_pin>
 800088e:	2800      	cmp	r0, #0
 8000890:	d040      	beq.n	8000914 <firewall_dispatch+0x568>
 8000892:	e044      	b.n	800091e <firewall_dispatch+0x572>
                            rv = ENOENT;
                        }
                    }
                    break;
                case 2:     // clear/update slot
                    if(!trick_mode) {
 8000894:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
 8000898:	2b00      	cmp	r3, #0
 800089a:	d140      	bne.n	800091e <firewall_dispatch+0x572>
                        rv = se2_save_trick(slot);
 800089c:	4630      	mov	r0, r6
 800089e:	f007 fb47 	bl	8007f30 <se2_save_trick>
 80008a2:	e64d      	b.n	8000540 <firewall_dispatch+0x194>
            break;
        }

        case 23:
            // fast wipe -- does system reset, no UX
            if(arg2 == 0xBeef) {
 80008a4:	9b01      	ldr	r3, [sp, #4]
 80008a6:	f64b 62ef 	movw	r2, #48879	; 0xbeef
 80008aa:	4293      	cmp	r3, r2
 80008ac:	d102      	bne.n	80008b4 <firewall_dispatch+0x508>
                // silent version, but does reset system
                fast_wipe();
 80008ae:	f001 fea5 	bl	80025fc <fast_wipe>
 80008b2:	e033      	b.n	800091c <firewall_dispatch+0x570>
            } else if(arg2 == 0xDead) {
 80008b4:	f64d 62ad 	movw	r2, #57005	; 0xdead
 80008b8:	4293      	cmp	r3, r2
 80008ba:	d12f      	bne.n	800091c <firewall_dispatch+0x570>
                // noisy, shows screen, halts
                mcu_key_clear(NULL);
 80008bc:	2000      	movs	r0, #0
 80008be:	f001 fddb 	bl	8002478 <mcu_key_clear>
                oled_show(screen_wiped);
 80008c2:	4831      	ldr	r0, [pc, #196]	; (8000988 <firewall_dispatch+0x5dc>)
 80008c4:	f000 fa96 	bl	8000df4 <oled_show>

                LOCKUP_FOREVER();
 80008c8:	bf30      	wfi
 80008ca:	e7fd      	b.n	80008c8 <firewall_dispatch+0x51c>
            rv = EPERM;
            break;

        case 24:
            // fast brick -- locks up w/ message
            if(arg2 == 0xDead) fast_brick();
 80008cc:	9a01      	ldr	r2, [sp, #4]
 80008ce:	f64d 63ad 	movw	r3, #57005	; 0xdead
 80008d2:	429a      	cmp	r2, r3
 80008d4:	d122      	bne.n	800091c <firewall_dispatch+0x570>
 80008d6:	f001 fe6d 	bl	80025b4 <fast_brick>
 80008da:	e01f      	b.n	800091c <firewall_dispatch+0x570>
            rv = EPERM;
            break;

        case 25: {
            // mk4: usage of mcu key slots
            REQUIRE_OUT(8);
 80008dc:	2300      	movs	r3, #0
 80008de:	4632      	mov	r2, r6
 80008e0:	2108      	movs	r1, #8
 80008e2:	4628      	mov	r0, r5
 80008e4:	f7ff fd40 	bl	8000368 <good_addr>
 80008e8:	4604      	mov	r4, r0
 80008ea:	b9c0      	cbnz	r0, 800091e <firewall_dispatch+0x572>

            int *avail = (int *)(buf_io+0);
            int *consumed = (int *)(buf_io+4);

            mcu_key_usage(avail, consumed);
 80008ec:	1d29      	adds	r1, r5, #4
 80008ee:	4628      	mov	r0, r5
 80008f0:	f001 fdec 	bl	80024cc <mcu_key_usage>
            break;
 80008f4:	e013      	b.n	800091e <firewall_dispatch+0x572>


        case -1:
            // System startup code. Cannot be reached by any code (that hopes to run
            // again) except our reset stub.
            if(incoming_lr <= BL_FLASH_BASE || incoming_lr >= (uint32_t)&firewall_starts) {
 80008f6:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
 80008fa:	d902      	bls.n	8000902 <firewall_dispatch+0x556>
 80008fc:	4b23      	ldr	r3, [pc, #140]	; (800098c <firewall_dispatch+0x5e0>)
 80008fe:	4299      	cmp	r1, r3
 8000900:	d302      	bcc.n	8000908 <firewall_dispatch+0x55c>
                fatal_error("LR");
 8000902:	4823      	ldr	r0, [pc, #140]	; (8000990 <firewall_dispatch+0x5e4>)
 8000904:	f000 f86a 	bl	80009dc <fatal_error>
            } else {
                system_startup();
 8000908:	f000 f8c2 	bl	8000a90 <system_startup>

        case 6:
            // Do we have a ATECC608a and all that implies?
            // NOTE: this number was unused in V1 bootroms, so return ENOENT
            #if FOR_608
                rv = 0;
 800090c:	2400      	movs	r4, #0
 800090e:	e006      	b.n	800091e <firewall_dispatch+0x572>
    // - use arg2 use when a simple number is needed; never a pointer!
    // - mpy may provide a pointer to flash if we give it a qstr or small value, and if
    //   we're reading only, that's fine.

    if(len_in > 1024) {     // arbitrary max, increase as needed
        rv = ERANGE;
 8000910:	2422      	movs	r4, #34	; 0x22
 8000912:	e004      	b.n	800091e <firewall_dispatch+0x572>
                    ae_setup();
                    rv = ae_get_counter((uint32_t *)buf_io, 0) ? EIO: 0;
                    break;

                default:
                    rv = ENOENT;
 8000914:	2402      	movs	r4, #2
 8000916:	e002      	b.n	800091e <firewall_dispatch+0x572>
                    if(buf_io[0] < 0x10 || buf_io[0] >= 0x40) {
                        // bad data
                        rv = ERANGE;
                    } if(check_is_downgrade(buf_io, NULL)) {
                        // already at a higher version?
                        rv = EAGAIN;
 8000918:	240b      	movs	r4, #11
 800091a:	e000      	b.n	800091e <firewall_dispatch+0x572>
                mcu_key_clear(NULL);
                oled_show(screen_wiped);

                LOCKUP_FOREVER();
            }
            rv = EPERM;
 800091c:	2401      	movs	r4, #1

fail:

    // Precaution: we don't want to leave ATECC508A authorized for any specific keys,
    // perhaps due to an error path we didn't see. Always reset the chip.
    ae_reset_chip();
 800091e:	f002 f831 	bl	8002984 <ae_reset_chip>

    // Unlikely it matters, but clear flash memory cache.
    __HAL_FLASH_DATA_CACHE_DISABLE();
 8000922:	4b1c      	ldr	r3, [pc, #112]	; (8000994 <firewall_dispatch+0x5e8>)
 8000924:	681a      	ldr	r2, [r3, #0]
 8000926:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800092a:	601a      	str	r2, [r3, #0]
    __HAL_FLASH_DATA_CACHE_RESET();
 800092c:	681a      	ldr	r2, [r3, #0]
 800092e:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8000932:	601a      	str	r2, [r3, #0]
 8000934:	681a      	ldr	r2, [r3, #0]
 8000936:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800093a:	601a      	str	r2, [r3, #0]
    __HAL_FLASH_DATA_CACHE_ENABLE();
 800093c:	681a      	ldr	r2, [r3, #0]
 800093e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000942:	601a      	str	r2, [r3, #0]

    // .. and instruction memory (flash cache too?)
    __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
 8000944:	681a      	ldr	r2, [r3, #0]
 8000946:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 800094a:	601a      	str	r2, [r3, #0]
    __HAL_FLASH_INSTRUCTION_CACHE_RESET();
 800094c:	681a      	ldr	r2, [r3, #0]
 800094e:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8000952:	601a      	str	r2, [r3, #0]
 8000954:	681a      	ldr	r2, [r3, #0]
 8000956:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 800095a:	601a      	str	r2, [r3, #0]
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 800095c:	681a      	ldr	r2, [r3, #0]
 800095e:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000962:	601a      	str	r2, [r3, #0]
    

    // authorize return from firewall into user's code
    __HAL_FIREWALL_PREARM_ENABLE();
 8000964:	f5a3 3382 	sub.w	r3, r3, #66560	; 0x10400

    return rv;
}
 8000968:	4620      	mov	r0, r4
    __HAL_FLASH_INSTRUCTION_CACHE_RESET();
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
    

    // authorize return from firewall into user's code
    __HAL_FIREWALL_PREARM_ENABLE();
 800096a:	6a1a      	ldr	r2, [r3, #32]
 800096c:	f042 0201 	orr.w	r2, r2, #1
 8000970:	621a      	str	r2, [r3, #32]
 8000972:	6a1b      	ldr	r3, [r3, #32]
 8000974:	f003 0301 	and.w	r3, r3, #1
 8000978:	930b      	str	r3, [sp, #44]	; 0x2c
 800097a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c

    return rv;
}
 800097c:	b01e      	add	sp, #120	; 0x78
 800097e:	bd70      	pop	{r4, r5, r6, pc}
 8000980:	0801e050 	.word	0x0801e050
 8000984:	0801e070 	.word	0x0801e070
 8000988:	0800dd2e 	.word	0x0800dd2e
 800098c:	08000300 	.word	0x08000300
 8000990:	0800d597 	.word	0x0800d597
 8000994:	40022000 	.word	0x40022000

08000998 <wipe_all_sram>:
//
    static inline void
memset4(uint32_t *dest, uint32_t value, uint32_t byte_len)
{
    for(; byte_len; byte_len-=4, dest++) {
        *dest = value;
 8000998:	480b      	ldr	r0, [pc, #44]	; (80009c8 <wipe_all_sram+0x30>)
// memset4()
//
    static inline void
memset4(uint32_t *dest, uint32_t value, uint32_t byte_len)
{
    for(; byte_len; byte_len-=4, dest++) {
 800099a:	490c      	ldr	r1, [pc, #48]	; (80009cc <wipe_all_sram+0x34>)

// wipe_all_sram()
//
    void
wipe_all_sram(void)
{
 800099c:	f04f 2320 	mov.w	r3, #536879104	; 0x20002000
        *dest = value;
 80009a0:	f843 0b04 	str.w	r0, [r3], #4
// memset4()
//
    static inline void
memset4(uint32_t *dest, uint32_t value, uint32_t byte_len)
{
    for(; byte_len; byte_len-=4, dest++) {
 80009a4:	428b      	cmp	r3, r1
 80009a6:	4a08      	ldr	r2, [pc, #32]	; (80009c8 <wipe_all_sram+0x30>)
 80009a8:	d1fa      	bne.n	80009a0 <wipe_all_sram+0x8>
 80009aa:	4909      	ldr	r1, [pc, #36]	; (80009d0 <wipe_all_sram+0x38>)
 80009ac:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
        *dest = value;
 80009b0:	f843 2b04 	str.w	r2, [r3], #4
// memset4()
//
    static inline void
memset4(uint32_t *dest, uint32_t value, uint32_t byte_len)
{
    for(; byte_len; byte_len-=4, dest++) {
 80009b4:	428b      	cmp	r3, r1
 80009b6:	d1fb      	bne.n	80009b0 <wipe_all_sram+0x18>
 80009b8:	4b06      	ldr	r3, [pc, #24]	; (80009d4 <wipe_all_sram+0x3c>)
 80009ba:	4907      	ldr	r1, [pc, #28]	; (80009d8 <wipe_all_sram+0x40>)
        *dest = value;
 80009bc:	f843 2b04 	str.w	r2, [r3], #4
// memset4()
//
    static inline void
memset4(uint32_t *dest, uint32_t value, uint32_t byte_len)
{
    for(; byte_len; byte_len-=4, dest++) {
 80009c0:	428b      	cmp	r3, r1
 80009c2:	d1fb      	bne.n	80009bc <wipe_all_sram+0x24>
    // wipe all of SRAM (except our own memory)
    const uint32_t s1start = SRAM1_BASE + BL_SRAM_SIZE + 0x400;
    memset4((void *)s1start, noise, SRAM1_BASE  + SRAM1_SIZE_MAX - s1start);
    memset4((void *)SRAM2_BASE, noise, SRAM2_SIZE);
    memset4((void *)SRAM3_BASE, noise, SRAM3_SIZE);
}
 80009c4:	4770      	bx	lr
 80009c6:	bf00      	nop
 80009c8:	deadbeef 	.word	0xdeadbeef
 80009cc:	20030000 	.word	0x20030000
 80009d0:	10010000 	.word	0x10010000
 80009d4:	20040000 	.word	0x20040000
 80009d8:	200a0000 	.word	0x200a0000

080009dc <fatal_error>:

// fatal_error(const char *msg)
//
    void __attribute__((noreturn))
fatal_error(const char *msgvoid)
{
 80009dc:	b508      	push	{r3, lr}
    oled_setup();
 80009de:	f000 f979 	bl	8000cd4 <oled_setup>
    oled_show(screen_fatal);
 80009e2:	4802      	ldr	r0, [pc, #8]	; (80009ec <fatal_error+0x10>)
 80009e4:	f000 fa06 	bl	8000df4 <oled_show>
    BREAKPOINT;
#endif

    // Maybe should do a reset after a delay, like with
    // the watchdog timer or something.
    LOCKUP_FOREVER();
 80009e8:	bf30      	wfi
 80009ea:	e7fd      	b.n	80009e8 <fatal_error+0xc>
 80009ec:	0800dcbd 	.word	0x0800dcbd

080009f0 <fatal_mitm>:

// fatal_mitm()
//
    void __attribute__((noreturn))
fatal_mitm(void)
{
 80009f0:	b508      	push	{r3, lr}
    oled_setup();
 80009f2:	f000 f96f 	bl	8000cd4 <oled_setup>
    oled_show(screen_mitm);
 80009f6:	4803      	ldr	r0, [pc, #12]	; (8000a04 <fatal_mitm+0x14>)
 80009f8:	f000 f9fc 	bl	8000df4 <oled_show>

#ifdef RELEASE
    wipe_all_sram();
 80009fc:	f7ff ffcc 	bl	8000998 <wipe_all_sram>
#endif

    LOCKUP_FOREVER();
 8000a00:	bf30      	wfi
 8000a02:	e7fd      	b.n	8000a00 <fatal_mitm+0x10>
 8000a04:	0800dfcb 	.word	0x0800dfcb

08000a08 <enter_dfu>:

// enter_dfu()
//
    void __attribute__((noreturn))
enter_dfu(void)
{
 8000a08:	b507      	push	{r0, r1, r2, lr}
    puts("enter_dfu()");
 8000a0a:	481d      	ldr	r0, [pc, #116]	; (8000a80 <enter_dfu+0x78>)
 8000a0c:	f004 f952 	bl	8004cb4 <puts>

    // clear the green light, if set
    ae_setup();
 8000a10:	f001 ffc6 	bl	80029a0 <ae_setup>
    ae_set_gpio(0);
 8000a14:	2000      	movs	r0, #0
 8000a16:	f002 fd1f 	bl	8003458 <ae_set_gpio>

    // Reset huge parts of the chip
    __HAL_RCC_APB1_FORCE_RESET();
 8000a1a:	4b1a      	ldr	r3, [pc, #104]	; (8000a84 <enter_dfu+0x7c>)
 8000a1c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    __HAL_RCC_APB1_RELEASE_RESET();
 8000a20:	2200      	movs	r2, #0
    // clear the green light, if set
    ae_setup();
    ae_set_gpio(0);

    // Reset huge parts of the chip
    __HAL_RCC_APB1_FORCE_RESET();
 8000a22:	6399      	str	r1, [r3, #56]	; 0x38
 8000a24:	63d9      	str	r1, [r3, #60]	; 0x3c
    __HAL_RCC_APB1_RELEASE_RESET();
 8000a26:	639a      	str	r2, [r3, #56]	; 0x38
 8000a28:	63da      	str	r2, [r3, #60]	; 0x3c

    __HAL_RCC_APB2_FORCE_RESET();
 8000a2a:	6419      	str	r1, [r3, #64]	; 0x40
    __HAL_RCC_APB2_RELEASE_RESET();
 8000a2c:	641a      	str	r2, [r3, #64]	; 0x40

    __HAL_RCC_AHB1_FORCE_RESET();
 8000a2e:	6299      	str	r1, [r3, #40]	; 0x28
    __HAL_RCC_AHB1_RELEASE_RESET();
 8000a30:	629a      	str	r2, [r3, #40]	; 0x28
    // But not this; it borks things.
    __HAL_RCC_AHB2_FORCE_RESET();
    __HAL_RCC_AHB2_RELEASE_RESET();
#endif

    __HAL_RCC_AHB3_FORCE_RESET();
 8000a32:	6319      	str	r1, [r3, #48]	; 0x30
    __HAL_RCC_AHB3_RELEASE_RESET();
 8000a34:	631a      	str	r2, [r3, #48]	; 0x30

    __HAL_FIREWALL_PREARM_ENABLE();
 8000a36:	f5a3 4374 	sub.w	r3, r3, #62464	; 0xf400
 8000a3a:	6a1a      	ldr	r2, [r3, #32]
 8000a3c:	f042 0201 	orr.w	r2, r2, #1
 8000a40:	621a      	str	r2, [r3, #32]
 8000a42:	6a1b      	ldr	r3, [r3, #32]
 8000a44:	f003 0301 	and.w	r3, r3, #1
 8000a48:	9301      	str	r3, [sp, #4]
 8000a4a:	9b01      	ldr	r3, [sp, #4]

    // Wipe all of memory SRAM, just in case 
    // there is some way to trick us into DFU
    // after sensitive content in place.
    wipe_all_sram();
 8000a4c:	f7ff ffa4 	bl	8000998 <wipe_all_sram>
// Write bag number (probably a string)
void flash_save_bag_number(const uint8_t new_number[32]);

// Are we operating in level2?
static inline bool flash_is_security_level2(void) {
    rng_delay();
 8000a50:	f001 fe71 	bl	8002736 <rng_delay>
    return ((FLASH->OPTR & FLASH_OPTR_RDP_Msk) == 0xCC);
 8000a54:	4b0c      	ldr	r3, [pc, #48]	; (8000a88 <enter_dfu+0x80>)
 8000a56:	6a1b      	ldr	r3, [r3, #32]

    if(flash_is_security_level2()) {
 8000a58:	b2db      	uxtb	r3, r3
 8000a5a:	2bcc      	cmp	r3, #204	; 0xcc
 8000a5c:	d101      	bne.n	8000a62 <enter_dfu+0x5a>
        // cannot do DFU in RDP=2, so just die. Helps to preserve screen
        LOCKUP_FOREVER();
 8000a5e:	bf30      	wfi
 8000a60:	e7fd      	b.n	8000a5e <enter_dfu+0x56>
    }

    // Reset clocks.
    HAL_RCC_DeInit();
 8000a62:	f007 fccd 	bl	8008400 <HAL_RCC_DeInit>

    // move system ROM into 0x0
    __HAL_SYSCFG_REMAPMEMORY_SYSTEMFLASH();
 8000a66:	4a09      	ldr	r2, [pc, #36]	; (8000a8c <enter_dfu+0x84>)
 8000a68:	6813      	ldr	r3, [r2, #0]
 8000a6a:	f023 0307 	bic.w	r3, r3, #7
 8000a6e:	f043 0301 	orr.w	r3, r3, #1
 8000a72:	6013      	str	r3, [r2, #0]

    // simulate a reset vector
    __ASM volatile ("movs r0, #0\n"
 8000a74:	2000      	movs	r0, #0
 8000a76:	6803      	ldr	r3, [r0, #0]
 8000a78:	f383 8808 	msr	MSP, r3
 8000a7c:	6843      	ldr	r3, [r0, #4]
 8000a7e:	4798      	blx	r3
 8000a80:	0800d59a 	.word	0x0800d59a
 8000a84:	40021000 	.word	0x40021000
 8000a88:	40022000 	.word	0x40022000
 8000a8c:	40010000 	.word	0x40010000

08000a90 <system_startup>:
//
// Called only on system boot.
//
    void
system_startup(void)
{
 8000a90:	b510      	push	{r4, lr}
    // configure critical stuff
    system_init0();
 8000a92:	f001 f9c3 	bl	8001e1c <system_init0>
    clocks_setup();
 8000a96:	f001 f9e3 	bl	8001e60 <clocks_setup>
    rng_setup();            // needs to be super early
 8000a9a:	f001 fe09 	bl	80026b0 <rng_setup>
    rng_delay();
 8000a9e:	f001 fe4a 	bl	8002736 <rng_delay>

#if RELEASE
    // security check: should we be in protected mode? Was there some UV-C bitrot perhaps?
    if(!check_all_ones(rom_secrets->bag_number, sizeof(rom_secrets->bag_number))
 8000aa2:	2120      	movs	r1, #32
 8000aa4:	483c      	ldr	r0, [pc, #240]	; (8000b98 <system_startup+0x108>)
 8000aa6:	f001 fdbf 	bl	8002628 <check_all_ones>
 8000aaa:	b948      	cbnz	r0, 8000ac0 <system_startup+0x30>
// Write bag number (probably a string)
void flash_save_bag_number(const uint8_t new_number[32]);

// Are we operating in level2?
static inline bool flash_is_security_level2(void) {
    rng_delay();
 8000aac:	f001 fe43 	bl	8002736 <rng_delay>
    return ((FLASH->OPTR & FLASH_OPTR_RDP_Msk) == 0xCC);
 8000ab0:	4b3a      	ldr	r3, [pc, #232]	; (8000b9c <system_startup+0x10c>)
 8000ab2:	6a1b      	ldr	r3, [r3, #32]
            && !flash_is_security_level2()
 8000ab4:	b2db      	uxtb	r3, r3
 8000ab6:	2bcc      	cmp	r3, #204	; 0xcc
 8000ab8:	d002      	beq.n	8000ac0 <system_startup+0x30>
    ) {
        // yikes. recovery: do lockdown... we should be/(thought we were) locked already
        flash_lockdown_hard(OB_RDP_LEVEL_2);
 8000aba:	20cc      	movs	r0, #204	; 0xcc
 8000abc:	f001 fc74 	bl	80023a8 <flash_lockdown_hard>
#else
# warning "Built for debug."
#endif

    // config pins
    gpio_setup();
 8000ac0:	f002 fef2 	bl	80038a8 <gpio_setup>

    // debug output and banner
    console_setup();
 8000ac4:	f004 f818 	bl	8004af8 <console_setup>

    puts2("\r\n\nMk4 Bootloader: ");
 8000ac8:	4835      	ldr	r0, [pc, #212]	; (8000ba0 <system_startup+0x110>)
 8000aca:	f004 f865 	bl	8004b98 <puts2>
    puts(version_string);
 8000ace:	4835      	ldr	r0, [pc, #212]	; (8000ba4 <system_startup+0x114>)
 8000ad0:	f004 f8f0 	bl	8004cb4 <puts>

    // lots of manual memory alloc here...
    uint8_t            *reboot_seed = &reboot_seed_base[0];  // 32 bytes

    // populate seed w/ some noise
    ASSERT(((uint32_t)reboot_seed) == 0x20001c00);
 8000ad4:	4834      	ldr	r0, [pc, #208]	; (8000ba8 <system_startup+0x118>)
 8000ad6:	4b35      	ldr	r3, [pc, #212]	; (8000bac <system_startup+0x11c>)
 8000ad8:	4298      	cmp	r0, r3
 8000ada:	d002      	beq.n	8000ae2 <system_startup+0x52>
 8000adc:	4834      	ldr	r0, [pc, #208]	; (8000bb0 <system_startup+0x120>)
 8000ade:	f7ff ff7d 	bl	80009dc <fatal_error>
    rng_buffer(reboot_seed, 32);
 8000ae2:	2120      	movs	r1, #32
 8000ae4:	f001 fe10 	bl	8002708 <rng_buffer>

    ASSERT((uint32_t)&shared_bootflags == RAM_BOOT_FLAGS_MK4);
 8000ae8:	4c32      	ldr	r4, [pc, #200]	; (8000bb4 <system_startup+0x124>)
 8000aea:	4b33      	ldr	r3, [pc, #204]	; (8000bb8 <system_startup+0x128>)
 8000aec:	429c      	cmp	r4, r3
 8000aee:	d1f5      	bne.n	8000adc <system_startup+0x4c>

    // clear
    shared_bootflags = 0;
 8000af0:	2300      	movs	r3, #0
 8000af2:	6023      	str	r3, [r4, #0]
// Write bag number (probably a string)
void flash_save_bag_number(const uint8_t new_number[32]);

// Are we operating in level2?
static inline bool flash_is_security_level2(void) {
    rng_delay();
 8000af4:	f001 fe1f 	bl	8002736 <rng_delay>
    return ((FLASH->OPTR & FLASH_OPTR_RDP_Msk) == 0xCC);
 8000af8:	4b28      	ldr	r3, [pc, #160]	; (8000b9c <system_startup+0x10c>)
 8000afa:	6a1b      	ldr	r3, [r3, #32]

    // this value can also be checked at runtime, but historical
    if(!flash_is_security_level2()) {
 8000afc:	b2db      	uxtb	r3, r3
 8000afe:	2bcc      	cmp	r3, #204	; 0xcc
#if RELEASE
        shared_bootflags |= RBF_FACTORY_MODE;
 8000b00:	bf1e      	ittt	ne
 8000b02:	6823      	ldrne	r3, [r4, #0]
 8000b04:	f043 0302 	orrne.w	r3, r3, #2
 8000b08:	6023      	strne	r3, [r4, #0]
#endif
    rng_delay();

    // Workaround to get into DFU from micropython
    // LATER: none of this is useful with RDP=2, but okay in the office.
    if(memcmp(dfu_flag->magic, REBOOT_TO_DFU, sizeof(dfu_flag->magic)) == 0) {
 8000b0a:	4c2c      	ldr	r4, [pc, #176]	; (8000bbc <system_startup+0x12c>)
    puts2("\r\n\nMk4 Bootloader: ");
    puts(version_string);

    // setup some limited shared data space between mpy and ourselves
    reboot_seed_setup();
    rng_delay();
 8000b0c:	f001 fe13 	bl	8002736 <rng_delay>

#ifndef RELEASE
    sha256_selftest();
    aes_selftest();
#endif
    rng_delay();
 8000b10:	f001 fe11 	bl	8002736 <rng_delay>

    // Workaround to get into DFU from micropython
    // LATER: none of this is useful with RDP=2, but okay in the office.
    if(memcmp(dfu_flag->magic, REBOOT_TO_DFU, sizeof(dfu_flag->magic)) == 0) {
 8000b14:	2208      	movs	r2, #8
 8000b16:	492a      	ldr	r1, [pc, #168]	; (8000bc0 <system_startup+0x130>)
 8000b18:	4620      	mov	r0, r4
 8000b1a:	f00c fc9f 	bl	800d45c <memcmp>
 8000b1e:	b938      	cbnz	r0, 8000b30 <system_startup+0xa0>
        dfu_flag->magic[0] = 0;
 8000b20:	7020      	strb	r0, [r4, #0]

        // still see a flash here, but that's proof it works.
        oled_setup();
 8000b22:	f000 f8d7 	bl	8000cd4 <oled_setup>
        oled_show(dfu_flag->screen);
 8000b26:	68a0      	ldr	r0, [r4, #8]
 8000b28:	f000 f964 	bl	8000df4 <oled_show>

        enter_dfu();
 8000b2c:	f7ff ff6c 	bl	8000a08 <enter_dfu>
        // NOT-REACHED
    }
    rng_delay();
 8000b30:	f001 fe01 	bl	8002736 <rng_delay>

    // clear and setup OLED display
    oled_setup();
 8000b34:	f000 f8ce 	bl	8000cd4 <oled_setup>
    oled_show_progress(screen_verify, 0);
 8000b38:	2100      	movs	r1, #0
 8000b3a:	4822      	ldr	r0, [pc, #136]	; (8000bc4 <system_startup+0x134>)
 8000b3c:	f000 f99c 	bl	8000e78 <oled_show_progress>

    // wipe all of SRAM (except our own memory, which was already wiped)
    wipe_all_sram();
 8000b40:	f7ff ff2a 	bl	8000998 <wipe_all_sram>

    puts2("SE1 setup: ");
 8000b44:	4820      	ldr	r0, [pc, #128]	; (8000bc8 <system_startup+0x138>)
 8000b46:	f004 f827 	bl	8004b98 <puts2>

    // secure elements setup
    ae_setup();
 8000b4a:	f001 ff29 	bl	80029a0 <ae_setup>
    ae_set_gpio(0);         // turn light red
 8000b4e:	2000      	movs	r0, #0
 8000b50:	f002 fc82 	bl	8003458 <ae_set_gpio>

    puts("done");
 8000b54:	481d      	ldr	r0, [pc, #116]	; (8000bcc <system_startup+0x13c>)
 8000b56:	f004 f8ad 	bl	8004cb4 <puts>

    puts2("SE2 setup: ");
 8000b5a:	481d      	ldr	r0, [pc, #116]	; (8000bd0 <system_startup+0x140>)
 8000b5c:	f004 f81c 	bl	8004b98 <puts2>
    se2_setup();
 8000b60:	f007 f828 	bl	8007bb4 <se2_setup>
    se2_probe();
 8000b64:	f006 fdb4 	bl	80076d0 <se2_probe>
    puts("done");
 8000b68:	4818      	ldr	r0, [pc, #96]	; (8000bcc <system_startup+0x13c>)
 8000b6a:	f004 f8a3 	bl	8004cb4 <puts>

    // protect our flash, and/or check it's protected 
    // - and pick pairing secret if we don't already have one
    // - may also do one-time setup of the secure elements
    // - note: ae_setup must already be called, since it can talk to that
    flash_setup();
 8000b6e:	f001 fb7b 	bl	8002268 <flash_setup>
    //puts("Flash: setup done");

    //puts("PSRAM setup");
    psram_setup();
 8000b72:	f004 f8d5 	bl	8004d20 <psram_setup>

    // Check firmware is legit; else enter DFU
    // - may die due to downgrade attack or badly signed image
    puts2("Verify: ");
 8000b76:	4817      	ldr	r0, [pc, #92]	; (8000bd4 <system_startup+0x144>)
 8000b78:	f004 f80e 	bl	8004b98 <puts2>
    bool main_ok = verify_firmware();
 8000b7c:	f001 f8ea 	bl	8001d54 <verify_firmware>

    if(main_ok) {
 8000b80:	b120      	cbz	r0, 8000b8c <system_startup+0xfc>
        // load a blank screen, so that if the firmware crashes, we are showing
        // something reasonable and not misleading.
        oled_show(screen_blankish);
 8000b82:	4815      	ldr	r0, [pc, #84]	; (8000bd8 <system_startup+0x148>)
    // .. will reboot if it works; only helps w/ reset pulses, not power downs.
    psram_recover_firmware();

    // use SDCard to recover
    while(1) sdcard_recovery();
}
 8000b84:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    bool main_ok = verify_firmware();

    if(main_ok) {
        // load a blank screen, so that if the firmware crashes, we are showing
        // something reasonable and not misleading.
        oled_show(screen_blankish);
 8000b88:	f000 b934 	b.w	8000df4 <oled_show>
    }


    // try to recover, from an image hanging around in PSRAM
    // .. will reboot if it works; only helps w/ reset pulses, not power downs.
    psram_recover_firmware();
 8000b8c:	f004 fa18 	bl	8004fc0 <psram_recover_firmware>

    // use SDCard to recover
    while(1) sdcard_recovery();
 8000b90:	f004 fba4 	bl	80052dc <sdcard_recovery>
 8000b94:	e7fc      	b.n	8000b90 <system_startup+0x100>
 8000b96:	bf00      	nop
 8000b98:	0801e050 	.word	0x0801e050
 8000b9c:	40022000 	.word	0x40022000
 8000ba0:	0800d5a6 	.word	0x0800d5a6
 8000ba4:	0800e478 	.word	0x0800e478
 8000ba8:	20001c00 	.word	0x20001c00
 8000bac:	20001c00 	.word	0x20001c00
 8000bb0:	0800d550 	.word	0x0800d550
 8000bb4:	20001c20 	.word	0x20001c20
 8000bb8:	20001c20 	.word	0x20001c20
 8000bbc:	20008000 	.word	0x20008000
 8000bc0:	0800d58e 	.word	0x0800d58e
 8000bc4:	0800d622 	.word	0x0800d622
 8000bc8:	0800d5ba 	.word	0x0800d5ba
 8000bcc:	0800d5c6 	.word	0x0800d5c6
 8000bd0:	0800d5cb 	.word	0x0800d5cb
 8000bd4:	0800d5d7 	.word	0x0800d5d7
 8000bd8:	0800dd01 	.word	0x0800dd01

08000bdc <write_bytes>:
    static inline void
write_bytes(int len, const uint8_t *buf)
{
#ifndef DISABLE_OLED
    // send via SPI(1)
    HAL_SPI_Transmit(&spi_port, (uint8_t *)buf, len, HAL_MAX_DELAY);
 8000bdc:	b282      	uxth	r2, r0
 8000bde:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8000be2:	4801      	ldr	r0, [pc, #4]	; (8000be8 <write_bytes+0xc>)
 8000be4:	f000 bc1a 	b.w	800141c <HAL_SPI_Transmit>
 8000be8:	20000168 	.word	0x20000168

08000bec <oled_write_cmd>:

// oled_write_cmd()
//
    void
oled_write_cmd(uint8_t cmd)
{
 8000bec:	b513      	push	{r0, r1, r4, lr}
 8000bee:	ac02      	add	r4, sp, #8
    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000bf0:	2201      	movs	r2, #1

// oled_write_cmd()
//
    void
oled_write_cmd(uint8_t cmd)
{
 8000bf2:	f804 0d01 	strb.w	r0, [r4, #-1]!
    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000bf6:	2110      	movs	r1, #16
 8000bf8:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000bfc:	f000 fb5c 	bl	80012b8 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOA, DC_PIN, 0);
 8000c00:	2200      	movs	r2, #0
 8000c02:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000c06:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000c0a:	f000 fb55 	bl	80012b8 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOA, CS_PIN, 0);
 8000c0e:	2200      	movs	r2, #0
 8000c10:	2110      	movs	r1, #16
 8000c12:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000c16:	f000 fb4f 	bl	80012b8 <HAL_GPIO_WritePin>

    write_bytes(1, &cmd);
 8000c1a:	4621      	mov	r1, r4
 8000c1c:	2001      	movs	r0, #1
 8000c1e:	f7ff ffdd 	bl	8000bdc <write_bytes>

    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000c22:	2201      	movs	r2, #1
 8000c24:	2110      	movs	r1, #16
 8000c26:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000c2a:	f000 fb45 	bl	80012b8 <HAL_GPIO_WritePin>
}
 8000c2e:	b002      	add	sp, #8
 8000c30:	bd10      	pop	{r4, pc}

08000c32 <oled_write_cmd_sequence>:

// oled_write_cmd_sequence()
//
    void
oled_write_cmd_sequence(int len, const uint8_t *cmds)
{
 8000c32:	b570      	push	{r4, r5, r6, lr}
 8000c34:	4606      	mov	r6, r0
 8000c36:	460d      	mov	r5, r1
    for(int i=0; i<len; i++) {
 8000c38:	460c      	mov	r4, r1
 8000c3a:	1b63      	subs	r3, r4, r5
 8000c3c:	429e      	cmp	r6, r3
 8000c3e:	dd04      	ble.n	8000c4a <oled_write_cmd_sequence+0x18>
        oled_write_cmd(cmds[i]);
 8000c40:	f814 0b01 	ldrb.w	r0, [r4], #1
 8000c44:	f7ff ffd2 	bl	8000bec <oled_write_cmd>
 8000c48:	e7f7      	b.n	8000c3a <oled_write_cmd_sequence+0x8>
    }
}
 8000c4a:	bd70      	pop	{r4, r5, r6, pc}

08000c4c <oled_write_data>:

// oled_write_data()
//
    void
oled_write_data(int len, const uint8_t *pixels)
{
 8000c4c:	b538      	push	{r3, r4, r5, lr}
    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000c4e:	2201      	movs	r2, #1

// oled_write_data()
//
    void
oled_write_data(int len, const uint8_t *pixels)
{
 8000c50:	4604      	mov	r4, r0
 8000c52:	460d      	mov	r5, r1
    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000c54:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000c58:	2110      	movs	r1, #16
 8000c5a:	f000 fb2d 	bl	80012b8 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOA, DC_PIN, 1);
 8000c5e:	2201      	movs	r2, #1
 8000c60:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000c64:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000c68:	f000 fb26 	bl	80012b8 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOA, CS_PIN, 0);
 8000c6c:	2200      	movs	r2, #0
 8000c6e:	2110      	movs	r1, #16
 8000c70:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000c74:	f000 fb20 	bl	80012b8 <HAL_GPIO_WritePin>

    write_bytes(len, pixels);
 8000c78:	4629      	mov	r1, r5
 8000c7a:	4620      	mov	r0, r4
 8000c7c:	f7ff ffae 	bl	8000bdc <write_bytes>

    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000c80:	2201      	movs	r2, #1
 8000c82:	2110      	movs	r1, #16
 8000c84:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
}
 8000c88:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    HAL_GPIO_WritePin(GPIOA, DC_PIN, 1);
    HAL_GPIO_WritePin(GPIOA, CS_PIN, 0);

    write_bytes(len, pixels);

    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000c8c:	f000 bb14 	b.w	80012b8 <HAL_GPIO_WritePin>

08000c90 <oled_spi_setup>:
//
// Just setup SPI, do not reset display, etc.
//
    void
oled_spi_setup(void)
{
 8000c90:	b538      	push	{r3, r4, r5, lr}
#ifndef DISABLE_OLED
    // might already be setup
    if(spi_port.Instance == SPI1) return;
 8000c92:	4c0e      	ldr	r4, [pc, #56]	; (8000ccc <oled_spi_setup+0x3c>)
 8000c94:	4d0e      	ldr	r5, [pc, #56]	; (8000cd0 <oled_spi_setup+0x40>)
 8000c96:	6823      	ldr	r3, [r4, #0]
 8000c98:	42ab      	cmp	r3, r5
 8000c9a:	d015      	beq.n	8000cc8 <oled_spi_setup+0x38>

    memset(&spi_port, 0, sizeof(spi_port));
 8000c9c:	4620      	mov	r0, r4
 8000c9e:	2264      	movs	r2, #100	; 0x64
 8000ca0:	2100      	movs	r1, #0
 8000ca2:	f00c fc10 	bl	800d4c6 <memset>

    spi_port.Instance = SPI1;

    // see SPI_InitTypeDef
    spi_port.Init.Mode = SPI_MODE_MASTER;
 8000ca6:	f44f 7382 	mov.w	r3, #260	; 0x104
 8000caa:	6063      	str	r3, [r4, #4]
    spi_port.Init.Direction = SPI_DIRECTION_2LINES;
    spi_port.Init.DataSize = SPI_DATASIZE_8BIT;
 8000cac:	f44f 63e0 	mov.w	r3, #1792	; 0x700
 8000cb0:	60e3      	str	r3, [r4, #12]
    spi_port.Init.CLKPolarity = SPI_POLARITY_LOW;
    spi_port.Init.CLKPhase = SPI_PHASE_1EDGE;
    spi_port.Init.NSS = SPI_NSS_SOFT;
 8000cb2:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000cb6:	61a3      	str	r3, [r4, #24]
    spi_port.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;    // conservative
 8000cb8:	2318      	movs	r3, #24
    // might already be setup
    if(spi_port.Instance == SPI1) return;

    memset(&spi_port, 0, sizeof(spi_port));

    spi_port.Instance = SPI1;
 8000cba:	6025      	str	r5, [r4, #0]
    spi_port.Init.Direction = SPI_DIRECTION_2LINES;
    spi_port.Init.DataSize = SPI_DATASIZE_8BIT;
    spi_port.Init.CLKPolarity = SPI_POLARITY_LOW;
    spi_port.Init.CLKPhase = SPI_PHASE_1EDGE;
    spi_port.Init.NSS = SPI_NSS_SOFT;
    spi_port.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;    // conservative
 8000cbc:	61e3      	str	r3, [r4, #28]
    spi_port.Init.FirstBit = SPI_FIRSTBIT_MSB;
    spi_port.Init.TIMode = SPI_TIMODE_DISABLED;
    spi_port.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;

    HAL_SPI_Init(&spi_port);
 8000cbe:	4620      	mov	r0, r4
#endif
}
 8000cc0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    spi_port.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;    // conservative
    spi_port.Init.FirstBit = SPI_FIRSTBIT_MSB;
    spi_port.Init.TIMode = SPI_TIMODE_DISABLED;
    spi_port.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;

    HAL_SPI_Init(&spi_port);
 8000cc4:	f000 bb50 	b.w	8001368 <HAL_SPI_Init>
 8000cc8:	bd38      	pop	{r3, r4, r5, pc}
 8000cca:	bf00      	nop
 8000ccc:	20000168 	.word	0x20000168
 8000cd0:	40013000 	.word	0x40013000

08000cd4 <oled_setup>:
//
// Ok to call this lots.
//
    void
oled_setup(void)
{
 8000cd4:	b530      	push	{r4, r5, lr}
    puts("oled disabled");return;     // disable so I can use MCO
#endif

    static uint32_t inited;

    if(inited == 0x238a572F) {
 8000cd6:	4b2c      	ldr	r3, [pc, #176]	; (8000d88 <oled_setup+0xb4>)
 8000cd8:	4a2c      	ldr	r2, [pc, #176]	; (8000d8c <oled_setup+0xb8>)
 8000cda:	6819      	ldr	r1, [r3, #0]
 8000cdc:	4291      	cmp	r1, r2
//
// Ok to call this lots.
//
    void
oled_setup(void)
{
 8000cde:	b089      	sub	sp, #36	; 0x24
    puts("oled disabled");return;     // disable so I can use MCO
#endif

    static uint32_t inited;

    if(inited == 0x238a572F) {
 8000ce0:	d050      	beq.n	8000d84 <oled_setup+0xb0>
        return;
    }
    inited = 0x238a572F;
 8000ce2:	601a      	str	r2, [r3, #0]

    // enable some internal clocks
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000ce4:	4b2a      	ldr	r3, [pc, #168]	; (8000d90 <oled_setup+0xbc>)
    __HAL_RCC_SPI1_CLK_ENABLE();

    // simple pins
    GPIO_InitTypeDef setup = {
 8000ce6:	4d2b      	ldr	r5, [pc, #172]	; (8000d94 <oled_setup+0xc0>)
        return;
    }
    inited = 0x238a572F;

    // enable some internal clocks
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000ce8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000cea:	f042 0201 	orr.w	r2, r2, #1
 8000cee:	64da      	str	r2, [r3, #76]	; 0x4c
 8000cf0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000cf2:	f002 0201 	and.w	r2, r2, #1
 8000cf6:	9201      	str	r2, [sp, #4]
 8000cf8:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_SPI1_CLK_ENABLE();
 8000cfa:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8000cfc:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8000d00:	661a      	str	r2, [r3, #96]	; 0x60
 8000d02:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8000d04:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8000d08:	9302      	str	r3, [sp, #8]
 8000d0a:	9b02      	ldr	r3, [sp, #8]

    // simple pins
    GPIO_InitTypeDef setup = {
 8000d0c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000d0e:	ac03      	add	r4, sp, #12
 8000d10:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000d12:	682b      	ldr	r3, [r5, #0]
 8000d14:	6023      	str	r3, [r4, #0]
        .Mode = GPIO_MODE_OUTPUT_PP,
        .Pull = GPIO_NOPULL,
        .Speed = GPIO_SPEED_FREQ_MEDIUM,
        .Alternate = 0,
    };
    HAL_GPIO_Init(GPIOA, &setup);
 8000d16:	a903      	add	r1, sp, #12
 8000d18:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000d1c:	f000 f950 	bl	8000fc0 <HAL_GPIO_Init>

    // starting values
    HAL_GPIO_WritePin(GPIOA, RESET_PIN | CS_PIN | DC_PIN, 1);
 8000d20:	2201      	movs	r2, #1
 8000d22:	f44f 71a8 	mov.w	r1, #336	; 0x150
 8000d26:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000d2a:	f000 fac5 	bl	80012b8 <HAL_GPIO_WritePin>

    // SPI pins
    setup.Pin = SPI_SCK | SPI_MOSI;
 8000d2e:	23a0      	movs	r3, #160	; 0xa0
 8000d30:	9303      	str	r3, [sp, #12]
    setup.Mode = GPIO_MODE_AF_PP;
 8000d32:	2302      	movs	r3, #2
 8000d34:	9304      	str	r3, [sp, #16]
    setup.Alternate = GPIO_AF5_SPI1;
    HAL_GPIO_Init(GPIOA, &setup);
 8000d36:	a903      	add	r1, sp, #12
    HAL_GPIO_WritePin(GPIOA, RESET_PIN | CS_PIN | DC_PIN, 1);

    // SPI pins
    setup.Pin = SPI_SCK | SPI_MOSI;
    setup.Mode = GPIO_MODE_AF_PP;
    setup.Alternate = GPIO_AF5_SPI1;
 8000d38:	2305      	movs	r3, #5
    HAL_GPIO_Init(GPIOA, &setup);
 8000d3a:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    HAL_GPIO_WritePin(GPIOA, RESET_PIN | CS_PIN | DC_PIN, 1);

    // SPI pins
    setup.Pin = SPI_SCK | SPI_MOSI;
    setup.Mode = GPIO_MODE_AF_PP;
    setup.Alternate = GPIO_AF5_SPI1;
 8000d3e:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &setup);
 8000d40:	f000 f93e 	bl	8000fc0 <HAL_GPIO_Init>

    // lock the RESET pin so that St's DFU code doesn't clear screen
    // it might be trying to use it a MISO signal for SPI loading
    HAL_GPIO_LockPin(GPIOA, RESET_PIN | CS_PIN | DC_PIN);
 8000d44:	f44f 71a8 	mov.w	r1, #336	; 0x150
 8000d48:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000d4c:	f000 fabd 	bl	80012ca <HAL_GPIO_LockPin>

    // 10ms low-going pulse on reset pin
    delay_ms(1);
 8000d50:	2001      	movs	r0, #1
 8000d52:	f002 fd99 	bl	8003888 <delay_ms>
    HAL_GPIO_WritePin(GPIOA, RESET_PIN, 0);
 8000d56:	2200      	movs	r2, #0
 8000d58:	2140      	movs	r1, #64	; 0x40
 8000d5a:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000d5e:	f000 faab 	bl	80012b8 <HAL_GPIO_WritePin>
    delay_ms(10);
 8000d62:	200a      	movs	r0, #10
 8000d64:	f002 fd90 	bl	8003888 <delay_ms>
    HAL_GPIO_WritePin(GPIOA, RESET_PIN, 1);
 8000d68:	2201      	movs	r2, #1
 8000d6a:	2140      	movs	r1, #64	; 0x40
 8000d6c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000d70:	f000 faa2 	bl	80012b8 <HAL_GPIO_WritePin>

    oled_spi_setup();
 8000d74:	f7ff ff8c 	bl	8000c90 <oled_spi_setup>
    // this code:
    //      '0x37c', '0x1700', '0x603'
    //SPI1->CR1 = 0x354;

    // write a sequence to reset things
    oled_write_cmd_sequence(sizeof(reset_commands), reset_commands);
 8000d78:	4907      	ldr	r1, [pc, #28]	; (8000d98 <oled_setup+0xc4>)
 8000d7a:	2019      	movs	r0, #25
 8000d7c:	f7ff ff59 	bl	8000c32 <oled_write_cmd_sequence>

    rng_delay();
 8000d80:	f001 fcd9 	bl	8002736 <rng_delay>
}
 8000d84:	b009      	add	sp, #36	; 0x24
 8000d86:	bd30      	pop	{r4, r5, pc}
 8000d88:	20000164 	.word	0x20000164
 8000d8c:	238a572f 	.word	0x238a572f
 8000d90:	40021000 	.word	0x40021000
 8000d94:	0800d5e0 	.word	0x0800d5e0
 8000d98:	0800d609 	.word	0x0800d609

08000d9c <oled_show_raw>:
//
// No decompression.
//
    void
oled_show_raw(uint32_t len, const uint8_t *pixels)
{
 8000d9c:	b538      	push	{r3, r4, r5, lr}
 8000d9e:	4604      	mov	r4, r0
 8000da0:	460d      	mov	r5, r1
    oled_setup();
 8000da2:	f7ff ff97 	bl	8000cd4 <oled_setup>

    oled_write_cmd_sequence(sizeof(before_show), before_show);
 8000da6:	4912      	ldr	r1, [pc, #72]	; (8000df0 <oled_show_raw+0x54>)
 8000da8:	2006      	movs	r0, #6
 8000daa:	f7ff ff42 	bl	8000c32 <oled_write_cmd_sequence>

    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000dae:	2201      	movs	r2, #1
 8000db0:	2110      	movs	r1, #16
 8000db2:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000db6:	f000 fa7f 	bl	80012b8 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOA, DC_PIN, 1);
 8000dba:	2201      	movs	r2, #1
 8000dbc:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000dc0:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000dc4:	f000 fa78 	bl	80012b8 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOA, CS_PIN, 0);
 8000dc8:	2200      	movs	r2, #0
 8000dca:	2110      	movs	r1, #16
 8000dcc:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000dd0:	f000 fa72 	bl	80012b8 <HAL_GPIO_WritePin>

    write_bytes(len, pixels);
 8000dd4:	4629      	mov	r1, r5
 8000dd6:	4620      	mov	r0, r4
 8000dd8:	f7ff ff00 	bl	8000bdc <write_bytes>

    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000ddc:	2201      	movs	r2, #1
 8000dde:	2110      	movs	r1, #16
 8000de0:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000de4:	f000 fa68 	bl	80012b8 <HAL_GPIO_WritePin>
    rng_delay();
}
 8000de8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    HAL_GPIO_WritePin(GPIOA, CS_PIN, 0);

    write_bytes(len, pixels);

    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
    rng_delay();
 8000dec:	f001 bca3 	b.w	8002736 <rng_delay>
 8000df0:	0800d5f4 	.word	0x0800d5f4

08000df4 <oled_show>:
//
// Perform simple RLE decompression.
//
    void
oled_show(const uint8_t *pixels)
{
 8000df4:	b530      	push	{r4, r5, lr}
 8000df6:	b0a1      	sub	sp, #132	; 0x84
 8000df8:	4604      	mov	r4, r0
    oled_setup();
 8000dfa:	f7ff ff6b 	bl	8000cd4 <oled_setup>

    oled_write_cmd_sequence(sizeof(before_show), before_show);
 8000dfe:	491d      	ldr	r1, [pc, #116]	; (8000e74 <oled_show+0x80>)
 8000e00:	2006      	movs	r0, #6
 8000e02:	f7ff ff16 	bl	8000c32 <oled_write_cmd_sequence>

    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000e06:	2201      	movs	r2, #1
 8000e08:	2110      	movs	r1, #16
 8000e0a:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000e0e:	f000 fa53 	bl	80012b8 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOA, DC_PIN, 1);
 8000e12:	2201      	movs	r2, #1
 8000e14:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000e18:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000e1c:	f000 fa4c 	bl	80012b8 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOA, CS_PIN, 0);
 8000e20:	2200      	movs	r2, #0
 8000e22:	2110      	movs	r1, #16
 8000e24:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000e28:	f000 fa46 	bl	80012b8 <HAL_GPIO_WritePin>
    uint8_t         buf[127];
    const uint8_t *p = pixels;

    // NOTE: must also update code in oled_show_progress, which dups this heavily.
    while(1) {
        uint8_t hdr = *(p++);
 8000e2c:	7823      	ldrb	r3, [r4, #0]
        if(!hdr) break;
 8000e2e:	b1b3      	cbz	r3, 8000e5e <oled_show+0x6a>

        uint8_t len = hdr & 0x7f;
 8000e30:	f003 057f 	and.w	r5, r3, #127	; 0x7f
        if(hdr & 0x80) {
 8000e34:	061b      	lsls	r3, r3, #24
 8000e36:	d507      	bpl.n	8000e48 <oled_show+0x54>
    uint8_t         buf[127];
    const uint8_t *p = pixels;

    // NOTE: must also update code in oled_show_progress, which dups this heavily.
    while(1) {
        uint8_t hdr = *(p++);
 8000e38:	3401      	adds	r4, #1
        if(!hdr) break;

        uint8_t len = hdr & 0x7f;
        if(hdr & 0x80) {
            // random bytes follow
            memcpy(buf, p, len);
 8000e3a:	4621      	mov	r1, r4
 8000e3c:	462a      	mov	r2, r5
 8000e3e:	4668      	mov	r0, sp
 8000e40:	f00c fb1b 	bl	800d47a <memcpy>
            p += len;
 8000e44:	442c      	add	r4, r5
 8000e46:	e005      	b.n	8000e54 <oled_show+0x60>
        } else {
            // repeat same byte
            memset(buf, *p, len);
 8000e48:	7861      	ldrb	r1, [r4, #1]
 8000e4a:	462a      	mov	r2, r5
 8000e4c:	4668      	mov	r0, sp
 8000e4e:	f00c fb3a 	bl	800d4c6 <memset>
            p++;
 8000e52:	3402      	adds	r4, #2
        }

        write_bytes(len, buf);
 8000e54:	4669      	mov	r1, sp
 8000e56:	4628      	mov	r0, r5
 8000e58:	f7ff fec0 	bl	8000bdc <write_bytes>
    }
 8000e5c:	e7e6      	b.n	8000e2c <oled_show+0x38>

    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000e5e:	2201      	movs	r2, #1
 8000e60:	2110      	movs	r1, #16
 8000e62:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000e66:	f000 fa27 	bl	80012b8 <HAL_GPIO_WritePin>
    rng_delay();
 8000e6a:	f001 fc64 	bl	8002736 <rng_delay>
}
 8000e6e:	b021      	add	sp, #132	; 0x84
 8000e70:	bd30      	pop	{r4, r5, pc}
 8000e72:	bf00      	nop
 8000e74:	0800d5f4 	.word	0x0800d5f4

08000e78 <oled_show_progress>:
//
// Perform simple RLE decompression, and add a bar on final screen line.
//
    void
oled_show_progress(const uint8_t *pixels, int progress)
{
 8000e78:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000e7c:	b0a0      	sub	sp, #128	; 0x80
 8000e7e:	460d      	mov	r5, r1
 8000e80:	4607      	mov	r7, r0
    oled_setup();
 8000e82:	f7ff ff27 	bl	8000cd4 <oled_setup>

    oled_write_cmd_sequence(sizeof(before_show), before_show);
 8000e86:	493c      	ldr	r1, [pc, #240]	; (8000f78 <oled_show_progress+0x100>)
 8000e88:	2006      	movs	r0, #6
 8000e8a:	f7ff fed2 	bl	8000c32 <oled_write_cmd_sequence>

    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000e8e:	2201      	movs	r2, #1
 8000e90:	2110      	movs	r1, #16
 8000e92:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000e96:	f000 fa0f 	bl	80012b8 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOA, DC_PIN, 1);
 8000e9a:	2201      	movs	r2, #1
 8000e9c:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000ea0:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000ea4:	f000 fa08 	bl	80012b8 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOA, CS_PIN, 0);
 8000ea8:	2110      	movs	r1, #16
 8000eaa:	2200      	movs	r2, #0
 8000eac:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000eb0:	f000 fa02 	bl	80012b8 <HAL_GPIO_WritePin>

    uint8_t         buf[127];
    const uint8_t *p = pixels;

    const uint16_t p_start = 896;
    uint32_t p_count = 1280 * progress / 1000;
 8000eb4:	f44f 61a0 	mov.w	r1, #1280	; 0x500
 8000eb8:	4369      	muls	r1, r5
 8000eba:	2600      	movs	r6, #0
 8000ebc:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8000ec0:	fb91 f5f5 	sdiv	r5, r1, r5
 8000ec4:	2d80      	cmp	r5, #128	; 0x80
 8000ec6:	bf28      	it	cs
 8000ec8:	2580      	movcs	r5, #128	; 0x80
 8000eca:	46b0      	mov	r8, r6

    bool last_line = false;

    uint16_t offset = 0;
    while(1) {
        uint8_t hdr = *(p++);
 8000ecc:	783b      	ldrb	r3, [r7, #0]
        if(hdr == 0) break;
 8000ece:	b3ab      	cbz	r3, 8000f3c <oled_show_progress+0xc4>

        uint8_t len = hdr & 0x7f;
 8000ed0:	f003 047f 	and.w	r4, r3, #127	; 0x7f
        if(hdr & 0x80) {
 8000ed4:	061b      	lsls	r3, r3, #24
 8000ed6:	d507      	bpl.n	8000ee8 <oled_show_progress+0x70>

    bool last_line = false;

    uint16_t offset = 0;
    while(1) {
        uint8_t hdr = *(p++);
 8000ed8:	3701      	adds	r7, #1
        if(hdr == 0) break;

        uint8_t len = hdr & 0x7f;
        if(hdr & 0x80) {
            // random bytes follow
            memcpy(buf, p, len);
 8000eda:	4639      	mov	r1, r7
 8000edc:	4622      	mov	r2, r4
 8000ede:	4668      	mov	r0, sp
 8000ee0:	f00c facb 	bl	800d47a <memcpy>
            p += len;
 8000ee4:	4427      	add	r7, r4
 8000ee6:	e005      	b.n	8000ef4 <oled_show_progress+0x7c>
        } else {
            // repeat same byte
            memset(buf, *p, len);
 8000ee8:	7879      	ldrb	r1, [r7, #1]
 8000eea:	4622      	mov	r2, r4
 8000eec:	4668      	mov	r0, sp
 8000eee:	f00c faea 	bl	800d4c6 <memset>
            p++;
 8000ef2:	3702      	adds	r7, #2
        }

        if(!last_line && (offset+len) >= p_start) {
 8000ef4:	f1b8 0f00 	cmp.w	r8, #0
 8000ef8:	d12b      	bne.n	8000f52 <oled_show_progress+0xda>
 8000efa:	1933      	adds	r3, r6, r4
 8000efc:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
 8000f00:	db15      	blt.n	8000f2e <oled_show_progress+0xb6>
            last_line = true;

            // adjust so we're aligned w/ last line
            int h = p_start - offset;
            if(h) {
 8000f02:	f5d6 7860 	rsbs	r8, r6, #896	; 0x380
 8000f06:	d024      	beq.n	8000f52 <oled_show_progress+0xda>
                write_bytes(h, buf);
 8000f08:	4669      	mov	r1, sp
 8000f0a:	4640      	mov	r0, r8
                memmove(buf, buf+h, len-h);
 8000f0c:	ebc8 0404 	rsb	r4, r8, r4
            last_line = true;

            // adjust so we're aligned w/ last line
            int h = p_start - offset;
            if(h) {
                write_bytes(h, buf);
 8000f10:	f7ff fe64 	bl	8000bdc <write_bytes>
                memmove(buf, buf+h, len-h);
 8000f14:	4622      	mov	r2, r4
 8000f16:	eb0d 0108 	add.w	r1, sp, r8
 8000f1a:	4668      	mov	r0, sp
 8000f1c:	f00c fab8 	bl	800d490 <memmove>
                len -= h;
 8000f20:	b2e4      	uxtb	r4, r4
                offset += h;
 8000f22:	f44f 7660 	mov.w	r6, #896	; 0x380
 8000f26:	e014      	b.n	8000f52 <oled_show_progress+0xda>
 8000f28:	4615      	mov	r5, r2
 8000f2a:	f04f 0801 	mov.w	r8, #1
            for(int j=0; (p_count > 0) && (j<len); j++, p_count--) {
                buf[j] |= 0x80;
            }
        }

        write_bytes(len, buf);
 8000f2e:	4669      	mov	r1, sp
 8000f30:	4620      	mov	r0, r4
        offset += len;
 8000f32:	4426      	add	r6, r4
            for(int j=0; (p_count > 0) && (j<len); j++, p_count--) {
                buf[j] |= 0x80;
            }
        }

        write_bytes(len, buf);
 8000f34:	f7ff fe52 	bl	8000bdc <write_bytes>
        offset += len;
 8000f38:	b2b6      	uxth	r6, r6
    }
 8000f3a:	e7c7      	b.n	8000ecc <oled_show_progress+0x54>

    HAL_GPIO_WritePin(GPIOA, CS_PIN, 1);
 8000f3c:	2201      	movs	r2, #1
 8000f3e:	2110      	movs	r1, #16
 8000f40:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000f44:	f000 f9b8 	bl	80012b8 <HAL_GPIO_WritePin>
    rng_delay();
 8000f48:	f001 fbf5 	bl	8002736 <rng_delay>
}
 8000f4c:	b020      	add	sp, #128	; 0x80
 8000f4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

    uint8_t         buf[127];
    const uint8_t *p = pixels;

    const uint16_t p_start = 896;
    uint32_t p_count = 1280 * progress / 1000;
 8000f52:	2300      	movs	r3, #0
                offset += h;
            }
        }

        if(last_line) {
            for(int j=0; (p_count > 0) && (j<len); j++, p_count--) {
 8000f54:	42ab      	cmp	r3, r5
 8000f56:	eba5 0203 	sub.w	r2, r5, r3
 8000f5a:	d009      	beq.n	8000f70 <oled_show_progress+0xf8>
 8000f5c:	42a3      	cmp	r3, r4
 8000f5e:	dae3      	bge.n	8000f28 <oled_show_progress+0xb0>
                buf[j] |= 0x80;
 8000f60:	f81d 2003 	ldrb.w	r2, [sp, r3]
 8000f64:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8000f68:	f80d 2003 	strb.w	r2, [sp, r3]
                offset += h;
            }
        }

        if(last_line) {
            for(int j=0; (p_count > 0) && (j<len); j++, p_count--) {
 8000f6c:	3301      	adds	r3, #1
 8000f6e:	e7f1      	b.n	8000f54 <oled_show_progress+0xdc>
 8000f70:	f04f 0801 	mov.w	r8, #1
 8000f74:	2500      	movs	r5, #0
 8000f76:	e7da      	b.n	8000f2e <oled_show_progress+0xb6>
 8000f78:	0800d5f4 	.word	0x0800d5f4

08000f7c <oled_factory_busy>:

// oled_factory_busy()
//
    void
oled_factory_busy(void)
{
 8000f7c:	b510      	push	{r4, lr}
    };
    uint8_t data[128];

    for(int x=0; x<128; x++) {
        // each byte here is a vertical column, 8 pixels tall, MSB at bottom
        data[x] = (1<<(7 - (x%8)));
 8000f7e:	2201      	movs	r2, #1

// oled_factory_busy()
//
    void
oled_factory_busy(void)
{
 8000f80:	b0a0      	sub	sp, #128	; 0x80
            0, 0xff,        // placeholders
        0x2f                // start
    };
    uint8_t data[128];

    for(int x=0; x<128; x++) {
 8000f82:	2400      	movs	r4, #0
        // each byte here is a vertical column, 8 pixels tall, MSB at bottom
        data[x] = (1<<(7 - (x%8)));
 8000f84:	f004 0307 	and.w	r3, r4, #7
 8000f88:	f1c3 0307 	rsb	r3, r3, #7
 8000f8c:	fa02 f303 	lsl.w	r3, r2, r3
 8000f90:	f80d 3004 	strb.w	r3, [sp, r4]
            0, 0xff,        // placeholders
        0x2f                // start
    };
    uint8_t data[128];

    for(int x=0; x<128; x++) {
 8000f94:	3401      	adds	r4, #1
 8000f96:	2c80      	cmp	r4, #128	; 0x80
 8000f98:	d1f4      	bne.n	8000f84 <oled_factory_busy+0x8>
        // each byte here is a vertical column, 8 pixels tall, MSB at bottom
        data[x] = (1<<(7 - (x%8)));
    }

    oled_write_cmd_sequence(sizeof(setup), setup);
 8000f9a:	4907      	ldr	r1, [pc, #28]	; (8000fb8 <oled_factory_busy+0x3c>)
 8000f9c:	2006      	movs	r0, #6
 8000f9e:	f7ff fe48 	bl	8000c32 <oled_write_cmd_sequence>
    oled_write_data(sizeof(data), data);
 8000fa2:	4669      	mov	r1, sp
 8000fa4:	4620      	mov	r0, r4
 8000fa6:	f7ff fe51 	bl	8000c4c <oled_write_data>
    oled_write_cmd_sequence(sizeof(animate), animate);
 8000faa:	4904      	ldr	r1, [pc, #16]	; (8000fbc <oled_factory_busy+0x40>)
 8000fac:	2009      	movs	r0, #9
 8000fae:	f7ff fe40 	bl	8000c32 <oled_write_cmd_sequence>
}
 8000fb2:	b020      	add	sp, #128	; 0x80
 8000fb4:	bd10      	pop	{r4, pc}
 8000fb6:	bf00      	nop
 8000fb8:	0800d5fa 	.word	0x0800d5fa
 8000fbc:	0800d600 	.word	0x0800d600

08000fc0 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000fc0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8000fc4:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 8001170 <HAL_GPIO_Init+0x1b0>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000fc8:	680b      	ldr	r3, [r1, #0]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000fca:	f8df c1a8 	ldr.w	ip, [pc, #424]	; 8001174 <HAL_GPIO_Init+0x1b4>
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000fce:	b085      	sub	sp, #20
 8000fd0:	4644      	mov	r4, r8
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000fd2:	9301      	str	r3, [sp, #4]
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
  uint32_t position = 0x00;
 8000fd4:	2300      	movs	r3, #0
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000fd6:	9a01      	ldr	r2, [sp, #4]
 8000fd8:	40da      	lsrs	r2, r3
 8000fda:	f000 80c3 	beq.w	8001164 <HAL_GPIO_Init+0x1a4>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 8000fde:	f04f 0e01 	mov.w	lr, #1

    if(iocurrent)
 8000fe2:	9a01      	ldr	r2, [sp, #4]

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 8000fe4:	fa0e fe03 	lsl.w	lr, lr, r3

    if(iocurrent)
 8000fe8:	ea12 060e 	ands.w	r6, r2, lr
 8000fec:	f000 80b8 	beq.w	8001160 <HAL_GPIO_Init+0x1a0>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000ff0:	684a      	ldr	r2, [r1, #4]
 8000ff2:	f022 0910 	bic.w	r9, r2, #16
 8000ff6:	f1b9 0f02 	cmp.w	r9, #2
 8000ffa:	d114      	bne.n	8001026 <HAL_GPIO_Init+0x66>
 8000ffc:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 8001000:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8001004:	f003 0b07 	and.w	fp, r3, #7
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 8001008:	f8da 7020 	ldr.w	r7, [sl, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 800100c:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 8001010:	250f      	movs	r5, #15
 8001012:	fa05 f50b 	lsl.w	r5, r5, fp
 8001016:	ea27 0505 	bic.w	r5, r7, r5
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 800101a:	690f      	ldr	r7, [r1, #16]
 800101c:	fa07 f70b 	lsl.w	r7, r7, fp
 8001020:	432f      	orrs	r7, r5
        GPIOx->AFR[position >> 3] = temp;
 8001022:	f8ca 7020 	str.w	r7, [sl, #32]
 8001026:	ea4f 0a43 	mov.w	sl, r3, lsl #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 800102a:	2503      	movs	r5, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800102c:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 800102e:	fa05 f50a 	lsl.w	r5, r5, sl
 8001032:	43ed      	mvns	r5, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8001034:	f002 0b03 	and.w	fp, r2, #3
        GPIOx->AFR[position >> 3] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 8001038:	402f      	ands	r7, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 800103a:	fa0b fb0a 	lsl.w	fp, fp, sl
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800103e:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8001042:	ea4b 0707 	orr.w	r7, fp, r7
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001046:	f1b9 0f01 	cmp.w	r9, #1

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
      GPIOx->MODER = temp;
 800104a:	6007      	str	r7, [r0, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800104c:	d811      	bhi.n	8001072 <HAL_GPIO_Init+0xb2>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 800104e:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2));
 8001050:	ea05 0907 	and.w	r9, r5, r7
        temp |= (GPIO_Init->Speed << (position * 2));
 8001054:	68cf      	ldr	r7, [r1, #12]
 8001056:	fa07 f70a 	lsl.w	r7, r7, sl
 800105a:	ea47 0709 	orr.w	r7, r7, r9
        GPIOx->OSPEEDR = temp;
 800105e:	6087      	str	r7, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8001060:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8001062:	ea27 0e0e 	bic.w	lr, r7, lr
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8001066:	f3c2 1700 	ubfx	r7, r2, #4, #1
 800106a:	409f      	lsls	r7, r3
 800106c:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OTYPER = temp;
 8001070:	6047      	str	r7, [r0, #4]
      }

#endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx */

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8001072:	68c7      	ldr	r7, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2));
 8001074:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8001076:	688f      	ldr	r7, [r1, #8]
 8001078:	fa07 f70a 	lsl.w	r7, r7, sl
 800107c:	433d      	orrs	r5, r7
      GPIOx->PUPDR = temp;
 800107e:	60c5      	str	r5, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001080:	00d5      	lsls	r5, r2, #3
 8001082:	d56d      	bpl.n	8001160 <HAL_GPIO_Init+0x1a0>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001084:	f8dc 5060 	ldr.w	r5, [ip, #96]	; 0x60
 8001088:	f045 0501 	orr.w	r5, r5, #1
 800108c:	f8cc 5060 	str.w	r5, [ip, #96]	; 0x60
 8001090:	f8dc 5060 	ldr.w	r5, [ip, #96]	; 0x60
 8001094:	f023 0703 	bic.w	r7, r3, #3
 8001098:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 800109c:	f005 0501 	and.w	r5, r5, #1
 80010a0:	f507 3780 	add.w	r7, r7, #65536	; 0x10000
 80010a4:	9503      	str	r5, [sp, #12]

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80010a6:	f003 0903 	and.w	r9, r3, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80010aa:	9d03      	ldr	r5, [sp, #12]

        temp = SYSCFG->EXTICR[position >> 2];
 80010ac:	f8d7 a008 	ldr.w	sl, [r7, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80010b0:	f04f 0e0f 	mov.w	lr, #15
 80010b4:	ea4f 0989 	mov.w	r9, r9, lsl #2
 80010b8:	fa0e f509 	lsl.w	r5, lr, r9
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
 80010bc:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80010c0:	ea2a 0e05 	bic.w	lr, sl, r5
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
 80010c4:	d01d      	beq.n	8001102 <HAL_GPIO_Init+0x142>
 80010c6:	4d29      	ldr	r5, [pc, #164]	; (800116c <HAL_GPIO_Init+0x1ac>)
 80010c8:	42a8      	cmp	r0, r5
 80010ca:	d01c      	beq.n	8001106 <HAL_GPIO_Init+0x146>
 80010cc:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80010d0:	42a8      	cmp	r0, r5
 80010d2:	d01a      	beq.n	800110a <HAL_GPIO_Init+0x14a>
 80010d4:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80010d8:	42a8      	cmp	r0, r5
 80010da:	d018      	beq.n	800110e <HAL_GPIO_Init+0x14e>
 80010dc:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80010e0:	42a8      	cmp	r0, r5
 80010e2:	d016      	beq.n	8001112 <HAL_GPIO_Init+0x152>
 80010e4:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80010e8:	42a8      	cmp	r0, r5
 80010ea:	d014      	beq.n	8001116 <HAL_GPIO_Init+0x156>
 80010ec:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80010f0:	42a8      	cmp	r0, r5
 80010f2:	d012      	beq.n	800111a <HAL_GPIO_Init+0x15a>
 80010f4:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80010f8:	42a8      	cmp	r0, r5
 80010fa:	bf14      	ite	ne
 80010fc:	2508      	movne	r5, #8
 80010fe:	2507      	moveq	r5, #7
 8001100:	e00c      	b.n	800111c <HAL_GPIO_Init+0x15c>
 8001102:	2500      	movs	r5, #0
 8001104:	e00a      	b.n	800111c <HAL_GPIO_Init+0x15c>
 8001106:	2501      	movs	r5, #1
 8001108:	e008      	b.n	800111c <HAL_GPIO_Init+0x15c>
 800110a:	2502      	movs	r5, #2
 800110c:	e006      	b.n	800111c <HAL_GPIO_Init+0x15c>
 800110e:	2503      	movs	r5, #3
 8001110:	e004      	b.n	800111c <HAL_GPIO_Init+0x15c>
 8001112:	2504      	movs	r5, #4
 8001114:	e002      	b.n	800111c <HAL_GPIO_Init+0x15c>
 8001116:	2505      	movs	r5, #5
 8001118:	e000      	b.n	800111c <HAL_GPIO_Init+0x15c>
 800111a:	2506      	movs	r5, #6
 800111c:	fa05 f509 	lsl.w	r5, r5, r9
 8001120:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2] = temp;
 8001124:	60bd      	str	r5, [r7, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8001126:	f8d8 5000 	ldr.w	r5, [r8]
        temp &= ~((uint32_t)iocurrent);
 800112a:	43f7      	mvns	r7, r6
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800112c:	f412 3f80 	tst.w	r2, #65536	; 0x10000
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
        temp &= ~((uint32_t)iocurrent);
 8001130:	bf0c      	ite	eq
 8001132:	403d      	andeq	r5, r7
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
 8001134:	4335      	orrne	r5, r6
        }
        EXTI->IMR1 = temp;
 8001136:	6025      	str	r5, [r4, #0]

        temp = EXTI->EMR1;
 8001138:	6865      	ldr	r5, [r4, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800113a:	f412 3f00 	tst.w	r2, #131072	; 0x20000
          temp |= iocurrent;
        }
        EXTI->IMR1 = temp;

        temp = EXTI->EMR1;
        temp &= ~((uint32_t)iocurrent);
 800113e:	bf0c      	ite	eq
 8001140:	403d      	andeq	r5, r7
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
 8001142:	4335      	orrne	r5, r6
        }
        EXTI->EMR1 = temp;
 8001144:	6065      	str	r5, [r4, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8001146:	68a5      	ldr	r5, [r4, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001148:	f412 1f80 	tst.w	r2, #1048576	; 0x100000
        }
        EXTI->EMR1 = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
        temp &= ~((uint32_t)iocurrent);
 800114c:	bf0c      	ite	eq
 800114e:	403d      	andeq	r5, r7
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
 8001150:	4335      	orrne	r5, r6
        }
        EXTI->RTSR1 = temp;
 8001152:	60a5      	str	r5, [r4, #8]

        temp = EXTI->FTSR1;
 8001154:	68e5      	ldr	r5, [r4, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001156:	0292      	lsls	r2, r2, #10
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;

        temp = EXTI->FTSR1;
        temp &= ~((uint32_t)iocurrent);
 8001158:	bf54      	ite	pl
 800115a:	403d      	andpl	r5, r7
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
 800115c:	4335      	orrmi	r5, r6
        }
        EXTI->FTSR1 = temp;
 800115e:	60e5      	str	r5, [r4, #12]
      }
    }

    position++;
 8001160:	3301      	adds	r3, #1
 8001162:	e738      	b.n	8000fd6 <HAL_GPIO_Init+0x16>
  }
}
 8001164:	b005      	add	sp, #20
 8001166:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800116a:	bf00      	nop
 800116c:	48000400 	.word	0x48000400
 8001170:	40010400 	.word	0x40010400
 8001174:	40021000 	.word	0x40021000

08001178 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 8001178:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      {
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
        SYSCFG->EXTICR[position >> 2] &= ~tmp;

        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~((uint32_t)iocurrent);
 800117c:	4c47      	ldr	r4, [pc, #284]	; (800129c <HAL_GPIO_DeInit+0x124>)
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 800117e:	f8df a124 	ldr.w	sl, [pc, #292]	; 80012a4 <HAL_GPIO_DeInit+0x12c>
 8001182:	f8df b124 	ldr.w	fp, [pc, #292]	; 80012a8 <HAL_GPIO_DeInit+0x130>
  *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
  uint32_t position = 0x00;
 8001186:	2200      	movs	r2, #0

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & (1U << position);
 8001188:	f04f 0901 	mov.w	r9, #1
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != RESET)
 800118c:	fa31 f302 	lsrs.w	r3, r1, r2
 8001190:	f000 8081 	beq.w	8001296 <HAL_GPIO_DeInit+0x11e>
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & (1U << position);
 8001194:	fa09 f802 	lsl.w	r8, r9, r2

    if (iocurrent)
 8001198:	ea11 0608 	ands.w	r6, r1, r8
 800119c:	d079      	beq.n	8001292 <HAL_GPIO_DeInit+0x11a>
    {
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2));
 800119e:	6807      	ldr	r7, [r0, #0]
 80011a0:	2303      	movs	r3, #3
 80011a2:	0055      	lsls	r5, r2, #1
 80011a4:	fa03 f505 	lsl.w	r5, r3, r5
 80011a8:	fa22 fc03 	lsr.w	ip, r2, r3
 80011ac:	432f      	orrs	r7, r5
 80011ae:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
 80011b2:	6007      	str	r7, [r0, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 80011b4:	f8dc 7020 	ldr.w	r7, [ip, #32]
 80011b8:	f002 0e07 	and.w	lr, r2, #7
 80011bc:	463b      	mov	r3, r7
 80011be:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 80011c2:	270f      	movs	r7, #15
 80011c4:	fa07 fe0e 	lsl.w	lr, r7, lr
 80011c8:	ea23 0e0e 	bic.w	lr, r3, lr
 80011cc:	f8cc e020 	str.w	lr, [ip, #32]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2));
 80011d0:	f8d0 e008 	ldr.w	lr, [r0, #8]
 80011d4:	43ed      	mvns	r5, r5
 80011d6:	ea0e 0e05 	and.w	lr, lr, r5
 80011da:	f8c0 e008 	str.w	lr, [r0, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
 80011de:	f8d0 e004 	ldr.w	lr, [r0, #4]
 80011e2:	ea2e 0808 	bic.w	r8, lr, r8
 80011e6:	f8c0 8004 	str.w	r8, [r0, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2));
 80011ea:	f8d0 e00c 	ldr.w	lr, [r0, #12]
 80011ee:	ea05 050e 	and.w	r5, r5, lr
 80011f2:	60c5      	str	r5, [r0, #12]
 80011f4:	f022 0503 	bic.w	r5, r2, #3
 80011f8:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 80011fc:	f505 3580 	add.w	r5, r5, #65536	; 0x10000

      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001200:	f002 0e03 	and.w	lr, r2, #3
#endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx */

      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = SYSCFG->EXTICR[position >> 2];
 8001204:	f8d5 c008 	ldr.w	ip, [r5, #8]
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001208:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 800120c:	fa07 f70e 	lsl.w	r7, r7, lr
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 8001210:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000

      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = SYSCFG->EXTICR[position >> 2];
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001214:	ea0c 0c07 	and.w	ip, ip, r7
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 8001218:	d019      	beq.n	800124e <HAL_GPIO_DeInit+0xd6>
 800121a:	4b21      	ldr	r3, [pc, #132]	; (80012a0 <HAL_GPIO_DeInit+0x128>)
 800121c:	4298      	cmp	r0, r3
 800121e:	d018      	beq.n	8001252 <HAL_GPIO_DeInit+0xda>
 8001220:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001224:	4298      	cmp	r0, r3
 8001226:	d016      	beq.n	8001256 <HAL_GPIO_DeInit+0xde>
 8001228:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800122c:	4298      	cmp	r0, r3
 800122e:	d014      	beq.n	800125a <HAL_GPIO_DeInit+0xe2>
 8001230:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001234:	4298      	cmp	r0, r3
 8001236:	d012      	beq.n	800125e <HAL_GPIO_DeInit+0xe6>
 8001238:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800123c:	4298      	cmp	r0, r3
 800123e:	d010      	beq.n	8001262 <HAL_GPIO_DeInit+0xea>
 8001240:	4550      	cmp	r0, sl
 8001242:	d010      	beq.n	8001266 <HAL_GPIO_DeInit+0xee>
 8001244:	4558      	cmp	r0, fp
 8001246:	bf0c      	ite	eq
 8001248:	2307      	moveq	r3, #7
 800124a:	2308      	movne	r3, #8
 800124c:	e00c      	b.n	8001268 <HAL_GPIO_DeInit+0xf0>
 800124e:	2300      	movs	r3, #0
 8001250:	e00a      	b.n	8001268 <HAL_GPIO_DeInit+0xf0>
 8001252:	2301      	movs	r3, #1
 8001254:	e008      	b.n	8001268 <HAL_GPIO_DeInit+0xf0>
 8001256:	2302      	movs	r3, #2
 8001258:	e006      	b.n	8001268 <HAL_GPIO_DeInit+0xf0>
 800125a:	2303      	movs	r3, #3
 800125c:	e004      	b.n	8001268 <HAL_GPIO_DeInit+0xf0>
 800125e:	2304      	movs	r3, #4
 8001260:	e002      	b.n	8001268 <HAL_GPIO_DeInit+0xf0>
 8001262:	2305      	movs	r3, #5
 8001264:	e000      	b.n	8001268 <HAL_GPIO_DeInit+0xf0>
 8001266:	2306      	movs	r3, #6
 8001268:	fa03 f30e 	lsl.w	r3, r3, lr
 800126c:	459c      	cmp	ip, r3
 800126e:	d110      	bne.n	8001292 <HAL_GPIO_DeInit+0x11a>
      {
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
        SYSCFG->EXTICR[position >> 2] &= ~tmp;
 8001270:	68ab      	ldr	r3, [r5, #8]
 8001272:	ea23 0707 	bic.w	r7, r3, r7
 8001276:	60af      	str	r7, [r5, #8]

        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~((uint32_t)iocurrent);
 8001278:	6823      	ldr	r3, [r4, #0]
 800127a:	43f6      	mvns	r6, r6
 800127c:	4033      	ands	r3, r6
 800127e:	6023      	str	r3, [r4, #0]
        EXTI->EMR1 &= ~((uint32_t)iocurrent);
 8001280:	6863      	ldr	r3, [r4, #4]
 8001282:	4033      	ands	r3, r6
 8001284:	6063      	str	r3, [r4, #4]

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR1 &= ~((uint32_t)iocurrent);
 8001286:	68a3      	ldr	r3, [r4, #8]
 8001288:	4033      	ands	r3, r6
 800128a:	60a3      	str	r3, [r4, #8]
        EXTI->FTSR1 &= ~((uint32_t)iocurrent);
 800128c:	68e3      	ldr	r3, [r4, #12]
 800128e:	401e      	ands	r6, r3
 8001290:	60e6      	str	r6, [r4, #12]
      }
    }

    position++;
 8001292:	3201      	adds	r2, #1
 8001294:	e77a      	b.n	800118c <HAL_GPIO_DeInit+0x14>
  }
}
 8001296:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800129a:	bf00      	nop
 800129c:	40010400 	.word	0x40010400
 80012a0:	48000400 	.word	0x48000400
 80012a4:	48001800 	.word	0x48001800
 80012a8:	48001c00 	.word	0x48001c00

080012ac <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 80012ac:	6903      	ldr	r3, [r0, #16]
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
 80012ae:	4219      	tst	r1, r3
}
 80012b0:	bf14      	ite	ne
 80012b2:	2001      	movne	r0, #1
 80012b4:	2000      	moveq	r0, #0
 80012b6:	4770      	bx	lr

080012b8 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 80012b8:	b10a      	cbz	r2, 80012be <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 80012ba:	6181      	str	r1, [r0, #24]
 80012bc:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 80012be:	6281      	str	r1, [r0, #40]	; 0x28
 80012c0:	4770      	bx	lr

080012c2 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 80012c2:	6943      	ldr	r3, [r0, #20]
 80012c4:	4059      	eors	r1, r3
 80012c6:	6141      	str	r1, [r0, #20]
 80012c8:	4770      	bx	lr

080012ca <HAL_GPIO_LockPin>:
  * @param  GPIO_Pin: specifies the port bits to be locked.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 80012ca:	b082      	sub	sp, #8
  __IO uint32_t tmp = GPIO_LCKR_LCKK;
 80012cc:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80012d0:	9301      	str	r3, [sp, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Apply lock key write sequence */
  tmp |= GPIO_Pin;
 80012d2:	9b01      	ldr	r3, [sp, #4]
 80012d4:	430b      	orrs	r3, r1
 80012d6:	9301      	str	r3, [sp, #4]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
 80012d8:	9b01      	ldr	r3, [sp, #4]
 80012da:	61c3      	str	r3, [r0, #28]
  /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
  GPIOx->LCKR = GPIO_Pin;
 80012dc:	61c1      	str	r1, [r0, #28]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
 80012de:	9b01      	ldr	r3, [sp, #4]
 80012e0:	61c3      	str	r3, [r0, #28]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 80012e2:	69c3      	ldr	r3, [r0, #28]
 80012e4:	9301      	str	r3, [sp, #4]

  if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)
 80012e6:	69c0      	ldr	r0, [r0, #28]
 80012e8:	f480 3080 	eor.w	r0, r0, #65536	; 0x10000
  }
  else
  {
    return HAL_ERROR;
  }
}
 80012ec:	f3c0 4000 	ubfx	r0, r0, #16, #1
 80012f0:	b002      	add	sp, #8
 80012f2:	4770      	bx	lr

080012f4 <HAL_GPIO_EXTI_Callback>:
  * @brief  EXTI line detection callback.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
 80012f4:	4770      	bx	lr
	...

080012f8 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 80012f8:	b508      	push	{r3, lr}
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
 80012fa:	4b04      	ldr	r3, [pc, #16]	; (800130c <HAL_GPIO_EXTI_IRQHandler+0x14>)
 80012fc:	6959      	ldr	r1, [r3, #20]
 80012fe:	4201      	tst	r1, r0
 8001300:	d002      	beq.n	8001308 <HAL_GPIO_EXTI_IRQHandler+0x10>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8001302:	6158      	str	r0, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8001304:	f7ff fff6 	bl	80012f4 <HAL_GPIO_EXTI_Callback>
 8001308:	bd08      	pop	{r3, pc}
 800130a:	bf00      	nop
 800130c:	40010400 	.word	0x40010400

08001310 <SPI_WaitFlagStateUntilTimeout.isra.1>:
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8001310:	6800      	ldr	r0, [r0, #0]
 8001312:	6883      	ldr	r3, [r0, #8]
 8001314:	ea31 0303 	bics.w	r3, r1, r3
 8001318:	bf0c      	ite	eq
 800131a:	2301      	moveq	r3, #1
 800131c:	2300      	movne	r3, #0
 800131e:	429a      	cmp	r2, r3
 8001320:	d1f7      	bne.n	8001312 <SPI_WaitFlagStateUntilTimeout.isra.1+0x2>
    }
#endif
  }

  return HAL_OK;
}
 8001322:	2000      	movs	r0, #0
 8001324:	4770      	bx	lr

08001326 <SPI_EndRxTxTransaction.isra.2>:
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
  __IO uint8_t tmpreg;

  while ((hspi->Instance->SR & Fifo) != State)
 8001326:	6803      	ldr	r3, [r0, #0]
  * @param  hspi: SPI handle
  * @param  Timeout: Timeout duration
  * @param  Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
 8001328:	b513      	push	{r0, r1, r4, lr}
 800132a:	4604      	mov	r4, r0
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
  __IO uint8_t tmpreg;

  while ((hspi->Instance->SR & Fifo) != State)
 800132c:	689a      	ldr	r2, [r3, #8]
 800132e:	f412 52c0 	ands.w	r2, r2, #6144	; 0x1800
 8001332:	d1fb      	bne.n	800132c <SPI_EndRxTxTransaction.isra.2+0x6>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }
  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8001334:	2180      	movs	r1, #128	; 0x80
 8001336:	4620      	mov	r0, r4
 8001338:	f7ff ffea 	bl	8001310 <SPI_WaitFlagStateUntilTimeout.isra.1>
 800133c:	b908      	cbnz	r0, 8001342 <SPI_EndRxTxTransaction.isra.2+0x1c>
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
  __IO uint8_t tmpreg;

  while ((hspi->Instance->SR & Fifo) != State)
 800133e:	6822      	ldr	r2, [r4, #0]
 8001340:	e005      	b.n	800134e <SPI_EndRxTxTransaction.isra.2+0x28>
    return HAL_TIMEOUT;
  }
  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8001342:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8001344:	f043 0320 	orr.w	r3, r3, #32
 8001348:	6623      	str	r3, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 800134a:	2003      	movs	r0, #3
 800134c:	e00a      	b.n	8001364 <SPI_EndRxTxTransaction.isra.2+0x3e>
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
  __IO uint8_t tmpreg;

  while ((hspi->Instance->SR & Fifo) != State)
 800134e:	6893      	ldr	r3, [r2, #8]
 8001350:	f413 6fc0 	tst.w	r3, #1536	; 0x600
 8001354:	d006      	beq.n	8001364 <SPI_EndRxTxTransaction.isra.2+0x3e>
  {
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
    {
      tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 8001356:	7b13      	ldrb	r3, [r2, #12]
 8001358:	b2db      	uxtb	r3, r3
 800135a:	f88d 3007 	strb.w	r3, [sp, #7]
      /* To avoid GCC warning */
      UNUSED(tmpreg);
 800135e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8001362:	e7f4      	b.n	800134e <SPI_EndRxTxTransaction.isra.2+0x28>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }
  return HAL_OK;
}
 8001364:	b002      	add	sp, #8
 8001366:	bd10      	pop	{r4, pc}

08001368 <HAL_SPI_Init>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 8001368:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
 800136a:	2800      	cmp	r0, #0
 800136c:	d054      	beq.n	8001418 <HAL_SPI_Init+0xb0>
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 800136e:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
 8001372:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001376:	b90b      	cbnz	r3, 800137c <HAL_SPI_Init+0x14>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 8001378:	f880 205c 	strb.w	r2, [r0, #92]	; 0x5c

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
//PDG//    HAL_SPI_MspInit(hspi);
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 800137c:	2302      	movs	r3, #2

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 800137e:	6801      	ldr	r1, [r0, #0]

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
//PDG//    HAL_SPI_MspInit(hspi);
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 8001380:	f880 305d 	strb.w	r3, [r0, #93]	; 0x5d

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001384:	680b      	ldr	r3, [r1, #0]

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8001386:	68c5      	ldr	r5, [r0, #12]
  }

  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001388:	f023 0340 	bic.w	r3, r3, #64	; 0x40

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800138c:	f5b5 6fe0 	cmp.w	r5, #1792	; 0x700
  }

  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001390:	600b      	str	r3, [r1, #0]
 8001392:	f04f 0300 	mov.w	r3, #0

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8001396:	d903      	bls.n	80013a0 <HAL_SPI_Init+0x38>
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 8001398:	461c      	mov	r4, r3
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
  }

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 800139a:	f5b5 6f70 	cmp.w	r5, #3840	; 0xf00
 800139e:	e001      	b.n	80013a4 <HAL_SPI_Init+0x3c>
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
  }
  else
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 80013a0:	f44f 5480 	mov.w	r4, #4096	; 0x1000

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
  {
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80013a4:	bf18      	it	ne
 80013a6:	6283      	strne	r3, [r0, #40]	; 0x28
  }

  /* Align the CRC Length on the data size */
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 80013a8:	6b03      	ldr	r3, [r0, #48]	; 0x30
 80013aa:	b92b      	cbnz	r3, 80013b8 <HAL_SPI_Init+0x50>
  {
    /* CRC Length aligned on the data size : value set by default */
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80013ac:	f5b5 6fe0 	cmp.w	r5, #1792	; 0x700
    {
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
 80013b0:	bf8c      	ite	hi
 80013b2:	2302      	movhi	r3, #2
    }
    else
    {
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 80013b4:	2301      	movls	r3, #1
 80013b6:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 80013b8:	6882      	ldr	r2, [r0, #8]
 80013ba:	6847      	ldr	r7, [r0, #4]
 80013bc:	6983      	ldr	r3, [r0, #24]
 80013be:	6a86      	ldr	r6, [r0, #40]	; 0x28
 80013c0:	4317      	orrs	r7, r2
 80013c2:	6902      	ldr	r2, [r0, #16]
 80013c4:	4317      	orrs	r7, r2
 80013c6:	6942      	ldr	r2, [r0, #20]
 80013c8:	4317      	orrs	r7, r2
 80013ca:	69c2      	ldr	r2, [r0, #28]
 80013cc:	4317      	orrs	r7, r2
 80013ce:	6a02      	ldr	r2, [r0, #32]
 80013d0:	433a      	orrs	r2, r7
 80013d2:	4332      	orrs	r2, r6
 80013d4:	f403 7700 	and.w	r7, r3, #512	; 0x200
 80013d8:	433a      	orrs	r2, r7
 80013da:	600a      	str	r2, [r1, #0]
                                  hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                                  hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation));
#if (USE_SPI_CRC != 0U)
  /* Configure : CRC Length */
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 80013dc:	6b02      	ldr	r2, [r0, #48]	; 0x30
 80013de:	2a02      	cmp	r2, #2
  {
    hspi->Instance->CR1 |= SPI_CR1_CRCL;
 80013e0:	bf02      	ittt	eq
 80013e2:	680a      	ldreq	r2, [r1, #0]
 80013e4:	f442 6200 	orreq.w	r2, r2, #2048	; 0x800
 80013e8:	600a      	streq	r2, [r1, #0]
  }
#endif /* USE_SPI_CRC */

  /* Configure : NSS management, TI Mode, NSS Pulse, Data size and Rx Fifo Threshold */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 80013ea:	6a42      	ldr	r2, [r0, #36]	; 0x24
 80013ec:	4315      	orrs	r5, r2
 80013ee:	6b42      	ldr	r2, [r0, #52]	; 0x34
 80013f0:	0c1b      	lsrs	r3, r3, #16
 80013f2:	4315      	orrs	r5, r2
 80013f4:	f003 0204 	and.w	r2, r3, #4
 80013f8:	ea45 0302 	orr.w	r3, r5, r2
 80013fc:	4323      	orrs	r3, r4
                                  hspi->Init.NSSPMode | hspi->Init.DataSize) | frxth);

#if (USE_SPI_CRC != 0U)
  /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
  /* Configure : CRC Polynomial */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80013fe:	f5b6 5f00 	cmp.w	r6, #8192	; 0x2000
    hspi->Instance->CR1 |= SPI_CR1_CRCL;
  }
#endif /* USE_SPI_CRC */

  /* Configure : NSS management, TI Mode, NSS Pulse, Data size and Rx Fifo Threshold */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8001402:	604b      	str	r3, [r1, #4]
#if (USE_SPI_CRC != 0U)
  /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
  /* Configure : CRC Polynomial */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    WRITE_REG(hspi->Instance->CRCPR, hspi->Init.CRCPolynomial);
 8001404:	bf04      	itt	eq
 8001406:	6ac3      	ldreq	r3, [r0, #44]	; 0x2c
 8001408:	610b      	streq	r3, [r1, #16]
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
  hspi->State     = HAL_SPI_STATE_READY;
 800140a:	2201      	movs	r2, #1
#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 800140c:	2300      	movs	r3, #0
 800140e:	6603      	str	r3, [r0, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 8001410:	f880 205d 	strb.w	r2, [r0, #93]	; 0x5d

  return HAL_OK;
 8001414:	4618      	mov	r0, r3
 8001416:	bdf0      	pop	{r4, r5, r6, r7, pc}
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
  {
    return HAL_ERROR;
 8001418:	2001      	movs	r0, #1

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
  hspi->State     = HAL_SPI_STATE_READY;

  return HAL_OK;
}
 800141a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800141c <HAL_SPI_Transmit>:
  * @param  Size: amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800141c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8001420:	461e      	mov	r6, r3

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8001422:	f890 305c 	ldrb.w	r3, [r0, #92]	; 0x5c
 8001426:	2b01      	cmp	r3, #1
  * @param  Size: amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8001428:	4604      	mov	r4, r0
 800142a:	460d      	mov	r5, r1
 800142c:	4690      	mov	r8, r2

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 800142e:	f000 80a1 	beq.w	8001574 <HAL_SPI_Transmit+0x158>
 8001432:	2301      	movs	r3, #1
 8001434:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 8001438:	f005 fde8 	bl	800700c <HAL_GetTick>
 800143c:	4607      	mov	r7, r0

  if (hspi->State != HAL_SPI_STATE_READY)
 800143e:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
 8001442:	b2c0      	uxtb	r0, r0
 8001444:	2801      	cmp	r0, #1
 8001446:	f040 808d 	bne.w	8001564 <HAL_SPI_Transmit+0x148>
  {
    errorcode = HAL_BUSY;
    goto error;
  }

  if ((pData == NULL) || (Size == 0U))
 800144a:	2d00      	cmp	r5, #0
 800144c:	f000 808b 	beq.w	8001566 <HAL_SPI_Transmit+0x14a>
 8001450:	f1b8 0f00 	cmp.w	r8, #0
 8001454:	f000 8087 	beq.w	8001566 <HAL_SPI_Transmit+0x14a>
    errorcode = HAL_ERROR;
    goto error;
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8001458:	2303      	movs	r3, #3
 800145a:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  hspi->RxXferCount = 0U;
  hspi->TxISR       = NULL;
  hspi->RxISR       = NULL;

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800145e:	68a3      	ldr	r3, [r4, #8]
 8001460:	6822      	ldr	r2, [r4, #0]
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8001462:	63a5      	str	r5, [r4, #56]	; 0x38
    goto error;
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8001464:	2100      	movs	r1, #0
  hspi->RxXferCount = 0U;
  hspi->TxISR       = NULL;
  hspi->RxISR       = NULL;

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8001466:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    goto error;
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800146a:	6621      	str	r1, [r4, #96]	; 0x60
  hspi->pTxBuffPtr  = (uint8_t *)pData;
  hspi->TxXferSize  = Size;
  hspi->TxXferCount = Size;
 800146c:	f8a4 803e 	strh.w	r8, [r4, #62]	; 0x3e

  /*Init field not used in handle to zero */
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
  hspi->RxXferSize  = 0U;
  hspi->RxXferCount = 0U;
 8001470:	f8a4 1046 	strh.w	r1, [r4, #70]	; 0x46
  hspi->RxISR       = NULL;

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
  {
    SPI_1LINE_TX(hspi);
 8001474:	bf08      	it	eq
 8001476:	6813      	ldreq	r3, [r2, #0]

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pData;
  hspi->TxXferSize  = Size;
 8001478:	f8a4 803c 	strh.w	r8, [r4, #60]	; 0x3c
  hspi->RxISR       = NULL;

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
  {
    SPI_1LINE_TX(hspi);
 800147c:	bf08      	it	eq
 800147e:	f443 4380 	orreq.w	r3, r3, #16384	; 0x4000
  hspi->pTxBuffPtr  = (uint8_t *)pData;
  hspi->TxXferSize  = Size;
  hspi->TxXferCount = Size;

  /*Init field not used in handle to zero */
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8001482:	6421      	str	r1, [r4, #64]	; 0x40
  hspi->RxXferSize  = 0U;
 8001484:	f8a4 1044 	strh.w	r1, [r4, #68]	; 0x44
  hspi->RxXferCount = 0U;
  hspi->TxISR       = NULL;
 8001488:	6521      	str	r1, [r4, #80]	; 0x50
  hspi->RxISR       = NULL;
 800148a:	64e1      	str	r1, [r4, #76]	; 0x4c

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
  {
    SPI_1LINE_TX(hspi);
 800148c:	bf08      	it	eq
 800148e:	6013      	streq	r3, [r2, #0]
  }

#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8001490:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001492:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8001496:	d107      	bne.n	80014a8 <HAL_SPI_Transmit+0x8c>
  {
    SPI_RESET_CRC(hspi);
 8001498:	6813      	ldr	r3, [r2, #0]
 800149a:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800149e:	6013      	str	r3, [r2, #0]
 80014a0:	6813      	ldr	r3, [r2, #0]
 80014a2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80014a6:	6013      	str	r3, [r2, #0]
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80014a8:	6813      	ldr	r3, [r2, #0]
 80014aa:	0659      	lsls	r1, r3, #25
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 80014ac:	bf5e      	ittt	pl
 80014ae:	6813      	ldrpl	r3, [r2, #0]
 80014b0:	f043 0340 	orrpl.w	r3, r3, #64	; 0x40
 80014b4:	6013      	strpl	r3, [r2, #0]
  }
  /* Transmit data in 8 Bit mode */
  else
  {
#endif
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
 80014b6:	6863      	ldr	r3, [r4, #4]
 80014b8:	b11b      	cbz	r3, 80014c2 <HAL_SPI_Transmit+0xa6>
 80014ba:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80014bc:	b29b      	uxth	r3, r3
 80014be:	2b01      	cmp	r3, #1
 80014c0:	d115      	bne.n	80014ee <HAL_SPI_Transmit+0xd2>
    {
      if (hspi->TxXferCount > 1U)
 80014c2:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80014c4:	b29b      	uxth	r3, r3
 80014c6:	2b01      	cmp	r3, #1
 80014c8:	d903      	bls.n	80014d2 <HAL_SPI_Transmit+0xb6>
      {
        /* write on the data register in packing mode */
        hspi->Instance->DR = *((uint16_t *)pData);
 80014ca:	f835 3b02 	ldrh.w	r3, [r5], #2
 80014ce:	60d3      	str	r3, [r2, #12]
 80014d0:	e01b      	b.n	800150a <HAL_SPI_Transmit+0xee>
        pData += sizeof(uint16_t);
        hspi->TxXferCount -= 2U;
      }
      else
      {
        *((__IO uint8_t *)&hspi->Instance->DR) = (*pData++);
 80014d2:	782b      	ldrb	r3, [r5, #0]
 80014d4:	7313      	strb	r3, [r2, #12]
        hspi->TxXferCount--;
 80014d6:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80014d8:	3b01      	subs	r3, #1
 80014da:	b29b      	uxth	r3, r3
 80014dc:	87e3      	strh	r3, [r4, #62]	; 0x3e
 80014de:	e005      	b.n	80014ec <HAL_SPI_Transmit+0xd0>
          pData += sizeof(uint16_t);
          hspi->TxXferCount -= 2U;
        }
        else
        {
          *((__IO uint8_t *)&hspi->Instance->DR) = (*pData++);
 80014e0:	782a      	ldrb	r2, [r5, #0]
 80014e2:	731a      	strb	r2, [r3, #12]
          hspi->TxXferCount--;
 80014e4:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 80014e6:	3a01      	subs	r2, #1
 80014e8:	b292      	uxth	r2, r2
 80014ea:	87e2      	strh	r2, [r4, #62]	; 0x3e
          pData += sizeof(uint16_t);
          hspi->TxXferCount -= 2U;
        }
        else
        {
          *((__IO uint8_t *)&hspi->Instance->DR) = (*pData++);
 80014ec:	3501      	adds	r5, #1
      {
        *((__IO uint8_t *)&hspi->Instance->DR) = (*pData++);
        hspi->TxXferCount--;
      }
    }
    while (hspi->TxXferCount > 0U)
 80014ee:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80014f0:	b29b      	uxth	r3, r3
 80014f2:	b1d3      	cbz	r3, 800152a <HAL_SPI_Transmit+0x10e>
    {
      /* Wait until TXE flag is set to send data */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 80014f4:	6823      	ldr	r3, [r4, #0]
 80014f6:	689a      	ldr	r2, [r3, #8]
 80014f8:	0792      	lsls	r2, r2, #30
 80014fa:	d50b      	bpl.n	8001514 <HAL_SPI_Transmit+0xf8>
      {
        if (hspi->TxXferCount > 1U)
 80014fc:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 80014fe:	b292      	uxth	r2, r2
 8001500:	2a01      	cmp	r2, #1
 8001502:	d9ed      	bls.n	80014e0 <HAL_SPI_Transmit+0xc4>
        {
          /* write on the data register in packing mode */
          hspi->Instance->DR = *((uint16_t *)pData);
 8001504:	f835 2b02 	ldrh.w	r2, [r5], #2
 8001508:	60da      	str	r2, [r3, #12]
          pData += sizeof(uint16_t);
          hspi->TxXferCount -= 2U;
 800150a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800150c:	3b02      	subs	r3, #2
 800150e:	b29b      	uxth	r3, r3
 8001510:	87e3      	strh	r3, [r4, #62]	; 0x3e
 8001512:	e7ec      	b.n	80014ee <HAL_SPI_Transmit+0xd2>
        }
      }
      else
      {
        /* Timeout management */
        if ((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout)))
 8001514:	b90e      	cbnz	r6, 800151a <HAL_SPI_Transmit+0xfe>
        {
          errorcode = HAL_TIMEOUT;
 8001516:	2003      	movs	r0, #3
 8001518:	e025      	b.n	8001566 <HAL_SPI_Transmit+0x14a>
        }
      }
      else
      {
        /* Timeout management */
        if ((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout)))
 800151a:	1c73      	adds	r3, r6, #1
 800151c:	d0e7      	beq.n	80014ee <HAL_SPI_Transmit+0xd2>
 800151e:	f005 fd75 	bl	800700c <HAL_GetTick>
 8001522:	1bc0      	subs	r0, r0, r7
 8001524:	4286      	cmp	r6, r0
 8001526:	d8e2      	bhi.n	80014ee <HAL_SPI_Transmit+0xd2>
 8001528:	e7f5      	b.n	8001516 <HAL_SPI_Transmit+0xfa>
      }
    }
//  }
#if (USE_SPI_CRC != 0U)
  /* Enable CRC Transmission */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800152a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800152c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
  {
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 8001530:	bf01      	itttt	eq
 8001532:	6822      	ldreq	r2, [r4, #0]
 8001534:	6813      	ldreq	r3, [r2, #0]
 8001536:	f443 5380 	orreq.w	r3, r3, #4096	; 0x1000
 800153a:	6013      	streq	r3, [r2, #0]
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 800153c:	4620      	mov	r0, r4
 800153e:	f7ff fef2 	bl	8001326 <SPI_EndRxTxTransaction.isra.2>
 8001542:	b108      	cbz	r0, 8001548 <HAL_SPI_Transmit+0x12c>
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8001544:	2320      	movs	r3, #32
 8001546:	6623      	str	r3, [r4, #96]	; 0x60
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8001548:	68a3      	ldr	r3, [r4, #8]
 800154a:	b933      	cbnz	r3, 800155a <HAL_SPI_Transmit+0x13e>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 800154c:	9301      	str	r3, [sp, #4]
 800154e:	6823      	ldr	r3, [r4, #0]
 8001550:	68da      	ldr	r2, [r3, #12]
 8001552:	9201      	str	r2, [sp, #4]
 8001554:	689b      	ldr	r3, [r3, #8]
 8001556:	9301      	str	r3, [sp, #4]
 8001558:	9b01      	ldr	r3, [sp, #4]
  }

  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 800155a:	6e20      	ldr	r0, [r4, #96]	; 0x60
  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();

  if (hspi->State != HAL_SPI_STATE_READY)
  {
    errorcode = HAL_BUSY;
 800155c:	3000      	adds	r0, #0
 800155e:	bf18      	it	ne
 8001560:	2001      	movne	r0, #1
 8001562:	e000      	b.n	8001566 <HAL_SPI_Transmit+0x14a>
 8001564:	2002      	movs	r0, #2
  {
    errorcode = HAL_ERROR;
  }

error:
  hspi->State = HAL_SPI_STATE_READY;
 8001566:	2301      	movs	r3, #1
 8001568:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 800156c:	2300      	movs	r3, #0
 800156e:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  return errorcode;
 8001572:	e000      	b.n	8001576 <HAL_SPI_Transmit+0x15a>

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8001574:	2002      	movs	r0, #2
error:
  hspi->State = HAL_SPI_STATE_READY;
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 8001576:	b002      	add	sp, #8
 8001578:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800157c <HAL_SPI_TransmitReceive>:
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
                                          uint32_t Timeout)
{
 800157c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8001580:	461d      	mov	r5, r3
  uint32_t tmp = 0U, tmp1 = 0U;
#if (USE_SPI_CRC != 0U)
  __IO uint16_t tmpreg = 0U;
 8001582:	2300      	movs	r3, #0
 8001584:	f8ad 3006 	strh.w	r3, [sp, #6]

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8001588:	f890 305c 	ldrb.w	r3, [r0, #92]	; 0x5c
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
                                          uint32_t Timeout)
{
 800158c:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8001590:	2b01      	cmp	r3, #1
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
                                          uint32_t Timeout)
{
 8001592:	4604      	mov	r4, r0
 8001594:	460e      	mov	r6, r1
 8001596:	4617      	mov	r7, r2

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8001598:	f000 8132 	beq.w	8001800 <HAL_SPI_TransmitReceive+0x284>
 800159c:	2301      	movs	r3, #1
 800159e:	f880 305c 	strb.w	r3, [r0, #92]	; 0x5c

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 80015a2:	f005 fd33 	bl	800700c <HAL_GetTick>

  tmp  = hspi->State;
 80015a6:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
  tmp1 = hspi->Init.Mode;
 80015aa:	6861      	ldr	r1, [r4, #4]
  __HAL_LOCK(hspi);

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();

  tmp  = hspi->State;
 80015ac:	b2db      	uxtb	r3, r3
  tmp1 = hspi->Init.Mode;

  if (!((tmp == HAL_SPI_STATE_READY) || \
 80015ae:	2b01      	cmp	r3, #1

  /* Process Locked */
  __HAL_LOCK(hspi);

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 80015b0:	4681      	mov	r9, r0

  tmp  = hspi->State;
  tmp1 = hspi->Init.Mode;

  if (!((tmp == HAL_SPI_STATE_READY) || \
 80015b2:	d00a      	beq.n	80015ca <HAL_SPI_TransmitReceive+0x4e>
 80015b4:	f5b1 7f82 	cmp.w	r1, #260	; 0x104
 80015b8:	f040 8117 	bne.w	80017ea <HAL_SPI_TransmitReceive+0x26e>
        ((tmp1 == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp == HAL_SPI_STATE_BUSY_RX))))
 80015bc:	68a2      	ldr	r2, [r4, #8]
 80015be:	2a00      	cmp	r2, #0
 80015c0:	f040 8113 	bne.w	80017ea <HAL_SPI_TransmitReceive+0x26e>
 80015c4:	2b04      	cmp	r3, #4
 80015c6:	f040 8110 	bne.w	80017ea <HAL_SPI_TransmitReceive+0x26e>
  {
    errorcode = HAL_BUSY;
    goto error;
  }

  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 80015ca:	2e00      	cmp	r6, #0
 80015cc:	f000 810b 	beq.w	80017e6 <HAL_SPI_TransmitReceive+0x26a>
 80015d0:	2f00      	cmp	r7, #0
 80015d2:	f000 8108 	beq.w	80017e6 <HAL_SPI_TransmitReceive+0x26a>
 80015d6:	2d00      	cmp	r5, #0
 80015d8:	f000 8105 	beq.w	80017e6 <HAL_SPI_TransmitReceive+0x26a>
    errorcode = HAL_ERROR;
    goto error;
  }

  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 80015dc:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 80015e0:	6427      	str	r7, [r4, #64]	; 0x40
    errorcode = HAL_ERROR;
    goto error;
  }

  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 80015e2:	2b04      	cmp	r3, #4
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 80015e4:	bf1c      	itt	ne
 80015e6:	2305      	movne	r3, #5
 80015e8:	f884 305d 	strbne.w	r3, [r4, #93]	; 0x5d
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80015ec:	2300      	movs	r3, #0
 80015ee:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
  hspi->TxXferCount = Size;
  hspi->TxXferSize  = Size;

  /*Init field not used in handle to zero */
  hspi->RxISR       = NULL;
 80015f0:	64e3      	str	r3, [r4, #76]	; 0x4c
  hspi->TxISR       = NULL;
 80015f2:	6523      	str	r3, [r4, #80]	; 0x50

#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80015f4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
  hspi->RxXferCount = Size;
 80015f6:	f8a4 5046 	strh.w	r5, [r4, #70]	; 0x46
  hspi->RxISR       = NULL;
  hspi->TxISR       = NULL;

#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80015fa:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
  hspi->RxXferCount = Size;
  hspi->RxXferSize  = Size;
 80015fe:	f8a4 5044 	strh.w	r5, [r4, #68]	; 0x44
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 8001602:	63a6      	str	r6, [r4, #56]	; 0x38
  hspi->TxXferCount = Size;
 8001604:	87e5      	strh	r5, [r4, #62]	; 0x3e
  hspi->TxXferSize  = Size;
 8001606:	87a5      	strh	r5, [r4, #60]	; 0x3c
 8001608:	6823      	ldr	r3, [r4, #0]
  hspi->RxISR       = NULL;
  hspi->TxISR       = NULL;

#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800160a:	d107      	bne.n	800161c <HAL_SPI_TransmitReceive+0xa0>
  {
    SPI_RESET_CRC(hspi);
 800160c:	681a      	ldr	r2, [r3, #0]
 800160e:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8001612:	601a      	str	r2, [r3, #0]
 8001614:	681a      	ldr	r2, [r3, #0]
 8001616:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800161a:	601a      	str	r2, [r3, #0]
  }
#endif /* USE_SPI_CRC */

  /* Set the Rx Fifo threshold */
  if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (hspi->RxXferCount > 1U))
 800161c:	68e2      	ldr	r2, [r4, #12]
 800161e:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
 8001622:	d804      	bhi.n	800162e <HAL_SPI_TransmitReceive+0xb2>
 8001624:	f8b4 2046 	ldrh.w	r2, [r4, #70]	; 0x46
 8001628:	b292      	uxth	r2, r2
 800162a:	2a01      	cmp	r2, #1
 800162c:	d903      	bls.n	8001636 <HAL_SPI_TransmitReceive+0xba>
  {
    /* set fiforxthreshold according the reception data length: 16bit */
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800162e:	685a      	ldr	r2, [r3, #4]
 8001630:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8001634:	e002      	b.n	800163c <HAL_SPI_TransmitReceive+0xc0>
  }
  else
  {
    /* set fiforxthreshold according the reception data length: 8bit */
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8001636:	685a      	ldr	r2, [r3, #4]
 8001638:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800163c:	605a      	str	r2, [r3, #4]
  }

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 800163e:	681a      	ldr	r2, [r3, #0]
 8001640:	0655      	lsls	r5, r2, #25
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 8001642:	bf5e      	ittt	pl
 8001644:	681a      	ldrpl	r2, [r3, #0]
 8001646:	f042 0240 	orrpl.w	r2, r2, #64	; 0x40
 800164a:	601a      	strpl	r2, [r3, #0]
  }
  /* Transmit and Receive data in 8 Bit mode */
  else
  {
#endif
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
 800164c:	b119      	cbz	r1, 8001656 <HAL_SPI_TransmitReceive+0xda>
 800164e:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8001650:	b292      	uxth	r2, r2
 8001652:	2a01      	cmp	r2, #1
 8001654:	d112      	bne.n	800167c <HAL_SPI_TransmitReceive+0x100>
    {
      if (hspi->TxXferCount > 1U)
 8001656:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8001658:	b292      	uxth	r2, r2
 800165a:	2a01      	cmp	r2, #1
 800165c:	d907      	bls.n	800166e <HAL_SPI_TransmitReceive+0xf2>
      {
        hspi->Instance->DR = *((uint16_t *)pTxData);
 800165e:	f836 2b02 	ldrh.w	r2, [r6], #2
 8001662:	60da      	str	r2, [r3, #12]
        pTxData += sizeof(uint16_t);
        hspi->TxXferCount -= 2U;
 8001664:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8001666:	3b02      	subs	r3, #2
 8001668:	b29b      	uxth	r3, r3
 800166a:	87e3      	strh	r3, [r4, #62]	; 0x3e
 800166c:	e006      	b.n	800167c <HAL_SPI_TransmitReceive+0x100>
      }
      else
      {
        *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
 800166e:	7832      	ldrb	r2, [r6, #0]
 8001670:	731a      	strb	r2, [r3, #12]
        hspi->TxXferCount--;
 8001672:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8001674:	3b01      	subs	r3, #1
 8001676:	b29b      	uxth	r3, r3
 8001678:	87e3      	strh	r3, [r4, #62]	; 0x3e
        pTxData += sizeof(uint16_t);
        hspi->TxXferCount -= 2U;
      }
      else
      {
        *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
 800167a:	3601      	adds	r6, #1
        {
          (*(uint8_t *)pRxData++) = *(__IO uint8_t *)&hspi->Instance->DR;
          hspi->RxXferCount--;
        }
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
 800167c:	2501      	movs	r5, #1
      {
        *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
        hspi->TxXferCount--;
      }
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800167e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8001680:	b29b      	uxth	r3, r3
 8001682:	2b00      	cmp	r3, #0
 8001684:	d06a      	beq.n	800175c <HAL_SPI_TransmitReceive+0x1e0>
    {
      /* check TXE flag */
      if (txallowed && (hspi->TxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)))
 8001686:	2d00      	cmp	r5, #0
 8001688:	d034      	beq.n	80016f4 <HAL_SPI_TransmitReceive+0x178>
 800168a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800168c:	b29b      	uxth	r3, r3
 800168e:	2b00      	cmp	r3, #0
 8001690:	d02d      	beq.n	80016ee <HAL_SPI_TransmitReceive+0x172>
 8001692:	6823      	ldr	r3, [r4, #0]
 8001694:	689a      	ldr	r2, [r3, #8]
 8001696:	0790      	lsls	r0, r2, #30
 8001698:	d529      	bpl.n	80016ee <HAL_SPI_TransmitReceive+0x172>
      {
        if (hspi->TxXferCount > 1U)
 800169a:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 800169c:	b292      	uxth	r2, r2
 800169e:	2a01      	cmp	r2, #1
 80016a0:	d907      	bls.n	80016b2 <HAL_SPI_TransmitReceive+0x136>
        {
          hspi->Instance->DR = *((uint16_t *)pTxData);
 80016a2:	f836 2b02 	ldrh.w	r2, [r6], #2
 80016a6:	60da      	str	r2, [r3, #12]
          pTxData += sizeof(uint16_t);
          hspi->TxXferCount -= 2U;
 80016a8:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80016aa:	3b02      	subs	r3, #2
 80016ac:	b29b      	uxth	r3, r3
 80016ae:	87e3      	strh	r3, [r4, #62]	; 0x3e
 80016b0:	e006      	b.n	80016c0 <HAL_SPI_TransmitReceive+0x144>
        }
        else
        {
          *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
 80016b2:	7832      	ldrb	r2, [r6, #0]
 80016b4:	731a      	strb	r2, [r3, #12]
          hspi->TxXferCount--;
 80016b6:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80016b8:	3b01      	subs	r3, #1
 80016ba:	b29b      	uxth	r3, r3
 80016bc:	87e3      	strh	r3, [r4, #62]	; 0x3e
          pTxData += sizeof(uint16_t);
          hspi->TxXferCount -= 2U;
        }
        else
        {
          *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
 80016be:	3601      	adds	r6, #1
        /* Next Data is a reception (Rx). Tx not allowed */
        txallowed = 0U;

#if (USE_SPI_CRC != 0U)
        /* Enable CRC Transmission */
        if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
 80016c0:	8fe5      	ldrh	r5, [r4, #62]	; 0x3e
 80016c2:	b2ad      	uxth	r5, r5
 80016c4:	b9ad      	cbnz	r5, 80016f2 <HAL_SPI_TransmitReceive+0x176>
 80016c6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80016c8:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80016cc:	d112      	bne.n	80016f4 <HAL_SPI_TransmitReceive+0x178>
        {
          /* Set NSS Soft to received correctly the CRC on slave mode with NSS pulse activated */
          if (((hspi->Instance->CR1 & SPI_CR1_MSTR) == 0U) && ((hspi->Instance->CR2 & SPI_CR2_NSSP) == SPI_CR2_NSSP))
 80016ce:	6823      	ldr	r3, [r4, #0]
 80016d0:	681a      	ldr	r2, [r3, #0]
 80016d2:	0751      	lsls	r1, r2, #29
 80016d4:	d406      	bmi.n	80016e4 <HAL_SPI_TransmitReceive+0x168>
 80016d6:	685a      	ldr	r2, [r3, #4]
 80016d8:	0712      	lsls	r2, r2, #28
          {
            SET_BIT(hspi->Instance->CR1, SPI_CR1_SSM);
 80016da:	bf42      	ittt	mi
 80016dc:	681a      	ldrmi	r2, [r3, #0]
 80016de:	f442 7200 	orrmi.w	r2, r2, #512	; 0x200
 80016e2:	601a      	strmi	r2, [r3, #0]
          }
          SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 80016e4:	681a      	ldr	r2, [r3, #0]
 80016e6:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80016ea:	601a      	str	r2, [r3, #0]
 80016ec:	e001      	b.n	80016f2 <HAL_SPI_TransmitReceive+0x176>
 80016ee:	2501      	movs	r5, #1
 80016f0:	e000      	b.n	80016f4 <HAL_SPI_TransmitReceive+0x178>
        {
          *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
          hspi->TxXferCount--;
        }
        /* Next Data is a reception (Rx). Tx not allowed */
        txallowed = 0U;
 80016f2:	2500      	movs	r5, #0
        }
#endif /* USE_SPI_CRC */
      }

      /* Wait until RXNE flag is reset */
      if ((hspi->RxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)))
 80016f4:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 80016f8:	b29b      	uxth	r3, r3
 80016fa:	b32b      	cbz	r3, 8001748 <HAL_SPI_TransmitReceive+0x1cc>
 80016fc:	6822      	ldr	r2, [r4, #0]
 80016fe:	6893      	ldr	r3, [r2, #8]
 8001700:	07db      	lsls	r3, r3, #31
 8001702:	d521      	bpl.n	8001748 <HAL_SPI_TransmitReceive+0x1cc>
      {
        if (hspi->RxXferCount > 1U)
 8001704:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8001708:	b29b      	uxth	r3, r3
 800170a:	2b01      	cmp	r3, #1
 800170c:	d912      	bls.n	8001734 <HAL_SPI_TransmitReceive+0x1b8>
        {
          *((uint16_t *)pRxData) = hspi->Instance->DR;
 800170e:	68d3      	ldr	r3, [r2, #12]
 8001710:	f827 3b02 	strh.w	r3, [r7], #2
          pRxData += sizeof(uint16_t);
          hspi->RxXferCount -= 2U;
 8001714:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8001718:	3b02      	subs	r3, #2
 800171a:	b29b      	uxth	r3, r3
 800171c:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
          if (hspi->RxXferCount <= 1U)
 8001720:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8001724:	b29b      	uxth	r3, r3
 8001726:	2b01      	cmp	r3, #1
 8001728:	d80d      	bhi.n	8001746 <HAL_SPI_TransmitReceive+0x1ca>
          {
            /* set fiforxthresold before to switch on 8 bit data size */
            SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800172a:	6853      	ldr	r3, [r2, #4]
 800172c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8001730:	6053      	str	r3, [r2, #4]
 8001732:	e008      	b.n	8001746 <HAL_SPI_TransmitReceive+0x1ca>
          }
        }
        else
        {
          (*(uint8_t *)pRxData++) = *(__IO uint8_t *)&hspi->Instance->DR;
 8001734:	7b13      	ldrb	r3, [r2, #12]
 8001736:	703b      	strb	r3, [r7, #0]
          hspi->RxXferCount--;
 8001738:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 800173c:	3b01      	subs	r3, #1
 800173e:	b29b      	uxth	r3, r3
 8001740:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
            SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
          }
        }
        else
        {
          (*(uint8_t *)pRxData++) = *(__IO uint8_t *)&hspi->Instance->DR;
 8001744:	3701      	adds	r7, #1
          hspi->RxXferCount--;
        }
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
 8001746:	2501      	movs	r5, #1
      }
      if ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout))
 8001748:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
 800174c:	d097      	beq.n	800167e <HAL_SPI_TransmitReceive+0x102>
 800174e:	f005 fc5d 	bl	800700c <HAL_GetTick>
 8001752:	ebc9 0000 	rsb	r0, r9, r0
 8001756:	4580      	cmp	r8, r0
 8001758:	d891      	bhi.n	800167e <HAL_SPI_TransmitReceive+0x102>
 800175a:	e048      	b.n	80017ee <HAL_SPI_TransmitReceive+0x272>
      {
        *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
        hspi->TxXferCount--;
      }
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 800175c:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 8001760:	b29b      	uxth	r3, r3
 8001762:	2b00      	cmp	r3, #0
 8001764:	d18f      	bne.n	8001686 <HAL_SPI_TransmitReceive+0x10a>
    }
//  }

#if (USE_SPI_CRC != 0U)
  /* Read CRC from DR to close CRC calculation process */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8001766:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001768:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800176c:	d126      	bne.n	80017bc <HAL_SPI_TransmitReceive+0x240>
  {
    /* Wait until TXE flag */
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
 800176e:	2201      	movs	r2, #1
 8001770:	4611      	mov	r1, r2
 8001772:	4620      	mov	r0, r4
 8001774:	f7ff fdcc 	bl	8001310 <SPI_WaitFlagStateUntilTimeout.isra.1>
 8001778:	b9a8      	cbnz	r0, 80017a6 <HAL_SPI_TransmitReceive+0x22a>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
      errorcode = HAL_TIMEOUT;
      goto error;
    }
    /* Read CRC */
    if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 800177a:	68e3      	ldr	r3, [r4, #12]
 800177c:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 8001780:	6823      	ldr	r3, [r4, #0]
 8001782:	d102      	bne.n	800178a <HAL_SPI_TransmitReceive+0x20e>
    {
      tmpreg = hspi->Instance->DR;
 8001784:	68db      	ldr	r3, [r3, #12]
 8001786:	b29b      	uxth	r3, r3
 8001788:	e014      	b.n	80017b4 <HAL_SPI_TransmitReceive+0x238>
      /* To avoid GCC warning */
      UNUSED(tmpreg);
    }
    else
    {
      tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 800178a:	7b1b      	ldrb	r3, [r3, #12]
 800178c:	f8ad 3006 	strh.w	r3, [sp, #6]
      /* To avoid GCC warning */
      UNUSED(tmpreg);
 8001790:	f8bd 3006 	ldrh.w	r3, [sp, #6]

      if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8001794:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001796:	2b02      	cmp	r3, #2
 8001798:	d110      	bne.n	80017bc <HAL_SPI_TransmitReceive+0x240>
      {
        if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
 800179a:	2201      	movs	r2, #1
 800179c:	4611      	mov	r1, r2
 800179e:	4620      	mov	r0, r4
 80017a0:	f7ff fdb6 	bl	8001310 <SPI_WaitFlagStateUntilTimeout.isra.1>
 80017a4:	b120      	cbz	r0, 80017b0 <HAL_SPI_TransmitReceive+0x234>
        {
          /* Error on the CRC reception */
          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 80017a6:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80017a8:	f043 0302 	orr.w	r3, r3, #2
 80017ac:	6623      	str	r3, [r4, #96]	; 0x60
 80017ae:	e01e      	b.n	80017ee <HAL_SPI_TransmitReceive+0x272>
          errorcode = HAL_TIMEOUT;
          goto error;
        }
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 80017b0:	6823      	ldr	r3, [r4, #0]
 80017b2:	7b1b      	ldrb	r3, [r3, #12]
 80017b4:	f8ad 3006 	strh.w	r3, [sp, #6]
        /* To avoid GCC warning */
        UNUSED(tmpreg);
 80017b8:	f8bd 3006 	ldrh.w	r3, [sp, #6]
      }
    }
  }

  /* Check if CRC error occurred */
  if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
 80017bc:	6822      	ldr	r2, [r4, #0]
 80017be:	6895      	ldr	r5, [r2, #8]
 80017c0:	f015 0510 	ands.w	r5, r5, #16
 80017c4:	d007      	beq.n	80017d6 <HAL_SPI_TransmitReceive+0x25a>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 80017c6:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80017c8:	f043 0302 	orr.w	r3, r3, #2
 80017cc:	6623      	str	r3, [r4, #96]	; 0x60
    /* Clear CRC Flag */
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 80017ce:	f64f 73ef 	movw	r3, #65519	; 0xffef
 80017d2:	6093      	str	r3, [r2, #8]

    errorcode = HAL_ERROR;
 80017d4:	2501      	movs	r5, #1
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 80017d6:	4620      	mov	r0, r4
 80017d8:	f7ff fda5 	bl	8001326 <SPI_EndRxTxTransaction.isra.2>
 80017dc:	b108      	cbz	r0, 80017e2 <HAL_SPI_TransmitReceive+0x266>
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 80017de:	2320      	movs	r3, #32
 80017e0:	6623      	str	r3, [r4, #96]	; 0x60
  }

  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 80017e2:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80017e4:	b123      	cbz	r3, 80017f0 <HAL_SPI_TransmitReceive+0x274>
  {
    errorcode = HAL_ERROR;
 80017e6:	2501      	movs	r5, #1
 80017e8:	e002      	b.n	80017f0 <HAL_SPI_TransmitReceive+0x274>
  tmp1 = hspi->Init.Mode;

  if (!((tmp == HAL_SPI_STATE_READY) || \
        ((tmp1 == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp == HAL_SPI_STATE_BUSY_RX))))
  {
    errorcode = HAL_BUSY;
 80017ea:	2502      	movs	r5, #2
 80017ec:	e000      	b.n	80017f0 <HAL_SPI_TransmitReceive+0x274>
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
      }
      if ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout))
      {
        errorcode = HAL_TIMEOUT;
 80017ee:	2503      	movs	r5, #3
  {
    errorcode = HAL_ERROR;
  }

error :
  hspi->State = HAL_SPI_STATE_READY;
 80017f0:	2301      	movs	r3, #1
 80017f2:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 80017f6:	2300      	movs	r3, #0
 80017f8:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  return errorcode;
 80017fc:	4628      	mov	r0, r5
 80017fe:	e000      	b.n	8001802 <HAL_SPI_TransmitReceive+0x286>

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8001800:	2002      	movs	r0, #2

error :
  hspi->State = HAL_SPI_STATE_READY;
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 8001802:	b003      	add	sp, #12
 8001804:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08001808 <HAL_SPI_Receive>:
  * @param  Size: amount of data to be received
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8001808:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 800180c:	461e      	mov	r6, r3
#if (USE_SPI_CRC != 0U)
  __IO uint16_t tmpreg = 0U;
 800180e:	2300      	movs	r3, #0
 8001810:	f8ad 300e 	strh.w	r3, [sp, #14]
#endif /* USE_SPI_CRC */
  uint32_t tickstart = 0U;
  HAL_StatusTypeDef errorcode = HAL_OK;


  if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 8001814:	6843      	ldr	r3, [r0, #4]
 8001816:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
  * @param  Size: amount of data to be received
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800181a:	4604      	mov	r4, r0
 800181c:	460d      	mov	r5, r1
 800181e:	4690      	mov	r8, r2
#endif /* USE_SPI_CRC */
  uint32_t tickstart = 0U;
  HAL_StatusTypeDef errorcode = HAL_OK;


  if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 8001820:	d10a      	bne.n	8001838 <HAL_SPI_Receive+0x30>
 8001822:	6883      	ldr	r3, [r0, #8]
 8001824:	b943      	cbnz	r3, 8001838 <HAL_SPI_Receive+0x30>
  {
    hspi->State = HAL_SPI_STATE_BUSY_RX;
 8001826:	2304      	movs	r3, #4
 8001828:	f880 305d 	strb.w	r3, [r0, #93]	; 0x5d
    /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
    return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
 800182c:	4613      	mov	r3, r2
 800182e:	9600      	str	r6, [sp, #0]
 8001830:	460a      	mov	r2, r1
 8001832:	f7ff fea3 	bl	800157c <HAL_SPI_TransmitReceive>
 8001836:	e100      	b.n	8001a3a <HAL_SPI_Receive+0x232>
  }

  /* Process Locked */
  __HAL_LOCK(hspi);
 8001838:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
 800183c:	2b01      	cmp	r3, #1
 800183e:	f000 80fb 	beq.w	8001a38 <HAL_SPI_Receive+0x230>
 8001842:	2301      	movs	r3, #1
 8001844:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 8001848:	f005 fbe0 	bl	800700c <HAL_GetTick>
 800184c:	4607      	mov	r7, r0

  if (hspi->State != HAL_SPI_STATE_READY)
 800184e:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
 8001852:	b2c0      	uxtb	r0, r0
 8001854:	2801      	cmp	r0, #1
 8001856:	f040 80e7 	bne.w	8001a28 <HAL_SPI_Receive+0x220>
  {
    errorcode = HAL_BUSY;
    goto error;
  }

  if ((pData == NULL) || (Size == 0U))
 800185a:	2d00      	cmp	r5, #0
 800185c:	f000 80e5 	beq.w	8001a2a <HAL_SPI_Receive+0x222>
 8001860:	f1b8 0f00 	cmp.w	r8, #0
 8001864:	f000 80e1 	beq.w	8001a2a <HAL_SPI_Receive+0x222>
    errorcode = HAL_ERROR;
    goto error;
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 8001868:	2304      	movs	r3, #4
 800186a:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  hspi->RxISR       = NULL;
  hspi->TxISR       = NULL;

#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800186e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pRxBuffPtr  = (uint8_t *)pData;
 8001870:	6425      	str	r5, [r4, #64]	; 0x40
    goto error;
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8001872:	2100      	movs	r1, #0
  hspi->RxISR       = NULL;
  hspi->TxISR       = NULL;

#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8001874:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
    goto error;
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8001878:	6621      	str	r1, [r4, #96]	; 0x60
  hspi->pRxBuffPtr  = (uint8_t *)pData;
  hspi->RxXferSize  = Size;
 800187a:	f8a4 8044 	strh.w	r8, [r4, #68]	; 0x44
  hspi->RxXferCount = Size;
 800187e:	f8a4 8046 	strh.w	r8, [r4, #70]	; 0x46

  /*Init field not used in handle to zero */
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
 8001882:	63a1      	str	r1, [r4, #56]	; 0x38
  hspi->TxXferSize  = 0U;
 8001884:	87a1      	strh	r1, [r4, #60]	; 0x3c
  hspi->TxXferCount = 0U;
 8001886:	87e1      	strh	r1, [r4, #62]	; 0x3e
  hspi->RxISR       = NULL;
 8001888:	64e1      	str	r1, [r4, #76]	; 0x4c
  hspi->TxISR       = NULL;
 800188a:	6521      	str	r1, [r4, #80]	; 0x50
 800188c:	6822      	ldr	r2, [r4, #0]

#if (USE_SPI_CRC != 0U)
  /* Reset CRC Calculation */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800188e:	d10d      	bne.n	80018ac <HAL_SPI_Receive+0xa4>
  {
    SPI_RESET_CRC(hspi);
 8001890:	6813      	ldr	r3, [r2, #0]
 8001892:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8001896:	6013      	str	r3, [r2, #0]
 8001898:	6813      	ldr	r3, [r2, #0]
 800189a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800189e:	6013      	str	r3, [r2, #0]
    /* this is done to handle the CRCNEXT before the latest data */
    hspi->RxXferCount--;
 80018a0:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 80018a4:	3b01      	subs	r3, #1
 80018a6:	b29b      	uxth	r3, r3
 80018a8:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
  }
#endif /* USE_SPI_CRC */

  /* Set the Rx Fifo threshold */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80018ac:	68e3      	ldr	r3, [r4, #12]
 80018ae:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
  {
    /* set fiforxthresold according the reception data length: 16bit */
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80018b2:	6853      	ldr	r3, [r2, #4]
 80018b4:	bf8c      	ite	hi
 80018b6:	f423 5380 	bichi.w	r3, r3, #4096	; 0x1000
  }
  else
  {
    /* set fiforxthresold according the reception data length: 8bit */
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80018ba:	f443 5380 	orrls.w	r3, r3, #4096	; 0x1000
 80018be:	6053      	str	r3, [r2, #4]
  }

  /* Configure communication direction: 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80018c0:	68a3      	ldr	r3, [r4, #8]
 80018c2:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  {
    SPI_1LINE_RX(hspi);
 80018c6:	bf02      	ittt	eq
 80018c8:	6813      	ldreq	r3, [r2, #0]
 80018ca:	f423 4380 	biceq.w	r3, r3, #16384	; 0x4000
 80018ce:	6013      	streq	r3, [r2, #0]
  }

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80018d0:	6813      	ldr	r3, [r2, #0]
 80018d2:	065b      	lsls	r3, r3, #25
 80018d4:	d411      	bmi.n	80018fa <HAL_SPI_Receive+0xf2>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 80018d6:	6813      	ldr	r3, [r2, #0]
 80018d8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80018dc:	6013      	str	r3, [r2, #0]
 80018de:	e00c      	b.n	80018fa <HAL_SPI_Receive+0xf2>
#endif
    /* Transfer loop */
    while (hspi->RxXferCount > 0U)
    {
      /* Check the RXNE flag */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 80018e0:	6823      	ldr	r3, [r4, #0]
 80018e2:	689a      	ldr	r2, [r3, #8]
 80018e4:	07d0      	lsls	r0, r2, #31
 80018e6:	d50e      	bpl.n	8001906 <HAL_SPI_Receive+0xfe>
      {
        /* read the received data */
        (* (uint8_t *)pData) = *(__IO uint8_t *)&hspi->Instance->DR;
 80018e8:	7b1b      	ldrb	r3, [r3, #12]
 80018ea:	f805 3b01 	strb.w	r3, [r5], #1
        pData += sizeof(uint8_t);
        hspi->RxXferCount--;
 80018ee:	f8b4 2046 	ldrh.w	r2, [r4, #70]	; 0x46
 80018f2:	3a01      	subs	r2, #1
 80018f4:	b292      	uxth	r2, r2
 80018f6:	f8a4 2046 	strh.w	r2, [r4, #70]	; 0x46
#if 0
  if (hspi->Init.DataSize <= SPI_DATASIZE_8BIT)
  {
#endif
    /* Transfer loop */
    while (hspi->RxXferCount > 0U)
 80018fa:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
 80018fe:	b29b      	uxth	r3, r3
 8001900:	2b00      	cmp	r3, #0
 8001902:	d1ed      	bne.n	80018e0 <HAL_SPI_Receive+0xd8>
 8001904:	e009      	b.n	800191a <HAL_SPI_Receive+0x112>
        hspi->RxXferCount--;
      }
      else
      {
        /* Timeout management */
        if ((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick() - tickstart) >=  Timeout)))
 8001906:	2e00      	cmp	r6, #0
 8001908:	d043      	beq.n	8001992 <HAL_SPI_Receive+0x18a>
 800190a:	1c71      	adds	r1, r6, #1
 800190c:	d0f5      	beq.n	80018fa <HAL_SPI_Receive+0xf2>
 800190e:	f005 fb7d 	bl	800700c <HAL_GetTick>
 8001912:	1bc0      	subs	r0, r0, r7
 8001914:	4286      	cmp	r6, r0
 8001916:	d8f0      	bhi.n	80018fa <HAL_SPI_Receive+0xf2>
 8001918:	e03b      	b.n	8001992 <HAL_SPI_Receive+0x18a>
  }
#endif

#if (USE_SPI_CRC != 0U)
  /* Handle the CRC Transmission */
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800191a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800191c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8001920:	d13f      	bne.n	80019a2 <HAL_SPI_Receive+0x19a>
  {
    /* freeze the CRC before the latest data */
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 8001922:	6822      	ldr	r2, [r4, #0]
 8001924:	6813      	ldr	r3, [r2, #0]
 8001926:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800192a:	6013      	str	r3, [r2, #0]

    /* Read the latest data */
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
 800192c:	2201      	movs	r2, #1
 800192e:	4611      	mov	r1, r2
 8001930:	4620      	mov	r0, r4
 8001932:	f7ff fced 	bl	8001310 <SPI_WaitFlagStateUntilTimeout.isra.1>
 8001936:	bb60      	cbnz	r0, 8001992 <HAL_SPI_Receive+0x18a>
      errorcode = HAL_TIMEOUT;
      goto error;
    }

    /* Receive last data in 16 Bit mode */
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8001938:	68e3      	ldr	r3, [r4, #12]
 800193a:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 800193e:	6823      	ldr	r3, [r4, #0]
    {
      (*(uint8_t *)pData) = *(__IO uint8_t *)&hspi->Instance->DR;
    }

    /* Wait the CRC data */
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
 8001940:	f04f 0201 	mov.w	r2, #1
    }

    /* Receive last data in 16 Bit mode */
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
    {
      *((uint16_t *)pData) = hspi->Instance->DR;
 8001944:	bf8b      	itete	hi
 8001946:	68db      	ldrhi	r3, [r3, #12]
    }
    /* Receive last data in 8 Bit mode */
    else
    {
      (*(uint8_t *)pData) = *(__IO uint8_t *)&hspi->Instance->DR;
 8001948:	7b1b      	ldrbls	r3, [r3, #12]
    }

    /* Receive last data in 16 Bit mode */
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
    {
      *((uint16_t *)pData) = hspi->Instance->DR;
 800194a:	802b      	strhhi	r3, [r5, #0]
    }
    /* Receive last data in 8 Bit mode */
    else
    {
      (*(uint8_t *)pData) = *(__IO uint8_t *)&hspi->Instance->DR;
 800194c:	702b      	strbls	r3, [r5, #0]
    }

    /* Wait the CRC data */
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
 800194e:	4611      	mov	r1, r2
 8001950:	4620      	mov	r0, r4
 8001952:	f7ff fcdd 	bl	8001310 <SPI_WaitFlagStateUntilTimeout.isra.1>
 8001956:	b9c0      	cbnz	r0, 800198a <HAL_SPI_Receive+0x182>
      errorcode = HAL_TIMEOUT;
      goto error;
    }

    /* Read CRC to Flush DR and RXNE flag */
    if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 8001958:	68e2      	ldr	r2, [r4, #12]
 800195a:	6823      	ldr	r3, [r4, #0]
 800195c:	f5b2 6f70 	cmp.w	r2, #3840	; 0xf00
 8001960:	d102      	bne.n	8001968 <HAL_SPI_Receive+0x160>
    {
      tmpreg = hspi->Instance->DR;
 8001962:	68db      	ldr	r3, [r3, #12]
 8001964:	b29b      	uxth	r3, r3
 8001966:	e018      	b.n	800199a <HAL_SPI_Receive+0x192>
      /* To avoid GCC warning */
      UNUSED(tmpreg);
    }
    else
    {
      tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8001968:	7b1b      	ldrb	r3, [r3, #12]
 800196a:	f8ad 300e 	strh.w	r3, [sp, #14]
      /* To avoid GCC warning */
      UNUSED(tmpreg);

      if ((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
 800196e:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
    }
    else
    {
      tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
      /* To avoid GCC warning */
      UNUSED(tmpreg);
 8001972:	f8bd 300e 	ldrh.w	r3, [sp, #14]

      if ((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT))
 8001976:	d114      	bne.n	80019a2 <HAL_SPI_Receive+0x19a>
 8001978:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800197a:	2b02      	cmp	r3, #2
 800197c:	d111      	bne.n	80019a2 <HAL_SPI_Receive+0x19a>
      {
        if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, Timeout, tickstart) != HAL_OK)
 800197e:	2201      	movs	r2, #1
 8001980:	4611      	mov	r1, r2
 8001982:	4620      	mov	r0, r4
 8001984:	f7ff fcc4 	bl	8001310 <SPI_WaitFlagStateUntilTimeout.isra.1>
 8001988:	b128      	cbz	r0, 8001996 <HAL_SPI_Receive+0x18e>
        {
          /* Error on the CRC reception */
          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 800198a:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800198c:	f043 0302 	orr.w	r3, r3, #2
 8001990:	6623      	str	r3, [r4, #96]	; 0x60
          errorcode = HAL_TIMEOUT;
 8001992:	2003      	movs	r0, #3
          goto error;
 8001994:	e049      	b.n	8001a2a <HAL_SPI_Receive+0x222>
        }
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8001996:	6823      	ldr	r3, [r4, #0]
 8001998:	7b1b      	ldrb	r3, [r3, #12]
 800199a:	f8ad 300e 	strh.w	r3, [sp, #14]
        /* To avoid GCC warning */
        UNUSED(tmpreg);
 800199e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
  * @param  Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout, uint32_t Tickstart)
{
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80019a2:	6863      	ldr	r3, [r4, #4]
 80019a4:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 80019a8:	d10b      	bne.n	80019c2 <HAL_SPI_Receive+0x1ba>
 80019aa:	68a3      	ldr	r3, [r4, #8]
 80019ac:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80019b0:	d002      	beq.n	80019b8 <HAL_SPI_Receive+0x1b0>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 80019b2:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80019b6:	d104      	bne.n	80019c2 <HAL_SPI_Receive+0x1ba>
  {
    /* Disable SPI peripheral */
    __HAL_SPI_DISABLE(hspi);
 80019b8:	6822      	ldr	r2, [r4, #0]
 80019ba:	6813      	ldr	r3, [r2, #0]
 80019bc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80019c0:	6013      	str	r3, [r2, #0]
  }

  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 80019c2:	2200      	movs	r2, #0
 80019c4:	2180      	movs	r1, #128	; 0x80
 80019c6:	4620      	mov	r0, r4
 80019c8:	f7ff fca2 	bl	8001310 <SPI_WaitFlagStateUntilTimeout.isra.1>
 80019cc:	6823      	ldr	r3, [r4, #0]
 80019ce:	b130      	cbz	r0, 80019de <HAL_SPI_Receive+0x1d6>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80019d0:	6e22      	ldr	r2, [r4, #96]	; 0x60
 80019d2:	f042 0220 	orr.w	r2, r2, #32
 80019d6:	6622      	str	r2, [r4, #96]	; 0x60
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTransaction(hspi, Timeout, tickstart) != HAL_OK)
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 80019d8:	2220      	movs	r2, #32
 80019da:	6622      	str	r2, [r4, #96]	; 0x60
 80019dc:	e015      	b.n	8001a0a <HAL_SPI_Receive+0x202>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }

  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80019de:	6862      	ldr	r2, [r4, #4]
 80019e0:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
 80019e4:	d111      	bne.n	8001a0a <HAL_SPI_Receive+0x202>
 80019e6:	68a2      	ldr	r2, [r4, #8]
 80019e8:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 80019ec:	d002      	beq.n	80019f4 <HAL_SPI_Receive+0x1ec>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 80019ee:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 80019f2:	d10a      	bne.n	8001a0a <HAL_SPI_Receive+0x202>
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
  __IO uint8_t tmpreg;

  while ((hspi->Instance->SR & Fifo) != State)
 80019f4:	689a      	ldr	r2, [r3, #8]
 80019f6:	f412 6fc0 	tst.w	r2, #1536	; 0x600
 80019fa:	d006      	beq.n	8001a0a <HAL_SPI_Receive+0x202>
  {
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
    {
      tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 80019fc:	7b1a      	ldrb	r2, [r3, #12]
 80019fe:	b2d2      	uxtb	r2, r2
 8001a00:	f88d 200d 	strb.w	r2, [sp, #13]
      /* To avoid GCC warning */
      UNUSED(tmpreg);
 8001a04:	f89d 200d 	ldrb.w	r2, [sp, #13]
 8001a08:	e7f4      	b.n	80019f4 <HAL_SPI_Receive+0x1ec>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
  }

#if (USE_SPI_CRC != 0U)
  /* Check if CRC error occurred */
  if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
 8001a0a:	689a      	ldr	r2, [r3, #8]
 8001a0c:	06d2      	lsls	r2, r2, #27
 8001a0e:	d506      	bpl.n	8001a1e <HAL_SPI_Receive+0x216>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8001a10:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8001a12:	f042 0202 	orr.w	r2, r2, #2
 8001a16:	6622      	str	r2, [r4, #96]	; 0x60
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 8001a18:	f64f 72ef 	movw	r2, #65519	; 0xffef
 8001a1c:	609a      	str	r2, [r3, #8]
  }
#endif /* USE_SPI_CRC */

  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8001a1e:	6e20      	ldr	r0, [r4, #96]	; 0x60
  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();

  if (hspi->State != HAL_SPI_STATE_READY)
  {
    errorcode = HAL_BUSY;
 8001a20:	3000      	adds	r0, #0
 8001a22:	bf18      	it	ne
 8001a24:	2001      	movne	r0, #1
 8001a26:	e000      	b.n	8001a2a <HAL_SPI_Receive+0x222>
 8001a28:	2002      	movs	r0, #2
  {
    errorcode = HAL_ERROR;
  }

error :
  hspi->State = HAL_SPI_STATE_READY;
 8001a2a:	2301      	movs	r3, #1
 8001a2c:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  __HAL_UNLOCK(hspi);
 8001a30:	2300      	movs	r3, #0
 8001a32:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
  return errorcode;
 8001a36:	e000      	b.n	8001a3a <HAL_SPI_Receive+0x232>
    /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
    return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
  }

  /* Process Locked */
  __HAL_LOCK(hspi);
 8001a38:	2002      	movs	r0, #2

error :
  hspi->State = HAL_SPI_STATE_READY;
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 8001a3a:	b004      	add	sp, #16
 8001a3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08001a40 <checksum_more>:

// checksum_more()
//
    static void
checksum_more(SHA256_CTX *ctx, uint32_t *total, const uint8_t *addr, int len)
{
 8001a40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001a42:	460d      	mov	r5, r1
    puts2("Verify %0x");
    puthex2(percent);
    putchar('\n');
#endif

    oled_show_progress(screen_verify, percent);
 8001a44:	6809      	ldr	r1, [r1, #0]

// checksum_more()
//
    static void
checksum_more(SHA256_CTX *ctx, uint32_t *total, const uint8_t *addr, int len)
{
 8001a46:	461c      	mov	r4, r3
    puts2("Verify %0x");
    puthex2(percent);
    putchar('\n');
#endif

    oled_show_progress(screen_verify, percent);
 8001a48:	2364      	movs	r3, #100	; 0x64
 8001a4a:	434b      	muls	r3, r1

// checksum_more()
//
    static void
checksum_more(SHA256_CTX *ctx, uint32_t *total, const uint8_t *addr, int len)
{
 8001a4c:	4617      	mov	r7, r2
 8001a4e:	4606      	mov	r6, r0
    puts2("Verify %0x");
    puthex2(percent);
    putchar('\n');
#endif

    oled_show_progress(screen_verify, percent);
 8001a50:	4907      	ldr	r1, [pc, #28]	; (8001a70 <checksum_more+0x30>)
 8001a52:	4808      	ldr	r0, [pc, #32]	; (8001a74 <checksum_more+0x34>)
 8001a54:	fbb3 f1f1 	udiv	r1, r3, r1
 8001a58:	f7ff fa0e 	bl	8000e78 <oled_show_progress>

    sha256_update(ctx, addr, len);
 8001a5c:	4622      	mov	r2, r4
 8001a5e:	4639      	mov	r1, r7
 8001a60:	4630      	mov	r0, r6
 8001a62:	f003 fc85 	bl	8005370 <sha256_update>
    *total += len;
 8001a66:	682b      	ldr	r3, [r5, #0]
 8001a68:	441c      	add	r4, r3
 8001a6a:	602c      	str	r4, [r5, #0]
 8001a6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001a6e:	bf00      	nop
 8001a70:	0018741c 	.word	0x0018741c
 8001a74:	0800d622 	.word	0x0800d622

08001a78 <checksum_flash>:

// checksum_flash()
//
    void
checksum_flash(uint8_t fw_digest[32], uint8_t world_digest[32], uint32_t fw_length)
{
 8001a78:	b570      	push	{r4, r5, r6, lr}
 8001a7a:	b09c      	sub	sp, #112	; 0x70
 8001a7c:	4606      	mov	r6, r0
 8001a7e:	460d      	mov	r5, r1
 8001a80:	4614      	mov	r4, r2
    const uint8_t *start = (const uint8_t *)FIRMWARE_START;

    rng_delay();
 8001a82:	f000 fe58 	bl	8002736 <rng_delay>

    SHA256_CTX  ctx;
    uint32_t    total_len = 0;
 8001a86:	2300      	movs	r3, #0
 8001a88:	9300      	str	r3, [sp, #0]

    if(fw_length == 0) {
 8001a8a:	b9e4      	cbnz	r4, 8001ac6 <checksum_flash+0x4e>
        uint8_t first[32];
        sha256_init(&ctx);
 8001a8c:	a809      	add	r0, sp, #36	; 0x24
 8001a8e:	f003 fc5f 	bl	8005350 <sha256_init>

        // use length from header in flash
        fw_length = FW_HDR->firmware_length;
 8001a92:	4b37      	ldr	r3, [pc, #220]	; (8001b70 <checksum_flash+0xf8>)

        // start of firmware (just after we end) to header
        checksum_more(&ctx, &total_len, start, FW_HEADER_OFFSET + FW_HEADER_SIZE - 64);
 8001a94:	4a37      	ldr	r2, [pc, #220]	; (8001b74 <checksum_flash+0xfc>)
    if(fw_length == 0) {
        uint8_t first[32];
        sha256_init(&ctx);

        // use length from header in flash
        fw_length = FW_HDR->firmware_length;
 8001a96:	699c      	ldr	r4, [r3, #24]

        // start of firmware (just after we end) to header
        checksum_more(&ctx, &total_len, start, FW_HEADER_OFFSET + FW_HEADER_SIZE - 64);
 8001a98:	4669      	mov	r1, sp
 8001a9a:	a809      	add	r0, sp, #36	; 0x24
 8001a9c:	f44f 537f 	mov.w	r3, #16320	; 0x3fc0
 8001aa0:	f7ff ffce 	bl	8001a40 <checksum_more>

        // from after header to end
        checksum_more(&ctx, &total_len, start + FW_HEADER_OFFSET + FW_HEADER_SIZE, 
 8001aa4:	f5a4 4380 	sub.w	r3, r4, #16384	; 0x4000
 8001aa8:	4a33      	ldr	r2, [pc, #204]	; (8001b78 <checksum_flash+0x100>)
 8001aaa:	4669      	mov	r1, sp
 8001aac:	a809      	add	r0, sp, #36	; 0x24
 8001aae:	f7ff ffc7 	bl	8001a40 <checksum_more>
                                fw_length - (FW_HEADER_OFFSET + FW_HEADER_SIZE));

        sha256_final(&ctx, first);
 8001ab2:	a901      	add	r1, sp, #4
 8001ab4:	a809      	add	r0, sp, #36	; 0x24
 8001ab6:	f003 fca1 	bl	80053fc <sha256_final>

        // double SHA256
        sha256_single(first, sizeof(first), fw_digest);
 8001aba:	4632      	mov	r2, r6
 8001abc:	2120      	movs	r1, #32
 8001abe:	a801      	add	r0, sp, #4
 8001ac0:	f003 fcb0 	bl	8005424 <sha256_single>
 8001ac4:	e002      	b.n	8001acc <checksum_flash+0x54>
    } else {
        // fw_digest should already be populated by caller
        total_len = fw_length - 64;
 8001ac6:	f1a4 0340 	sub.w	r3, r4, #64	; 0x40
 8001aca:	9300      	str	r3, [sp, #0]
    }

    // start over, and get the rest of flash. All of it.
    sha256_init(&ctx);
 8001acc:	a809      	add	r0, sp, #36	; 0x24
 8001ace:	f003 fc3f 	bl	8005350 <sha256_init>

    // .. and chain in what we have so far
    sha256_update(&ctx, fw_digest, 32);
 8001ad2:	2220      	movs	r2, #32
 8001ad4:	4631      	mov	r1, r6
 8001ad6:	a809      	add	r0, sp, #36	; 0x24
 8001ad8:	f003 fc4a 	bl	8005370 <sha256_update>

    // bootloader, including pairing secret area.
    const uint8_t *base = (const uint8_t *)BL_FLASH_BASE;
    checksum_more(&ctx, &total_len, base, start-base);
 8001adc:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8001ae0:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8001ae4:	4669      	mov	r1, sp
 8001ae6:	a809      	add	r0, sp, #36	; 0x24
 8001ae8:	f7ff ffaa 	bl	8001a40 <checksum_more>

    // probably-blank area after firmware, and filesystem area
    const uint8_t *fs = start + fw_length;
 8001aec:	f104 6200 	add.w	r2, r4, #134217728	; 0x8000000
 8001af0:	f502 3200 	add.w	r2, r2, #131072	; 0x20000
    const uint8_t *last = base + MAIN_FLASH_SIZE;
    checksum_more(&ctx, &total_len, fs, last-fs);
 8001af4:	f1c2 6301 	rsb	r3, r2, #135266304	; 0x8100000
 8001af8:	f503 2300 	add.w	r3, r3, #524288	; 0x80000
 8001afc:	4669      	mov	r1, sp
 8001afe:	a809      	add	r0, sp, #36	; 0x24
 8001b00:	f7ff ff9e 	bl	8001a40 <checksum_more>

    rng_delay();
 8001b04:	f000 fe17 	bl	8002736 <rng_delay>

    // OTP area
    checksum_more(&ctx, &total_len, (void *)0x1fff7000, 0x400);
 8001b08:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001b0c:	4a1b      	ldr	r2, [pc, #108]	; (8001b7c <checksum_flash+0x104>)
 8001b0e:	4669      	mov	r1, sp
 8001b10:	a809      	add	r0, sp, #36	; 0x24
 8001b12:	f7ff ff95 	bl	8001a40 <checksum_more>

    // "just in case" ... the option bytes (2 banks)
    checksum_more(&ctx, &total_len, (void *)0x1fff7800, 0x28);
 8001b16:	2328      	movs	r3, #40	; 0x28
 8001b18:	4a19      	ldr	r2, [pc, #100]	; (8001b80 <checksum_flash+0x108>)
 8001b1a:	4669      	mov	r1, sp
 8001b1c:	a809      	add	r0, sp, #36	; 0x24
 8001b1e:	f7ff ff8f 	bl	8001a40 <checksum_more>
    checksum_more(&ctx, &total_len, (void *)0x1ffff800, 0x28);
 8001b22:	2328      	movs	r3, #40	; 0x28
 8001b24:	4a17      	ldr	r2, [pc, #92]	; (8001b84 <checksum_flash+0x10c>)
 8001b26:	4669      	mov	r1, sp
 8001b28:	a809      	add	r0, sp, #36	; 0x24
 8001b2a:	f7ff ff89 	bl	8001a40 <checksum_more>

    // System ROM (they say it can't change, but clearly
    // implemented as flash cells)
    checksum_more(&ctx, &total_len, (void *)0x1fff0000, 0x7000);
 8001b2e:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8001b32:	4a15      	ldr	r2, [pc, #84]	; (8001b88 <checksum_flash+0x110>)
 8001b34:	4669      	mov	r1, sp
 8001b36:	a809      	add	r0, sp, #36	; 0x24
 8001b38:	f7ff ff82 	bl	8001a40 <checksum_more>

    // device serial number, just for kicks
    checksum_more(&ctx, &total_len, (void *)0x1fff7590, 12);
 8001b3c:	230c      	movs	r3, #12
 8001b3e:	4a13      	ldr	r2, [pc, #76]	; (8001b8c <checksum_flash+0x114>)
 8001b40:	4669      	mov	r1, sp
 8001b42:	a809      	add	r0, sp, #36	; 0x24
 8001b44:	f7ff ff7c 	bl	8001a40 <checksum_more>

    ASSERT(total_len == TOTAL_CHECKSUM_LEN);
 8001b48:	9a00      	ldr	r2, [sp, #0]
 8001b4a:	4b11      	ldr	r3, [pc, #68]	; (8001b90 <checksum_flash+0x118>)
 8001b4c:	429a      	cmp	r2, r3
 8001b4e:	d002      	beq.n	8001b56 <checksum_flash+0xde>
 8001b50:	4810      	ldr	r0, [pc, #64]	; (8001b94 <checksum_flash+0x11c>)
 8001b52:	f7fe ff43 	bl	80009dc <fatal_error>
    
    sha256_final(&ctx, world_digest);
 8001b56:	4629      	mov	r1, r5
 8001b58:	a809      	add	r0, sp, #36	; 0x24
 8001b5a:	f003 fc4f 	bl	80053fc <sha256_final>

    // double SHA256 (a bitcoin fetish)
    sha256_single(world_digest, 32, world_digest);
 8001b5e:	462a      	mov	r2, r5
 8001b60:	2120      	movs	r1, #32
 8001b62:	4628      	mov	r0, r5
 8001b64:	f003 fc5e 	bl	8005424 <sha256_single>

    rng_delay();
 8001b68:	f000 fde5 	bl	8002736 <rng_delay>
}
 8001b6c:	b01c      	add	sp, #112	; 0x70
 8001b6e:	bd70      	pop	{r4, r5, r6, pc}
 8001b70:	08023f80 	.word	0x08023f80
 8001b74:	08020000 	.word	0x08020000
 8001b78:	08024000 	.word	0x08024000
 8001b7c:	1fff7000 	.word	0x1fff7000
 8001b80:	1fff7800 	.word	0x1fff7800
 8001b84:	1ffff800 	.word	0x1ffff800
 8001b88:	1fff0000 	.word	0x1fff0000
 8001b8c:	1fff7590 	.word	0x1fff7590
 8001b90:	0018741c 	.word	0x0018741c
 8001b94:	0800d550 	.word	0x0800d550

08001b98 <get_min_version>:
// Scan the OTP area and determine what the current min-version (timestamp)
// we can allow. All zeros if any if okay.
//
    void
get_min_version(uint8_t min_version[8])
{
 8001b98:	b570      	push	{r4, r5, r6, lr}
 8001b9a:	4605      	mov	r5, r0
    const uint8_t *otp = (const uint8_t *)OPT_FLASH_BASE;
 8001b9c:	4c0c      	ldr	r4, [pc, #48]	; (8001bd0 <get_min_version+0x38>)

    rng_delay();
    memset(min_version, 0, 8);

    for(int i=0; i<NUM_OPT_SLOTS; i++, otp+=8) {
 8001b9e:	4e0d      	ldr	r6, [pc, #52]	; (8001bd4 <get_min_version+0x3c>)
    void
get_min_version(uint8_t min_version[8])
{
    const uint8_t *otp = (const uint8_t *)OPT_FLASH_BASE;

    rng_delay();
 8001ba0:	f000 fdc9 	bl	8002736 <rng_delay>
    memset(min_version, 0, 8);
 8001ba4:	2300      	movs	r3, #0
 8001ba6:	602b      	str	r3, [r5, #0]
 8001ba8:	606b      	str	r3, [r5, #4]
        // is it programmed?
        if(otp[0] == 0xff) continue;

        // is it a timestamp value?
        if(otp[0] >= 0x40) continue;
        if(otp[0] < 0x10) continue;
 8001baa:	7823      	ldrb	r3, [r4, #0]
 8001bac:	3b10      	subs	r3, #16
 8001bae:	2b2f      	cmp	r3, #47	; 0x2f
 8001bb0:	d80a      	bhi.n	8001bc8 <get_min_version+0x30>

        if(memcmp(otp, min_version, 8) > 0) {
 8001bb2:	4629      	mov	r1, r5
 8001bb4:	2208      	movs	r2, #8
 8001bb6:	4620      	mov	r0, r4
 8001bb8:	f00b fc50 	bl	800d45c <memcmp>
 8001bbc:	2800      	cmp	r0, #0
            memcpy(min_version, otp, 8);
 8001bbe:	bfc1      	itttt	gt
 8001bc0:	4623      	movgt	r3, r4
 8001bc2:	cb03      	ldmiagt	r3!, {r0, r1}
 8001bc4:	6028      	strgt	r0, [r5, #0]
 8001bc6:	6069      	strgt	r1, [r5, #4]
    const uint8_t *otp = (const uint8_t *)OPT_FLASH_BASE;

    rng_delay();
    memset(min_version, 0, 8);

    for(int i=0; i<NUM_OPT_SLOTS; i++, otp+=8) {
 8001bc8:	3408      	adds	r4, #8
 8001bca:	42b4      	cmp	r4, r6
 8001bcc:	d1ed      	bne.n	8001baa <get_min_version+0x12>

        if(memcmp(otp, min_version, 8) > 0) {
            memcpy(min_version, otp, 8);
        }
    }
}
 8001bce:	bd70      	pop	{r4, r5, r6, pc}
 8001bd0:	1fff7000 	.word	0x1fff7000
 8001bd4:	1fff7400 	.word	0x1fff7400

08001bd8 <check_is_downgrade>:

// check_is_downgrade()
//
    bool
check_is_downgrade(const uint8_t timestamp[8], const char *version)
{
 8001bd8:	b513      	push	{r0, r1, r4, lr}
 8001bda:	4604      	mov	r4, r0
    if(version) {
 8001bdc:	b129      	cbz	r1, 8001bea <check_is_downgrade+0x12>
        int major = (version[1] == '.') ? (version[0]-'0') : 10;
 8001bde:	784b      	ldrb	r3, [r1, #1]
 8001be0:	2b2e      	cmp	r3, #46	; 0x2e
 8001be2:	d102      	bne.n	8001bea <check_is_downgrade+0x12>
        if(major < 3) {
 8001be4:	780b      	ldrb	r3, [r1, #0]
 8001be6:	2b32      	cmp	r3, #50	; 0x32
 8001be8:	dd09      	ble.n	8001bfe <check_is_downgrade+0x26>
        }
    }

    // look at FW_HDR->timestamp and compare to a growing list in main flash OTP
    uint8_t min[8];
    get_min_version(min);
 8001bea:	4668      	mov	r0, sp
 8001bec:	f7ff ffd4 	bl	8001b98 <get_min_version>

    return (memcmp(timestamp, min, 8) < 0);
 8001bf0:	2208      	movs	r2, #8
 8001bf2:	4669      	mov	r1, sp
 8001bf4:	4620      	mov	r0, r4
 8001bf6:	f00b fc31 	bl	800d45c <memcmp>
 8001bfa:	0fc0      	lsrs	r0, r0, #31
 8001bfc:	e000      	b.n	8001c00 <check_is_downgrade+0x28>
{
    if(version) {
        int major = (version[1] == '.') ? (version[0]-'0') : 10;
        if(major < 3) {
            // we require major version 3.0.0 or later (for mark3 hardware)
            return true;
 8001bfe:	2001      	movs	r0, #1
    // look at FW_HDR->timestamp and compare to a growing list in main flash OTP
    uint8_t min[8];
    get_min_version(min);

    return (memcmp(timestamp, min, 8) < 0);
}
 8001c00:	b002      	add	sp, #8
 8001c02:	bd10      	pop	{r4, pc}

08001c04 <warn_fishy_firmware>:

// warn_fishy_firmware()
//
    void
warn_fishy_firmware(const uint8_t *pixels)
{
 8001c04:	b538      	push	{r3, r4, r5, lr}
 8001c06:	4605      	mov	r5, r0
    const int wait = 100;
#else
    const int wait = 10;
#endif
    
    for(int i=0; i < wait; i++) {
 8001c08:	2400      	movs	r4, #0
        oled_show_progress(pixels, (i*100)/wait);
 8001c0a:	4621      	mov	r1, r4
 8001c0c:	4628      	mov	r0, r5
 8001c0e:	f7ff f933 	bl	8000e78 <oled_show_progress>
    const int wait = 100;
#else
    const int wait = 10;
#endif
    
    for(int i=0; i < wait; i++) {
 8001c12:	3401      	adds	r4, #1
        oled_show_progress(pixels, (i*100)/wait);

        delay_ms(250);
 8001c14:	20fa      	movs	r0, #250	; 0xfa
 8001c16:	f001 fe37 	bl	8003888 <delay_ms>
    const int wait = 100;
#else
    const int wait = 10;
#endif
    
    for(int i=0; i < wait; i++) {
 8001c1a:	2c64      	cmp	r4, #100	; 0x64
 8001c1c:	d1f5      	bne.n	8001c0a <warn_fishy_firmware+0x6>
        oled_show_progress(pixels, (i*100)/wait);

        delay_ms(250);
    }
}
 8001c1e:	bd38      	pop	{r3, r4, r5, pc}

08001c20 <verify_header>:

// verify_header()
//
    bool
verify_header(const coldcardFirmwareHeader_t *hdr)
{
 8001c20:	b510      	push	{r4, lr}
 8001c22:	4604      	mov	r4, r0
    rng_delay();
 8001c24:	f000 fd87 	bl	8002736 <rng_delay>

    if(hdr->magic_value != FW_HEADER_MAGIC) goto fail;
 8001c28:	6822      	ldr	r2, [r4, #0]
 8001c2a:	4b0c      	ldr	r3, [pc, #48]	; (8001c5c <verify_header+0x3c>)
 8001c2c:	429a      	cmp	r2, r3
 8001c2e:	d112      	bne.n	8001c56 <verify_header+0x36>
    if(hdr->version_string[0] == 0x0) goto fail;
 8001c30:	7b23      	ldrb	r3, [r4, #12]
 8001c32:	b173      	cbz	r3, 8001c52 <verify_header+0x32>
    if(hdr->timestamp[0] >= 0x40) goto fail;        // 22 yr product lifetime
 8001c34:	7923      	ldrb	r3, [r4, #4]
 8001c36:	2b3f      	cmp	r3, #63	; 0x3f
 8001c38:	d80d      	bhi.n	8001c56 <verify_header+0x36>
    if(hdr->firmware_length < FW_MIN_LENGTH) goto fail;
 8001c3a:	69a3      	ldr	r3, [r4, #24]
 8001c3c:	f5a3 2380 	sub.w	r3, r3, #262144	; 0x40000
 8001c40:	f5b3 2f38 	cmp.w	r3, #753664	; 0xb8000
 8001c44:	d807      	bhi.n	8001c56 <verify_header+0x36>
    if(hdr->firmware_length > FW_MAX_LENGTH) goto fail;
    if(hdr->pubkey_num >= NUM_KNOWN_PUBKEYS) goto fail;
 8001c46:	6960      	ldr	r0, [r4, #20]
 8001c48:	2805      	cmp	r0, #5
 8001c4a:	bf8c      	ite	hi
 8001c4c:	2000      	movhi	r0, #0
 8001c4e:	2001      	movls	r0, #1
 8001c50:	bd10      	pop	{r4, pc}

    return true;
fail:
    return false;
 8001c52:	4618      	mov	r0, r3
 8001c54:	bd10      	pop	{r4, pc}
 8001c56:	2000      	movs	r0, #0
}
 8001c58:	bd10      	pop	{r4, pc}
 8001c5a:	bf00      	nop
 8001c5c:	cc001234 	.word	0xcc001234

08001c60 <verify_signature>:
//
// Given double-sha256 over the firmware bytes, check the signature.
//
    bool
verify_signature(const coldcardFirmwareHeader_t *hdr, const uint8_t fw_check[32])
{
 8001c60:	b573      	push	{r0, r1, r4, r5, r6, lr}
    // this takes a few ms at least, not fast.
    int ok = uECC_verify(approved_pubkeys[hdr->pubkey_num], fw_check, 32,
 8001c62:	4a0c      	ldr	r2, [pc, #48]	; (8001c94 <verify_signature+0x34>)
 8001c64:	6944      	ldr	r4, [r0, #20]
//
// Given double-sha256 over the firmware bytes, check the signature.
//
    bool
verify_signature(const coldcardFirmwareHeader_t *hdr, const uint8_t fw_check[32])
{
 8001c66:	4605      	mov	r5, r0
    // this takes a few ms at least, not fast.
    int ok = uECC_verify(approved_pubkeys[hdr->pubkey_num], fw_check, 32,
 8001c68:	eb02 1484 	add.w	r4, r2, r4, lsl #6
//
// Given double-sha256 over the firmware bytes, check the signature.
//
    bool
verify_signature(const coldcardFirmwareHeader_t *hdr, const uint8_t fw_check[32])
{
 8001c6c:	460e      	mov	r6, r1
    // this takes a few ms at least, not fast.
    int ok = uECC_verify(approved_pubkeys[hdr->pubkey_num], fw_check, 32,
 8001c6e:	f004 fdb5 	bl	80067dc <uECC_secp256k1>
 8001c72:	f105 0340 	add.w	r3, r5, #64	; 0x40
 8001c76:	9000      	str	r0, [sp, #0]
 8001c78:	2220      	movs	r2, #32
 8001c7a:	4631      	mov	r1, r6
 8001c7c:	4620      	mov	r0, r4
 8001c7e:	f005 f83b 	bl	8006cf8 <uECC_verify>
 8001c82:	4604      	mov	r4, r0
                                    hdr->signature, uECC_secp256k1());

    //puts(ok ? "Sig ok" : "Sig fail");
    rng_delay();
 8001c84:	f000 fd57 	bl	8002736 <rng_delay>

    return ok;
}
 8001c88:	1c20      	adds	r0, r4, #0
 8001c8a:	bf18      	it	ne
 8001c8c:	2001      	movne	r0, #1
 8001c8e:	b002      	add	sp, #8
 8001c90:	bd70      	pop	{r4, r5, r6, pc}
 8001c92:	bf00      	nop
 8001c94:	0800e1df 	.word	0x0800e1df

08001c98 <verify_firmware_in_ram>:
// Check hdr, and even signature of protential new firmware in PSRAM.
// Returns checksum needed for 608
//
    bool
verify_firmware_in_ram(const uint8_t *start, uint32_t len, uint8_t world_check[32])
{
 8001c98:	b5f0      	push	{r4, r5, r6, r7, lr}
    const coldcardFirmwareHeader_t *hdr = (const coldcardFirmwareHeader_t *)
 8001c9a:	f500 547e 	add.w	r4, r0, #16256	; 0x3f80
// Check hdr, and even signature of protential new firmware in PSRAM.
// Returns checksum needed for 608
//
    bool
verify_firmware_in_ram(const uint8_t *start, uint32_t len, uint8_t world_check[32])
{
 8001c9e:	b09d      	sub	sp, #116	; 0x74
 8001ca0:	4606      	mov	r6, r0
    const coldcardFirmwareHeader_t *hdr = (const coldcardFirmwareHeader_t *)
                                                    (start + FW_HEADER_OFFSET);
    uint8_t fw_digest[32];

    // check basics like verison, hw compat, etc
    if(!verify_header(hdr)) goto fail;
 8001ca2:	4620      	mov	r0, r4
// Check hdr, and even signature of protential new firmware in PSRAM.
// Returns checksum needed for 608
//
    bool
verify_firmware_in_ram(const uint8_t *start, uint32_t len, uint8_t world_check[32])
{
 8001ca4:	4617      	mov	r7, r2
    const coldcardFirmwareHeader_t *hdr = (const coldcardFirmwareHeader_t *)
                                                    (start + FW_HEADER_OFFSET);
    uint8_t fw_digest[32];

    // check basics like verison, hw compat, etc
    if(!verify_header(hdr)) goto fail;
 8001ca6:	f7ff ffbb 	bl	8001c20 <verify_header>
 8001caa:	4605      	mov	r5, r0
 8001cac:	2800      	cmp	r0, #0
 8001cae:	d03b      	beq.n	8001d28 <verify_firmware_in_ram+0x90>

    if(check_is_downgrade(hdr->timestamp, (const char *)hdr->version_string)) {
 8001cb0:	f104 010c 	add.w	r1, r4, #12
 8001cb4:	1d20      	adds	r0, r4, #4
 8001cb6:	f7ff ff8f 	bl	8001bd8 <check_is_downgrade>
 8001cba:	4605      	mov	r5, r0
 8001cbc:	b120      	cbz	r0, 8001cc8 <verify_firmware_in_ram+0x30>
        puts("downgrade");
 8001cbe:	481c      	ldr	r0, [pc, #112]	; (8001d30 <verify_firmware_in_ram+0x98>)
 8001cc0:	f002 fff8 	bl	8004cb4 <puts>

    checksum_flash(fw_digest, world_check, hdr->firmware_length);

    return true;
fail:
    return false;
 8001cc4:	2500      	movs	r5, #0
    // check basics like verison, hw compat, etc
    if(!verify_header(hdr)) goto fail;

    if(check_is_downgrade(hdr->timestamp, (const char *)hdr->version_string)) {
        puts("downgrade");
        goto fail;
 8001cc6:	e02f      	b.n	8001d28 <verify_firmware_in_ram+0x90>
    }

    rng_delay();
 8001cc8:	f000 fd35 	bl	8002736 <rng_delay>

    SHA256_CTX  ctx;
    uint32_t    total_len = 0;

    sha256_init(&ctx);
 8001ccc:	a809      	add	r0, sp, #36	; 0x24
    }

    rng_delay();

    SHA256_CTX  ctx;
    uint32_t    total_len = 0;
 8001cce:	9500      	str	r5, [sp, #0]

    sha256_init(&ctx);
 8001cd0:	f003 fb3e 	bl	8005350 <sha256_init>

    // start of firmware up to header's signature
    checksum_more(&ctx, &total_len, start, FW_HEADER_OFFSET + FW_HEADER_SIZE - 64);
 8001cd4:	f44f 537f 	mov.w	r3, #16320	; 0x3fc0
 8001cd8:	4632      	mov	r2, r6
 8001cda:	4669      	mov	r1, sp
 8001cdc:	a809      	add	r0, sp, #36	; 0x24
 8001cde:	f7ff feaf 	bl	8001a40 <checksum_more>

    // from after header to end
    checksum_more(&ctx, &total_len, start + FW_HEADER_OFFSET + FW_HEADER_SIZE, 
 8001ce2:	69a3      	ldr	r3, [r4, #24]
 8001ce4:	f506 4280 	add.w	r2, r6, #16384	; 0x4000
 8001ce8:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
 8001cec:	4669      	mov	r1, sp
 8001cee:	a809      	add	r0, sp, #36	; 0x24
 8001cf0:	f7ff fea6 	bl	8001a40 <checksum_more>
                            hdr->firmware_length - (FW_HEADER_OFFSET + FW_HEADER_SIZE));

    // double SHA256
    sha256_final(&ctx, fw_digest);
 8001cf4:	a901      	add	r1, sp, #4
 8001cf6:	a809      	add	r0, sp, #36	; 0x24
 8001cf8:	f003 fb80 	bl	80053fc <sha256_final>
    sha256_single(fw_digest, 32, fw_digest);
 8001cfc:	aa01      	add	r2, sp, #4
 8001cfe:	4610      	mov	r0, r2
 8001d00:	2120      	movs	r1, #32
 8001d02:	f003 fb8f 	bl	8005424 <sha256_single>

    rng_delay();
 8001d06:	f000 fd16 	bl	8002736 <rng_delay>

    if(!verify_signature(hdr, fw_digest)) {
 8001d0a:	a901      	add	r1, sp, #4
 8001d0c:	4620      	mov	r0, r4
 8001d0e:	f7ff ffa7 	bl	8001c60 <verify_signature>
 8001d12:	4605      	mov	r5, r0
 8001d14:	b918      	cbnz	r0, 8001d1e <verify_firmware_in_ram+0x86>
        puts("sig fail");
 8001d16:	4807      	ldr	r0, [pc, #28]	; (8001d34 <verify_firmware_in_ram+0x9c>)
 8001d18:	f002 ffcc 	bl	8004cb4 <puts>
        goto fail;
 8001d1c:	e004      	b.n	8001d28 <verify_firmware_in_ram+0x90>
    }

    checksum_flash(fw_digest, world_check, hdr->firmware_length);
 8001d1e:	69a2      	ldr	r2, [r4, #24]
 8001d20:	4639      	mov	r1, r7
 8001d22:	a801      	add	r0, sp, #4
 8001d24:	f7ff fea8 	bl	8001a78 <checksum_flash>

    return true;
fail:
    return false;
}
 8001d28:	4628      	mov	r0, r5
 8001d2a:	b01d      	add	sp, #116	; 0x74
 8001d2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001d2e:	bf00      	nop
 8001d30:	0800e179 	.word	0x0800e179
 8001d34:	0800e183 	.word	0x0800e183

08001d38 <verify_world_checksum>:
// - don't set the light at this point.
// - requires bootloader to have been unchanged since world_check recorded (debug issue)
//
    bool
verify_world_checksum(const uint8_t world_check[32])
{
 8001d38:	b510      	push	{r4, lr}
 8001d3a:	4604      	mov	r4, r0
    ae_setup();
 8001d3c:	f000 fe30 	bl	80029a0 <ae_setup>
    ae_pair_unlock();
 8001d40:	f001 f82e 	bl	8002da0 <ae_pair_unlock>

    return (ae_checkmac_hard(KEYNUM_firmware, world_check) == 0);
 8001d44:	4621      	mov	r1, r4
 8001d46:	200e      	movs	r0, #14
 8001d48:	f001 f994 	bl	8003074 <ae_checkmac_hard>
}
 8001d4c:	fab0 f080 	clz	r0, r0
 8001d50:	0940      	lsrs	r0, r0, #5
 8001d52:	bd10      	pop	{r4, pc}

08001d54 <verify_firmware>:

// verify_firmware()
//
    bool
verify_firmware(void)
{
 8001d54:	b570      	push	{r4, r5, r6, lr}
    STATIC_ASSERT(sizeof(coldcardFirmwareHeader_t) == FW_HEADER_SIZE);

    rng_delay();

    // watch for unprogrammed header. and some 
    if(FW_HDR->version_string[0] == 0xff) goto blank;
 8001d56:	4d21      	ldr	r5, [pc, #132]	; (8001ddc <verify_firmware+0x88>)

// verify_firmware()
//
    bool
verify_firmware(void)
{
 8001d58:	b090      	sub	sp, #64	; 0x40
    STATIC_ASSERT(sizeof(coldcardFirmwareHeader_t) == FW_HEADER_SIZE);

    rng_delay();
 8001d5a:	f000 fcec 	bl	8002736 <rng_delay>

    // watch for unprogrammed header. and some 
    if(FW_HDR->version_string[0] == 0xff) goto blank;
 8001d5e:	7b2b      	ldrb	r3, [r5, #12]
 8001d60:	2bff      	cmp	r3, #255	; 0xff
 8001d62:	d031      	beq.n	8001dc8 <verify_firmware+0x74>
    if(!verify_header(FW_HDR)) goto fail;
 8001d64:	4628      	mov	r0, r5
 8001d66:	f7ff ff5b 	bl	8001c20 <verify_header>
 8001d6a:	b358      	cbz	r0, 8001dc4 <verify_firmware+0x70>

    rng_delay();
 8001d6c:	f000 fce3 	bl	8002736 <rng_delay>

    // measure checksum
    uint8_t fw_check[32], world_check[32];
    checksum_flash(fw_check, world_check, 0);
 8001d70:	2200      	movs	r2, #0
 8001d72:	a908      	add	r1, sp, #32
 8001d74:	4668      	mov	r0, sp
 8001d76:	f7ff fe7f 	bl	8001a78 <checksum_flash>

    rng_delay();
 8001d7a:	f000 fcdc 	bl	8002736 <rng_delay>

    // Verify the signature
    // - use pubkey_num to pick a specific key
    if(!verify_signature(FW_HDR, fw_check)) goto fail;
 8001d7e:	4669      	mov	r1, sp
 8001d80:	4628      	mov	r0, r5
 8001d82:	f7ff ff6d 	bl	8001c60 <verify_signature>
 8001d86:	4604      	mov	r4, r0
 8001d88:	b1e0      	cbz	r0, 8001dc4 <verify_firmware+0x70>
 
    // Push the hash to the SE which might make the Genuine light green,
    // but only if we arrived at same hash before. It decides.
    int not_green = ae_set_gpio_secure(world_check);
 8001d8a:	a808      	add	r0, sp, #32
 8001d8c:	f001 fb7b 	bl	8003486 <ae_set_gpio_secure>
 8001d90:	4606      	mov	r6, r0

    rng_delay();
 8001d92:	f000 fcd0 	bl	8002736 <rng_delay>

    // show big/slow warning if light is not green
    if(not_green) {
 8001d96:	b126      	cbz	r6, 8001da2 <verify_firmware+0x4e>
        // When light is not green; some part of flash (not firmware area)
        // is changed. these are typically false-positives, unfortunately.
        puts("WARN: Red light");
 8001d98:	4811      	ldr	r0, [pc, #68]	; (8001de0 <verify_firmware+0x8c>)
 8001d9a:	f002 ff8b 	bl	8004cb4 <puts>
        warn_fishy_firmware(screen_red_light);
 8001d9e:	4811      	ldr	r0, [pc, #68]	; (8001de4 <verify_firmware+0x90>)
 8001da0:	e005      	b.n	8001dae <verify_firmware+0x5a>
    } else if(FW_HDR->pubkey_num == 0) {
 8001da2:	696b      	ldr	r3, [r5, #20]
 8001da4:	b933      	cbnz	r3, 8001db4 <verify_firmware+0x60>
        // public signing key used; firmware not from Coinkite!
        puts("WARN: Unsigned firmware");
 8001da6:	4810      	ldr	r0, [pc, #64]	; (8001de8 <verify_firmware+0x94>)
 8001da8:	f002 ff84 	bl	8004cb4 <puts>
        warn_fishy_firmware(screen_devmode);
 8001dac:	480f      	ldr	r0, [pc, #60]	; (8001dec <verify_firmware+0x98>)
 8001dae:	f7ff ff29 	bl	8001c04 <warn_fishy_firmware>
 8001db2:	e010      	b.n	8001dd6 <verify_firmware+0x82>
    } else {
        oled_show_progress(screen_verify, 100);
 8001db4:	2164      	movs	r1, #100	; 0x64
 8001db6:	480e      	ldr	r0, [pc, #56]	; (8001df0 <verify_firmware+0x9c>)
 8001db8:	f7ff f85e 	bl	8000e78 <oled_show_progress>
        puts("Good firmware");
 8001dbc:	480d      	ldr	r0, [pc, #52]	; (8001df4 <verify_firmware+0xa0>)
 8001dbe:	f002 ff79 	bl	8004cb4 <puts>
 8001dc2:	e008      	b.n	8001dd6 <verify_firmware+0x82>
    }

    return true;

fail:
    puts("corrupt firmware");
 8001dc4:	480c      	ldr	r0, [pc, #48]	; (8001df8 <verify_firmware+0xa4>)
 8001dc6:	e000      	b.n	8001dca <verify_firmware+0x76>
    oled_show(screen_corrupt);
    return false;

blank:
    puts("no firmware");
 8001dc8:	480c      	ldr	r0, [pc, #48]	; (8001dfc <verify_firmware+0xa8>)
 8001dca:	f002 ff73 	bl	8004cb4 <puts>
    oled_show(screen_corrupt);
 8001dce:	480c      	ldr	r0, [pc, #48]	; (8001e00 <verify_firmware+0xac>)
 8001dd0:	f7ff f810 	bl	8000df4 <oled_show>
    //enter_dfu();

    return false;
 8001dd4:	2400      	movs	r4, #0
}
 8001dd6:	4620      	mov	r0, r4
 8001dd8:	b010      	add	sp, #64	; 0x40
 8001dda:	bd70      	pop	{r4, r5, r6, pc}
 8001ddc:	08023f80 	.word	0x08023f80
 8001de0:	0800e18c 	.word	0x0800e18c
 8001de4:	0800dad0 	.word	0x0800dad0
 8001de8:	0800e19c 	.word	0x0800e19c
 8001dec:	0800d796 	.word	0x0800d796
 8001df0:	0800d622 	.word	0x0800d622
 8001df4:	0800e1b4 	.word	0x0800e1b4
 8001df8:	0800e1c2 	.word	0x0800e1c2
 8001dfc:	0800e1d3 	.word	0x0800e1d3
 8001e00:	0800d6e3 	.word	0x0800d6e3

08001e04 <systick_setup>:
    void
systick_setup(void)
{
    const uint32_t ticks = HCLK_FREQUENCY/1000;

    SysTick->LOAD = (ticks - 1);
 8001e04:	4b03      	ldr	r3, [pc, #12]	; (8001e14 <systick_setup+0x10>)
 8001e06:	4a04      	ldr	r2, [pc, #16]	; (8001e18 <systick_setup+0x14>)
 8001e08:	605a      	str	r2, [r3, #4]
    SysTick->VAL = 0;
 8001e0a:	2200      	movs	r2, #0
 8001e0c:	609a      	str	r2, [r3, #8]
    SysTick->CTRL = SYSTICK_CLKSOURCE_HCLK | SysTick_CTRL_ENABLE_Msk;
 8001e0e:	2205      	movs	r2, #5
 8001e10:	601a      	str	r2, [r3, #0]
 8001e12:	4770      	bx	lr
 8001e14:	e000e010 	.word	0xe000e010
 8001e18:	0001d4bf 	.word	0x0001d4bf

08001e1c <system_init0>:
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#endif

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 8001e1c:	4a0e      	ldr	r2, [pc, #56]	; (8001e58 <system_init0+0x3c>)
 8001e1e:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8001e22:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8001e26:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
#endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8001e2a:	4b0c      	ldr	r3, [pc, #48]	; (8001e5c <system_init0+0x40>)
 8001e2c:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000U;
 8001e2e:	2100      	movs	r1, #0
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
#endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8001e30:	f042 0201 	orr.w	r2, r2, #1
 8001e34:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000U;
 8001e36:	6099      	str	r1, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= 0xEAF6FFFFU;
 8001e38:	681a      	ldr	r2, [r3, #0]
 8001e3a:	f022 52a8 	bic.w	r2, r2, #352321536	; 0x15000000
 8001e3e:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
 8001e42:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00001000U;
 8001e44:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8001e48:	60da      	str	r2, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8001e4a:	681a      	ldr	r2, [r3, #0]
 8001e4c:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8001e50:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000U;
 8001e52:	6199      	str	r1, [r3, #24]
 8001e54:	4770      	bx	lr
 8001e56:	bf00      	nop
 8001e58:	e000ed00 	.word	0xe000ed00
 8001e5c:	40021000 	.word	0x40021000

08001e60 <clocks_setup>:

// clocks_setup()
//
    void
clocks_setup(void)
{
 8001e60:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

    // setup power supplies
    HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);

    // Configure LSE Drive Capability
    __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
 8001e64:	4c42      	ldr	r4, [pc, #264]	; (8001f70 <clocks_setup+0x110>)

// clocks_setup()
//
    void
clocks_setup(void)
{
 8001e66:	b0c1      	sub	sp, #260	; 0x104
    RCC_ClkInitTypeDef RCC_ClkInitStruct;
    RCC_OscInitTypeDef RCC_OscInitStruct;

    // setup power supplies
    HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);
 8001e68:	2000      	movs	r0, #0
 8001e6a:	f005 f8e5 	bl	8007038 <HAL_PWREx_ControlVoltageScaling>

    // Configure LSE Drive Capability
    __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
 8001e6e:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 8001e72:	f023 0318 	bic.w	r3, r3, #24
 8001e76:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90

    // Enable HSE Oscillator and activate PLL with HSE as source
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8001e7a:	2301      	movs	r3, #1
 8001e7c:	930a      	str	r3, [sp, #40]	; 0x28

    RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8001e7e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8001e82:	930b      	str	r3, [sp, #44]	; 0x2c
    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;

    // Select PLL as system clock source and configure
    // the HCLK, PCLK1 and PCLK2 clocks dividers
    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK 
 8001e84:	230f      	movs	r3, #15

    // Enable HSE Oscillator and activate PLL with HSE as source
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;

    RCC_OscInitStruct.HSEState = RCC_HSE_ON;
    RCC_OscInitStruct.LSEState = RCC_LSE_OFF;
 8001e86:	2500      	movs	r5, #0
    RCC_OscInitStruct.MSIState = RCC_MSI_OFF;

    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8001e88:	2602      	movs	r6, #2

    RCC_OscInitStruct.HSEState = RCC_HSE_ON;
    RCC_OscInitStruct.LSEState = RCC_LSE_OFF;
    RCC_OscInitStruct.MSIState = RCC_MSI_OFF;

    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8001e8a:	2703      	movs	r7, #3
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;

    // Select PLL as system clock source and configure
    // the HCLK, PCLK1 and PCLK2 clocks dividers
    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK 
 8001e8c:	9305      	str	r3, [sp, #20]
                                    | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;

    RCC_OscInitStruct.PLL.PLLM = CKCC_CLK_PLLM;
    RCC_OscInitStruct.PLL.PLLN = CKCC_CLK_PLLN;
    RCC_OscInitStruct.PLL.PLLP = CKCC_CLK_PLLP;
 8001e8e:	f04f 0807 	mov.w	r8, #7
    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK 
                                    | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;

    RCC_OscInitStruct.PLL.PLLM = CKCC_CLK_PLLM;
    RCC_OscInitStruct.PLL.PLLN = CKCC_CLK_PLLN;
 8001e92:	233c      	movs	r3, #60	; 0x3c
    RCC_OscInitStruct.PLL.PLLP = CKCC_CLK_PLLP;
    RCC_OscInitStruct.PLL.PLLQ = CKCC_CLK_PLLQ;
 8001e94:	f04f 0905 	mov.w	r9, #5

    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

    HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8001e98:	a80a      	add	r0, sp, #40	; 0x28
    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK 
                                    | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;

    RCC_OscInitStruct.PLL.PLLM = CKCC_CLK_PLLM;
    RCC_OscInitStruct.PLL.PLLN = CKCC_CLK_PLLN;
 8001e9a:	9317      	str	r3, [sp, #92]	; 0x5c

    // Enable HSE Oscillator and activate PLL with HSE as source
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;

    RCC_OscInitStruct.HSEState = RCC_HSE_ON;
    RCC_OscInitStruct.LSEState = RCC_LSE_OFF;
 8001e9c:	950c      	str	r5, [sp, #48]	; 0x30
    RCC_OscInitStruct.MSIState = RCC_MSI_OFF;
 8001e9e:	9510      	str	r5, [sp, #64]	; 0x40

    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8001ea0:	9715      	str	r7, [sp, #84]	; 0x54
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8001ea2:	9614      	str	r6, [sp, #80]	; 0x50

    // Select PLL as system clock source and configure
    // the HCLK, PCLK1 and PCLK2 clocks dividers
    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK 
                                    | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8001ea4:	9706      	str	r7, [sp, #24]

    RCC_OscInitStruct.PLL.PLLM = CKCC_CLK_PLLM;
 8001ea6:	9616      	str	r6, [sp, #88]	; 0x58
    RCC_OscInitStruct.PLL.PLLN = CKCC_CLK_PLLN;
    RCC_OscInitStruct.PLL.PLLP = CKCC_CLK_PLLP;
 8001ea8:	f8cd 8060 	str.w	r8, [sp, #96]	; 0x60
    RCC_OscInitStruct.PLL.PLLQ = CKCC_CLK_PLLQ;
 8001eac:	f8cd 9064 	str.w	r9, [sp, #100]	; 0x64
    RCC_OscInitStruct.PLL.PLLR = CKCC_CLK_PLLR;
 8001eb0:	961a      	str	r6, [sp, #104]	; 0x68

    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8001eb2:	9507      	str	r5, [sp, #28]
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8001eb4:	9508      	str	r5, [sp, #32]
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8001eb6:	9509      	str	r5, [sp, #36]	; 0x24

    HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8001eb8:	f006 fb8e 	bl	80085d8 <HAL_RCC_OscConfig>

    HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
 8001ebc:	4649      	mov	r1, r9
 8001ebe:	a805      	add	r0, sp, #20
 8001ec0:	f006 fe44 	bl	8008b4c <HAL_RCC_ClockConfig>

    // DIS-able MSI-Hardware auto calibration mode with LSE
    CLEAR_BIT(RCC->CR, RCC_CR_MSIPLLEN);
 8001ec4:	6823      	ldr	r3, [r4, #0]
 8001ec6:	f023 0304 	bic.w	r3, r3, #4
 8001eca:	6023      	str	r3, [r4, #0]

    RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SAI1|RCC_PERIPHCLK_I2C2
 8001ecc:	4b29      	ldr	r3, [pc, #164]	; (8001f74 <clocks_setup+0x114>)
 8001ece:	931b      	str	r3, [sp, #108]	; 0x6c

    // PLLSAI is used to clock USB, ADC, I2C1 and RNG. The frequency is
    // HSE(8MHz)/PLLM(2)*PLLSAI1N(24)/PLLSAIQ(2) = 48MHz.
    //
    PeriphClkInitStruct.Sai1ClockSelection = RCC_SAI1CLKSOURCE_PLLSAI1;
    PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
 8001ed0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8001ed4:	933b      	str	r3, [sp, #236]	; 0xec
    PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;
 8001ed6:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8001eda:	9338      	str	r3, [sp, #224]	; 0xe0
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;           // XXX wrong?
    PeriphClkInitStruct.RngClockSelection = RCC_RNGCLKSOURCE_PLLSAI1;
 8001edc:	933a      	str	r3, [sp, #232]	; 0xe8

    PeriphClkInitStruct.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_HSE;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1M = 2;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1N = 24;
 8001ede:	2318      	movs	r3, #24
    // HSE(8MHz)/PLLM(2)*PLLSAI1N(24)/PLLSAIQ(2) = 48MHz.
    //
    PeriphClkInitStruct.Sai1ClockSelection = RCC_SAI1CLKSOURCE_PLLSAI1;
    PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
    PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;           // XXX wrong?
 8001ee0:	f44f 7280 	mov.w	r2, #256	; 0x100
    PeriphClkInitStruct.RngClockSelection = RCC_RNGCLKSOURCE_PLLSAI1;

    PeriphClkInitStruct.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_HSE;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1M = 2;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1N = 24;
 8001ee4:	931e      	str	r3, [sp, #120]	; 0x78
    PeriphClkInitStruct.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_SAI1CLK
                                                 |RCC_PLLSAI1_48M2CLK
                                                 |RCC_PLLSAI1_ADC1CLK;

    HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
 8001ee6:	a81b      	add	r0, sp, #108	; 0x6c
    PeriphClkInitStruct.PLLSAI1.PLLSAI1M = 2;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1N = 24;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_SAI1CLK
 8001ee8:	4b23      	ldr	r3, [pc, #140]	; (8001f78 <clocks_setup+0x118>)
    // HSE(8MHz)/PLLM(2)*PLLSAI1N(24)/PLLSAIQ(2) = 48MHz.
    //
    PeriphClkInitStruct.Sai1ClockSelection = RCC_SAI1CLKSOURCE_PLLSAI1;
    PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
    PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;           // XXX wrong?
 8001eea:	923f      	str	r2, [sp, #252]	; 0xfc
    PeriphClkInitStruct.PLLSAI1.PLLSAI1M = 2;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1N = 24;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_SAI1CLK
 8001eec:	9322      	str	r3, [sp, #136]	; 0x88
    RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SAI1|RCC_PERIPHCLK_I2C2
                                              |RCC_PERIPHCLK_USB |RCC_PERIPHCLK_ADC
                                              |RCC_PERIPHCLK_RNG |RCC_PERIPHCLK_RTC;

    PeriphClkInitStruct.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
 8001eee:	9531      	str	r5, [sp, #196]	; 0xc4

    // PLLSAI is used to clock USB, ADC, I2C1 and RNG. The frequency is
    // HSE(8MHz)/PLLM(2)*PLLSAI1N(24)/PLLSAIQ(2) = 48MHz.
    //
    PeriphClkInitStruct.Sai1ClockSelection = RCC_SAI1CLKSOURCE_PLLSAI1;
 8001ef0:	9536      	str	r5, [sp, #216]	; 0xd8
    PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
    PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;           // XXX wrong?
    PeriphClkInitStruct.RngClockSelection = RCC_RNGCLKSOURCE_PLLSAI1;

    PeriphClkInitStruct.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_HSE;
 8001ef2:	971c      	str	r7, [sp, #112]	; 0x70
    PeriphClkInitStruct.PLLSAI1.PLLSAI1M = 2;
 8001ef4:	961d      	str	r6, [sp, #116]	; 0x74
    PeriphClkInitStruct.PLLSAI1.PLLSAI1N = 24;
    PeriphClkInitStruct.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
 8001ef6:	f8cd 807c 	str.w	r8, [sp, #124]	; 0x7c
    PeriphClkInitStruct.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
 8001efa:	9620      	str	r6, [sp, #128]	; 0x80
    PeriphClkInitStruct.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
 8001efc:	9621      	str	r6, [sp, #132]	; 0x84
    PeriphClkInitStruct.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_SAI1CLK
                                                 |RCC_PLLSAI1_48M2CLK
                                                 |RCC_PLLSAI1_ADC1CLK;

    HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
 8001efe:	f007 f96b 	bl	80091d8 <HAL_RCCEx_PeriphCLKConfig>

    __HAL_RCC_RTC_ENABLE();
 8001f02:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 8001f06:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001f0a:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
    __HAL_RCC_HASH_CLK_ENABLE();        // for SHA256
 8001f0e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8001f10:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001f14:	64e3      	str	r3, [r4, #76]	; 0x4c
 8001f16:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8001f18:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001f1c:	9301      	str	r3, [sp, #4]
 8001f1e:	9b01      	ldr	r3, [sp, #4]
    __HAL_RCC_SPI1_CLK_ENABLE();        // for OLED
 8001f20:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8001f22:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8001f26:	6623      	str	r3, [r4, #96]	; 0x60
 8001f28:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8001f2a:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8001f2e:	9302      	str	r3, [sp, #8]
 8001f30:	9b02      	ldr	r3, [sp, #8]
    //__HAL_RCC_SPI2_CLK_ENABLE();        // for SPI flash
    __HAL_RCC_DMAMUX1_CLK_ENABLE();     // (need this) because code missing in mpy?
 8001f32:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8001f34:	f043 0304 	orr.w	r3, r3, #4
 8001f38:	64a3      	str	r3, [r4, #72]	; 0x48
 8001f3a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8001f3c:	f003 0304 	and.w	r3, r3, #4
 8001f40:	9303      	str	r3, [sp, #12]
 8001f42:	9b03      	ldr	r3, [sp, #12]

    // for SE2
    __HAL_RCC_I2C2_CLK_ENABLE();
 8001f44:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8001f46:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8001f4a:	65a3      	str	r3, [r4, #88]	; 0x58
 8001f4c:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8001f4e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8001f52:	9304      	str	r3, [sp, #16]
 8001f54:	9b04      	ldr	r3, [sp, #16]
    __HAL_RCC_I2C2_FORCE_RESET();
 8001f56:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001f58:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8001f5c:	63a3      	str	r3, [r4, #56]	; 0x38
    __HAL_RCC_I2C2_RELEASE_RESET();
 8001f5e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001f60:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8001f64:	63a3      	str	r3, [r4, #56]	; 0x38

    // setup SYSTICK, but we don't have the irq hooked up and not using HAL
    // but we use it in polling mode for delay_ms()
    systick_setup();
 8001f66:	f7ff ff4d 	bl	8001e04 <systick_setup>

}
 8001f6a:	b041      	add	sp, #260	; 0x104
 8001f6c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8001f70:	40021000 	.word	0x40021000
 8001f74:	00066880 	.word	0x00066880
 8001f78:	01110000 	.word	0x01110000

08001f7c <flash_ob_lock.part.1>:
    } else {

        // write changes to OB flash bytes

        // Set OPTSTRT bit
        SET_BIT(FLASH->CR, FLASH_CR_OPTSTRT);
 8001f7c:	4b14      	ldr	r3, [pc, #80]	; (8001fd0 <flash_ob_lock.part.1+0x54>)
 8001f7e:	695a      	ldr	r2, [r3, #20]
 8001f80:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8001f84:	615a      	str	r2, [r3, #20]
    __attribute__((section(".ramfunc")))
    __attribute__((always_inline))
    static inline uint32_t
_flash_wait_done(void)
{
    while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) {
 8001f86:	6919      	ldr	r1, [r3, #16]
 8001f88:	4a11      	ldr	r2, [pc, #68]	; (8001fd0 <flash_ob_lock.part.1+0x54>)
 8001f8a:	03c9      	lsls	r1, r1, #15
 8001f8c:	d4fb      	bmi.n	8001f86 <flash_ob_lock.part.1+0xa>
        // busy wait
    }

    uint32_t error = (FLASH->SR & FLASH_FLAG_SR_ERRORS);
 8001f8e:	6911      	ldr	r1, [r2, #16]
    if(error) {
 8001f90:	4b10      	ldr	r3, [pc, #64]	; (8001fd4 <flash_ob_lock.part.1+0x58>)
 8001f92:	400b      	ands	r3, r1
 8001f94:	b923      	cbnz	r3, 8001fa0 <flash_ob_lock.part.1+0x24>
        // Save an error code; somewhat random, depends on chip details
        return error;
    }

    // Check FLASH End of Operation flag
    if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP)) {
 8001f96:	6913      	ldr	r3, [r2, #16]
 8001f98:	07d8      	lsls	r0, r3, #31
        // Clear FLASH End of Operation pending bit
        __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8001f9a:	bf44      	itt	mi
 8001f9c:	2301      	movmi	r3, #1
 8001f9e:	6113      	strmi	r3, [r2, #16]

        /// Wait for update to complete
        _flash_wait_done();

        // lock OB again.
        SET_BIT(FLASH->CR, FLASH_CR_OPTLOCK);
 8001fa0:	4b0b      	ldr	r3, [pc, #44]	; (8001fd0 <flash_ob_lock.part.1+0x54>)
 8001fa2:	695a      	ldr	r2, [r3, #20]
 8001fa4:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8001fa8:	615a      	str	r2, [r3, #20]

        // include "launch" to make them take effect NOW
        SET_BIT(FLASH->CR, FLASH_CR_OBL_LAUNCH);
 8001faa:	695a      	ldr	r2, [r3, #20]
 8001fac:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 8001fb0:	615a      	str	r2, [r3, #20]
    __attribute__((section(".ramfunc")))
    __attribute__((always_inline))
    static inline uint32_t
_flash_wait_done(void)
{
    while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) {
 8001fb2:	6919      	ldr	r1, [r3, #16]
 8001fb4:	4a06      	ldr	r2, [pc, #24]	; (8001fd0 <flash_ob_lock.part.1+0x54>)
 8001fb6:	03c9      	lsls	r1, r1, #15
 8001fb8:	d4fb      	bmi.n	8001fb2 <flash_ob_lock.part.1+0x36>
        // busy wait
    }

    uint32_t error = (FLASH->SR & FLASH_FLAG_SR_ERRORS);
 8001fba:	6911      	ldr	r1, [r2, #16]
    if(error) {
 8001fbc:	4b05      	ldr	r3, [pc, #20]	; (8001fd4 <flash_ob_lock.part.1+0x58>)
 8001fbe:	400b      	ands	r3, r1
 8001fc0:	b923      	cbnz	r3, 8001fcc <flash_ob_lock.part.1+0x50>
        // Save an error code; somewhat random, depends on chip details
        return error;
    }

    // Check FLASH End of Operation flag
    if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP)) {
 8001fc2:	6913      	ldr	r3, [r2, #16]
 8001fc4:	07db      	lsls	r3, r3, #31
        // Clear FLASH End of Operation pending bit
        __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8001fc6:	bf44      	itt	mi
 8001fc8:	2301      	movmi	r3, #1
 8001fca:	6113      	strmi	r3, [r2, #16]
 8001fcc:	4770      	bx	lr
 8001fce:	bf00      	nop
 8001fd0:	40022000 	.word	0x40022000
 8001fd4:	0002c3fa 	.word	0x0002c3fa

08001fd8 <flash_setup0>:

// flash_setup0()
//
    void
flash_setup0(void)
{
 8001fd8:	b507      	push	{r0, r1, r2, lr}
    // bits in the same bank. Cannot read bank while programming it.
    // Therefore, must have our programming code running in RAM.

    // put the ram-callable functions into place
    extern uint8_t _srelocate, _etext, _erelocate;
    memcpy(&_srelocate, &_etext, ((uint32_t)&_erelocate)-(uint32_t)&_srelocate);
 8001fda:	4809      	ldr	r0, [pc, #36]	; (8002000 <flash_setup0+0x28>)
 8001fdc:	4a09      	ldr	r2, [pc, #36]	; (8002004 <flash_setup0+0x2c>)
 8001fde:	490a      	ldr	r1, [pc, #40]	; (8002008 <flash_setup0+0x30>)
 8001fe0:	1a12      	subs	r2, r2, r0
 8001fe2:	f00b fa4a 	bl	800d47a <memcpy>

    // turn on clock to flash registers
    __HAL_RCC_FLASH_CLK_ENABLE();
 8001fe6:	4b09      	ldr	r3, [pc, #36]	; (800200c <flash_setup0+0x34>)
 8001fe8:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8001fea:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001fee:	649a      	str	r2, [r3, #72]	; 0x48
 8001ff0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8001ff2:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8001ff6:	9301      	str	r3, [sp, #4]
 8001ff8:	9b01      	ldr	r3, [sp, #4]
}
 8001ffa:	b003      	add	sp, #12
 8001ffc:	f85d fb04 	ldr.w	pc, [sp], #4
 8002000:	20000000 	.word	0x20000000
 8002004:	20000164 	.word	0x20000164
 8002008:	0800e784 	.word	0x0800e784
 800200c:	40021000 	.word	0x40021000

08002010 <flash_lock>:
//
    void
flash_lock(void)
{
    // see HAL_FLASH_Lock();
    SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 8002010:	4a02      	ldr	r2, [pc, #8]	; (800201c <flash_lock+0xc>)
 8002012:	6953      	ldr	r3, [r2, #20]
 8002014:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8002018:	6153      	str	r3, [r2, #20]
 800201a:	4770      	bx	lr
 800201c:	40022000 	.word	0x40022000

08002020 <flash_unlock>:
//
// Ok to run from flash.
//
    void
flash_unlock(void)
{
 8002020:	b508      	push	{r3, lr}
    // see HAL_FLASH_Unlock();
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK)) {
 8002022:	4b08      	ldr	r3, [pc, #32]	; (8002044 <flash_unlock+0x24>)
 8002024:	695a      	ldr	r2, [r3, #20]
 8002026:	2a00      	cmp	r2, #0
 8002028:	da0a      	bge.n	8002040 <flash_unlock+0x20>
        // Authorize the FLASH Registers access
        WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 800202a:	4a07      	ldr	r2, [pc, #28]	; (8002048 <flash_unlock+0x28>)
 800202c:	609a      	str	r2, [r3, #8]
        WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 800202e:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
 8002032:	609a      	str	r2, [r3, #8]

        if(READ_BIT(FLASH->CR, FLASH_CR_LOCK)) {
 8002034:	695b      	ldr	r3, [r3, #20]
 8002036:	2b00      	cmp	r3, #0
 8002038:	da02      	bge.n	8002040 <flash_unlock+0x20>
            INCONSISTENT("failed to unlock");
 800203a:	4804      	ldr	r0, [pc, #16]	; (800204c <flash_unlock+0x2c>)
 800203c:	f7fe fcce 	bl	80009dc <fatal_error>
 8002040:	bd08      	pop	{r3, pc}
 8002042:	bf00      	nop
 8002044:	40022000 	.word	0x40022000
 8002048:	45670123 	.word	0x45670123
 800204c:	0800d557 	.word	0x0800d557

08002050 <flash_ob_lock>:
// - also does "launch" when done
// - also locks/unlocks the main flash
//
    void
flash_ob_lock(bool lock)
{
 8002050:	b510      	push	{r4, lr}
    if(!lock) {
 8002052:	b980      	cbnz	r0, 8002076 <flash_ob_lock+0x26>
        // unlock sequence
        if(READ_BIT(FLASH->CR, FLASH_CR_OPTLOCK)) {
 8002054:	4c0a      	ldr	r4, [pc, #40]	; (8002080 <flash_ob_lock+0x30>)
 8002056:	6963      	ldr	r3, [r4, #20]
 8002058:	005a      	lsls	r2, r3, #1
 800205a:	d510      	bpl.n	800207e <flash_ob_lock+0x2e>
            flash_unlock();
 800205c:	f7ff ffe0 	bl	8002020 <flash_unlock>

            WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY1);
 8002060:	4b08      	ldr	r3, [pc, #32]	; (8002084 <flash_ob_lock+0x34>)
 8002062:	60e3      	str	r3, [r4, #12]
            WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY2);
 8002064:	f103 3344 	add.w	r3, r3, #1145324612	; 0x44444444
 8002068:	60e3      	str	r3, [r4, #12]

            if(READ_BIT(FLASH->CR, FLASH_CR_OPTLOCK)) {
 800206a:	6963      	ldr	r3, [r4, #20]
 800206c:	005b      	lsls	r3, r3, #1
 800206e:	d506      	bpl.n	800207e <flash_ob_lock+0x2e>
                INCONSISTENT("failed to OB unlock");
 8002070:	4805      	ldr	r0, [pc, #20]	; (8002088 <flash_ob_lock+0x38>)
 8002072:	f7fe fcb3 	bl	80009dc <fatal_error>
        // include "launch" to make them take effect NOW
        SET_BIT(FLASH->CR, FLASH_CR_OBL_LAUNCH);

        _flash_wait_done();
    }
}
 8002076:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800207a:	f7ff bf7f 	b.w	8001f7c <flash_ob_lock.part.1>
 800207e:	bd10      	pop	{r4, pc}
 8002080:	40022000 	.word	0x40022000
 8002084:	08192a3b 	.word	0x08192a3b
 8002088:	0800d557 	.word	0x0800d557

0800208c <pick_pairing_secret>:

// pick_pairing_secret()
//
    static void
pick_pairing_secret(void)
{
 800208c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002090:	f2ad 4d24 	subw	sp, sp, #1060	; 0x424
    // important the RNG works here. ok to call setup multiple times.
    rng_setup();
 8002094:	f000 fb0c 	bl	80026b0 <rng_setup>
 8002098:	24c8      	movs	r4, #200	; 0xc8

    // Demo to anyone watching that the RNG is working, but likely only
    // to be seen by production team during initial powerup.
    uint8_t    tmp[1024];
    for(int i=0; i<200; i++) {
        rng_buffer(tmp, sizeof(tmp));
 800209a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800209e:	a808      	add	r0, sp, #32
 80020a0:	f000 fb32 	bl	8002708 <rng_buffer>

        oled_show_raw(sizeof(tmp), (void *)tmp);
 80020a4:	a908      	add	r1, sp, #32
 80020a6:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80020aa:	f7fe fe77 	bl	8000d9c <oled_show_raw>
    rng_setup();

    // Demo to anyone watching that the RNG is working, but likely only
    // to be seen by production team during initial powerup.
    uint8_t    tmp[1024];
    for(int i=0; i<200; i++) {
 80020ae:	3c01      	subs	r4, #1
 80020b0:	d1f3      	bne.n	800209a <pick_pairing_secret+0xe>
        rng_buffer(tmp, sizeof(tmp));

        oled_show_raw(sizeof(tmp), (void *)tmp);
    }

    oled_factory_busy();
 80020b2:	f7fe ff63 	bl	8000f7c <oled_factory_busy>

    // .. but don't use those numbers, because those are semi-public now.
    uint32_t secret[8];
    for(int i=0; i<8; i++) {
        secret[i] = rng_sample();
 80020b6:	f000 fae7 	bl	8002688 <rng_sample>
 80020ba:	f84d 0024 	str.w	r0, [sp, r4, lsl #2]

    oled_factory_busy();

    // .. but don't use those numbers, because those are semi-public now.
    uint32_t secret[8];
    for(int i=0; i<8; i++) {
 80020be:	3401      	adds	r4, #1
 80020c0:	2c08      	cmp	r4, #8
 80020c2:	d1f8      	bne.n	80020b6 <pick_pairing_secret+0x2a>
        secret[i] = rng_sample();
    }

    // enforce policy that first word is not all ones (so it never
    // looks like unprogrammed flash).
    while(secret[0] == ~0) {
 80020c4:	9b00      	ldr	r3, [sp, #0]
 80020c6:	3301      	adds	r3, #1
 80020c8:	d103      	bne.n	80020d2 <pick_pairing_secret+0x46>
        secret[0] = rng_sample();
 80020ca:	f000 fadd 	bl	8002688 <rng_sample>
 80020ce:	9000      	str	r0, [sp, #0]
 80020d0:	e7f8      	b.n	80020c4 <pick_pairing_secret+0x38>

    // Write pairing secret into flash
    {
        uint32_t dest = (uint32_t)&rom_secrets->pairing_secret;

        flash_unlock();
 80020d2:	f7ff ffa5 	bl	8002020 <flash_unlock>
 80020d6:	2400      	movs	r4, #0
        for(int i=0; i<8; i+=2, dest += 8) {
            uint64_t    val = (((uint64_t)secret[i]) << 32) | secret[i+1];
 80020d8:	eb0d 0304 	add.w	r3, sp, r4

            if(flash_burn(dest, val)) {
 80020dc:	f85d 9004 	ldr.w	r9, [sp, r4]
 80020e0:	685a      	ldr	r2, [r3, #4]
 80020e2:	f04f 0800 	mov.w	r8, #0
 80020e6:	4640      	mov	r0, r8
 80020e8:	4649      	mov	r1, r9
 80020ea:	ea40 0002 	orr.w	r0, r0, r2
 80020ee:	4602      	mov	r2, r0
 80020f0:	f104 6000 	add.w	r0, r4, #134217728	; 0x8000000
 80020f4:	460b      	mov	r3, r1
 80020f6:	f500 30f0 	add.w	r0, r0, #122880	; 0x1e000
 80020fa:	f00b fa21 	bl	800d540 <__flash_burn_veneer>
 80020fe:	b110      	cbz	r0, 8002106 <pick_pairing_secret+0x7a>
                INCONSISTENT("flash fail");
 8002100:	4811      	ldr	r0, [pc, #68]	; (8002148 <pick_pairing_secret+0xbc>)
 8002102:	f7fe fc6b 	bl	80009dc <fatal_error>
 8002106:	3408      	adds	r4, #8
    // Write pairing secret into flash
    {
        uint32_t dest = (uint32_t)&rom_secrets->pairing_secret;

        flash_unlock();
        for(int i=0; i<8; i+=2, dest += 8) {
 8002108:	2c20      	cmp	r4, #32
 800210a:	d1e5      	bne.n	80020d8 <pick_pairing_secret+0x4c>

            if(flash_burn(dest, val)) {
                INCONSISTENT("flash fail");
            }
        }
        flash_lock();
 800210c:	f7ff ff80 	bl	8002010 <flash_lock>
                                + sizeof(rom_secrets->mcu_hmac_key);

        STATIC_ASSERT(offsetof(rom_secrets_t, hash_cache_secret) % 8 == 0);
        STATIC_ASSERT(blen % 8 == 0);

        flash_unlock();
 8002110:	f7ff ff86 	bl	8002020 <flash_unlock>
    }

    // Also at this point, pick some RNG noise to use as our non-changing
    // bits of various things.
    {
        uint32_t dest = (uint32_t)&rom_secrets->hash_cache_secret;
 8002114:	4c0d      	ldr	r4, [pc, #52]	; (800214c <pick_pairing_secret+0xc0>)

        STATIC_ASSERT(offsetof(rom_secrets_t, hash_cache_secret) % 8 == 0);
        STATIC_ASSERT(blen % 8 == 0);

        flash_unlock();
        for(int i=0; i<blen; i+=8, dest += 8) {
 8002116:	4d0e      	ldr	r5, [pc, #56]	; (8002150 <pick_pairing_secret+0xc4>)
            uint64_t    val = ((uint64_t)rng_sample() << 32) | rng_sample();
 8002118:	f000 fab6 	bl	8002688 <rng_sample>
 800211c:	4680      	mov	r8, r0
 800211e:	f000 fab3 	bl	8002688 <rng_sample>

            if(flash_burn(dest, val)) {
 8002122:	2600      	movs	r6, #0
 8002124:	ea46 0200 	orr.w	r2, r6, r0
 8002128:	4643      	mov	r3, r8
 800212a:	4620      	mov	r0, r4
 800212c:	f00b fa08 	bl	800d540 <__flash_burn_veneer>
 8002130:	2800      	cmp	r0, #0
 8002132:	d1e5      	bne.n	8002100 <pick_pairing_secret+0x74>

        STATIC_ASSERT(offsetof(rom_secrets_t, hash_cache_secret) % 8 == 0);
        STATIC_ASSERT(blen % 8 == 0);

        flash_unlock();
        for(int i=0; i<blen; i+=8, dest += 8) {
 8002134:	3408      	adds	r4, #8
 8002136:	42ac      	cmp	r4, r5
 8002138:	d1ee      	bne.n	8002118 <pick_pairing_secret+0x8c>

            if(flash_burn(dest, val)) {
                INCONSISTENT("flash fail");
            }
        }
        flash_lock();
 800213a:	f7ff ff69 	bl	8002010 <flash_lock>
    }
    
}
 800213e:	f20d 4d24 	addw	sp, sp, #1060	; 0x424
 8002142:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8002146:	bf00      	nop
 8002148:	0800d557 	.word	0x0800d557
 800214c:	0801e070 	.word	0x0801e070
 8002150:	0801e0b0 	.word	0x0801e0b0

08002154 <flash_save_ae_serial>:
//
// Write the serial number of ATECC608 into flash forever.
//
    void
flash_save_ae_serial(const uint8_t serial[9])
{
 8002154:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8002156:	4604      	mov	r4, r0

    uint64_t    tmp[2];
    memset(&tmp, 0x0, sizeof(tmp));
 8002158:	2210      	movs	r2, #16
 800215a:	2100      	movs	r1, #0
 800215c:	4668      	mov	r0, sp
 800215e:	f00b f9b2 	bl	800d4c6 <memset>
    memcpy(&tmp, serial, 9);
 8002162:	6820      	ldr	r0, [r4, #0]
 8002164:	6861      	ldr	r1, [r4, #4]
 8002166:	7a22      	ldrb	r2, [r4, #8]
 8002168:	466b      	mov	r3, sp
 800216a:	c303      	stmia	r3!, {r0, r1}
 800216c:	701a      	strb	r2, [r3, #0]

    flash_setup0();
 800216e:	f7ff ff33 	bl	8001fd8 <flash_setup0>
    flash_unlock();
 8002172:	f7ff ff55 	bl	8002020 <flash_unlock>

    if(flash_burn((uint32_t)&rom_secrets->ae_serial_number[0], tmp[0])) {
 8002176:	e9dd 2300 	ldrd	r2, r3, [sp]
 800217a:	4809      	ldr	r0, [pc, #36]	; (80021a0 <flash_save_ae_serial+0x4c>)
 800217c:	f00b f9e0 	bl	800d540 <__flash_burn_veneer>
 8002180:	b110      	cbz	r0, 8002188 <flash_save_ae_serial+0x34>
        INCONSISTENT("fail1");
 8002182:	4808      	ldr	r0, [pc, #32]	; (80021a4 <flash_save_ae_serial+0x50>)
 8002184:	f7fe fc2a 	bl	80009dc <fatal_error>
    }
    if(flash_burn((uint32_t)&rom_secrets->ae_serial_number[1], tmp[1])) {
 8002188:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800218c:	4806      	ldr	r0, [pc, #24]	; (80021a8 <flash_save_ae_serial+0x54>)
 800218e:	f00b f9d7 	bl	800d540 <__flash_burn_veneer>
 8002192:	2800      	cmp	r0, #0
 8002194:	d1f5      	bne.n	8002182 <flash_save_ae_serial+0x2e>
        INCONSISTENT("fail2");
    }

    flash_lock();
}
 8002196:	b004      	add	sp, #16
 8002198:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    }
    if(flash_burn((uint32_t)&rom_secrets->ae_serial_number[1], tmp[1])) {
        INCONSISTENT("fail2");
    }

    flash_lock();
 800219c:	f7ff bf38 	b.w	8002010 <flash_lock>
 80021a0:	0801e040 	.word	0x0801e040
 80021a4:	0800d557 	.word	0x0800d557
 80021a8:	0801e048 	.word	0x0801e048

080021ac <flash_save_bag_number>:
//
// Write bag number (probably a string)
//
    void
flash_save_bag_number(const uint8_t new_number[32])
{
 80021ac:	b570      	push	{r4, r5, r6, lr}
 80021ae:	4605      	mov	r5, r0

    uint32_t dest = (uint32_t)&rom_secrets->bag_number[0];
    uint64_t *src = (uint64_t *)new_number;

    flash_setup0();
 80021b0:	f7ff ff12 	bl	8001fd8 <flash_setup0>
    flash_unlock();
 80021b4:	f7ff ff34 	bl	8002020 <flash_unlock>
//
    void
flash_save_bag_number(const uint8_t new_number[32])
{

    uint32_t dest = (uint32_t)&rom_secrets->bag_number[0];
 80021b8:	4c09      	ldr	r4, [pc, #36]	; (80021e0 <flash_save_bag_number+0x34>)
    flash_setup0();
    flash_unlock();

    // NOTE: can only write once! No provision for read/check, and write
    // when non-ones will fail.
    for(int i=0; i<(32/8); i++, dest+=8, src++) {
 80021ba:	4e0a      	ldr	r6, [pc, #40]	; (80021e4 <flash_save_bag_number+0x38>)
 80021bc:	3d08      	subs	r5, #8
        if(flash_burn(dest, *src)) {
 80021be:	e9f5 2302 	ldrd	r2, r3, [r5, #8]!
 80021c2:	4620      	mov	r0, r4
 80021c4:	f00b f9bc 	bl	800d540 <__flash_burn_veneer>
 80021c8:	b110      	cbz	r0, 80021d0 <flash_save_bag_number+0x24>
            INCONSISTENT("fail write");
 80021ca:	4807      	ldr	r0, [pc, #28]	; (80021e8 <flash_save_bag_number+0x3c>)
 80021cc:	f7fe fc06 	bl	80009dc <fatal_error>
    flash_setup0();
    flash_unlock();

    // NOTE: can only write once! No provision for read/check, and write
    // when non-ones will fail.
    for(int i=0; i<(32/8); i++, dest+=8, src++) {
 80021d0:	3408      	adds	r4, #8
 80021d2:	42b4      	cmp	r4, r6
 80021d4:	d1f3      	bne.n	80021be <flash_save_bag_number+0x12>
            INCONSISTENT("fail write");
        }
    }

    flash_lock();
}
 80021d6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        if(flash_burn(dest, *src)) {
            INCONSISTENT("fail write");
        }
    }

    flash_lock();
 80021da:	f7ff bf19 	b.w	8002010 <flash_lock>
 80021de:	bf00      	nop
 80021e0:	0801e050 	.word	0x0801e050
 80021e4:	0801e070 	.word	0x0801e070
 80021e8:	0800d557 	.word	0x0800d557

080021ec <flash_save_se2_data>:
// Save bunch of stuff related to SE2. Allow updates to sections that are
// given as ones at this point.
//
    void
flash_save_se2_data(const se2_secrets_t *se2)
{
 80021ec:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 80021f0:	4605      	mov	r5, r0
    uint8_t *dest = (uint8_t *)&rom_secrets->se2;
    uint8_t *src = (uint8_t *)se2;

    STATIC_ASSERT(offsetof(rom_secrets_t, se2) % 8 == 0);

    flash_setup0();
 80021f2:	f7ff fef1 	bl	8001fd8 <flash_setup0>
    flash_unlock();
 80021f6:	f7ff ff13 	bl	8002020 <flash_unlock>
// given as ones at this point.
//
    void
flash_save_se2_data(const se2_secrets_t *se2)
{
    uint8_t *dest = (uint8_t *)&rom_secrets->se2;
 80021fa:	4c17      	ldr	r4, [pc, #92]	; (8002258 <flash_save_se2_data+0x6c>)
    STATIC_ASSERT(offsetof(rom_secrets_t, se2) % 8 == 0);

    flash_setup0();
    flash_unlock();

    for(int i=0; i<(sizeof(se2_secrets_t)/8); i++, dest+=8, src+=8) {
 80021fc:	f8df 8064 	ldr.w	r8, [pc, #100]	; 8002264 <flash_save_se2_data+0x78>
        uint64_t val;
        memcpy(&val, src, sizeof(val));
 8002200:	6828      	ldr	r0, [r5, #0]
 8002202:	6869      	ldr	r1, [r5, #4]
 8002204:	466b      	mov	r3, sp
 8002206:	c303      	stmia	r3!, {r0, r1}

        // don't write if all ones or already written correctly
        if(val == ~0) continue;
 8002208:	e9dd 6700 	ldrd	r6, r7, [sp]
 800220c:	1c7b      	adds	r3, r7, #1
 800220e:	bf08      	it	eq
 8002210:	f1b6 3fff 	cmpeq.w	r6, #4294967295	; 0xffffffff
 8002214:	d015      	beq.n	8002242 <flash_save_se2_data+0x56>
        if(check_equal(dest, src, 8)) continue;
 8002216:	2208      	movs	r2, #8
 8002218:	4629      	mov	r1, r5
 800221a:	4620      	mov	r0, r4
 800221c:	f000 fa23 	bl	8002666 <check_equal>
 8002220:	b978      	cbnz	r0, 8002242 <flash_save_se2_data+0x56>

        // can't write if not ones already
        ASSERT(check_all_ones(dest, 8));
 8002222:	2108      	movs	r1, #8
 8002224:	4620      	mov	r0, r4
 8002226:	f000 f9ff 	bl	8002628 <check_all_ones>
 800222a:	b908      	cbnz	r0, 8002230 <flash_save_se2_data+0x44>
 800222c:	480b      	ldr	r0, [pc, #44]	; (800225c <flash_save_se2_data+0x70>)
 800222e:	e006      	b.n	800223e <flash_save_se2_data+0x52>

        if(flash_burn((uint32_t)dest, val)) {
 8002230:	4632      	mov	r2, r6
 8002232:	463b      	mov	r3, r7
 8002234:	4620      	mov	r0, r4
 8002236:	f00b f983 	bl	800d540 <__flash_burn_veneer>
 800223a:	b110      	cbz	r0, 8002242 <flash_save_se2_data+0x56>
            INCONSISTENT("fail write");
 800223c:	4808      	ldr	r0, [pc, #32]	; (8002260 <flash_save_se2_data+0x74>)
 800223e:	f7fe fbcd 	bl	80009dc <fatal_error>
    STATIC_ASSERT(offsetof(rom_secrets_t, se2) % 8 == 0);

    flash_setup0();
    flash_unlock();

    for(int i=0; i<(sizeof(se2_secrets_t)/8); i++, dest+=8, src+=8) {
 8002242:	3408      	adds	r4, #8
 8002244:	4544      	cmp	r4, r8
 8002246:	f105 0508 	add.w	r5, r5, #8
 800224a:	d1d9      	bne.n	8002200 <flash_save_se2_data+0x14>
            INCONSISTENT("fail write");
        }
    }

    flash_lock();
}
 800224c:	b002      	add	sp, #8
 800224e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        if(flash_burn((uint32_t)dest, val)) {
            INCONSISTENT("fail write");
        }
    }

    flash_lock();
 8002252:	f7ff bedd 	b.w	8002010 <flash_lock>
 8002256:	bf00      	nop
 8002258:	0801e0b0 	.word	0x0801e0b0
 800225c:	0800d550 	.word	0x0800d550
 8002260:	0800d557 	.word	0x0800d557
 8002264:	0801e190 	.word	0x0801e190

08002268 <flash_setup>:
//
// This is really a state-machine, to recover boards that are booted w/ missing AE chip.
//
    void
flash_setup(void)
{
 8002268:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

    // see if we have picked a pairing secret yet.
    // NOTE: critical section for glitching (at least in past versions)
    //  - check_all.. functions have a rng_delay in them already
    rng_delay();
    bool blank_ps = check_all_ones(rom_secrets->pairing_secret, 32);
 800226c:	4c40      	ldr	r4, [pc, #256]	; (8002370 <flash_setup+0x108>)
//
// This is really a state-machine, to recover boards that are booted w/ missing AE chip.
//
    void
flash_setup(void)
{
 800226e:	b089      	sub	sp, #36	; 0x24
    flash_setup0();
 8002270:	f7ff feb2 	bl	8001fd8 <flash_setup0>
    STATIC_ASSERT(sizeof(rom_secrets_t) <= 0x2000);

    // see if we have picked a pairing secret yet.
    // NOTE: critical section for glitching (at least in past versions)
    //  - check_all.. functions have a rng_delay in them already
    rng_delay();
 8002274:	f000 fa5f 	bl	8002736 <rng_delay>
    bool blank_ps = check_all_ones(rom_secrets->pairing_secret, 32);
 8002278:	2120      	movs	r1, #32
 800227a:	4620      	mov	r0, r4
 800227c:	f000 f9d4 	bl	8002628 <check_all_ones>
    bool zeroed_ps = check_all_zeros(rom_secrets->pairing_secret, 32);
 8002280:	2120      	movs	r1, #32

    // see if we have picked a pairing secret yet.
    // NOTE: critical section for glitching (at least in past versions)
    //  - check_all.. functions have a rng_delay in them already
    rng_delay();
    bool blank_ps = check_all_ones(rom_secrets->pairing_secret, 32);
 8002282:	4680      	mov	r8, r0
    bool zeroed_ps = check_all_zeros(rom_secrets->pairing_secret, 32);
 8002284:	4620      	mov	r0, r4
 8002286:	f000 f9df 	bl	8002648 <check_all_zeros>
    bool blank_xor = check_all_ones(rom_secrets->pairing_secret_xor, 32);
 800228a:	2120      	movs	r1, #32
    // see if we have picked a pairing secret yet.
    // NOTE: critical section for glitching (at least in past versions)
    //  - check_all.. functions have a rng_delay in them already
    rng_delay();
    bool blank_ps = check_all_ones(rom_secrets->pairing_secret, 32);
    bool zeroed_ps = check_all_zeros(rom_secrets->pairing_secret, 32);
 800228c:	4681      	mov	r9, r0
    bool blank_xor = check_all_ones(rom_secrets->pairing_secret_xor, 32);
 800228e:	4839      	ldr	r0, [pc, #228]	; (8002374 <flash_setup+0x10c>)
 8002290:	f000 f9ca 	bl	8002628 <check_all_ones>
    bool blank_ae = (~rom_secrets->ae_serial_number[0] == 0);
 8002294:	e9d4 6710 	ldrd	r6, r7, [r4, #64]	; 0x40
    // NOTE: critical section for glitching (at least in past versions)
    //  - check_all.. functions have a rng_delay in them already
    rng_delay();
    bool blank_ps = check_all_ones(rom_secrets->pairing_secret, 32);
    bool zeroed_ps = check_all_zeros(rom_secrets->pairing_secret, 32);
    bool blank_xor = check_all_ones(rom_secrets->pairing_secret_xor, 32);
 8002298:	4605      	mov	r5, r0
    bool blank_ae = (~rom_secrets->ae_serial_number[0] == 0);
    rng_delay();
 800229a:	f000 fa4c 	bl	8002736 <rng_delay>

    if(zeroed_ps) {
 800229e:	f1b9 0f00 	cmp.w	r9, #0
 80022a2:	d004      	beq.n	80022ae <flash_setup+0x46>
        // fast brick process leaves us w/ zero pairing secret
        oled_show(screen_brick);
 80022a4:	4834      	ldr	r0, [pc, #208]	; (8002378 <flash_setup+0x110>)
 80022a6:	f7fe fda5 	bl	8000df4 <oled_show>
        LOCKUP_FOREVER();
 80022aa:	bf30      	wfi
 80022ac:	e7fd      	b.n	80022aa <flash_setup+0x42>
    }

    if(blank_ps) {
 80022ae:	f1b8 0f00 	cmp.w	r8, #0
 80022b2:	d001      	beq.n	80022b8 <flash_setup+0x50>
        // get some good entropy, save it.
        pick_pairing_secret();
 80022b4:	f7ff feea 	bl	800208c <pick_pairing_secret>

        blank_ps = false;
    }

    if(blank_xor || blank_ae) {
 80022b8:	b925      	cbnz	r5, 80022c4 <flash_setup+0x5c>
 80022ba:	3701      	adds	r7, #1
 80022bc:	bf08      	it	eq
 80022be:	f1b6 3fff 	cmpeq.w	r6, #4294967295	; 0xffffffff
 80022c2:	d12e      	bne.n	8002322 <flash_setup+0xba>

        // setup the SE2 (mostly). handles failures by dying
        se2_setup_config();
 80022c4:	f005 fa74 	bl	80077b0 <se2_setup_config>

        // configure and lock-down the SE1
        int rv = ae_setup_config();
 80022c8:	f001 f95e 	bl	8003588 <ae_setup_config>
 80022cc:	4604      	mov	r4, r0

        rng_delay();
 80022ce:	f000 fa32 	bl	8002736 <rng_delay>
        if(rv) {
 80022d2:	b13c      	cbz	r4, 80022e4 <flash_setup+0x7c>
            // Hardware fail speaking to AE chip ... be careful not to brick here.
            // Do not continue!! We might fix the board, or add missing pullup, etc.
            oled_show(screen_se1_issue);
 80022d4:	4829      	ldr	r0, [pc, #164]	; (800237c <flash_setup+0x114>)
 80022d6:	f7fe fd8d 	bl	8000df4 <oled_show>
            puts("SE1 config fail");
 80022da:	4829      	ldr	r0, [pc, #164]	; (8002380 <flash_setup+0x118>)
 80022dc:	f002 fcea 	bl	8004cb4 <puts>

            LOCKUP_FOREVER();
 80022e0:	bf30      	wfi
 80022e2:	e7fd      	b.n	80022e0 <flash_setup+0x78>
        }

        rng_delay();
 80022e4:	f000 fa27 	bl	8002736 <rng_delay>
        if(blank_xor) {
 80022e8:	b19d      	cbz	r5, 8002312 <flash_setup+0xaa>
    // BUT: so we are just using this to mark the 2nd half of a two-phase commit w.r.t SE1 setup

    uint64_t *src = (uint64_t *)&rom_secrets->pairing_secret;
    uint32_t dest = (uint32_t)&rom_secrets->pairing_secret_xor;

    flash_unlock();
 80022ea:	f7ff fe99 	bl	8002020 <flash_unlock>
 80022ee:	4c25      	ldr	r4, [pc, #148]	; (8002384 <flash_setup+0x11c>)
    for(int i=0; i<(32/8); i++, dest+=8, src++) {
 80022f0:	4d25      	ldr	r5, [pc, #148]	; (8002388 <flash_setup+0x120>)
 80022f2:	f104 0028 	add.w	r0, r4, #40	; 0x28
        uint64_t    val = ~(*src);

        if(flash_burn(dest, val)) {
 80022f6:	e9f4 2302 	ldrd	r2, r3, [r4, #8]!
 80022fa:	43d2      	mvns	r2, r2
 80022fc:	43db      	mvns	r3, r3
 80022fe:	f00b f91f 	bl	800d540 <__flash_burn_veneer>
 8002302:	b110      	cbz	r0, 800230a <flash_setup+0xa2>
            INCONSISTENT("flash xor fail");
 8002304:	4821      	ldr	r0, [pc, #132]	; (800238c <flash_setup+0x124>)
 8002306:	f7fe fb69 	bl	80009dc <fatal_error>

    uint64_t *src = (uint64_t *)&rom_secrets->pairing_secret;
    uint32_t dest = (uint32_t)&rom_secrets->pairing_secret_xor;

    flash_unlock();
    for(int i=0; i<(32/8); i++, dest+=8, src++) {
 800230a:	42ac      	cmp	r4, r5
 800230c:	d1f1      	bne.n	80022f2 <flash_setup+0x8a>

        if(flash_burn(dest, val)) {
            INCONSISTENT("flash xor fail");
        }
    }
    flash_lock();
 800230e:	f7ff fe7f 	bl	8002010 <flash_lock>
            // write secret again, complemented, to indicate successful AE programming
            confirm_pairing_secret();
        }

        // real power cycle required now.
        oled_show(screen_replug);
 8002312:	481f      	ldr	r0, [pc, #124]	; (8002390 <flash_setup+0x128>)
 8002314:	f7fe fd6e 	bl	8000df4 <oled_show>
        puts("replug required");
 8002318:	481e      	ldr	r0, [pc, #120]	; (8002394 <flash_setup+0x12c>)
 800231a:	f002 fccb 	bl	8004cb4 <puts>

        LOCKUP_FOREVER();
 800231e:	bf30      	wfi
 8002320:	e7fd      	b.n	800231e <flash_setup+0xb6>

    rng_delay();
    if(!blank_ps && !blank_xor) {
        // check the XOR value also written: 2 phase commit
        uint8_t tmp[32];
        memcpy(tmp, rom_secrets->pairing_secret, 32);
 8002322:	4d13      	ldr	r5, [pc, #76]	; (8002370 <flash_setup+0x108>)
        puts("replug required");

        LOCKUP_FOREVER();
    }

    rng_delay();
 8002324:	f000 fa07 	bl	8002736 <rng_delay>
    if(!blank_ps && !blank_xor) {
        // check the XOR value also written: 2 phase commit
        uint8_t tmp[32];
        memcpy(tmp, rom_secrets->pairing_secret, 32);
 8002328:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800232a:	466c      	mov	r4, sp
 800232c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800232e:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8002332:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 8002336:	4a18      	ldr	r2, [pc, #96]	; (8002398 <flash_setup+0x130>)
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 8002338:	4c18      	ldr	r4, [pc, #96]	; (800239c <flash_setup+0x134>)
 800233a:	466b      	mov	r3, sp
 800233c:	4668      	mov	r0, sp
		*(acc) ^= *(more);
 800233e:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 8002342:	781d      	ldrb	r5, [r3, #0]
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 8002344:	42a2      	cmp	r2, r4
		*(acc) ^= *(more);
 8002346:	ea81 0105 	eor.w	r1, r1, r5
 800234a:	f803 1b01 	strb.w	r1, [r3], #1
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 800234e:	d1f6      	bne.n	800233e <flash_setup+0xd6>
        xor_mixin(tmp, rom_secrets->pairing_secret_xor, 32);

        if(!check_all_ones(tmp, 32)) {
 8002350:	2120      	movs	r1, #32
 8002352:	f000 f969 	bl	8002628 <check_all_ones>
 8002356:	b938      	cbnz	r0, 8002368 <flash_setup+0x100>
            oled_show(screen_corrupt);
 8002358:	4811      	ldr	r0, [pc, #68]	; (80023a0 <flash_setup+0x138>)
 800235a:	f7fe fd4b 	bl	8000df4 <oled_show>
            puts("corrupt pair sec");
 800235e:	4811      	ldr	r0, [pc, #68]	; (80023a4 <flash_setup+0x13c>)
 8002360:	f002 fca8 	bl	8004cb4 <puts>

            // dfu won't save them here, so just die
            LOCKUP_FOREVER();
 8002364:	bf30      	wfi
 8002366:	e7fd      	b.n	8002364 <flash_setup+0xfc>
    // That's fine if we intend to ship units locked already.
    
    // Do NOT do write every boot, as it might wear-out
    // the flash bits in OB.

}
 8002368:	b009      	add	sp, #36	; 0x24
 800236a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800236e:	bf00      	nop
 8002370:	0801e000 	.word	0x0801e000
 8002374:	0801e020 	.word	0x0801e020
 8002378:	0800de53 	.word	0x0800de53
 800237c:	0800e0e7 	.word	0x0800e0e7
 8002380:	0800e35f 	.word	0x0800e35f
 8002384:	0801dff8 	.word	0x0801dff8
 8002388:	0801e018 	.word	0x0801e018
 800238c:	0800d557 	.word	0x0800d557
 8002390:	0800ddf2 	.word	0x0800ddf2
 8002394:	0800e36f 	.word	0x0800e36f
 8002398:	0801e01f 	.word	0x0801e01f
 800239c:	0801e03f 	.word	0x0801e03f
 80023a0:	0800d6e3 	.word	0x0800d6e3
 80023a4:	0800e37f 	.word	0x0800e37f

080023a8 <flash_lockdown_hard>:
// 
// This is a one-way trip. Might need power cycle to (fully?) take effect.
//
    void
flash_lockdown_hard(uint8_t rdp_level_code)
{
 80023a8:	b510      	push	{r4, lr}
 80023aa:	4604      	mov	r4, r0
    flash_setup0();
 80023ac:	f7ff fe14 	bl	8001fd8 <flash_setup0>

    // see FLASH_OB_WRPConfig()

    flash_ob_lock(false);
 80023b0:	2000      	movs	r0, #0
 80023b2:	f7ff fe4d 	bl	8002050 <flash_ob_lock>
        // lock first 32k against any writes
        FLASH->WRP1AR = (num_pages_locked << 16);
 80023b6:	4b08      	ldr	r3, [pc, #32]	; (80023d8 <flash_lockdown_hard+0x30>)
 80023b8:	f44f 12f8 	mov.w	r2, #2031616	; 0x1f0000
 80023bc:	62da      	str	r2, [r3, #44]	; 0x2c
        FLASH->WRP1BR = 0xff;      // unused.
 80023be:	22ff      	movs	r2, #255	; 0xff
 80023c0:	631a      	str	r2, [r3, #48]	; 0x30
        FLASH->WRP2AR = 0xff;      // unused.
 80023c2:	64da      	str	r2, [r3, #76]	; 0x4c
        FLASH->WRP2BR = 0xff;      // unused.
 80023c4:	651a      	str	r2, [r3, #80]	; 0x50
        //    the RDP level is decreased from Level 1 to Level 0)."
        // - D-bus access blocked, even for code running inside the PCROP area! (AN4758)
        //   So literal values and constant tables and such would need special linking.

        // set protection level
        uint32_t was = FLASH->OPTR & ~0xff;
 80023c6:	6a1a      	ldr	r2, [r3, #32]
        FLASH->OPTR = was | rdp_level_code;    // select level X, other values as observed
 80023c8:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 80023cc:	4314      	orrs	r4, r2
 80023ce:	621c      	str	r4, [r3, #32]

    flash_ob_lock(true);
}
 80023d0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80023d4:	f7ff bdd2 	b.w	8001f7c <flash_ob_lock.part.1>
 80023d8:	40022000 	.word	0x40022000

080023dc <record_highwater_version>:

// record_highwater_version()
//
    int
record_highwater_version(const uint8_t timestamp[8])
{
 80023dc:	b573      	push	{r0, r1, r4, r5, r6, lr}
    const uint8_t *otp = (const uint8_t *)OPT_FLASH_BASE;

    ASSERT(timestamp[0] < 0x40);
    ASSERT(timestamp[0] >= 0x10);
 80023de:	7803      	ldrb	r3, [r0, #0]
 80023e0:	3b10      	subs	r3, #16
 80023e2:	2b2f      	cmp	r3, #47	; 0x2f

// record_highwater_version()
//
    int
record_highwater_version(const uint8_t timestamp[8])
{
 80023e4:	4605      	mov	r5, r0
    const uint8_t *otp = (const uint8_t *)OPT_FLASH_BASE;

    ASSERT(timestamp[0] < 0x40);
    ASSERT(timestamp[0] >= 0x10);
 80023e6:	d902      	bls.n	80023ee <record_highwater_version+0x12>
    int
record_highwater_version(const uint8_t timestamp[8])
{
    const uint8_t *otp = (const uint8_t *)OPT_FLASH_BASE;

    ASSERT(timestamp[0] < 0x40);
 80023e8:	4810      	ldr	r0, [pc, #64]	; (800242c <record_highwater_version+0x50>)
 80023ea:	f7fe faf7 	bl	80009dc <fatal_error>
 80023ee:	4c10      	ldr	r4, [pc, #64]	; (8002430 <record_highwater_version+0x54>)
    ASSERT(timestamp[0] >= 0x10);

    // just write to first blank slot we can find.
    for(int i=0; i<NUM_OPT_SLOTS; i++, otp+=8) {
 80023f0:	4e10      	ldr	r6, [pc, #64]	; (8002434 <record_highwater_version+0x58>)
        if(check_all_ones(otp, 8)) {
 80023f2:	2108      	movs	r1, #8
 80023f4:	4620      	mov	r0, r4
 80023f6:	f000 f917 	bl	8002628 <check_all_ones>
 80023fa:	b180      	cbz	r0, 800241e <record_highwater_version+0x42>
            // here.
            uint64_t val = 0;
            memcpy(&val, timestamp, 8);
 80023fc:	6869      	ldr	r1, [r5, #4]
 80023fe:	6828      	ldr	r0, [r5, #0]
 8002400:	466b      	mov	r3, sp
 8002402:	c303      	stmia	r3!, {r0, r1}

            flash_setup0();
 8002404:	f7ff fde8 	bl	8001fd8 <flash_setup0>

            flash_unlock();
 8002408:	f7ff fe0a 	bl	8002020 <flash_unlock>
                flash_burn((uint32_t)otp, val);
 800240c:	e9dd 2300 	ldrd	r2, r3, [sp]
 8002410:	4620      	mov	r0, r4
 8002412:	f00b f895 	bl	800d540 <__flash_burn_veneer>
            flash_lock();
 8002416:	f7ff fdfb 	bl	8002010 <flash_lock>

            return 0;
 800241a:	2000      	movs	r0, #0
 800241c:	e003      	b.n	8002426 <record_highwater_version+0x4a>

    ASSERT(timestamp[0] < 0x40);
    ASSERT(timestamp[0] >= 0x10);

    // just write to first blank slot we can find.
    for(int i=0; i<NUM_OPT_SLOTS; i++, otp+=8) {
 800241e:	3408      	adds	r4, #8
 8002420:	42b4      	cmp	r4, r6
 8002422:	d1e6      	bne.n	80023f2 <record_highwater_version+0x16>
            return 0;
        }
    }

    // no space.
    return 1;
 8002424:	2001      	movs	r0, #1
}
 8002426:	b002      	add	sp, #8
 8002428:	bd70      	pop	{r4, r5, r6, pc}
 800242a:	bf00      	nop
 800242c:	0800d550 	.word	0x0800d550
 8002430:	1fff7000 	.word	0x1fff7000
 8002434:	1fff7400 	.word	0x1fff7400

08002438 <mcu_key_get>:

// mcu_key_get()
//
    const mcu_key_t *
mcu_key_get(bool *valid)
{
 8002438:	b570      	push	{r4, r5, r6, lr}
    // get current "mcu_key" value; first byte will never be 0x0 or 0xff
    // - except if no key set yet/recently wiped
    // - if none set, returns ptr to first available slot which will be all ones
    const mcu_key_t *ptr = rom_secrets->mcu_keys, *avail=NULL;

    for(int i=0; i<numberof(rom_secrets->mcu_keys); i++, ptr++) {
 800243a:	4a0d      	ldr	r2, [pc, #52]	; (8002470 <mcu_key_get+0x38>)
mcu_key_get(bool *valid)
{
    // get current "mcu_key" value; first byte will never be 0x0 or 0xff
    // - except if no key set yet/recently wiped
    // - if none set, returns ptr to first available slot which will be all ones
    const mcu_key_t *ptr = rom_secrets->mcu_keys, *avail=NULL;
 800243c:	4c0d      	ldr	r4, [pc, #52]	; (8002474 <mcu_key_get+0x3c>)

// mcu_key_get()
//
    const mcu_key_t *
mcu_key_get(bool *valid)
{
 800243e:	4606      	mov	r6, r0
    // get current "mcu_key" value; first byte will never be 0x0 or 0xff
    // - except if no key set yet/recently wiped
    // - if none set, returns ptr to first available slot which will be all ones
    const mcu_key_t *ptr = rom_secrets->mcu_keys, *avail=NULL;
 8002440:	2500      	movs	r5, #0

    for(int i=0; i<numberof(rom_secrets->mcu_keys); i++, ptr++) {
        if(ptr->value[0] == 0xff) {
 8002442:	7823      	ldrb	r3, [r4, #0]
 8002444:	2bff      	cmp	r3, #255	; 0xff
 8002446:	d103      	bne.n	8002450 <mcu_key_get+0x18>
            if(!avail) {
 8002448:	2d00      	cmp	r5, #0
 800244a:	bf08      	it	eq
 800244c:	4625      	moveq	r5, r4
 800244e:	e006      	b.n	800245e <mcu_key_get+0x26>
                avail = ptr;
            }
        } else if(ptr->value[0] != 0x00) {
 8002450:	b12b      	cbz	r3, 800245e <mcu_key_get+0x26>
            rng_delay();
 8002452:	f000 f970 	bl	8002736 <rng_delay>
            *valid = true;
 8002456:	2301      	movs	r3, #1
 8002458:	7033      	strb	r3, [r6, #0]
            return ptr;
 800245a:	4625      	mov	r5, r4
 800245c:	e006      	b.n	800246c <mcu_key_get+0x34>
    // get current "mcu_key" value; first byte will never be 0x0 or 0xff
    // - except if no key set yet/recently wiped
    // - if none set, returns ptr to first available slot which will be all ones
    const mcu_key_t *ptr = rom_secrets->mcu_keys, *avail=NULL;

    for(int i=0; i<numberof(rom_secrets->mcu_keys); i++, ptr++) {
 800245e:	3420      	adds	r4, #32
 8002460:	4294      	cmp	r4, r2
 8002462:	d1ee      	bne.n	8002442 <mcu_key_get+0xa>
            *valid = true;
            return ptr;
        }
    }

    rng_delay();
 8002464:	f000 f967 	bl	8002736 <rng_delay>
    *valid = false;
 8002468:	2300      	movs	r3, #0
 800246a:	7033      	strb	r3, [r6, #0]
    return avail;
}
 800246c:	4628      	mov	r0, r5
 800246e:	bd70      	pop	{r4, r5, r6, pc}
 8002470:	0801f190 	.word	0x0801f190
 8002474:	0801e190 	.word	0x0801e190

08002478 <mcu_key_clear>:

// mcu_key_clear()
//
    void
mcu_key_clear(const mcu_key_t *cur)
{
 8002478:	b513      	push	{r0, r1, r4, lr}
    if(!cur) {
 800247a:	4604      	mov	r4, r0
 800247c:	b938      	cbnz	r0, 800248e <mcu_key_clear+0x16>
        bool valid;
        cur = mcu_key_get(&valid);
 800247e:	f10d 0007 	add.w	r0, sp, #7
 8002482:	f7ff ffd9 	bl	8002438 <mcu_key_get>

        if(!valid) return;
 8002486:	f89d 3007 	ldrb.w	r3, [sp, #7]
    void
mcu_key_clear(const mcu_key_t *cur)
{
    if(!cur) {
        bool valid;
        cur = mcu_key_get(&valid);
 800248a:	4604      	mov	r4, r0

        if(!valid) return;
 800248c:	b1e3      	cbz	r3, 80024c8 <mcu_key_clear+0x50>

    STATIC_ASSERT(offsetof(rom_secrets_t, mcu_keys) % 8 == 0);

    // no delays here since decision has been made, and don't 
    // want to give them more time to interrupt us
    flash_setup0();
 800248e:	f7ff fda3 	bl	8001fd8 <flash_setup0>
    flash_unlock();
 8002492:	f7ff fdc5 	bl	8002020 <flash_unlock>
        uint32_t  pos = (uint32_t)cur;
        flash_burn(pos, 0); pos += 8;
 8002496:	2200      	movs	r2, #0
 8002498:	2300      	movs	r3, #0
 800249a:	4620      	mov	r0, r4
 800249c:	f00b f850 	bl	800d540 <__flash_burn_veneer>
        flash_burn(pos, 0); pos += 8;
 80024a0:	2200      	movs	r2, #0
 80024a2:	2300      	movs	r3, #0
 80024a4:	f104 0008 	add.w	r0, r4, #8
 80024a8:	f00b f84a 	bl	800d540 <__flash_burn_veneer>
        flash_burn(pos, 0); pos += 8;
 80024ac:	2200      	movs	r2, #0
 80024ae:	2300      	movs	r3, #0
 80024b0:	f104 0010 	add.w	r0, r4, #16
 80024b4:	f00b f844 	bl	800d540 <__flash_burn_veneer>
        flash_burn(pos, 0);
 80024b8:	2200      	movs	r2, #0
 80024ba:	2300      	movs	r3, #0
 80024bc:	f104 0018 	add.w	r0, r4, #24
 80024c0:	f00b f83e 	bl	800d540 <__flash_burn_veneer>
    flash_lock();
 80024c4:	f7ff fda4 	bl	8002010 <flash_lock>
}
 80024c8:	b002      	add	sp, #8
 80024ca:	bd10      	pop	{r4, pc}

080024cc <mcu_key_usage>:

// mcu_key_usage()
//
    void
mcu_key_usage(int *avail_out, int *consumed_out)
{
 80024cc:	b570      	push	{r4, r5, r6, lr}
    const mcu_key_t *ptr = rom_secrets->mcu_keys;
    int avail = 0, used = 0;
 80024ce:	2300      	movs	r3, #0

// mcu_key_usage()
//
    void
mcu_key_usage(int *avail_out, int *consumed_out)
{
 80024d0:	4a08      	ldr	r2, [pc, #32]	; (80024f4 <mcu_key_usage+0x28>)
    const mcu_key_t *ptr = rom_secrets->mcu_keys;
    int avail = 0, used = 0;

    for(int i=0; i<numberof(rom_secrets->mcu_keys); i++, ptr++) {
 80024d2:	4e09      	ldr	r6, [pc, #36]	; (80024f8 <mcu_key_usage+0x2c>)
//
    void
mcu_key_usage(int *avail_out, int *consumed_out)
{
    const mcu_key_t *ptr = rom_secrets->mcu_keys;
    int avail = 0, used = 0;
 80024d4:	461c      	mov	r4, r3

    for(int i=0; i<numberof(rom_secrets->mcu_keys); i++, ptr++) {
        if(ptr->value[0] == 0xff) {
 80024d6:	f812 5c20 	ldrb.w	r5, [r2, #-32]
 80024da:	2dff      	cmp	r5, #255	; 0xff
 80024dc:	d101      	bne.n	80024e2 <mcu_key_usage+0x16>
            avail ++;
 80024de:	3401      	adds	r4, #1
 80024e0:	e001      	b.n	80024e6 <mcu_key_usage+0x1a>
        } else if(ptr->value[0] == 0x00) {
 80024e2:	b905      	cbnz	r5, 80024e6 <mcu_key_usage+0x1a>
            used ++;
 80024e4:	3301      	adds	r3, #1
 80024e6:	3220      	adds	r2, #32
mcu_key_usage(int *avail_out, int *consumed_out)
{
    const mcu_key_t *ptr = rom_secrets->mcu_keys;
    int avail = 0, used = 0;

    for(int i=0; i<numberof(rom_secrets->mcu_keys); i++, ptr++) {
 80024e8:	42b2      	cmp	r2, r6
 80024ea:	d1f4      	bne.n	80024d6 <mcu_key_usage+0xa>
        } else if(ptr->value[0] == 0x00) {
            used ++;
        }
    }

    *avail_out = avail;
 80024ec:	6004      	str	r4, [r0, #0]
    *consumed_out = used;
 80024ee:	600b      	str	r3, [r1, #0]
 80024f0:	bd70      	pop	{r4, r5, r6, pc}
 80024f2:	bf00      	nop
 80024f4:	0801e1b0 	.word	0x0801e1b0
 80024f8:	0801f1b0 	.word	0x0801f1b0

080024fc <mcu_key_pick>:

// mcu_key_pick()
//
    const mcu_key_t *
mcu_key_pick(void)
{
 80024fc:	b530      	push	{r4, r5, lr}
 80024fe:	b08d      	sub	sp, #52	; 0x34
    mcu_key_t       n;

    // get some good entropy, and whiten it just in case.
    do { 
        rng_buffer(n.value, 32);
 8002500:	2120      	movs	r1, #32
 8002502:	a804      	add	r0, sp, #16
 8002504:	f000 f900 	bl	8002708 <rng_buffer>
        sha256_single(n.value, 32, n.value);
 8002508:	aa04      	add	r2, sp, #16
 800250a:	4610      	mov	r0, r2
 800250c:	2120      	movs	r1, #32
 800250e:	f002 ff89 	bl	8005424 <sha256_single>
        sha256_single(n.value, 32, n.value);
 8002512:	aa04      	add	r2, sp, #16
 8002514:	2120      	movs	r1, #32
 8002516:	4610      	mov	r0, r2
 8002518:	f002 ff84 	bl	8005424 <sha256_single>
    } while(n.value[0] == 0x0 || n.value[0] == 0xff);
 800251c:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8002520:	3b01      	subs	r3, #1
 8002522:	b2db      	uxtb	r3, r3
 8002524:	2bfd      	cmp	r3, #253	; 0xfd
 8002526:	d8eb      	bhi.n	8002500 <mcu_key_pick+0x4>

    const mcu_key_t *cur;

    do {
        bool valid = false; 
 8002528:	a80c      	add	r0, sp, #48	; 0x30
 800252a:	2300      	movs	r3, #0
 800252c:	f800 3d29 	strb.w	r3, [r0, #-41]!
        cur = mcu_key_get(&valid);
 8002530:	f7ff ff82 	bl	8002438 <mcu_key_get>

        if(!cur) {
 8002534:	4605      	mov	r5, r0
 8002536:	b938      	cbnz	r0, 8002548 <mcu_key_pick+0x4c>
            // no free slots. we are brick.
            puts("mk full");
 8002538:	481b      	ldr	r0, [pc, #108]	; (80025a8 <mcu_key_pick+0xac>)
 800253a:	f002 fbbb 	bl	8004cb4 <puts>
            oled_show(screen_brick);
 800253e:	481b      	ldr	r0, [pc, #108]	; (80025ac <mcu_key_pick+0xb0>)
 8002540:	f7fe fc58 	bl	8000df4 <oled_show>

            LOCKUP_FOREVER();
 8002544:	bf30      	wfi
 8002546:	e7fd      	b.n	8002544 <mcu_key_pick+0x48>
        }

        if(valid) {
 8002548:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800254c:	b14b      	cbz	r3, 8002562 <mcu_key_pick+0x66>
            // clear existing key, if it's defined.
            ASSERT(cur->value[0] != 0x00);
 800254e:	7803      	ldrb	r3, [r0, #0]
 8002550:	3b01      	subs	r3, #1
 8002552:	b2db      	uxtb	r3, r3
 8002554:	2bfd      	cmp	r3, #253	; 0xfd
 8002556:	d902      	bls.n	800255e <mcu_key_pick+0x62>
 8002558:	4815      	ldr	r0, [pc, #84]	; (80025b0 <mcu_key_pick+0xb4>)
 800255a:	f7fe fa3f 	bl	80009dc <fatal_error>
            ASSERT(cur->value[0] != 0xff);

            mcu_key_clear(cur);
 800255e:	f7ff ff8b 	bl	8002478 <mcu_key_clear>
            continue;
        }
    } while(0);
    
    // burn it
    flash_setup0();
 8002562:	f7ff fd39 	bl	8001fd8 <flash_setup0>
    flash_unlock();
 8002566:	f7ff fd5b 	bl	8002020 <flash_unlock>
        uint32_t  pos = (uint32_t)cur;
        const uint8_t   *fr = n.value;

        for(int i=0; i<32; i+= 8, pos += 8, fr += 8) {
 800256a:	2400      	movs	r4, #0
            uint64_t v;
            memcpy(&v, fr, sizeof(v));
 800256c:	ab04      	add	r3, sp, #16
 800256e:	191a      	adds	r2, r3, r4
 8002570:	ab02      	add	r3, sp, #8
 8002572:	6810      	ldr	r0, [r2, #0]
 8002574:	6851      	ldr	r1, [r2, #4]
 8002576:	c303      	stmia	r3!, {r0, r1}

            flash_burn(pos, v);
 8002578:	1928      	adds	r0, r5, r4
 800257a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    flash_setup0();
    flash_unlock();
        uint32_t  pos = (uint32_t)cur;
        const uint8_t   *fr = n.value;

        for(int i=0; i<32; i+= 8, pos += 8, fr += 8) {
 800257e:	3408      	adds	r4, #8
            uint64_t v;
            memcpy(&v, fr, sizeof(v));

            flash_burn(pos, v);
 8002580:	f00a ffde 	bl	800d540 <__flash_burn_veneer>
    flash_setup0();
    flash_unlock();
        uint32_t  pos = (uint32_t)cur;
        const uint8_t   *fr = n.value;

        for(int i=0; i<32; i+= 8, pos += 8, fr += 8) {
 8002584:	2c20      	cmp	r4, #32
 8002586:	d1f1      	bne.n	800256c <mcu_key_pick+0x70>
            uint64_t v;
            memcpy(&v, fr, sizeof(v));

            flash_burn(pos, v);
        }
    flash_lock();
 8002588:	f7ff fd42 	bl	8002010 <flash_lock>

#if 1
    // check it
    bool valid = false; 
 800258c:	2300      	movs	r3, #0
    const mcu_key_t *after = mcu_key_get(&valid);
 800258e:	a802      	add	r0, sp, #8
        }
    flash_lock();

#if 1
    // check it
    bool valid = false; 
 8002590:	f88d 3008 	strb.w	r3, [sp, #8]
    const mcu_key_t *after = mcu_key_get(&valid);
 8002594:	f7ff ff50 	bl	8002438 <mcu_key_get>
    ASSERT(valid);
 8002598:	f89d 2008 	ldrb.w	r2, [sp, #8]
 800259c:	2a00      	cmp	r2, #0
 800259e:	d0db      	beq.n	8002558 <mcu_key_pick+0x5c>
    ASSERT(after == cur);
 80025a0:	4285      	cmp	r5, r0
 80025a2:	d1d9      	bne.n	8002558 <mcu_key_pick+0x5c>
#endif

    return cur;
}
 80025a4:	b00d      	add	sp, #52	; 0x34
 80025a6:	bd30      	pop	{r4, r5, pc}
 80025a8:	0800e390 	.word	0x0800e390
 80025ac:	0800de53 	.word	0x0800de53
 80025b0:	0800d550 	.word	0x0800d550

080025b4 <fast_brick>:

// fast_brick()
//
    void
fast_brick(void)
{
 80025b4:	b538      	push	{r3, r4, r5, lr}
    flash_setup0();
 80025b6:	f7ff fd0f 	bl	8001fd8 <flash_setup0>
    flash_unlock();
 80025ba:	f7ff fd31 	bl	8002020 <flash_unlock>
        // simply erase all the critical secrets
        flash_page_erase(BL_NVROM_BASE);
 80025be:	480b      	ldr	r0, [pc, #44]	; (80025ec <fast_brick+0x38>)

        // but then write zeros so it doesn't look like unprogrammed part
        for(uint32_t  pos = BL_NVROM_BASE, i=0; i<64/8; i++, pos += 8) {
 80025c0:	4c0a      	ldr	r4, [pc, #40]	; (80025ec <fast_brick+0x38>)
 80025c2:	4d0b      	ldr	r5, [pc, #44]	; (80025f0 <fast_brick+0x3c>)
fast_brick(void)
{
    flash_setup0();
    flash_unlock();
        // simply erase all the critical secrets
        flash_page_erase(BL_NVROM_BASE);
 80025c4:	f00a ffb4 	bl	800d530 <__flash_page_erase_veneer>

        // but then write zeros so it doesn't look like unprogrammed part
        for(uint32_t  pos = BL_NVROM_BASE, i=0; i<64/8; i++, pos += 8) {
            flash_burn(pos, 0);
 80025c8:	4620      	mov	r0, r4
 80025ca:	2200      	movs	r2, #0
 80025cc:	2300      	movs	r3, #0
    flash_unlock();
        // simply erase all the critical secrets
        flash_page_erase(BL_NVROM_BASE);

        // but then write zeros so it doesn't look like unprogrammed part
        for(uint32_t  pos = BL_NVROM_BASE, i=0; i<64/8; i++, pos += 8) {
 80025ce:	3408      	adds	r4, #8
            flash_burn(pos, 0);
 80025d0:	f00a ffb6 	bl	800d540 <__flash_burn_veneer>
    flash_unlock();
        // simply erase all the critical secrets
        flash_page_erase(BL_NVROM_BASE);

        // but then write zeros so it doesn't look like unprogrammed part
        for(uint32_t  pos = BL_NVROM_BASE, i=0; i<64/8; i++, pos += 8) {
 80025d4:	42ac      	cmp	r4, r5
 80025d6:	d1f7      	bne.n	80025c8 <fast_brick+0x14>
            flash_burn(pos, 0);
        }
    flash_lock();
 80025d8:	f7ff fd1a 	bl	8002010 <flash_lock>
    
    puts("fast brck");
 80025dc:	4805      	ldr	r0, [pc, #20]	; (80025f4 <fast_brick+0x40>)
 80025de:	f002 fb69 	bl	8004cb4 <puts>
    oled_show(screen_brick);
 80025e2:	4805      	ldr	r0, [pc, #20]	; (80025f8 <fast_brick+0x44>)
 80025e4:	f7fe fc06 	bl	8000df4 <oled_show>

    LOCKUP_FOREVER();
 80025e8:	bf30      	wfi
 80025ea:	e7fd      	b.n	80025e8 <fast_brick+0x34>
 80025ec:	0801e000 	.word	0x0801e000
 80025f0:	0801e040 	.word	0x0801e040
 80025f4:	0800e398 	.word	0x0800e398
 80025f8:	0800de53 	.word	0x0800de53

080025fc <fast_wipe>:

// fast_wipe()
//
    void
fast_wipe(void)
{
 80025fc:	b508      	push	{r3, lr}
    // dump (part of) the main seed key and become a new Coldcard
    // - lots of other code can and will detect a missing MCU key as "blank"
    // - and the check value on main seed will be garbage now
    mcu_key_clear(NULL);
 80025fe:	2000      	movs	r0, #0
 8002600:	f7ff ff3a 	bl	8002478 <mcu_key_clear>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8002604:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8002608:	4905      	ldr	r1, [pc, #20]	; (8002620 <fast_wipe+0x24>)
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800260a:	4b06      	ldr	r3, [pc, #24]	; (8002624 <fast_wipe+0x28>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800260c:	68ca      	ldr	r2, [r1, #12]
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800260e:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8002612:	4313      	orrs	r3, r2
 8002614:	60cb      	str	r3, [r1, #12]
 8002616:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 800261a:	bf00      	nop
 800261c:	e7fd      	b.n	800261a <fast_wipe+0x1e>
 800261e:	bf00      	nop
 8002620:	e000ed00 	.word	0xe000ed00
 8002624:	05fa0004 	.word	0x05fa0004

08002628 <check_all_ones>:
//
// Return T if all bytes are 0xFF
//
	bool
check_all_ones(const void *ptrV, int len)
{
 8002628:	b510      	push	{r4, lr}
 800262a:	4401      	add	r1, r0
	uint8_t rv = 0xff;
 800262c:	24ff      	movs	r4, #255	; 0xff
	const uint8_t *ptr = (const uint8_t *)ptrV;

	for(; len; len--, ptr++) {
 800262e:	4288      	cmp	r0, r1
 8002630:	d003      	beq.n	800263a <check_all_ones+0x12>
		rv &= *ptr;
 8002632:	f810 3b01 	ldrb.w	r3, [r0], #1
 8002636:	401c      	ands	r4, r3
 8002638:	e7f9      	b.n	800262e <check_all_ones+0x6>
	}

    rng_delay();
 800263a:	f000 f87c 	bl	8002736 <rng_delay>
	return (rv == 0xff);
}
 800263e:	f1a4 03ff 	sub.w	r3, r4, #255	; 0xff
 8002642:	4258      	negs	r0, r3
 8002644:	4158      	adcs	r0, r3
 8002646:	bd10      	pop	{r4, pc}

08002648 <check_all_zeros>:
//
// Return T if all bytes are 0x00
//
	bool
check_all_zeros(const void *ptrV, int len)
{
 8002648:	b510      	push	{r4, lr}
 800264a:	4401      	add	r1, r0
	uint8_t rv = 0x0;
 800264c:	2400      	movs	r4, #0
	const uint8_t *ptr = (const uint8_t *)ptrV;

	for(; len; len--, ptr++) {
 800264e:	4288      	cmp	r0, r1
 8002650:	d003      	beq.n	800265a <check_all_zeros+0x12>
		rv |= *ptr;
 8002652:	f810 3b01 	ldrb.w	r3, [r0], #1
 8002656:	431c      	orrs	r4, r3
 8002658:	e7f9      	b.n	800264e <check_all_zeros+0x6>
	}

    rng_delay();
 800265a:	f000 f86c 	bl	8002736 <rng_delay>
	return (rv == 0x00);
}
 800265e:	fab4 f084 	clz	r0, r4
 8002662:	0940      	lsrs	r0, r0, #5
 8002664:	bd10      	pop	{r4, pc}

08002666 <check_equal>:
	const uint8_t *left = (const uint8_t *)aV;
	const uint8_t *right = (const uint8_t *)bV;
    uint8_t diff = 0;
    int i;

    for (i = 0; i < len; i++) {
 8002666:	2300      	movs	r3, #0
//
// Equality check.
//
	bool
check_equal(const void *aV, const void *bV, int len)
{
 8002668:	b570      	push	{r4, r5, r6, lr}
	const uint8_t *left = (const uint8_t *)aV;
	const uint8_t *right = (const uint8_t *)bV;
    uint8_t diff = 0;
 800266a:	461c      	mov	r4, r3
    int i;

    for (i = 0; i < len; i++) {
 800266c:	4293      	cmp	r3, r2
 800266e:	da05      	bge.n	800267c <check_equal+0x16>
        diff |= (left[i] ^ right[i]);
 8002670:	5cc6      	ldrb	r6, [r0, r3]
 8002672:	5ccd      	ldrb	r5, [r1, r3]
 8002674:	4075      	eors	r5, r6
 8002676:	432c      	orrs	r4, r5
	const uint8_t *left = (const uint8_t *)aV;
	const uint8_t *right = (const uint8_t *)bV;
    uint8_t diff = 0;
    int i;

    for (i = 0; i < len; i++) {
 8002678:	3301      	adds	r3, #1
 800267a:	e7f7      	b.n	800266c <check_equal+0x6>
        diff |= (left[i] ^ right[i]);
    }

    rng_delay();
 800267c:	f000 f85b 	bl	8002736 <rng_delay>
    return (diff == 0);
}
 8002680:	fab4 f084 	clz	r0, r4
 8002684:	0940      	lsrs	r0, r0, #5
 8002686:	bd70      	pop	{r4, r5, r6, pc}

08002688 <rng_sample>:
        }

        // Get the new number
        uint32_t rv = RNG->DR;

        if(rv != last_rng_result && rv) {
 8002688:	4b07      	ldr	r3, [pc, #28]	; (80026a8 <rng_sample+0x20>)
{
    static uint32_t last_rng_result;

    while(1) {
        // Check if data register contains valid random data
        while(!(RNG->SR & RNG_FLAG_DRDY)) {
 800268a:	4a08      	ldr	r2, [pc, #32]	; (80026ac <rng_sample+0x24>)
        }

        // Get the new number
        uint32_t rv = RNG->DR;

        if(rv != last_rng_result && rv) {
 800268c:	6819      	ldr	r1, [r3, #0]

// rng_sample()
//
    uint32_t
rng_sample(void)
{
 800268e:	b510      	push	{r4, lr}
    static uint32_t last_rng_result;

    while(1) {
        // Check if data register contains valid random data
        while(!(RNG->SR & RNG_FLAG_DRDY)) {
 8002690:	4614      	mov	r4, r2
 8002692:	6850      	ldr	r0, [r2, #4]
 8002694:	07c0      	lsls	r0, r0, #31
 8002696:	d5fc      	bpl.n	8002692 <rng_sample+0xa>
            // busy wait; okay to get stuck here... better than failing.
        }

        // Get the new number
        uint32_t rv = RNG->DR;
 8002698:	68a0      	ldr	r0, [r4, #8]

        if(rv != last_rng_result && rv) {
 800269a:	4288      	cmp	r0, r1
 800269c:	d0f9      	beq.n	8002692 <rng_sample+0xa>
 800269e:	2800      	cmp	r0, #0
 80026a0:	d0f7      	beq.n	8002692 <rng_sample+0xa>
            last_rng_result = rv;
 80026a2:	6018      	str	r0, [r3, #0]

        // keep trying if not a new number
    }

    // NOT-REACHED
}
 80026a4:	bd10      	pop	{r4, pc}
 80026a6:	bf00      	nop
 80026a8:	200001cc 	.word	0x200001cc
 80026ac:	50060800 	.word	0x50060800

080026b0 <rng_setup>:
// rng_setup()
//
    void
rng_setup(void)
{
    if(RNG->CR & RNG_CR_RNGEN) {
 80026b0:	4b12      	ldr	r3, [pc, #72]	; (80026fc <rng_setup+0x4c>)
 80026b2:	681a      	ldr	r2, [r3, #0]
 80026b4:	0752      	lsls	r2, r2, #29

// rng_setup()
//
    void
rng_setup(void)
{
 80026b6:	b513      	push	{r0, r1, r4, lr}
    if(RNG->CR & RNG_CR_RNGEN) {
 80026b8:	d41d      	bmi.n	80026f6 <rng_setup+0x46>
        // already setup
        return;
    }

    // Enable the Peripheral
    __HAL_RCC_RNG_CLK_ENABLE();
 80026ba:	4a11      	ldr	r2, [pc, #68]	; (8002700 <rng_setup+0x50>)
 80026bc:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 80026be:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
 80026c2:	64d1      	str	r1, [r2, #76]	; 0x4c
 80026c4:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 80026c6:	f402 2280 	and.w	r2, r2, #262144	; 0x40000
 80026ca:	9201      	str	r2, [sp, #4]
 80026cc:	9a01      	ldr	r2, [sp, #4]

    // Turn on feature.
    RNG->CR |=  RNG_CR_RNGEN;
 80026ce:	681a      	ldr	r2, [r3, #0]
 80026d0:	f042 0204 	orr.w	r2, r2, #4
 80026d4:	601a      	str	r2, [r3, #0]

    // Sample twice to be sure that we have a 
    // valid RNG result.
    uint32_t chk = rng_sample();
 80026d6:	f7ff ffd7 	bl	8002688 <rng_sample>
 80026da:	4604      	mov	r4, r0
    uint32_t chk2 = rng_sample();
 80026dc:	f7ff ffd4 	bl	8002688 <rng_sample>

    // die if we are clearly not getting random values
    if(chk == 0 || chk == ~0
 80026e0:	1e63      	subs	r3, r4, #1
 80026e2:	3303      	adds	r3, #3
 80026e4:	d804      	bhi.n	80026f0 <rng_setup+0x40>
        || chk2 == 0 || chk2 == ~0
 80026e6:	1e43      	subs	r3, r0, #1
 80026e8:	3303      	adds	r3, #3
 80026ea:	d801      	bhi.n	80026f0 <rng_setup+0x40>
        || chk == chk2
 80026ec:	4284      	cmp	r4, r0
 80026ee:	d102      	bne.n	80026f6 <rng_setup+0x46>
    ) {
        INCONSISTENT("bad rng");
 80026f0:	4804      	ldr	r0, [pc, #16]	; (8002704 <rng_setup+0x54>)
 80026f2:	f7fe f973 	bl	80009dc <fatal_error>

        while(1) ;
    }
}
 80026f6:	b002      	add	sp, #8
 80026f8:	bd10      	pop	{r4, pc}
 80026fa:	bf00      	nop
 80026fc:	50060800 	.word	0x50060800
 8002700:	40021000 	.word	0x40021000
 8002704:	0800d557 	.word	0x0800d557

08002708 <rng_buffer>:

// rng_buffer()
//
    void
rng_buffer(uint8_t *result, int len)
{
 8002708:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800270a:	4607      	mov	r7, r0
 800270c:	460e      	mov	r6, r1
    while(len > 0) {
 800270e:	460c      	mov	r4, r1
 8002710:	1b35      	subs	r5, r6, r4
 8002712:	2c00      	cmp	r4, #0
 8002714:	443d      	add	r5, r7
 8002716:	dd0c      	ble.n	8002732 <rng_buffer+0x2a>
        uint32_t    t = rng_sample();
 8002718:	f7ff ffb6 	bl	8002688 <rng_sample>

        memcpy(result, &t, MIN(4, len));
 800271c:	2c04      	cmp	r4, #4
 800271e:	4622      	mov	r2, r4
//
    void
rng_buffer(uint8_t *result, int len)
{
    while(len > 0) {
        uint32_t    t = rng_sample();
 8002720:	9001      	str	r0, [sp, #4]

        memcpy(result, &t, MIN(4, len));
 8002722:	bfa8      	it	ge
 8002724:	2204      	movge	r2, #4
 8002726:	a901      	add	r1, sp, #4
 8002728:	4628      	mov	r0, r5
 800272a:	f00a fea6 	bl	800d47a <memcpy>

        len -= 4;
 800272e:	3c04      	subs	r4, #4
 8002730:	e7ee      	b.n	8002710 <rng_buffer+0x8>
        result += 4;
    }
}
 8002732:	b003      	add	sp, #12
 8002734:	bdf0      	pop	{r4, r5, r6, r7, pc}

08002736 <rng_delay>:
//
// Call anytime. Delays for a random time period to fustrate glitchers.
//
    void
rng_delay(void)
{
 8002736:	b508      	push	{r3, lr}
    uint32_t    r = rng_sample() % 20;
 8002738:	f7ff ffa6 	bl	8002688 <rng_sample>
    uint32_t    cnt = (1<<r);
 800273c:	2314      	movs	r3, #20
 800273e:	fbb0 f2f3 	udiv	r2, r0, r3
 8002742:	fb02 0013 	mls	r0, r2, r3, r0
 8002746:	2301      	movs	r3, #1
 8002748:	fa03 f000 	lsl.w	r0, r3, r0

    while(cnt) {
        asm("nop");         // need this to keep from being optimized away, check bootloader.lss
 800274c:	bf00      	nop
rng_delay(void)
{
    uint32_t    r = rng_sample() % 20;
    uint32_t    cnt = (1<<r);

    while(cnt) {
 800274e:	3801      	subs	r0, #1
 8002750:	d1fc      	bne.n	800274c <rng_delay+0x16>
        asm("nop");         // need this to keep from being optimized away, check bootloader.lss
        cnt--;
    }
}
 8002752:	bd08      	pop	{r3, pc}

08002754 <_send_byte>:
    static inline void
_send_byte(uint8_t ch)
{
    // reset timeout timer (Systick)
    uint32_t    ticks = 0;
    SysTick->VAL = 0;
 8002754:	4b08      	ldr	r3, [pc, #32]	; (8002778 <_send_byte+0x24>)

// _send_byte()
//
    static inline void
_send_byte(uint8_t ch)
{
 8002756:	b510      	push	{r4, lr}
    // reset timeout timer (Systick)
    uint32_t    ticks = 0;
    SysTick->VAL = 0;
 8002758:	2200      	movs	r2, #0

    while(!(MY_UART->ISR & UART_FLAG_TXE)) {
 800275a:	4c08      	ldr	r4, [pc, #32]	; (800277c <_send_byte+0x28>)
    static inline void
_send_byte(uint8_t ch)
{
    // reset timeout timer (Systick)
    uint32_t    ticks = 0;
    SysTick->VAL = 0;
 800275c:	609a      	str	r2, [r3, #8]

    while(!(MY_UART->ISR & UART_FLAG_TXE)) {
 800275e:	220b      	movs	r2, #11
 8002760:	69e1      	ldr	r1, [r4, #28]
 8002762:	0609      	lsls	r1, r1, #24
 8002764:	d404      	bmi.n	8002770 <_send_byte+0x1c>
        // busy-wait until able to send (no fifo?)
        if(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) {
 8002766:	6819      	ldr	r1, [r3, #0]
 8002768:	03c9      	lsls	r1, r1, #15
 800276a:	d5f9      	bpl.n	8002760 <_send_byte+0xc>
            // failsafe timeout
            ticks += 1;
            if(ticks > 10) break;
 800276c:	3a01      	subs	r2, #1
 800276e:	d1f7      	bne.n	8002760 <_send_byte+0xc>
        }
    }
    MY_UART->TDR = ch;
 8002770:	4b02      	ldr	r3, [pc, #8]	; (800277c <_send_byte+0x28>)
 8002772:	b280      	uxth	r0, r0
 8002774:	8518      	strh	r0, [r3, #40]	; 0x28
 8002776:	bd10      	pop	{r4, pc}
 8002778:	e000e010 	.word	0xe000e010
 800277c:	40004c00 	.word	0x40004c00

08002780 <_send_bits>:

// _send_bits()
//
    static void
_send_bits(uint8_t tx)
{
 8002780:	b570      	push	{r4, r5, r6, lr}
 8002782:	4606      	mov	r6, r0
 8002784:	2508      	movs	r5, #8
    // serialize and send one byte
    uint8_t     mask = 0x1;
 8002786:	2401      	movs	r4, #1

    for(int i=0; i<8; i++, mask <<= 1) {
        uint8_t h = (tx & mask) ? BIT1 : BIT0;
 8002788:	4226      	tst	r6, r4

        _send_byte(h);
 800278a:	bf14      	ite	ne
 800278c:	207f      	movne	r0, #127	; 0x7f
 800278e:	207d      	moveq	r0, #125	; 0x7d
 8002790:	f7ff ffe0 	bl	8002754 <_send_byte>
_send_bits(uint8_t tx)
{
    // serialize and send one byte
    uint8_t     mask = 0x1;

    for(int i=0; i<8; i++, mask <<= 1) {
 8002794:	0064      	lsls	r4, r4, #1
 8002796:	3d01      	subs	r5, #1
 8002798:	b2e4      	uxtb	r4, r4
 800279a:	d1f5      	bne.n	8002788 <_send_bits+0x8>
        uint8_t h = (tx & mask) ? BIT1 : BIT0;

        _send_byte(h);
    }
}
 800279c:	bd70      	pop	{r4, r5, r6, pc}

0800279e <_send_serialized>:

// _send_serialized()
//
    static void
_send_serialized(const uint8_t *buf, int len)
{
 800279e:	b570      	push	{r4, r5, r6, lr}
 80027a0:	4605      	mov	r5, r0
 80027a2:	460e      	mov	r6, r1
    for(int i=0; i<len; i++) {
 80027a4:	4604      	mov	r4, r0
 80027a6:	1b63      	subs	r3, r4, r5
 80027a8:	429e      	cmp	r6, r3
 80027aa:	dd04      	ble.n	80027b6 <_send_serialized+0x18>
        _send_bits(buf[i]);
 80027ac:	f814 0b01 	ldrb.w	r0, [r4], #1
 80027b0:	f7ff ffe6 	bl	8002780 <_send_bits>
 80027b4:	e7f7      	b.n	80027a6 <_send_serialized+0x8>
    }
}
 80027b6:	bd70      	pop	{r4, r5, r6, pc}

080027b8 <_flush_rx>:
//
    static inline void
_flush_rx(void)
{
    // reset timeout timer (Systick)
    SysTick->VAL = 0;
 80027b8:	4b0c      	ldr	r3, [pc, #48]	; (80027ec <_flush_rx+0x34>)

    while(!(MY_UART->ISR & UART_FLAG_TC)) {
 80027ba:	490d      	ldr	r1, [pc, #52]	; (80027f0 <_flush_rx+0x38>)
//
    static inline void
_flush_rx(void)
{
    // reset timeout timer (Systick)
    SysTick->VAL = 0;
 80027bc:	2200      	movs	r2, #0
 80027be:	609a      	str	r2, [r3, #8]

    while(!(MY_UART->ISR & UART_FLAG_TC)) {
 80027c0:	69ca      	ldr	r2, [r1, #28]
 80027c2:	0652      	lsls	r2, r2, #25
 80027c4:	d402      	bmi.n	80027cc <_flush_rx+0x14>
        // wait for last bit(byte) to be serialized and sent

        if(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) {
 80027c6:	681a      	ldr	r2, [r3, #0]
 80027c8:	03d0      	lsls	r0, r2, #15
 80027ca:	d5f9      	bpl.n	80027c0 <_flush_rx+0x8>
            break;
        }
    }

    // We actualy need this delay here!
    __NOP();
 80027cc:	bf00      	nop
    __NOP();
 80027ce:	bf00      	nop
    __NOP();
 80027d0:	bf00      	nop
    __NOP();
 80027d2:	bf00      	nop
    __NOP();
 80027d4:	bf00      	nop
    __NOP();
 80027d6:	bf00      	nop
    __NOP();
 80027d8:	bf00      	nop
    __NOP();
 80027da:	bf00      	nop

    // clear junk in rx buffer
    MY_UART->RQR = USART_RQR_RXFRQ;
 80027dc:	4b04      	ldr	r3, [pc, #16]	; (80027f0 <_flush_rx+0x38>)
 80027de:	2208      	movs	r2, #8
 80027e0:	831a      	strh	r2, [r3, #24]

    // clear overrun error
    // clear rx timeout flag
    // clear framing error
    MY_UART->ICR = USART_ICR_ORECF | USART_ICR_RTOCF | USART_ICR_FECF;
 80027e2:	f640 020a 	movw	r2, #2058	; 0x80a
 80027e6:	621a      	str	r2, [r3, #32]
 80027e8:	4770      	bx	lr
 80027ea:	bf00      	nop
 80027ec:	e000e010 	.word	0xe000e010
 80027f0:	40004c00 	.word	0x40004c00

080027f4 <crc16_chain>:
 * \param[in] data pointer to data for which CRC should be calculated
 * \param[out] crc pointer to 16-bit CRC
 */ 
	static void
crc16_chain(uint8_t length, const uint8_t *data, uint8_t crc[2])
{
 80027f4:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16_t crc_register = 0;
    uint16_t polynom = 0x8005;
    uint8_t shift_register;
    uint8_t data_bit, crc_bit;
    
    crc_register = (((uint16_t) crc[0]) & 0x00FF) | (((uint16_t) crc[1]) << 8);
 80027f6:	7813      	ldrb	r3, [r2, #0]
 80027f8:	7854      	ldrb	r4, [r2, #1]
    
    for (counter = 0; counter < length; counter++) {
 80027fa:	460e      	mov	r6, r1
    uint16_t crc_register = 0;
    uint16_t polynom = 0x8005;
    uint8_t shift_register;
    uint8_t data_bit, crc_bit;
    
    crc_register = (((uint16_t) crc[0]) & 0x00FF) | (((uint16_t) crc[1]) << 8);
 80027fc:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
    
    for (counter = 0; counter < length; counter++) {
 8002800:	1a74      	subs	r4, r6, r1
 8002802:	b2e4      	uxtb	r4, r4
 8002804:	42a0      	cmp	r0, r4
 8002806:	d91a      	bls.n	800283e <crc16_chain+0x4a>
      for (shift_register = 0x01; shift_register > 0x00; shift_register <<= 1) {
         data_bit = (data[counter] & shift_register) ? 1 : 0;
 8002808:	f816 7b01 	ldrb.w	r7, [r6], #1
 800280c:	2508      	movs	r5, #8
 800280e:	2401      	movs	r4, #1
         crc_bit = crc_register >> 15;

         // Shift CRC to the left by 1.
         crc_register <<= 1; 

         if ((data_bit ^ crc_bit) != 0)
 8002810:	4227      	tst	r7, r4
    crc_register = (((uint16_t) crc[0]) & 0x00FF) | (((uint16_t) crc[1]) << 8);
    
    for (counter = 0; counter < length; counter++) {
      for (shift_register = 0x01; shift_register > 0x00; shift_register <<= 1) {
         data_bit = (data[counter] & shift_register) ? 1 : 0;
         crc_bit = crc_register >> 15;
 8002812:	ea4f 3ed3 	mov.w	lr, r3, lsr #15

         // Shift CRC to the left by 1.
         crc_register <<= 1; 

         if ((data_bit ^ crc_bit) != 0)
 8002816:	bf18      	it	ne
 8002818:	f04f 0c01 	movne.w	ip, #1
      for (shift_register = 0x01; shift_register > 0x00; shift_register <<= 1) {
         data_bit = (data[counter] & shift_register) ? 1 : 0;
         crc_bit = crc_register >> 15;

         // Shift CRC to the left by 1.
         crc_register <<= 1; 
 800281c:	ea4f 0343 	mov.w	r3, r3, lsl #1

         if ((data_bit ^ crc_bit) != 0)
 8002820:	bf08      	it	eq
 8002822:	f04f 0c00 	moveq.w	ip, #0
 8002826:	45f4      	cmp	ip, lr
      for (shift_register = 0x01; shift_register > 0x00; shift_register <<= 1) {
         data_bit = (data[counter] & shift_register) ? 1 : 0;
         crc_bit = crc_register >> 15;

         // Shift CRC to the left by 1.
         crc_register <<= 1; 
 8002828:	b29b      	uxth	r3, r3

         if ((data_bit ^ crc_bit) != 0)
            crc_register ^= polynom;
 800282a:	bf1c      	itt	ne
 800282c:	f483 4300 	eorne.w	r3, r3, #32768	; 0x8000
 8002830:	f083 0305 	eorne.w	r3, r3, #5
    uint8_t data_bit, crc_bit;
    
    crc_register = (((uint16_t) crc[0]) & 0x00FF) | (((uint16_t) crc[1]) << 8);
    
    for (counter = 0; counter < length; counter++) {
      for (shift_register = 0x01; shift_register > 0x00; shift_register <<= 1) {
 8002834:	0064      	lsls	r4, r4, #1
 8002836:	3d01      	subs	r5, #1
 8002838:	b2e4      	uxtb	r4, r4
 800283a:	d1e9      	bne.n	8002810 <crc16_chain+0x1c>
 800283c:	e7e0      	b.n	8002800 <crc16_chain+0xc>
         if ((data_bit ^ crc_bit) != 0)
            crc_register ^= polynom;
      }  
    }
        
    crc[0] = (uint8_t) (crc_register & 0x00FF);
 800283e:	7013      	strb	r3, [r2, #0]
    crc[1] = (uint8_t) (crc_register >> 8);
 8002840:	0a1b      	lsrs	r3, r3, #8
 8002842:	7053      	strb	r3, [r2, #1]
 8002844:	bdf0      	pop	{r4, r5, r6, r7, pc}

08002846 <ae_check_crc>:

// ae_check_crc()
//
	static bool
ae_check_crc(const uint8_t *data, uint8_t length)
{
 8002846:	b573      	push	{r0, r1, r4, r5, r6, lr}
	uint8_t obs[2] = { 0, 0 };

	if(data[0] != length) {
 8002848:	7805      	ldrb	r5, [r0, #0]
// ae_check_crc()
//
	static bool
ae_check_crc(const uint8_t *data, uint8_t length)
{
	uint8_t obs[2] = { 0, 0 };
 800284a:	2400      	movs	r4, #0

	if(data[0] != length) {
 800284c:	428d      	cmp	r5, r1

// ae_check_crc()
//
	static bool
ae_check_crc(const uint8_t *data, uint8_t length)
{
 800284e:	4606      	mov	r6, r0
	uint8_t obs[2] = { 0, 0 };
 8002850:	f88d 4004 	strb.w	r4, [sp, #4]
 8002854:	f88d 4005 	strb.w	r4, [sp, #5]

	if(data[0] != length) {
 8002858:	d113      	bne.n	8002882 <ae_check_crc+0x3c>
		// length is wrong
        STATS(crc_len_error++);
		return false;
	}

	crc16_chain(length-2, data, obs);
 800285a:	1ea8      	subs	r0, r5, #2

	return (obs[0] == data[length-2] && obs[1] == data[length-1]);
 800285c:	4435      	add	r5, r6
		// length is wrong
        STATS(crc_len_error++);
		return false;
	}

	crc16_chain(length-2, data, obs);
 800285e:	aa01      	add	r2, sp, #4
 8002860:	4631      	mov	r1, r6
 8002862:	b2c0      	uxtb	r0, r0
 8002864:	f7ff ffc6 	bl	80027f4 <crc16_chain>

	return (obs[0] == data[length-2] && obs[1] == data[length-1]);
 8002868:	f89d 2004 	ldrb.w	r2, [sp, #4]
 800286c:	f815 3c02 	ldrb.w	r3, [r5, #-2]
 8002870:	429a      	cmp	r2, r3
 8002872:	d106      	bne.n	8002882 <ae_check_crc+0x3c>
 8002874:	f89d 4005 	ldrb.w	r4, [sp, #5]
 8002878:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 800287c:	1b1b      	subs	r3, r3, r4
 800287e:	425c      	negs	r4, r3
 8002880:	415c      	adcs	r4, r3
	uint8_t obs[2] = { 0, 0 };

	if(data[0] != length) {
		// length is wrong
        STATS(crc_len_error++);
		return false;
 8002882:	4620      	mov	r0, r4
	}

	crc16_chain(length-2, data, obs);

	return (obs[0] == data[length-2] && obs[1] == data[length-1]);
}
 8002884:	b002      	add	sp, #8
 8002886:	bd70      	pop	{r4, r5, r6, pc}

08002888 <ae_wake>:
// Prior to First Command) as an error to any on-going/attempted operation.
//
//
    static void
ae_wake(void)
{
 8002888:	b508      	push	{r3, lr}
    // send zero (all low), delay 2.5ms
    _send_byte(0x00);
 800288a:	2000      	movs	r0, #0
 800288c:	f7ff ff62 	bl	8002754 <_send_byte>

    delay_ms(3);     // measured: ~2.9ms
 8002890:	2003      	movs	r0, #3
 8002892:	f000 fff9 	bl	8003888 <delay_ms>

    _flush_rx();
}
 8002896:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    // send zero (all low), delay 2.5ms
    _send_byte(0x00);

    delay_ms(3);     // measured: ~2.9ms

    _flush_rx();
 800289a:	f7ff bf8d 	b.w	80027b8 <_flush_rx>
	...

080028a0 <ae_read_response>:
// We ignore extra bytes not expected, and always read until a timeout.
// Cmds to chip can be up to 155 bytes, but not clear what max len for responses.
//
    static int
ae_read_response(uint8_t *buf, int max_len)
{
 80028a0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    int max_expect = (max_len+1) * 8;
 80028a4:	1c4c      	adds	r4, r1, #1
 80028a6:	00e4      	lsls	r4, r4, #3
// We ignore extra bytes not expected, and always read until a timeout.
// Cmds to chip can be up to 155 bytes, but not clear what max len for responses.
//
    static int
ae_read_response(uint8_t *buf, int max_len)
{
 80028a8:	af00      	add	r7, sp, #0
 80028aa:	4605      	mov	r5, r0
    int max_expect = (max_len+1) * 8;
    uint8_t raw[max_expect];
 80028ac:	ebad 0d04 	sub.w	sp, sp, r4

    // tell chip to write stuff to bus
    _send_bits(IOFLAG_TX);
 80028b0:	2088      	movs	r0, #136	; 0x88
// We ignore extra bytes not expected, and always read until a timeout.
// Cmds to chip can be up to 155 bytes, but not clear what max len for responses.
//
    static int
ae_read_response(uint8_t *buf, int max_len)
{
 80028b2:	460e      	mov	r6, r1
    int max_expect = (max_len+1) * 8;
    uint8_t raw[max_expect];

    // tell chip to write stuff to bus
    _send_bits(IOFLAG_TX);
 80028b4:	f7ff ff64 	bl	8002780 <_send_bits>

    // kill first byte which we expect to be IOFLAG_TX echo (0x88)
    _flush_rx();
 80028b8:	f7ff ff7e 	bl	80027b8 <_flush_rx>
    uint32_t    ticks = 0;

    // reset timeout timer (Systick)
    SysTick->VAL = 0;

    while(!(MY_UART->ISR & UART_FLAG_RXNE) && !(MY_UART->ISR & UART_FLAG_RTOF)) {
 80028bc:	4b2e      	ldr	r3, [pc, #184]	; (8002978 <ae_read_response+0xd8>)
_read_byte(void)
{
    uint32_t    ticks = 0;

    // reset timeout timer (Systick)
    SysTick->VAL = 0;
 80028be:	f8df e0c0 	ldr.w	lr, [pc, #192]	; 8002980 <ae_read_response+0xe0>

    // It takes between 64 and 131us (tTURNAROUND) for the chip to recover
    // and start sending bits to us. We're blocked on reading
    // them anyway, so no need to delay. Also a danger of overruns here.

    int actual = 0;
 80028c2:	2000      	movs	r0, #0
//
    static int
ae_read_response(uint8_t *buf, int max_len)
{
    int max_expect = (max_len+1) * 8;
    uint8_t raw[max_expect];
 80028c4:	46e8      	mov	r8, sp
    // It takes between 64 and 131us (tTURNAROUND) for the chip to recover
    // and start sending bits to us. We're blocked on reading
    // them anyway, so no need to delay. Also a danger of overruns here.

    int actual = 0;
    for(uint8_t *p = raw; ; actual++) {
 80028c6:	466a      	mov	r2, sp
_read_byte(void)
{
    uint32_t    ticks = 0;

    // reset timeout timer (Systick)
    SysTick->VAL = 0;
 80028c8:	4684      	mov	ip, r0
 80028ca:	4699      	mov	r9, r3
 80028cc:	f8ce c008 	str.w	ip, [lr, #8]
 80028d0:	2105      	movs	r1, #5

    while(!(MY_UART->ISR & UART_FLAG_RXNE) && !(MY_UART->ISR & UART_FLAG_RTOF)) {
 80028d2:	f8d3 a01c 	ldr.w	sl, [r3, #28]
 80028d6:	f01a 0f20 	tst.w	sl, #32
 80028da:	d10c      	bne.n	80028f6 <ae_read_response+0x56>
 80028dc:	f8d3 a01c 	ldr.w	sl, [r3, #28]
 80028e0:	f41a 6f00 	tst.w	sl, #2048	; 0x800
 80028e4:	d107      	bne.n	80028f6 <ae_read_response+0x56>
        // busy-waiting

        if(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) {
 80028e6:	f8de a000 	ldr.w	sl, [lr]
 80028ea:	f41a 3f80 	tst.w	sl, #65536	; 0x10000
 80028ee:	d0f0      	beq.n	80028d2 <ae_read_response+0x32>
            ticks += 1;
            if(ticks >= 5) {
 80028f0:	3901      	subs	r1, #1
 80028f2:	d1ee      	bne.n	80028d2 <ae_read_response+0x32>
 80028f4:	e019      	b.n	800292a <ae_read_response+0x8a>
                return -1;
            }
        }
    }

    if(MY_UART->ISR & UART_FLAG_RXNE) {
 80028f6:	f8d9 a01c 	ldr.w	sl, [r9, #28]
 80028fa:	491f      	ldr	r1, [pc, #124]	; (8002978 <ae_read_response+0xd8>)
 80028fc:	f01a 0f20 	tst.w	sl, #32
 8002900:	d007      	beq.n	8002912 <ae_read_response+0x72>
        return MY_UART->RDR & 0x7f;
 8002902:	8c99      	ldrh	r1, [r3, #36]	; 0x24
        int ch = _read_byte();
        if(ch < 0) {
            break;
        }

        if(actual < max_expect) {
 8002904:	42a0      	cmp	r0, r4
 8002906:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 800290a:	da0c      	bge.n	8002926 <ae_read_response+0x86>
            *(p++) = ch;
 800290c:	7011      	strb	r1, [r2, #0]
 800290e:	3201      	adds	r2, #1
 8002910:	e009      	b.n	8002926 <ae_read_response+0x86>
    }

    if(MY_UART->ISR & UART_FLAG_RXNE) {
        return MY_UART->RDR & 0x7f;
    }
    if(MY_UART->ISR & UART_FLAG_RTOF) {
 8002912:	69cb      	ldr	r3, [r1, #28]
 8002914:	051b      	lsls	r3, r3, #20
 8002916:	d503      	bpl.n	8002920 <ae_read_response+0x80>
        // "fast" timeout reached, clear flag
        MY_UART->ICR = USART_ICR_RTOCF;
 8002918:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800291c:	620b      	str	r3, [r1, #32]
 800291e:	e004      	b.n	800292a <ae_read_response+0x8a>
        return -1;
    }
    INCONSISTENT("rxf");
 8002920:	4816      	ldr	r0, [pc, #88]	; (800297c <ae_read_response+0xdc>)
 8002922:	f7fe f85b 	bl	80009dc <fatal_error>
    // It takes between 64 and 131us (tTURNAROUND) for the chip to recover
    // and start sending bits to us. We're blocked on reading
    // them anyway, so no need to delay. Also a danger of overruns here.

    int actual = 0;
    for(uint8_t *p = raw; ; actual++) {
 8002926:	3001      	adds	r0, #1
        }

        if(actual < max_expect) {
            *(p++) = ch;
        }
    }
 8002928:	e7d0      	b.n	80028cc <ae_read_response+0x2c>

    // Sometimes our framing is not perfect.
    // We might get a spurious bit at the leading edge (perhaps an echo
    // of part of the 0x88??) or junk at the end.
    actual &= ~7;
 800292a:	f020 0007 	bic.w	r0, r0, #7
 800292e:	1dc3      	adds	r3, r0, #7
 8002930:	f108 0207 	add.w	r2, r8, #7
 8002934:	eb08 0103 	add.w	r1, r8, r3
 8002938:	462c      	mov	r4, r5
// Return a deserialized byte, or -1 for timeout.
//
    static void
deserialize(const uint8_t *from, int from_len, uint8_t *into, int max_into)
{
    while(from_len > 0) {
 800293a:	428a      	cmp	r2, r1
 800293c:	d017      	beq.n	800296e <ae_read_response+0xce>
 800293e:	f1a2 0c08 	sub.w	ip, r2, #8
 8002942:	2301      	movs	r3, #1
 8002944:	f04f 0e00 	mov.w	lr, #0
        uint8_t rv = 0, mask = 0x1;

        for(int i=0; i<8; i++, mask <<= 1) {
            if(from[i] == BIT1) {
 8002948:	f81c 8f01 	ldrb.w	r8, [ip, #1]!
 800294c:	f1b8 0f7f 	cmp.w	r8, #127	; 0x7f
                rv |= mask;
 8002950:	bf08      	it	eq
 8002952:	ea4e 0e03 	orreq.w	lr, lr, r3
deserialize(const uint8_t *from, int from_len, uint8_t *into, int max_into)
{
    while(from_len > 0) {
        uint8_t rv = 0, mask = 0x1;

        for(int i=0; i<8; i++, mask <<= 1) {
 8002956:	005b      	lsls	r3, r3, #1
 8002958:	4594      	cmp	ip, r2
 800295a:	b2db      	uxtb	r3, r3
 800295c:	d1f4      	bne.n	8002948 <ae_read_response+0xa8>
            if(from[i] == BIT1) {
                rv |= mask;
            }
        }

        *(into++) = rv;
 800295e:	f804 eb01 	strb.w	lr, [r4], #1
 8002962:	1b33      	subs	r3, r6, r4
 8002964:	442b      	add	r3, r5
        from += 8;
        from_len -= 8;

        max_into --;
        if(max_into <= 0) break;
 8002966:	2b00      	cmp	r3, #0
 8002968:	f102 0208 	add.w	r2, r2, #8
 800296c:	dce5      	bgt.n	800293a <ae_read_response+0x9a>
    // We might get a spurious bit at the leading edge (perhaps an echo
    // of part of the 0x88??) or junk at the end.
    actual &= ~7;
    deserialize(raw, actual, buf, max_len);

    return actual / 8;
 800296e:	10c0      	asrs	r0, r0, #3
}
 8002970:	46bd      	mov	sp, r7
 8002972:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002976:	bf00      	nop
 8002978:	40004c00 	.word	0x40004c00
 800297c:	0800d557 	.word	0x0800d557
 8002980:	e000e010 	.word	0xe000e010

08002984 <ae_reset_chip>:
// ae_reset_chip()
//
    void
ae_reset_chip(void)
{
    if(ae_chip_is_setup == AE_CHIP_IS_SETUP) {
 8002984:	4b04      	ldr	r3, [pc, #16]	; (8002998 <ae_reset_chip+0x14>)
 8002986:	681a      	ldr	r2, [r3, #0]
 8002988:	4b04      	ldr	r3, [pc, #16]	; (800299c <ae_reset_chip+0x18>)
 800298a:	429a      	cmp	r2, r3
 800298c:	d102      	bne.n	8002994 <ae_reset_chip+0x10>
        // "The ATECC508A goes into the low power sleep mode and ignores all
        // subsequent I/O transitions until the next wake flag. The entire volatile
        // state of the device is reset"
        _send_bits(IOFLAG_SLEEP);
 800298e:	20cc      	movs	r0, #204	; 0xcc
 8002990:	f7ff bef6 	b.w	8002780 <_send_bits>
 8002994:	4770      	bx	lr
 8002996:	bf00      	nop
 8002998:	200001d0 	.word	0x200001d0
 800299c:	35d25d63 	.word	0x35d25d63

080029a0 <ae_setup>:
#ifdef DEV_STATS
    memset(&stats, 0, sizeof(stats));
#endif

    // enable clock to that part of chip
    __HAL_RCC_UART4_CLK_ENABLE();
 80029a0:	4b14      	ldr	r3, [pc, #80]	; (80029f4 <ae_setup+0x54>)
//
// Configure pins. Do not attempt to talk to chip.
//
    void
ae_setup(void)
{
 80029a2:	b507      	push	{r0, r1, r2, lr}
#ifdef DEV_STATS
    memset(&stats, 0, sizeof(stats));
#endif

    // enable clock to that part of chip
    __HAL_RCC_UART4_CLK_ENABLE();
 80029a4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80029a6:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 80029aa:	659a      	str	r2, [r3, #88]	; 0x58
 80029ac:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80029ae:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 80029b2:	9301      	str	r3, [sp, #4]
 80029b4:	9b01      	ldr	r3, [sp, #4]
    //
    // For max clock error insensitivity:
    // OVER8==0, ONEBIT=1

    // disable UART so some other bits can be set (only while disabled)
    MY_UART->CR1 = 0;
 80029b6:	4b10      	ldr	r3, [pc, #64]	; (80029f8 <ae_setup+0x58>)
 80029b8:	2200      	movs	r2, #0
 80029ba:	601a      	str	r2, [r3, #0]
    MY_UART->CR1 = 0x1000002d & ~(0
 80029bc:	4a0f      	ldr	r2, [pc, #60]	; (80029fc <ae_setup+0x5c>)
 80029be:	601a      	str	r2, [r3, #0]
#endif
                                    | USART_CR1_IDLEIE
                                    | USART_CR1_OVER8
                                    | USART_CR1_UE);

    MY_UART->RTOR = 24;                  // timeout in bit periods: 3 chars or so
 80029c0:	2218      	movs	r2, #24
 80029c2:	615a      	str	r2, [r3, #20]
    MY_UART->CR2 = USART_CR2_RTOEN;      // rx timeout enable
 80029c4:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 80029c8:	605a      	str	r2, [r3, #4]
    MY_UART->CR3 = USART_CR3_HDSEL | USART_CR3_ONEBIT;
 80029ca:	f640 0208 	movw	r2, #2056	; 0x808
 80029ce:	609a      	str	r2, [r3, #8]
#if HCLK_FREQUENCY == 80000000
    MY_UART->BRR = 0x0000015b;          // 230400 bps @ 80 Mhz SYSCLK
#elif HCLK_FREQUENCY == 120000000
    MY_UART->BRR = 521;                 // 230400 bps @ 120 Mhz SYSCLK
 80029d0:	f240 2209 	movw	r2, #521	; 0x209
 80029d4:	60da      	str	r2, [r3, #12]
#else
#   error "needs math"
#endif

    // clear rx timeout flag
    MY_UART->ICR = USART_ICR_RTOCF;
 80029d6:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80029da:	621a      	str	r2, [r3, #32]

    // finally enable UART
    MY_UART->CR1 |= USART_CR1_UE;
 80029dc:	681a      	ldr	r2, [r3, #0]
 80029de:	f042 0201 	orr.w	r2, r2, #1
 80029e2:	601a      	str	r2, [r3, #0]
    
    // configure pin A0 to be AFx_UARTy, PULL_NONE
    // should already be done: gpio_setup();
    
    // mark it as ready
    ae_chip_is_setup = AE_CHIP_IS_SETUP;
 80029e4:	4b06      	ldr	r3, [pc, #24]	; (8002a00 <ae_setup+0x60>)
 80029e6:	4a07      	ldr	r2, [pc, #28]	; (8002a04 <ae_setup+0x64>)
 80029e8:	601a      	str	r2, [r3, #0]

    rng_delay();
 80029ea:	f7ff fea4 	bl	8002736 <rng_delay>
}
 80029ee:	b003      	add	sp, #12
 80029f0:	f85d fb04 	ldr.w	pc, [sp], #4
 80029f4:	40021000 	.word	0x40021000
 80029f8:	40004c00 	.word	0x40004c00
 80029fc:	1000002c 	.word	0x1000002c
 8002a00:	200001d0 	.word	0x200001d0
 8002a04:	35d25d63 	.word	0x35d25d63

08002a08 <ae_keep_alive>:

// ae_keep_alive()
//
	void
ae_keep_alive(void)
{
 8002a08:	b508      	push	{r3, lr}
ae_send_idle(void)
{
	// "The ATECC508A goes into the idle mode and ignores all subsequent
	// I/O transitions until the next wake flag. The contents of TempKey
	// and RNG Seed registers are retained."
    ae_wake();
 8002a0a:	f7ff ff3d 	bl	8002888 <ae_wake>

    _send_bits(IOFLAG_IDLE);
 8002a0e:	20bb      	movs	r0, #187	; 0xbb
 8002a10:	f7ff feb6 	bl	8002780 <_send_bits>
	ae_send_idle();

    // no need to wake: next transaction will do that 
	//ae_wake();
    rng_delay();
}
 8002a14:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	// To reset the watchdog, (1) put it into idle mode, then (2) wake it.
	ae_send_idle();

    // no need to wake: next transaction will do that 
	//ae_wake();
    rng_delay();
 8002a18:	f7ff be8d 	b.w	8002736 <rng_delay>

08002a1c <ae_read1>:
// Read a one-byte status/error code response from chip. It's wrapped as 4 bytes: 
//	(len=4) (value) (crc16) (crc16)
//
	int
ae_read1(void)
{
 8002a1c:	b513      	push	{r0, r1, r4, lr}
 8002a1e:	2408      	movs	r4, #8
	uint8_t msg[4];

	for(int retry=7; retry >= 0; retry--) {
        // tell it we want to read a response, read it, and deserialize
        int rv = ae_read_response(msg, 4);
 8002a20:	2104      	movs	r1, #4
 8002a22:	eb0d 0001 	add.w	r0, sp, r1
 8002a26:	f7ff ff3b 	bl	80028a0 <ae_read_response>

        if(rv == 0) {
 8002a2a:	4601      	mov	r1, r0
 8002a2c:	b918      	cbnz	r0, 8002a36 <ae_read1+0x1a>
            // nothing heard, it's probably still processing
            ERR("not rdy");
            STATS(not_ready++);

            delay_ms(5);
 8002a2e:	2005      	movs	r0, #5
 8002a30:	f000 ff2a 	bl	8003888 <delay_ms>
            goto try_again;
 8002a34:	e008      	b.n	8002a48 <ae_read1+0x2c>
        }

        if(rv != 4) {
 8002a36:	2804      	cmp	r0, #4
 8002a38:	d106      	bne.n	8002a48 <ae_read1+0x2c>
            goto try_again;
        }

		// Check length and CRC bytes. we will retry a few times
		// if they are wrong.
		if(!ae_check_crc(msg, 4)) {
 8002a3a:	a801      	add	r0, sp, #4
 8002a3c:	f7ff ff03 	bl	8002846 <ae_check_crc>
 8002a40:	b110      	cbz	r0, 8002a48 <ae_read1+0x2c>
		}

        STATS(last_resp1 = msg[1]);

		// done, and it worked; return the one byte.
		return msg[1];
 8002a42:	f89d 0005 	ldrb.w	r0, [sp, #5]
 8002a46:	e003      	b.n	8002a50 <ae_read1+0x34>
	int
ae_read1(void)
{
	uint8_t msg[4];

	for(int retry=7; retry >= 0; retry--) {
 8002a48:	3c01      	subs	r4, #1
 8002a4a:	d1e9      	bne.n	8002a20 <ae_read1+0x4>
	try_again:
        STATS(l1_retry++);
	}

	// fail.
	return -1;
 8002a4c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8002a50:	b002      	add	sp, #8
 8002a52:	bd10      	pop	{r4, pc}

08002a54 <ae_read_n>:
// Read and check CRC over N bytes, wrapped in 3-bytes of framing overhead.
// Return -1 for timeout, zero for normal, and one-byte error code otherwise.
//
	int
ae_read_n(uint8_t len, uint8_t *body)
{
 8002a54:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    uint8_t tmp[1+len+2];
 8002a58:	1cc6      	adds	r6, r0, #3
 8002a5a:	300a      	adds	r0, #10
 8002a5c:	f020 0007 	bic.w	r0, r0, #7
// Read and check CRC over N bytes, wrapped in 3-bytes of framing overhead.
// Return -1 for timeout, zero for normal, and one-byte error code otherwise.
//
	int
ae_read_n(uint8_t len, uint8_t *body)
{
 8002a60:	af00      	add	r7, sp, #0
    uint8_t tmp[1+len+2];
 8002a62:	ebad 0d00 	sub.w	sp, sp, r0
// Read and check CRC over N bytes, wrapped in 3-bytes of framing overhead.
// Return -1 for timeout, zero for normal, and one-byte error code otherwise.
//
	int
ae_read_n(uint8_t len, uint8_t *body)
{
 8002a66:	4688      	mov	r8, r1
    uint8_t tmp[1+len+2];
 8002a68:	466c      	mov	r4, sp
 8002a6a:	f04f 0908 	mov.w	r9, #8

	for(int retry=7; retry >= 0; retry--) {

        int actual = ae_read_response(tmp, len+3);
 8002a6e:	4631      	mov	r1, r6
 8002a70:	4620      	mov	r0, r4
 8002a72:	f7ff ff15 	bl	80028a0 <ae_read_response>
        if(actual < 4) {
 8002a76:	2803      	cmp	r0, #3
{
    uint8_t tmp[1+len+2];

	for(int retry=7; retry >= 0; retry--) {

        int actual = ae_read_response(tmp, len+3);
 8002a78:	4605      	mov	r5, r0
        if(actual < 4) {
 8002a7a:	dc04      	bgt.n	8002a86 <ae_read_n+0x32>

            if(actual == 0) {
 8002a7c:	b9b0      	cbnz	r0, 8002aac <ae_read_n+0x58>
                // nothing heard, it's probably still processing
                delay_ms(5);
 8002a7e:	2005      	movs	r0, #5
 8002a80:	f000 ff02 	bl	8003888 <delay_ms>
 8002a84:	e012      	b.n	8002aac <ae_read_n+0x58>
                STATS(short_error++);
            }
            goto try_again;
        }

        uint8_t resp_len = tmp[0];
 8002a86:	7823      	ldrb	r3, [r4, #0]
		if(resp_len != (len + 3)) {
 8002a88:	429e      	cmp	r6, r3
 8002a8a:	d003      	beq.n	8002a94 <ae_read_n+0x40>
            STATS(len_error++);
            if(resp_len == 4) {
 8002a8c:	2b04      	cmp	r3, #4
 8002a8e:	d10d      	bne.n	8002aac <ae_read_n+0x58>
				// Probably an unexpected error. But no way to return a short read, so
				// just print out debug info.
                ERRV(tmp[1], "ae errcode");
                STATS(last_resp1 = tmp[1]);

                return tmp[1];
 8002a90:	7860      	ldrb	r0, [r4, #1]
 8002a92:	e012      	b.n	8002aba <ae_read_n+0x66>
            }
			ERRV(tmp[0], "wr len");		 // wrong length
			goto try_again;
		}

		if(!ae_check_crc(tmp, actual)) {
 8002a94:	b2c1      	uxtb	r1, r0
 8002a96:	4620      	mov	r0, r4
 8002a98:	f7ff fed5 	bl	8002846 <ae_check_crc>
 8002a9c:	b130      	cbz	r0, 8002aac <ae_read_n+0x58>
            STATS(crc_error++);
			goto try_again;
		}

		// normal case: copy out body of message w/o framing
        memcpy(body, tmp+1, actual-3);
 8002a9e:	1eea      	subs	r2, r5, #3
 8002aa0:	1c61      	adds	r1, r4, #1
 8002aa2:	4640      	mov	r0, r8
 8002aa4:	f00a fce9 	bl	800d47a <memcpy>
#ifdef DEV_STATS
        memcpy(stats.last_n_data, body, MIN(32, actual-3));
        stats.last_n_len =  actual-3;
#endif

		return 0;
 8002aa8:	2000      	movs	r0, #0
 8002aaa:	e006      	b.n	8002aba <ae_read_n+0x66>

	try_again:
        STATS(ln_retry++);
        ae_wake();
 8002aac:	f7ff feec 	bl	8002888 <ae_wake>
	int
ae_read_n(uint8_t len, uint8_t *body)
{
    uint8_t tmp[1+len+2];

	for(int retry=7; retry >= 0; retry--) {
 8002ab0:	f1b9 0901 	subs.w	r9, r9, #1
 8002ab4:	d1db      	bne.n	8002a6e <ae_read_n+0x1a>
	try_again:
        STATS(ln_retry++);
        ae_wake();
	}

	return -1;
 8002ab6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8002aba:	46bd      	mov	sp, r7
 8002abc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08002ac0 <ae_send_n>:

// ae_send_n()
//
	void
ae_send_n(aeopcode_t opcode, uint8_t p1, uint16_t p2, const uint8_t *data, uint8_t data_len) 
{
 8002ac0:	b530      	push	{r4, r5, lr}
 8002ac2:	b085      	sub	sp, #20
 8002ac4:	461d      	mov	r5, r3
 8002ac6:	f89d 4020 	ldrb.w	r4, [sp, #32]
		uint8_t	framed_len;
		uint8_t	op;
		uint8_t	p1;
		uint8_t	p2_lsb;
		uint8_t	p2_msb;
	} known = { 
 8002aca:	f88d 200c 	strb.w	r2, [sp, #12]
 8002ace:	2377      	movs	r3, #119	; 0x77
 8002ad0:	0a12      	lsrs	r2, r2, #8
 8002ad2:	f88d 3008 	strb.w	r3, [sp, #8]
 8002ad6:	1de3      	adds	r3, r4, #7
 8002ad8:	f88d 3009 	strb.w	r3, [sp, #9]
 8002adc:	f88d 200d 	strb.w	r2, [sp, #13]
 8002ae0:	f88d 000a 	strb.w	r0, [sp, #10]
 8002ae4:	f88d 100b 	strb.w	r1, [sp, #11]
    STATS(last_op = opcode);
    STATS(last_p1 = p1);
    STATS(last_p2 = p2);

    // important to wake chip at this point.
    ae_wake();
 8002ae8:	f7ff fece 	bl	8002888 <ae_wake>

    _send_serialized((const uint8_t *)&known, sizeof(known));
 8002aec:	2106      	movs	r1, #6
 8002aee:	a802      	add	r0, sp, #8
 8002af0:	f7ff fe55 	bl	800279e <_send_serialized>

	// CRC will start from frame_len onwards
	uint8_t crc[2] = {0, 0};
 8002af4:	2300      	movs	r3, #0
	crc16_chain(sizeof(known)-1, &known.framed_len, crc);
 8002af6:	aa01      	add	r2, sp, #4
 8002af8:	f10d 0109 	add.w	r1, sp, #9
 8002afc:	2005      	movs	r0, #5
    ae_wake();

    _send_serialized((const uint8_t *)&known, sizeof(known));

	// CRC will start from frame_len onwards
	uint8_t crc[2] = {0, 0};
 8002afe:	f88d 3004 	strb.w	r3, [sp, #4]
 8002b02:	f88d 3005 	strb.w	r3, [sp, #5]
	crc16_chain(sizeof(known)-1, &known.framed_len, crc);
 8002b06:	f7ff fe75 	bl	80027f4 <crc16_chain>

	// insert a variable-length body area (sometimes)
	if(data_len) {
 8002b0a:	b144      	cbz	r4, 8002b1e <ae_send_n+0x5e>
        _send_serialized(data, data_len);
 8002b0c:	4621      	mov	r1, r4
 8002b0e:	4628      	mov	r0, r5
 8002b10:	f7ff fe45 	bl	800279e <_send_serialized>
		
		crc16_chain(data_len, data, crc);
 8002b14:	aa01      	add	r2, sp, #4
 8002b16:	4629      	mov	r1, r5
 8002b18:	4620      	mov	r0, r4
 8002b1a:	f7ff fe6b 	bl	80027f4 <crc16_chain>
	}

	// send final CRC bytes
    _send_serialized(crc, 2);
 8002b1e:	2102      	movs	r1, #2
 8002b20:	a801      	add	r0, sp, #4
 8002b22:	f7ff fe3c 	bl	800279e <_send_serialized>
}
 8002b26:	b005      	add	sp, #20
 8002b28:	bd30      	pop	{r4, r5, pc}

08002b2a <ae_send>:

// ae_send()
//
	void
ae_send(aeopcode_t opcode, uint8_t p1, uint16_t p2) 
{
 8002b2a:	b507      	push	{r0, r1, r2, lr}
	ae_send_n(opcode, p1, p2, NULL, 0);
 8002b2c:	2300      	movs	r3, #0
 8002b2e:	9300      	str	r3, [sp, #0]
 8002b30:	f7ff ffc6 	bl	8002ac0 <ae_send_n>
}
 8002b34:	b003      	add	sp, #12
 8002b36:	f85d fb04 	ldr.w	pc, [sp], #4

08002b3a <ae_get_info>:
//
// Do Info(p1=2) command, and return result.
//
	uint16_t
ae_get_info(void)
{
 8002b3a:	b507      	push	{r0, r1, r2, lr}
	// not doing error checking here
	ae_send(OP_Info, 0x2, 0);
 8002b3c:	2200      	movs	r2, #0
 8002b3e:	2102      	movs	r1, #2
 8002b40:	2030      	movs	r0, #48	; 0x30
 8002b42:	f7ff fff2 	bl	8002b2a <ae_send>

	// note: always returns 4 bytes, but most are garbage and unused.
	uint8_t tmp[4];
	ae_read_n(4, tmp);
 8002b46:	a901      	add	r1, sp, #4
 8002b48:	2004      	movs	r0, #4
 8002b4a:	f7ff ff83 	bl	8002a54 <ae_read_n>

	return (tmp[0] << 8) | tmp[1];
 8002b4e:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8002b52:	f89d 3005 	ldrb.w	r3, [sp, #5]
}
 8002b56:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8002b5a:	b003      	add	sp, #12
 8002b5c:	f85d fb04 	ldr.w	pc, [sp], #4

08002b60 <ae_load_nonce>:
// Load Tempkey with a specific value. Resulting Tempkey cannot be
// used with many commands/keys, but is needed for signing.
//
	int
ae_load_nonce(const uint8_t nonce[32])
{
 8002b60:	b507      	push	{r0, r1, r2, lr}
    // p1=3
	ae_send_n(OP_Nonce, 3, 0, nonce, 32);          // 608a ok
 8002b62:	2320      	movs	r3, #32
 8002b64:	9300      	str	r3, [sp, #0]
 8002b66:	2200      	movs	r2, #0
 8002b68:	4603      	mov	r3, r0
 8002b6a:	2103      	movs	r1, #3
 8002b6c:	2016      	movs	r0, #22
 8002b6e:	f7ff ffa7 	bl	8002ac0 <ae_send_n>

    return ae_read1();
}
 8002b72:	b003      	add	sp, #12
 8002b74:	f85d eb04 	ldr.w	lr, [sp], #4
ae_load_nonce(const uint8_t nonce[32])
{
    // p1=3
	ae_send_n(OP_Nonce, 3, 0, nonce, 32);          // 608a ok

    return ae_read1();
 8002b78:	f7ff bf50 	b.w	8002a1c <ae_read1>

08002b7c <ae_load_msgdigest>:
// Load 32bytes of message digest  with a specific value.
// Needed for signing.
//
	int
ae_load_msgdigest(const uint8_t md[32])
{
 8002b7c:	b507      	push	{r0, r1, r2, lr}
	ae_send_n(OP_Nonce, (1<<6) | 3, 0, md, 32);
 8002b7e:	2320      	movs	r3, #32
 8002b80:	9300      	str	r3, [sp, #0]
 8002b82:	2200      	movs	r2, #0
 8002b84:	4603      	mov	r3, r0
 8002b86:	2143      	movs	r1, #67	; 0x43
 8002b88:	2016      	movs	r0, #22
 8002b8a:	f7ff ff99 	bl	8002ac0 <ae_send_n>

    return ae_read1();
}
 8002b8e:	b003      	add	sp, #12
 8002b90:	f85d eb04 	ldr.w	lr, [sp], #4
	int
ae_load_msgdigest(const uint8_t md[32])
{
	ae_send_n(OP_Nonce, (1<<6) | 3, 0, md, 32);

    return ae_read1();
 8002b94:	f7ff bf42 	b.w	8002a1c <ae_read1>

08002b98 <ae_pick_nonce>:
// Load Tempkey with a nonce value that we both know, but
// is random and we both know is random! Tricky!
//
	int
ae_pick_nonce(const uint8_t num_in[20], uint8_t tempkey[32])
{
 8002b98:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002b9a:	b09f      	sub	sp, #124	; 0x7c
	// We provide some 20 bytes of randomness to chip
	// The chip must provide 32-bytes of random-ness,
	// so no choice in args to OP.Nonce here (due to ReqRandom).
	ae_send_n(OP_Nonce, 0, 0, num_in, 20);
 8002b9c:	2200      	movs	r2, #0
 8002b9e:	2614      	movs	r6, #20
 8002ba0:	4603      	mov	r3, r0
// Load Tempkey with a nonce value that we both know, but
// is random and we both know is random! Tricky!
//
	int
ae_pick_nonce(const uint8_t num_in[20], uint8_t tempkey[32])
{
 8002ba2:	4605      	mov	r5, r0
 8002ba4:	460f      	mov	r7, r1
	// We provide some 20 bytes of randomness to chip
	// The chip must provide 32-bytes of random-ness,
	// so no choice in args to OP.Nonce here (due to ReqRandom).
	ae_send_n(OP_Nonce, 0, 0, num_in, 20);
 8002ba6:	2016      	movs	r0, #22
 8002ba8:	4611      	mov	r1, r2
 8002baa:	9600      	str	r6, [sp, #0]
 8002bac:	f7ff ff88 	bl	8002ac0 <ae_send_n>

    rng_delay();
 8002bb0:	f7ff fdc1 	bl	8002736 <rng_delay>

	// Nonce command returns the RNG result, but not contents of TempKey
	uint8_t randout[32];
	int rv = ae_read_n(32, randout);
 8002bb4:	a903      	add	r1, sp, #12
 8002bb6:	2020      	movs	r0, #32
 8002bb8:	f7ff ff4c 	bl	8002a54 <ae_read_n>
	RET_IF_BAD(rv);
 8002bbc:	4604      	mov	r4, r0
 8002bbe:	b9f0      	cbnz	r0, 8002bfe <ae_pick_nonce+0x66>
	//
	//		return sha256(rndout + num_in + b'\x16\0\0').digest()
	//
	SHA256_CTX ctx;

    sha256_init(&ctx);
 8002bc0:	a80b      	add	r0, sp, #44	; 0x2c
 8002bc2:	f002 fbc5 	bl	8005350 <sha256_init>
    sha256_update(&ctx, randout, 32);
 8002bc6:	2220      	movs	r2, #32
 8002bc8:	a903      	add	r1, sp, #12
 8002bca:	a80b      	add	r0, sp, #44	; 0x2c
 8002bcc:	f002 fbd0 	bl	8005370 <sha256_update>
    sha256_update(&ctx, num_in, 20);
 8002bd0:	4632      	mov	r2, r6
 8002bd2:	4629      	mov	r1, r5
 8002bd4:	a80b      	add	r0, sp, #44	; 0x2c
 8002bd6:	f002 fbcb 	bl	8005370 <sha256_update>
	const uint8_t fixed[3] = { 0x16, 0, 0 };
 8002bda:	2316      	movs	r3, #22
    sha256_update(&ctx, fixed, 3);
 8002bdc:	2203      	movs	r2, #3
 8002bde:	a902      	add	r1, sp, #8
 8002be0:	a80b      	add	r0, sp, #44	; 0x2c
	SHA256_CTX ctx;

    sha256_init(&ctx);
    sha256_update(&ctx, randout, 32);
    sha256_update(&ctx, num_in, 20);
	const uint8_t fixed[3] = { 0x16, 0, 0 };
 8002be2:	f88d 3008 	strb.w	r3, [sp, #8]
 8002be6:	f88d 4009 	strb.w	r4, [sp, #9]
 8002bea:	f88d 400a 	strb.w	r4, [sp, #10]
    sha256_update(&ctx, fixed, 3);
 8002bee:	f002 fbbf 	bl	8005370 <sha256_update>

    sha256_final(&ctx, tempkey);
 8002bf2:	4639      	mov	r1, r7
 8002bf4:	a80b      	add	r0, sp, #44	; 0x2c
 8002bf6:	f002 fc01 	bl	80053fc <sha256_final>

    rng_delay();
 8002bfa:	f7ff fd9c 	bl	8002736 <rng_delay>

	return 0;
}
 8002bfe:	4620      	mov	r0, r4
 8002c00:	b01f      	add	sp, #124	; 0x7c
 8002c02:	bdf0      	pop	{r4, r5, r6, r7, pc}

08002c04 <ae_is_correct_tempkey>:
// Check that TempKey is holding what we think it does. Uses the MAC
// command over contents of Tempkey and our shared secret.
//
    bool
ae_is_correct_tempkey(const uint8_t expected_tempkey[32])
{
 8002c04:	b570      	push	{r4, r5, r6, lr}
    const uint8_t mode =   (1<<6)     // include full serial number
                         | (0<<2)     // TempKey.SourceFlag == 0 == 'rand'
                         | (0<<1)     // first 32 bytes are the shared secret
                         | (1<<0);    // second 32 bytes are tempkey

	ae_send(OP_MAC, mode, KEYNUM_pairing);
 8002c06:	2141      	movs	r1, #65	; 0x41
// Check that TempKey is holding what we think it does. Uses the MAC
// command over contents of Tempkey and our shared secret.
//
    bool
ae_is_correct_tempkey(const uint8_t expected_tempkey[32])
{
 8002c08:	b0a8      	sub	sp, #160	; 0xa0
 8002c0a:	4604      	mov	r4, r0
    const uint8_t mode =   (1<<6)     // include full serial number
                         | (0<<2)     // TempKey.SourceFlag == 0 == 'rand'
                         | (0<<1)     // first 32 bytes are the shared secret
                         | (1<<0);    // second 32 bytes are tempkey

	ae_send(OP_MAC, mode, KEYNUM_pairing);
 8002c0c:	2201      	movs	r2, #1
 8002c0e:	2008      	movs	r0, #8
 8002c10:	f7ff ff8b 	bl	8002b2a <ae_send>

    // read chip's answer
	uint8_t resp[32];
	int rv = ae_read_n(32, resp);
 8002c14:	a905      	add	r1, sp, #20
 8002c16:	2020      	movs	r0, #32
 8002c18:	f7ff ff1c 	bl	8002a54 <ae_read_n>
    if(rv) return false;
 8002c1c:	2800      	cmp	r0, #0
 8002c1e:	d134      	bne.n	8002c8a <ae_is_correct_tempkey+0x86>

    ae_keep_alive();
 8002c20:	f7ff fef2 	bl	8002a08 <ae_keep_alive>

    // Duplicate the hash process, and then compare.
	SHA256_CTX ctx;

    sha256_init(&ctx);
 8002c24:	a815      	add	r0, sp, #84	; 0x54
 8002c26:	f002 fb93 	bl	8005350 <sha256_init>
    sha256_update(&ctx, rom_secrets->pairing_secret, 32);
 8002c2a:	2220      	movs	r2, #32
 8002c2c:	4918      	ldr	r1, [pc, #96]	; (8002c90 <ae_is_correct_tempkey+0x8c>)
 8002c2e:	a815      	add	r0, sp, #84	; 0x54
 8002c30:	f002 fb9e 	bl	8005370 <sha256_update>
    sha256_update(&ctx, expected_tempkey, 32);
 8002c34:	2220      	movs	r2, #32
 8002c36:	4621      	mov	r1, r4
 8002c38:	a815      	add	r0, sp, #84	; 0x54
 8002c3a:	f002 fb99 	bl	8005370 <sha256_update>

	const uint8_t fixed[16] = { OP_MAC, mode, KEYNUM_pairing, 0x0,
 8002c3e:	4b15      	ldr	r3, [pc, #84]	; (8002c94 <ae_is_correct_tempkey+0x90>)
 8002c40:	aa01      	add	r2, sp, #4
 8002c42:	f103 0610 	add.w	r6, r3, #16
 8002c46:	4615      	mov	r5, r2
 8002c48:	6818      	ldr	r0, [r3, #0]
 8002c4a:	6859      	ldr	r1, [r3, #4]
 8002c4c:	4614      	mov	r4, r2
 8002c4e:	c403      	stmia	r4!, {r0, r1}
 8002c50:	3308      	adds	r3, #8
 8002c52:	42b3      	cmp	r3, r6
 8002c54:	4622      	mov	r2, r4
 8002c56:	d1f7      	bne.n	8002c48 <ae_is_correct_tempkey+0x44>
                                    0,0,0,0, 0,0,0,0,       // eight zeros
                                    0,0,0,                  // three zeros
                                    0xEE };
    sha256_update(&ctx, fixed, sizeof(fixed));
 8002c58:	4629      	mov	r1, r5
 8002c5a:	a815      	add	r0, sp, #84	; 0x54
 8002c5c:	2210      	movs	r2, #16
 8002c5e:	f002 fb87 	bl	8005370 <sha256_update>

    sha256_update(&ctx, ((const uint8_t *)rom_secrets->ae_serial_number)+4, 4);
 8002c62:	a815      	add	r0, sp, #84	; 0x54
 8002c64:	2204      	movs	r2, #4
 8002c66:	490c      	ldr	r1, [pc, #48]	; (8002c98 <ae_is_correct_tempkey+0x94>)
 8002c68:	f002 fb82 	bl	8005370 <sha256_update>
    sha256_update(&ctx, ((const uint8_t *)rom_secrets->ae_serial_number)+0, 4);
 8002c6c:	2204      	movs	r2, #4
 8002c6e:	a815      	add	r0, sp, #84	; 0x54
 8002c70:	490a      	ldr	r1, [pc, #40]	; (8002c9c <ae_is_correct_tempkey+0x98>)
 8002c72:	f002 fb7d 	bl	8005370 <sha256_update>
	// this verifies no problem.
	ASSERT(ctx.datalen + (ctx.bitlen/8) == 32+32+1+1+2+8+3+1+4+2+2);        // == 88
#endif

    uint8_t         actual[32];
    sha256_final(&ctx, actual);
 8002c76:	a90d      	add	r1, sp, #52	; 0x34
 8002c78:	a815      	add	r0, sp, #84	; 0x54
 8002c7a:	f002 fbbf 	bl	80053fc <sha256_final>

    return check_equal(actual, resp, 32);
 8002c7e:	2220      	movs	r2, #32
 8002c80:	a905      	add	r1, sp, #20
 8002c82:	a80d      	add	r0, sp, #52	; 0x34
 8002c84:	f7ff fcef 	bl	8002666 <check_equal>
 8002c88:	e000      	b.n	8002c8c <ae_is_correct_tempkey+0x88>
	ae_send(OP_MAC, mode, KEYNUM_pairing);

    // read chip's answer
	uint8_t resp[32];
	int rv = ae_read_n(32, resp);
    if(rv) return false;
 8002c8a:	2000      	movs	r0, #0

    uint8_t         actual[32];
    sha256_final(&ctx, actual);

    return check_equal(actual, resp, 32);
}
 8002c8c:	b028      	add	sp, #160	; 0xa0
 8002c8e:	bd70      	pop	{r4, r5, r6, pc}
 8002c90:	0801e000 	.word	0x0801e000
 8002c94:	0800e3a2 	.word	0x0800e3a2
 8002c98:	0801e044 	.word	0x0801e044
 8002c9c:	0801e040 	.word	0x0801e040

08002ca0 <ae_checkmac>:
// inside the 508a/608a, like use of a specific key, but not for us to
// authenticate the 508a/608a or its contents/state.
//
    int
ae_checkmac(uint8_t keynum, const uint8_t secret[32])
{
 8002ca0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002ca2:	b0c3      	sub	sp, #268	; 0x10c

	// Since this is part of the hash, we want random bytes
	// for our "other data". Also a number for "numin" of nonce
	uint8_t od[32], numin[20];

	rng_buffer(od, sizeof(od));
 8002ca4:	ad0b      	add	r5, sp, #44	; 0x2c
// inside the 508a/608a, like use of a specific key, but not for us to
// authenticate the 508a/608a or its contents/state.
//
    int
ae_checkmac(uint8_t keynum, const uint8_t secret[32])
{
 8002ca6:	4606      	mov	r6, r0
 8002ca8:	460c      	mov	r4, r1

	// Since this is part of the hash, we want random bytes
	// for our "other data". Also a number for "numin" of nonce
	uint8_t od[32], numin[20];

	rng_buffer(od, sizeof(od));
 8002caa:	4628      	mov	r0, r5
 8002cac:	2120      	movs	r1, #32
 8002cae:	f7ff fd2b 	bl	8002708 <rng_buffer>
	rng_buffer(numin, sizeof(numin));
 8002cb2:	2114      	movs	r1, #20
 8002cb4:	a806      	add	r0, sp, #24
 8002cb6:	f7ff fd27 	bl	8002708 <rng_buffer>

    // need this one, want to reset watchdog to this point.
	ae_keep_alive();
 8002cba:	f7ff fea5 	bl	8002a08 <ae_keep_alive>

	// - load tempkey with a known nonce value
	uint8_t zeros[8] = {0};
 8002cbe:	2300      	movs	r3, #0
	uint8_t tempkey[32];
	rv = ae_pick_nonce(numin, tempkey);
 8002cc0:	a913      	add	r1, sp, #76	; 0x4c
 8002cc2:	a806      	add	r0, sp, #24

    // need this one, want to reset watchdog to this point.
	ae_keep_alive();

	// - load tempkey with a known nonce value
	uint8_t zeros[8] = {0};
 8002cc4:	9304      	str	r3, [sp, #16]
 8002cc6:	9305      	str	r3, [sp, #20]
	uint8_t tempkey[32];
	rv = ae_pick_nonce(numin, tempkey);
 8002cc8:	f7ff ff66 	bl	8002b98 <ae_pick_nonce>
	RET_IF_BAD(rv);
 8002ccc:	2800      	cmp	r0, #0
 8002cce:	d160      	bne.n	8002d92 <ae_checkmac+0xf2>

	// - hash nonce and lots of other bits together
	SHA256_CTX ctx;
    sha256_init(&ctx);
 8002cd0:	a81b      	add	r0, sp, #108	; 0x6c
 8002cd2:	f002 fb3d 	bl	8005350 <sha256_init>

    // shared secret is 32 bytes from flash
    sha256_update(&ctx, secret, 32);
 8002cd6:	2220      	movs	r2, #32
 8002cd8:	4621      	mov	r1, r4
 8002cda:	a81b      	add	r0, sp, #108	; 0x6c
 8002cdc:	f002 fb48 	bl	8005370 <sha256_update>

    sha256_update(&ctx, tempkey, 32);
 8002ce0:	2220      	movs	r2, #32
 8002ce2:	a913      	add	r1, sp, #76	; 0x4c
 8002ce4:	a81b      	add	r0, sp, #108	; 0x6c
 8002ce6:	f002 fb43 	bl	8005370 <sha256_update>
    sha256_update(&ctx, &od[0], 4);
 8002cea:	2204      	movs	r2, #4
 8002cec:	4629      	mov	r1, r5
 8002cee:	a81b      	add	r0, sp, #108	; 0x6c
 8002cf0:	f002 fb3e 	bl	8005370 <sha256_update>

    sha256_update(&ctx, zeros, 8);
 8002cf4:	2208      	movs	r2, #8
 8002cf6:	a904      	add	r1, sp, #16
 8002cf8:	a81b      	add	r0, sp, #108	; 0x6c
 8002cfa:	f002 fb39 	bl	8005370 <sha256_update>

    sha256_update(&ctx, &od[4], 3);
 8002cfe:	2203      	movs	r2, #3
 8002d00:	a90c      	add	r1, sp, #48	; 0x30
 8002d02:	a81b      	add	r0, sp, #108	; 0x6c
 8002d04:	f002 fb34 	bl	8005370 <sha256_update>

	uint8_t ee = 0xEE;
 8002d08:	a942      	add	r1, sp, #264	; 0x108
 8002d0a:	23ee      	movs	r3, #238	; 0xee
 8002d0c:	f801 3dfd 	strb.w	r3, [r1, #-253]!
    sha256_update(&ctx, &ee, 1);
 8002d10:	2201      	movs	r2, #1
 8002d12:	a81b      	add	r0, sp, #108	; 0x6c
 8002d14:	f002 fb2c 	bl	8005370 <sha256_update>
    sha256_update(&ctx, &od[7], 4);
 8002d18:	2204      	movs	r2, #4
 8002d1a:	f10d 0133 	add.w	r1, sp, #51	; 0x33
 8002d1e:	a81b      	add	r0, sp, #108	; 0x6c
 8002d20:	f002 fb26 	bl	8005370 <sha256_update>

	uint8_t snp[2] = { 0x01, 0x23 };
 8002d24:	4b1c      	ldr	r3, [pc, #112]	; (8002d98 <ae_checkmac+0xf8>)
    sha256_update(&ctx, snp, 2);
 8002d26:	2202      	movs	r2, #2

	uint8_t ee = 0xEE;
    sha256_update(&ctx, &ee, 1);
    sha256_update(&ctx, &od[7], 4);

	uint8_t snp[2] = { 0x01, 0x23 };
 8002d28:	881b      	ldrh	r3, [r3, #0]
 8002d2a:	f8ad 300c 	strh.w	r3, [sp, #12]
    sha256_update(&ctx, snp, 2);
 8002d2e:	a903      	add	r1, sp, #12
 8002d30:	a81b      	add	r0, sp, #108	; 0x6c
 8002d32:	f002 fb1d 	bl	8005370 <sha256_update>
    sha256_update(&ctx, &od[11], 2);
 8002d36:	2202      	movs	r2, #2
 8002d38:	f10d 0137 	add.w	r1, sp, #55	; 0x37
 8002d3c:	a81b      	add	r0, sp, #108	; 0x6c
 8002d3e:	f002 fb17 	bl	8005370 <sha256_update>
		uint8_t		resp[32];
		uint8_t		od[13];
	} req;

    // content doesn't matter, but nice and visible:
    memcpy(req.ch3, copyright_msg, 32);
 8002d42:	4b16      	ldr	r3, [pc, #88]	; (8002d9c <ae_checkmac+0xfc>)
 8002d44:	aa2e      	add	r2, sp, #184	; 0xb8
 8002d46:	f103 0e20 	add.w	lr, r3, #32
 8002d4a:	4617      	mov	r7, r2
 8002d4c:	6818      	ldr	r0, [r3, #0]
 8002d4e:	6859      	ldr	r1, [r3, #4]
 8002d50:	4614      	mov	r4, r2
 8002d52:	c403      	stmia	r4!, {r0, r1}
 8002d54:	3308      	adds	r3, #8
 8002d56:	4573      	cmp	r3, lr
 8002d58:	4622      	mov	r2, r4
 8002d5a:	d1f7      	bne.n	8002d4c <ae_checkmac+0xac>
	// this verifies no problem.
	int l = (ctx.blocks * 64) + ctx.npartial;
	ASSERT(l == 32+32+4+8+3+1+4+2+2);			// == 88
#endif

    sha256_final(&ctx, req.resp);
 8002d5c:	a936      	add	r1, sp, #216	; 0xd8
 8002d5e:	a81b      	add	r0, sp, #108	; 0x6c
 8002d60:	f002 fb4c 	bl	80053fc <sha256_final>
	memcpy(req.od, od, 13);
 8002d64:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8002d68:	ac3e      	add	r4, sp, #248	; 0xf8
 8002d6a:	c407      	stmia	r4!, {r0, r1, r2}
 8002d6c:	7023      	strb	r3, [r4, #0]

	STATIC_ASSERT(sizeof(req) == 32 + 32 + 13);

	// Give our answer to the chip.
	ae_send_n(OP_CheckMac, 0x01, keynum, (uint8_t *)&req, sizeof(req));
 8002d6e:	234d      	movs	r3, #77	; 0x4d
 8002d70:	9300      	str	r3, [sp, #0]
 8002d72:	4632      	mov	r2, r6
 8002d74:	463b      	mov	r3, r7
 8002d76:	2101      	movs	r1, #1
 8002d78:	2028      	movs	r0, #40	; 0x28
 8002d7a:	f7ff fea1 	bl	8002ac0 <ae_send_n>

	rv = ae_read1();
 8002d7e:	f7ff fe4d 	bl	8002a1c <ae_read1>
	if(rv != 0) {
 8002d82:	4604      	mov	r4, r0
 8002d84:	b918      	cbnz	r0, 8002d8e <ae_checkmac+0xee>
		return -1;
	}
#endif

	// just in case ... always restart watchdog timer.
	ae_keep_alive();
 8002d86:	f7ff fe3f 	bl	8002a08 <ae_keep_alive>

	return 0;
 8002d8a:	4620      	mov	r0, r4
 8002d8c:	e001      	b.n	8002d92 <ae_checkmac+0xf2>
		if(rv == AE_CHECKMAC_FAIL) {
			ERR("CM fail");				// typical case: our hashs don't match
		} else {
			ERRV(rv, "CheckMac");
		}
		return -1;
 8002d8e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff

	// just in case ... always restart watchdog timer.
	ae_keep_alive();

	return 0;
}
 8002d92:	b043      	add	sp, #268	; 0x10c
 8002d94:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002d96:	bf00      	nop
 8002d98:	0800e3b2 	.word	0x0800e3b2
 8002d9c:	0800e3b4 	.word	0x0800e3b4

08002da0 <ae_pair_unlock>:
// Purpose is to show we are a pair of chips that belong together.
//
	int
ae_pair_unlock()
{
    return ae_checkmac(KEYNUM_pairing, rom_secrets->pairing_secret);
 8002da0:	4901      	ldr	r1, [pc, #4]	; (8002da8 <ae_pair_unlock+0x8>)
 8002da2:	2001      	movs	r0, #1
 8002da4:	f7ff bf7c 	b.w	8002ca0 <ae_checkmac>
 8002da8:	0801e000 	.word	0x0801e000

08002dac <ae_sign_authed>:
// Sign a message (already digested)
//
	int
ae_sign_authed(uint8_t keynum, const uint8_t msg_hash[32],
                uint8_t signature[64], int auth_kn, const uint8_t auth_digest[32])
{
 8002dac:	b570      	push	{r4, r5, r6, lr}
 8002dae:	460e      	mov	r6, r1
 8002db0:	4604      	mov	r4, r0
 8002db2:	4615      	mov	r5, r2
    // indicate we know the PIN
    ae_pair_unlock();
 8002db4:	f7ff fff4 	bl	8002da0 <ae_pair_unlock>
    int rv = ae_checkmac(KEYNUM_main_pin, auth_digest);
 8002db8:	9904      	ldr	r1, [sp, #16]
 8002dba:	2003      	movs	r0, #3
 8002dbc:	f7ff ff70 	bl	8002ca0 <ae_checkmac>
    RET_IF_BAD(rv);
 8002dc0:	b990      	cbnz	r0, 8002de8 <ae_sign_authed+0x3c>

    // send what we need signed
	rv = ae_load_msgdigest(msg_hash);
 8002dc2:	4630      	mov	r0, r6
 8002dc4:	f7ff feda 	bl	8002b7c <ae_load_msgdigest>
	RET_IF_BAD(rv);
 8002dc8:	b970      	cbnz	r0, 8002de8 <ae_sign_authed+0x3c>

    do {
        ae_send(OP_Sign, (7<<5), keynum);
 8002dca:	b2a4      	uxth	r4, r4
 8002dcc:	4622      	mov	r2, r4
 8002dce:	21e0      	movs	r1, #224	; 0xe0
 8002dd0:	2041      	movs	r0, #65	; 0x41
 8002dd2:	f7ff feaa 	bl	8002b2a <ae_send>

        delay_ms(60);     // min time for processing
 8002dd6:	203c      	movs	r0, #60	; 0x3c
 8002dd8:	f000 fd56 	bl	8003888 <delay_ms>

        rv = ae_read_n(64, signature);
 8002ddc:	4629      	mov	r1, r5
 8002dde:	2040      	movs	r0, #64	; 0x40
 8002de0:	f7ff fe38 	bl	8002a54 <ae_read_n>
    } while(rv == AE_ECC_FAULT);
 8002de4:	2805      	cmp	r0, #5
 8002de6:	d0f1      	beq.n	8002dcc <ae_sign_authed+0x20>

	return rv;
}
 8002de8:	bd70      	pop	{r4, r5, r6, pc}

08002dea <ae_gen_ecc_key>:

// ae_gen_ecc_key()
//
    int
ae_gen_ecc_key(uint8_t keynum, uint8_t pubkey_out[64])
{
 8002dea:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    int rv;
    uint8_t junk[3] = { 0 };
 8002dec:	2300      	movs	r3, #0

// ae_gen_ecc_key()
//
    int
ae_gen_ecc_key(uint8_t keynum, uint8_t pubkey_out[64])
{
 8002dee:	460c      	mov	r4, r1
    int rv;
    uint8_t junk[3] = { 0 };
 8002df0:	f8ad 300c 	strh.w	r3, [sp, #12]
 8002df4:	f88d 300e 	strb.w	r3, [sp, #14]

    do {
        ae_send_n(OP_GenKey, (1<<2), keynum, junk, 3);
 8002df8:	4605      	mov	r5, r0
 8002dfa:	2603      	movs	r6, #3
 8002dfc:	ab03      	add	r3, sp, #12
 8002dfe:	462a      	mov	r2, r5
 8002e00:	2104      	movs	r1, #4
 8002e02:	2040      	movs	r0, #64	; 0x40
 8002e04:	9600      	str	r6, [sp, #0]
 8002e06:	f7ff fe5b 	bl	8002ac0 <ae_send_n>

        delay_ms(100);     // to avoid timeouts
 8002e0a:	2064      	movs	r0, #100	; 0x64
 8002e0c:	f000 fd3c 	bl	8003888 <delay_ms>

        rv = ae_read_n(64, pubkey_out);
 8002e10:	4621      	mov	r1, r4
 8002e12:	2040      	movs	r0, #64	; 0x40
 8002e14:	f7ff fe1e 	bl	8002a54 <ae_read_n>
    } while(rv == AE_ECC_FAULT);
 8002e18:	2805      	cmp	r0, #5
 8002e1a:	d0ef      	beq.n	8002dfc <ae_gen_ecc_key+0x12>

    return rv;
}
 8002e1c:	b004      	add	sp, #16
 8002e1e:	bd70      	pop	{r4, r5, r6, pc}

08002e20 <ae_hmac32>:
// 508a: Different opcode, OP_HMAC does exactly 32 bytes w/ less steps.
// 608a: Use old SHA256 command, but with new flags.
//
    int
ae_hmac32(uint8_t keynum, const uint8_t msg[32], uint8_t digest[32])
{
 8002e20:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8002e22:	460e      	mov	r6, r1
 8002e24:	4615      	mov	r5, r2
    return ae_read_n(32, digest);
#endif

#if FOR_608
    // Start SHA w/ HMAC setup
	ae_send(OP_SHA, 4, keynum);        // 4 = HMAC_Init
 8002e26:	2104      	movs	r1, #4
 8002e28:	4602      	mov	r2, r0
 8002e2a:	2047      	movs	r0, #71	; 0x47
 8002e2c:	f7ff fe7d 	bl	8002b2a <ae_send>

    // expect zero, meaning "ready"
    int rv = ae_read1();
 8002e30:	f7ff fdf4 	bl	8002a1c <ae_read1>
    RET_IF_BAD(rv);
 8002e34:	b970      	cbnz	r0, 8002e54 <ae_hmac32+0x34>

    // send the contents to be hashed
	ae_send_n(OP_SHA, (3<<6) | 2, 32, msg, 32); // 2 = Finalize, 3=Place output
 8002e36:	2420      	movs	r4, #32
 8002e38:	9400      	str	r4, [sp, #0]
 8002e3a:	4633      	mov	r3, r6
 8002e3c:	4622      	mov	r2, r4
 8002e3e:	21c2      	movs	r1, #194	; 0xc2
 8002e40:	2047      	movs	r0, #71	; 0x47
 8002e42:	f7ff fe3d 	bl	8002ac0 <ae_send_n>
    
    // read result
    return ae_read_n(32, digest);
 8002e46:	4629      	mov	r1, r5
 8002e48:	4620      	mov	r0, r4
#endif
}
 8002e4a:	b002      	add	sp, #8
 8002e4c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

    // send the contents to be hashed
	ae_send_n(OP_SHA, (3<<6) | 2, 32, msg, 32); // 2 = Finalize, 3=Place output
    
    // read result
    return ae_read_n(32, digest);
 8002e50:	f7ff be00 	b.w	8002a54 <ae_read_n>
#endif
}
 8002e54:	b002      	add	sp, #8
 8002e56:	bd70      	pop	{r4, r5, r6, pc}

08002e58 <ae_get_serial>:
//
// Return the serial number: it's 9 bytes, altho 3 are fixed.
//
	int
ae_get_serial(uint8_t serial[6])
{
 8002e58:	b510      	push	{r4, lr}
	ae_send(OP_Read, 0x80, 0x0);
 8002e5a:	2200      	movs	r2, #0
//
// Return the serial number: it's 9 bytes, altho 3 are fixed.
//
	int
ae_get_serial(uint8_t serial[6])
{
 8002e5c:	b08c      	sub	sp, #48	; 0x30
	ae_send(OP_Read, 0x80, 0x0);
 8002e5e:	2180      	movs	r1, #128	; 0x80
//
// Return the serial number: it's 9 bytes, altho 3 are fixed.
//
	int
ae_get_serial(uint8_t serial[6])
{
 8002e60:	4604      	mov	r4, r0
	ae_send(OP_Read, 0x80, 0x0);
 8002e62:	2002      	movs	r0, #2
 8002e64:	f7ff fe61 	bl	8002b2a <ae_send>

	uint8_t temp[32];
	int rv = ae_read_n(32, temp);
 8002e68:	a904      	add	r1, sp, #16
 8002e6a:	2020      	movs	r0, #32
 8002e6c:	f7ff fdf2 	bl	8002a54 <ae_read_n>
	RET_IF_BAD(rv);
 8002e70:	4602      	mov	r2, r0
 8002e72:	b9b0      	cbnz	r0, 8002ea2 <ae_get_serial+0x4a>

    // reformat to 9 bytes.
    uint8_t ts[9];
	memcpy(ts, &temp[0], 4);
	memcpy(&ts[4], &temp[8], 5);
 8002e74:	a906      	add	r1, sp, #24
 8002e76:	c903      	ldmia	r1, {r0, r1}
	int rv = ae_read_n(32, temp);
	RET_IF_BAD(rv);

    // reformat to 9 bytes.
    uint8_t ts[9];
	memcpy(ts, &temp[0], 4);
 8002e78:	9b04      	ldr	r3, [sp, #16]
	memcpy(&ts[4], &temp[8], 5);
 8002e7a:	9002      	str	r0, [sp, #8]

    // check the hard-coded values
    if((ts[0] != 0x01) || (ts[1] != 0x23) || (ts[8] != 0xEE)) return 1;
 8002e7c:	b2d8      	uxtb	r0, r3
 8002e7e:	2801      	cmp	r0, #1
	int rv = ae_read_n(32, temp);
	RET_IF_BAD(rv);

    // reformat to 9 bytes.
    uint8_t ts[9];
	memcpy(ts, &temp[0], 4);
 8002e80:	9301      	str	r3, [sp, #4]
	memcpy(&ts[4], &temp[8], 5);
 8002e82:	f88d 100c 	strb.w	r1, [sp, #12]

    // check the hard-coded values
    if((ts[0] != 0x01) || (ts[1] != 0x23) || (ts[8] != 0xEE)) return 1;
 8002e86:	d10e      	bne.n	8002ea6 <ae_get_serial+0x4e>
 8002e88:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8002e8c:	2b23      	cmp	r3, #35	; 0x23
 8002e8e:	d10b      	bne.n	8002ea8 <ae_get_serial+0x50>
 8002e90:	b2cb      	uxtb	r3, r1
 8002e92:	2bee      	cmp	r3, #238	; 0xee
 8002e94:	d108      	bne.n	8002ea8 <ae_get_serial+0x50>

    // save only the unique bits.
    memcpy(serial, ts+2, 6);
 8002e96:	ab0c      	add	r3, sp, #48	; 0x30
 8002e98:	f853 1d2a 	ldr.w	r1, [r3, #-42]!
 8002e9c:	6021      	str	r1, [r4, #0]
 8002e9e:	889b      	ldrh	r3, [r3, #4]
 8002ea0:	80a3      	strh	r3, [r4, #4]
 8002ea2:	4610      	mov	r0, r2
 8002ea4:	e000      	b.n	8002ea8 <ae_get_serial+0x50>
    uint8_t ts[9];
	memcpy(ts, &temp[0], 4);
	memcpy(&ts[4], &temp[8], 5);

    // check the hard-coded values
    if((ts[0] != 0x01) || (ts[1] != 0x23) || (ts[8] != 0xEE)) return 1;
 8002ea6:	2001      	movs	r0, #1

    // save only the unique bits.
    memcpy(serial, ts+2, 6);

	return 0;
}
 8002ea8:	b00c      	add	sp, #48	; 0x30
 8002eaa:	bd10      	pop	{r4, pc}

08002eac <ae_probe>:

// ae_probe()
//
	const char *
ae_probe(void)
{
 8002eac:	b513      	push	{r0, r1, r4, lr}
ae_send_sleep(void)
{
	// "The ATECC508A goes into the low power sleep mode and ignores all
	// subsequent I/O transitions until the next wake flag. The entire volatile
	// state of the device is reset"
    ae_wake();
 8002eae:	f7ff fceb 	bl	8002888 <ae_wake>

    _send_bits(IOFLAG_SLEEP);
 8002eb2:	20cc      	movs	r0, #204	; 0xcc
 8002eb4:	f7ff fc64 	bl	8002780 <_send_bits>
{
    // Make it sleep / wake it up.
	ae_send_sleep();

    // Wake it again (to reset state)
    ae_wake();
 8002eb8:	f7ff fce6 	bl	8002888 <ae_wake>

	// do a real read w/ CRC
	// with no command happening, expect 0x11: "After Wake, prior to first command"
    ae_read1();
 8002ebc:	f7ff fdae 	bl	8002a1c <ae_read1>

	uint8_t chk = ae_read1();
 8002ec0:	f7ff fdac 	bl	8002a1c <ae_read1>
	if(chk != AE_AFTER_WAKE) return "wk fl";
 8002ec4:	b2c0      	uxtb	r0, r0
 8002ec6:	2811      	cmp	r0, #17
 8002ec8:	d10d      	bne.n	8002ee6 <ae_probe+0x3a>

    // read the serial number one time
    uint8_t serial[6];
	if(ae_get_serial(serial)) return "no ser";
 8002eca:	4668      	mov	r0, sp
 8002ecc:	f7ff ffc4 	bl	8002e58 <ae_get_serial>
 8002ed0:	4604      	mov	r4, r0
 8002ed2:	b930      	cbnz	r0, 8002ee2 <ae_probe+0x36>
ae_send_sleep(void)
{
	// "The ATECC508A goes into the low power sleep mode and ignores all
	// subsequent I/O transitions until the next wake flag. The entire volatile
	// state of the device is reset"
    ae_wake();
 8002ed4:	f7ff fcd8 	bl	8002888 <ae_wake>

    _send_bits(IOFLAG_SLEEP);
 8002ed8:	20cc      	movs	r0, #204	; 0xcc
 8002eda:	f7ff fc51 	bl	8002780 <_send_bits>
	if(ae_get_serial(serial)) return "no ser";

	// put into a low-power mode, might be a bit before we come back
	ae_send_sleep();

	return NULL;
 8002ede:	4620      	mov	r0, r4
 8002ee0:	e002      	b.n	8002ee8 <ae_probe+0x3c>
	uint8_t chk = ae_read1();
	if(chk != AE_AFTER_WAKE) return "wk fl";

    // read the serial number one time
    uint8_t serial[6];
	if(ae_get_serial(serial)) return "no ser";
 8002ee2:	4802      	ldr	r0, [pc, #8]	; (8002eec <ae_probe+0x40>)
 8002ee4:	e000      	b.n	8002ee8 <ae_probe+0x3c>
	// do a real read w/ CRC
	// with no command happening, expect 0x11: "After Wake, prior to first command"
    ae_read1();

	uint8_t chk = ae_read1();
	if(chk != AE_AFTER_WAKE) return "wk fl";
 8002ee6:	4802      	ldr	r0, [pc, #8]	; (8002ef0 <ae_probe+0x44>)

	// put into a low-power mode, might be a bit before we come back
	ae_send_sleep();

	return NULL;
}
 8002ee8:	b002      	add	sp, #8
 8002eea:	bd10      	pop	{r4, pc}
 8002eec:	0800e3d5 	.word	0x0800e3d5
 8002ef0:	0800e3dc 	.word	0x0800e3dc

08002ef4 <ae_write_data_slot>:
//
// -- can also lock it.
//
    int
ae_write_data_slot(int slot_num, const uint8_t *data, int len, bool lock_it)
{
 8002ef4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002ef8:	461c      	mov	r4, r3
    ASSERT(len >= 32);
 8002efa:	f1a2 0320 	sub.w	r3, r2, #32
//
// -- can also lock it.
//
    int
ae_write_data_slot(int slot_num, const uint8_t *data, int len, bool lock_it)
{
 8002efe:	b085      	sub	sp, #20
    ASSERT(len >= 32);
 8002f00:	f5b3 7fc0 	cmp.w	r3, #384	; 0x180
//
// -- can also lock it.
//
    int
ae_write_data_slot(int slot_num, const uint8_t *data, int len, bool lock_it)
{
 8002f04:	4605      	mov	r5, r0
 8002f06:	af02      	add	r7, sp, #8
 8002f08:	460e      	mov	r6, r1
 8002f0a:	4691      	mov	r9, r2
    ASSERT(len >= 32);
 8002f0c:	d902      	bls.n	8002f14 <ae_write_data_slot+0x20>
 8002f0e:	4830      	ldr	r0, [pc, #192]	; (8002fd0 <ae_write_data_slot+0xdc>)
 8002f10:	f7fd fd64 	bl	80009dc <fatal_error>
 8002f14:	1e53      	subs	r3, r2, #1
    ASSERT(len <= 416);

    for(int blk=0, xlen=len; xlen>0; blk++, xlen-=32) {
        // have to write each "block" of 32-bytes, separately
        // zone => data
        ae_send_n(OP_Write, 0x80|2, (blk<<8) | (slot_num<<3), data+(blk*32), 32);
 8002f16:	ea4f 0ac0 	mov.w	sl, r0, lsl #3
 8002f1a:	095b      	lsrs	r3, r3, #5
 8002f1c:	fa1f fa8a 	uxth.w	sl, sl
 8002f20:	f103 0b01 	add.w	fp, r3, #1
 8002f24:	f04f 0800 	mov.w	r8, #0
 8002f28:	2320      	movs	r3, #32
 8002f2a:	ea4a 2208 	orr.w	r2, sl, r8, lsl #8
 8002f2e:	b292      	uxth	r2, r2
 8002f30:	9300      	str	r3, [sp, #0]
 8002f32:	2182      	movs	r1, #130	; 0x82
 8002f34:	eb06 1348 	add.w	r3, r6, r8, lsl #5
 8002f38:	2012      	movs	r0, #18
 8002f3a:	f7ff fdc1 	bl	8002ac0 <ae_send_n>

        int rv = ae_read1();
 8002f3e:	f7ff fd6d 	bl	8002a1c <ae_read1>
        RET_IF_BAD(rv);
 8002f42:	2800      	cmp	r0, #0
 8002f44:	d13f      	bne.n	8002fc6 <ae_write_data_slot+0xd2>
ae_write_data_slot(int slot_num, const uint8_t *data, int len, bool lock_it)
{
    ASSERT(len >= 32);
    ASSERT(len <= 416);

    for(int blk=0, xlen=len; xlen>0; blk++, xlen-=32) {
 8002f46:	f108 0801 	add.w	r8, r8, #1
 8002f4a:	45c3      	cmp	fp, r8
 8002f4c:	d1ec      	bne.n	8002f28 <ae_write_data_slot+0x34>

        int rv = ae_read1();
        RET_IF_BAD(rv);
    }

    if(lock_it) {
 8002f4e:	b3cc      	cbz	r4, 8002fc4 <ae_write_data_slot+0xd0>
        ASSERT(slot_num != 8);          // no support for mega slot 8
 8002f50:	2d08      	cmp	r5, #8

        int rv = ae_read1();
        RET_IF_BAD(rv);
    }

    if(lock_it) {
 8002f52:	466c      	mov	r4, sp
        ASSERT(slot_num != 8);          // no support for mega slot 8
 8002f54:	d0db      	beq.n	8002f0e <ae_write_data_slot+0x1a>
        ASSERT(len == 32);              // probably not a limitation here
 8002f56:	f1b9 0f20 	cmp.w	r9, #32
 8002f5a:	d1d8      	bne.n	8002f0e <ae_write_data_slot+0x1a>

        // Assume 36/72-byte long slot, which will be partially written, and rest
        // should be ones.
        const int slot_len = (slot_num <= 7) ? 36 : 72;
 8002f5c:	2d08      	cmp	r5, #8
 8002f5e:	bfb4      	ite	lt
 8002f60:	f04f 0824 	movlt.w	r8, #36	; 0x24
 8002f64:	f04f 0848 	movge.w	r8, #72	; 0x48
        uint8_t copy[slot_len];
 8002f68:	f108 0307 	add.w	r3, r8, #7
 8002f6c:	f023 0307 	bic.w	r3, r3, #7
 8002f70:	ebad 0d03 	sub.w	sp, sp, r3
 8002f74:	ab02      	add	r3, sp, #8

        memset(copy, 0xff, slot_len);
 8002f76:	4642      	mov	r2, r8
 8002f78:	21ff      	movs	r1, #255	; 0xff
 8002f7a:	4618      	mov	r0, r3
 8002f7c:	f00a faa3 	bl	800d4c6 <memset>
        memcpy(copy, data, len);
 8002f80:	f106 0120 	add.w	r1, r6, #32
        // Assume 36/72-byte long slot, which will be partially written, and rest
        // should be ones.
        const int slot_len = (slot_num <= 7) ? 36 : 72;
        uint8_t copy[slot_len];

        memset(copy, 0xff, slot_len);
 8002f84:	4603      	mov	r3, r0
        memcpy(copy, data, len);
 8002f86:	4602      	mov	r2, r0
 8002f88:	f856 0b04 	ldr.w	r0, [r6], #4
 8002f8c:	f842 0b04 	str.w	r0, [r2], #4
 8002f90:	428e      	cmp	r6, r1
 8002f92:	d1f9      	bne.n	8002f88 <ae_write_data_slot+0x94>

        // calc expected CRC
        uint8_t crc[2] = {0, 0};
 8002f94:	2200      	movs	r2, #0
        crc16_chain(slot_len, copy, crc);
 8002f96:	4619      	mov	r1, r3

        memset(copy, 0xff, slot_len);
        memcpy(copy, data, len);

        // calc expected CRC
        uint8_t crc[2] = {0, 0};
 8002f98:	713a      	strb	r2, [r7, #4]
 8002f9a:	717a      	strb	r2, [r7, #5]
        crc16_chain(slot_len, copy, crc);
 8002f9c:	4640      	mov	r0, r8
 8002f9e:	1d3a      	adds	r2, r7, #4
 8002fa0:	f7ff fc28 	bl	80027f4 <crc16_chain>

        // do the lock
        ae_send(OP_Lock, 2 | (slot_num << 2), (crc[1]<<8) | crc[0]);
 8002fa4:	793b      	ldrb	r3, [r7, #4]
 8002fa6:	797a      	ldrb	r2, [r7, #5]
 8002fa8:	00a9      	lsls	r1, r5, #2
 8002faa:	f041 0102 	orr.w	r1, r1, #2
 8002fae:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
 8002fb2:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
 8002fb6:	2017      	movs	r0, #23
 8002fb8:	f7ff fdb7 	bl	8002b2a <ae_send>

        int rv = ae_read1();
 8002fbc:	f7ff fd2e 	bl	8002a1c <ae_read1>
 8002fc0:	46a5      	mov	sp, r4
 8002fc2:	e000      	b.n	8002fc6 <ae_write_data_slot+0xd2>
        RET_IF_BAD(rv);
    }

    return 0;
 8002fc4:	4620      	mov	r0, r4
}
 8002fc6:	370c      	adds	r7, #12
 8002fc8:	46bd      	mov	sp, r7
 8002fca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002fce:	bf00      	nop
 8002fd0:	0800d550 	.word	0x0800d550

08002fd4 <ae_gendig_slot>:

// ae_gendig_slot()
//
    int
ae_gendig_slot(int slot_num, const uint8_t slot_contents[32], uint8_t digest[32])
{
 8002fd4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002fd6:	b0ab      	sub	sp, #172	; 0xac
 8002fd8:	4605      	mov	r5, r0
 8002fda:	460f      	mov	r7, r1
    // Construct a digest on the device (and here) that depends on the secret
    // contents of a specific slot.
    uint8_t num_in[20], tempkey[32];

	rng_buffer(num_in, sizeof(num_in));
 8002fdc:	a803      	add	r0, sp, #12
 8002fde:	2114      	movs	r1, #20

// ae_gendig_slot()
//
    int
ae_gendig_slot(int slot_num, const uint8_t slot_contents[32], uint8_t digest[32])
{
 8002fe0:	4616      	mov	r6, r2
    // Construct a digest on the device (and here) that depends on the secret
    // contents of a specific slot.
    uint8_t num_in[20], tempkey[32];

	rng_buffer(num_in, sizeof(num_in));
 8002fe2:	f7ff fb91 	bl	8002708 <rng_buffer>
	int rv = ae_pick_nonce(num_in, tempkey);
 8002fe6:	a90f      	add	r1, sp, #60	; 0x3c
 8002fe8:	a803      	add	r0, sp, #12
 8002fea:	f7ff fdd5 	bl	8002b98 <ae_pick_nonce>
    RET_IF_BAD(rv);
 8002fee:	2800      	cmp	r0, #0
 8002ff0:	d13e      	bne.n	8003070 <ae_gendig_slot+0x9c>

    //using Zone=2="Data" => "KeyID specifies a slot in the Data zone"
    ae_send(OP_GenDig, 0x2, slot_num);
 8002ff2:	b2aa      	uxth	r2, r5
 8002ff4:	2102      	movs	r1, #2
 8002ff6:	2015      	movs	r0, #21
 8002ff8:	f7ff fd97 	bl	8002b2a <ae_send>

    rv = ae_read1();
 8002ffc:	f7ff fd0e 	bl	8002a1c <ae_read1>
    RET_IF_BAD(rv);
 8003000:	4604      	mov	r4, r0
 8003002:	bba0      	cbnz	r0, 800306e <ae_gendig_slot+0x9a>

    ae_keep_alive();
 8003004:	f7ff fd00 	bl	8002a08 <ae_keep_alive>
    //   msg = hkey + b'\x15\x02' + ustruct.pack("<H", slot_num)
    //   msg += b'\xee\x01\x23' + (b'\0'*25) + challenge
    //   assert len(msg) == 32+1+1+2+1+2+25+32
    //
	SHA256_CTX ctx;
    sha256_init(&ctx);
 8003008:	a817      	add	r0, sp, #92	; 0x5c
 800300a:	f002 f9a1 	bl	8005350 <sha256_init>

	uint8_t args[7] = { OP_GenDig, 2, slot_num, 0, 0xEE, 0x01, 0x23 };
 800300e:	2315      	movs	r3, #21
 8003010:	f88d 3004 	strb.w	r3, [sp, #4]
 8003014:	2302      	movs	r3, #2
 8003016:	f88d 3005 	strb.w	r3, [sp, #5]
 800301a:	23ee      	movs	r3, #238	; 0xee
 800301c:	f88d 3008 	strb.w	r3, [sp, #8]
 8003020:	2301      	movs	r3, #1
 8003022:	f88d 3009 	strb.w	r3, [sp, #9]
    uint8_t zeros[25] = { 0 };
 8003026:	2219      	movs	r2, #25
    //   assert len(msg) == 32+1+1+2+1+2+25+32
    //
	SHA256_CTX ctx;
    sha256_init(&ctx);

	uint8_t args[7] = { OP_GenDig, 2, slot_num, 0, 0xEE, 0x01, 0x23 };
 8003028:	2323      	movs	r3, #35	; 0x23
    uint8_t zeros[25] = { 0 };
 800302a:	4621      	mov	r1, r4
 800302c:	a808      	add	r0, sp, #32
    //   assert len(msg) == 32+1+1+2+1+2+25+32
    //
	SHA256_CTX ctx;
    sha256_init(&ctx);

	uint8_t args[7] = { OP_GenDig, 2, slot_num, 0, 0xEE, 0x01, 0x23 };
 800302e:	f88d 300a 	strb.w	r3, [sp, #10]
 8003032:	f88d 5006 	strb.w	r5, [sp, #6]
 8003036:	f88d 4007 	strb.w	r4, [sp, #7]
    uint8_t zeros[25] = { 0 };
 800303a:	f00a fa44 	bl	800d4c6 <memset>

    sha256_update(&ctx, slot_contents, 32);
 800303e:	2220      	movs	r2, #32
 8003040:	4639      	mov	r1, r7
 8003042:	a817      	add	r0, sp, #92	; 0x5c
 8003044:	f002 f994 	bl	8005370 <sha256_update>
    sha256_update(&ctx, args, sizeof(args));
 8003048:	2207      	movs	r2, #7
 800304a:	a901      	add	r1, sp, #4
 800304c:	a817      	add	r0, sp, #92	; 0x5c
 800304e:	f002 f98f 	bl	8005370 <sha256_update>
    sha256_update(&ctx, zeros, sizeof(zeros));
 8003052:	2219      	movs	r2, #25
 8003054:	a908      	add	r1, sp, #32
 8003056:	a817      	add	r0, sp, #92	; 0x5c
 8003058:	f002 f98a 	bl	8005370 <sha256_update>
    sha256_update(&ctx, tempkey, 32);
 800305c:	a90f      	add	r1, sp, #60	; 0x3c
 800305e:	a817      	add	r0, sp, #92	; 0x5c
 8003060:	2220      	movs	r2, #32
 8003062:	f002 f985 	bl	8005370 <sha256_update>

    sha256_final(&ctx, digest);
 8003066:	4631      	mov	r1, r6
 8003068:	a817      	add	r0, sp, #92	; 0x5c
 800306a:	f002 f9c7 	bl	80053fc <sha256_final>
 800306e:	4620      	mov	r0, r4

    return 0;
}
 8003070:	b02b      	add	sp, #172	; 0xac
 8003072:	bdf0      	pop	{r4, r5, r6, r7, pc}

08003074 <ae_checkmac_hard>:
// meaning that we both know the shared secret and the state of stuff in
// the 508a is what we expect.
//
    int
ae_checkmac_hard(uint8_t keynum, const uint8_t secret[32])
{
 8003074:	b500      	push	{lr}
 8003076:	b089      	sub	sp, #36	; 0x24
    uint8_t     digest[32];

    int rv = ae_gendig_slot(keynum, secret, digest);
 8003078:	466a      	mov	r2, sp
 800307a:	f7ff ffab 	bl	8002fd4 <ae_gendig_slot>
    RET_IF_BAD(rv);
 800307e:	b938      	cbnz	r0, 8003090 <ae_checkmac_hard+0x1c>

    // NOTE: we use this sometimes when we know the value is wrong, like
    // checking for blank pin codes... so not a huge error/security issue
    // if wrong here.
    if(!ae_is_correct_tempkey(digest)) return -2;
 8003080:	4668      	mov	r0, sp
 8003082:	f7ff fdbf 	bl	8002c04 <ae_is_correct_tempkey>
 8003086:	2800      	cmp	r0, #0

    // worked.
    return 0;
 8003088:	bf0c      	ite	eq
 800308a:	f06f 0001 	mvneq.w	r0, #1
 800308e:	2000      	movne	r0, #0
}
 8003090:	b009      	add	sp, #36	; 0x24
 8003092:	f85d fb04 	ldr.w	pc, [sp], #4

08003096 <ae_gendig_counter>:
// the digest should be, and ask the chip to do the same. Verify we match
// using MAC command (done elsewhere).
//
    int
ae_gendig_counter(int counter_num, const uint32_t expected_value, uint8_t digest[32])
{
 8003096:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003098:	b0ad      	sub	sp, #180	; 0xb4
 800309a:	4606      	mov	r6, r0
 800309c:	9101      	str	r1, [sp, #4]
    uint8_t num_in[20], tempkey[32];

	rng_buffer(num_in, sizeof(num_in));
 800309e:	a804      	add	r0, sp, #16
 80030a0:	2114      	movs	r1, #20
// the digest should be, and ask the chip to do the same. Verify we match
// using MAC command (done elsewhere).
//
    int
ae_gendig_counter(int counter_num, const uint32_t expected_value, uint8_t digest[32])
{
 80030a2:	4617      	mov	r7, r2
    uint8_t num_in[20], tempkey[32];

	rng_buffer(num_in, sizeof(num_in));
 80030a4:	f7ff fb30 	bl	8002708 <rng_buffer>
	int rv = ae_pick_nonce(num_in, tempkey);
 80030a8:	a909      	add	r1, sp, #36	; 0x24
 80030aa:	a804      	add	r0, sp, #16
 80030ac:	f7ff fd74 	bl	8002b98 <ae_pick_nonce>
    RET_IF_BAD(rv);
 80030b0:	2800      	cmp	r0, #0
 80030b2:	d148      	bne.n	8003146 <ae_gendig_counter+0xb0>

    //using Zone=4="Counter" => "KeyID specifies the monotonic counter ID"
    ae_send(OP_GenDig, 0x4, counter_num);
 80030b4:	b2b2      	uxth	r2, r6
 80030b6:	2104      	movs	r1, #4
 80030b8:	2015      	movs	r0, #21
 80030ba:	f7ff fd36 	bl	8002b2a <ae_send>

    rv = ae_read1();
 80030be:	f7ff fcad 	bl	8002a1c <ae_read1>
    RET_IF_BAD(rv);
 80030c2:	4604      	mov	r4, r0
 80030c4:	2800      	cmp	r0, #0
 80030c6:	d13d      	bne.n	8003144 <ae_gendig_counter+0xae>

    ae_keep_alive();
 80030c8:	f7ff fc9e 	bl	8002a08 <ae_keep_alive>
    //   msg = hkey + b'\x15\x02' + ustruct.pack("<H", slot_num)
    //   msg += b'\xee\x01\x23' + (b'\0'*25) + challenge
    //   assert len(msg) == 32+1+1+2+1+2+25+32
    //
	SHA256_CTX ctx;
    sha256_init(&ctx);
 80030cc:	a819      	add	r0, sp, #100	; 0x64
 80030ce:	f002 f93f 	bl	8005350 <sha256_init>

    uint8_t zeros[32] = { 0 };
 80030d2:	2220      	movs	r2, #32
 80030d4:	4621      	mov	r1, r4
 80030d6:	a811      	add	r0, sp, #68	; 0x44
 80030d8:	f00a f9f5 	bl	800d4c6 <memset>
	uint8_t args[8] = { OP_GenDig, 0x4, counter_num, 0,  0xEE, 0x01, 0x23, 0x0 };
 80030dc:	2315      	movs	r3, #21
 80030de:	f88d 3008 	strb.w	r3, [sp, #8]
 80030e2:	23ee      	movs	r3, #238	; 0xee
 80030e4:	f88d 300c 	strb.w	r3, [sp, #12]
 80030e8:	2301      	movs	r3, #1
 80030ea:	2504      	movs	r5, #4
 80030ec:	f88d 300d 	strb.w	r3, [sp, #13]

    sha256_update(&ctx, zeros, 32);
 80030f0:	2220      	movs	r2, #32
    //
	SHA256_CTX ctx;
    sha256_init(&ctx);

    uint8_t zeros[32] = { 0 };
	uint8_t args[8] = { OP_GenDig, 0x4, counter_num, 0,  0xEE, 0x01, 0x23, 0x0 };
 80030f2:	2323      	movs	r3, #35	; 0x23

    sha256_update(&ctx, zeros, 32);
 80030f4:	a911      	add	r1, sp, #68	; 0x44
 80030f6:	a819      	add	r0, sp, #100	; 0x64
    //
	SHA256_CTX ctx;
    sha256_init(&ctx);

    uint8_t zeros[32] = { 0 };
	uint8_t args[8] = { OP_GenDig, 0x4, counter_num, 0,  0xEE, 0x01, 0x23, 0x0 };
 80030f8:	f88d 300e 	strb.w	r3, [sp, #14]
 80030fc:	f88d 5009 	strb.w	r5, [sp, #9]
 8003100:	f88d 600a 	strb.w	r6, [sp, #10]
 8003104:	f88d 400b 	strb.w	r4, [sp, #11]
 8003108:	f88d 400f 	strb.w	r4, [sp, #15]

    sha256_update(&ctx, zeros, 32);
 800310c:	f002 f930 	bl	8005370 <sha256_update>
    sha256_update(&ctx, args, sizeof(args));
 8003110:	2208      	movs	r2, #8
 8003112:	eb0d 0102 	add.w	r1, sp, r2
 8003116:	a819      	add	r0, sp, #100	; 0x64
 8003118:	f002 f92a 	bl	8005370 <sha256_update>
    sha256_update(&ctx, (const uint8_t *)&expected_value, 4);
 800311c:	462a      	mov	r2, r5
 800311e:	eb0d 0105 	add.w	r1, sp, r5
 8003122:	a819      	add	r0, sp, #100	; 0x64
 8003124:	f002 f924 	bl	8005370 <sha256_update>
    sha256_update(&ctx, zeros, 20);
 8003128:	2214      	movs	r2, #20
 800312a:	a911      	add	r1, sp, #68	; 0x44
 800312c:	a819      	add	r0, sp, #100	; 0x64
 800312e:	f002 f91f 	bl	8005370 <sha256_update>
    sha256_update(&ctx, tempkey, 32);
 8003132:	a909      	add	r1, sp, #36	; 0x24
 8003134:	a819      	add	r0, sp, #100	; 0x64
 8003136:	2220      	movs	r2, #32
 8003138:	f002 f91a 	bl	8005370 <sha256_update>

    sha256_final(&ctx, digest);
 800313c:	4639      	mov	r1, r7
 800313e:	a819      	add	r0, sp, #100	; 0x64
 8003140:	f002 f95c 	bl	80053fc <sha256_final>
 8003144:	4620      	mov	r0, r4

    return 0;
}
 8003146:	b02d      	add	sp, #180	; 0xb4
 8003148:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800314a <ae_get_counter>:
//
// Just read a one-way counter.
//
	int
ae_get_counter(uint32_t *result, uint8_t counter_number)
{
 800314a:	b530      	push	{r4, r5, lr}
    ae_send(OP_Counter, 0x0, counter_number);
 800314c:	460a      	mov	r2, r1
//
// Just read a one-way counter.
//
	int
ae_get_counter(uint32_t *result, uint8_t counter_number)
{
 800314e:	b089      	sub	sp, #36	; 0x24
 8003150:	4605      	mov	r5, r0
 8003152:	460c      	mov	r4, r1
    ae_send(OP_Counter, 0x0, counter_number);
 8003154:	2024      	movs	r0, #36	; 0x24
 8003156:	2100      	movs	r1, #0
 8003158:	f7ff fce7 	bl	8002b2a <ae_send>

    int rv = ae_read_n(4, (uint8_t *)result);
 800315c:	4629      	mov	r1, r5
 800315e:	2004      	movs	r0, #4
 8003160:	f7ff fc78 	bl	8002a54 <ae_read_n>
    RET_IF_BAD(rv);
 8003164:	b968      	cbnz	r0, 8003182 <ae_get_counter+0x38>
    // IMPORTANT: Always verify the counter's value because otherwise
    // nothing prevents an active MitM changing the value that we think
    // we just read.

    uint8_t     digest[32];
    rv = ae_gendig_counter(counter_number, *result, digest);
 8003166:	4620      	mov	r0, r4
 8003168:	466a      	mov	r2, sp
 800316a:	6829      	ldr	r1, [r5, #0]
 800316c:	f7ff ff93 	bl	8003096 <ae_gendig_counter>
	RET_IF_BAD(rv);
 8003170:	4604      	mov	r4, r0
 8003172:	b928      	cbnz	r0, 8003180 <ae_get_counter+0x36>

    if(!ae_is_correct_tempkey(digest)) {
 8003174:	4668      	mov	r0, sp
 8003176:	f7ff fd45 	bl	8002c04 <ae_is_correct_tempkey>
 800317a:	b908      	cbnz	r0, 8003180 <ae_get_counter+0x36>
        // no legit way for this to happen, so just die.
        fatal_mitm();
 800317c:	f7fd fc38 	bl	80009f0 <fatal_mitm>
    }

    return 0;
 8003180:	4620      	mov	r0, r4
}
 8003182:	b009      	add	sp, #36	; 0x24
 8003184:	bd30      	pop	{r4, r5, pc}

08003186 <ae_add_counter>:
// Add-to and return a one-way counter's value. Have to go up in
// single-unit steps, but can we loop.
//
	int
ae_add_counter(uint32_t *result, uint8_t counter_number, int incr)
{
 8003186:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800318a:	4606      	mov	r6, r0
 800318c:	b088      	sub	sp, #32
 800318e:	460d      	mov	r5, r1
 8003190:	4617      	mov	r7, r2
    for(int i=0; i<incr; i++) {
 8003192:	2400      	movs	r4, #0
        ae_send(OP_Counter, 0x1, counter_number);
 8003194:	fa1f f881 	uxth.w	r8, r1
// single-unit steps, but can we loop.
//
	int
ae_add_counter(uint32_t *result, uint8_t counter_number, int incr)
{
    for(int i=0; i<incr; i++) {
 8003198:	42bc      	cmp	r4, r7
 800319a:	da0b      	bge.n	80031b4 <ae_add_counter+0x2e>
        ae_send(OP_Counter, 0x1, counter_number);
 800319c:	2101      	movs	r1, #1
 800319e:	2024      	movs	r0, #36	; 0x24
 80031a0:	4642      	mov	r2, r8
 80031a2:	f7ff fcc2 	bl	8002b2a <ae_send>
        int rv = ae_read_n(4, (uint8_t *)result);
 80031a6:	4631      	mov	r1, r6
 80031a8:	2004      	movs	r0, #4
 80031aa:	f7ff fc53 	bl	8002a54 <ae_read_n>
        RET_IF_BAD(rv);
 80031ae:	b978      	cbnz	r0, 80031d0 <ae_add_counter+0x4a>
// single-unit steps, but can we loop.
//
	int
ae_add_counter(uint32_t *result, uint8_t counter_number, int incr)
{
    for(int i=0; i<incr; i++) {
 80031b0:	3401      	adds	r4, #1
 80031b2:	e7f1      	b.n	8003198 <ae_add_counter+0x12>
    // IMPORTANT: Always verify the counter's value because otherwise
    // nothing prevents an active MitM changing the value that we think
    // we just read. They could also stop us increamenting the counter.

    uint8_t     digest[32];
    int rv = ae_gendig_counter(counter_number, *result, digest);
 80031b4:	466a      	mov	r2, sp
 80031b6:	6831      	ldr	r1, [r6, #0]
 80031b8:	4628      	mov	r0, r5
 80031ba:	f7ff ff6c 	bl	8003096 <ae_gendig_counter>
	RET_IF_BAD(rv);
 80031be:	4604      	mov	r4, r0
 80031c0:	b928      	cbnz	r0, 80031ce <ae_add_counter+0x48>

    if(!ae_is_correct_tempkey(digest)) {
 80031c2:	4668      	mov	r0, sp
 80031c4:	f7ff fd1e 	bl	8002c04 <ae_is_correct_tempkey>
 80031c8:	b908      	cbnz	r0, 80031ce <ae_add_counter+0x48>
        // no legit way for this to happen, so just die.
        fatal_mitm();
 80031ca:	f7fd fc11 	bl	80009f0 <fatal_mitm>
    }

    return 0;
 80031ce:	4620      	mov	r0, r4
}
 80031d0:	b008      	add	sp, #32
 80031d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080031d6 <ae_encrypted_read32>:
// ae_encrypted_read32()
//
    int
ae_encrypted_read32(int data_slot, int blk,
                    int read_kn, const uint8_t read_key[32], uint8_t data[32])
{
 80031d6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80031da:	b088      	sub	sp, #32
 80031dc:	4617      	mov	r7, r2
 80031de:	4698      	mov	r8, r3
 80031e0:	460e      	mov	r6, r1
 80031e2:	4604      	mov	r4, r0
 80031e4:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    uint8_t     digest[32];

    ae_pair_unlock();
 80031e6:	f7ff fddb 	bl	8002da0 <ae_pair_unlock>

    int rv = ae_gendig_slot(read_kn, read_key, digest);
 80031ea:	466a      	mov	r2, sp
 80031ec:	4641      	mov	r1, r8
 80031ee:	4638      	mov	r0, r7
 80031f0:	f7ff fef0 	bl	8002fd4 <ae_gendig_slot>
    RET_IF_BAD(rv);
 80031f4:	b9b0      	cbnz	r0, 8003224 <ae_encrypted_read32+0x4e>

    // read nth 32-byte "block"
    ae_send(OP_Read, 0x82, (blk << 8) | (data_slot<<3));
 80031f6:	00e2      	lsls	r2, r4, #3
 80031f8:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
 80031fc:	2182      	movs	r1, #130	; 0x82
 80031fe:	2002      	movs	r0, #2
 8003200:	b292      	uxth	r2, r2
 8003202:	f7ff fc92 	bl	8002b2a <ae_send>

    rv = ae_read_n(32, data);
 8003206:	4629      	mov	r1, r5
 8003208:	2020      	movs	r0, #32
 800320a:	f7ff fc23 	bl	8002a54 <ae_read_n>
    RET_IF_BAD(rv);
 800320e:	b948      	cbnz	r0, 8003224 <ae_encrypted_read32+0x4e>
		*(acc) ^= *(more);
 8003210:	782a      	ldrb	r2, [r5, #0]
 8003212:	f81d 3000 	ldrb.w	r3, [sp, r0]
 8003216:	3001      	adds	r0, #1
 8003218:	4053      	eors	r3, r2
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 800321a:	2820      	cmp	r0, #32
		*(acc) ^= *(more);
 800321c:	f805 3b01 	strb.w	r3, [r5], #1
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 8003220:	d1f6      	bne.n	8003210 <ae_encrypted_read32+0x3a>

    xor_mixin(data, digest, 32);

    return 0;
 8003222:	2000      	movs	r0, #0
}
 8003224:	b008      	add	sp, #32
 8003226:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

0800322c <ae_encrypted_read>:

// ae_encrypted_read()
//
    int
ae_encrypted_read(int data_slot, int read_kn, const uint8_t read_key[32], uint8_t *data, int len)
{
 800322c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003230:	b08a      	sub	sp, #40	; 0x28
 8003232:	4606      	mov	r6, r0
 8003234:	9c10      	ldr	r4, [sp, #64]	; 0x40
    // not clear if chip supports 4-byte encrypted reads 
    ASSERT((len == 32) || (len == 72));
 8003236:	2c20      	cmp	r4, #32

// ae_encrypted_read()
//
    int
ae_encrypted_read(int data_slot, int read_kn, const uint8_t read_key[32], uint8_t *data, int len)
{
 8003238:	460f      	mov	r7, r1
 800323a:	4690      	mov	r8, r2
 800323c:	461d      	mov	r5, r3
    // not clear if chip supports 4-byte encrypted reads 
    ASSERT((len == 32) || (len == 72));
 800323e:	d004      	beq.n	800324a <ae_encrypted_read+0x1e>
 8003240:	2c48      	cmp	r4, #72	; 0x48
 8003242:	d002      	beq.n	800324a <ae_encrypted_read+0x1e>
 8003244:	4814      	ldr	r0, [pc, #80]	; (8003298 <ae_encrypted_read+0x6c>)
 8003246:	f7fd fbc9 	bl	80009dc <fatal_error>

    int rv = ae_encrypted_read32(data_slot, 0, read_kn, read_key, data);
 800324a:	9500      	str	r5, [sp, #0]
 800324c:	4643      	mov	r3, r8
 800324e:	463a      	mov	r2, r7
 8003250:	2100      	movs	r1, #0
 8003252:	4630      	mov	r0, r6
 8003254:	f7ff ffbf 	bl	80031d6 <ae_encrypted_read32>
    RET_IF_BAD(rv);
 8003258:	b9d0      	cbnz	r0, 8003290 <ae_encrypted_read+0x64>

    if(len == 32) return 0;
 800325a:	2c20      	cmp	r4, #32
 800325c:	d018      	beq.n	8003290 <ae_encrypted_read+0x64>

    rv = ae_encrypted_read32(data_slot, 1, read_kn, read_key, data+32);
 800325e:	f105 0320 	add.w	r3, r5, #32
 8003262:	9300      	str	r3, [sp, #0]
 8003264:	463a      	mov	r2, r7
 8003266:	4643      	mov	r3, r8
 8003268:	2101      	movs	r1, #1
 800326a:	4630      	mov	r0, r6
 800326c:	f7ff ffb3 	bl	80031d6 <ae_encrypted_read32>
    RET_IF_BAD(rv);
 8003270:	b970      	cbnz	r0, 8003290 <ae_encrypted_read+0x64>

    uint8_t tmp[32];
    rv = ae_encrypted_read32(data_slot, 2, read_kn, read_key, tmp);
 8003272:	ac02      	add	r4, sp, #8
 8003274:	4643      	mov	r3, r8
 8003276:	9400      	str	r4, [sp, #0]
 8003278:	463a      	mov	r2, r7
 800327a:	2102      	movs	r1, #2
 800327c:	4630      	mov	r0, r6
 800327e:	f7ff ffaa 	bl	80031d6 <ae_encrypted_read32>
    RET_IF_BAD(rv);
 8003282:	4603      	mov	r3, r0
 8003284:	b918      	cbnz	r0, 800328e <ae_encrypted_read+0x62>

    memcpy(data+64, tmp, 72-64);
 8003286:	4622      	mov	r2, r4
 8003288:	ca03      	ldmia	r2!, {r0, r1}
 800328a:	6428      	str	r0, [r5, #64]	; 0x40
 800328c:	6469      	str	r1, [r5, #68]	; 0x44
 800328e:	4618      	mov	r0, r3

    return 0;
}
 8003290:	b00a      	add	sp, #40	; 0x28
 8003292:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003296:	bf00      	nop
 8003298:	0800d550 	.word	0x0800d550

0800329c <ae_encrypted_write32>:
// ae_encrypted_write()
//
    int
ae_encrypted_write32(int data_slot, int blk, int write_kn,
                        const uint8_t write_key[32], const uint8_t data[32])
{
 800329c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80032a0:	b0b7      	sub	sp, #220	; 0xdc
 80032a2:	4614      	mov	r4, r2
 80032a4:	461f      	mov	r7, r3
    uint8_t digest[32];

    ae_pair_unlock();

    // generate a hash over shared secret and rng
    int rv = ae_gendig_slot(write_kn, write_key, digest);
 80032a6:	f10d 0b2c 	add.w	fp, sp, #44	; 0x2c
// ae_encrypted_write()
//
    int
ae_encrypted_write32(int data_slot, int blk, int write_kn,
                        const uint8_t write_key[32], const uint8_t data[32])
{
 80032aa:	460e      	mov	r6, r1
 80032ac:	4605      	mov	r5, r0
 80032ae:	f8dd a100 	ldr.w	sl, [sp, #256]	; 0x100
    uint8_t digest[32];

    ae_pair_unlock();
 80032b2:	f7ff fd75 	bl	8002da0 <ae_pair_unlock>

    // generate a hash over shared secret and rng
    int rv = ae_gendig_slot(write_kn, write_key, digest);
 80032b6:	465a      	mov	r2, fp
 80032b8:	4639      	mov	r1, r7
 80032ba:	4620      	mov	r0, r4
 80032bc:	f7ff fe8a 	bl	8002fd4 <ae_gendig_slot>
    RET_IF_BAD(rv);
 80032c0:	2800      	cmp	r0, #0
 80032c2:	d14f      	bne.n	8003364 <ae_encrypted_write32+0xc8>
 80032c4:	4604      	mov	r4, r0

    // encrypt the data to be written, and append an authenticating MAC
    uint8_t body[32 + 32];

    for(int i=0; i<32; i++) {
        body[i] = data[i] ^ digest[i];
 80032c6:	f81a 2004 	ldrb.w	r2, [sl, r4]
 80032ca:	f81b 3004 	ldrb.w	r3, [fp, r4]
 80032ce:	f10d 094c 	add.w	r9, sp, #76	; 0x4c
 80032d2:	4053      	eors	r3, r2
 80032d4:	f804 3009 	strb.w	r3, [r4, r9]
    RET_IF_BAD(rv);

    // encrypt the data to be written, and append an authenticating MAC
    uint8_t body[32 + 32];

    for(int i=0; i<32; i++) {
 80032d8:	3401      	adds	r4, #1
 80032da:	2c20      	cmp	r4, #32
 80032dc:	d1f3      	bne.n	80032c6 <ae_encrypted_write32+0x2a>
	//	    + (b'\0'*25)
	//	    + new_value)
	//	assert len(msg) == 32+1+1+2+1+2+25+32
	//		
	SHA256_CTX ctx;
    sha256_init(&ctx);
 80032de:	a823      	add	r0, sp, #140	; 0x8c
 80032e0:	f002 f836 	bl	8005350 <sha256_init>

    uint8_t p1 = 0x80|2;        // 32 bytes into a data slot
    uint8_t p2_lsb = (data_slot << 3); 
    uint8_t p2_msb = blk;

	uint8_t args[7] = { OP_Write, p1, p2_lsb, p2_msb, 0xEE, 0x01, 0x23 };
 80032e4:	23ee      	movs	r3, #238	; 0xee
 80032e6:	f88d 300c 	strb.w	r3, [sp, #12]
	//		
	SHA256_CTX ctx;
    sha256_init(&ctx);

    uint8_t p1 = 0x80|2;        // 32 bytes into a data slot
    uint8_t p2_lsb = (data_slot << 3); 
 80032ea:	00ed      	lsls	r5, r5, #3
    uint8_t p2_msb = blk;

	uint8_t args[7] = { OP_Write, p1, p2_lsb, p2_msb, 0xEE, 0x01, 0x23 };
 80032ec:	2301      	movs	r3, #1
	//		
	SHA256_CTX ctx;
    sha256_init(&ctx);

    uint8_t p1 = 0x80|2;        // 32 bytes into a data slot
    uint8_t p2_lsb = (data_slot << 3); 
 80032ee:	b2ed      	uxtb	r5, r5
    uint8_t p2_msb = blk;

	uint8_t args[7] = { OP_Write, p1, p2_lsb, p2_msb, 0xEE, 0x01, 0x23 };
 80032f0:	2712      	movs	r7, #18
 80032f2:	f04f 0882 	mov.w	r8, #130	; 0x82
 80032f6:	f88d 300d 	strb.w	r3, [sp, #13]
    uint8_t zeros[25] = { 0 };
 80032fa:	2219      	movs	r2, #25

    uint8_t p1 = 0x80|2;        // 32 bytes into a data slot
    uint8_t p2_lsb = (data_slot << 3); 
    uint8_t p2_msb = blk;

	uint8_t args[7] = { OP_Write, p1, p2_lsb, p2_msb, 0xEE, 0x01, 0x23 };
 80032fc:	2323      	movs	r3, #35	; 0x23
    uint8_t zeros[25] = { 0 };
 80032fe:	2100      	movs	r1, #0
 8003300:	a804      	add	r0, sp, #16

    uint8_t p1 = 0x80|2;        // 32 bytes into a data slot
    uint8_t p2_lsb = (data_slot << 3); 
    uint8_t p2_msb = blk;

	uint8_t args[7] = { OP_Write, p1, p2_lsb, p2_msb, 0xEE, 0x01, 0x23 };
 8003302:	f88d 300e 	strb.w	r3, [sp, #14]
 8003306:	f88d 7008 	strb.w	r7, [sp, #8]
 800330a:	f88d 8009 	strb.w	r8, [sp, #9]
 800330e:	f88d 500a 	strb.w	r5, [sp, #10]
 8003312:	f88d 600b 	strb.w	r6, [sp, #11]
    uint8_t zeros[25] = { 0 };
 8003316:	f00a f8d6 	bl	800d4c6 <memset>

    sha256_update(&ctx, digest, 32);
 800331a:	4622      	mov	r2, r4
 800331c:	4659      	mov	r1, fp
 800331e:	a823      	add	r0, sp, #140	; 0x8c
 8003320:	f002 f826 	bl	8005370 <sha256_update>
    sha256_update(&ctx, args, sizeof(args));
 8003324:	2207      	movs	r2, #7
 8003326:	a902      	add	r1, sp, #8
 8003328:	a823      	add	r0, sp, #140	; 0x8c
 800332a:	f002 f821 	bl	8005370 <sha256_update>
    sha256_update(&ctx, zeros, sizeof(zeros));
 800332e:	2219      	movs	r2, #25
 8003330:	a904      	add	r1, sp, #16
 8003332:	a823      	add	r0, sp, #140	; 0x8c
 8003334:	f002 f81c 	bl	8005370 <sha256_update>
    sha256_update(&ctx, data, 32);
 8003338:	4622      	mov	r2, r4
 800333a:	4651      	mov	r1, sl
 800333c:	a823      	add	r0, sp, #140	; 0x8c
 800333e:	f002 f817 	bl	8005370 <sha256_update>

    sha256_final(&ctx, &body[32]);
 8003342:	a91b      	add	r1, sp, #108	; 0x6c
 8003344:	a823      	add	r0, sp, #140	; 0x8c
 8003346:	f002 f859 	bl	80053fc <sha256_final>

    ae_send_n(OP_Write, p1, (p2_msb << 8) | p2_lsb, body, sizeof(body));
 800334a:	0232      	lsls	r2, r6, #8
 800334c:	2340      	movs	r3, #64	; 0x40
 800334e:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 8003352:	9300      	str	r3, [sp, #0]
 8003354:	432a      	orrs	r2, r5
 8003356:	464b      	mov	r3, r9
 8003358:	4641      	mov	r1, r8
 800335a:	4638      	mov	r0, r7
 800335c:	f7ff fbb0 	bl	8002ac0 <ae_send_n>

    return ae_read1();
 8003360:	f7ff fb5c 	bl	8002a1c <ae_read1>
}
 8003364:	b037      	add	sp, #220	; 0xdc
 8003366:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

0800336c <ae_encrypted_write>:
// ae_encrypted_write()
//
    int
ae_encrypted_write(int data_slot, int write_kn, const uint8_t write_key[32],
                        const uint8_t *data, int len)
{
 800336c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003370:	b08a      	sub	sp, #40	; 0x28
    ASSERT(data_slot >= 0);
    ASSERT(data_slot <= 15);
 8003372:	280f      	cmp	r0, #15
// ae_encrypted_write()
//
    int
ae_encrypted_write(int data_slot, int write_kn, const uint8_t write_key[32],
                        const uint8_t *data, int len)
{
 8003374:	4607      	mov	r7, r0
 8003376:	4688      	mov	r8, r1
 8003378:	4691      	mov	r9, r2
 800337a:	469a      	mov	sl, r3
 800337c:	9d12      	ldr	r5, [sp, #72]	; 0x48
    ASSERT(data_slot >= 0);
    ASSERT(data_slot <= 15);
 800337e:	d902      	bls.n	8003386 <ae_encrypted_write+0x1a>
//
    int
ae_encrypted_write(int data_slot, int write_kn, const uint8_t write_key[32],
                        const uint8_t *data, int len)
{
    ASSERT(data_slot >= 0);
 8003380:	4812      	ldr	r0, [pc, #72]	; (80033cc <ae_encrypted_write+0x60>)
 8003382:	f7fd fb2b 	bl	80009dc <fatal_error>
 8003386:	2400      	movs	r4, #0

    for(int blk=0; blk<3 && len>0; blk++, len-=32) {
        int here = MIN(32, len);

        // be nice and don't read past end of input buffer
        uint8_t     tmp[32] = { 0 };
 8003388:	ae02      	add	r6, sp, #8
                        const uint8_t *data, int len)
{
    ASSERT(data_slot >= 0);
    ASSERT(data_slot <= 15);

    for(int blk=0; blk<3 && len>0; blk++, len-=32) {
 800338a:	2d00      	cmp	r5, #0
 800338c:	dd1a      	ble.n	80033c4 <ae_encrypted_write+0x58>
        int here = MIN(32, len);

        // be nice and don't read past end of input buffer
        uint8_t     tmp[32] = { 0 };
 800338e:	2220      	movs	r2, #32
 8003390:	2100      	movs	r1, #0
 8003392:	4630      	mov	r0, r6
 8003394:	f00a f897 	bl	800d4c6 <memset>
        memcpy(tmp, data+(32*blk), here);
 8003398:	2d20      	cmp	r5, #32
 800339a:	462a      	mov	r2, r5
 800339c:	eb0a 1144 	add.w	r1, sl, r4, lsl #5
 80033a0:	bfa8      	it	ge
 80033a2:	2220      	movge	r2, #32
 80033a4:	4630      	mov	r0, r6
 80033a6:	f00a f868 	bl	800d47a <memcpy>

        int rv = ae_encrypted_write32(data_slot, blk, write_kn, write_key, tmp);
 80033aa:	9600      	str	r6, [sp, #0]
 80033ac:	464b      	mov	r3, r9
 80033ae:	4642      	mov	r2, r8
 80033b0:	4621      	mov	r1, r4
 80033b2:	4638      	mov	r0, r7
 80033b4:	f7ff ff72 	bl	800329c <ae_encrypted_write32>
        RET_IF_BAD(rv);
 80033b8:	b928      	cbnz	r0, 80033c6 <ae_encrypted_write+0x5a>
                        const uint8_t *data, int len)
{
    ASSERT(data_slot >= 0);
    ASSERT(data_slot <= 15);

    for(int blk=0; blk<3 && len>0; blk++, len-=32) {
 80033ba:	3401      	adds	r4, #1
 80033bc:	2c03      	cmp	r4, #3
 80033be:	f1a5 0520 	sub.w	r5, r5, #32
 80033c2:	d1e2      	bne.n	800338a <ae_encrypted_write+0x1e>

        int rv = ae_encrypted_write32(data_slot, blk, write_kn, write_key, tmp);
        RET_IF_BAD(rv);
    }

    return 0;
 80033c4:	2000      	movs	r0, #0
}
 80033c6:	b00a      	add	sp, #40	; 0x28
 80033c8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80033cc:	0800d550 	.word	0x0800d550

080033d0 <ae_read_data_slot>:

// ae_read_data_slot()
//
    int
ae_read_data_slot(int slot_num, uint8_t *data, int len)
{
 80033d0:	b570      	push	{r4, r5, r6, lr}
    ASSERT((len == 4) || (len == 32) || (len == 72));
 80033d2:	2a04      	cmp	r2, #4

// ae_read_data_slot()
//
    int
ae_read_data_slot(int slot_num, uint8_t *data, int len)
{
 80033d4:	b088      	sub	sp, #32
 80033d6:	460d      	mov	r5, r1
 80033d8:	4616      	mov	r6, r2
    ASSERT((len == 4) || (len == 32) || (len == 72));
 80033da:	d002      	beq.n	80033e2 <ae_read_data_slot+0x12>
 80033dc:	2a20      	cmp	r2, #32
 80033de:	d034      	beq.n	800344a <ae_read_data_slot+0x7a>
 80033e0:	e02e      	b.n	8003440 <ae_read_data_slot+0x70>

    // zone => data
    // only reading first block of 32 bytes. ignore the rest
    ae_send(OP_Read, (len == 4 ? 0x00 : 0x80) | 2, (slot_num<<3));
 80033e2:	2102      	movs	r1, #2
 80033e4:	00c0      	lsls	r0, r0, #3
 80033e6:	b284      	uxth	r4, r0
 80033e8:	4622      	mov	r2, r4
 80033ea:	2002      	movs	r0, #2
 80033ec:	f7ff fb9d 	bl	8002b2a <ae_send>

    int rv = ae_read_n((len == 4) ? 4 : 32, data);
 80033f0:	2e04      	cmp	r6, #4
 80033f2:	bf0c      	ite	eq
 80033f4:	2004      	moveq	r0, #4
 80033f6:	2020      	movne	r0, #32
 80033f8:	4629      	mov	r1, r5
 80033fa:	f7ff fb2b 	bl	8002a54 <ae_read_n>
    RET_IF_BAD(rv);
 80033fe:	bb30      	cbnz	r0, 800344e <ae_read_data_slot+0x7e>

    if(len == 72) {
 8003400:	2e48      	cmp	r6, #72	; 0x48
 8003402:	d124      	bne.n	800344e <ae_read_data_slot+0x7e>
        // read second block
        ae_send(OP_Read, 0x82, (1<<8) | (slot_num<<3));
 8003404:	2182      	movs	r1, #130	; 0x82
 8003406:	2002      	movs	r0, #2
 8003408:	f444 7280 	orr.w	r2, r4, #256	; 0x100
 800340c:	f7ff fb8d 	bl	8002b2a <ae_send>

        int rv = ae_read_n(32, data+32);
 8003410:	f105 0120 	add.w	r1, r5, #32
 8003414:	2020      	movs	r0, #32
 8003416:	f7ff fb1d 	bl	8002a54 <ae_read_n>
        RET_IF_BAD(rv);
 800341a:	b9c0      	cbnz	r0, 800344e <ae_read_data_slot+0x7e>

        // read third block, but only using part of it
        uint8_t     tmp[32];
        ae_send(OP_Read, 0x82, (2<<8) | (slot_num<<3));
 800341c:	f444 7200 	orr.w	r2, r4, #512	; 0x200
 8003420:	2182      	movs	r1, #130	; 0x82
 8003422:	2002      	movs	r0, #2
 8003424:	f7ff fb81 	bl	8002b2a <ae_send>

        rv = ae_read_n(32, tmp);
 8003428:	4669      	mov	r1, sp
 800342a:	2020      	movs	r0, #32
 800342c:	f7ff fb12 	bl	8002a54 <ae_read_n>
        RET_IF_BAD(rv);
 8003430:	4603      	mov	r3, r0
 8003432:	b918      	cbnz	r0, 800343c <ae_read_data_slot+0x6c>

        memcpy(data+64, tmp, 72-64);
 8003434:	466a      	mov	r2, sp
 8003436:	ca03      	ldmia	r2!, {r0, r1}
 8003438:	6428      	str	r0, [r5, #64]	; 0x40
 800343a:	6469      	str	r1, [r5, #68]	; 0x44
 800343c:	4618      	mov	r0, r3
 800343e:	e006      	b.n	800344e <ae_read_data_slot+0x7e>
// ae_read_data_slot()
//
    int
ae_read_data_slot(int slot_num, uint8_t *data, int len)
{
    ASSERT((len == 4) || (len == 32) || (len == 72));
 8003440:	2a48      	cmp	r2, #72	; 0x48
 8003442:	d002      	beq.n	800344a <ae_read_data_slot+0x7a>
 8003444:	4803      	ldr	r0, [pc, #12]	; (8003454 <ae_read_data_slot+0x84>)
 8003446:	f7fd fac9 	bl	80009dc <fatal_error>

    // zone => data
    // only reading first block of 32 bytes. ignore the rest
    ae_send(OP_Read, (len == 4 ? 0x00 : 0x80) | 2, (slot_num<<3));
 800344a:	2182      	movs	r1, #130	; 0x82
 800344c:	e7ca      	b.n	80033e4 <ae_read_data_slot+0x14>

        memcpy(data+64, tmp, 72-64);
    }

    return 0;
}
 800344e:	b008      	add	sp, #32
 8003450:	bd70      	pop	{r4, r5, r6, pc}
 8003452:	bf00      	nop
 8003454:	0800d550 	.word	0x0800d550

08003458 <ae_set_gpio>:

// ae_set_gpio()
//
    int
ae_set_gpio(int state)
{
 8003458:	b513      	push	{r0, r1, r4, lr}
    // 1=turn on green, 0=red light (if not yet configured to be secure)
    ae_send(OP_Info, 3, 2 | (!!state));
 800345a:	2800      	cmp	r0, #0
 800345c:	bf14      	ite	ne
 800345e:	2203      	movne	r2, #3
 8003460:	2202      	moveq	r2, #2
 8003462:	2103      	movs	r1, #3
 8003464:	4604      	mov	r4, r0
 8003466:	2030      	movs	r0, #48	; 0x30
 8003468:	f7ff fb5f 	bl	8002b2a <ae_send>

    // "Always return the current state in the first byte followed by three bytes of 0x00"
    // - simple 1/0, in LSB.
    uint8_t resp[4];

    int rv = ae_read_n(4, resp);
 800346c:	a901      	add	r1, sp, #4
 800346e:	2004      	movs	r0, #4
 8003470:	f7ff faf0 	bl	8002a54 <ae_read_n>
	RET_IF_BAD(rv);
 8003474:	b928      	cbnz	r0, 8003482 <ae_set_gpio+0x2a>

    return (resp[0] != state) ? -1 : 0;
 8003476:	f89d 0004 	ldrb.w	r0, [sp, #4]
 800347a:	1b00      	subs	r0, r0, r4
 800347c:	bf18      	it	ne
 800347e:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
}
 8003482:	b002      	add	sp, #8
 8003484:	bd10      	pop	{r4, pc}

08003486 <ae_set_gpio_secure>:
//
// Set the GPIO using secure hash generated somehow already.
//
    int
ae_set_gpio_secure(uint8_t digest[32])
{
 8003486:	b538      	push	{r3, r4, r5, lr}
 8003488:	4605      	mov	r5, r0
    ae_pair_unlock();
 800348a:	f7ff fc89 	bl	8002da0 <ae_pair_unlock>
    ae_checkmac(KEYNUM_firmware, digest);
 800348e:	4629      	mov	r1, r5
 8003490:	200e      	movs	r0, #14
 8003492:	f7ff fc05 	bl	8002ca0 <ae_checkmac>

    int rv = ae_set_gpio(1);
 8003496:	2001      	movs	r0, #1
 8003498:	f7ff ffde 	bl	8003458 <ae_set_gpio>

    if(rv == 0) {
 800349c:	4604      	mov	r4, r0
 800349e:	b940      	cbnz	r0, 80034b2 <ae_set_gpio_secure+0x2c>
        // trust that readback, and so do a verify that the chip has 
        // the digest we think it does. If MitM wanted to turn off the output,
        // they can do that anytime regardless. We just don't want them to be
        // able to fake it being set, and therefore bypass the
        // "unsigned firmware" delay and warning.
        ae_pair_unlock();
 80034a0:	f7ff fc7e 	bl	8002da0 <ae_pair_unlock>

        if(ae_checkmac_hard(KEYNUM_firmware, digest) != 0) {
 80034a4:	4629      	mov	r1, r5
 80034a6:	200e      	movs	r0, #14
 80034a8:	f7ff fde4 	bl	8003074 <ae_checkmac_hard>
 80034ac:	b108      	cbz	r0, 80034b2 <ae_set_gpio_secure+0x2c>
            fatal_mitm();
 80034ae:	f7fd fa9f 	bl	80009f0 <fatal_mitm>
        }
    }

    return rv;
}
 80034b2:	4620      	mov	r0, r4
 80034b4:	bd38      	pop	{r3, r4, r5, pc}

080034b6 <ae_get_gpio>:
//
// IMPORTANT: do not trust this result, could be MitM'ed.
//
	uint8_t
ae_get_gpio(void)
{
 80034b6:	b507      	push	{r0, r1, r2, lr}
	// not doing error checking here
	ae_send(OP_Info, 0x3, 0);
 80034b8:	2200      	movs	r2, #0
 80034ba:	2103      	movs	r1, #3
 80034bc:	2030      	movs	r0, #48	; 0x30
 80034be:	f7ff fb34 	bl	8002b2a <ae_send>

	// note: always returns 4 bytes, but most are garbage and unused.
	uint8_t tmp[4];
	ae_read_n(4, tmp);
 80034c2:	a901      	add	r1, sp, #4
 80034c4:	2004      	movs	r0, #4
 80034c6:	f7ff fac5 	bl	8002a54 <ae_read_n>

	return tmp[0];
}
 80034ca:	f89d 0004 	ldrb.w	r0, [sp, #4]
 80034ce:	b003      	add	sp, #12
 80034d0:	f85d fb04 	ldr.w	pc, [sp], #4

080034d4 <ae_read_config_word>:
//
// Read a 4-byte area from config area, or -1 if fail.
//
    int
ae_read_config_word(int offset, uint8_t *dest)
{
 80034d4:	b510      	push	{r4, lr}
    offset &= 0x7f;

    // read 32 bits (aligned)
    ae_send(OP_Read, 0x00, offset/4);
 80034d6:	f3c0 0284 	ubfx	r2, r0, #2, #5
//
// Read a 4-byte area from config area, or -1 if fail.
//
    int
ae_read_config_word(int offset, uint8_t *dest)
{
 80034da:	460c      	mov	r4, r1
    offset &= 0x7f;

    // read 32 bits (aligned)
    ae_send(OP_Read, 0x00, offset/4);
 80034dc:	2002      	movs	r0, #2
 80034de:	2100      	movs	r1, #0
 80034e0:	f7ff fb23 	bl	8002b2a <ae_send>

	int rv = ae_read_n(4, dest);
 80034e4:	4621      	mov	r1, r4
 80034e6:	2004      	movs	r0, #4
 80034e8:	f7ff fab4 	bl	8002a54 <ae_read_n>
 80034ec:	3000      	adds	r0, #0
 80034ee:	bf18      	it	ne
 80034f0:	2001      	movne	r0, #1
    if(rv) return -1;

    return 0;
}
 80034f2:	4240      	negs	r0, r0
 80034f4:	bd10      	pop	{r4, pc}
	...

080034f8 <ae_read_config_byte>:
//
// Read a byte from config area.
//
    int
ae_read_config_byte(int offset)
{
 80034f8:	b513      	push	{r0, r1, r4, lr}
	uint8_t tmp[4];

    ae_read_config_word(offset, tmp);
 80034fa:	a901      	add	r1, sp, #4
//
// Read a byte from config area.
//
    int
ae_read_config_byte(int offset)
{
 80034fc:	4604      	mov	r4, r0
	uint8_t tmp[4];

    ae_read_config_word(offset, tmp);
 80034fe:	f7ff ffe9 	bl	80034d4 <ae_read_config_word>

	return tmp[offset % 4];
 8003502:	4b07      	ldr	r3, [pc, #28]	; (8003520 <ae_read_config_byte+0x28>)
 8003504:	4023      	ands	r3, r4
 8003506:	2b00      	cmp	r3, #0
 8003508:	bfbe      	ittt	lt
 800350a:	f103 33ff 	addlt.w	r3, r3, #4294967295	; 0xffffffff
 800350e:	f063 0303 	ornlt	r3, r3, #3
 8003512:	3301      	addlt	r3, #1
 8003514:	aa02      	add	r2, sp, #8
 8003516:	4413      	add	r3, r2
}
 8003518:	f813 0c04 	ldrb.w	r0, [r3, #-4]
 800351c:	b002      	add	sp, #8
 800351e:	bd10      	pop	{r4, pc}
 8003520:	80000003 	.word	0x80000003

08003524 <ae_destroy_key>:

// ae_destroy_key()
//
    int
ae_destroy_key(int keynum)
{
 8003524:	b510      	push	{r4, lr}
 8003526:	b090      	sub	sp, #64	; 0x40
	uint8_t numin[20];

	// Load tempkey with a known (random) nonce value
	rng_buffer(numin, sizeof(numin));
 8003528:	2114      	movs	r1, #20

// ae_destroy_key()
//
    int
ae_destroy_key(int keynum)
{
 800352a:	4604      	mov	r4, r0
	uint8_t numin[20];

	// Load tempkey with a known (random) nonce value
	rng_buffer(numin, sizeof(numin));
 800352c:	a803      	add	r0, sp, #12
 800352e:	f7ff f8eb 	bl	8002708 <rng_buffer>
    ae_send_n(OP_Nonce, 0, 0, numin, 20);
 8003532:	2314      	movs	r3, #20
 8003534:	2200      	movs	r2, #0
 8003536:	9300      	str	r3, [sp, #0]
 8003538:	4611      	mov	r1, r2
 800353a:	2016      	movs	r0, #22
 800353c:	ab03      	add	r3, sp, #12
 800353e:	f7ff fabf 	bl	8002ac0 <ae_send_n>

	// Nonce command returns the RNG result, not contents of TempKey,
    // but since we are destroying, no need to calculate what it is.
	uint8_t randout[32];
	int rv = ae_read_n(32, randout);
 8003542:	a908      	add	r1, sp, #32
 8003544:	2020      	movs	r0, #32
 8003546:	f7ff fa85 	bl	8002a54 <ae_read_n>
	RET_IF_BAD(rv);
 800354a:	b930      	cbnz	r0, 800355a <ae_destroy_key+0x36>

    // do a "DeriveKey" operation, based on that!
	ae_send(OP_DeriveKey, 0x00, keynum);
 800354c:	4601      	mov	r1, r0
 800354e:	b2a2      	uxth	r2, r4
 8003550:	201c      	movs	r0, #28
 8003552:	f7ff faea 	bl	8002b2a <ae_send>

    return ae_read1();
 8003556:	f7ff fa61 	bl	8002a1c <ae_read1>
}
 800355a:	b010      	add	sp, #64	; 0x40
 800355c:	bd10      	pop	{r4, pc}

0800355e <ae_config_read>:

// ae_config_read()
//
    int 
ae_config_read(uint8_t config[128])
{
 800355e:	b538      	push	{r3, r4, r5, lr}
 8003560:	4605      	mov	r5, r0
    for(int blk=0; blk<4; blk++) {
 8003562:	2400      	movs	r4, #0
        // read 32 bytes (aligned) from config "zone"
        ae_send(OP_Read, 0x80, blk<<3);
 8003564:	00e2      	lsls	r2, r4, #3
 8003566:	2180      	movs	r1, #128	; 0x80
 8003568:	2002      	movs	r0, #2
 800356a:	b292      	uxth	r2, r2
 800356c:	f7ff fadd 	bl	8002b2a <ae_send>

        int rv = ae_read_n(32, &config[32*blk]);
 8003570:	eb05 1144 	add.w	r1, r5, r4, lsl #5
 8003574:	2020      	movs	r0, #32
 8003576:	f7ff fa6d 	bl	8002a54 <ae_read_n>
        if(rv) return EIO;
 800357a:	b918      	cbnz	r0, 8003584 <ae_config_read+0x26>
// ae_config_read()
//
    int 
ae_config_read(uint8_t config[128])
{
    for(int blk=0; blk<4; blk++) {
 800357c:	3401      	adds	r4, #1
 800357e:	2c04      	cmp	r4, #4
 8003580:	d1f0      	bne.n	8003564 <ae_config_read+0x6>
 8003582:	bd38      	pop	{r3, r4, r5, pc}
        // read 32 bytes (aligned) from config "zone"
        ae_send(OP_Read, 0x80, blk<<3);

        int rv = ae_read_n(32, &config[32*blk]);
        if(rv) return EIO;
 8003584:	2005      	movs	r0, #5
    }

    return 0;
}
 8003586:	bd38      	pop	{r3, r4, r5, pc}

08003588 <ae_setup_config>:
// us to write the (existing) pairing secret into, they would see the pairing
// secret in cleartext. They could then restore original chip and access freely.
//
    int
ae_setup_config(void)
{
 8003588:	b570      	push	{r4, r5, r6, lr}
 800358a:	2405      	movs	r4, #5
 800358c:	f5ad 7d40 	sub.w	sp, sp, #768	; 0x300
    // Need to wake up AE, since many things happen before this point.
    for(int retry=0; retry<5; retry++) {
        if(!ae_probe()) break;
 8003590:	f7ff fc8c 	bl	8002eac <ae_probe>
 8003594:	b108      	cbz	r0, 800359a <ae_setup_config+0x12>
//
    int
ae_setup_config(void)
{
    // Need to wake up AE, since many things happen before this point.
    for(int retry=0; retry<5; retry++) {
 8003596:	3c01      	subs	r4, #1
 8003598:	d1fa      	bne.n	8003590 <ae_setup_config+0x8>
    // Is data zone is locked?
    // Allow rest of function to happen if it's not.

#if 1
    //  0x55 = unlocked; 0x00 = locked
    bool data_locked = (ae_read_config_byte(86) != 0x55);
 800359a:	2056      	movs	r0, #86	; 0x56
 800359c:	f7ff ffac 	bl	80034f8 <ae_read_config_byte>
    if(data_locked) return 0;       // basically success
 80035a0:	2855      	cmp	r0, #85	; 0x55
 80035a2:	f040 80f6 	bne.w	8003792 <ae_setup_config+0x20a>

    // To lock, we need a CRC over whole thing, but we
    // only set a few values... plus the serial number is
    // in there, so start with some readout.
    uint8_t config[128];
    int rv = ae_config_read(config);
 80035a6:	a838      	add	r0, sp, #224	; 0xe0
 80035a8:	f7ff ffd9 	bl	800355e <ae_config_read>
    if(rv) return rv;
 80035ac:	2800      	cmp	r0, #0
 80035ae:	f040 80f3 	bne.w	8003798 <ae_setup_config+0x210>
    uint8_t config[128];
    while(ae_config_read(config)) ;
#endif

    // verify some fixed values
    ASSERT(config[0] == 0x01);
 80035b2:	f89d 30e0 	ldrb.w	r3, [sp, #224]	; 0xe0
 80035b6:	2b01      	cmp	r3, #1
 80035b8:	d001      	beq.n	80035be <ae_setup_config+0x36>
 80035ba:	4879      	ldr	r0, [pc, #484]	; (80037a0 <ae_setup_config+0x218>)
 80035bc:	e050      	b.n	8003660 <ae_setup_config+0xd8>
    ASSERT(config[1] == 0x23);
 80035be:	f89d 30e1 	ldrb.w	r3, [sp, #225]	; 0xe1
 80035c2:	2b23      	cmp	r3, #35	; 0x23
 80035c4:	d1f9      	bne.n	80035ba <ae_setup_config+0x32>
    ASSERT(config[12] == 0xee);
 80035c6:	f89d 30ec 	ldrb.w	r3, [sp, #236]	; 0xec
 80035ca:	2bee      	cmp	r3, #238	; 0xee
 80035cc:	d1f5      	bne.n	80035ba <ae_setup_config+0x32>

    // guess part number: must be 608
    int8_t partno = ((config[6]>>4)&0xf);
    ASSERT(partno == 6);
 80035ce:	f89d 30e6 	ldrb.w	r3, [sp, #230]	; 0xe6
 80035d2:	091b      	lsrs	r3, r3, #4
 80035d4:	2b06      	cmp	r3, #6
 80035d6:	d1f0      	bne.n	80035ba <ae_setup_config+0x32>

    uint8_t serial[9];
	memcpy(serial, &config[0], 4);
 80035d8:	9b38      	ldr	r3, [sp, #224]	; 0xe0
 80035da:	9303      	str	r3, [sp, #12]
	memcpy(&serial[4], &config[8], 5);
 80035dc:	ab3a      	add	r3, sp, #232	; 0xe8
 80035de:	e893 0003 	ldmia.w	r3, {r0, r1}
 80035e2:	9004      	str	r0, [sp, #16]
 80035e4:	f88d 1014 	strb.w	r1, [sp, #20]

    if(check_all_ones(rom_secrets->ae_serial_number, 9)) {
 80035e8:	486e      	ldr	r0, [pc, #440]	; (80037a4 <ae_setup_config+0x21c>)
 80035ea:	2109      	movs	r1, #9
 80035ec:	f7ff f81c 	bl	8002628 <check_all_ones>
 80035f0:	b110      	cbz	r0, 80035f8 <ae_setup_config+0x70>
        // flash is empty; remember this serial number
        flash_save_ae_serial(serial);
 80035f2:	a803      	add	r0, sp, #12
 80035f4:	f7fe fdae 	bl	8002154 <flash_save_ae_serial>
    }

    if(!check_equal(rom_secrets->ae_serial_number, serial, 9)) {
 80035f8:	2209      	movs	r2, #9
 80035fa:	a903      	add	r1, sp, #12
 80035fc:	4869      	ldr	r0, [pc, #420]	; (80037a4 <ae_setup_config+0x21c>)
 80035fe:	f7ff f832 	bl	8002666 <check_equal>
 8003602:	2800      	cmp	r0, #0
 8003604:	f000 80c7 	beq.w	8003796 <ae_setup_config+0x20e>
    // - pick RNG value for words secret (and forget it)
    // - set all PIN values to known value (zeros)
    // - set all money secrets to knonw value (zeros)
    // - lock the data zone

    if(config[87] == 0x55) {
 8003608:	f89d 3137 	ldrb.w	r3, [sp, #311]	; 0x137
 800360c:	2b55      	cmp	r3, #85	; 0x55
 800360e:	d143      	bne.n	8003698 <ae_setup_config+0x110>
        static const uint8_t    config_2[] = AE_CHIP_CONFIG_2;

        STATIC_ASSERT(sizeof(config_1) == 84-16);
        STATIC_ASSERT(sizeof(config_2) == 128-90);

        memcpy(&config[16], config_1, sizeof(config_1));
 8003610:	2244      	movs	r2, #68	; 0x44
 8003612:	4965      	ldr	r1, [pc, #404]	; (80037a8 <ae_setup_config+0x220>)
 8003614:	a83c      	add	r0, sp, #240	; 0xf0
 8003616:	f009 ff30 	bl	800d47a <memcpy>
        memcpy(&config[90], config_2, sizeof(config_2));
 800361a:	4b64      	ldr	r3, [pc, #400]	; (80037ac <ae_setup_config+0x224>)
 800361c:	f50d 729d 	add.w	r2, sp, #314	; 0x13a
 8003620:	f103 0124 	add.w	r1, r3, #36	; 0x24
 8003624:	f853 0b04 	ldr.w	r0, [r3], #4
 8003628:	f842 0b04 	str.w	r0, [r2], #4
 800362c:	428b      	cmp	r3, r1
 800362e:	d1f9      	bne.n	8003624 <ae_setup_config+0x9c>
 8003630:	881b      	ldrh	r3, [r3, #0]
 8003632:	8013      	strh	r3, [r2, #0]
//
    static int
ae_config_write(const uint8_t config[128])
{
    // send all 128 bytes, less some that can't be written.
    for(int n=16; n<128; n+= 4) {
 8003634:	2410      	movs	r4, #16
        if(n == 84) continue;       // that word not writable

        // Must work on words, since can't write to most of the complete blocks.
        //  args = write_params(block=n//32, offset=n//4, is_config=True)
        //  p2 = (block << 3) | offset
        ae_send_n(OP_Write, 0, n/4, &config[n], 4);
 8003636:	2504      	movs	r5, #4
    static int
ae_config_write(const uint8_t config[128])
{
    // send all 128 bytes, less some that can't be written.
    for(int n=16; n<128; n+= 4) {
        if(n == 84) continue;       // that word not writable
 8003638:	2c54      	cmp	r4, #84	; 0x54
 800363a:	d103      	bne.n	8003644 <ae_setup_config+0xbc>
//
    static int
ae_config_write(const uint8_t config[128])
{
    // send all 128 bytes, less some that can't be written.
    for(int n=16; n<128; n+= 4) {
 800363c:	3404      	adds	r4, #4
 800363e:	2c80      	cmp	r4, #128	; 0x80
 8003640:	d1fa      	bne.n	8003638 <ae_setup_config+0xb0>
 8003642:	e00f      	b.n	8003664 <ae_setup_config+0xdc>
        if(n == 84) continue;       // that word not writable

        // Must work on words, since can't write to most of the complete blocks.
        //  args = write_params(block=n//32, offset=n//4, is_config=True)
        //  p2 = (block << 3) | offset
        ae_send_n(OP_Write, 0, n/4, &config[n], 4);
 8003644:	ab38      	add	r3, sp, #224	; 0xe0
 8003646:	4423      	add	r3, r4
 8003648:	f3c4 028f 	ubfx	r2, r4, #2, #16
 800364c:	2100      	movs	r1, #0
 800364e:	2012      	movs	r0, #18
 8003650:	9500      	str	r5, [sp, #0]
 8003652:	f7ff fa35 	bl	8002ac0 <ae_send_n>
    
		int rv = ae_read1();
 8003656:	f7ff f9e1 	bl	8002a1c <ae_read1>
        if(rv) return rv;
 800365a:	2800      	cmp	r0, #0
 800365c:	d0ee      	beq.n	800363c <ae_setup_config+0xb4>

        ae_keep_alive();

        // lock config zone
        if(ae_lock_config_zone(config)) {
            INCONSISTENT("conf lock");
 800365e:	4854      	ldr	r0, [pc, #336]	; (80037b0 <ae_setup_config+0x228>)
 8003660:	f7fd f9bc 	bl	80009dc <fatal_error>
        // write it.
        if(ae_config_write(config)) {
            INCONSISTENT("conf wr");
        }

        ae_keep_alive();
 8003664:	f7ff f9d0 	bl	8002a08 <ae_keep_alive>
//
    static int
ae_lock_config_zone(const uint8_t config[128])
{
    // calc expected CRC
    uint8_t crc[2] = {0, 0};
 8003668:	2500      	movs	r5, #0

    crc16_chain(128, config, crc);
 800366a:	aa58      	add	r2, sp, #352	; 0x160
 800366c:	a938      	add	r1, sp, #224	; 0xe0
 800366e:	4620      	mov	r0, r4
//
    static int
ae_lock_config_zone(const uint8_t config[128])
{
    // calc expected CRC
    uint8_t crc[2] = {0, 0};
 8003670:	f88d 5160 	strb.w	r5, [sp, #352]	; 0x160
 8003674:	f88d 5161 	strb.w	r5, [sp, #353]	; 0x161

    crc16_chain(128, config, crc);
 8003678:	f7ff f8bc 	bl	80027f4 <crc16_chain>

    // do the lock: mode=0
    ae_send(OP_Lock, 0x0, (crc[1]<<8) | crc[0]);
 800367c:	f89d 3160 	ldrb.w	r3, [sp, #352]	; 0x160
 8003680:	f89d 2161 	ldrb.w	r2, [sp, #353]	; 0x161
 8003684:	4629      	mov	r1, r5
 8003686:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
 800368a:	2017      	movs	r0, #23
 800368c:	f7ff fa4d 	bl	8002b2a <ae_send>

    return ae_read1();
 8003690:	f7ff f9c4 	bl	8002a1c <ae_read1>
        }

        ae_keep_alive();

        // lock config zone
        if(ae_lock_config_zone(config)) {
 8003694:	2800      	cmp	r0, #0
 8003696:	d1e2      	bne.n	800365e <ae_setup_config+0xd6>
    // Load data zone with some known values.
    // The datazone still unlocked, so no encryption needed (nor possible).
    
    // will use zeros for all PIN codes, and customer-defined-secret starting values
    uint8_t     zeros[72];
    memset(zeros, 0, sizeof(zeros));
 8003698:	2248      	movs	r2, #72	; 0x48
 800369a:	2100      	movs	r1, #0
 800369c:	a826      	add	r0, sp, #152	; 0x98
 800369e:	f009 ff12 	bl	800d4c6 <memset>

    // slots can already locked, if we re-run any of this code... can't overwrite in
    // that case.
    uint16_t unlocked = config[88] | (((uint8_t)config[89])<<8);
 80036a2:	f89d 5139 	ldrb.w	r5, [sp, #313]	; 0x139
 80036a6:	f89d 3138 	ldrb.w	r3, [sp, #312]	; 0x138

    for(int kn=0; kn<16; kn++) {
 80036aa:	2400      	movs	r4, #0
    uint8_t     zeros[72];
    memset(zeros, 0, sizeof(zeros));

    // slots can already locked, if we re-run any of this code... can't overwrite in
    // that case.
    uint16_t unlocked = config[88] | (((uint8_t)config[89])<<8);
 80036ac:	ea43 2505 	orr.w	r5, r3, r5, lsl #8

    for(int kn=0; kn<16; kn++) {
        ae_keep_alive();
 80036b0:	f7ff f9aa 	bl	8002a08 <ae_keep_alive>

        if(!(unlocked & (1<<kn))) {
 80036b4:	fa45 f304 	asr.w	r3, r5, r4
 80036b8:	f013 0f01 	tst.w	r3, #1
 80036bc:	f104 0601 	add.w	r6, r4, #1
 80036c0:	d058      	beq.n	8003774 <ae_setup_config+0x1ec>
            STATS(was_locked |= (1<<kn));
            continue;
        }

        switch(kn) {
 80036c2:	2c0e      	cmp	r4, #14
 80036c4:	d856      	bhi.n	8003774 <ae_setup_config+0x1ec>
 80036c6:	e8df f004 	tbb	[pc, r4]
 80036ca:	084a      	.short	0x084a
 80036cc:	150d150d 	.word	0x150d150d
 80036d0:	1a1d3a29 	.word	0x1a1d3a29
 80036d4:	1a1a1a1a 	.word	0x1a1a1a1a
 80036d8:	15          	.byte	0x15
 80036d9:	00          	.byte	0x00
            default:
            case 15: break;

            case KEYNUM_pairing:
                if(ae_write_data_slot(kn, rom_secrets->pairing_secret, 32, false)) {
 80036da:	2300      	movs	r3, #0
 80036dc:	2220      	movs	r2, #32
 80036de:	4935      	ldr	r1, [pc, #212]	; (80037b4 <ae_setup_config+0x22c>)
 80036e0:	2001      	movs	r0, #1
 80036e2:	e040      	b.n	8003766 <ae_setup_config+0x1de>
                    // - each pin attempt (limited by counter0)
                    // - stretching pin/words attempts (iterated may times)
                    // See mathcheck.py for details.
                    uint8_t     tmp[32];

                    rng_buffer(tmp, sizeof(tmp));
 80036e4:	2120      	movs	r1, #32
 80036e6:	a806      	add	r0, sp, #24
 80036e8:	f7ff f80e 	bl	8002708 <rng_buffer>
                    //#warning "fixed secrets"
                    //memset(tmp, 0x41+kn, 32);

                    if(ae_write_data_slot(kn, tmp, 32, true)) {
 80036ec:	2301      	movs	r3, #1
 80036ee:	2220      	movs	r2, #32
 80036f0:	a906      	add	r1, sp, #24
 80036f2:	e002      	b.n	80036fa <ae_setup_config+0x172>
                break;

            case KEYNUM_main_pin:
            case KEYNUM_lastgood:
            case KEYNUM_firmware:
                if(ae_write_data_slot(kn, zeros, 32, false)) {
 80036f4:	2300      	movs	r3, #0
 80036f6:	2220      	movs	r2, #32
 80036f8:	a926      	add	r1, sp, #152	; 0x98
 80036fa:	4620      	mov	r0, r4
 80036fc:	e01b      	b.n	8003736 <ae_setup_config+0x1ae>
            case KEYNUM_secret:
            case KEYNUM_check_secret:
            case KEYNUM_spare_1:
            case KEYNUM_spare_2:
            case KEYNUM_spare_3:
                if(ae_write_data_slot(kn, zeros, 72, false)) {
 80036fe:	2300      	movs	r3, #0
 8003700:	2248      	movs	r2, #72	; 0x48
 8003702:	e7f9      	b.n	80036f8 <ae_setup_config+0x170>
                    INCONSISTENT("wr blk 72");
                }
                break;

            case KEYNUM_long_secret: {            // 416 bytes
                uint8_t long_zeros[416] = {0};
 8003704:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
 8003708:	2100      	movs	r1, #0
 800370a:	a858      	add	r0, sp, #352	; 0x160
 800370c:	f009 fedb 	bl	800d4c6 <memset>
                if(ae_write_data_slot(kn, long_zeros, 416, false)) {
 8003710:	2300      	movs	r3, #0
 8003712:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
 8003716:	a958      	add	r1, sp, #352	; 0x160
 8003718:	2008      	movs	r0, #8
 800371a:	e00c      	b.n	8003736 <ae_setup_config+0x1ae>
                }
                break;
            }

            case KEYNUM_match_count: {
                uint32_t     buf[32/4] = { 1024, 1024 };
 800371c:	2220      	movs	r2, #32
 800371e:	2100      	movs	r1, #0
 8003720:	a80e      	add	r0, sp, #56	; 0x38
 8003722:	f009 fed0 	bl	800d4c6 <memset>
 8003726:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800372a:	930e      	str	r3, [sp, #56]	; 0x38
 800372c:	930f      	str	r3, [sp, #60]	; 0x3c
                if(ae_write_data_slot(KEYNUM_match_count, (const uint8_t *)buf,sizeof(buf),false)) {
 800372e:	2220      	movs	r2, #32
 8003730:	2300      	movs	r3, #0
 8003732:	a90e      	add	r1, sp, #56	; 0x38
 8003734:	2006      	movs	r0, #6
 8003736:	f7ff fbdd 	bl	8002ef4 <ae_write_data_slot>
 800373a:	b1d8      	cbz	r0, 8003774 <ae_setup_config+0x1ec>
 800373c:	e78f      	b.n	800365e <ae_setup_config+0xd6>

            case KEYNUM_joiner_key: {
                uint8_t     pubkey[64];

                // ? must prove we know the auth key (which is zeros, but still)
                if(ae_checkmac_hard(KEYNUM_main_pin, zeros) != 0) {
 800373e:	a926      	add	r1, sp, #152	; 0x98
 8003740:	2003      	movs	r0, #3
 8003742:	f7ff fc97 	bl	8003074 <ae_checkmac_hard>
 8003746:	2800      	cmp	r0, #0
 8003748:	d189      	bne.n	800365e <ae_setup_config+0xd6>
                    INCONSISTENT("ak");
                }

                // pick ECC keypair, lock it down, capture pubkey part
                if(ae_gen_ecc_key(KEYNUM_joiner_key, pubkey)) {
 800374a:	a916      	add	r1, sp, #88	; 0x58
 800374c:	2007      	movs	r0, #7
 800374e:	f7ff fb4c 	bl	8002dea <ae_gen_ecc_key>
 8003752:	2800      	cmp	r0, #0
 8003754:	d183      	bne.n	800365e <ae_setup_config+0xd6>
                    INCONSISTENT("kp");
                }

                // tell the SE2 part about that key, and apply it as the AUTH key C
                se2_save_auth_pubkey(pubkey);
 8003756:	a816      	add	r0, sp, #88	; 0x58
 8003758:	f004 f8d4 	bl	8007904 <se2_save_auth_pubkey>
 800375c:	e00a      	b.n	8003774 <ae_setup_config+0x1ec>
                break;
            }

            case 0:
                if(ae_write_data_slot(kn, (const uint8_t *)copyright_msg, 32, true)) {
 800375e:	4916      	ldr	r1, [pc, #88]	; (80037b8 <ae_setup_config+0x230>)
 8003760:	2301      	movs	r3, #1
 8003762:	2220      	movs	r2, #32
 8003764:	2000      	movs	r0, #0
 8003766:	f7ff fbc5 	bl	8002ef4 <ae_write_data_slot>
 800376a:	2800      	cmp	r0, #0
 800376c:	f47f af77 	bne.w	800365e <ae_setup_config+0xd6>

    // slots can already locked, if we re-run any of this code... can't overwrite in
    // that case.
    uint16_t unlocked = config[88] | (((uint8_t)config[89])<<8);

    for(int kn=0; kn<16; kn++) {
 8003770:	4634      	mov	r4, r6
 8003772:	e79d      	b.n	80036b0 <ae_setup_config+0x128>
 8003774:	2e10      	cmp	r6, #16
 8003776:	4634      	mov	r4, r6
 8003778:	d19a      	bne.n	80036b0 <ae_setup_config+0x128>
                break;
        }
    }

    // lock the data zone and effectively enter normal operation.
    ae_keep_alive();
 800377a:	f7ff f945 	bl	8002a08 <ae_keep_alive>
ae_lock_data_zone(void)
{
    // NOTE: I haven't been able to calc CRC right, so not using it.

    // do the lock: mode=1 (datazone) + 0x80 (no CRC check)
    ae_send(OP_Lock, 0x81, 0x0000);
 800377e:	2200      	movs	r2, #0
 8003780:	2181      	movs	r1, #129	; 0x81
 8003782:	2017      	movs	r0, #23
 8003784:	f7ff f9d1 	bl	8002b2a <ae_send>

    return ae_read1();
 8003788:	f7ff f948 	bl	8002a1c <ae_read1>
        }
    }

    // lock the data zone and effectively enter normal operation.
    ae_keep_alive();
    if(ae_lock_data_zone()) {
 800378c:	2800      	cmp	r0, #0
 800378e:	f47f af66 	bne.w	800365e <ae_setup_config+0xd6>
    // Allow rest of function to happen if it's not.

#if 1
    //  0x55 = unlocked; 0x00 = locked
    bool data_locked = (ae_read_config_byte(86) != 0x55);
    if(data_locked) return 0;       // basically success
 8003792:	2000      	movs	r0, #0
 8003794:	e000      	b.n	8003798 <ae_setup_config+0x210>
    }

    if(!check_equal(rom_secrets->ae_serial_number, serial, 9)) {
        // write failed?
        // we're already linked to a different chip? Write failed?
        return EPERM;
 8003796:	2001      	movs	r0, #1
    if(ae_lock_data_zone()) {
        INCONSISTENT("data lock");
    }

    return 0;
}
 8003798:	f50d 7d40 	add.w	sp, sp, #768	; 0x300
 800379c:	bd70      	pop	{r4, r5, r6, pc}
 800379e:	bf00      	nop
 80037a0:	0800d550 	.word	0x0800d550
 80037a4:	0801e040 	.word	0x0801e040
 80037a8:	0800e408 	.word	0x0800e408
 80037ac:	0800e3e2 	.word	0x0800e3e2
 80037b0:	0800d557 	.word	0x0800d557
 80037b4:	0801e000 	.word	0x0801e000
 80037b8:	0800e3b4 	.word	0x0800e3b4

080037bc <ae_stretch_iter>:
// - but our time to do each iteration is limited by software SHA256 in ae_pair_unlock
//
    int
ae_stretch_iter(const uint8_t start[32], uint8_t end[32], int iterations)
{
    ASSERT(start != end);           // we can't work inplace
 80037bc:	4288      	cmp	r0, r1
// - cost of each iteration, approximately: 8ms
// - but our time to do each iteration is limited by software SHA256 in ae_pair_unlock
//
    int
ae_stretch_iter(const uint8_t start[32], uint8_t end[32], int iterations)
{
 80037be:	b570      	push	{r4, r5, r6, lr}
 80037c0:	460c      	mov	r4, r1
 80037c2:	4616      	mov	r6, r2
    ASSERT(start != end);           // we can't work inplace
 80037c4:	d102      	bne.n	80037cc <ae_stretch_iter+0x10>
 80037c6:	480f      	ldr	r0, [pc, #60]	; (8003804 <ae_stretch_iter+0x48>)
 80037c8:	f7fd f908 	bl	80009dc <fatal_error>
    memcpy(end, start, 32);
 80037cc:	460b      	mov	r3, r1
 80037ce:	f100 0220 	add.w	r2, r0, #32
 80037d2:	f850 1b04 	ldr.w	r1, [r0], #4
 80037d6:	f843 1b04 	str.w	r1, [r3], #4
 80037da:	4290      	cmp	r0, r2
 80037dc:	d1f9      	bne.n	80037d2 <ae_stretch_iter+0x16>

    for(int i=0; i<iterations; i++) {
 80037de:	2500      	movs	r5, #0
 80037e0:	42b5      	cmp	r5, r6
 80037e2:	da0a      	bge.n	80037fa <ae_stretch_iter+0x3e>
        // must unlock again, because pin_stretch is an auth'd key
        if(ae_pair_unlock()) return -2;
 80037e4:	f7ff fadc 	bl	8002da0 <ae_pair_unlock>
 80037e8:	b948      	cbnz	r0, 80037fe <ae_stretch_iter+0x42>

        int rv = ae_hmac32(KEYNUM_pin_stretch, end, end);
 80037ea:	4622      	mov	r2, r4
 80037ec:	4621      	mov	r1, r4
 80037ee:	2002      	movs	r0, #2
 80037f0:	f7ff fb16 	bl	8002e20 <ae_hmac32>
        RET_IF_BAD(rv);
 80037f4:	b928      	cbnz	r0, 8003802 <ae_stretch_iter+0x46>
ae_stretch_iter(const uint8_t start[32], uint8_t end[32], int iterations)
{
    ASSERT(start != end);           // we can't work inplace
    memcpy(end, start, 32);

    for(int i=0; i<iterations; i++) {
 80037f6:	3501      	adds	r5, #1
 80037f8:	e7f2      	b.n	80037e0 <ae_stretch_iter+0x24>

        int rv = ae_hmac32(KEYNUM_pin_stretch, end, end);
        RET_IF_BAD(rv);
    }

    return 0;
 80037fa:	2000      	movs	r0, #0
 80037fc:	bd70      	pop	{r4, r5, r6, pc}
    ASSERT(start != end);           // we can't work inplace
    memcpy(end, start, 32);

    for(int i=0; i<iterations; i++) {
        // must unlock again, because pin_stretch is an auth'd key
        if(ae_pair_unlock()) return -2;
 80037fe:	f06f 0001 	mvn.w	r0, #1
        int rv = ae_hmac32(KEYNUM_pin_stretch, end, end);
        RET_IF_BAD(rv);
    }

    return 0;
}
 8003802:	bd70      	pop	{r4, r5, r6, pc}
 8003804:	0800d550 	.word	0x0800d550

08003808 <ae_mixin_key>:
// Apply HMAC using secret in chip as a HMAC key, then encrypt
// the result a little because read in clear over bus.
//
    int
ae_mixin_key(uint8_t keynum, const uint8_t start[32], uint8_t end[32])
{
 8003808:	b570      	push	{r4, r5, r6, lr}
 800380a:	b096      	sub	sp, #88	; 0x58
    ASSERT(start != end);           // we can't work inplace
 800380c:	4291      	cmp	r1, r2
// Apply HMAC using secret in chip as a HMAC key, then encrypt
// the result a little because read in clear over bus.
//
    int
ae_mixin_key(uint8_t keynum, const uint8_t start[32], uint8_t end[32])
{
 800380e:	460e      	mov	r6, r1
 8003810:	4615      	mov	r5, r2
 8003812:	f88d 0007 	strb.w	r0, [sp, #7]
    ASSERT(start != end);           // we can't work inplace
 8003816:	d102      	bne.n	800381e <ae_mixin_key+0x16>
 8003818:	4819      	ldr	r0, [pc, #100]	; (8003880 <ae_mixin_key+0x78>)
 800381a:	f7fd f8df 	bl	80009dc <fatal_error>

    if(ae_pair_unlock()) return -1;
 800381e:	f7ff fabf 	bl	8002da0 <ae_pair_unlock>
 8003822:	bb30      	cbnz	r0, 8003872 <ae_mixin_key+0x6a>

    ASSERT(keynum != 0);
 8003824:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8003828:	2800      	cmp	r0, #0
 800382a:	d0f5      	beq.n	8003818 <ae_mixin_key+0x10>
    int rv = ae_hmac32(keynum, start, end);
 800382c:	462a      	mov	r2, r5
 800382e:	4631      	mov	r1, r6
 8003830:	f7ff faf6 	bl	8002e20 <ae_hmac32>
    RET_IF_BAD(rv);
 8003834:	4604      	mov	r4, r0
 8003836:	b9f8      	cbnz	r0, 8003878 <ae_mixin_key+0x70>
    // use the value provided in cleartext[sic--it's not] write back shortly (to test it).
    // Solution: one more SHA256, and to be safe, mixin lots of values!

	SHA256_CTX ctx;

    sha256_init(&ctx);
 8003838:	a803      	add	r0, sp, #12
 800383a:	f001 fd89 	bl	8005350 <sha256_init>
    sha256_update(&ctx, rom_secrets->pairing_secret, 32);
 800383e:	a803      	add	r0, sp, #12
 8003840:	2220      	movs	r2, #32
 8003842:	4910      	ldr	r1, [pc, #64]	; (8003884 <ae_mixin_key+0x7c>)
 8003844:	f001 fd94 	bl	8005370 <sha256_update>
    sha256_update(&ctx, start, 32);
 8003848:	4631      	mov	r1, r6
 800384a:	a803      	add	r0, sp, #12
 800384c:	2220      	movs	r2, #32
 800384e:	f001 fd8f 	bl	8005370 <sha256_update>
    sha256_update(&ctx, &keynum, 1);
 8003852:	f10d 0107 	add.w	r1, sp, #7
 8003856:	a803      	add	r0, sp, #12
 8003858:	2201      	movs	r2, #1
 800385a:	f001 fd89 	bl	8005370 <sha256_update>
    sha256_update(&ctx, end, 32);
 800385e:	4629      	mov	r1, r5
 8003860:	a803      	add	r0, sp, #12
 8003862:	2220      	movs	r2, #32
 8003864:	f001 fd84 	bl	8005370 <sha256_update>
    sha256_final(&ctx, end);
 8003868:	4629      	mov	r1, r5
 800386a:	a803      	add	r0, sp, #12
 800386c:	f001 fdc6 	bl	80053fc <sha256_final>
 8003870:	e002      	b.n	8003878 <ae_mixin_key+0x70>
    int
ae_mixin_key(uint8_t keynum, const uint8_t start[32], uint8_t end[32])
{
    ASSERT(start != end);           // we can't work inplace

    if(ae_pair_unlock()) return -1;
 8003872:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003876:	e000      	b.n	800387a <ae_mixin_key+0x72>
 8003878:	4620      	mov	r0, r4
    sha256_update(&ctx, &keynum, 1);
    sha256_update(&ctx, end, 32);
    sha256_final(&ctx, end);

    return 0;
}
 800387a:	b016      	add	sp, #88	; 0x58
 800387c:	bd70      	pop	{r4, r5, r6, pc}
 800387e:	bf00      	nop
 8003880:	0800d550 	.word	0x0800d550
 8003884:	0801e000 	.word	0x0801e000

08003888 <delay_ms>:
//
    void
delay_ms(int ms)
{
    // Clear the COUNTFLAG and reset value to zero
    SysTick->VAL = 0;
 8003888:	4b05      	ldr	r3, [pc, #20]	; (80038a0 <delay_ms+0x18>)
 800388a:	2200      	movs	r2, #0
 800388c:	609a      	str	r2, [r3, #8]
    //SysTick->CTRL;  

    // Wait for ticks to happen
    while(ms > 0) {
 800388e:	2800      	cmp	r0, #0
 8003890:	dd05      	ble.n	800389e <delay_ms+0x16>
        if(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) {
 8003892:	681a      	ldr	r2, [r3, #0]
 8003894:	03d2      	lsls	r2, r2, #15
            ms--;
 8003896:	bf48      	it	mi
 8003898:	f100 30ff 	addmi.w	r0, r0, #4294967295	; 0xffffffff
 800389c:	e7f7      	b.n	800388e <delay_ms+0x6>
        }
    }
}
 800389e:	4770      	bx	lr
 80038a0:	e000e010 	.word	0xe000e010

080038a4 <HAL_Delay>:
// Replace HAL version which needs interrupts
//
    void
HAL_Delay(uint32_t Delay)
{
    delay_ms(Delay);
 80038a4:	f7ff bff0 	b.w	8003888 <delay_ms>

080038a8 <gpio_setup>:
    // NOTES:
    // - try not to limit PCB changes for future revs; leave unused unchanged.
    // - oled_setup() uses pins on PA4 thru PA8

    // enable clock to GPIO's ... we will be using them all at some point
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80038a8:	4b3b      	ldr	r3, [pc, #236]	; (8003998 <gpio_setup+0xf0>)
//
// set directions, lock critical ones, etc.
//
    void
gpio_setup(void)
{
 80038aa:	b570      	push	{r4, r5, r6, lr}
    // NOTES:
    // - try not to limit PCB changes for future revs; leave unused unchanged.
    // - oled_setup() uses pins on PA4 thru PA8

    // enable clock to GPIO's ... we will be using them all at some point
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80038ac:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    __HAL_RCC_GPIOC_CLK_ENABLE();
    __HAL_RCC_GPIOD_CLK_ENABLE();
    __HAL_RCC_GPIOE_CLK_ENABLE();

    {   // Onewire bus pins used for ATECC608 comms
        GPIO_InitTypeDef setup = {
 80038ae:	4c3b      	ldr	r4, [pc, #236]	; (800399c <gpio_setup+0xf4>)
    // NOTES:
    // - try not to limit PCB changes for future revs; leave unused unchanged.
    // - oled_setup() uses pins on PA4 thru PA8

    // enable clock to GPIO's ... we will be using them all at some point
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80038b0:	f042 0201 	orr.w	r2, r2, #1
 80038b4:	64da      	str	r2, [r3, #76]	; 0x4c
 80038b6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
//
// set directions, lock critical ones, etc.
//
    void
gpio_setup(void)
{
 80038b8:	b08a      	sub	sp, #40	; 0x28
    // NOTES:
    // - try not to limit PCB changes for future revs; leave unused unchanged.
    // - oled_setup() uses pins on PA4 thru PA8

    // enable clock to GPIO's ... we will be using them all at some point
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80038ba:	f002 0201 	and.w	r2, r2, #1
 80038be:	9200      	str	r2, [sp, #0]
 80038c0:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80038c2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80038c4:	f042 0202 	orr.w	r2, r2, #2
 80038c8:	64da      	str	r2, [r3, #76]	; 0x4c
 80038ca:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80038cc:	f002 0202 	and.w	r2, r2, #2
 80038d0:	9201      	str	r2, [sp, #4]
 80038d2:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80038d4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80038d6:	f042 0204 	orr.w	r2, r2, #4
 80038da:	64da      	str	r2, [r3, #76]	; 0x4c
 80038dc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80038de:	f002 0204 	and.w	r2, r2, #4
 80038e2:	9202      	str	r2, [sp, #8]
 80038e4:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80038e6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80038e8:	f042 0208 	orr.w	r2, r2, #8
 80038ec:	64da      	str	r2, [r3, #76]	; 0x4c
 80038ee:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80038f0:	f002 0208 	and.w	r2, r2, #8
 80038f4:	9203      	str	r2, [sp, #12]
 80038f6:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80038f8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80038fa:	f042 0210 	orr.w	r2, r2, #16
 80038fe:	64da      	str	r2, [r3, #76]	; 0x4c
 8003900:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003902:	f003 0310 	and.w	r3, r3, #16
 8003906:	9304      	str	r3, [sp, #16]
 8003908:	9b04      	ldr	r3, [sp, #16]

    {   // Onewire bus pins used for ATECC608 comms
        GPIO_InitTypeDef setup = {
 800390a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800390c:	ad05      	add	r5, sp, #20
 800390e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8003910:	6823      	ldr	r3, [r4, #0]
 8003912:	602b      	str	r3, [r5, #0]
            .Mode = GPIO_MODE_AF_OD,
            .Pull = GPIO_NOPULL,
            .Speed = GPIO_SPEED_FREQ_MEDIUM,
            .Alternate = GPIO_AF8_UART4,
        };
        HAL_GPIO_Init(ONEWIRE_PORT, &setup);
 8003914:	a905      	add	r1, sp, #20
 8003916:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800391a:	f7fd fb51 	bl	8000fc0 <HAL_GPIO_Init>
    }

    // Bugfix: re-init of console port pins seems to wreck
    // the mpy uart code, so avoid after first time.
    if(USART1->BRR == 0) {
 800391e:	4b20      	ldr	r3, [pc, #128]	; (80039a0 <gpio_setup+0xf8>)
 8003920:	68de      	ldr	r6, [r3, #12]
 8003922:	b9ae      	cbnz	r6, 8003950 <gpio_setup+0xa8>
        // debug console: USART1 = PA9=Tx & PA10=Rx
        GPIO_InitTypeDef setup = {
 8003924:	3404      	adds	r4, #4
 8003926:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8003928:	ad05      	add	r5, sp, #20
 800392a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800392c:	6823      	ldr	r3, [r4, #0]
 800392e:	602b      	str	r3, [r5, #0]
            .Mode = GPIO_MODE_AF_PP,
            .Pull = GPIO_NOPULL,
            .Speed = GPIO_SPEED_FREQ_MEDIUM,
            .Alternate = GPIO_AF7_USART1,
        };
        HAL_GPIO_Init(GPIOA, &setup);
 8003930:	a905      	add	r1, sp, #20
 8003932:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8003936:	f7fd fb43 	bl	8000fc0 <HAL_GPIO_Init>

        setup.Pin = GPIO_PIN_10;
 800393a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800393e:	9305      	str	r3, [sp, #20]
        setup.Mode = GPIO_MODE_INPUT;
        setup.Pull = GPIO_PULLUP;
        HAL_GPIO_Init(GPIOA, &setup);
 8003940:	a905      	add	r1, sp, #20
        };
        HAL_GPIO_Init(GPIOA, &setup);

        setup.Pin = GPIO_PIN_10;
        setup.Mode = GPIO_MODE_INPUT;
        setup.Pull = GPIO_PULLUP;
 8003942:	2301      	movs	r3, #1
        HAL_GPIO_Init(GPIOA, &setup);
 8003944:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
            .Alternate = GPIO_AF7_USART1,
        };
        HAL_GPIO_Init(GPIOA, &setup);

        setup.Pin = GPIO_PIN_10;
        setup.Mode = GPIO_MODE_INPUT;
 8003948:	9606      	str	r6, [sp, #24]
        setup.Pull = GPIO_PULLUP;
 800394a:	9307      	str	r3, [sp, #28]
        HAL_GPIO_Init(GPIOA, &setup);
 800394c:	f7fd fb38 	bl	8000fc0 <HAL_GPIO_Init>
    }

    // SD active LED: PC7
    // USB active LED: PC6
    {   GPIO_InitTypeDef setup = {
 8003950:	2214      	movs	r2, #20
 8003952:	eb0d 0002 	add.w	r0, sp, r2
 8003956:	2100      	movs	r1, #0
 8003958:	f009 fdb5 	bl	800d4c6 <memset>
 800395c:	25c0      	movs	r5, #192	; 0xc0
 800395e:	2401      	movs	r4, #1
            .Pin = GPIO_PIN_7 | GPIO_PIN_6,
            .Mode = GPIO_MODE_OUTPUT_PP,
            .Pull = GPIO_NOPULL,
            .Speed = GPIO_SPEED_FREQ_LOW,
        };
        HAL_GPIO_Init(GPIOC, &setup);
 8003960:	a905      	add	r1, sp, #20
 8003962:	4810      	ldr	r0, [pc, #64]	; (80039a4 <gpio_setup+0xfc>)
        HAL_GPIO_Init(GPIOA, &setup);
    }

    // SD active LED: PC7
    // USB active LED: PC6
    {   GPIO_InitTypeDef setup = {
 8003964:	9505      	str	r5, [sp, #20]
 8003966:	9406      	str	r4, [sp, #24]
            .Pin = GPIO_PIN_7 | GPIO_PIN_6,
            .Mode = GPIO_MODE_OUTPUT_PP,
            .Pull = GPIO_NOPULL,
            .Speed = GPIO_SPEED_FREQ_LOW,
        };
        HAL_GPIO_Init(GPIOC, &setup);
 8003968:	f7fd fb2a 	bl	8000fc0 <HAL_GPIO_Init>

        HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7|GPIO_PIN_6, 0);    // turn LEDs off
 800396c:	4629      	mov	r1, r5
 800396e:	2200      	movs	r2, #0
 8003970:	480c      	ldr	r0, [pc, #48]	; (80039a4 <gpio_setup+0xfc>)
 8003972:	f7fd fca1 	bl	80012b8 <HAL_GPIO_WritePin>
    }

    // SD card detect switch: PC13
    {   GPIO_InitTypeDef setup = {
 8003976:	2214      	movs	r2, #20
 8003978:	eb0d 0002 	add.w	r0, sp, r2
 800397c:	2100      	movs	r1, #0
 800397e:	f009 fda2 	bl	800d4c6 <memset>
 8003982:	f44f 5300 	mov.w	r3, #8192	; 0x2000
            .Pin = GPIO_PIN_13,
            .Mode = GPIO_MODE_INPUT,
            .Pull = GPIO_PULLUP,
            .Speed = GPIO_SPEED_FREQ_LOW,
        };
        HAL_GPIO_Init(GPIOC, &setup);
 8003986:	a905      	add	r1, sp, #20
 8003988:	4806      	ldr	r0, [pc, #24]	; (80039a4 <gpio_setup+0xfc>)

        HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7|GPIO_PIN_6, 0);    // turn LEDs off
    }

    // SD card detect switch: PC13
    {   GPIO_InitTypeDef setup = {
 800398a:	9305      	str	r3, [sp, #20]
 800398c:	9407      	str	r4, [sp, #28]
            .Pin = GPIO_PIN_13,
            .Mode = GPIO_MODE_INPUT,
            .Pull = GPIO_PULLUP,
            .Speed = GPIO_SPEED_FREQ_LOW,
        };
        HAL_GPIO_Init(GPIOC, &setup);
 800398e:	f7fd fb17 	bl	8000fc0 <HAL_GPIO_Init>

    // elsewhere...
    //HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, 1);
    //HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, 0);
#endif
}
 8003992:	b00a      	add	sp, #40	; 0x28
 8003994:	bd70      	pop	{r4, r5, r6, pc}
 8003996:	bf00      	nop
 8003998:	40021000 	.word	0x40021000
 800399c:	0800e44c 	.word	0x0800e44c
 80039a0:	40013800 	.word	0x40013800
 80039a4:	48000800 	.word	0x48000800

080039a8 <_hmac_attempt>:
//
// Maybe should be proper HMAC from fips std? Can be changed later.
//
    static void
_hmac_attempt(const pinAttempt_t *args, uint8_t result[32])
{
 80039a8:	b530      	push	{r4, r5, lr}
 80039aa:	b095      	sub	sp, #84	; 0x54
 80039ac:	4604      	mov	r4, r0
	SHA256_CTX ctx;

    sha256_init(&ctx);
 80039ae:	a801      	add	r0, sp, #4
//
// Maybe should be proper HMAC from fips std? Can be changed later.
//
    static void
_hmac_attempt(const pinAttempt_t *args, uint8_t result[32])
{
 80039b0:	460d      	mov	r5, r1
	SHA256_CTX ctx;

    sha256_init(&ctx);
 80039b2:	f001 fccd 	bl	8005350 <sha256_init>
    sha256_update(&ctx, rom_secrets->pairing_secret, 32);
 80039b6:	2220      	movs	r2, #32
 80039b8:	4911      	ldr	r1, [pc, #68]	; (8003a00 <_hmac_attempt+0x58>)
 80039ba:	a801      	add	r0, sp, #4
 80039bc:	f001 fcd8 	bl	8005370 <sha256_update>
    sha256_update(&ctx, reboot_seed_base, 32);
 80039c0:	2220      	movs	r2, #32
 80039c2:	4910      	ldr	r1, [pc, #64]	; (8003a04 <_hmac_attempt+0x5c>)
 80039c4:	a801      	add	r0, sp, #4
 80039c6:	f001 fcd3 	bl	8005370 <sha256_update>
    sha256_update(&ctx, (uint8_t *)args, offsetof(pinAttempt_t, hmac));
 80039ca:	2244      	movs	r2, #68	; 0x44
 80039cc:	4621      	mov	r1, r4
 80039ce:	a801      	add	r0, sp, #4
 80039d0:	f001 fcce 	bl	8005370 <sha256_update>

    if(args->magic_value == PA_MAGIC_V2) {
 80039d4:	6822      	ldr	r2, [r4, #0]
 80039d6:	4b0c      	ldr	r3, [pc, #48]	; (8003a08 <_hmac_attempt+0x60>)
 80039d8:	429a      	cmp	r2, r3
 80039da:	d105      	bne.n	80039e8 <_hmac_attempt+0x40>
        sha256_update(&ctx, (uint8_t *)args->cached_main_pin,
 80039dc:	2220      	movs	r2, #32
 80039de:	f104 01f8 	add.w	r1, r4, #248	; 0xf8
 80039e2:	a801      	add	r0, sp, #4
 80039e4:	f001 fcc4 	bl	8005370 <sha256_update>
                                msizeof(pinAttempt_t, cached_main_pin));
    }

    sha256_final(&ctx, result);
 80039e8:	4629      	mov	r1, r5
 80039ea:	a801      	add	r0, sp, #4
 80039ec:	f001 fd06 	bl	80053fc <sha256_final>

    // and a second-sha256 on that, just in case.
    sha256_single(result, 32, result);
 80039f0:	462a      	mov	r2, r5
 80039f2:	2120      	movs	r1, #32
 80039f4:	4628      	mov	r0, r5
 80039f6:	f001 fd15 	bl	8005424 <sha256_single>
}
 80039fa:	b015      	add	sp, #84	; 0x54
 80039fc:	bd30      	pop	{r4, r5, pc}
 80039fe:	bf00      	nop
 8003a00:	0801e000 	.word	0x0801e000
 8003a04:	20001c00 	.word	0x20001c00
 8003a08:	2eaf6312 	.word	0x2eaf6312

08003a0c <_validate_attempt>:

// _validate_attempt()
//
    static int
_validate_attempt(const pinAttempt_t *args, bool first_time)
{
 8003a0c:	b510      	push	{r4, lr}
 8003a0e:	4604      	mov	r4, r0
 8003a10:	b088      	sub	sp, #32
    if(first_time) {
 8003a12:	b961      	cbnz	r1, 8003a2e <_validate_attempt+0x22>
        // no hmac needed for setup call
    } else {
        // if hmac is defined, better be right.
        uint8_t     actual[32];

        _hmac_attempt(args, actual);
 8003a14:	4669      	mov	r1, sp
 8003a16:	f7ff ffc7 	bl	80039a8 <_hmac_attempt>

        if(!check_equal(actual, args->hmac, 32)) {
 8003a1a:	2220      	movs	r2, #32
 8003a1c:	f104 0144 	add.w	r1, r4, #68	; 0x44
 8003a20:	4668      	mov	r0, sp
 8003a22:	f7fe fe20 	bl	8002666 <check_equal>
 8003a26:	b910      	cbnz	r0, 8003a2e <_validate_attempt+0x22>
            // hmac is wrong?
            return EPIN_HMAC_FAIL;
 8003a28:	f06f 0063 	mvn.w	r0, #99	; 0x63
 8003a2c:	e021      	b.n	8003a72 <_validate_attempt+0x66>
        }
    }

    // check fields.
    if(args->magic_value == PA_MAGIC_V2) {
 8003a2e:	6822      	ldr	r2, [r4, #0]
 8003a30:	4b11      	ldr	r3, [pc, #68]	; (8003a78 <_validate_attempt+0x6c>)
 8003a32:	429a      	cmp	r2, r3
 8003a34:	d118      	bne.n	8003a68 <_validate_attempt+0x5c>
    } else {
        return EPIN_BAD_MAGIC;
    }

    // check fields
    if(args->pin_len > MAX_PIN_LEN) return EPIN_RANGE_ERR;
 8003a36:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003a38:	2b20      	cmp	r3, #32
 8003a3a:	dc18      	bgt.n	8003a6e <_validate_attempt+0x62>
    if(args->old_pin_len > MAX_PIN_LEN) return EPIN_RANGE_ERR;
 8003a3c:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 8003a40:	2b20      	cmp	r3, #32
 8003a42:	dc14      	bgt.n	8003a6e <_validate_attempt+0x62>
    if(args->new_pin_len > MAX_PIN_LEN) return EPIN_RANGE_ERR;
 8003a44:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 8003a48:	2b20      	cmp	r3, #32
 8003a4a:	dc10      	bgt.n	8003a6e <_validate_attempt+0x62>
    if((args->change_flags & CHANGE__MASK) != args->change_flags) return EPIN_RANGE_ERR;
 8003a4c:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8003a4e:	f640 737f 	movw	r3, #3967	; 0xf7f
 8003a52:	4013      	ands	r3, r2
 8003a54:	429a      	cmp	r2, r3
 8003a56:	d10a      	bne.n	8003a6e <_validate_attempt+0x62>

    if((args->is_secondary & 0x1) != args->is_secondary) return EPIN_RANGE_ERR;
 8003a58:	6863      	ldr	r3, [r4, #4]
 8003a5a:	f033 0301 	bics.w	r3, r3, #1
        
    return 0;
 8003a5e:	bf14      	ite	ne
 8003a60:	f06f 0066 	mvnne.w	r0, #102	; 0x66
 8003a64:	2000      	moveq	r0, #0
 8003a66:	e004      	b.n	8003a72 <_validate_attempt+0x66>

    // check fields.
    if(args->magic_value == PA_MAGIC_V2) {
        // ok
    } else {
        return EPIN_BAD_MAGIC;
 8003a68:	f06f 0065 	mvn.w	r0, #101	; 0x65
 8003a6c:	e001      	b.n	8003a72 <_validate_attempt+0x66>
    }

    // check fields
    if(args->pin_len > MAX_PIN_LEN) return EPIN_RANGE_ERR;
 8003a6e:	f06f 0066 	mvn.w	r0, #102	; 0x66
    if((args->change_flags & CHANGE__MASK) != args->change_flags) return EPIN_RANGE_ERR;

    if((args->is_secondary & 0x1) != args->is_secondary) return EPIN_RANGE_ERR;
        
    return 0;
}
 8003a72:	b008      	add	sp, #32
 8003a74:	bd10      	pop	{r4, pc}
 8003a76:	bf00      	nop
 8003a78:	2eaf6312 	.word	0x2eaf6312

08003a7c <warmup_ae>:

// warmup_ae()
//
    static int
warmup_ae(void)
{
 8003a7c:	b510      	push	{r4, lr}
    ae_setup();
 8003a7e:	f7fe ff8f 	bl	80029a0 <ae_setup>
 8003a82:	2405      	movs	r4, #5

    for(int retry=0; retry<5; retry++) {
        if(!ae_probe()) break;
 8003a84:	f7ff fa12 	bl	8002eac <ae_probe>
 8003a88:	b108      	cbz	r0, 8003a8e <warmup_ae+0x12>
    static int
warmup_ae(void)
{
    ae_setup();

    for(int retry=0; retry<5; retry++) {
 8003a8a:	3c01      	subs	r4, #1
 8003a8c:	d1fa      	bne.n	8003a84 <warmup_ae+0x8>
        if(!ae_probe()) break;
    }

    if(ae_pair_unlock()) return -1;
 8003a8e:	f7ff f987 	bl	8002da0 <ae_pair_unlock>
 8003a92:	4604      	mov	r4, r0
 8003a94:	b910      	cbnz	r0, 8003a9c <warmup_ae+0x20>

    // reset watchdog timer
    ae_keep_alive();
 8003a96:	f7fe ffb7 	bl	8002a08 <ae_keep_alive>

    return 0;
 8003a9a:	e001      	b.n	8003aa0 <warmup_ae+0x24>

    for(int retry=0; retry<5; retry++) {
        if(!ae_probe()) break;
    }

    if(ae_pair_unlock()) return -1;
 8003a9c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff

    // reset watchdog timer
    ae_keep_alive();

    return 0;
}
 8003aa0:	4620      	mov	r0, r4
 8003aa2:	bd10      	pop	{r4, pc}

08003aa4 <_read_slot_as_counter>:

// _read_slot_as_counter()
//
    static int
_read_slot_as_counter(uint8_t slot, uint32_t *dest)
{
 8003aa4:	b530      	push	{r4, r5, lr}
 8003aa6:	b091      	sub	sp, #68	; 0x44
    // Important that this be authenticated.
    //
    // - using first 32-bits only, others will be zero/ignored
    // - but need to read whole thing for the digest check

    uint32_t padded[32/4] = { 0 };
 8003aa8:	2220      	movs	r2, #32

// _read_slot_as_counter()
//
    static int
_read_slot_as_counter(uint8_t slot, uint32_t *dest)
{
 8003aaa:	4604      	mov	r4, r0
 8003aac:	460d      	mov	r5, r1
    // Important that this be authenticated.
    //
    // - using first 32-bits only, others will be zero/ignored
    // - but need to read whole thing for the digest check

    uint32_t padded[32/4] = { 0 };
 8003aae:	4668      	mov	r0, sp
 8003ab0:	2100      	movs	r1, #0
 8003ab2:	f009 fd08 	bl	800d4c6 <memset>
    ae_pair_unlock();
 8003ab6:	f7ff f973 	bl	8002da0 <ae_pair_unlock>
    if(ae_read_data_slot(slot, (uint8_t *)padded, 32)) return -1;
 8003aba:	2220      	movs	r2, #32
 8003abc:	4669      	mov	r1, sp
 8003abe:	4620      	mov	r0, r4
 8003ac0:	f7ff fc86 	bl	80033d0 <ae_read_data_slot>
 8003ac4:	b110      	cbz	r0, 8003acc <_read_slot_as_counter+0x28>
 8003ac6:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 8003aca:	e011      	b.n	8003af0 <_read_slot_as_counter+0x4c>

    uint8_t tempkey[32];
    ae_pair_unlock();
 8003acc:	f7ff f968 	bl	8002da0 <ae_pair_unlock>
    if(ae_gendig_slot(slot, (const uint8_t *)padded, tempkey)) return -1;
 8003ad0:	4620      	mov	r0, r4
 8003ad2:	aa08      	add	r2, sp, #32
 8003ad4:	4669      	mov	r1, sp
 8003ad6:	f7ff fa7d 	bl	8002fd4 <ae_gendig_slot>
 8003ada:	4604      	mov	r4, r0
 8003adc:	2800      	cmp	r0, #0
 8003ade:	d1f2      	bne.n	8003ac6 <_read_slot_as_counter+0x22>

    if(!ae_is_correct_tempkey(tempkey)) fatal_mitm();
 8003ae0:	a808      	add	r0, sp, #32
 8003ae2:	f7ff f88f 	bl	8002c04 <ae_is_correct_tempkey>
 8003ae6:	b908      	cbnz	r0, 8003aec <_read_slot_as_counter+0x48>
 8003ae8:	f7fc ff82 	bl	80009f0 <fatal_mitm>

    *dest = padded[0];
 8003aec:	9b00      	ldr	r3, [sp, #0]
 8003aee:	602b      	str	r3, [r5, #0]

    return 0;
}
 8003af0:	4620      	mov	r0, r4
 8003af2:	b011      	add	sp, #68	; 0x44
 8003af4:	bd30      	pop	{r4, r5, pc}

08003af6 <get_last_success>:
// not really so strong with the 608, since it's all enforced on that side, but
// we'll do it anyway.
//
    static int __attribute__ ((noinline))
get_last_success(pinAttempt_t *args)
{
 8003af6:	b530      	push	{r4, r5, lr}
 8003af8:	b095      	sub	sp, #84	; 0x54
 8003afa:	4604      	mov	r4, r0
    const int slot = KEYNUM_lastgood;

    ae_pair_unlock();
 8003afc:	f7ff f950 	bl	8002da0 <ae_pair_unlock>

    // Read counter value of last-good login. Important that this be authenticated.
    // - using first 32-bits only, others will be zero
    uint32_t padded[32/4] = { 0 };
 8003b00:	2220      	movs	r2, #32
 8003b02:	2100      	movs	r1, #0
 8003b04:	a804      	add	r0, sp, #16
 8003b06:	f009 fcde 	bl	800d4c6 <memset>
    if(ae_read_data_slot(slot, (uint8_t *)padded, 32)) return -1;
 8003b0a:	2220      	movs	r2, #32
 8003b0c:	a904      	add	r1, sp, #16
 8003b0e:	2005      	movs	r0, #5
 8003b10:	f7ff fc5e 	bl	80033d0 <ae_read_data_slot>
 8003b14:	b110      	cbz	r0, 8003b1c <get_last_success+0x26>
 8003b16:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003b1a:	e033      	b.n	8003b84 <get_last_success+0x8e>

    uint8_t tempkey[32];
    ae_pair_unlock();
 8003b1c:	f7ff f940 	bl	8002da0 <ae_pair_unlock>
    if(ae_gendig_slot(slot, (const uint8_t *)padded, tempkey)) return -1;
 8003b20:	aa0c      	add	r2, sp, #48	; 0x30
 8003b22:	a904      	add	r1, sp, #16
 8003b24:	2005      	movs	r0, #5
 8003b26:	f7ff fa55 	bl	8002fd4 <ae_gendig_slot>
 8003b2a:	4605      	mov	r5, r0
 8003b2c:	2800      	cmp	r0, #0
 8003b2e:	d1f2      	bne.n	8003b16 <get_last_success+0x20>

    if(!ae_is_correct_tempkey(tempkey)) fatal_mitm();
 8003b30:	a80c      	add	r0, sp, #48	; 0x30
 8003b32:	f7ff f867 	bl	8002c04 <ae_is_correct_tempkey>
 8003b36:	b908      	cbnz	r0, 8003b3c <get_last_success+0x46>
 8003b38:	f7fc ff5a 	bl	80009f0 <fatal_mitm>

    // Read two values from data slots
    uint32_t lastgood=0, match_count=0, counter=0;
    if(_read_slot_as_counter(KEYNUM_lastgood, &lastgood)) return -1;
 8003b3c:	a901      	add	r1, sp, #4
 8003b3e:	2005      	movs	r0, #5
    if(ae_gendig_slot(slot, (const uint8_t *)padded, tempkey)) return -1;

    if(!ae_is_correct_tempkey(tempkey)) fatal_mitm();

    // Read two values from data slots
    uint32_t lastgood=0, match_count=0, counter=0;
 8003b40:	9501      	str	r5, [sp, #4]
 8003b42:	9502      	str	r5, [sp, #8]
 8003b44:	9503      	str	r5, [sp, #12]
    if(_read_slot_as_counter(KEYNUM_lastgood, &lastgood)) return -1;
 8003b46:	f7ff ffad 	bl	8003aa4 <_read_slot_as_counter>
 8003b4a:	2800      	cmp	r0, #0
 8003b4c:	d1e3      	bne.n	8003b16 <get_last_success+0x20>
    if(_read_slot_as_counter(KEYNUM_match_count, &match_count)) return -1;
 8003b4e:	a902      	add	r1, sp, #8
 8003b50:	2006      	movs	r0, #6
 8003b52:	f7ff ffa7 	bl	8003aa4 <_read_slot_as_counter>
 8003b56:	4601      	mov	r1, r0
 8003b58:	2800      	cmp	r0, #0
 8003b5a:	d1dc      	bne.n	8003b16 <get_last_success+0x20>

    // Read the monotonically-increasing counter
    if(ae_get_counter(&counter, 0)) return -1;
 8003b5c:	a803      	add	r0, sp, #12
 8003b5e:	f7ff faf4 	bl	800314a <ae_get_counter>
 8003b62:	2800      	cmp	r0, #0
 8003b64:	d1d7      	bne.n	8003b16 <get_last_success+0x20>

    if(lastgood > counter) {
 8003b66:	9b01      	ldr	r3, [sp, #4]
 8003b68:	9a03      	ldr	r2, [sp, #12]
 8003b6a:	4293      	cmp	r3, r2
        // monkey business, but impossible, right?!
        args->num_fails = 99;
 8003b6c:	bf8c      	ite	hi
 8003b6e:	2363      	movhi	r3, #99	; 0x63
    } else {
        args->num_fails = counter - lastgood;
 8003b70:	1ad3      	subls	r3, r2, r3
 8003b72:	6363      	str	r3, [r4, #52]	; 0x34
    }

    // NOTE: 5LSB of match_count should be stored as zero.
    match_count &= ~31;
 8003b74:	9b02      	ldr	r3, [sp, #8]
 8003b76:	f023 031f 	bic.w	r3, r3, #31
    if(counter < match_count) {
 8003b7a:	429a      	cmp	r2, r3
        // typical case: some number of attempts left before death
        args->attempts_left = match_count - counter;
 8003b7c:	bf34      	ite	cc
 8003b7e:	1a9b      	subcc	r3, r3, r2
    } else if(counter >= match_count) {
        // we're a brick now, but maybe say that nicer to customer
        args->attempts_left = 0;
 8003b80:	2300      	movcs	r3, #0
 8003b82:	63a3      	str	r3, [r4, #56]	; 0x38
    }

    return 0;
}
 8003b84:	b015      	add	sp, #84	; 0x54
 8003b86:	bd30      	pop	{r4, r5, pc}

08003b88 <updates_for_good_login>:

// updates_for_good_login()
//
    static int
updates_for_good_login(uint8_t digest[32])
{
 8003b88:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003b8a:	b08d      	sub	sp, #52	; 0x34
    // User got the main PIN right: update the attempt counters,
    // to document this (lastgood) and also bump the match counter if needed

    uint32_t count;
    int rv = ae_get_counter(&count, 0);
 8003b8c:	2100      	movs	r1, #0

// updates_for_good_login()
//
    static int
updates_for_good_login(uint8_t digest[32])
{
 8003b8e:	4606      	mov	r6, r0
    // User got the main PIN right: update the attempt counters,
    // to document this (lastgood) and also bump the match counter if needed

    uint32_t count;
    int rv = ae_get_counter(&count, 0);
 8003b90:	a802      	add	r0, sp, #8
 8003b92:	f7ff fada 	bl	800314a <ae_get_counter>
    if(rv) goto fail;
 8003b96:	4601      	mov	r1, r0
 8003b98:	2800      	cmp	r0, #0
 8003b9a:	d13c      	bne.n	8003c16 <updates_for_good_login+0x8e>

    // Challenge: Have to update both the counter, and the target match value because
    // no other way to have exact value.

    uint32_t mc = (count + MAX_TARGET_ATTEMPTS + 32) & ~31;
 8003b9c:	9b02      	ldr	r3, [sp, #8]
 8003b9e:	f103 042d 	add.w	r4, r3, #45	; 0x2d
 8003ba2:	f024 041f 	bic.w	r4, r4, #31
    ASSERT(mc >= count);
 8003ba6:	42a3      	cmp	r3, r4
 8003ba8:	d902      	bls.n	8003bb0 <updates_for_good_login+0x28>
 8003baa:	481e      	ldr	r0, [pc, #120]	; (8003c24 <updates_for_good_login+0x9c>)
 8003bac:	f7fc ff16 	bl	80009dc <fatal_error>

    int bump = (mc - MAX_TARGET_ATTEMPTS) - count;
 8003bb0:	f06f 050c 	mvn.w	r5, #12
 8003bb4:	1aed      	subs	r5, r5, r3
 8003bb6:	4425      	add	r5, r4
    ASSERT(bump >= 1);
 8003bb8:	1e6b      	subs	r3, r5, #1
 8003bba:	2b1f      	cmp	r3, #31
 8003bbc:	d8f5      	bhi.n	8003baa <updates_for_good_login+0x22>
    // Would rather update the counter first, so that a hostile interruption can't increase
    // attempts (altho the attacker knows the pin at that point?!) .. but chip won't
    // let the counter go past the match value, so that has to be first.

    // set the new "match count"
    {   uint32_t    tmp[32/4] = {mc, mc} ;
 8003bbe:	2720      	movs	r7, #32
 8003bc0:	463a      	mov	r2, r7
 8003bc2:	a804      	add	r0, sp, #16
 8003bc4:	f009 fc7f 	bl	800d4c6 <memset>
        rv = ae_encrypted_write(KEYNUM_match_count, KEYNUM_main_pin, digest, (void *)tmp, 32);
 8003bc8:	2103      	movs	r1, #3
 8003bca:	9700      	str	r7, [sp, #0]
 8003bcc:	ab04      	add	r3, sp, #16
 8003bce:	4632      	mov	r2, r6
 8003bd0:	2006      	movs	r0, #6
    // Would rather update the counter first, so that a hostile interruption can't increase
    // attempts (altho the attacker knows the pin at that point?!) .. but chip won't
    // let the counter go past the match value, so that has to be first.

    // set the new "match count"
    {   uint32_t    tmp[32/4] = {mc, mc} ;
 8003bd2:	9404      	str	r4, [sp, #16]
 8003bd4:	9405      	str	r4, [sp, #20]
        rv = ae_encrypted_write(KEYNUM_match_count, KEYNUM_main_pin, digest, (void *)tmp, 32);
 8003bd6:	f7ff fbc9 	bl	800336c <ae_encrypted_write>
        if(rv) goto fail;
 8003bda:	4601      	mov	r1, r0
 8003bdc:	b9d8      	cbnz	r0, 8003c16 <updates_for_good_login+0x8e>
    }

    // incr the counter a bunch to get to that-13
    uint32_t new_count = 0;
 8003bde:	a80c      	add	r0, sp, #48	; 0x30
    rv = ae_add_counter(&new_count, 0, bump);
 8003be0:	462a      	mov	r2, r5
        rv = ae_encrypted_write(KEYNUM_match_count, KEYNUM_main_pin, digest, (void *)tmp, 32);
        if(rv) goto fail;
    }

    // incr the counter a bunch to get to that-13
    uint32_t new_count = 0;
 8003be2:	f840 1d24 	str.w	r1, [r0, #-36]!
    rv = ae_add_counter(&new_count, 0, bump);
 8003be6:	f7ff face 	bl	8003186 <ae_add_counter>
    if(rv) goto fail;
 8003bea:	4601      	mov	r1, r0
 8003bec:	b998      	cbnz	r0, 8003c16 <updates_for_good_login+0x8e>

    ASSERT(new_count == count + bump);
 8003bee:	9b02      	ldr	r3, [sp, #8]
 8003bf0:	441d      	add	r5, r3
 8003bf2:	9b03      	ldr	r3, [sp, #12]
 8003bf4:	429d      	cmp	r5, r3
 8003bf6:	d1d8      	bne.n	8003baa <updates_for_good_login+0x22>
    ASSERT(mc > new_count);
 8003bf8:	42ac      	cmp	r4, r5
 8003bfa:	d9d6      	bls.n	8003baa <updates_for_good_login+0x22>

    // Update the "last good" counter
    {   uint32_t    tmp[32/4] = {new_count, 0 };
 8003bfc:	463a      	mov	r2, r7
 8003bfe:	a804      	add	r0, sp, #16
 8003c00:	f009 fc61 	bl	800d4c6 <memset>
        rv = ae_encrypted_write(KEYNUM_lastgood, KEYNUM_main_pin, digest, (void *)tmp, 32);
 8003c04:	9700      	str	r7, [sp, #0]
 8003c06:	ab04      	add	r3, sp, #16
 8003c08:	4632      	mov	r2, r6
 8003c0a:	2103      	movs	r1, #3
 8003c0c:	2005      	movs	r0, #5

    ASSERT(new_count == count + bump);
    ASSERT(mc > new_count);

    // Update the "last good" counter
    {   uint32_t    tmp[32/4] = {new_count, 0 };
 8003c0e:	9504      	str	r5, [sp, #16]
        rv = ae_encrypted_write(KEYNUM_lastgood, KEYNUM_main_pin, digest, (void *)tmp, 32);
 8003c10:	f7ff fbac 	bl	800336c <ae_encrypted_write>
        if(rv) goto fail;
 8003c14:	b118      	cbz	r0, 8003c1e <updates_for_good_login+0x96>
    // just be reducing attempts.

    return 0;

fail:
    ae_reset_chip();
 8003c16:	f7fe feb5 	bl	8002984 <ae_reset_chip>
    return EPIN_AE_FAIL;
 8003c1a:	f06f 0069 	mvn.w	r0, #105	; 0x69
}
 8003c1e:	b00d      	add	sp, #52	; 0x34
 8003c20:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003c22:	bf00      	nop
 8003c24:	0800d550 	.word	0x0800d550

08003c28 <pin_hash>:
//
// Hash up a string of digits into 32-bytes of goodness.
//
    static void
pin_hash(const char *pin, int pin_len, uint8_t result[32], uint32_t purpose)
{
 8003c28:	b570      	push	{r4, r5, r6, lr}
 8003c2a:	b096      	sub	sp, #88	; 0x58
    ASSERT(pin_len <= MAX_PIN_LEN);
 8003c2c:	2920      	cmp	r1, #32
//
// Hash up a string of digits into 32-bytes of goodness.
//
    static void
pin_hash(const char *pin, int pin_len, uint8_t result[32], uint32_t purpose)
{
 8003c2e:	4606      	mov	r6, r0
 8003c30:	460d      	mov	r5, r1
 8003c32:	4614      	mov	r4, r2
 8003c34:	9301      	str	r3, [sp, #4]
    ASSERT(pin_len <= MAX_PIN_LEN);
 8003c36:	dd02      	ble.n	8003c3e <pin_hash+0x16>
 8003c38:	4815      	ldr	r0, [pc, #84]	; (8003c90 <pin_hash+0x68>)
 8003c3a:	f7fc fecf 	bl	80009dc <fatal_error>

    if(pin_len == 0) {
 8003c3e:	b921      	cbnz	r1, 8003c4a <pin_hash+0x22>
        // zero-length PIN is considered the "blank" one: all zero
        memset(result, 0, 32);
 8003c40:	2220      	movs	r2, #32
 8003c42:	4620      	mov	r0, r4
 8003c44:	f009 fc3f 	bl	800d4c6 <memset>
 8003c48:	e020      	b.n	8003c8c <pin_hash+0x64>

        return;
    }

	SHA256_CTX ctx;
    sha256_init(&ctx);
 8003c4a:	a803      	add	r0, sp, #12
 8003c4c:	f001 fb80 	bl	8005350 <sha256_init>

    sha256_update(&ctx, rom_secrets->pairing_secret, 32);
 8003c50:	2220      	movs	r2, #32
 8003c52:	4910      	ldr	r1, [pc, #64]	; (8003c94 <pin_hash+0x6c>)
 8003c54:	a803      	add	r0, sp, #12
 8003c56:	f001 fb8b 	bl	8005370 <sha256_update>
    sha256_update(&ctx, (uint8_t *)&purpose, 4);
 8003c5a:	2204      	movs	r2, #4
 8003c5c:	eb0d 0102 	add.w	r1, sp, r2
 8003c60:	a803      	add	r0, sp, #12
 8003c62:	f001 fb85 	bl	8005370 <sha256_update>
    sha256_update(&ctx, (uint8_t *)pin, pin_len);
 8003c66:	462a      	mov	r2, r5
 8003c68:	4631      	mov	r1, r6
 8003c6a:	a803      	add	r0, sp, #12
 8003c6c:	f001 fb80 	bl	8005370 <sha256_update>
    sha256_update(&ctx, rom_secrets->pairing_secret, 32);
 8003c70:	2220      	movs	r2, #32
 8003c72:	4908      	ldr	r1, [pc, #32]	; (8003c94 <pin_hash+0x6c>)
 8003c74:	a803      	add	r0, sp, #12
 8003c76:	f001 fb7b 	bl	8005370 <sha256_update>

    sha256_final(&ctx, result);
 8003c7a:	4621      	mov	r1, r4
 8003c7c:	a803      	add	r0, sp, #12
 8003c7e:	f001 fbbd 	bl	80053fc <sha256_final>

    // and a second-sha256 on that, just in case.
    sha256_single(result, 32, result);
 8003c82:	4622      	mov	r2, r4
 8003c84:	2120      	movs	r1, #32
 8003c86:	4620      	mov	r0, r4
 8003c88:	f001 fbcc 	bl	8005424 <sha256_single>
}
 8003c8c:	b016      	add	sp, #88	; 0x58
 8003c8e:	bd70      	pop	{r4, r5, r6, pc}
 8003c90:	0800d550 	.word	0x0800d550
 8003c94:	0801e000 	.word	0x0801e000

08003c98 <pin_hash_attempt>:
//
// - call with target_kn == 0 to return a mid-state that can be used for both main and duress
//
    static int
pin_hash_attempt(const char *pin, int pin_len, uint8_t result[32])
{
 8003c98:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003c9a:	4617      	mov	r7, r2
 8003c9c:	b089      	sub	sp, #36	; 0x24
    uint8_t tmp[32]; 

    if(pin_len == 0) {
 8003c9e:	460c      	mov	r4, r1
 8003ca0:	b929      	cbnz	r1, 8003cae <pin_hash_attempt+0x16>
        // zero len PIN is the "blank" value: all zeros, no hashing
        memset(result, 0, 32);
 8003ca2:	2220      	movs	r2, #32
 8003ca4:	4638      	mov	r0, r7
 8003ca6:	f009 fc0e 	bl	800d4c6 <memset>
 8003caa:	4620      	mov	r0, r4
 8003cac:	e01b      	b.n	8003ce6 <pin_hash_attempt+0x4e>

        return 0;
    }

    // quick local hashing
    pin_hash(pin, pin_len, tmp, PIN_PURPOSE_NORMAL);
 8003cae:	4b0f      	ldr	r3, [pc, #60]	; (8003cec <pin_hash_attempt+0x54>)
 8003cb0:	466a      	mov	r2, sp
 8003cb2:	f7ff ffb9 	bl	8003c28 <pin_hash>

    // do mega hashing
    int rv = ae_stretch_iter(tmp, result, KDF_ITER_PIN);
 8003cb6:	2208      	movs	r2, #8
 8003cb8:	4639      	mov	r1, r7
 8003cba:	4668      	mov	r0, sp
 8003cbc:	f7ff fd7e 	bl	80037bc <ae_stretch_iter>
    if(rv) return EPIN_AE_FAIL;
 8003cc0:	4606      	mov	r6, r0
 8003cc2:	b970      	cbnz	r0, 8003ce2 <pin_hash_attempt+0x4a>

    // CAUTION: at this point, we just read the value off the bus
    // in clear text. Don't use that value directly.
    memcpy(tmp, result, 32);
 8003cc4:	463d      	mov	r5, r7
 8003cc6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8003cc8:	466c      	mov	r4, sp
 8003cca:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8003ccc:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8003cd0:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    ae_mixin_key(KEYNUM_pin_attempt, tmp, result);
 8003cd4:	463a      	mov	r2, r7
 8003cd6:	4669      	mov	r1, sp
 8003cd8:	2004      	movs	r0, #4
 8003cda:	f7ff fd95 	bl	8003808 <ae_mixin_key>

    return 0;
 8003cde:	4630      	mov	r0, r6
 8003ce0:	e001      	b.n	8003ce6 <pin_hash_attempt+0x4e>
    // quick local hashing
    pin_hash(pin, pin_len, tmp, PIN_PURPOSE_NORMAL);

    // do mega hashing
    int rv = ae_stretch_iter(tmp, result, KDF_ITER_PIN);
    if(rv) return EPIN_AE_FAIL;
 8003ce2:	f06f 0069 	mvn.w	r0, #105	; 0x69
    // in clear text. Don't use that value directly.
    memcpy(tmp, result, 32);
    ae_mixin_key(KEYNUM_pin_attempt, tmp, result);

    return 0;
}
 8003ce6:	b009      	add	sp, #36	; 0x24
 8003ce8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003cea:	bf00      	nop
 8003cec:	334d1858 	.word	0x334d1858

08003cf0 <pin_cache_get_key>:

// pin_cache_get_key()
//
    void
pin_cache_get_key(uint8_t key[32])
{
 8003cf0:	b510      	push	{r4, lr}
 8003cf2:	b094      	sub	sp, #80	; 0x50
 8003cf4:	4604      	mov	r4, r0
    // per-boot unique key.
	SHA256_CTX ctx;

    sha256_init(&ctx);
 8003cf6:	a801      	add	r0, sp, #4
 8003cf8:	f001 fb2a 	bl	8005350 <sha256_init>
    sha256_update(&ctx, reboot_seed_base, 32);
 8003cfc:	a801      	add	r0, sp, #4
 8003cfe:	2220      	movs	r2, #32
 8003d00:	4906      	ldr	r1, [pc, #24]	; (8003d1c <pin_cache_get_key+0x2c>)
 8003d02:	f001 fb35 	bl	8005370 <sha256_update>
    sha256_update(&ctx, rom_secrets->hash_cache_secret, 32);
 8003d06:	2220      	movs	r2, #32
 8003d08:	a801      	add	r0, sp, #4
 8003d0a:	4905      	ldr	r1, [pc, #20]	; (8003d20 <pin_cache_get_key+0x30>)
 8003d0c:	f001 fb30 	bl	8005370 <sha256_update>

    sha256_final(&ctx, key);
 8003d10:	4621      	mov	r1, r4
 8003d12:	a801      	add	r0, sp, #4
 8003d14:	f001 fb72 	bl	80053fc <sha256_final>
}
 8003d18:	b014      	add	sp, #80	; 0x50
 8003d1a:	bd10      	pop	{r4, pc}
 8003d1c:	20001c00 	.word	0x20001c00
 8003d20:	0801e070 	.word	0x0801e070

08003d24 <pin_cache_save>:

// pin_cache_save()
//
    static void
pin_cache_save(pinAttempt_t *args, const uint8_t digest[32])
{
 8003d24:	b530      	push	{r4, r5, lr}
 8003d26:	460d      	mov	r5, r1
 8003d28:	b089      	sub	sp, #36	; 0x24
 8003d2a:	4604      	mov	r4, r0
    // encrypt w/ rom secret + SRAM seed value
    uint8_t     value[32];

    if(!check_all_zeros(digest, 32)) {
 8003d2c:	2120      	movs	r1, #32
 8003d2e:	4628      	mov	r0, r5
 8003d30:	f7fe fc8a 	bl	8002648 <check_all_zeros>
 8003d34:	b978      	cbnz	r0, 8003d56 <pin_cache_save+0x32>
        pin_cache_get_key(value);
 8003d36:	4668      	mov	r0, sp
 8003d38:	f7ff ffda 	bl	8003cf0 <pin_cache_get_key>
 8003d3c:	1e6b      	subs	r3, r5, #1
 8003d3e:	f10d 32ff 	add.w	r2, sp, #4294967295	; 0xffffffff
 8003d42:	351f      	adds	r5, #31
		*(acc) ^= *(more);
 8003d44:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 8003d48:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 8003d4c:	4041      	eors	r1, r0
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 8003d4e:	42ab      	cmp	r3, r5
		*(acc) ^= *(more);
 8003d50:	7011      	strb	r1, [r2, #0]
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 8003d52:	d1f7      	bne.n	8003d44 <pin_cache_save+0x20>
 8003d54:	e004      	b.n	8003d60 <pin_cache_save+0x3c>
        xor_mixin(value, digest, 32);
    } else {
        memset(value, 0, 32);
 8003d56:	2220      	movs	r2, #32
 8003d58:	2100      	movs	r1, #0
 8003d5a:	4668      	mov	r0, sp
 8003d5c:	f009 fbb3 	bl	800d4c6 <memset>
    }

    ASSERT(args->magic_value == PA_MAGIC_V2);
 8003d60:	6822      	ldr	r2, [r4, #0]
 8003d62:	4b0a      	ldr	r3, [pc, #40]	; (8003d8c <pin_cache_save+0x68>)
 8003d64:	429a      	cmp	r2, r3
 8003d66:	d002      	beq.n	8003d6e <pin_cache_save+0x4a>
 8003d68:	4809      	ldr	r0, [pc, #36]	; (8003d90 <pin_cache_save+0x6c>)
 8003d6a:	f7fc fe37 	bl	80009dc <fatal_error>
    memcpy(args->cached_main_pin, value, 32);
 8003d6e:	466a      	mov	r2, sp
 8003d70:	f104 03f8 	add.w	r3, r4, #248	; 0xf8
 8003d74:	ad08      	add	r5, sp, #32
 8003d76:	4614      	mov	r4, r2
 8003d78:	cc03      	ldmia	r4!, {r0, r1}
 8003d7a:	42ac      	cmp	r4, r5
 8003d7c:	6018      	str	r0, [r3, #0]
 8003d7e:	6059      	str	r1, [r3, #4]
 8003d80:	4622      	mov	r2, r4
 8003d82:	f103 0308 	add.w	r3, r3, #8
 8003d86:	d1f6      	bne.n	8003d76 <pin_cache_save+0x52>
}
 8003d88:	b009      	add	sp, #36	; 0x24
 8003d8a:	bd30      	pop	{r4, r5, pc}
 8003d8c:	2eaf6312 	.word	0x2eaf6312
 8003d90:	0800d550 	.word	0x0800d550

08003d94 <pin_cache_restore>:

// pin_cache_restore()
//
    static void
pin_cache_restore(const pinAttempt_t *args, uint8_t digest[32])
{
 8003d94:	b570      	push	{r4, r5, r6, lr}
    // decrypt w/ rom secret + SRAM seed value

    ASSERT(args->magic_value == PA_MAGIC_V2);
 8003d96:	6802      	ldr	r2, [r0, #0]
 8003d98:	4b14      	ldr	r3, [pc, #80]	; (8003dec <pin_cache_restore+0x58>)
 8003d9a:	429a      	cmp	r2, r3

// pin_cache_restore()
//
    static void
pin_cache_restore(const pinAttempt_t *args, uint8_t digest[32])
{
 8003d9c:	b088      	sub	sp, #32
 8003d9e:	460d      	mov	r5, r1
    // decrypt w/ rom secret + SRAM seed value

    ASSERT(args->magic_value == PA_MAGIC_V2);
 8003da0:	d002      	beq.n	8003da8 <pin_cache_restore+0x14>
 8003da2:	4813      	ldr	r0, [pc, #76]	; (8003df0 <pin_cache_restore+0x5c>)
 8003da4:	f7fc fe1a 	bl	80009dc <fatal_error>
    memcpy(digest, args->cached_main_pin, 32);
 8003da8:	f100 02f8 	add.w	r2, r0, #248	; 0xf8
 8003dac:	460e      	mov	r6, r1
 8003dae:	f500 738c 	add.w	r3, r0, #280	; 0x118
 8003db2:	6810      	ldr	r0, [r2, #0]
 8003db4:	6851      	ldr	r1, [r2, #4]
 8003db6:	4634      	mov	r4, r6
 8003db8:	c403      	stmia	r4!, {r0, r1}
 8003dba:	3208      	adds	r2, #8
 8003dbc:	429a      	cmp	r2, r3
 8003dbe:	4626      	mov	r6, r4
 8003dc0:	d1f7      	bne.n	8003db2 <pin_cache_restore+0x1e>

    if(!check_all_zeros(digest, 32)) {
 8003dc2:	2120      	movs	r1, #32
 8003dc4:	4628      	mov	r0, r5
 8003dc6:	f7fe fc3f 	bl	8002648 <check_all_zeros>
 8003dca:	4604      	mov	r4, r0
 8003dcc:	b960      	cbnz	r0, 8003de8 <pin_cache_restore+0x54>
        uint8_t     key[32];
        pin_cache_get_key(key);
 8003dce:	4668      	mov	r0, sp
 8003dd0:	f7ff ff8e 	bl	8003cf0 <pin_cache_get_key>
 8003dd4:	4620      	mov	r0, r4
		*(acc) ^= *(more);
 8003dd6:	782a      	ldrb	r2, [r5, #0]
 8003dd8:	f81d 3000 	ldrb.w	r3, [sp, r0]
 8003ddc:	3001      	adds	r0, #1
 8003dde:	4053      	eors	r3, r2
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 8003de0:	2820      	cmp	r0, #32
		*(acc) ^= *(more);
 8003de2:	f805 3b01 	strb.w	r3, [r5], #1
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 8003de6:	d1f6      	bne.n	8003dd6 <pin_cache_restore+0x42>

        xor_mixin(digest, key, 32);
    }
}
 8003de8:	b008      	add	sp, #32
 8003dea:	bd70      	pop	{r4, r5, r6, pc}
 8003dec:	2eaf6312 	.word	0x2eaf6312
 8003df0:	0800d550 	.word	0x0800d550

08003df4 <pin_prefix_words>:
// - rate-limited by the chip, since it takes many iterations of HMAC(key we dont have)
// - hash generated is shown on bus (but further hashing happens after that)
//
    int
pin_prefix_words(const char *pin_prefix, int prefix_len, uint32_t *result)
{
 8003df4:	b530      	push	{r4, r5, lr}
 8003df6:	b091      	sub	sp, #68	; 0x44
    uint8_t     tmp[32];
    uint8_t     digest[32];

    // hash it up, a little
    pin_hash(pin_prefix, prefix_len, tmp, PIN_PURPOSE_WORDS);
 8003df8:	4b0b      	ldr	r3, [pc, #44]	; (8003e28 <pin_prefix_words+0x34>)
// - rate-limited by the chip, since it takes many iterations of HMAC(key we dont have)
// - hash generated is shown on bus (but further hashing happens after that)
//
    int
pin_prefix_words(const char *pin_prefix, int prefix_len, uint32_t *result)
{
 8003dfa:	4615      	mov	r5, r2
    uint8_t     tmp[32];
    uint8_t     digest[32];

    // hash it up, a little
    pin_hash(pin_prefix, prefix_len, tmp, PIN_PURPOSE_WORDS);
 8003dfc:	466a      	mov	r2, sp
 8003dfe:	f7ff ff13 	bl	8003c28 <pin_hash>

    // Using 608a, we can do key stretching to get good built-in delays
    ae_setup();
 8003e02:	f7fe fdcd 	bl	80029a0 <ae_setup>

    int rv = ae_stretch_iter(tmp, digest, KDF_ITER_WORDS);
 8003e06:	220c      	movs	r2, #12
 8003e08:	a908      	add	r1, sp, #32
 8003e0a:	4668      	mov	r0, sp
 8003e0c:	f7ff fcd6 	bl	80037bc <ae_stretch_iter>
 8003e10:	4604      	mov	r4, r0

    ae_reset_chip();
 8003e12:	f7fe fdb7 	bl	8002984 <ae_reset_chip>
	if(rv) return -1;
 8003e16:	b91c      	cbnz	r4, 8003e20 <pin_prefix_words+0x2c>

    // take just 32 bits of that (only 22 bits shown to user)
    memcpy(result, digest, 4);
 8003e18:	9808      	ldr	r0, [sp, #32]
 8003e1a:	6028      	str	r0, [r5, #0]

    return 0;
 8003e1c:	4620      	mov	r0, r4
 8003e1e:	e001      	b.n	8003e24 <pin_prefix_words+0x30>
    ae_setup();

    int rv = ae_stretch_iter(tmp, digest, KDF_ITER_WORDS);

    ae_reset_chip();
	if(rv) return -1;
 8003e20:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff

    // take just 32 bits of that (only 22 bits shown to user)
    memcpy(result, digest, 4);

    return 0;
}
 8003e24:	b011      	add	sp, #68	; 0x44
 8003e26:	bd30      	pop	{r4, r5, pc}
 8003e28:	2e6d6773 	.word	0x2e6d6773

08003e2c <calc_delay_required>:
calc_delay_required(int num_fails)
{
    // With the 608a, we let the slow KDF and the auto counter incr
    // protect against rate limiting... no need to do our own.
    return 0;
}
 8003e2c:	2000      	movs	r0, #0
 8003e2e:	4770      	bx	lr

08003e30 <pin_setup_attempt>:
// Get number of failed attempts on a PIN, since last success. Calculate
// required delay, and setup initial struct for later attempts.
//
    int
pin_setup_attempt(pinAttempt_t *args)
{
 8003e30:	b5f0      	push	{r4, r5, r6, r7, lr}
    STATIC_ASSERT(sizeof(pinAttempt_t) == PIN_ATTEMPT_SIZE_V2);

    int rv = _validate_attempt(args, true);
 8003e32:	2101      	movs	r1, #1
// Get number of failed attempts on a PIN, since last success. Calculate
// required delay, and setup initial struct for later attempts.
//
    int
pin_setup_attempt(pinAttempt_t *args)
{
 8003e34:	b091      	sub	sp, #68	; 0x44
 8003e36:	4604      	mov	r4, r0
    STATIC_ASSERT(sizeof(pinAttempt_t) == PIN_ATTEMPT_SIZE_V2);

    int rv = _validate_attempt(args, true);
 8003e38:	f7ff fde8 	bl	8003a0c <_validate_attempt>
    if(rv) return rv;
 8003e3c:	2800      	cmp	r0, #0
 8003e3e:	d15a      	bne.n	8003ef6 <pin_setup_attempt+0xc6>

    // NOTE: Can only attempt primary pin. If it happens to
    // match a trick PIN, then perhaps something happens.

    if(args->is_secondary) {
 8003e40:	6867      	ldr	r7, [r4, #4]
 8003e42:	2f00      	cmp	r7, #0
 8003e44:	d159      	bne.n	8003efa <pin_setup_attempt+0xca>

    // wipe most of struct, keep only what we expect and want!
    // - old firmware wrote zero to magic before this point, and so we set it here

    char    pin_copy[MAX_PIN_LEN];
    int     pin_len = args->pin_len;
 8003e46:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    memcpy(pin_copy, args->pin, pin_len);
 8003e48:	f104 0508 	add.w	r5, r4, #8
 8003e4c:	4632      	mov	r2, r6
 8003e4e:	4629      	mov	r1, r5
 8003e50:	4668      	mov	r0, sp
 8003e52:	f009 fb12 	bl	800d47a <memcpy>

    memset(args, 0, PIN_ATTEMPT_SIZE_V2);
 8003e56:	f44f 728c 	mov.w	r2, #280	; 0x118
 8003e5a:	4639      	mov	r1, r7
 8003e5c:	4620      	mov	r0, r4
 8003e5e:	f009 fb32 	bl	800d4c6 <memset>

    args->state_flags = 0;
    args->magic_value = PA_MAGIC_V2;
 8003e62:	4b2a      	ldr	r3, [pc, #168]	; (8003f0c <pin_setup_attempt+0xdc>)
 8003e64:	6023      	str	r3, [r4, #0]
    args->pin_len = pin_len;
    memcpy(args->pin, pin_copy, pin_len);
 8003e66:	4632      	mov	r2, r6
 8003e68:	4669      	mov	r1, sp
    int     pin_len = args->pin_len;
    memcpy(pin_copy, args->pin, pin_len);

    memset(args, 0, PIN_ATTEMPT_SIZE_V2);

    args->state_flags = 0;
 8003e6a:	63e7      	str	r7, [r4, #60]	; 0x3c
    args->magic_value = PA_MAGIC_V2;
    args->pin_len = pin_len;
 8003e6c:	62a6      	str	r6, [r4, #40]	; 0x28
    memcpy(args->pin, pin_copy, pin_len);
 8003e6e:	4628      	mov	r0, r5
 8003e70:	f009 fb03 	bl	800d47a <memcpy>

    // unlock the AE chip
    if(warmup_ae()) {
 8003e74:	f7ff fe02 	bl	8003a7c <warmup_ae>
 8003e78:	2800      	cmp	r0, #0
 8003e7a:	d141      	bne.n	8003f00 <pin_setup_attempt+0xd0>
        return EPIN_I_AM_BRICK;
    }

    // read counters, and calc number of PIN attempts left
    if(get_last_success(args)) {
 8003e7c:	4620      	mov	r0, r4
 8003e7e:	f7ff fe3a 	bl	8003af6 <get_last_success>
 8003e82:	4605      	mov	r5, r0
 8003e84:	b120      	cbz	r0, 8003e90 <pin_setup_attempt+0x60>
        ae_reset_chip();
 8003e86:	f7fe fd7d 	bl	8002984 <ae_reset_chip>

        return EPIN_AE_FAIL;
 8003e8a:	f06f 0569 	mvn.w	r5, #105	; 0x69
 8003e8e:	e039      	b.n	8003f04 <pin_setup_attempt+0xd4>
// Is a specific PIN defined already? Not safe to expose this directly to callers!
//
    static bool
pin_is_blank(uint8_t keynum)
{
    uint8_t blank[32] = {0};
 8003e90:	2220      	movs	r2, #32
 8003e92:	4601      	mov	r1, r0

        return EPIN_AE_FAIL;
    }

    // delays now handled by chip and our KDF process directly
    args->delay_required = 0;
 8003e94:	6320      	str	r0, [r4, #48]	; 0x30
    args->delay_achieved = 0;
 8003e96:	62e0      	str	r0, [r4, #44]	; 0x2c
// Is a specific PIN defined already? Not safe to expose this directly to callers!
//
    static bool
pin_is_blank(uint8_t keynum)
{
    uint8_t blank[32] = {0};
 8003e98:	eb0d 0002 	add.w	r0, sp, r2
 8003e9c:	f009 fb13 	bl	800d4c6 <memset>

    ae_reset_chip();
 8003ea0:	f7fe fd70 	bl	8002984 <ae_reset_chip>
    ae_pair_unlock();
 8003ea4:	f7fe ff7c 	bl	8002da0 <ae_pair_unlock>

    // Passing this check with zeros, means PIN was blank.
    // Failure here means nothing (except not blank).
    int is_blank = (ae_checkmac_hard(keynum, blank) == 0);
 8003ea8:	a908      	add	r1, sp, #32
 8003eaa:	2003      	movs	r0, #3
 8003eac:	f7ff f8e2 	bl	8003074 <ae_checkmac_hard>
 8003eb0:	4606      	mov	r6, r0

    // CAUTION? We've unlocked something maybe, but it's blank, so...
    ae_reset_chip();
 8003eb2:	f7fe fd67 	bl	8002984 <ae_reset_chip>
    // delays now handled by chip and our KDF process directly
    args->delay_required = 0;
    args->delay_achieved = 0;

    // need to know if we are blank/unused device
    if(pin_is_blank(KEYNUM_main_pin)) {
 8003eb6:	b9c6      	cbnz	r6, 8003eea <pin_setup_attempt+0xba>
        args->state_flags |= PA_SUCCESSFUL | PA_IS_BLANK;
 8003eb8:	6be3      	ldr	r3, [r4, #60]	; 0x3c

        // We need to save this 'zero' value because it's encrypted, and/or might be 
        // un-initialized memory. 
        const uint8_t zeros[32] = {0};
 8003eba:	2220      	movs	r2, #32
    args->delay_required = 0;
    args->delay_achieved = 0;

    // need to know if we are blank/unused device
    if(pin_is_blank(KEYNUM_main_pin)) {
        args->state_flags |= PA_SUCCESSFUL | PA_IS_BLANK;
 8003ebc:	f043 0303 	orr.w	r3, r3, #3
 8003ec0:	63e3      	str	r3, [r4, #60]	; 0x3c

        // We need to save this 'zero' value because it's encrypted, and/or might be 
        // un-initialized memory. 
        const uint8_t zeros[32] = {0};
 8003ec2:	eb0d 0002 	add.w	r0, sp, r2
 8003ec6:	4629      	mov	r1, r5
 8003ec8:	f009 fafd 	bl	800d4c6 <memset>
        pin_cache_save(args, zeros);
 8003ecc:	a908      	add	r1, sp, #32
 8003ece:	4620      	mov	r0, r4
 8003ed0:	f7ff ff28 	bl	8003d24 <pin_cache_save>
set_is_trick(pinAttempt_t *args, const trick_slot_t *slot)
{
    // Set and "encrypt" our one flag bit
    bool is_trick_pin = !!slot;

    args->private_state = ((rng_sample() & ~1) | is_trick_pin) ^ rom_secrets->hash_cache_secret[0];
 8003ed4:	f7fe fbd8 	bl	8002688 <rng_sample>
 8003ed8:	4b0d      	ldr	r3, [pc, #52]	; (8003f10 <pin_setup_attempt+0xe0>)
 8003eda:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70

    if(!slot) {
        args->delay_required = 0;
 8003ede:	6325      	str	r5, [r4, #48]	; 0x30
set_is_trick(pinAttempt_t *args, const trick_slot_t *slot)
{
    // Set and "encrypt" our one flag bit
    bool is_trick_pin = !!slot;

    args->private_state = ((rng_sample() & ~1) | is_trick_pin) ^ rom_secrets->hash_cache_secret[0];
 8003ee0:	f020 0001 	bic.w	r0, r0, #1
 8003ee4:	4058      	eors	r0, r3
 8003ee6:	6420      	str	r0, [r4, #64]	; 0x40

    if(!slot) {
        args->delay_required = 0;
        args->delay_achieved = 0;
 8003ee8:	62e5      	str	r5, [r4, #44]	; 0x2c
// Provide our "signature" validating struct contents as coming from us.
//
    static void
_sign_attempt(pinAttempt_t *args)
{
    _hmac_attempt(args, args->hmac);
 8003eea:	f104 0144 	add.w	r1, r4, #68	; 0x44
 8003eee:	4620      	mov	r0, r4
 8003ef0:	f7ff fd5a 	bl	80039a8 <_hmac_attempt>
 8003ef4:	e006      	b.n	8003f04 <pin_setup_attempt+0xd4>
 8003ef6:	4605      	mov	r5, r0
 8003ef8:	e004      	b.n	8003f04 <pin_setup_attempt+0xd4>
    // NOTE: Can only attempt primary pin. If it happens to
    // match a trick PIN, then perhaps something happens.

    if(args->is_secondary) {
        // secondary PIN feature has been removed
        return EPIN_PRIMARY_ONLY;
 8003efa:	f06f 0571 	mvn.w	r5, #113	; 0x71
 8003efe:	e001      	b.n	8003f04 <pin_setup_attempt+0xd4>
    args->pin_len = pin_len;
    memcpy(args->pin, pin_copy, pin_len);

    // unlock the AE chip
    if(warmup_ae()) {
        return EPIN_I_AM_BRICK;
 8003f00:	f06f 0568 	mvn.w	r5, #104	; 0x68
    }

    _sign_attempt(args);

    return 0;
}
 8003f04:	4628      	mov	r0, r5
 8003f06:	b011      	add	sp, #68	; 0x44
 8003f08:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003f0a:	bf00      	nop
 8003f0c:	2eaf6312 	.word	0x2eaf6312
 8003f10:	0801e000 	.word	0x0801e000

08003f14 <pin_delay>:
    int
pin_delay(pinAttempt_t *args)
{
    // not required since Mk2
    return 0;
}
 8003f14:	2000      	movs	r0, #0
 8003f16:	4770      	bx	lr

08003f18 <pin_login_attempt>:
//
// Do the PIN check, and return a value. Or fail.
//
    int
pin_login_attempt(pinAttempt_t *args)
{
 8003f18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    bool deltamode = false;
    char tmp_pin[32];

    int rv = _validate_attempt(args, false);
 8003f1c:	2100      	movs	r1, #0
//
// Do the PIN check, and return a value. Or fail.
//
    int
pin_login_attempt(pinAttempt_t *args)
{
 8003f1e:	f5ad 7d34 	sub.w	sp, sp, #720	; 0x2d0
 8003f22:	4604      	mov	r4, r0
    bool deltamode = false;
    char tmp_pin[32];

    int rv = _validate_attempt(args, false);
 8003f24:	f7ff fd72 	bl	8003a0c <_validate_attempt>
    if(rv) return rv;
 8003f28:	2800      	cmp	r0, #0
 8003f2a:	f040 80df 	bne.w	80040ec <pin_login_attempt+0x1d4>

    if(args->state_flags & PA_SUCCESSFUL) {
 8003f2e:	6be6      	ldr	r6, [r4, #60]	; 0x3c
 8003f30:	f016 0601 	ands.w	r6, r6, #1
 8003f34:	f040 80d5 	bne.w	80040e2 <pin_login_attempt+0x1ca>
    }

    // Mk4: Check SE2 first to see if this is a "trick" pin.
    // - this call may have side-effects, like wiping keys, bricking, etc.
    trick_slot_t    slot;
    bool is_trick = se2_test_trick_pin(args->pin, args->pin_len, &slot, false);
 8003f38:	f104 0708 	add.w	r7, r4, #8
 8003f3c:	4633      	mov	r3, r6
 8003f3e:	aa13      	add	r2, sp, #76	; 0x4c
 8003f40:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8003f42:	4638      	mov	r0, r7
 8003f44:	f003 fee4 	bl	8007d10 <se2_test_trick_pin>
    
    if(is_trick) {
 8003f48:	2800      	cmp	r0, #0
 8003f4a:	f000 808b 	beq.w	8004064 <pin_login_attempt+0x14c>
        // They gave a trick PIN. Implement it.

        // Mark as success
        args->state_flags = PA_SUCCESSFUL;
 8003f4e:	2301      	movs	r3, #1
 8003f50:	63e3      	str	r3, [r4, #60]	; 0x3c
        args->num_fails = 0;
        args->attempts_left = MAX_TARGET_ATTEMPTS;
 8003f52:	230d      	movs	r3, #13
    if(is_trick) {
        // They gave a trick PIN. Implement it.

        // Mark as success
        args->state_flags = PA_SUCCESSFUL;
        args->num_fails = 0;
 8003f54:	6366      	str	r6, [r4, #52]	; 0x34
        args->attempts_left = MAX_TARGET_ATTEMPTS;
 8003f56:	63a3      	str	r3, [r4, #56]	; 0x38

        if(check_all_zeros(slot.xdata, 32) || (slot.tc_flags & TC_WIPE)) {
 8003f58:	2120      	movs	r1, #32
 8003f5a:	a815      	add	r0, sp, #84	; 0x54
 8003f5c:	f7fe fb74 	bl	8002648 <check_all_zeros>
 8003f60:	b918      	cbnz	r0, 8003f6a <pin_login_attempt+0x52>
 8003f62:	f9bd 3050 	ldrsh.w	r3, [sp, #80]	; 0x50
 8003f66:	2b00      	cmp	r3, #0
 8003f68:	da03      	bge.n	8003f72 <pin_login_attempt+0x5a>
            args->state_flags |= PA_ZERO_SECRET;
 8003f6a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8003f6c:	f043 0310 	orr.w	r3, r3, #16
 8003f70:	63e3      	str	r3, [r4, #60]	; 0x3c
set_is_trick(pinAttempt_t *args, const trick_slot_t *slot)
{
    // Set and "encrypt" our one flag bit
    bool is_trick_pin = !!slot;

    args->private_state = ((rng_sample() & ~1) | is_trick_pin) ^ rom_secrets->hash_cache_secret[0];
 8003f72:	f7fe fb89 	bl	8002688 <rng_sample>
 8003f76:	4b5f      	ldr	r3, [pc, #380]	; (80040f4 <pin_login_attempt+0x1dc>)
 8003f78:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70
 8003f7c:	f040 0001 	orr.w	r0, r0, #1
 8003f80:	4058      	eors	r0, r3

    // Hints for other mpy firmware to implement more trick features
    // impt detail: 
    // - duress wallet case, and many others will still read as zero here.
    // - mpy does need to know about TC_DELTA_MODE case, but not direction & amount
    uint16_t masked = (slot->tc_flags & ~TC_HIDDEN_MASK);
 8003f82:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
set_is_trick(pinAttempt_t *args, const trick_slot_t *slot)
{
    // Set and "encrypt" our one flag bit
    bool is_trick_pin = !!slot;

    args->private_state = ((rng_sample() & ~1) | is_trick_pin) ^ rom_secrets->hash_cache_secret[0];
 8003f86:	6420      	str	r0, [r4, #64]	; 0x40
    // Hints for other mpy firmware to implement more trick features
    // impt detail: 
    // - duress wallet case, and many others will still read as zero here.
    // - mpy does need to know about TC_DELTA_MODE case, but not direction & amount
    uint16_t masked = (slot->tc_flags & ~TC_HIDDEN_MASK);
    args->delay_required = masked;
 8003f88:	f3c3 020a 	ubfx	r2, r3, #0, #11
 8003f8c:	6322      	str	r2, [r4, #48]	; 0x30
    args->delay_achieved = (slot->tc_flags & TC_DELTA_MODE) ? 0 : slot->tc_arg;
 8003f8e:	055a      	lsls	r2, r3, #21
 8003f90:	bf58      	it	pl
 8003f92:	f8bd 6052 	ldrhpl.w	r6, [sp, #82]	; 0x52
 8003f96:	62e6      	str	r6, [r4, #44]	; 0x2c
//
    static void
_make_trick_aes_key(const pinAttempt_t *args, uint8_t key[32])
{
    // key is args->private_state (4 bytes) + 28 bytes from hash_cache_secret
    memcpy(key, &args->private_state, sizeof(args->private_state));
 8003f98:	6c20      	ldr	r0, [r4, #64]	; 0x40
    memcpy(key+4, rom_secrets->hash_cache_secret+4, sizeof(rom_secrets->hash_cache_secret)-4);
 8003f9a:	4e57      	ldr	r6, [pc, #348]	; (80040f8 <pin_login_attempt+0x1e0>)
//
    static void
_make_trick_aes_key(const pinAttempt_t *args, uint8_t key[32])
{
    // key is args->private_state (4 bytes) + 28 bytes from hash_cache_secret
    memcpy(key, &args->private_state, sizeof(args->private_state));
 8003f9c:	900b      	str	r0, [sp, #44]	; 0x2c
    memcpy(key+4, rom_secrets->hash_cache_secret+4, sizeof(rom_secrets->hash_cache_secret)-4);
 8003f9e:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8003fa0:	ad0c      	add	r5, sp, #48	; 0x30
 8003fa2:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8003fa4:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 8003fa8:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    uint8_t     key[32];
    _make_trick_aes_key(args, key);

    // capture first 32 bytes of slot info
    AES_CTX ctx;
    aes_init(&ctx);
 8003fac:	a833      	add	r0, sp, #204	; 0xcc
 8003fae:	f004 f90f 	bl	80081d0 <aes_init>
    aes_add(&ctx, (uint8_t *)slot, 32);
    aes_done(&ctx, args->cached_main_pin, 32, key, NULL);
 8003fb2:	f04f 0800 	mov.w	r8, #0
    _make_trick_aes_key(args, key);

    // capture first 32 bytes of slot info
    AES_CTX ctx;
    aes_init(&ctx);
    aes_add(&ctx, (uint8_t *)slot, 32);
 8003fb6:	2220      	movs	r2, #32
 8003fb8:	a913      	add	r1, sp, #76	; 0x4c
 8003fba:	a833      	add	r0, sp, #204	; 0xcc
 8003fbc:	f004 f90e 	bl	80081dc <aes_add>
    aes_done(&ctx, args->cached_main_pin, 32, key, NULL);
 8003fc0:	ab0b      	add	r3, sp, #44	; 0x2c
 8003fc2:	f8cd 8000 	str.w	r8, [sp]
 8003fc6:	2220      	movs	r2, #32
 8003fc8:	f104 01f8 	add.w	r1, r4, #248	; 0xf8
 8003fcc:	a833      	add	r0, sp, #204	; 0xcc
 8003fce:	f004 f91b 	bl	8008208 <aes_done>
        // this encodes one bit, and picks a nonce; also saves hint to mpy if appropriate
        // - encrypts and saves slot# and tc_flags as well for duress wallet cases
        // - but only 32 byte there, so store just the slot number and tc_flags
        set_is_trick(args, &slot);

        if(slot.tc_flags & TC_DELTA_MODE) {
 8003fd2:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
 8003fd6:	055b      	lsls	r3, r3, #21
 8003fd8:	d53d      	bpl.n	8004056 <pin_login_attempt+0x13e>
{
    // Starting with provided on pin as a string, change the last few digits
    // given to be replacement value which gives true pin.
    // - encoding: BCD with 0xf for unchanged
    
    memcpy(tmp_pin, pin, pin_len);
 8003fda:	6aa5      	ldr	r5, [r4, #40]	; 0x28
            // Thug gave wrong PIN, but we are going to let them 
            // past (by calculating correct PIN, up to 4 digits different),
            // and the mpy firmware can do tricky stuff to protect funds
            // even though the private key is known at that point.
            deltamode = true;
            apply_pin_delta(args->pin, args->pin_len, slot.tc_arg, tmp_pin);
 8003fdc:	f8bd 6052 	ldrh.w	r6, [sp, #82]	; 0x52
{
    // Starting with provided on pin as a string, change the last few digits
    // given to be replacement value which gives true pin.
    // - encoding: BCD with 0xf for unchanged
    
    memcpy(tmp_pin, pin, pin_len);
 8003fe0:	ab03      	add	r3, sp, #12
 8003fe2:	462a      	mov	r2, r5
 8003fe4:	4618      	mov	r0, r3
 8003fe6:	4639      	mov	r1, r7
 8003fe8:	f009 fa47 	bl	800d47a <memcpy>
 8003fec:	4603      	mov	r3, r0
    tmp_pin[pin_len] = 0;
 8003fee:	f800 8005 	strb.w	r8, [r0, r5]

    char *p = &tmp_pin[pin_len-1];
 8003ff2:	1e68      	subs	r0, r5, #1
 8003ff4:	4418      	add	r0, r3
 8003ff6:	2204      	movs	r2, #4

    for(int i=0; i<4; i++, p--) {
        if(*p == '-') p--;
 8003ff8:	7803      	ldrb	r3, [r0, #0]
 8003ffa:	2b2d      	cmp	r3, #45	; 0x2d
 8003ffc:	f006 030f 	and.w	r3, r6, #15
 8004000:	bf08      	it	eq
 8004002:	f100 30ff 	addeq.w	r0, r0, #4294967295	; 0xffffffff

        int here = replacement & 0xf;
        replacement >>= 4;

        if((here >= 0) && (here <= 9)) {
 8004006:	2b09      	cmp	r3, #9
            *p = '0' + here; 
 8004008:	bf9c      	itt	ls
 800400a:	3330      	addls	r3, #48	; 0x30
 800400c:	7003      	strbls	r3, [r0, #0]
    memcpy(tmp_pin, pin, pin_len);
    tmp_pin[pin_len] = 0;

    char *p = &tmp_pin[pin_len-1];

    for(int i=0; i<4; i++, p--) {
 800400e:	3a01      	subs	r2, #1
        if(*p == '-') p--;

        int here = replacement & 0xf;
        replacement >>= 4;
 8004010:	ea4f 1616 	mov.w	r6, r6, lsr #4
    memcpy(tmp_pin, pin, pin_len);
    tmp_pin[pin_len] = 0;

    char *p = &tmp_pin[pin_len-1];

    for(int i=0; i<4; i++, p--) {
 8004014:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
 8004018:	d1ee      	bne.n	8003ff8 <pin_login_attempt+0xe0>
        if(slot.tc_flags & TC_DELTA_MODE) {
            // Thug gave wrong PIN, but we are going to let them 
            // past (by calculating correct PIN, up to 4 digits different),
            // and the mpy firmware can do tricky stuff to protect funds
            // even though the private key is known at that point.
            deltamode = true;
 800401a:	2501      	movs	r5, #1
 800401c:	e023      	b.n	8004066 <pin_login_attempt+0x14e>
        if(rv) {
            ae_reset_chip();

            return EPIN_AE_FAIL;
        }
        ae_reset_chip();
 800401e:	f7fe fcb1 	bl	8002984 <ae_reset_chip>

        // if mcu_key empty, then that's also "zero"
        bool mcu_key_valid;
        mcu_key_get(&mcu_key_valid);
 8004022:	f10d 000b 	add.w	r0, sp, #11
 8004026:	f7fe fa07 	bl	8002438 <mcu_key_get>

        // new fresh system comes here comes w/ zeros (plaintext) in secret slot of SE1
        if(check_all_zeros(ts, AE_SECRET_LEN) || !mcu_key_valid) {
 800402a:	4631      	mov	r1, r6
 800402c:	a833      	add	r0, sp, #204	; 0xcc
 800402e:	f7fe fb0b 	bl	8002648 <check_all_zeros>
 8004032:	2800      	cmp	r0, #0
 8004034:	d150      	bne.n	80040d8 <pin_login_attempt+0x1c0>
 8004036:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800403a:	2b00      	cmp	r3, #0
 800403c:	d04c      	beq.n	80040d8 <pin_login_attempt+0x1c0>

    // indicate what features already enabled/non-blank
    //      args->state_flags |= (PA_HAS_DURESS | PA_HAS_BRICKME);
    // - mk3 and earlier set these flags, but that's obsolete now
    // - mk4 requires knowledge of the specific trick PIN to know what it does
    if(!deltamode) {
 800403e:	b955      	cbnz	r5, 8004056 <pin_login_attempt+0x13e>
set_is_trick(pinAttempt_t *args, const trick_slot_t *slot)
{
    // Set and "encrypt" our one flag bit
    bool is_trick_pin = !!slot;

    args->private_state = ((rng_sample() & ~1) | is_trick_pin) ^ rom_secrets->hash_cache_secret[0];
 8004040:	f7fe fb22 	bl	8002688 <rng_sample>
 8004044:	4b2b      	ldr	r3, [pc, #172]	; (80040f4 <pin_login_attempt+0x1dc>)
 8004046:	f893 3070 	ldrb.w	r3, [r3, #112]	; 0x70

    if(!slot) {
        args->delay_required = 0;
 800404a:	6325      	str	r5, [r4, #48]	; 0x30
set_is_trick(pinAttempt_t *args, const trick_slot_t *slot)
{
    // Set and "encrypt" our one flag bit
    bool is_trick_pin = !!slot;

    args->private_state = ((rng_sample() & ~1) | is_trick_pin) ^ rom_secrets->hash_cache_secret[0];
 800404c:	f020 0001 	bic.w	r0, r0, #1
 8004050:	4058      	eors	r0, r3
 8004052:	6420      	str	r0, [r4, #64]	; 0x40

    if(!slot) {
        args->delay_required = 0;
        args->delay_achieved = 0;
 8004054:	62e5      	str	r5, [r4, #44]	; 0x2c
// Provide our "signature" validating struct contents as coming from us.
//
    static void
_sign_attempt(pinAttempt_t *args)
{
    _hmac_attempt(args, args->hmac);
 8004056:	4620      	mov	r0, r4
 8004058:	f104 0144 	add.w	r1, r4, #68	; 0x44
 800405c:	f7ff fca4 	bl	80039a8 <_hmac_attempt>

            goto real_login;
        }
        _sign_attempt(args);

        return 0;
 8004060:	2000      	movs	r0, #0
 8004062:	e043      	b.n	80040ec <pin_login_attempt+0x1d4>
// Do the PIN check, and return a value. Or fail.
//
    int
pin_login_attempt(pinAttempt_t *args)
{
    bool deltamode = false;
 8004064:	4605      	mov	r5, r0
        return 0;
    }

real_login:
    // unlock the AE chip
    if(warmup_ae()) return EPIN_I_AM_BRICK;
 8004066:	f7ff fd09 	bl	8003a7c <warmup_ae>
 800406a:	2800      	cmp	r0, #0
 800406c:	d13c      	bne.n	80040e8 <pin_login_attempt+0x1d0>

    // hash up the pin now, assuming we'll use it on main PIN
    uint8_t     digest[32];
    rv = pin_hash_attempt(deltamode ? tmp_pin : args->pin, args->pin_len, digest);
 800406e:	b105      	cbz	r5, 8004072 <pin_login_attempt+0x15a>
 8004070:	af03      	add	r7, sp, #12
 8004072:	aa0b      	add	r2, sp, #44	; 0x2c
 8004074:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8004076:	4638      	mov	r0, r7
 8004078:	f7ff fe0e 	bl	8003c98 <pin_hash_attempt>
    if(rv) return EPIN_AE_FAIL;
 800407c:	bb48      	cbnz	r0, 80040d2 <pin_login_attempt+0x1ba>
// Do the checkmac thing using a PIN, and if it works, great.
//
    static bool
is_main_pin(const uint8_t digest[32])
{
    ae_reset_chip();
 800407e:	f7fe fc81 	bl	8002984 <ae_reset_chip>
    ae_pair_unlock();
 8004082:	f7fe fe8d 	bl	8002da0 <ae_pair_unlock>

    return (ae_checkmac_hard(KEYNUM_main_pin, digest) == 0);
 8004086:	a90b      	add	r1, sp, #44	; 0x2c
 8004088:	2003      	movs	r0, #3
 800408a:	f7fe fff3 	bl	8003074 <ae_checkmac_hard>
    rv = pin_hash_attempt(deltamode ? tmp_pin : args->pin, args->pin_len, digest);
    if(rv) return EPIN_AE_FAIL;

    // It is not a "trick pin", so assume it's the real PIN, and register
    // as an attempt on that.
    if(!is_main_pin(digest)) {
 800408e:	b130      	cbz	r0, 800409e <pin_login_attempt+0x186>
        // PIN code is just wrong.
        // - nothing to update, since the chip's done it already
        // - but maybe there are consequences to a wrong pin
        se2_handle_bad_pin(args->num_fails + 1);
 8004090:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8004092:	3001      	adds	r0, #1
 8004094:	f003 ff20 	bl	8007ed8 <se2_handle_bad_pin>

        return EPIN_AUTH_FAIL;
 8004098:	f06f 006f 	mvn.w	r0, #111	; 0x6f
 800409c:	e026      	b.n	80040ec <pin_login_attempt+0x1d4>
    }

    // change the various counters, since this worked
    rv = updates_for_good_login(digest);
 800409e:	a80b      	add	r0, sp, #44	; 0x2c
 80040a0:	f7ff fd72 	bl	8003b88 <updates_for_good_login>
    if(rv) return EPIN_AE_FAIL;
 80040a4:	4606      	mov	r6, r0
 80040a6:	b9a0      	cbnz	r0, 80040d2 <pin_login_attempt+0x1ba>

    // SUCCESS! "digest" holds a working value. Save it.
    pin_cache_save(args, digest);
 80040a8:	a90b      	add	r1, sp, #44	; 0x2c
 80040aa:	4620      	mov	r0, r4
 80040ac:	f7ff fe3a 	bl	8003d24 <pin_cache_save>

    // ASIDE: even if the above was bypassed, the following code will
    // fail when it tries to read/update the corresponding slots in the SE

    // mark as success
    args->state_flags = PA_SUCCESSFUL;
 80040b0:	2301      	movs	r3, #1
 80040b2:	63e3      	str	r3, [r4, #60]	; 0x3c

    // these are constants, and user doesn't care because they got in... but consistency.
    args->num_fails = 0;
 80040b4:	6366      	str	r6, [r4, #52]	; 0x34
    args->attempts_left = MAX_TARGET_ATTEMPTS;
 80040b6:	230d      	movs	r3, #13
    // I used to always read the secret, since it's so hard to get to this point,
    // but now just indicating if zero or non-zero so that we don't contaminate the
    // caller w/ sensitive data that they may not want yet.
    {   uint8_t ts[AE_SECRET_LEN];

        rv = ae_encrypted_read(KEYNUM_secret, KEYNUM_main_pin, digest, ts, AE_SECRET_LEN);
 80040b8:	2648      	movs	r6, #72	; 0x48
    // mark as success
    args->state_flags = PA_SUCCESSFUL;

    // these are constants, and user doesn't care because they got in... but consistency.
    args->num_fails = 0;
    args->attempts_left = MAX_TARGET_ATTEMPTS;
 80040ba:	63a3      	str	r3, [r4, #56]	; 0x38
    // I used to always read the secret, since it's so hard to get to this point,
    // but now just indicating if zero or non-zero so that we don't contaminate the
    // caller w/ sensitive data that they may not want yet.
    {   uint8_t ts[AE_SECRET_LEN];

        rv = ae_encrypted_read(KEYNUM_secret, KEYNUM_main_pin, digest, ts, AE_SECRET_LEN);
 80040bc:	9600      	str	r6, [sp, #0]
 80040be:	ab33      	add	r3, sp, #204	; 0xcc
 80040c0:	aa0b      	add	r2, sp, #44	; 0x2c
 80040c2:	2103      	movs	r1, #3
 80040c4:	2009      	movs	r0, #9
 80040c6:	f7ff f8b1 	bl	800322c <ae_encrypted_read>
        if(rv) {
 80040ca:	2800      	cmp	r0, #0
 80040cc:	d0a7      	beq.n	800401e <pin_login_attempt+0x106>
            ae_reset_chip();
 80040ce:	f7fe fc59 	bl	8002984 <ae_reset_chip>

            return EPIN_AE_FAIL;
 80040d2:	f06f 0069 	mvn.w	r0, #105	; 0x69
 80040d6:	e009      	b.n	80040ec <pin_login_attempt+0x1d4>
        bool mcu_key_valid;
        mcu_key_get(&mcu_key_valid);

        // new fresh system comes here comes w/ zeros (plaintext) in secret slot of SE1
        if(check_all_zeros(ts, AE_SECRET_LEN) || !mcu_key_valid) {
            args->state_flags |= PA_ZERO_SECRET;
 80040d8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80040da:	f043 0310 	orr.w	r3, r3, #16
 80040de:	63e3      	str	r3, [r4, #60]	; 0x3c
 80040e0:	e7ad      	b.n	800403e <pin_login_attempt+0x126>
    int rv = _validate_attempt(args, false);
    if(rv) return rv;

    if(args->state_flags & PA_SUCCESSFUL) {
        // already worked, or is blank
        return EPIN_WRONG_SUCCESS;
 80040e2:	f06f 006c 	mvn.w	r0, #108	; 0x6c
 80040e6:	e001      	b.n	80040ec <pin_login_attempt+0x1d4>
        return 0;
    }

real_login:
    // unlock the AE chip
    if(warmup_ae()) return EPIN_I_AM_BRICK;
 80040e8:	f06f 0068 	mvn.w	r0, #104	; 0x68
    }

    _sign_attempt(args);

    return 0;
}
 80040ec:	f50d 7d34 	add.w	sp, sp, #720	; 0x2d0
 80040f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80040f4:	0801e000 	.word	0x0801e000
 80040f8:	0801e074 	.word	0x0801e074

080040fc <pin_check_logged_in>:
//
// Verify we know the main PIN, but don't do anything with it.
//
    int
pin_check_logged_in(const pinAttempt_t *args, bool *is_trick)
{
 80040fc:	b570      	push	{r4, r5, r6, lr}
 80040fe:	460e      	mov	r6, r1
 8004100:	b088      	sub	sp, #32
    int rv = _validate_attempt(args, false);
 8004102:	2100      	movs	r1, #0
//
// Verify we know the main PIN, but don't do anything with it.
//
    int
pin_check_logged_in(const pinAttempt_t *args, bool *is_trick)
{
 8004104:	4605      	mov	r5, r0
    int rv = _validate_attempt(args, false);
 8004106:	f7ff fc81 	bl	8003a0c <_validate_attempt>
    if(rv) return rv;
 800410a:	4604      	mov	r4, r0
 800410c:	bb18      	cbnz	r0, 8004156 <pin_check_logged_in+0x5a>

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
 800410e:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8004110:	07db      	lsls	r3, r3, #31
 8004112:	d522      	bpl.n	800415a <pin_check_logged_in+0x5e>
    static bool
get_is_trick(const pinAttempt_t *args, trick_slot_t *slot)
{
    // read and "decrypt" our one flag bit
    // - optional: aes-decrypt some more details about the trick slot
    bool is_trick = ((args->private_state ^ rom_secrets->hash_cache_secret[0]) & 0x1);
 8004114:	4b13      	ldr	r3, [pc, #76]	; (8004164 <pin_check_logged_in+0x68>)
    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
        // must come here with a successful PIN login (so it's rate limited nicely)
        return EPIN_WRONG_SUCCESS;
    }

    if(get_is_trick(args, NULL)) {
 8004116:	f893 2070 	ldrb.w	r2, [r3, #112]	; 0x70
 800411a:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 800411c:	4053      	eors	r3, r2
 800411e:	f013 0301 	ands.w	r3, r3, #1
 8004122:	d007      	beq.n	8004134 <pin_check_logged_in+0x38>
        // they used a trick pin to get this far. Amuse them more.
        *is_trick = true;
 8004124:	2301      	movs	r3, #1
 8004126:	7033      	strb	r3, [r6, #0]

        // should calibrate this, but smart money will just look at the bus
        delay_ms(10);
 8004128:	200a      	movs	r0, #10
 800412a:	f7ff fbad 	bl	8003888 <delay_ms>
        rng_delay();
 800412e:	f7fe fb02 	bl	8002736 <rng_delay>
 8004132:	e010      	b.n	8004156 <pin_check_logged_in+0x5a>
    } else {
        *is_trick = false;
 8004134:	7033      	strb	r3, [r6, #0]

        // check we know the right PIN
        uint8_t auth_digest[32]; 
        pin_cache_restore(args, auth_digest);
 8004136:	4669      	mov	r1, sp
 8004138:	4628      	mov	r0, r5
 800413a:	f7ff fe2b 	bl	8003d94 <pin_cache_restore>

        ae_pair_unlock();
 800413e:	f7fe fe2f 	bl	8002da0 <ae_pair_unlock>
        int rv = ae_checkmac(KEYNUM_main_pin, auth_digest);
 8004142:	4669      	mov	r1, sp
 8004144:	2003      	movs	r0, #3
 8004146:	f7fe fdab 	bl	8002ca0 <ae_checkmac>
        if(rv) return EPIN_AUTH_FAIL;
 800414a:	2800      	cmp	r0, #0
 800414c:	bf0c      	ite	eq
 800414e:	2000      	moveq	r0, #0
 8004150:	f06f 006f 	mvnne.w	r0, #111	; 0x6f
 8004154:	e003      	b.n	800415e <pin_check_logged_in+0x62>
 8004156:	4620      	mov	r0, r4
 8004158:	e001      	b.n	800415e <pin_check_logged_in+0x62>
    int rv = _validate_attempt(args, false);
    if(rv) return rv;

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
        // must come here with a successful PIN login (so it's rate limited nicely)
        return EPIN_WRONG_SUCCESS;
 800415a:	f06f 006c 	mvn.w	r0, #108	; 0x6c
        int rv = ae_checkmac(KEYNUM_main_pin, auth_digest);
        if(rv) return EPIN_AUTH_FAIL;
    }

    return 0;
}
 800415e:	b008      	add	sp, #32
 8004160:	bd70      	pop	{r4, r5, r6, pc}
 8004162:	bf00      	nop
 8004164:	0801e000 	.word	0x0801e000

08004168 <pin_change>:
//
// Change the PIN and/or the secret. (Must also know the previous value, or it must be blank)
//
    int
pin_change(pinAttempt_t *args)
{
 8004168:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    // Validate args and signature
    int rv = _validate_attempt(args, false);
 800416c:	2100      	movs	r1, #0
//
// Change the PIN and/or the secret. (Must also know the previous value, or it must be blank)
//
    int
pin_change(pinAttempt_t *args)
{
 800416e:	b0ae      	sub	sp, #184	; 0xb8
 8004170:	4604      	mov	r4, r0
    // Validate args and signature
    int rv = _validate_attempt(args, false);
 8004172:	f7ff fc4b 	bl	8003a0c <_validate_attempt>
    if(rv) return rv;
 8004176:	2800      	cmp	r0, #0
 8004178:	f040 8099 	bne.w	80042ae <pin_change+0x146>

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
 800417c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800417e:	07d9      	lsls	r1, r3, #31
 8004180:	f140 8097 	bpl.w	80042b2 <pin_change+0x14a>
        // must come here with a successful PIN login (so it's rate limited nicely)
        return EPIN_WRONG_SUCCESS;
    }

    if(args->state_flags & PA_IS_BLANK) {
 8004184:	079a      	lsls	r2, r3, #30
 8004186:	d503      	bpl.n	8004190 <pin_change+0x28>
        // if blank, must provide blank value
        if(args->pin_len) return EPIN_RANGE_ERR;
 8004188:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800418a:	2b00      	cmp	r3, #0
 800418c:	f040 8097 	bne.w	80042be <pin_change+0x156>
    }

    // Look at change flags.
    const uint32_t cf = args->change_flags;

    ASSERT(!args->is_secondary);
 8004190:	6863      	ldr	r3, [r4, #4]
        // if blank, must provide blank value
        if(args->pin_len) return EPIN_RANGE_ERR;
    }

    // Look at change flags.
    const uint32_t cf = args->change_flags;
 8004192:	f8d4 9064 	ldr.w	r9, [r4, #100]	; 0x64

    ASSERT(!args->is_secondary);
 8004196:	b113      	cbz	r3, 800419e <pin_change+0x36>
 8004198:	484d      	ldr	r0, [pc, #308]	; (80042d0 <pin_change+0x168>)
 800419a:	f7fc fc1f 	bl	80009dc <fatal_error>
    if(cf & CHANGE_SECONDARY_WALLET_PIN) {
        // obsolete secondary support, can't support.
        return EPIN_BAD_REQUEST;
    }
    if(cf & (CHANGE_DURESS_PIN | CHANGE_DURESS_SECRET | CHANGE_BRICKME_PIN)) {
 800419e:	f019 0f36 	tst.w	r9, #54	; 0x36
 80041a2:	f040 8089 	bne.w	80042b8 <pin_change+0x150>
        // we need some new API for trick PIN lookup/changes. 
        return EPIN_BAD_REQUEST;
    }
    if(!(cf & (CHANGE_WALLET_PIN | CHANGE_SECRET))) {
 80041a6:	f019 0f09 	tst.w	r9, #9
 80041aa:	f000 8088 	beq.w	80042be <pin_change+0x156>
    static bool
get_is_trick(const pinAttempt_t *args, trick_slot_t *slot)
{
    // read and "decrypt" our one flag bit
    // - optional: aes-decrypt some more details about the trick slot
    bool is_trick = ((args->private_state ^ rom_secrets->hash_cache_secret[0]) & 0x1);
 80041ae:	4b49      	ldr	r3, [pc, #292]	; (80042d4 <pin_change+0x16c>)
    // If they authorized w/ a trick PIN, new policy is to wipe ourselves if
    // they try to change PIN code or the secret.
    //  - it's hard to fake them out here, and they may be onto us.
    //  - this protects the seed, but does end the game somewhat
    //  - all trick PINs will still be in effect, and looks like random reset
    if(get_is_trick(args, NULL)) {
 80041b0:	f893 2070 	ldrb.w	r2, [r3, #112]	; 0x70
 80041b4:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80041b6:	4053      	eors	r3, r2
 80041b8:	07db      	lsls	r3, r3, #31
 80041ba:	d502      	bpl.n	80041c2 <pin_change+0x5a>
        // User is a thug.. kill secret and reboot w/o any notice
        fast_wipe();
 80041bc:	f7fe fa1e 	bl	80025fc <fast_wipe>
 80041c0:	e07a      	b.n	80042b8 <pin_change+0x150>
        // NOT-REACHED
        return EPIN_BAD_REQUEST;
    }

    // unlock the AE chip
    if(warmup_ae()) return EPIN_I_AM_BRICK;
 80041c2:	f7ff fc5b 	bl	8003a7c <warmup_ae>
 80041c6:	4605      	mov	r5, r0
 80041c8:	2800      	cmp	r0, #0
 80041ca:	d17b      	bne.n	80042c4 <pin_change+0x15c>
    // If they tricked us to get to this point, doesn't matter as
    // below SE1 validates it all again.

    // Restore cached version of PIN digest: fast
    uint8_t required_digest[32]; 
    pin_cache_restore(args, required_digest);
 80041cc:	f10d 0808 	add.w	r8, sp, #8
 80041d0:	4641      	mov	r1, r8
 80041d2:	4620      	mov	r0, r4
 80041d4:	f7ff fdde 	bl	8003d94 <pin_cache_restore>

    // Calculate new PIN hashed value: will be slow to do
    if(cf & CHANGE_WALLET_PIN) {
 80041d8:	f019 0f01 	tst.w	r9, #1
 80041dc:	d021      	beq.n	8004222 <pin_change+0xba>
        uint8_t new_digest[32]; 
        rv = pin_hash_attempt(args->new_pin, args->new_pin_len, new_digest);
 80041de:	aa1c      	add	r2, sp, #112	; 0x70
 80041e0:	f8d4 10ac 	ldr.w	r1, [r4, #172]	; 0xac
 80041e4:	f104 008c 	add.w	r0, r4, #140	; 0x8c
 80041e8:	f7ff fd56 	bl	8003c98 <pin_hash_attempt>
        if(rv) goto ae_fail;
 80041ec:	2800      	cmp	r0, #0
 80041ee:	d159      	bne.n	80042a4 <pin_change+0x13c>

        if(ae_encrypted_write(KEYNUM_main_pin, KEYNUM_main_pin, required_digest, new_digest, 32)) {
 80041f0:	2320      	movs	r3, #32
 80041f2:	2103      	movs	r1, #3
 80041f4:	9300      	str	r3, [sp, #0]
 80041f6:	4642      	mov	r2, r8
 80041f8:	ab1c      	add	r3, sp, #112	; 0x70
 80041fa:	4608      	mov	r0, r1
 80041fc:	f7ff f8b6 	bl	800336c <ae_encrypted_write>
 8004200:	2800      	cmp	r0, #0
 8004202:	d14f      	bne.n	80042a4 <pin_change+0x13c>
            goto ae_fail;
        }

        memcpy(required_digest, new_digest, 32);
 8004204:	af1c      	add	r7, sp, #112	; 0x70
 8004206:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8004208:	4646      	mov	r6, r8
 800420a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 800420c:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
 8004210:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}

        // main pin is changing; reset counter to zero (good login) and our cache
        pin_cache_save(args, new_digest);
 8004214:	4620      	mov	r0, r4
 8004216:	a91c      	add	r1, sp, #112	; 0x70
 8004218:	f7ff fd84 	bl	8003d24 <pin_cache_save>

        updates_for_good_login(new_digest);
 800421c:	a81c      	add	r0, sp, #112	; 0x70
 800421e:	f7ff fcb3 	bl	8003b88 <updates_for_good_login>
    }

    // Recording new secret.
    // Note the required_digest might have just changed above.
    if(cf & CHANGE_SECRET) {
 8004222:	f019 0f08 	tst.w	r9, #8
 8004226:	d035      	beq.n	8004294 <pin_change+0x12c>
// Mk4 support additional secret storage: spares. Map to key number, or -1 if range error
//
    static int
keynum_for_secret(const pinAttempt_t *args)
{
    int which = (args->change_flags >> 8) & 0xf;
 8004228:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800422a:	f3c3 2303 	ubfx	r3, r3, #8, #4
 800422e:	2b03      	cmp	r3, #3
 8004230:	dc45      	bgt.n	80042be <pin_change+0x156>
 8004232:	4a29      	ldr	r2, [pc, #164]	; (80042d8 <pin_change+0x170>)
 8004234:	f912 a003 	ldrsb.w	sl, [r2, r3]
        uint8_t     tmp[AE_SECRET_LEN];
        uint8_t     check[AE_SECRET_LEN];

        // what slot (key number) are updating? (probably: KEYNUM_secret)
        int         target_slot = keynum_for_secret(args);
        if(target_slot < 0) return EPIN_RANGE_ERR;
 8004238:	f1ba 0f00 	cmp.w	sl, #0
 800423c:	db3f      	blt.n	80042be <pin_change+0x156>

        se2_encrypt_secret(args->secret, AE_SECRET_LEN, 0, tmp, check, required_digest);
 800423e:	f104 07b0 	add.w	r7, r4, #176	; 0xb0
 8004242:	ae1c      	add	r6, sp, #112	; 0x70
 8004244:	ab0a      	add	r3, sp, #40	; 0x28
 8004246:	2200      	movs	r2, #0
 8004248:	2148      	movs	r1, #72	; 0x48
 800424a:	f8cd 8004 	str.w	r8, [sp, #4]
 800424e:	9600      	str	r6, [sp, #0]
 8004250:	4638      	mov	r0, r7

        // write into two slots
        if(ae_encrypted_write(target_slot, KEYNUM_main_pin,
 8004252:	f04f 0948 	mov.w	r9, #72	; 0x48

        // what slot (key number) are updating? (probably: KEYNUM_secret)
        int         target_slot = keynum_for_secret(args);
        if(target_slot < 0) return EPIN_RANGE_ERR;

        se2_encrypt_secret(args->secret, AE_SECRET_LEN, 0, tmp, check, required_digest);
 8004256:	f003 ff05 	bl	8008064 <se2_encrypt_secret>

        // write into two slots
        if(ae_encrypted_write(target_slot, KEYNUM_main_pin,
 800425a:	2103      	movs	r1, #3
 800425c:	f8cd 9000 	str.w	r9, [sp]
 8004260:	ab0a      	add	r3, sp, #40	; 0x28
 8004262:	4642      	mov	r2, r8
 8004264:	4650      	mov	r0, sl
 8004266:	f7ff f881 	bl	800336c <ae_encrypted_write>
 800426a:	4601      	mov	r1, r0
 800426c:	b9d0      	cbnz	r0, 80042a4 <pin_change+0x13c>
                                        required_digest, tmp, AE_SECRET_LEN)){
            goto ae_fail;
        }
        if(ae_encrypted_write32(KEYNUM_check_secret, 0, KEYNUM_main_pin, required_digest, check)){
 800426e:	9600      	str	r6, [sp, #0]
 8004270:	4643      	mov	r3, r8
 8004272:	2203      	movs	r2, #3
 8004274:	200a      	movs	r0, #10
 8004276:	f7ff f811 	bl	800329c <ae_encrypted_write32>
 800427a:	b998      	cbnz	r0, 80042a4 <pin_change+0x13c>
            goto ae_fail;
        }

        // update the zero-secret flag to be correct.
        if(cf & CHANGE_SECRET) {
            if(check_all_zeros(args->secret, AE_SECRET_LEN)) {
 800427c:	4649      	mov	r1, r9
 800427e:	4638      	mov	r0, r7
 8004280:	f7fe f9e2 	bl	8002648 <check_all_zeros>
 8004284:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8004286:	b110      	cbz	r0, 800428e <pin_change+0x126>
                args->state_flags |= PA_ZERO_SECRET;
 8004288:	f043 0310 	orr.w	r3, r3, #16
 800428c:	e001      	b.n	8004292 <pin_change+0x12a>
            } else {
                args->state_flags &= ~PA_ZERO_SECRET;
 800428e:	f023 0310 	bic.w	r3, r3, #16
 8004292:	63e3      	str	r3, [r4, #60]	; 0x3c
            }
        }
    }

    ae_reset_chip();
 8004294:	f7fe fb76 	bl	8002984 <ae_reset_chip>
// Provide our "signature" validating struct contents as coming from us.
//
    static void
_sign_attempt(pinAttempt_t *args)
{
    _hmac_attempt(args, args->hmac);
 8004298:	f104 0144 	add.w	r1, r4, #68	; 0x44
 800429c:	4620      	mov	r0, r4
 800429e:	f7ff fb83 	bl	80039a8 <_hmac_attempt>
 80042a2:	e011      	b.n	80042c8 <pin_change+0x160>
    _sign_attempt(args);

    return 0;

ae_fail:
    ae_reset_chip();
 80042a4:	f7fe fb6e 	bl	8002984 <ae_reset_chip>

    return EPIN_AE_FAIL;
 80042a8:	f06f 0569 	mvn.w	r5, #105	; 0x69
 80042ac:	e00c      	b.n	80042c8 <pin_change+0x160>
 80042ae:	4605      	mov	r5, r0
 80042b0:	e00a      	b.n	80042c8 <pin_change+0x160>
    int rv = _validate_attempt(args, false);
    if(rv) return rv;

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
        // must come here with a successful PIN login (so it's rate limited nicely)
        return EPIN_WRONG_SUCCESS;
 80042b2:	f06f 056c 	mvn.w	r5, #108	; 0x6c
 80042b6:	e007      	b.n	80042c8 <pin_change+0x160>
        // obsolete secondary support, can't support.
        return EPIN_BAD_REQUEST;
    }
    if(cf & (CHANGE_DURESS_PIN | CHANGE_DURESS_SECRET | CHANGE_BRICKME_PIN)) {
        // we need some new API for trick PIN lookup/changes. 
        return EPIN_BAD_REQUEST;
 80042b8:	f06f 0567 	mvn.w	r5, #103	; 0x67
 80042bc:	e004      	b.n	80042c8 <pin_change+0x160>
        return EPIN_WRONG_SUCCESS;
    }

    if(args->state_flags & PA_IS_BLANK) {
        // if blank, must provide blank value
        if(args->pin_len) return EPIN_RANGE_ERR;
 80042be:	f06f 0566 	mvn.w	r5, #102	; 0x66
 80042c2:	e001      	b.n	80042c8 <pin_change+0x160>
        // NOT-REACHED
        return EPIN_BAD_REQUEST;
    }

    // unlock the AE chip
    if(warmup_ae()) return EPIN_I_AM_BRICK;
 80042c4:	f06f 0568 	mvn.w	r5, #104	; 0x68

ae_fail:
    ae_reset_chip();

    return EPIN_AE_FAIL;
}
 80042c8:	4628      	mov	r0, r5
 80042ca:	b02e      	add	sp, #184	; 0xb8
 80042cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80042d0:	0800d550 	.word	0x0800d550
 80042d4:	0801e000 	.word	0x0801e000
 80042d8:	0800e474 	.word	0x0800e474

080042dc <pin_fetch_secret>:
// To encourage not keeping the secret in memory, a way to fetch it after you've already
// proven you know the PIN.
//
    int
pin_fetch_secret(pinAttempt_t *args)
{
 80042dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    // Validate args and signature
    int rv = _validate_attempt(args, false);
 80042e0:	2100      	movs	r1, #0
// To encourage not keeping the secret in memory, a way to fetch it after you've already
// proven you know the PIN.
//
    int
pin_fetch_secret(pinAttempt_t *args)
{
 80042e2:	f5ad 7d36 	sub.w	sp, sp, #728	; 0x2d8
 80042e6:	4604      	mov	r4, r0
    // Validate args and signature
    int rv = _validate_attempt(args, false);
 80042e8:	f7ff fb90 	bl	8003a0c <_validate_attempt>
    if(rv) return rv;
 80042ec:	2800      	cmp	r0, #0
 80042ee:	f040 8091 	bne.w	8004414 <pin_fetch_secret+0x138>

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
 80042f2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80042f4:	07db      	lsls	r3, r3, #31
 80042f6:	f140 808f 	bpl.w	8004418 <pin_fetch_secret+0x13c>
        // must come here with a successful PIN login (so it's rate limited nicely)
        return EPIN_WRONG_SUCCESS;
    }
    if(args->change_flags & CHANGE_DURESS_SECRET) {
 80042fa:	6e65      	ldr	r5, [r4, #100]	; 0x64
 80042fc:	f015 0510 	ands.w	r5, r5, #16
 8004300:	f040 808d 	bne.w	800441e <pin_fetch_secret+0x142>

    // fetch the already-hashed pin
    // - no real need to re-prove PIN knowledge.
    // - if they tricked us, doesn't matter as below the SE validates it all again
    uint8_t     digest[32];
    pin_cache_restore(args, digest);
 8004304:	f10d 0814 	add.w	r8, sp, #20
 8004308:	4641      	mov	r1, r8
 800430a:	4620      	mov	r0, r4
 800430c:	f7ff fd42 	bl	8003d94 <pin_cache_restore>
    static bool
get_is_trick(const pinAttempt_t *args, trick_slot_t *slot)
{
    // read and "decrypt" our one flag bit
    // - optional: aes-decrypt some more details about the trick slot
    bool is_trick = ((args->private_state ^ rom_secrets->hash_cache_secret[0]) & 0x1);
 8004310:	4b5c      	ldr	r3, [pc, #368]	; (8004484 <pin_fetch_secret+0x1a8>)
 8004312:	f893 2070 	ldrb.w	r2, [r3, #112]	; 0x70
 8004316:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8004318:	4053      	eors	r3, r2

    if(!slot || !is_trick) return is_trick;
 800431a:	07df      	lsls	r7, r3, #31
 800431c:	d537      	bpl.n	800438e <pin_fetch_secret+0xb2>

    memset(slot, 0, sizeof(trick_slot_t));
 800431e:	2280      	movs	r2, #128	; 0x80
 8004320:	4629      	mov	r1, r5
 8004322:	a815      	add	r0, sp, #84	; 0x54
 8004324:	f009 f8cf 	bl	800d4c6 <memset>

    if(args->delay_required & TC_DELTA_MODE) {
 8004328:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800432a:	055e      	lsls	r6, r3, #21
 800432c:	d505      	bpl.n	800433a <pin_fetch_secret+0x5e>
        // in delta mode, we are using the cached_main_pin for real PIN (hashed)
        // so we cannot restore details
        slot->tc_flags = args->delay_required;
 800432e:	f8ad 3058 	strh.w	r3, [sp, #88]	; 0x58
        slot->tc_arg = 0;           // unknown
        slot->slot_num = -1;        // unknown
 8004332:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004336:	9315      	str	r3, [sp, #84]	; 0x54
 8004338:	e022      	b.n	8004380 <pin_fetch_secret+0xa4>
//
    static void
_make_trick_aes_key(const pinAttempt_t *args, uint8_t key[32])
{
    // key is args->private_state (4 bytes) + 28 bytes from hash_cache_secret
    memcpy(key, &args->private_state, sizeof(args->private_state));
 800433a:	6c20      	ldr	r0, [r4, #64]	; 0x40
    memcpy(key+4, rom_secrets->hash_cache_secret+4, sizeof(rom_secrets->hash_cache_secret)-4);
 800433c:	4f52      	ldr	r7, [pc, #328]	; (8004488 <pin_fetch_secret+0x1ac>)
//
    static void
_make_trick_aes_key(const pinAttempt_t *args, uint8_t key[32])
{
    // key is args->private_state (4 bytes) + 28 bytes from hash_cache_secret
    memcpy(key, &args->private_state, sizeof(args->private_state));
 800433e:	900d      	str	r0, [sp, #52]	; 0x34
    memcpy(key+4, rom_secrets->hash_cache_secret+4, sizeof(rom_secrets->hash_cache_secret)-4);
 8004340:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8004342:	ae0e      	add	r6, sp, #56	; 0x38
 8004344:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8004346:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
 800434a:	e886 0007 	stmia.w	r6, {r0, r1, r2}
        STATIC_ASSERT(offsetof(trick_slot_t, tc_arg) < 32);
        STATIC_ASSERT(sizeof(trick_slot_t) >= 32);

        // decode first 32 bytes of trick slot info into place
        AES_CTX ctx;
        aes_init(&ctx);
 800434e:	a835      	add	r0, sp, #212	; 0xd4
 8004350:	f003 ff3e 	bl	80081d0 <aes_init>
        aes_add(&ctx, args->cached_main_pin, 32);
 8004354:	2220      	movs	r2, #32
 8004356:	f104 01f8 	add.w	r1, r4, #248	; 0xf8
 800435a:	a835      	add	r0, sp, #212	; 0xd4
 800435c:	f003 ff3e 	bl	80081dc <aes_add>
        aes_done(&ctx, (uint8_t *)slot, 32, key, NULL);
 8004360:	a915      	add	r1, sp, #84	; 0x54
 8004362:	9500      	str	r5, [sp, #0]
 8004364:	ab0d      	add	r3, sp, #52	; 0x34
 8004366:	2220      	movs	r2, #32
 8004368:	a835      	add	r0, sp, #212	; 0xd4
 800436a:	f003 ff4d 	bl	8008208 <aes_done>

        if(slot->tc_flags & (TC_WORD_WALLET|TC_XPRV_WALLET)) {
 800436e:	f8bd 1058 	ldrh.w	r1, [sp, #88]	; 0x58
 8004372:	f411 5fc0 	tst.w	r1, #6144	; 0x1800
 8004376:	d003      	beq.n	8004380 <pin_fetch_secret+0xa4>
            // read 1 or 2 data slots that immediately follow a trick PIN slot
            se2_read_trick_data(slot->slot_num, slot->tc_flags, slot->xdata);
 8004378:	aa17      	add	r2, sp, #92	; 0x5c
 800437a:	9815      	ldr	r0, [sp, #84]	; 0x54
 800437c:	f003 fc8c 	bl	8007c98 <se2_read_trick_data>

    // determine if we should proceed under duress
    trick_slot_t slot;
    bool is_trick = get_is_trick(args, &slot);

    if(is_trick && !(slot.tc_flags & TC_DELTA_MODE)) {
 8004380:	f8bd 6058 	ldrh.w	r6, [sp, #88]	; 0x58
 8004384:	f406 6180 	and.w	r1, r6, #1024	; 0x400
 8004388:	b289      	uxth	r1, r1
 800438a:	2900      	cmp	r1, #0
 800438c:	d04d      	beq.n	800442a <pin_fetch_secret+0x14e>
// Mk4 support additional secret storage: spares. Map to key number, or -1 if range error
//
    static int
keynum_for_secret(const pinAttempt_t *args)
{
    int which = (args->change_flags >> 8) & 0xf;
 800438e:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8004390:	f3c3 2303 	ubfx	r3, r3, #8, #4
 8004394:	2b03      	cmp	r3, #3
 8004396:	dc45      	bgt.n	8004424 <pin_fetch_secret+0x148>
 8004398:	4a3c      	ldr	r2, [pc, #240]	; (800448c <pin_fetch_secret+0x1b0>)
 800439a:	56d0      	ldrsb	r0, [r2, r3]
    uint8_t    tmp[AE_SECRET_LEN];
    uint8_t    check[32];

    // default, zero: main secret, otherwise, the spares.
    int kn = keynum_for_secret(args);
    if(kn < 0) return EPIN_RANGE_ERR;
 800439c:	2800      	cmp	r0, #0
 800439e:	db41      	blt.n	8004424 <pin_fetch_secret+0x148>

    // read out the secret that corresponds to pin
    rv = ae_encrypted_read(kn, KEYNUM_main_pin, digest, tmp, AE_SECRET_LEN);
 80043a0:	2748      	movs	r7, #72	; 0x48
 80043a2:	9700      	str	r7, [sp, #0]
 80043a4:	ab35      	add	r3, sp, #212	; 0xd4
 80043a6:	4642      	mov	r2, r8
 80043a8:	2103      	movs	r1, #3
 80043aa:	f7fe ff3f 	bl	800322c <ae_encrypted_read>
    if(rv) goto fail;
 80043ae:	4605      	mov	r5, r0
 80043b0:	bb40      	cbnz	r0, 8004404 <pin_fetch_secret+0x128>
    rv = ae_encrypted_read32(KEYNUM_check_secret, 0, KEYNUM_main_pin, digest, check);
 80043b2:	ae0d      	add	r6, sp, #52	; 0x34
 80043b4:	4601      	mov	r1, r0
 80043b6:	9600      	str	r6, [sp, #0]
 80043b8:	4643      	mov	r3, r8
 80043ba:	2203      	movs	r2, #3
 80043bc:	200a      	movs	r0, #10
 80043be:	f7fe ff0a 	bl	80031d6 <ae_encrypted_read32>
    if(rv) goto fail;
 80043c2:	4605      	mov	r5, r0
 80043c4:	b9f0      	cbnz	r0, 8004404 <pin_fetch_secret+0x128>

    // decrypt via a complex process.
    bool is_valid;
    se2_decrypt_secret(args->secret, AE_SECRET_LEN, 0, tmp, check, digest, &is_valid);
 80043c6:	f10d 0a13 	add.w	sl, sp, #19
 80043ca:	f104 09b0 	add.w	r9, r4, #176	; 0xb0
 80043ce:	ab35      	add	r3, sp, #212	; 0xd4
 80043d0:	4602      	mov	r2, r0
 80043d2:	e88d 0540 	stmia.w	sp, {r6, r8, sl}
 80043d6:	4639      	mov	r1, r7
 80043d8:	4648      	mov	r0, r9
 80043da:	f003 fe93 	bl	8008104 <se2_decrypt_secret>

    if(!is_valid) {
 80043de:	f89a 3000 	ldrb.w	r3, [sl]
 80043e2:	b97b      	cbnz	r3, 8004404 <pin_fetch_secret+0x128>
        // means the MCU key has been wiped; so effectively our secret is zeros
        // - also happens in case of any corruption with SE1/SE2 contents
        rv = 0;
        memset(args->secret, 0, AE_SECRET_LEN);
 80043e4:	463a      	mov	r2, r7
 80043e6:	4629      	mov	r1, r5
 80043e8:	4648      	mov	r0, r9
 80043ea:	f009 f86c 	bl	800d4c6 <memset>

        if(!(args->state_flags & PA_ZERO_SECRET)) {
 80043ee:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80043f0:	06da      	lsls	r2, r3, #27
 80043f2:	d407      	bmi.n	8004404 <pin_fetch_secret+0x128>
            // we didn't know yet that we are blank, update that
            args->state_flags |= PA_ZERO_SECRET;
 80043f4:	f043 0310 	orr.w	r3, r3, #16
 80043f8:	63e3      	str	r3, [r4, #60]	; 0x3c
// Provide our "signature" validating struct contents as coming from us.
//
    static void
_sign_attempt(pinAttempt_t *args)
{
    _hmac_attempt(args, args->hmac);
 80043fa:	f104 0144 	add.w	r1, r4, #68	; 0x44
 80043fe:	4620      	mov	r0, r4
 8004400:	f7ff fad2 	bl	80039a8 <_hmac_attempt>
            _sign_attempt(args);
        }
    }

fail:
    ae_reset_chip();
 8004404:	f7fe fabe 	bl	8002984 <ae_reset_chip>

    if(rv) return EPIN_AE_FAIL;
 8004408:	2d00      	cmp	r5, #0
 800440a:	bf0c      	ite	eq
 800440c:	2500      	moveq	r5, #0
 800440e:	f06f 0569 	mvnne.w	r5, #105	; 0x69
 8004412:	e032      	b.n	800447a <pin_fetch_secret+0x19e>
 8004414:	4605      	mov	r5, r0
 8004416:	e030      	b.n	800447a <pin_fetch_secret+0x19e>
    int rv = _validate_attempt(args, false);
    if(rv) return rv;

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
        // must come here with a successful PIN login (so it's rate limited nicely)
        return EPIN_WRONG_SUCCESS;
 8004418:	f06f 056c 	mvn.w	r5, #108	; 0x6c
 800441c:	e02d      	b.n	800447a <pin_fetch_secret+0x19e>
    }
    if(args->change_flags & CHANGE_DURESS_SECRET) {
        // obsolete API: reading the duress secret from main PIN code (was never used)
        return EPIN_BAD_REQUEST;
 800441e:	f06f 0567 	mvn.w	r5, #103	; 0x67
 8004422:	e02a      	b.n	800447a <pin_fetch_secret+0x19e>
    uint8_t    tmp[AE_SECRET_LEN];
    uint8_t    check[32];

    // default, zero: main secret, otherwise, the spares.
    int kn = keynum_for_secret(args);
    if(kn < 0) return EPIN_RANGE_ERR;
 8004424:	f06f 0566 	mvn.w	r5, #102	; 0x66
 8004428:	e027      	b.n	800447a <pin_fetch_secret+0x19e>
    bool is_trick = get_is_trick(args, &slot);

    if(is_trick && !(slot.tc_flags & TC_DELTA_MODE)) {
        // emulate a 24-word wallet, or xprv based wallet
        // see stash.py for encoding details
        memset(args->secret, 0, AE_SECRET_LEN);
 800442a:	2248      	movs	r2, #72	; 0x48
 800442c:	f104 00b0 	add.w	r0, r4, #176	; 0xb0
 8004430:	f009 f849 	bl	800d4c6 <memset>

        if(slot.tc_flags & TC_WORD_WALLET) {
 8004434:	04f0      	lsls	r0, r6, #19
 8004436:	d50f      	bpl.n	8004458 <pin_fetch_secret+0x17c>
            args->secret[0] = 0x82;         // 24 word phrase
 8004438:	2382      	movs	r3, #130	; 0x82
 800443a:	f884 30b0 	strb.w	r3, [r4, #176]	; 0xb0
            memcpy(&args->secret[1], slot.xdata, 32);
 800443e:	aa17      	add	r2, sp, #92	; 0x5c
 8004440:	34b1      	adds	r4, #177	; 0xb1
 8004442:	ae1f      	add	r6, sp, #124	; 0x7c
 8004444:	4613      	mov	r3, r2
 8004446:	cb03      	ldmia	r3!, {r0, r1}
 8004448:	42b3      	cmp	r3, r6
 800444a:	6020      	str	r0, [r4, #0]
 800444c:	6061      	str	r1, [r4, #4]
 800444e:	461a      	mov	r2, r3
 8004450:	f104 0408 	add.w	r4, r4, #8
 8004454:	d1f6      	bne.n	8004444 <pin_fetch_secret+0x168>
 8004456:	e010      	b.n	800447a <pin_fetch_secret+0x19e>
        } else if(slot.tc_flags & TC_XPRV_WALLET) {
 8004458:	0531      	lsls	r1, r6, #20
 800445a:	d50e      	bpl.n	800447a <pin_fetch_secret+0x19e>
            args->secret[0] = 0x01;         // XPRV mode
 800445c:	2301      	movs	r3, #1
 800445e:	f884 30b0 	strb.w	r3, [r4, #176]	; 0xb0
            memcpy(&args->secret[1], slot.xdata, 64);
 8004462:	aa17      	add	r2, sp, #92	; 0x5c
 8004464:	34b1      	adds	r4, #177	; 0xb1
 8004466:	ae27      	add	r6, sp, #156	; 0x9c
 8004468:	4613      	mov	r3, r2
 800446a:	cb03      	ldmia	r3!, {r0, r1}
 800446c:	42b3      	cmp	r3, r6
 800446e:	6020      	str	r0, [r4, #0]
 8004470:	6061      	str	r1, [r4, #4]
 8004472:	461a      	mov	r2, r3
 8004474:	f104 0408 	add.w	r4, r4, #8
 8004478:	d1f6      	bne.n	8004468 <pin_fetch_secret+0x18c>
    ae_reset_chip();

    if(rv) return EPIN_AE_FAIL;

    return 0;
}
 800447a:	4628      	mov	r0, r5
 800447c:	f50d 7d36 	add.w	sp, sp, #728	; 0x2d8
 8004480:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8004484:	0801e000 	.word	0x0801e000
 8004488:	0801e074 	.word	0x0801e074
 800448c:	0800e474 	.word	0x0800e474

08004490 <pin_long_secret>:
// - new API so whole thing provided in one shot? encryption issues: provide
//   "dest" and all 416 bytes end up there (read case only).
//
    int
pin_long_secret(pinAttempt_t *args, uint8_t *dest)
{
 8004490:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8004494:	460e      	mov	r6, r1
 8004496:	b097      	sub	sp, #92	; 0x5c
    // Validate args and signature
    int rv = _validate_attempt(args, false);
 8004498:	2100      	movs	r1, #0
// - new API so whole thing provided in one shot? encryption issues: provide
//   "dest" and all 416 bytes end up there (read case only).
//
    int
pin_long_secret(pinAttempt_t *args, uint8_t *dest)
{
 800449a:	4605      	mov	r5, r0
    // Validate args and signature
    int rv = _validate_attempt(args, false);
 800449c:	f7ff fab6 	bl	8003a0c <_validate_attempt>
    if(rv) return rv;
 80044a0:	4604      	mov	r4, r0
 80044a2:	2800      	cmp	r0, #0
 80044a4:	f040 809f 	bne.w	80045e6 <pin_long_secret+0x156>

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
 80044a8:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 80044aa:	07db      	lsls	r3, r3, #31
 80044ac:	f140 809d 	bpl.w	80045ea <pin_long_secret+0x15a>
    static bool
get_is_trick(const pinAttempt_t *args, trick_slot_t *slot)
{
    // read and "decrypt" our one flag bit
    // - optional: aes-decrypt some more details about the trick slot
    bool is_trick = ((args->private_state ^ rom_secrets->hash_cache_secret[0]) & 0x1);
 80044b0:	4b53      	ldr	r3, [pc, #332]	; (8004600 <pin_long_secret+0x170>)
    }

    // determine if we should proceed under duress/in some trick way
    bool is_trick = get_is_trick(args, NULL);

    if(is_trick) {
 80044b2:	f893 9070 	ldrb.w	r9, [r3, #112]	; 0x70
 80044b6:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 80044b8:	ea89 0903 	eor.w	r9, r9, r3
 80044bc:	f019 0901 	ands.w	r9, r9, #1
 80044c0:	d00f      	beq.n	80044e2 <pin_long_secret+0x52>
        // Not supported in trick mode. Pretend it's all zeros. Accept all writes.
        memset(args->secret, 0, 32);
 80044c2:	4601      	mov	r1, r0
 80044c4:	2220      	movs	r2, #32
 80044c6:	f105 00b0 	add.w	r0, r5, #176	; 0xb0
 80044ca:	f008 fffc 	bl	800d4c6 <memset>
        if(dest) memset(dest, 0, AE_LONG_SECRET_LEN);
 80044ce:	2e00      	cmp	r6, #0
 80044d0:	f000 8087 	beq.w	80045e2 <pin_long_secret+0x152>
 80044d4:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
 80044d8:	4621      	mov	r1, r4
 80044da:	4630      	mov	r0, r6
 80044dc:	f008 fff3 	bl	800d4c6 <memset>
 80044e0:	e081      	b.n	80045e6 <pin_long_secret+0x156>
        return 0;
    }

    // which 32-byte section?
    STATIC_ASSERT(CHANGE_LS_OFFSET == 0xf00);
    int blk = (args->change_flags >> 8) & 0xf;
 80044e2:	6e6f      	ldr	r7, [r5, #100]	; 0x64
 80044e4:	f3c7 2703 	ubfx	r7, r7, #8, #4
    if(blk > 13) return EPIN_RANGE_ERR;
 80044e8:	2f0d      	cmp	r7, #13
 80044ea:	f300 8081 	bgt.w	80045f0 <pin_long_secret+0x160>

    // fetch the already-hashed pin
    // - no real need to re-prove PIN knowledge.
    // - if they tricked us, doesn't matter as below the SE validates it all again
    uint8_t     digest[32];
    pin_cache_restore(args, digest);
 80044ee:	f10d 0818 	add.w	r8, sp, #24
 80044f2:	4641      	mov	r1, r8
 80044f4:	4628      	mov	r0, r5
 80044f6:	f7ff fc4d 	bl	8003d94 <pin_cache_restore>

    // read/write exactly 32 bytes
    if(!(args->change_flags & CHANGE_SECRET)) {
 80044fa:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 80044fc:	f013 0308 	ands.w	r3, r3, #8
 8004500:	d14c      	bne.n	800459c <pin_long_secret+0x10c>
        if(!dest) {
 8004502:	b9f6      	cbnz	r6, 8004542 <pin_long_secret+0xb2>
            uint8_t     tmp[32];

            rv = ae_encrypted_read32(KEYNUM_long_secret, blk, KEYNUM_main_pin, digest, tmp);
 8004504:	ae0e      	add	r6, sp, #56	; 0x38
 8004506:	9600      	str	r6, [sp, #0]
 8004508:	4643      	mov	r3, r8
 800450a:	2203      	movs	r2, #3
 800450c:	4639      	mov	r1, r7
 800450e:	2008      	movs	r0, #8
 8004510:	f7fe fe61 	bl	80031d6 <ae_encrypted_read32>
            if(rv) goto fail;
 8004514:	4604      	mov	r4, r0
 8004516:	2800      	cmp	r0, #0
 8004518:	d160      	bne.n	80045dc <pin_long_secret+0x14c>

            bool is_valid;
            se2_decrypt_secret(args->secret, 32, blk*32, tmp, NULL, digest, &is_valid);
 800451a:	f10d 0317 	add.w	r3, sp, #23
 800451e:	35b0      	adds	r5, #176	; 0xb0
 8004520:	9302      	str	r3, [sp, #8]
 8004522:	e88d 0110 	stmia.w	sp, {r4, r8}
 8004526:	4633      	mov	r3, r6
 8004528:	017a      	lsls	r2, r7, #5
 800452a:	2120      	movs	r1, #32
 800452c:	4628      	mov	r0, r5
 800452e:	f003 fde9 	bl	8008104 <se2_decrypt_secret>
            if(!is_valid) {
 8004532:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8004536:	2b00      	cmp	r3, #0
 8004538:	d150      	bne.n	80045dc <pin_long_secret+0x14c>
                // no encryption key yet, so assume blank
                memset(args->secret, 0, 32);
 800453a:	2220      	movs	r2, #32
 800453c:	4621      	mov	r1, r4
 800453e:	4628      	mov	r0, r5
 8004540:	e029      	b.n	8004596 <pin_long_secret+0x106>
 8004542:	4637      	mov	r7, r6
 8004544:	461d      	mov	r5, r3
                rv = 0;
            }
        } else {
            uint8_t *p = dest;
            for(blk=0; blk<13; blk++, p += 32) {
                rv = ae_encrypted_read32(KEYNUM_long_secret, blk, KEYNUM_main_pin, digest, p);
 8004546:	9700      	str	r7, [sp, #0]
 8004548:	4643      	mov	r3, r8
 800454a:	2203      	movs	r2, #3
 800454c:	4629      	mov	r1, r5
 800454e:	2008      	movs	r0, #8
 8004550:	f7fe fe41 	bl	80031d6 <ae_encrypted_read32>
                if(rv) goto fail;
 8004554:	4604      	mov	r4, r0
 8004556:	2800      	cmp	r0, #0
 8004558:	d140      	bne.n	80045dc <pin_long_secret+0x14c>
                memset(args->secret, 0, 32);
                rv = 0;
            }
        } else {
            uint8_t *p = dest;
            for(blk=0; blk<13; blk++, p += 32) {
 800455a:	3501      	adds	r5, #1
 800455c:	2d0d      	cmp	r5, #13
 800455e:	f107 0720 	add.w	r7, r7, #32
 8004562:	d1f0      	bne.n	8004546 <pin_long_secret+0xb6>
                rv = ae_encrypted_read32(KEYNUM_long_secret, blk, KEYNUM_main_pin, digest, p);
                if(rv) goto fail;
            }
            ASSERT(p == dest+AE_LONG_SECRET_LEN);
 8004564:	f506 73d0 	add.w	r3, r6, #416	; 0x1a0
 8004568:	429f      	cmp	r7, r3
 800456a:	d002      	beq.n	8004572 <pin_long_secret+0xe2>
 800456c:	4825      	ldr	r0, [pc, #148]	; (8004604 <pin_long_secret+0x174>)
 800456e:	f7fc fa35 	bl	80009dc <fatal_error>

            // decrypt in one step (big time savings here)
            bool is_valid;
            se2_decrypt_secret(dest, AE_LONG_SECRET_LEN, 0, dest, NULL, digest, &is_valid);
 8004572:	ab0e      	add	r3, sp, #56	; 0x38
 8004574:	9302      	str	r3, [sp, #8]
 8004576:	4602      	mov	r2, r0
 8004578:	4633      	mov	r3, r6
 800457a:	e88d 0110 	stmia.w	sp, {r4, r8}
 800457e:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 8004582:	4630      	mov	r0, r6
 8004584:	f003 fdbe 	bl	8008104 <se2_decrypt_secret>
            if(!is_valid) {
 8004588:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
 800458c:	bb33      	cbnz	r3, 80045dc <pin_long_secret+0x14c>
                // no encryption key yet, so assume blank
                memset(dest, 0, AE_LONG_SECRET_LEN);
 800458e:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
 8004592:	4621      	mov	r1, r4
 8004594:	4630      	mov	r0, r6
 8004596:	f008 ff96 	bl	800d4c6 <memset>
 800459a:	e01f      	b.n	80045dc <pin_long_secret+0x14c>
                rv = 0;
            }
        }
    } else {
        // write case, does not update check
        uint8_t tmp[32] = {0};
 800459c:	ac0e      	add	r4, sp, #56	; 0x38
 800459e:	2220      	movs	r2, #32
 80045a0:	4649      	mov	r1, r9
 80045a2:	4620      	mov	r0, r4
 80045a4:	f008 ff8f 	bl	800d4c6 <memset>

        if(se2_encrypt_secret(args->secret, 32, blk*32, tmp, NULL, digest)) {
 80045a8:	f8cd 8004 	str.w	r8, [sp, #4]
 80045ac:	f8cd 9000 	str.w	r9, [sp]
 80045b0:	4623      	mov	r3, r4
 80045b2:	017a      	lsls	r2, r7, #5
 80045b4:	2120      	movs	r1, #32
 80045b6:	f105 00b0 	add.w	r0, r5, #176	; 0xb0
 80045ba:	f003 fd53 	bl	8008064 <se2_encrypt_secret>
 80045be:	b940      	cbnz	r0, 80045d2 <pin_long_secret+0x142>
            // can happen if secret not set yet, can't work since we can't
            // write the check value.
            goto se2_fail;
        }

        rv = ae_encrypted_write32(KEYNUM_long_secret, blk, KEYNUM_main_pin, digest, tmp);
 80045c0:	9400      	str	r4, [sp, #0]
 80045c2:	4643      	mov	r3, r8
 80045c4:	2203      	movs	r2, #3
 80045c6:	4639      	mov	r1, r7
 80045c8:	2008      	movs	r0, #8
 80045ca:	f7fe fe67 	bl	800329c <ae_encrypted_write32>
 80045ce:	4604      	mov	r4, r0
 80045d0:	e004      	b.n	80045dc <pin_long_secret+0x14c>
    if(rv) return EPIN_AE_FAIL;

    return 0;

se2_fail:
    ae_reset_chip();
 80045d2:	f7fe f9d7 	bl	8002984 <ae_reset_chip>

    return EPIN_SE2_FAIL;
 80045d6:	f06f 0072 	mvn.w	r0, #114	; 0x72
 80045da:	e00e      	b.n	80045fa <pin_long_secret+0x16a>

        rv = ae_encrypted_write32(KEYNUM_long_secret, blk, KEYNUM_main_pin, digest, tmp);
    }

fail:
    ae_reset_chip();
 80045dc:	f7fe f9d2 	bl	8002984 <ae_reset_chip>

    if(rv) return EPIN_AE_FAIL;
 80045e0:	b94c      	cbnz	r4, 80045f6 <pin_long_secret+0x166>

    return 0;
 80045e2:	2000      	movs	r0, #0
 80045e4:	e009      	b.n	80045fa <pin_long_secret+0x16a>
 80045e6:	4620      	mov	r0, r4
 80045e8:	e007      	b.n	80045fa <pin_long_secret+0x16a>
    int rv = _validate_attempt(args, false);
    if(rv) return rv;

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
        // must come here with a successful PIN login (so it's rate limited nicely)
        return EPIN_WRONG_SUCCESS;
 80045ea:	f06f 006c 	mvn.w	r0, #108	; 0x6c
 80045ee:	e004      	b.n	80045fa <pin_long_secret+0x16a>
    }

    // which 32-byte section?
    STATIC_ASSERT(CHANGE_LS_OFFSET == 0xf00);
    int blk = (args->change_flags >> 8) & 0xf;
    if(blk > 13) return EPIN_RANGE_ERR;
 80045f0:	f06f 0066 	mvn.w	r0, #102	; 0x66
 80045f4:	e001      	b.n	80045fa <pin_long_secret+0x16a>
    }

fail:
    ae_reset_chip();

    if(rv) return EPIN_AE_FAIL;
 80045f6:	f06f 0069 	mvn.w	r0, #105	; 0x69

se2_fail:
    ae_reset_chip();

    return EPIN_SE2_FAIL;
}
 80045fa:	b017      	add	sp, #92	; 0x5c
 80045fc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8004600:	0801e000 	.word	0x0801e000
 8004604:	0800d550 	.word	0x0800d550

08004608 <pin_firmware_greenlight>:
//
// Record current flash checksum and make green light go on.
//
    int
pin_firmware_greenlight(pinAttempt_t *args)
{
 8004608:	b530      	push	{r4, r5, lr}
    // Validate args and signature
    int rv = _validate_attempt(args, false);
 800460a:	2100      	movs	r1, #0
//
// Record current flash checksum and make green light go on.
//
    int
pin_firmware_greenlight(pinAttempt_t *args)
{
 800460c:	b09b      	sub	sp, #108	; 0x6c
 800460e:	4605      	mov	r5, r0
    // Validate args and signature
    int rv = _validate_attempt(args, false);
 8004610:	f7ff f9fc 	bl	8003a0c <_validate_attempt>
    if(rv) return rv;
 8004614:	bb58      	cbnz	r0, 800466e <pin_firmware_greenlight+0x66>

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
 8004616:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8004618:	07da      	lsls	r2, r3, #31
 800461a:	d52a      	bpl.n	8004672 <pin_firmware_greenlight+0x6a>
        // must come here with a successful PIN login (so it's rate limited nicely)
        return EPIN_WRONG_SUCCESS;
    }

    if(args->is_secondary) {
 800461c:	686c      	ldr	r4, [r5, #4]
 800461e:	bb5c      	cbnz	r4, 8004678 <pin_firmware_greenlight+0x70>
        return EPIN_PRIMARY_ONLY;
    }

    // load existing PIN's hash
    uint8_t     digest[32];
    pin_cache_restore(args, digest);
 8004620:	a902      	add	r1, sp, #8
 8004622:	4628      	mov	r0, r5
 8004624:	f7ff fbb6 	bl	8003d94 <pin_cache_restore>

    // step 1: calc the value to use
    uint8_t fw_check[32], world_check[32];
    checksum_flash(fw_check, world_check, 0);
 8004628:	4622      	mov	r2, r4
 800462a:	a912      	add	r1, sp, #72	; 0x48
 800462c:	a80a      	add	r0, sp, #40	; 0x28
 800462e:	f7fd fa23 	bl	8001a78 <checksum_flash>

    // step 2: write it out to chip.
    if(warmup_ae()) return EPIN_I_AM_BRICK;
 8004632:	f7ff fa23 	bl	8003a7c <warmup_ae>
 8004636:	4604      	mov	r4, r0
 8004638:	bb08      	cbnz	r0, 800467e <pin_firmware_greenlight+0x76>
    static bool
get_is_trick(const pinAttempt_t *args, trick_slot_t *slot)
{
    // read and "decrypt" our one flag bit
    // - optional: aes-decrypt some more details about the trick slot
    bool is_trick = ((args->private_state ^ rom_secrets->hash_cache_secret[0]) & 0x1);
 800463a:	4b13      	ldr	r3, [pc, #76]	; (8004688 <pin_firmware_greenlight+0x80>)

    // step 2: write it out to chip.
    if(warmup_ae()) return EPIN_I_AM_BRICK;

    // under duress, we can't fake this, but we go through the motions anyway
    if(!get_is_trick(args, NULL)) {
 800463c:	f893 2070 	ldrb.w	r2, [r3, #112]	; 0x70
 8004640:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 8004642:	4053      	eors	r3, r2
 8004644:	07db      	lsls	r3, r3, #31
 8004646:	d40d      	bmi.n	8004664 <pin_firmware_greenlight+0x5c>
        rv = ae_encrypted_write(KEYNUM_firmware, KEYNUM_main_pin, digest, world_check, 32);
 8004648:	2320      	movs	r3, #32
 800464a:	9300      	str	r3, [sp, #0]
 800464c:	aa02      	add	r2, sp, #8
 800464e:	ab12      	add	r3, sp, #72	; 0x48
 8004650:	2103      	movs	r1, #3
 8004652:	200e      	movs	r0, #14
 8004654:	f7fe fe8a 	bl	800336c <ae_encrypted_write>

        if(rv) {
 8004658:	b120      	cbz	r0, 8004664 <pin_firmware_greenlight+0x5c>
            ae_reset_chip();
 800465a:	f7fe f993 	bl	8002984 <ae_reset_chip>

            return EPIN_AE_FAIL;
 800465e:	f06f 0469 	mvn.w	r4, #105	; 0x69
 8004662:	e00e      	b.n	8004682 <pin_firmware_greenlight+0x7a>
        }
    }

    // turn on light
    rv = ae_set_gpio_secure(world_check);
 8004664:	a812      	add	r0, sp, #72	; 0x48
 8004666:	f7fe ff0e 	bl	8003486 <ae_set_gpio_secure>
    if(rv) {
 800466a:	b150      	cbz	r0, 8004682 <pin_firmware_greenlight+0x7a>
 800466c:	e7f5      	b.n	800465a <pin_firmware_greenlight+0x52>
 800466e:	4604      	mov	r4, r0
 8004670:	e007      	b.n	8004682 <pin_firmware_greenlight+0x7a>
    int rv = _validate_attempt(args, false);
    if(rv) return rv;

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
        // must come here with a successful PIN login (so it's rate limited nicely)
        return EPIN_WRONG_SUCCESS;
 8004672:	f06f 046c 	mvn.w	r4, #108	; 0x6c
 8004676:	e004      	b.n	8004682 <pin_firmware_greenlight+0x7a>
    }

    if(args->is_secondary) {
        // only main PIN holder can do this
        return EPIN_PRIMARY_ONLY;
 8004678:	f06f 0471 	mvn.w	r4, #113	; 0x71
 800467c:	e001      	b.n	8004682 <pin_firmware_greenlight+0x7a>
    // step 1: calc the value to use
    uint8_t fw_check[32], world_check[32];
    checksum_flash(fw_check, world_check, 0);

    // step 2: write it out to chip.
    if(warmup_ae()) return EPIN_I_AM_BRICK;
 800467e:	f06f 0468 	mvn.w	r4, #104	; 0x68

        return EPIN_AE_FAIL;
    }

    return 0;
}
 8004682:	4620      	mov	r0, r4
 8004684:	b01b      	add	sp, #108	; 0x6c
 8004686:	bd30      	pop	{r4, r5, pc}
 8004688:	0801e000 	.word	0x0801e000

0800468c <pin_firmware_upgrade>:
// Update the system firmware via file in PSRAM. Arrange for 
// light to stay green through out process.
//
    int
pin_firmware_upgrade(pinAttempt_t *args)
{
 800468c:	b570      	push	{r4, r5, r6, lr}
    // Validate args and signature
    int rv = _validate_attempt(args, false);
 800468e:	2100      	movs	r1, #0
// Update the system firmware via file in PSRAM. Arrange for 
// light to stay green through out process.
//
    int
pin_firmware_upgrade(pinAttempt_t *args)
{
 8004690:	b092      	sub	sp, #72	; 0x48
 8004692:	4604      	mov	r4, r0
    // Validate args and signature
    int rv = _validate_attempt(args, false);
 8004694:	f7ff f9ba 	bl	8003a0c <_validate_attempt>
    if(rv) return rv;
 8004698:	2800      	cmp	r0, #0
 800469a:	d15d      	bne.n	8004758 <pin_firmware_upgrade+0xcc>

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
 800469c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800469e:	07da      	lsls	r2, r3, #31
 80046a0:	d54c      	bpl.n	800473c <pin_firmware_upgrade+0xb0>
        // must come here with a successful PIN login
        return EPIN_WRONG_SUCCESS;
    }

    if(args->change_flags != CHANGE_FIRMWARE) {
 80046a2:	6e63      	ldr	r3, [r4, #100]	; 0x64
 80046a4:	2b40      	cmp	r3, #64	; 0x40
 80046a6:	d14c      	bne.n	8004742 <pin_firmware_upgrade+0xb6>
    }

    // expecting start/length relative to psram start
    uint32_t *about = (uint32_t *)args->secret;
    uint32_t start = about[0];
    uint32_t len = about[1];
 80046a8:	f8d4 60b4 	ldr.w	r6, [r4, #180]	; 0xb4
        return EPIN_BAD_REQUEST;
    }

    // expecting start/length relative to psram start
    uint32_t *about = (uint32_t *)args->secret;
    uint32_t start = about[0];
 80046ac:	f8d4 50b0 	ldr.w	r5, [r4, #176]	; 0xb0
    uint32_t len = about[1];

    if(len < 32768) return EPIN_RANGE_ERR;
 80046b0:	f5a6 4300 	sub.w	r3, r6, #32768	; 0x8000
 80046b4:	f5b3 1ffc 	cmp.w	r3, #2064384	; 0x1f8000
 80046b8:	d846      	bhi.n	8004748 <pin_firmware_upgrade+0xbc>
    if(len > 2<<20) return EPIN_RANGE_ERR;
    if(start+len > PSRAM_SIZE) return EPIN_RANGE_ERR;
 80046ba:	19ab      	adds	r3, r5, r6
 80046bc:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 80046c0:	d842      	bhi.n	8004748 <pin_firmware_upgrade+0xbc>

    const uint8_t *data = (const uint8_t *)PSRAM_BASE+start;
 80046c2:	f105 4510 	add.w	r5, r5, #2415919104	; 0x90000000

    // verify a firmware image that's in RAM, and calc its digest
    // - also applies watermark policy, etc
    uint8_t world_check[32];
    bool ok = verify_firmware_in_ram(data, len, world_check);
 80046c6:	aa02      	add	r2, sp, #8
 80046c8:	4631      	mov	r1, r6
 80046ca:	4628      	mov	r0, r5
 80046cc:	f7fd fae4 	bl	8001c98 <verify_firmware_in_ram>
    if(!ok) {
 80046d0:	2800      	cmp	r0, #0
 80046d2:	d03c      	beq.n	800474e <pin_firmware_upgrade+0xc2>
    static bool
get_is_trick(const pinAttempt_t *args, trick_slot_t *slot)
{
    // read and "decrypt" our one flag bit
    // - optional: aes-decrypt some more details about the trick slot
    bool is_trick = ((args->private_state ^ rom_secrets->hash_cache_secret[0]) & 0x1);
 80046d4:	4b21      	ldr	r3, [pc, #132]	; (800475c <pin_firmware_upgrade+0xd0>)
    if(!ok) {
        return EPIN_AUTH_FAIL;
    }

    // under duress, we can't fake this, so kill ourselves.
    if(get_is_trick(args, NULL)) {
 80046d6:	f893 2070 	ldrb.w	r2, [r3, #112]	; 0x70
 80046da:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80046dc:	4053      	eors	r3, r2
 80046de:	07db      	lsls	r3, r3, #31
 80046e0:	d502      	bpl.n	80046e8 <pin_firmware_upgrade+0x5c>
        // User is a thug.. kill secret and reboot w/o any notice
        fast_wipe();
 80046e2:	f7fd ff8b 	bl	80025fc <fast_wipe>
 80046e6:	e02c      	b.n	8004742 <pin_firmware_upgrade+0xb6>
        return EPIN_BAD_REQUEST;
    }

    // load existing PIN's hash
    uint8_t     digest[32];
    pin_cache_restore(args, digest);
 80046e8:	a90a      	add	r1, sp, #40	; 0x28
 80046ea:	4620      	mov	r0, r4
 80046ec:	f7ff fb52 	bl	8003d94 <pin_cache_restore>

    // step 1: calc the value to use, see above
    if(warmup_ae()) return EPIN_I_AM_BRICK;
 80046f0:	f7ff f9c4 	bl	8003a7c <warmup_ae>
 80046f4:	bb70      	cbnz	r0, 8004754 <pin_firmware_upgrade+0xc8>

    // step 2: write it out to chip.
    rv = ae_encrypted_write(KEYNUM_firmware, KEYNUM_main_pin, digest, world_check, 32);
 80046f6:	2320      	movs	r3, #32
 80046f8:	9300      	str	r3, [sp, #0]
 80046fa:	aa0a      	add	r2, sp, #40	; 0x28
 80046fc:	ab02      	add	r3, sp, #8
 80046fe:	2103      	movs	r1, #3
 8004700:	200e      	movs	r0, #14
 8004702:	f7fe fe33 	bl	800336c <ae_encrypted_write>
    if(rv) goto fail;
 8004706:	b9a0      	cbnz	r0, 8004732 <pin_firmware_upgrade+0xa6>

    // turn on light? maybe not idk
    rv = ae_set_gpio_secure(world_check);
 8004708:	a802      	add	r0, sp, #8
 800470a:	f7fe febc 	bl	8003486 <ae_set_gpio_secure>
    if(rv) goto fail;
 800470e:	b980      	cbnz	r0, 8004732 <pin_firmware_upgrade+0xa6>

    // -- point of no return -- 

    // burn it, shows progress
    psram_do_upgrade(data, len);
 8004710:	4631      	mov	r1, r6
 8004712:	4628      	mov	r0, r5
 8004714:	f000 fc08 	bl	8004f28 <psram_do_upgrade>
 8004718:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800471c:	4910      	ldr	r1, [pc, #64]	; (8004760 <pin_firmware_upgrade+0xd4>)
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800471e:	4b11      	ldr	r3, [pc, #68]	; (8004764 <pin_firmware_upgrade+0xd8>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8004720:	68ca      	ldr	r2, [r1, #12]
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8004722:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8004726:	4313      	orrs	r3, r2
 8004728:	60cb      	str	r3, [r1, #12]
 800472a:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 800472e:	bf00      	nop
 8004730:	e7fd      	b.n	800472e <pin_firmware_upgrade+0xa2>
    NVIC_SystemReset();

    return 0;

fail:
    ae_reset_chip();
 8004732:	f7fe f927 	bl	8002984 <ae_reset_chip>

    return EPIN_AE_FAIL;
 8004736:	f06f 0069 	mvn.w	r0, #105	; 0x69
 800473a:	e00d      	b.n	8004758 <pin_firmware_upgrade+0xcc>
    int rv = _validate_attempt(args, false);
    if(rv) return rv;

    if((args->state_flags & PA_SUCCESSFUL) != PA_SUCCESSFUL) {
        // must come here with a successful PIN login
        return EPIN_WRONG_SUCCESS;
 800473c:	f06f 006c 	mvn.w	r0, #108	; 0x6c
 8004740:	e00a      	b.n	8004758 <pin_firmware_upgrade+0xcc>
    }

    if(args->change_flags != CHANGE_FIRMWARE) {
        return EPIN_BAD_REQUEST;
 8004742:	f06f 0067 	mvn.w	r0, #103	; 0x67
 8004746:	e007      	b.n	8004758 <pin_firmware_upgrade+0xcc>
    // expecting start/length relative to psram start
    uint32_t *about = (uint32_t *)args->secret;
    uint32_t start = about[0];
    uint32_t len = about[1];

    if(len < 32768) return EPIN_RANGE_ERR;
 8004748:	f06f 0066 	mvn.w	r0, #102	; 0x66
 800474c:	e004      	b.n	8004758 <pin_firmware_upgrade+0xcc>
    // verify a firmware image that's in RAM, and calc its digest
    // - also applies watermark policy, etc
    uint8_t world_check[32];
    bool ok = verify_firmware_in_ram(data, len, world_check);
    if(!ok) {
        return EPIN_AUTH_FAIL;
 800474e:	f06f 006f 	mvn.w	r0, #111	; 0x6f
 8004752:	e001      	b.n	8004758 <pin_firmware_upgrade+0xcc>
    // load existing PIN's hash
    uint8_t     digest[32];
    pin_cache_restore(args, digest);

    // step 1: calc the value to use, see above
    if(warmup_ae()) return EPIN_I_AM_BRICK;
 8004754:	f06f 0068 	mvn.w	r0, #104	; 0x68

fail:
    ae_reset_chip();

    return EPIN_AE_FAIL;
}
 8004758:	b012      	add	sp, #72	; 0x48
 800475a:	bd70      	pop	{r4, r5, r6, pc}
 800475c:	0801e000 	.word	0x0801e000
 8004760:	e000ed00 	.word	0xe000ed00
 8004764:	05fa0004 	.word	0x05fa0004

08004768 <strcat_hex>:

// strcat_hex()
//
	void
strcat_hex(char *msg, const void *d, int len)
{
 8004768:	b570      	push	{r4, r5, r6, lr}
 800476a:	4605      	mov	r5, r0
 800476c:	4616      	mov	r6, r2
 800476e:	460c      	mov	r4, r1
	char *p = msg+strlen(msg);
 8004770:	f008 fed5 	bl	800d51e <strlen>
	const uint8_t *h = (const uint8_t *)d;

	for(; len; len--, h++) {
		*(p++) = hexmap[(*h>>4) & 0xf];
 8004774:	4a0c      	ldr	r2, [pc, #48]	; (80047a8 <strcat_hex+0x40>)
// strcat_hex()
//
	void
strcat_hex(char *msg, const void *d, int len)
{
	char *p = msg+strlen(msg);
 8004776:	4428      	add	r0, r5
 8004778:	4603      	mov	r3, r0
 800477a:	19a5      	adds	r5, r4, r6
	const uint8_t *h = (const uint8_t *)d;

	for(; len; len--, h++) {
 800477c:	42ac      	cmp	r4, r5
 800477e:	f103 0302 	add.w	r3, r3, #2
 8004782:	d00c      	beq.n	800479e <strcat_hex+0x36>
		*(p++) = hexmap[(*h>>4) & 0xf];
 8004784:	7821      	ldrb	r1, [r4, #0]
 8004786:	0909      	lsrs	r1, r1, #4
 8004788:	5c51      	ldrb	r1, [r2, r1]
 800478a:	f803 1c02 	strb.w	r1, [r3, #-2]
		*(p++) = hexmap[(*h>>0) & 0xf];
 800478e:	f814 1b01 	ldrb.w	r1, [r4], #1
 8004792:	f001 010f 	and.w	r1, r1, #15
 8004796:	5c51      	ldrb	r1, [r2, r1]
 8004798:	f803 1c01 	strb.w	r1, [r3, #-1]
 800479c:	e7ee      	b.n	800477c <strcat_hex+0x14>
	}

	*(p++) = 0;
 800479e:	2300      	movs	r3, #0
 80047a0:	f800 3016 	strb.w	r3, [r0, r6, lsl #1]
 80047a4:	bd70      	pop	{r4, r5, r6, pc}
 80047a6:	bf00      	nop
 80047a8:	0800e4a6 	.word	0x0800e4a6

080047ac <HAL_USART_Init>:
  *         parameters in the USART_InitTypeDef and initialize the associated handle.
  * @param  husart USART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_USART_Init(USART_HandleTypeDef *husart)
{
 80047ac:	b538      	push	{r3, r4, r5, lr}
  /* Check the USART handle allocation */
  if (husart == NULL)
 80047ae:	4604      	mov	r4, r0
 80047b0:	b908      	cbnz	r0, 80047b6 <HAL_USART_Init+0xa>
  {
    return HAL_ERROR;
 80047b2:	2001      	movs	r0, #1
 80047b4:	bd38      	pop	{r3, r4, r5, pc}
  }

  /* Check the parameters */
  assert_param(IS_USART_INSTANCE(husart->Instance));

  if (husart->State == HAL_USART_STATE_RESET)
 80047b6:	f890 3059 	ldrb.w	r3, [r0, #89]	; 0x59
 80047ba:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80047be:	b90b      	cbnz	r3, 80047c4 <HAL_USART_Init+0x18>
  {
    /* Allocate lock resource and initialize it */
    husart->Lock = HAL_UNLOCKED;
 80047c0:	f880 2058 	strb.w	r2, [r0, #88]	; 0x58
  }

  husart->State = HAL_USART_STATE_BUSY;

  /* Disable the Peripheral */
  __HAL_USART_DISABLE(husart);
 80047c4:	6822      	ldr	r2, [r4, #0]
  *  set the M bits according to husart->Init.WordLength value
  *  set PCE and PS bits according to husart->Init.Parity value
  *  set TE and RE bits according to husart->Init.Mode value
  *  force OVER8 to 1 to allow to reach the maximum speed (Fclock/8) */
  tmpreg = (uint32_t)husart->Init.WordLength | husart->Init.Parity | husart->Init.Mode | USART_CR1_OVER8;
  MODIFY_REG(husart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80047c6:	68a1      	ldr	r1, [r4, #8]
  {
    /* Allocate lock resource and initialize it */
    husart->Lock = HAL_UNLOCKED;
  }

  husart->State = HAL_USART_STATE_BUSY;
 80047c8:	2302      	movs	r3, #2
 80047ca:	f884 3059 	strb.w	r3, [r4, #89]	; 0x59

  /* Disable the Peripheral */
  __HAL_USART_DISABLE(husart);
 80047ce:	6813      	ldr	r3, [r2, #0]
 80047d0:	f023 0301 	bic.w	r3, r3, #1
 80047d4:	6013      	str	r3, [r2, #0]
  *  set the M bits according to husart->Init.WordLength value
  *  set PCE and PS bits according to husart->Init.Parity value
  *  set TE and RE bits according to husart->Init.Mode value
  *  force OVER8 to 1 to allow to reach the maximum speed (Fclock/8) */
  tmpreg = (uint32_t)husart->Init.WordLength | husart->Init.Parity | husart->Init.Mode | USART_CR1_OVER8;
  MODIFY_REG(husart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80047d6:	6923      	ldr	r3, [r4, #16]
 80047d8:	6810      	ldr	r0, [r2, #0]
 80047da:	430b      	orrs	r3, r1
 80047dc:	6961      	ldr	r1, [r4, #20]
 80047de:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80047e2:	4319      	orrs	r1, r3
 80047e4:	4b9d      	ldr	r3, [pc, #628]	; (8004a5c <HAL_USART_Init+0x2b0>)
 80047e6:	4003      	ands	r3, r0
 80047e8:	430b      	orrs	r3, r1
 80047ea:	6013      	str	r3, [r2, #0]
   * set CPHA bit according to husart->Init.CLKPhase value
   * set LBCL bit according to husart->Init.CLKLastBit value (used in SPI master mode only)
   * set STOP[13:12] bits according to husart->Init.StopBits value */
  tmpreg = (uint32_t)(USART_CLOCK_ENABLE);
  tmpreg |= (uint32_t)husart->Init.CLKLastBit;
  tmpreg |= ((uint32_t)husart->Init.CLKPolarity | (uint32_t)husart->Init.CLKPhase);
 80047ec:	6a21      	ldr	r1, [r4, #32]
 80047ee:	69a3      	ldr	r3, [r4, #24]
 80047f0:	69e0      	ldr	r0, [r4, #28]
 80047f2:	430b      	orrs	r3, r1
 80047f4:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  tmpreg |= (uint32_t)husart->Init.StopBits;
  MODIFY_REG(husart->Instance->CR2, USART_CR2_FIELDS, tmpreg);
 80047f8:	6851      	ldr	r1, [r2, #4]
   * set CPHA bit according to husart->Init.CLKPhase value
   * set LBCL bit according to husart->Init.CLKLastBit value (used in SPI master mode only)
   * set STOP[13:12] bits according to husart->Init.StopBits value */
  tmpreg = (uint32_t)(USART_CLOCK_ENABLE);
  tmpreg |= (uint32_t)husart->Init.CLKLastBit;
  tmpreg |= ((uint32_t)husart->Init.CLKPolarity | (uint32_t)husart->Init.CLKPhase);
 80047fa:	4303      	orrs	r3, r0
  tmpreg |= (uint32_t)husart->Init.StopBits;
  MODIFY_REG(husart->Instance->CR2, USART_CR2_FIELDS, tmpreg);
 80047fc:	68e0      	ldr	r0, [r4, #12]
 80047fe:	4318      	orrs	r0, r3
 8004800:	f421 537c 	bic.w	r3, r1, #16128	; 0x3f00
 8004804:	f023 0309 	bic.w	r3, r3, #9
 8004808:	4303      	orrs	r3, r0
 800480a:	6053      	str	r3, [r2, #4]

#if defined(USART_PRESC_PRESCALER)
  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
   * - USART Clock Prescaler : set PRESCALER according to husart->Init.ClockPrescaler value */
  MODIFY_REG(husart->Instance->PRESC, USART_PRESC_PRESCALER, husart->Init.ClockPrescaler);
 800480c:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 800480e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004810:	f021 010f 	bic.w	r1, r1, #15
 8004814:	4319      	orrs	r1, r3
 8004816:	62d1      	str	r1, [r2, #44]	; 0x2c
#endif /* USART_PRESC_PRESCALER */

  /*-------------------------- USART BRR Configuration -----------------------*/
  /* BRR is filled-up according to OVER8 bit setting which is forced to 1     */
  USART_GETCLOCKSOURCE(husart, clocksource);
 8004818:	4991      	ldr	r1, [pc, #580]	; (8004a60 <HAL_USART_Init+0x2b4>)
 800481a:	428a      	cmp	r2, r1
 800481c:	d106      	bne.n	800482c <HAL_USART_Init+0x80>
 800481e:	4a91      	ldr	r2, [pc, #580]	; (8004a64 <HAL_USART_Init+0x2b8>)
 8004820:	4991      	ldr	r1, [pc, #580]	; (8004a68 <HAL_USART_Init+0x2bc>)
 8004822:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 8004826:	f002 0203 	and.w	r2, r2, #3
 800482a:	e008      	b.n	800483e <HAL_USART_Init+0x92>
 800482c:	498f      	ldr	r1, [pc, #572]	; (8004a6c <HAL_USART_Init+0x2c0>)
 800482e:	428a      	cmp	r2, r1
 8004830:	d110      	bne.n	8004854 <HAL_USART_Init+0xa8>
 8004832:	4a8c      	ldr	r2, [pc, #560]	; (8004a64 <HAL_USART_Init+0x2b8>)
 8004834:	498e      	ldr	r1, [pc, #568]	; (8004a70 <HAL_USART_Init+0x2c4>)
 8004836:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 800483a:	f002 020c 	and.w	r2, r2, #12
 800483e:	5c8a      	ldrb	r2, [r1, r2]

  switch (clocksource)
 8004840:	2a08      	cmp	r2, #8
 8004842:	f200 80d5 	bhi.w	80049f0 <HAL_USART_Init+0x244>
 8004846:	e8df f002 	tbb	[pc, r2]
 800484a:	1b18      	.short	0x1b18
 800484c:	d354d31e 	.word	0xd354d31e
 8004850:	d3d3      	.short	0xd3d3
 8004852:	90          	.byte	0x90
 8004853:	00          	.byte	0x00
  MODIFY_REG(husart->Instance->PRESC, USART_PRESC_PRESCALER, husart->Init.ClockPrescaler);
#endif /* USART_PRESC_PRESCALER */

  /*-------------------------- USART BRR Configuration -----------------------*/
  /* BRR is filled-up according to OVER8 bit setting which is forced to 1     */
  USART_GETCLOCKSOURCE(husart, clocksource);
 8004854:	4987      	ldr	r1, [pc, #540]	; (8004a74 <HAL_USART_Init+0x2c8>)
 8004856:	428a      	cmp	r2, r1
 8004858:	f040 80ca 	bne.w	80049f0 <HAL_USART_Init+0x244>
 800485c:	4a81      	ldr	r2, [pc, #516]	; (8004a64 <HAL_USART_Init+0x2b8>)
 800485e:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 8004862:	f002 0230 	and.w	r2, r2, #48	; 0x30
 8004866:	2a10      	cmp	r2, #16
 8004868:	d043      	beq.n	80048f2 <HAL_USART_Init+0x146>
 800486a:	d801      	bhi.n	8004870 <HAL_USART_Init+0xc4>
 800486c:	b12a      	cbz	r2, 800487a <HAL_USART_Init+0xce>
 800486e:	e0bf      	b.n	80049f0 <HAL_USART_Init+0x244>
 8004870:	2a20      	cmp	r2, #32
 8004872:	d008      	beq.n	8004886 <HAL_USART_Init+0xda>
 8004874:	2a30      	cmp	r2, #48	; 0x30
 8004876:	d078      	beq.n	800496a <HAL_USART_Init+0x1be>
 8004878:	e0ba      	b.n	80049f0 <HAL_USART_Init+0x244>

  switch (clocksource)
  {
    case USART_CLOCKSOURCE_PCLK1:
      pclk = HAL_RCC_GetPCLK1Freq();
 800487a:	f004 fa6b 	bl	8008d54 <HAL_RCC_GetPCLK1Freq>
 800487e:	e03a      	b.n	80048f6 <HAL_USART_Init+0x14a>
#else
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(pclk, husart->Init.BaudRate));
#endif /* USART_PRESC_PRESCALER */
      break;
    case USART_CLOCKSOURCE_PCLK2:
      pclk = HAL_RCC_GetPCLK2Freq();
 8004880:	f004 fa7a 	bl	8008d78 <HAL_RCC_GetPCLK2Freq>
 8004884:	e037      	b.n	80048f6 <HAL_USART_Init+0x14a>
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(pclk, husart->Init.BaudRate));
#endif /* USART_PRESC_PRESCALER */
      break;
    case USART_CLOCKSOURCE_HSI:
#if defined(USART_PRESC_PRESCALER)
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(HSI_VALUE, husart->Init.BaudRate, husart->Init.ClockPrescaler));
 8004886:	b1cb      	cbz	r3, 80048bc <HAL_USART_Init+0x110>
 8004888:	2b01      	cmp	r3, #1
 800488a:	d019      	beq.n	80048c0 <HAL_USART_Init+0x114>
 800488c:	2b02      	cmp	r3, #2
 800488e:	d019      	beq.n	80048c4 <HAL_USART_Init+0x118>
 8004890:	2b03      	cmp	r3, #3
 8004892:	d019      	beq.n	80048c8 <HAL_USART_Init+0x11c>
 8004894:	2b04      	cmp	r3, #4
 8004896:	d019      	beq.n	80048cc <HAL_USART_Init+0x120>
 8004898:	2b05      	cmp	r3, #5
 800489a:	d019      	beq.n	80048d0 <HAL_USART_Init+0x124>
 800489c:	2b06      	cmp	r3, #6
 800489e:	d019      	beq.n	80048d4 <HAL_USART_Init+0x128>
 80048a0:	2b07      	cmp	r3, #7
 80048a2:	d019      	beq.n	80048d8 <HAL_USART_Init+0x12c>
 80048a4:	2b08      	cmp	r3, #8
 80048a6:	d019      	beq.n	80048dc <HAL_USART_Init+0x130>
 80048a8:	2b09      	cmp	r3, #9
 80048aa:	d019      	beq.n	80048e0 <HAL_USART_Init+0x134>
 80048ac:	2b0a      	cmp	r3, #10
 80048ae:	d019      	beq.n	80048e4 <HAL_USART_Init+0x138>
 80048b0:	4a71      	ldr	r2, [pc, #452]	; (8004a78 <HAL_USART_Init+0x2cc>)
 80048b2:	4972      	ldr	r1, [pc, #456]	; (8004a7c <HAL_USART_Init+0x2d0>)
 80048b4:	2b0b      	cmp	r3, #11
 80048b6:	bf18      	it	ne
 80048b8:	460a      	movne	r2, r1
 80048ba:	e014      	b.n	80048e6 <HAL_USART_Init+0x13a>
 80048bc:	4a6f      	ldr	r2, [pc, #444]	; (8004a7c <HAL_USART_Init+0x2d0>)
 80048be:	e012      	b.n	80048e6 <HAL_USART_Init+0x13a>
 80048c0:	4a6f      	ldr	r2, [pc, #444]	; (8004a80 <HAL_USART_Init+0x2d4>)
 80048c2:	e010      	b.n	80048e6 <HAL_USART_Init+0x13a>
 80048c4:	4a6f      	ldr	r2, [pc, #444]	; (8004a84 <HAL_USART_Init+0x2d8>)
 80048c6:	e00e      	b.n	80048e6 <HAL_USART_Init+0x13a>
 80048c8:	4a6f      	ldr	r2, [pc, #444]	; (8004a88 <HAL_USART_Init+0x2dc>)
 80048ca:	e00c      	b.n	80048e6 <HAL_USART_Init+0x13a>
 80048cc:	4a6f      	ldr	r2, [pc, #444]	; (8004a8c <HAL_USART_Init+0x2e0>)
 80048ce:	e00a      	b.n	80048e6 <HAL_USART_Init+0x13a>
 80048d0:	4a6f      	ldr	r2, [pc, #444]	; (8004a90 <HAL_USART_Init+0x2e4>)
 80048d2:	e008      	b.n	80048e6 <HAL_USART_Init+0x13a>
 80048d4:	4a6f      	ldr	r2, [pc, #444]	; (8004a94 <HAL_USART_Init+0x2e8>)
 80048d6:	e006      	b.n	80048e6 <HAL_USART_Init+0x13a>
 80048d8:	4a6f      	ldr	r2, [pc, #444]	; (8004a98 <HAL_USART_Init+0x2ec>)
 80048da:	e004      	b.n	80048e6 <HAL_USART_Init+0x13a>
 80048dc:	4a6f      	ldr	r2, [pc, #444]	; (8004a9c <HAL_USART_Init+0x2f0>)
 80048de:	e002      	b.n	80048e6 <HAL_USART_Init+0x13a>
 80048e0:	4a6f      	ldr	r2, [pc, #444]	; (8004aa0 <HAL_USART_Init+0x2f4>)
 80048e2:	e000      	b.n	80048e6 <HAL_USART_Init+0x13a>
 80048e4:	4a6f      	ldr	r2, [pc, #444]	; (8004aa4 <HAL_USART_Init+0x2f8>)
 80048e6:	6863      	ldr	r3, [r4, #4]
 80048e8:	eb02 0253 	add.w	r2, r2, r3, lsr #1
 80048ec:	fbb2 f3f3 	udiv	r3, r2, r3
 80048f0:	e07c      	b.n	80049ec <HAL_USART_Init+0x240>
#else
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(HSI_VALUE, husart->Init.BaudRate));
#endif /* USART_PRESC_PRESCALER */
      break;
    case USART_CLOCKSOURCE_SYSCLK:
      pclk = HAL_RCC_GetSysClockFreq();
 80048f2:	f003 fe1f 	bl	8008534 <HAL_RCC_GetSysClockFreq>
#if defined(USART_PRESC_PRESCALER)
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(pclk, husart->Init.BaudRate, husart->Init.ClockPrescaler));
 80048f6:	6a65      	ldr	r5, [r4, #36]	; 0x24
 80048f8:	b1cd      	cbz	r5, 800492e <HAL_USART_Init+0x182>
 80048fa:	2d01      	cmp	r5, #1
 80048fc:	d019      	beq.n	8004932 <HAL_USART_Init+0x186>
 80048fe:	2d02      	cmp	r5, #2
 8004900:	d019      	beq.n	8004936 <HAL_USART_Init+0x18a>
 8004902:	2d03      	cmp	r5, #3
 8004904:	d019      	beq.n	800493a <HAL_USART_Init+0x18e>
 8004906:	2d04      	cmp	r5, #4
 8004908:	d019      	beq.n	800493e <HAL_USART_Init+0x192>
 800490a:	2d05      	cmp	r5, #5
 800490c:	d019      	beq.n	8004942 <HAL_USART_Init+0x196>
 800490e:	2d06      	cmp	r5, #6
 8004910:	d019      	beq.n	8004946 <HAL_USART_Init+0x19a>
 8004912:	2d07      	cmp	r5, #7
 8004914:	d019      	beq.n	800494a <HAL_USART_Init+0x19e>
 8004916:	2d08      	cmp	r5, #8
 8004918:	d019      	beq.n	800494e <HAL_USART_Init+0x1a2>
 800491a:	2d09      	cmp	r5, #9
 800491c:	d019      	beq.n	8004952 <HAL_USART_Init+0x1a6>
 800491e:	2d0a      	cmp	r5, #10
 8004920:	d019      	beq.n	8004956 <HAL_USART_Init+0x1aa>
 8004922:	2d0b      	cmp	r5, #11
 8004924:	bf14      	ite	ne
 8004926:	2101      	movne	r1, #1
 8004928:	f44f 7180 	moveq.w	r1, #256	; 0x100
 800492c:	e014      	b.n	8004958 <HAL_USART_Init+0x1ac>
 800492e:	2101      	movs	r1, #1
 8004930:	e012      	b.n	8004958 <HAL_USART_Init+0x1ac>
 8004932:	2102      	movs	r1, #2
 8004934:	e010      	b.n	8004958 <HAL_USART_Init+0x1ac>
 8004936:	2104      	movs	r1, #4
 8004938:	e00e      	b.n	8004958 <HAL_USART_Init+0x1ac>
 800493a:	2106      	movs	r1, #6
 800493c:	e00c      	b.n	8004958 <HAL_USART_Init+0x1ac>
 800493e:	2108      	movs	r1, #8
 8004940:	e00a      	b.n	8004958 <HAL_USART_Init+0x1ac>
 8004942:	210a      	movs	r1, #10
 8004944:	e008      	b.n	8004958 <HAL_USART_Init+0x1ac>
 8004946:	210c      	movs	r1, #12
 8004948:	e006      	b.n	8004958 <HAL_USART_Init+0x1ac>
 800494a:	2110      	movs	r1, #16
 800494c:	e004      	b.n	8004958 <HAL_USART_Init+0x1ac>
 800494e:	2120      	movs	r1, #32
 8004950:	e002      	b.n	8004958 <HAL_USART_Init+0x1ac>
 8004952:	2140      	movs	r1, #64	; 0x40
 8004954:	e000      	b.n	8004958 <HAL_USART_Init+0x1ac>
 8004956:	2180      	movs	r1, #128	; 0x80
 8004958:	6863      	ldr	r3, [r4, #4]
 800495a:	fbb0 f0f1 	udiv	r0, r0, r1
 800495e:	0859      	lsrs	r1, r3, #1
 8004960:	eb01 0040 	add.w	r0, r1, r0, lsl #1
 8004964:	fbb0 f3f3 	udiv	r3, r0, r3
 8004968:	e040      	b.n	80049ec <HAL_USART_Init+0x240>
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(pclk, husart->Init.BaudRate));
#endif /* USART_PRESC_PRESCALER */
      break;
    case USART_CLOCKSOURCE_LSE:
#if defined(USART_PRESC_PRESCALER)
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(LSE_VALUE, husart->Init.BaudRate, husart->Init.ClockPrescaler));
 800496a:	b1d3      	cbz	r3, 80049a2 <HAL_USART_Init+0x1f6>
 800496c:	2b01      	cmp	r3, #1
 800496e:	d01b      	beq.n	80049a8 <HAL_USART_Init+0x1fc>
 8004970:	2b02      	cmp	r3, #2
 8004972:	d01c      	beq.n	80049ae <HAL_USART_Init+0x202>
 8004974:	2b03      	cmp	r3, #3
 8004976:	d01d      	beq.n	80049b4 <HAL_USART_Init+0x208>
 8004978:	2b04      	cmp	r3, #4
 800497a:	d01e      	beq.n	80049ba <HAL_USART_Init+0x20e>
 800497c:	2b05      	cmp	r3, #5
 800497e:	d01f      	beq.n	80049c0 <HAL_USART_Init+0x214>
 8004980:	2b06      	cmp	r3, #6
 8004982:	d020      	beq.n	80049c6 <HAL_USART_Init+0x21a>
 8004984:	2b07      	cmp	r3, #7
 8004986:	d021      	beq.n	80049cc <HAL_USART_Init+0x220>
 8004988:	2b08      	cmp	r3, #8
 800498a:	d022      	beq.n	80049d2 <HAL_USART_Init+0x226>
 800498c:	2b09      	cmp	r3, #9
 800498e:	d023      	beq.n	80049d8 <HAL_USART_Init+0x22c>
 8004990:	2b0a      	cmp	r3, #10
 8004992:	d024      	beq.n	80049de <HAL_USART_Init+0x232>
 8004994:	2b0b      	cmp	r3, #11
 8004996:	bf14      	ite	ne
 8004998:	f44f 3380 	movne.w	r3, #65536	; 0x10000
 800499c:	f44f 7380 	moveq.w	r3, #256	; 0x100
 80049a0:	e01f      	b.n	80049e2 <HAL_USART_Init+0x236>
 80049a2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80049a6:	e01c      	b.n	80049e2 <HAL_USART_Init+0x236>
 80049a8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80049ac:	e019      	b.n	80049e2 <HAL_USART_Init+0x236>
 80049ae:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80049b2:	e016      	b.n	80049e2 <HAL_USART_Init+0x236>
 80049b4:	f642 23aa 	movw	r3, #10922	; 0x2aaa
 80049b8:	e013      	b.n	80049e2 <HAL_USART_Init+0x236>
 80049ba:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80049be:	e010      	b.n	80049e2 <HAL_USART_Init+0x236>
 80049c0:	f641 1398 	movw	r3, #6552	; 0x1998
 80049c4:	e00d      	b.n	80049e2 <HAL_USART_Init+0x236>
 80049c6:	f241 5354 	movw	r3, #5460	; 0x1554
 80049ca:	e00a      	b.n	80049e2 <HAL_USART_Init+0x236>
 80049cc:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80049d0:	e007      	b.n	80049e2 <HAL_USART_Init+0x236>
 80049d2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80049d6:	e004      	b.n	80049e2 <HAL_USART_Init+0x236>
 80049d8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80049dc:	e001      	b.n	80049e2 <HAL_USART_Init+0x236>
 80049de:	f44f 7300 	mov.w	r3, #512	; 0x200
 80049e2:	6862      	ldr	r2, [r4, #4]
 80049e4:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 80049e8:	fbb3 f3f2 	udiv	r3, r3, r2
  */
static HAL_StatusTypeDef USART_SetConfig(USART_HandleTypeDef *husart)
{
  uint32_t tmpreg;
  USART_ClockSourceTypeDef clocksource;
  HAL_StatusTypeDef ret                = HAL_OK;
 80049ec:	2100      	movs	r1, #0
 80049ee:	e001      	b.n	80049f4 <HAL_USART_Init+0x248>
  uint16_t brrtemp;
  uint32_t usartdiv                    = 0x00000000;
 80049f0:	2300      	movs	r3, #0
#else
      usartdiv = (uint32_t)(USART_DIV_SAMPLING8(LSE_VALUE, husart->Init.BaudRate));
#endif /* USART_PRESC_PRESCALER */
      break;
    default:
      ret = HAL_ERROR;
 80049f2:	2101      	movs	r1, #1
      break;
  }

  /* USARTDIV must be greater than or equal to 0d16 and smaller than or equal to ffff */
  if ((usartdiv >= USART_BRR_MIN) && (usartdiv <= USART_BRR_MAX))
 80049f4:	f1a3 0010 	sub.w	r0, r3, #16
 80049f8:	f64f 72ef 	movw	r2, #65519	; 0xffef
 80049fc:	4290      	cmp	r0, r2
  {
    brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 80049fe:	bf9f      	itttt	ls
 8004a00:	f3c3 0242 	ubfxls	r2, r3, #1, #3
 8004a04:	f023 030f 	bicls.w	r3, r3, #15
 8004a08:	4313      	orrls	r3, r2
 8004a0a:	b29b      	uxthls	r3, r3
    husart->Instance->BRR = brrtemp;
 8004a0c:	bf9d      	ittte	ls
 8004a0e:	6822      	ldrls	r2, [r4, #0]
 8004a10:	b29b      	uxthls	r3, r3
 8004a12:	60d3      	strls	r3, [r2, #12]
  }
  else
  {
    ret = HAL_ERROR;
 8004a14:	2101      	movhi	r1, #1
  }

#if defined(USART_CR1_FIFOEN)
  /* Initialize the number of data to process during RX/TX ISR execution */
  husart->NbTxDataToProcess = 1U;
 8004a16:	2301      	movs	r3, #1
  husart->NbRxDataToProcess = 1U;
#endif /* USART_CR1_FIFOEN */

  /* Clear ISR function pointers */
  husart->RxISR   = NULL;
 8004a18:	2200      	movs	r2, #0
    ret = HAL_ERROR;
  }

#if defined(USART_CR1_FIFOEN)
  /* Initialize the number of data to process during RX/TX ISR execution */
  husart->NbTxDataToProcess = 1U;
 8004a1a:	87a3      	strh	r3, [r4, #60]	; 0x3c
  husart->NbRxDataToProcess = 1U;
 8004a1c:	8763      	strh	r3, [r4, #58]	; 0x3a
#endif /* USART_CR1_FIFOEN */

  /* Clear ISR function pointers */
  husart->RxISR   = NULL;
 8004a1e:	64a2      	str	r2, [r4, #72]	; 0x48
  husart->TxISR   = NULL;
 8004a20:	64e2      	str	r2, [r4, #76]	; 0x4c

  /* Disable the Peripheral */
  __HAL_USART_DISABLE(husart);

  /* Set the Usart Communication parameters */
  if (USART_SetConfig(husart) == HAL_ERROR)
 8004a22:	2900      	cmp	r1, #0
 8004a24:	f47f aec5 	bne.w	80047b2 <HAL_USART_Init+0x6>
  }

  /* In Synchronous mode, the following bits must be kept cleared:
  - LINEN bit in the USART_CR2 register
  - HDSEL, SCEN and IREN bits in the USART_CR3 register.*/
  husart->Instance->CR2 &= ~USART_CR2_LINEN;
 8004a28:	6823      	ldr	r3, [r4, #0]
 8004a2a:	6859      	ldr	r1, [r3, #4]
 8004a2c:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
 8004a30:	6059      	str	r1, [r3, #4]
  husart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);
 8004a32:	6899      	ldr	r1, [r3, #8]
 8004a34:	f021 012a 	bic.w	r1, r1, #42	; 0x2a
 8004a38:	6099      	str	r1, [r3, #8]

  /* Enable the Peripheral */
  __HAL_USART_ENABLE(husart);
 8004a3a:	6819      	ldr	r1, [r3, #0]
 8004a3c:	f041 0101 	orr.w	r1, r1, #1
 8004a40:	6019      	str	r1, [r3, #0]
static HAL_StatusTypeDef USART_CheckIdleState(USART_HandleTypeDef *husart)
{
  uint32_t tickstart;

  /* Initialize the USART ErrorCode */
  husart->ErrorCode = HAL_USART_ERROR_NONE;
 8004a42:	65e2      	str	r2, [r4, #92]	; 0x5c

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 8004a44:	f002 fae2 	bl	800700c <HAL_GetTick>

  /* Check if the Transmitter is enabled */
  if ((husart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8004a48:	6823      	ldr	r3, [r4, #0]
 8004a4a:	681b      	ldr	r3, [r3, #0]
 8004a4c:	071a      	lsls	r2, r3, #28

  /* Initialize the USART ErrorCode */
  husart->ErrorCode = HAL_USART_ERROR_NONE;

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 8004a4e:	4605      	mov	r5, r0

  /* Check if the Transmitter is enabled */
  if ((husart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8004a50:	d430      	bmi.n	8004ab4 <HAL_USART_Init+0x308>
      /* Timeout occurred */
      return HAL_TIMEOUT;
    }
  }
  /* Check if the Receiver is enabled */
  if ((husart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8004a52:	6823      	ldr	r3, [r4, #0]
 8004a54:	681b      	ldr	r3, [r3, #0]
 8004a56:	075b      	lsls	r3, r3, #29
 8004a58:	d53f      	bpl.n	8004ada <HAL_USART_Init+0x32e>
 8004a5a:	e038      	b.n	8004ace <HAL_USART_Init+0x322>
 8004a5c:	cfff69f3 	.word	0xcfff69f3
 8004a60:	40013800 	.word	0x40013800
 8004a64:	40021000 	.word	0x40021000
 8004a68:	0800e4b6 	.word	0x0800e4b6
 8004a6c:	40004400 	.word	0x40004400
 8004a70:	0800e4ba 	.word	0x0800e4ba
 8004a74:	40004800 	.word	0x40004800
 8004a78:	0001e848 	.word	0x0001e848
 8004a7c:	01e84800 	.word	0x01e84800
 8004a80:	00f42400 	.word	0x00f42400
 8004a84:	007a1200 	.word	0x007a1200
 8004a88:	00516154 	.word	0x00516154
 8004a8c:	003d0900 	.word	0x003d0900
 8004a90:	0030d400 	.word	0x0030d400
 8004a94:	0028b0aa 	.word	0x0028b0aa
 8004a98:	001e8480 	.word	0x001e8480
 8004a9c:	000f4240 	.word	0x000f4240
 8004aa0:	0007a120 	.word	0x0007a120
 8004aa4:	0003d090 	.word	0x0003d090
  while ((__HAL_USART_GET_FLAG(husart, Flag) ? SET : RESET) == Status)
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8004aa8:	f002 fab0 	bl	800700c <HAL_GetTick>
 8004aac:	1b40      	subs	r0, r0, r5
 8004aae:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8004ab2:	d819      	bhi.n	8004ae8 <HAL_USART_Init+0x33c>
  */
static HAL_StatusTypeDef USART_WaitOnFlagUntilTimeout(USART_HandleTypeDef *husart, uint32_t Flag, FlagStatus Status,
                                                      uint32_t Tickstart, uint32_t Timeout)
{
  /* Wait until flag is set */
  while ((__HAL_USART_GET_FLAG(husart, Flag) ? SET : RESET) == Status)
 8004ab4:	6823      	ldr	r3, [r4, #0]
 8004ab6:	69db      	ldr	r3, [r3, #28]
 8004ab8:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8004abc:	2b00      	cmp	r3, #0
 8004abe:	d0f3      	beq.n	8004aa8 <HAL_USART_Init+0x2fc>
 8004ac0:	e7c7      	b.n	8004a52 <HAL_USART_Init+0x2a6>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8004ac2:	f002 faa3 	bl	800700c <HAL_GetTick>
 8004ac6:	1b40      	subs	r0, r0, r5
 8004ac8:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8004acc:	d80c      	bhi.n	8004ae8 <HAL_USART_Init+0x33c>
  */
static HAL_StatusTypeDef USART_WaitOnFlagUntilTimeout(USART_HandleTypeDef *husart, uint32_t Flag, FlagStatus Status,
                                                      uint32_t Tickstart, uint32_t Timeout)
{
  /* Wait until flag is set */
  while ((__HAL_USART_GET_FLAG(husart, Flag) ? SET : RESET) == Status)
 8004ace:	6823      	ldr	r3, [r4, #0]
 8004ad0:	69db      	ldr	r3, [r3, #28]
 8004ad2:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8004ad6:	2b00      	cmp	r3, #0
 8004ad8:	d0f3      	beq.n	8004ac2 <HAL_USART_Init+0x316>
      return HAL_TIMEOUT;
    }
  }

  /* Initialize the USART state*/
  husart->State = HAL_USART_STATE_READY;
 8004ada:	2301      	movs	r3, #1

  /* Process Unlocked */
  __HAL_UNLOCK(husart);
 8004adc:	2000      	movs	r0, #0
      return HAL_TIMEOUT;
    }
  }

  /* Initialize the USART state*/
  husart->State = HAL_USART_STATE_READY;
 8004ade:	f884 3059 	strb.w	r3, [r4, #89]	; 0x59

  /* Process Unlocked */
  __HAL_UNLOCK(husart);
 8004ae2:	f884 0058 	strb.w	r0, [r4, #88]	; 0x58
 8004ae6:	bd38      	pop	{r3, r4, r5, pc}
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
      {
        husart->State = HAL_USART_STATE_READY;
 8004ae8:	2301      	movs	r3, #1
 8004aea:	f884 3059 	strb.w	r3, [r4, #89]	; 0x59

        /* Process Unlocked */
        __HAL_UNLOCK(husart);
 8004aee:	2300      	movs	r3, #0
 8004af0:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
  {
    /* Wait until REACK flag is set */
    if (USART_WaitOnFlagUntilTimeout(husart, USART_ISR_REACK, RESET, tickstart, USART_TEACK_REACK_TIMEOUT) != HAL_OK)
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 8004af4:	2003      	movs	r0, #3
 8004af6:	bd38      	pop	{r3, r4, r5, pc}

08004af8 <console_setup>:
static USART_HandleTypeDef con;

void console_setup(void)
{
    // enable clock to that part of chip
    __HAL_RCC_USART1_CONFIG(RCC_USART1CLKSOURCE_SYSCLK);
 8004af8:	4b14      	ldr	r3, [pc, #80]	; (8004b4c <console_setup+0x54>)
 8004afa:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8004afe:	f022 0203 	bic.w	r2, r2, #3
 8004b02:	f042 0201 	orr.w	r2, r2, #1
static const char *CRLF = "\r\n";

static USART_HandleTypeDef con;

void console_setup(void)
{
 8004b06:	b513      	push	{r0, r1, r4, lr}
    // enable clock to that part of chip
    __HAL_RCC_USART1_CONFIG(RCC_USART1CLKSOURCE_SYSCLK);
 8004b08:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    __HAL_RCC_USART1_CLK_ENABLE();
 8004b0c:	6e1a      	ldr	r2, [r3, #96]	; 0x60

    // TODO: cleanup shit HAL code w/ barebones we need

    // config for 115200 8N1
    memset(&con, 0, sizeof(con));
 8004b0e:	4c10      	ldr	r4, [pc, #64]	; (8004b50 <console_setup+0x58>)

void console_setup(void)
{
    // enable clock to that part of chip
    __HAL_RCC_USART1_CONFIG(RCC_USART1CLKSOURCE_SYSCLK);
    __HAL_RCC_USART1_CLK_ENABLE();
 8004b10:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8004b14:	661a      	str	r2, [r3, #96]	; 0x60
 8004b16:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004b18:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8004b1c:	9301      	str	r3, [sp, #4]

    // TODO: cleanup shit HAL code w/ barebones we need

    // config for 115200 8N1
    memset(&con, 0, sizeof(con));
 8004b1e:	2260      	movs	r2, #96	; 0x60
 8004b20:	2100      	movs	r1, #0
 8004b22:	4620      	mov	r0, r4

void console_setup(void)
{
    // enable clock to that part of chip
    __HAL_RCC_USART1_CONFIG(RCC_USART1CLKSOURCE_SYSCLK);
    __HAL_RCC_USART1_CLK_ENABLE();
 8004b24:	9b01      	ldr	r3, [sp, #4]

    // TODO: cleanup shit HAL code w/ barebones we need

    // config for 115200 8N1
    memset(&con, 0, sizeof(con));
 8004b26:	f008 fcce 	bl	800d4c6 <memset>
    con.Instance = MY_UART;
    con.Init.BaudRate = 115200;
 8004b2a:	4a0a      	ldr	r2, [pc, #40]	; (8004b54 <console_setup+0x5c>)
 8004b2c:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 8004b30:	e884 000c 	stmia.w	r4, {r2, r3}
    con.Init.WordLength = USART_WORDLENGTH_8B;
    con.Init.Parity = USART_PARITY_NONE;
    con.Init.StopBits = USART_STOPBITS_1;
    con.Init.Mode = USART_MODE_TX_RX;

    HAL_StatusTypeDef rv = HAL_USART_Init(&con);
 8004b34:	4620      	mov	r0, r4
    con.Instance = MY_UART;
    con.Init.BaudRate = 115200;
    con.Init.WordLength = USART_WORDLENGTH_8B;
    con.Init.Parity = USART_PARITY_NONE;
    con.Init.StopBits = USART_STOPBITS_1;
    con.Init.Mode = USART_MODE_TX_RX;
 8004b36:	230c      	movs	r3, #12
 8004b38:	6163      	str	r3, [r4, #20]

    HAL_StatusTypeDef rv = HAL_USART_Init(&con);
 8004b3a:	f7ff fe37 	bl	80047ac <HAL_USART_Init>
    ASSERT(rv == HAL_OK);
 8004b3e:	b110      	cbz	r0, 8004b46 <console_setup+0x4e>
 8004b40:	4805      	ldr	r0, [pc, #20]	; (8004b58 <console_setup+0x60>)
 8004b42:	f7fb ff4b 	bl	80009dc <fatal_error>
}
 8004b46:	b002      	add	sp, #8
 8004b48:	bd10      	pop	{r4, pc}
 8004b4a:	bf00      	nop
 8004b4c:	40021000 	.word	0x40021000
 8004b50:	200001d4 	.word	0x200001d4
 8004b54:	40013800 	.word	0x40013800
 8004b58:	0800d550 	.word	0x0800d550

08004b5c <HAL_USART_Transmit>:
  * @param  Size Amount of data elements (u8 or u16) to be sent.
  * @param  Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_USART_Transmit(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size, uint32_t Timeout)
{
 8004b5c:	4b0d      	ldr	r3, [pc, #52]	; (8004b94 <HAL_USART_Transmit+0x38>)
 8004b5e:	b510      	push	{r4, lr}
    while(Size > 0U) {
        while(!(MY_UART->ISR & UART_FLAG_TXE)) {
 8004b60:	461c      	mov	r4, r3
 8004b62:	480c      	ldr	r0, [pc, #48]	; (8004b94 <HAL_USART_Transmit+0x38>)
  * @param  Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_USART_Transmit(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size, uint32_t Timeout)
{
    while(Size > 0U) {
 8004b64:	b142      	cbz	r2, 8004b78 <HAL_USART_Transmit+0x1c>
        while(!(MY_UART->ISR & UART_FLAG_TXE)) {
 8004b66:	69d8      	ldr	r0, [r3, #28]
 8004b68:	0600      	lsls	r0, r0, #24
 8004b6a:	d5fc      	bpl.n	8004b66 <HAL_USART_Transmit+0xa>
            // wait to be able send
        }

        MY_UART->TDR = *pTxData;
 8004b6c:	f811 0b01 	ldrb.w	r0, [r1], #1
 8004b70:	8520      	strh	r0, [r4, #40]	; 0x28
        pTxData++;
        Size --;
 8004b72:	3a01      	subs	r2, #1
 8004b74:	b292      	uxth	r2, r2
 8004b76:	e7f4      	b.n	8004b62 <HAL_USART_Transmit+0x6>
    }

    while(!(MY_UART->ISR & UART_FLAG_TC)) {
 8004b78:	69c2      	ldr	r2, [r0, #28]
 8004b7a:	4b06      	ldr	r3, [pc, #24]	; (8004b94 <HAL_USART_Transmit+0x38>)
 8004b7c:	0652      	lsls	r2, r2, #25
 8004b7e:	d5fb      	bpl.n	8004b78 <HAL_USART_Transmit+0x1c>
        // wait for final byte to be sent
    }

    // Clear Transmission Complete Flag
    MY_UART->ICR = USART_CLEAR_TCF;
 8004b80:	2240      	movs	r2, #64	; 0x40
 8004b82:	621a      	str	r2, [r3, #32]

    // Clear overrun flag and discard the received data
    MY_UART->ICR = USART_CLEAR_OREF;
 8004b84:	2208      	movs	r2, #8
 8004b86:	621a      	str	r2, [r3, #32]
    MY_UART->RQR = USART_RXDATA_FLUSH_REQUEST;
 8004b88:	831a      	strh	r2, [r3, #24]
    MY_UART->RQR = USART_TXDATA_FLUSH_REQUEST;
 8004b8a:	2210      	movs	r2, #16
 8004b8c:	831a      	strh	r2, [r3, #24]

    return HAL_OK;
}
 8004b8e:	2000      	movs	r0, #0
 8004b90:	bd10      	pop	{r4, pc}
 8004b92:	bf00      	nop
 8004b94:	40013800 	.word	0x40013800

08004b98 <puts2>:

// puts2()
//
	void
puts2(const char *msg)
{
 8004b98:	b510      	push	{r4, lr}
 8004b9a:	4604      	mov	r4, r0
	// output string with NO newline.
    rng_delay();
 8004b9c:	f7fd fdcb 	bl	8002736 <rng_delay>
    HAL_USART_Transmit(&con, (uint8_t *)msg, strlen(msg), HAL_MAX_DELAY);
 8004ba0:	4620      	mov	r0, r4
 8004ba2:	f008 fcbc 	bl	800d51e <strlen>
 8004ba6:	4621      	mov	r1, r4
 8004ba8:	b282      	uxth	r2, r0
 8004baa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004bae:	4803      	ldr	r0, [pc, #12]	; (8004bbc <puts2+0x24>)
 8004bb0:	f7ff ffd4 	bl	8004b5c <HAL_USART_Transmit>
    rng_delay();
}
 8004bb4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
puts2(const char *msg)
{
	// output string with NO newline.
    rng_delay();
    HAL_USART_Transmit(&con, (uint8_t *)msg, strlen(msg), HAL_MAX_DELAY);
    rng_delay();
 8004bb8:	f7fd bdbd 	b.w	8002736 <rng_delay>
 8004bbc:	200001d4 	.word	0x200001d4

08004bc0 <putchar>:

// putchar()
//
	int
putchar(int c)
{
 8004bc0:	b513      	push	{r0, r1, r4, lr}
 8004bc2:	4604      	mov	r4, r0
    uint8_t cb = c;
 8004bc4:	f88d 0007 	strb.w	r0, [sp, #7]

    rng_delay();
 8004bc8:	f7fd fdb5 	bl	8002736 <rng_delay>
    if(cb != '\n') {
 8004bcc:	f89d 3007 	ldrb.w	r3, [sp, #7]
        HAL_USART_Transmit(&con, &cb, 1, HAL_MAX_DELAY);
    } else {
        HAL_USART_Transmit(&con, (uint8_t *)CRLF, 2, HAL_MAX_DELAY);
 8004bd0:	4808      	ldr	r0, [pc, #32]	; (8004bf4 <putchar+0x34>)
putchar(int c)
{
    uint8_t cb = c;

    rng_delay();
    if(cb != '\n') {
 8004bd2:	2b0a      	cmp	r3, #10
        HAL_USART_Transmit(&con, &cb, 1, HAL_MAX_DELAY);
 8004bd4:	bf18      	it	ne
 8004bd6:	2201      	movne	r2, #1
 8004bd8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004bdc:	bf12      	itee	ne
 8004bde:	f10d 0107 	addne.w	r1, sp, #7
    } else {
        HAL_USART_Transmit(&con, (uint8_t *)CRLF, 2, HAL_MAX_DELAY);
 8004be2:	2202      	moveq	r2, #2
 8004be4:	4904      	ldreq	r1, [pc, #16]	; (8004bf8 <putchar+0x38>)
 8004be6:	f7ff ffb9 	bl	8004b5c <HAL_USART_Transmit>
    }
    rng_delay();
 8004bea:	f7fd fda4 	bl	8002736 <rng_delay>

    return c;
}
 8004bee:	4620      	mov	r0, r4
 8004bf0:	b002      	add	sp, #8
 8004bf2:	bd10      	pop	{r4, pc}
 8004bf4:	200001d4 	.word	0x200001d4
 8004bf8:	0800e4a3 	.word	0x0800e4a3

08004bfc <puthex2>:

// puthex2()
//
	void
puthex2(uint8_t b)
{
 8004bfc:	b538      	push	{r3, r4, r5, lr}
	putchar(hexmap[(b>>4) & 0xf]);
 8004bfe:	4d06      	ldr	r5, [pc, #24]	; (8004c18 <puthex2+0x1c>)
 8004c00:	0903      	lsrs	r3, r0, #4

// puthex2()
//
	void
puthex2(uint8_t b)
{
 8004c02:	4604      	mov	r4, r0
	putchar(hexmap[(b>>4) & 0xf]);
	putchar(hexmap[(b>>0) & 0xf]);
 8004c04:	f004 040f 	and.w	r4, r4, #15
// puthex2()
//
	void
puthex2(uint8_t b)
{
	putchar(hexmap[(b>>4) & 0xf]);
 8004c08:	5ce8      	ldrb	r0, [r5, r3]
 8004c0a:	f7ff ffd9 	bl	8004bc0 <putchar>
	putchar(hexmap[(b>>0) & 0xf]);
 8004c0e:	5d28      	ldrb	r0, [r5, r4]
}
 8004c10:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
//
	void
puthex2(uint8_t b)
{
	putchar(hexmap[(b>>4) & 0xf]);
	putchar(hexmap[(b>>0) & 0xf]);
 8004c14:	f7ff bfd4 	b.w	8004bc0 <putchar>
 8004c18:	0800e4a6 	.word	0x0800e4a6

08004c1c <puthex4>:

// puthex4()
//
	void
puthex4(uint16_t w)
{
 8004c1c:	b538      	push	{r3, r4, r5, lr}
	putchar(hexmap[(w>>12) & 0xf]);
 8004c1e:	4d0b      	ldr	r5, [pc, #44]	; (8004c4c <puthex4+0x30>)
 8004c20:	0b03      	lsrs	r3, r0, #12

// puthex4()
//
	void
puthex4(uint16_t w)
{
 8004c22:	4604      	mov	r4, r0
	putchar(hexmap[(w>>12) & 0xf]);
 8004c24:	5ce8      	ldrb	r0, [r5, r3]
 8004c26:	f7ff ffcb 	bl	8004bc0 <putchar>
	putchar(hexmap[(w>>8) & 0xf]);
 8004c2a:	f3c4 2303 	ubfx	r3, r4, #8, #4
 8004c2e:	5ce8      	ldrb	r0, [r5, r3]
 8004c30:	f7ff ffc6 	bl	8004bc0 <putchar>
	putchar(hexmap[(w>>4) & 0xf]);
 8004c34:	f3c4 1303 	ubfx	r3, r4, #4, #4
	putchar(hexmap[(w>>0) & 0xf]);
 8004c38:	f004 040f 	and.w	r4, r4, #15
	void
puthex4(uint16_t w)
{
	putchar(hexmap[(w>>12) & 0xf]);
	putchar(hexmap[(w>>8) & 0xf]);
	putchar(hexmap[(w>>4) & 0xf]);
 8004c3c:	5ce8      	ldrb	r0, [r5, r3]
 8004c3e:	f7ff ffbf 	bl	8004bc0 <putchar>
	putchar(hexmap[(w>>0) & 0xf]);
 8004c42:	5d28      	ldrb	r0, [r5, r4]
}
 8004c44:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
puthex4(uint16_t w)
{
	putchar(hexmap[(w>>12) & 0xf]);
	putchar(hexmap[(w>>8) & 0xf]);
	putchar(hexmap[(w>>4) & 0xf]);
	putchar(hexmap[(w>>0) & 0xf]);
 8004c48:	f7ff bfba 	b.w	8004bc0 <putchar>
 8004c4c:	0800e4a6 	.word	0x0800e4a6

08004c50 <puthex8>:

// puthex8()
//
	void
puthex8(uint32_t w)
{
 8004c50:	b510      	push	{r4, lr}
 8004c52:	4604      	mov	r4, r0
    puthex4(w >> 16);
 8004c54:	0c00      	lsrs	r0, r0, #16
 8004c56:	f7ff ffe1 	bl	8004c1c <puthex4>
    puthex4(w & 0xffff);
 8004c5a:	b2a0      	uxth	r0, r4
}
 8004c5c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
//
	void
puthex8(uint32_t w)
{
    puthex4(w >> 16);
    puthex4(w & 0xffff);
 8004c60:	f7ff bfdc 	b.w	8004c1c <puthex4>

08004c64 <putdec4>:

// putdec()
//
	void
putdec4(uint16_t w)
{
 8004c64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004c66:	4607      	mov	r7, r0
 8004c68:	2504      	movs	r5, #4
    for(int m=1000; m; m /= 10) {
 8004c6a:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
        if(w >= m) {
            char n = '0' + ((w / m) % 10);
            putchar(n);
 8004c6e:	260a      	movs	r6, #10
//
	void
putdec4(uint16_t w)
{
    for(int m=1000; m; m /= 10) {
        if(w >= m) {
 8004c70:	42a7      	cmp	r7, r4
 8004c72:	db09      	blt.n	8004c88 <putdec4+0x24>
            char n = '0' + ((w / m) % 10);
            putchar(n);
 8004c74:	fb97 f0f4 	sdiv	r0, r7, r4
 8004c78:	fb90 f3f6 	sdiv	r3, r0, r6
 8004c7c:	fb06 0013 	mls	r0, r6, r3, r0
 8004c80:	3030      	adds	r0, #48	; 0x30
 8004c82:	b2c0      	uxtb	r0, r0
 8004c84:	f7ff ff9c 	bl	8004bc0 <putchar>
// putdec()
//
	void
putdec4(uint16_t w)
{
    for(int m=1000; m; m /= 10) {
 8004c88:	fb94 f4f6 	sdiv	r4, r4, r6
 8004c8c:	3d01      	subs	r5, #1
 8004c8e:	d1ef      	bne.n	8004c70 <putdec4+0xc>
        if(w >= m) {
            char n = '0' + ((w / m) % 10);
            putchar(n);
        }
    }
}
 8004c90:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08004c92 <hex_dump>:

// hex_dump()
//
    void
hex_dump(const void *d, int len)
{
 8004c92:	b570      	push	{r4, r5, r6, lr}
 8004c94:	4605      	mov	r5, r0
 8004c96:	460e      	mov	r6, r1
	const uint8_t *data = (const uint8_t *)d;
#if 1
    for(int i=0; i<len; i++) {
 8004c98:	4604      	mov	r4, r0
 8004c9a:	1b63      	subs	r3, r4, r5
 8004c9c:	429e      	cmp	r6, r3
 8004c9e:	dd04      	ble.n	8004caa <hex_dump+0x18>
        puthex2(data[i]);
 8004ca0:	f814 0b01 	ldrb.w	r0, [r4], #1
 8004ca4:	f7ff ffaa 	bl	8004bfc <puthex2>
 8004ca8:	e7f7      	b.n	8004c9a <hex_dump+0x8>
    }
    putchar('\n');
 8004caa:	200a      	movs	r0, #10
        putchar('\n');
        i += j;
    }
#endif

}
 8004cac:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	const uint8_t *data = (const uint8_t *)d;
#if 1
    for(int i=0; i<len; i++) {
        puthex2(data[i]);
    }
    putchar('\n');
 8004cb0:	f7ff bf86 	b.w	8004bc0 <putchar>

08004cb4 <puts>:

// puts()
//
    int
puts(const char *msg)
{
 8004cb4:	b538      	push	{r3, r4, r5, lr}
 8004cb6:	4605      	mov	r5, r0
    int ln = strlen(msg);
 8004cb8:	f008 fc31 	bl	800d51e <strlen>
 8004cbc:	4604      	mov	r4, r0

    rng_delay();
 8004cbe:	f7fd fd3a 	bl	8002736 <rng_delay>

    if(ln) HAL_USART_Transmit(&con, (uint8_t *)msg, ln, HAL_MAX_DELAY);
 8004cc2:	b134      	cbz	r4, 8004cd2 <puts+0x1e>
 8004cc4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004cc8:	b2a2      	uxth	r2, r4
 8004cca:	4629      	mov	r1, r5
 8004ccc:	4806      	ldr	r0, [pc, #24]	; (8004ce8 <puts+0x34>)
 8004cce:	f7ff ff45 	bl	8004b5c <HAL_USART_Transmit>
    HAL_USART_Transmit(&con, (uint8_t *)CRLF, 2, HAL_MAX_DELAY);
 8004cd2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004cd6:	2202      	movs	r2, #2
 8004cd8:	4904      	ldr	r1, [pc, #16]	; (8004cec <puts+0x38>)
 8004cda:	4803      	ldr	r0, [pc, #12]	; (8004ce8 <puts+0x34>)
 8004cdc:	f7ff ff3e 	bl	8004b5c <HAL_USART_Transmit>

    rng_delay();
 8004ce0:	f7fd fd29 	bl	8002736 <rng_delay>

    return 1;
}
 8004ce4:	2001      	movs	r0, #1
 8004ce6:	bd38      	pop	{r3, r4, r5, pc}
 8004ce8:	200001d4 	.word	0x200001d4
 8004cec:	0800e4a3 	.word	0x0800e4a3

08004cf0 <psram_send_byte>:

// psram_send_byte()
//
    void
psram_send_byte(OSPI_HandleTypeDef  *qh, uint8_t cmd_byte, bool is_quad)
{   
 8004cf0:	b570      	push	{r4, r5, r6, lr}
 8004cf2:	b094      	sub	sp, #80	; 0x50
 8004cf4:	4604      	mov	r4, r0
 8004cf6:	460e      	mov	r6, r1
 8004cf8:	4615      	mov	r5, r2
    // Send single-byte commands to the PSRAM chip. Quad mode or normal SPI.

    OSPI_RegularCmdTypeDef cmd = {
 8004cfa:	2100      	movs	r1, #0
 8004cfc:	2250      	movs	r2, #80	; 0x50
 8004cfe:	4668      	mov	r0, sp
 8004d00:	f008 fbe1 	bl	800d4c6 <memset>
        .OperationType = HAL_OSPI_OPTYPE_COMMON_CFG,
        .Instruction = cmd_byte,                    // Exit Quad Mode
        .InstructionMode = is_quad ? HAL_OSPI_INSTRUCTION_4_LINES : HAL_OSPI_INSTRUCTION_1_LINE,
 8004d04:	2d00      	cmp	r5, #0
 8004d06:	bf14      	ite	ne
 8004d08:	2303      	movne	r3, #3
 8004d0a:	2301      	moveq	r3, #1
        .DataMode = HAL_OSPI_DATA_NONE,
        .NbData = 0,                        // how much to read in bytes
    };

    // Start and finish a "Indirection functional mode" request
    HAL_OSPI_Command(qh, &cmd, HAL_MAX_DELAY);
 8004d0c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8004d10:	4669      	mov	r1, sp
 8004d12:	4620      	mov	r0, r4
    void
psram_send_byte(OSPI_HandleTypeDef  *qh, uint8_t cmd_byte, bool is_quad)
{   
    // Send single-byte commands to the PSRAM chip. Quad mode or normal SPI.

    OSPI_RegularCmdTypeDef cmd = {
 8004d14:	9602      	str	r6, [sp, #8]
 8004d16:	9303      	str	r3, [sp, #12]
        .DataMode = HAL_OSPI_DATA_NONE,
        .NbData = 0,                        // how much to read in bytes
    };

    // Start and finish a "Indirection functional mode" request
    HAL_OSPI_Command(qh, &cmd, HAL_MAX_DELAY);
 8004d18:	f006 f820 	bl	800ad5c <HAL_OSPI_Command>
}
 8004d1c:	b014      	add	sp, #80	; 0x50
 8004d1e:	bd70      	pop	{r4, r5, r6, pc}

08004d20 <psram_setup>:

// psram_setup()
//
    void
psram_setup(void)
{
 8004d20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004d24:	b0c6      	sub	sp, #280	; 0x118
    // Using OSPI1 block
    OSPI_HandleTypeDef  qh = { 0 };
 8004d26:	2250      	movs	r2, #80	; 0x50
 8004d28:	2100      	movs	r1, #0
 8004d2a:	a80a      	add	r0, sp, #40	; 0x28
 8004d2c:	f008 fbcb 	bl	800d4c6 <memset>

    // enable clocks
    __HAL_RCC_OSPI1_CLK_ENABLE();
 8004d30:	4b6c      	ldr	r3, [pc, #432]	; (8004ee4 <psram_setup+0x1c4>)
    // reset module
    __HAL_RCC_OSPI1_FORCE_RESET();
    __HAL_RCC_OSPI1_RELEASE_RESET();

   // configure pins: Port E PE10-PE15
    GPIO_InitTypeDef setup = {
 8004d32:	4c6d      	ldr	r4, [pc, #436]	; (8004ee8 <psram_setup+0x1c8>)
{
    // Using OSPI1 block
    OSPI_HandleTypeDef  qh = { 0 };

    // enable clocks
    __HAL_RCC_OSPI1_CLK_ENABLE();
 8004d34:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8004d36:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8004d3a:	651a      	str	r2, [r3, #80]	; 0x50
 8004d3c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8004d3e:	f402 7280 	and.w	r2, r2, #256	; 0x100
 8004d42:	9201      	str	r2, [sp, #4]
 8004d44:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8004d46:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004d48:	f042 0210 	orr.w	r2, r2, #16
 8004d4c:	64da      	str	r2, [r3, #76]	; 0x4c
 8004d4e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8004d50:	f002 0210 	and.w	r2, r2, #16
 8004d54:	9202      	str	r2, [sp, #8]
 8004d56:	9a02      	ldr	r2, [sp, #8]

    // reset module
    __HAL_RCC_OSPI1_FORCE_RESET();
 8004d58:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004d5a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8004d5e:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_RCC_OSPI1_RELEASE_RESET();
 8004d60:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004d62:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8004d66:	631a      	str	r2, [r3, #48]	; 0x30

   // configure pins: Port E PE10-PE15
    GPIO_InitTypeDef setup = {
 8004d68:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8004d6a:	ad05      	add	r5, sp, #20
 8004d6c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8004d6e:	6823      	ldr	r3, [r4, #0]
        .Mode = GPIO_MODE_AF_PP,            // not sure
        .Pull = GPIO_NOPULL,                // not sure
        .Speed = GPIO_SPEED_FREQ_VERY_HIGH,
        .Alternate = GPIO_AF10_OCTOSPIM_P1,
    };
    HAL_GPIO_Init(GPIOE, &setup);
 8004d70:	485e      	ldr	r0, [pc, #376]	; (8004eec <psram_setup+0x1cc>)
    // reset module
    __HAL_RCC_OSPI1_FORCE_RESET();
    __HAL_RCC_OSPI1_RELEASE_RESET();

   // configure pins: Port E PE10-PE15
    GPIO_InitTypeDef setup = {
 8004d72:	602b      	str	r3, [r5, #0]
        .Mode = GPIO_MODE_AF_PP,            // not sure
        .Pull = GPIO_NOPULL,                // not sure
        .Speed = GPIO_SPEED_FREQ_VERY_HIGH,
        .Alternate = GPIO_AF10_OCTOSPIM_P1,
    };
    HAL_GPIO_Init(GPIOE, &setup);
 8004d74:	a905      	add	r1, sp, #20
 8004d76:	f7fc f923 	bl	8000fc0 <HAL_GPIO_Init>


    // Config operational values
    qh.Instance = OCTOSPI1;
 8004d7a:	4b5d      	ldr	r3, [pc, #372]	; (8004ef0 <psram_setup+0x1d0>)
 8004d7c:	930a      	str	r3, [sp, #40]	; 0x28
    qh.Init.FifoThreshold = 1;                          // ?? unused
    qh.Init.DualQuad = HAL_OSPI_DUALQUAD_DISABLE;
    qh.Init.MemoryType = HAL_OSPI_MEMTYPE_MICRON;       // want standard mode (but octo only?)
    qh.Init.DeviceSize = 24;                    // assume max size, actual is 8Mbyte
 8004d7e:	2218      	movs	r2, #24


    // Config operational values
    qh.Instance = OCTOSPI1;
    qh.Init.FifoThreshold = 1;                          // ?? unused
    qh.Init.DualQuad = HAL_OSPI_DUALQUAD_DISABLE;
 8004d80:	2300      	movs	r3, #0
    HAL_GPIO_Init(GPIOE, &setup);


    // Config operational values
    qh.Instance = OCTOSPI1;
    qh.Init.FifoThreshold = 1;                          // ?? unused
 8004d82:	2601      	movs	r6, #1
    qh.Init.DualQuad = HAL_OSPI_DUALQUAD_DISABLE;
    qh.Init.MemoryType = HAL_OSPI_MEMTYPE_MICRON;       // want standard mode (but octo only?)
    qh.Init.DeviceSize = 24;                    // assume max size, actual is 8Mbyte
 8004d84:	920e      	str	r2, [sp, #56]	; 0x38
    qh.Init.FreeRunningClock = HAL_OSPI_FREERUNCLK_DISABLE;     // required!
    qh.Init.ClockMode = HAL_OSPI_CLOCK_MODE_0;  // low clock between ops (required, see errata)
#if HCLK_FREQUENCY == 80000000
    qh.Init.ClockPrescaler = 1;                 // prescaler (1=>80Mhz, 2=>40Mhz, etc)
#elif HCLK_FREQUENCY == 120000000
    qh.Init.ClockPrescaler = 2;                 // prescaler (1=>120Mhz, 2=>60Mhz, etc)
 8004d86:	f04f 0802 	mov.w	r8, #2
    qh.Init.FifoThreshold = 1;                          // ?? unused
    qh.Init.DualQuad = HAL_OSPI_DUALQUAD_DISABLE;
    qh.Init.MemoryType = HAL_OSPI_MEMTYPE_MICRON;       // want standard mode (but octo only?)
    qh.Init.DeviceSize = 24;                    // assume max size, actual is 8Mbyte
    qh.Init.ChipSelectHighTime = 1;             // 1, maxed out, seems to work
    qh.Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_ENABLE;       // maybe?
 8004d8a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
#elif HCLK_FREQUENCY == 120000000
    qh.Init.ClockPrescaler = 2;                 // prescaler (1=>120Mhz, 2=>60Mhz, etc)
#else
#   error "testing needed"
#endif
    qh.Init.DelayBlockBypass = HAL_OSPI_DELAY_BLOCK_BYPASSED;        // dont need it?
 8004d8e:	f04f 0908 	mov.w	r9, #8
    // - (during reads) 3 => 400ns  4 => 660ns   5+ => 1us 
    // - LATER: Errata 2.8.1 => says shall not use
    qh.Init.ChipSelectBoundary = 0;

    // module init 
    HAL_StatusTypeDef rv = HAL_OSPI_Init(&qh);
 8004d92:	a80a      	add	r0, sp, #40	; 0x28
    HAL_GPIO_Init(GPIOE, &setup);


    // Config operational values
    qh.Instance = OCTOSPI1;
    qh.Init.FifoThreshold = 1;                          // ?? unused
 8004d94:	960b      	str	r6, [sp, #44]	; 0x2c
    qh.Init.DualQuad = HAL_OSPI_DUALQUAD_DISABLE;
 8004d96:	930c      	str	r3, [sp, #48]	; 0x30
    qh.Init.MemoryType = HAL_OSPI_MEMTYPE_MICRON;       // want standard mode (but octo only?)
 8004d98:	930d      	str	r3, [sp, #52]	; 0x34
    qh.Init.DeviceSize = 24;                    // assume max size, actual is 8Mbyte
    qh.Init.ChipSelectHighTime = 1;             // 1, maxed out, seems to work
 8004d9a:	960f      	str	r6, [sp, #60]	; 0x3c
    qh.Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_ENABLE;       // maybe?
 8004d9c:	9214      	str	r2, [sp, #80]	; 0x50
    qh.Init.FreeRunningClock = HAL_OSPI_FREERUNCLK_DISABLE;     // required!
 8004d9e:	9310      	str	r3, [sp, #64]	; 0x40
    qh.Init.ClockMode = HAL_OSPI_CLOCK_MODE_0;  // low clock between ops (required, see errata)
 8004da0:	9311      	str	r3, [sp, #68]	; 0x44
#if HCLK_FREQUENCY == 80000000
    qh.Init.ClockPrescaler = 1;                 // prescaler (1=>80Mhz, 2=>40Mhz, etc)
#elif HCLK_FREQUENCY == 120000000
    qh.Init.ClockPrescaler = 2;                 // prescaler (1=>120Mhz, 2=>60Mhz, etc)
 8004da2:	f8cd 8048 	str.w	r8, [sp, #72]	; 0x48
#else
#   error "testing needed"
#endif
    qh.Init.DelayBlockBypass = HAL_OSPI_DELAY_BLOCK_BYPASSED;        // dont need it?
 8004da6:	f8cd 9058 	str.w	r9, [sp, #88]	; 0x58
    // ESP-PSRAM64H calls for max of 8us w/ CS low. Needs it for refresh time.
    // - stm32 datasheet says min 3 here; found 1-3 all work
    // - zero works, but CS is never released (but doesn't seem to affect operation?)
    // - (during reads) 3 => 400ns  4 => 660ns   5+ => 1us 
    // - LATER: Errata 2.8.1 => says shall not use
    qh.Init.ChipSelectBoundary = 0;
 8004daa:	9315      	str	r3, [sp, #84]	; 0x54

    // module init 
    HAL_StatusTypeDef rv = HAL_OSPI_Init(&qh);
 8004dac:	f005 ff6c 	bl	800ac88 <HAL_OSPI_Init>
    ASSERT(rv == HAL_OK);
 8004db0:	4607      	mov	r7, r0
 8004db2:	b110      	cbz	r0, 8004dba <psram_setup+0x9a>
 8004db4:	484f      	ldr	r0, [pc, #316]	; (8004ef4 <psram_setup+0x1d4>)
 8004db6:	f7fb fe11 	bl	80009dc <fatal_error>

    // do some SPI commands first

    // Exit Quad mode, to get to a known state, after first power-up
    psram_send_byte(&qh, 0xf5, true);
 8004dba:	4632      	mov	r2, r6
 8004dbc:	21f5      	movs	r1, #245	; 0xf5
 8004dbe:	a80a      	add	r0, sp, #40	; 0x28
 8004dc0:	f7ff ff96 	bl	8004cf0 <psram_send_byte>

    // Chip Reset sequence
    psram_send_byte(&qh, 0x66, false);      // reset enable
 8004dc4:	463a      	mov	r2, r7
 8004dc6:	2166      	movs	r1, #102	; 0x66
 8004dc8:	a80a      	add	r0, sp, #40	; 0x28
 8004dca:	f7ff ff91 	bl	8004cf0 <psram_send_byte>

    // Read Electronic ID
    // - length not clear from datasheet, but repeats after 8 bytes
    uint8_t psram_chip_eid[8];

    {   OSPI_RegularCmdTypeDef cmd = {
 8004dce:	ad32      	add	r5, sp, #200	; 0xc8
    // Exit Quad mode, to get to a known state, after first power-up
    psram_send_byte(&qh, 0xf5, true);

    // Chip Reset sequence
    psram_send_byte(&qh, 0x66, false);      // reset enable
    psram_send_byte(&qh, 0x99, false);      // reset
 8004dd0:	463a      	mov	r2, r7
 8004dd2:	2199      	movs	r1, #153	; 0x99
 8004dd4:	a80a      	add	r0, sp, #40	; 0x28
 8004dd6:	f7ff ff8b 	bl	8004cf0 <psram_send_byte>

    // Read Electronic ID
    // - length not clear from datasheet, but repeats after 8 bytes
    uint8_t psram_chip_eid[8];

    {   OSPI_RegularCmdTypeDef cmd = {
 8004dda:	4639      	mov	r1, r7
 8004ddc:	2250      	movs	r2, #80	; 0x50
 8004dde:	4628      	mov	r0, r5
 8004de0:	f008 fb71 	bl	800d4c6 <memset>
 8004de4:	239f      	movs	r3, #159	; 0x9f
 8004de6:	9334      	str	r3, [sp, #208]	; 0xd0
 8004de8:	f44f 7380 	mov.w	r3, #256	; 0x100
 8004dec:	9339      	str	r3, [sp, #228]	; 0xe4
 8004dee:	f44f 5700 	mov.w	r7, #8192	; 0x2000
 8004df2:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
            .DataMode = HAL_OSPI_DATA_1_LINE,
            .NbData = sizeof(psram_chip_eid),                        // how much to read in bytes
        };

        // Start a "Indirection functional mode" request
        rv = HAL_OSPI_Command(&qh, &cmd, HAL_MAX_DELAY);
 8004df6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8004dfa:	4629      	mov	r1, r5
 8004dfc:	a80a      	add	r0, sp, #40	; 0x28

    // Read Electronic ID
    // - length not clear from datasheet, but repeats after 8 bytes
    uint8_t psram_chip_eid[8];

    {   OSPI_RegularCmdTypeDef cmd = {
 8004dfe:	9635      	str	r6, [sp, #212]	; 0xd4
 8004e00:	973a      	str	r7, [sp, #232]	; 0xe8
 8004e02:	9340      	str	r3, [sp, #256]	; 0x100
 8004e04:	f8cd 9104 	str.w	r9, [sp, #260]	; 0x104
            .DataMode = HAL_OSPI_DATA_1_LINE,
            .NbData = sizeof(psram_chip_eid),                        // how much to read in bytes
        };

        // Start a "Indirection functional mode" request
        rv = HAL_OSPI_Command(&qh, &cmd, HAL_MAX_DELAY);
 8004e08:	f005 ffa8 	bl	800ad5c <HAL_OSPI_Command>
        if(rv != HAL_OK) goto fail;
 8004e0c:	2800      	cmp	r0, #0
 8004e0e:	d15f      	bne.n	8004ed0 <psram_setup+0x1b0>

        rv = HAL_OSPI_Receive(&qh, psram_chip_eid, HAL_MAX_DELAY);
 8004e10:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8004e14:	a903      	add	r1, sp, #12
 8004e16:	a80a      	add	r0, sp, #40	; 0x28
 8004e18:	f006 f8cc 	bl	800afb4 <HAL_OSPI_Receive>
        if(rv != HAL_OK) goto fail;
 8004e1c:	4681      	mov	r9, r0
 8004e1e:	2800      	cmp	r0, #0
 8004e20:	d156      	bne.n	8004ed0 <psram_setup+0x1b0>
    }

    //puts2("PSRAM EID: "); 
    //hex_dump(psram_chip_eid, sizeof(psram_chip_eid));
    ASSERT(psram_chip_eid[0] == 0x0d);
 8004e22:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8004e26:	2b0d      	cmp	r3, #13
 8004e28:	d1c4      	bne.n	8004db4 <psram_setup+0x94>
    ASSERT(psram_chip_eid[1] == 0x5d);
 8004e2a:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8004e2e:	2b5d      	cmp	r3, #93	; 0x5d
 8004e30:	d1c0      	bne.n	8004db4 <psram_setup+0x94>
    // .. other bits seem pretty similar between devices, they don't claim they are UUID

    // Put into Quad mode
    psram_send_byte(&qh, 0x35, false);  // 0x35 = Enter Quad Mode
 8004e32:	4602      	mov	r2, r0
 8004e34:	2135      	movs	r1, #53	; 0x35
 8004e36:	a80a      	add	r0, sp, #40	; 0x28
 8004e38:	f7ff ff5a 	bl	8004cf0 <psram_send_byte>

    // Configure read/write cycles for mem-mapped mode
    {   OSPI_RegularCmdTypeDef cmd = {
 8004e3c:	4649      	mov	r1, r9
 8004e3e:	2250      	movs	r2, #80	; 0x50
 8004e40:	a81e      	add	r0, sp, #120	; 0x78
 8004e42:	f008 fb40 	bl	800d4c6 <memset>
 8004e46:	f04f 0a03 	mov.w	sl, #3
 8004e4a:	f8cd 8078 	str.w	r8, [sp, #120]	; 0x78
 8004e4e:	f8cd 8080 	str.w	r8, [sp, #128]	; 0x80
            .DataMode = HAL_OSPI_DATA_4_LINES,
            .NbData = 0,                        // don't care / TBD?
        };

        // Config for write
        rv = HAL_OSPI_Command(&qh, &cmd, HAL_MAX_DELAY);
 8004e52:	a91e      	add	r1, sp, #120	; 0x78

    // Put into Quad mode
    psram_send_byte(&qh, 0x35, false);  // 0x35 = Enter Quad Mode

    // Configure read/write cycles for mem-mapped mode
    {   OSPI_RegularCmdTypeDef cmd = {
 8004e54:	f44f 7940 	mov.w	r9, #768	; 0x300
 8004e58:	f04f 7840 	mov.w	r8, #50331648	; 0x3000000
            .DataMode = HAL_OSPI_DATA_4_LINES,
            .NbData = 0,                        // don't care / TBD?
        };

        // Config for write
        rv = HAL_OSPI_Command(&qh, &cmd, HAL_MAX_DELAY);
 8004e5c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8004e60:	a80a      	add	r0, sp, #40	; 0x28

    // Put into Quad mode
    psram_send_byte(&qh, 0x35, false);  // 0x35 = Enter Quad Mode

    // Configure read/write cycles for mem-mapped mode
    {   OSPI_RegularCmdTypeDef cmd = {
 8004e62:	f8cd a084 	str.w	sl, [sp, #132]	; 0x84
 8004e66:	f8cd 9094 	str.w	r9, [sp, #148]	; 0x94
 8004e6a:	9726      	str	r7, [sp, #152]	; 0x98
 8004e6c:	f8cd 80b0 	str.w	r8, [sp, #176]	; 0xb0
            .DataMode = HAL_OSPI_DATA_4_LINES,
            .NbData = 0,                        // don't care / TBD?
        };

        // Config for write
        rv = HAL_OSPI_Command(&qh, &cmd, HAL_MAX_DELAY);
 8004e70:	f005 ff74 	bl	800ad5c <HAL_OSPI_Command>
        if(rv != HAL_OK) goto fail;
 8004e74:	4601      	mov	r1, r0
 8004e76:	bb58      	cbnz	r0, 8004ed0 <psram_setup+0x1b0>

        // .. for read
        OSPI_RegularCmdTypeDef cmd2 = {
 8004e78:	2250      	movs	r2, #80	; 0x50
 8004e7a:	4628      	mov	r0, r5
 8004e7c:	f008 fb23 	bl	800d4c6 <memset>
 8004e80:	23eb      	movs	r3, #235	; 0xeb
 8004e82:	9334      	str	r3, [sp, #208]	; 0xd0
            .DataMode = HAL_OSPI_DATA_4_LINES,
            .NbData = 0,                        // don't care / TBD?
        };

        // Config for read
        rv = HAL_OSPI_Command(&qh, &cmd2, HAL_MAX_DELAY);
 8004e84:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
        // Config for write
        rv = HAL_OSPI_Command(&qh, &cmd, HAL_MAX_DELAY);
        if(rv != HAL_OK) goto fail;

        // .. for read
        OSPI_RegularCmdTypeDef cmd2 = {
 8004e88:	2306      	movs	r3, #6
            .DataMode = HAL_OSPI_DATA_4_LINES,
            .NbData = 0,                        // don't care / TBD?
        };

        // Config for read
        rv = HAL_OSPI_Command(&qh, &cmd2, HAL_MAX_DELAY);
 8004e8a:	4629      	mov	r1, r5
 8004e8c:	a80a      	add	r0, sp, #40	; 0x28
        // Config for write
        rv = HAL_OSPI_Command(&qh, &cmd, HAL_MAX_DELAY);
        if(rv != HAL_OK) goto fail;

        // .. for read
        OSPI_RegularCmdTypeDef cmd2 = {
 8004e8e:	9632      	str	r6, [sp, #200]	; 0xc8
 8004e90:	f8cd a0d4 	str.w	sl, [sp, #212]	; 0xd4
 8004e94:	f8cd 90e4 	str.w	r9, [sp, #228]	; 0xe4
 8004e98:	973a      	str	r7, [sp, #232]	; 0xe8
 8004e9a:	f8cd 8100 	str.w	r8, [sp, #256]	; 0x100
 8004e9e:	9343      	str	r3, [sp, #268]	; 0x10c
            .DataMode = HAL_OSPI_DATA_4_LINES,
            .NbData = 0,                        // don't care / TBD?
        };

        // Config for read
        rv = HAL_OSPI_Command(&qh, &cmd2, HAL_MAX_DELAY);
 8004ea0:	f005 ff5c 	bl	800ad5c <HAL_OSPI_Command>
        if(rv != HAL_OK) goto fail;
 8004ea4:	b9a0      	cbnz	r0, 8004ed0 <psram_setup+0x1b0>
    }

    // config for memmap
    {   OSPI_MemoryMappedTypeDef mmap = {
 8004ea6:	3404      	adds	r4, #4
 8004ea8:	e894 0003 	ldmia.w	r4, {r0, r1}
 8004eac:	e885 0003 	stmia.w	r5, {r0, r1}
           // Need this so that CS lines returns to inactive sometimes.
          .TimeOutActivation = HAL_OSPI_TIMEOUT_COUNTER_ENABLE,
          .TimeOutPeriod = 16,          // no idea, max value 0xffff
        };

        rv = HAL_OSPI_MemoryMapped(&qh, &mmap);
 8004eb0:	4629      	mov	r1, r5
 8004eb2:	a80a      	add	r0, sp, #40	; 0x28
 8004eb4:	f006 f96e 	bl	800b194 <HAL_OSPI_MemoryMapped>
        if(rv != HAL_OK) goto fail;
 8004eb8:	b950      	cbnz	r0, 8004ed0 <psram_setup+0x1b0>
#else
    // Only a quick operational check only here. Non-destructive.
    {   __IO uint32_t    *ptr = (uint32_t *)(PSRAM_BASE+PSRAM_SIZE-4);
        uint32_t    tmp;

        tmp = *ptr;
 8004eba:	4b0f      	ldr	r3, [pc, #60]	; (8004ef8 <psram_setup+0x1d8>)
        *ptr = 0x55aa1234;
 8004ebc:	4a0f      	ldr	r2, [pc, #60]	; (8004efc <psram_setup+0x1dc>)
#else
    // Only a quick operational check only here. Non-destructive.
    {   __IO uint32_t    *ptr = (uint32_t *)(PSRAM_BASE+PSRAM_SIZE-4);
        uint32_t    tmp;

        tmp = *ptr;
 8004ebe:	6819      	ldr	r1, [r3, #0]
        *ptr = 0x55aa1234;
 8004ec0:	601a      	str	r2, [r3, #0]
        if(*ptr != 0x55aa1234) goto fail;
 8004ec2:	6818      	ldr	r0, [r3, #0]
 8004ec4:	4290      	cmp	r0, r2
 8004ec6:	d103      	bne.n	8004ed0 <psram_setup+0x1b0>
        *ptr = tmp;
 8004ec8:	6019      	str	r1, [r3, #0]

    oled_setup();
    oled_show(screen_fatal);

    LOCKUP_FOREVER();
}
 8004eca:	b046      	add	sp, #280	; 0x118
 8004ecc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
#endif

    return;

fail:
    puts("PSRAM fail");
 8004ed0:	480b      	ldr	r0, [pc, #44]	; (8004f00 <psram_setup+0x1e0>)
 8004ed2:	f7ff feef 	bl	8004cb4 <puts>

    oled_setup();
 8004ed6:	f7fb fefd 	bl	8000cd4 <oled_setup>
    oled_show(screen_fatal);
 8004eda:	480a      	ldr	r0, [pc, #40]	; (8004f04 <psram_setup+0x1e4>)
 8004edc:	f7fb ff8a 	bl	8000df4 <oled_show>

    LOCKUP_FOREVER();
 8004ee0:	bf30      	wfi
 8004ee2:	e7fd      	b.n	8004ee0 <psram_setup+0x1c0>
 8004ee4:	40021000 	.word	0x40021000
 8004ee8:	0800e4c8 	.word	0x0800e4c8
 8004eec:	48001000 	.word	0x48001000
 8004ef0:	a0001000 	.word	0xa0001000
 8004ef4:	0800d550 	.word	0x0800d550
 8004ef8:	907ffffc 	.word	0x907ffffc
 8004efc:	55aa1234 	.word	0x55aa1234
 8004f00:	0800e4e4 	.word	0x0800e4e4
 8004f04:	0800dcbd 	.word	0x0800dcbd

08004f08 <psram_wipe>:

// psram_wipe()
//
    void
psram_wipe(void)
{
 8004f08:	b508      	push	{r3, lr}
    if(OCTOSPI1->CR == 0) return;       // PSRAM not enabled (yet?)
 8004f0a:	4b06      	ldr	r3, [pc, #24]	; (8004f24 <psram_wipe+0x1c>)
 8004f0c:	681b      	ldr	r3, [r3, #0]
 8004f0e:	b143      	cbz	r3, 8004f22 <psram_wipe+0x1a>

    // Fast! But real; maybe 150ms
    //puts2("PSRAM Wipe: ");
    memset4((uint32_t *)PSRAM_BASE, rng_sample(), PSRAM_SIZE);
 8004f10:	f7fd fbba 	bl	8002688 <rng_sample>
 8004f14:	f04f 4310 	mov.w	r3, #2415919104	; 0x90000000
        *dest = value;
 8004f18:	f843 0b04 	str.w	r0, [r3], #4
// memset4()
//
    static inline void
memset4(uint32_t *dest, uint32_t value, uint32_t byte_len)
{
    for(; byte_len; byte_len-=4, dest++) {
 8004f1c:	f113 4fdf 	cmn.w	r3, #1870659584	; 0x6f800000
 8004f20:	d1fa      	bne.n	8004f18 <psram_wipe+0x10>
 8004f22:	bd08      	pop	{r3, pc}
 8004f24:	a0001000 	.word	0xa0001000

08004f28 <psram_do_upgrade>:
// NOTE: incoming start address is typically not aligned.
//
    void
psram_do_upgrade(const uint8_t *start, uint32_t size)
{
    ASSERT(size >= FW_MIN_LENGTH);
 8004f28:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000
//
// NOTE: incoming start address is typically not aligned.
//
    void
psram_do_upgrade(const uint8_t *start, uint32_t size)
{
 8004f2c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8004f30:	4607      	mov	r7, r0
 8004f32:	460e      	mov	r6, r1
    ASSERT(size >= FW_MIN_LENGTH);
 8004f34:	d202      	bcs.n	8004f3c <psram_do_upgrade+0x14>
 8004f36:	481d      	ldr	r0, [pc, #116]	; (8004fac <psram_do_upgrade+0x84>)
 8004f38:	f7fb fd50 	bl	80009dc <fatal_error>

    // In case of reset/crash, we can recover, so save
    // what we need for that -- yes, we will re-verify signatures
    volatile recovery_header_t   *h = RECHDR_POS;
    h->start = start;
 8004f3c:	4b1c      	ldr	r3, [pc, #112]	; (8004fb0 <psram_do_upgrade+0x88>)
    h->size = size;
    h->magic1 = RECHDR_MAGIC1;
 8004f3e:	4a1d      	ldr	r2, [pc, #116]	; (8004fb4 <psram_do_upgrade+0x8c>)
    ASSERT(size >= FW_MIN_LENGTH);

    // In case of reset/crash, we can recover, so save
    // what we need for that -- yes, we will re-verify signatures
    volatile recovery_header_t   *h = RECHDR_POS;
    h->start = start;
 8004f40:	6058      	str	r0, [r3, #4]
    h->size = size;
 8004f42:	6099      	str	r1, [r3, #8]
    h->magic1 = RECHDR_MAGIC1;
 8004f44:	601a      	str	r2, [r3, #0]
    h->magic2 = RECHDR_MAGIC2;
 8004f46:	4a1c      	ldr	r2, [pc, #112]	; (8004fb8 <psram_do_upgrade+0x90>)
 8004f48:	60da      	str	r2, [r3, #12]

    flash_setup0();
 8004f4a:	f7fd f845 	bl	8001fd8 <flash_setup0>
    flash_unlock();
 8004f4e:	f7fd f867 	bl	8002020 <flash_unlock>

    int rv;

    // one uint64_t at a time = 8 bytes
    uint64_t tmp;
    for(uint32_t pos=0; pos < size; pos += 8) {
 8004f52:	2400      	movs	r4, #0
        uint32_t dest = FIRMWARE_START+pos;

        if(dest % (4*FLASH_PAGE_SIZE) == 0) {
            // show some progress
            oled_show_progress(screen_upgrading, pos*100/size);
 8004f54:	f04f 0864 	mov.w	r8, #100	; 0x64
 8004f58:	f104 6500 	add.w	r5, r4, #134217728	; 0x8000000
 8004f5c:	f505 3500 	add.w	r5, r5, #131072	; 0x20000
    // one uint64_t at a time = 8 bytes
    uint64_t tmp;
    for(uint32_t pos=0; pos < size; pos += 8) {
        uint32_t dest = FIRMWARE_START+pos;

        if(dest % (4*FLASH_PAGE_SIZE) == 0) {
 8004f60:	f3c5 030d 	ubfx	r3, r5, #0, #14
 8004f64:	b933      	cbnz	r3, 8004f74 <psram_do_upgrade+0x4c>
            // show some progress
            oled_show_progress(screen_upgrading, pos*100/size);
 8004f66:	fb08 f104 	mul.w	r1, r8, r4
 8004f6a:	4814      	ldr	r0, [pc, #80]	; (8004fbc <psram_do_upgrade+0x94>)
 8004f6c:	fbb1 f1f6 	udiv	r1, r1, r6
 8004f70:	f7fb ff82 	bl	8000e78 <oled_show_progress>
        }

        if(dest % FLASH_PAGE_SIZE == 0) {
 8004f74:	f3c5 030b 	ubfx	r3, r5, #0, #12
 8004f78:	b923      	cbnz	r3, 8004f84 <psram_do_upgrade+0x5c>
            // page erase as we go
            rv = flash_page_erase(dest);
 8004f7a:	4628      	mov	r0, r5
 8004f7c:	f008 fad8 	bl	800d530 <__flash_page_erase_veneer>
            ASSERT(rv == 0);
 8004f80:	2800      	cmp	r0, #0
 8004f82:	d1d8      	bne.n	8004f36 <psram_do_upgrade+0xe>
        }

        memcpy(&tmp, start+pos, 8);
 8004f84:	193a      	adds	r2, r7, r4
 8004f86:	466b      	mov	r3, sp
 8004f88:	6810      	ldr	r0, [r2, #0]
 8004f8a:	6851      	ldr	r1, [r2, #4]
 8004f8c:	c303      	stmia	r3!, {r0, r1}
        rv = flash_burn(dest, tmp);
 8004f8e:	4628      	mov	r0, r5
 8004f90:	e9dd 2300 	ldrd	r2, r3, [sp]
 8004f94:	f008 fad4 	bl	800d540 <__flash_burn_veneer>
        ASSERT(rv == 0);
 8004f98:	2800      	cmp	r0, #0
 8004f9a:	d1cc      	bne.n	8004f36 <psram_do_upgrade+0xe>

    int rv;

    // one uint64_t at a time = 8 bytes
    uint64_t tmp;
    for(uint32_t pos=0; pos < size; pos += 8) {
 8004f9c:	3408      	adds	r4, #8
 8004f9e:	42a6      	cmp	r6, r4
 8004fa0:	d8da      	bhi.n	8004f58 <psram_do_upgrade+0x30>
        rv = flash_burn(dest, tmp);
        ASSERT(rv == 0);
    }

    flash_lock();
}
 8004fa2:	b002      	add	sp, #8
 8004fa4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        memcpy(&tmp, start+pos, 8);
        rv = flash_burn(dest, tmp);
        ASSERT(rv == 0);
    }

    flash_lock();
 8004fa8:	f7fd b832 	b.w	8002010 <flash_lock>
 8004fac:	0800d550 	.word	0x0800d550
 8004fb0:	907ff800 	.word	0x907ff800
 8004fb4:	dbcc8350 	.word	0xdbcc8350
 8004fb8:	bafcfba3 	.word	0xbafcfba3
 8004fbc:	0800dbff 	.word	0x0800dbff

08004fc0 <psram_recover_firmware>:
//
// Try to recover from interrupt PSRAM-based firmware upgrade.
//
    bool
psram_recover_firmware(void)
{
 8004fc0:	b510      	push	{r4, lr}
    volatile recovery_header_t   *h = RECHDR_POS;

    // Check header is valid.
    if(    (h->magic1 != RECHDR_MAGIC1)
 8004fc2:	4c1f      	ldr	r4, [pc, #124]	; (8005040 <psram_recover_firmware+0x80>)
 8004fc4:	4b1f      	ldr	r3, [pc, #124]	; (8005044 <psram_recover_firmware+0x84>)
 8004fc6:	6822      	ldr	r2, [r4, #0]
 8004fc8:	429a      	cmp	r2, r3
//
// Try to recover from interrupt PSRAM-based firmware upgrade.
//
    bool
psram_recover_firmware(void)
{
 8004fca:	b088      	sub	sp, #32
    volatile recovery_header_t   *h = RECHDR_POS;

    // Check header is valid.
    if(    (h->magic1 != RECHDR_MAGIC1)
 8004fcc:	d113      	bne.n	8004ff6 <psram_recover_firmware+0x36>
        || (h->magic2 != RECHDR_MAGIC2)
 8004fce:	68e2      	ldr	r2, [r4, #12]
 8004fd0:	4b1d      	ldr	r3, [pc, #116]	; (8005048 <psram_recover_firmware+0x88>)
 8004fd2:	429a      	cmp	r2, r3
 8004fd4:	d10f      	bne.n	8004ff6 <psram_recover_firmware+0x36>
        || ((uint32_t)h->start < PSRAM_BASE) 
 8004fd6:	6863      	ldr	r3, [r4, #4]
 8004fd8:	f1b3 4f10 	cmp.w	r3, #2415919104	; 0x90000000
 8004fdc:	d30b      	bcc.n	8004ff6 <psram_recover_firmware+0x36>
        || ((uint32_t)h->start >= PSRAM_BASE+(PSRAM_SIZE/2)) 
 8004fde:	6862      	ldr	r2, [r4, #4]
 8004fe0:	4b1a      	ldr	r3, [pc, #104]	; (800504c <psram_recover_firmware+0x8c>)
 8004fe2:	429a      	cmp	r2, r3
 8004fe4:	d807      	bhi.n	8004ff6 <psram_recover_firmware+0x36>
        || (h->size > FW_MAX_LENGTH_MK4) 
 8004fe6:	68a3      	ldr	r3, [r4, #8]
 8004fe8:	f5b3 1ff0 	cmp.w	r3, #1966080	; 0x1e0000
 8004fec:	d803      	bhi.n	8004ff6 <psram_recover_firmware+0x36>
        || (h->size < FW_MIN_LENGTH)
 8004fee:	68a3      	ldr	r3, [r4, #8]
 8004ff0:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8004ff4:	d201      	bcs.n	8004ffa <psram_recover_firmware+0x3a>
    ) {
        puts("PSR: nada");
 8004ff6:	4816      	ldr	r0, [pc, #88]	; (8005050 <psram_recover_firmware+0x90>)
 8004ff8:	e00c      	b.n	8005014 <psram_recover_firmware+0x54>
    }

    // Re-verify bytes and factory signature; will catch any bitrot in our 
    // PSRAM copy of firmware
    uint8_t     world_check[32];
    bool ok = verify_firmware_in_ram(h->start, h->size, world_check);
 8004ffa:	6860      	ldr	r0, [r4, #4]
 8004ffc:	68a1      	ldr	r1, [r4, #8]
 8004ffe:	466a      	mov	r2, sp
 8005000:	f7fc fe4a 	bl	8001c98 <verify_firmware_in_ram>

    if(!ok) {
 8005004:	b908      	cbnz	r0, 800500a <psram_recover_firmware+0x4a>
        puts("PSR: !check");
 8005006:	4813      	ldr	r0, [pc, #76]	; (8005054 <psram_recover_firmware+0x94>)
 8005008:	e004      	b.n	8005014 <psram_recover_firmware+0x54>
    }

    // Check we have the **right** firmware, based on the world check sum
    // but don't set the light at this point.
    // - this includes check over bootrom (ourselves)
    if(!verify_world_checksum(world_check)) {
 800500a:	4668      	mov	r0, sp
 800500c:	f7fc fe94 	bl	8001d38 <verify_world_checksum>
 8005010:	b928      	cbnz	r0, 800501e <psram_recover_firmware+0x5e>
        puts("PSR: version");
 8005012:	4811      	ldr	r0, [pc, #68]	; (8005058 <psram_recover_firmware+0x98>)
 8005014:	f7ff fe4e 	bl	8004cb4 <puts>
    // done
    NVIC_SystemReset();

    // not-reached
    return true;
}
 8005018:	2000      	movs	r0, #0
 800501a:	b008      	add	sp, #32
 800501c:	bd10      	pop	{r4, pc}
        puts("PSR: version");
        return false;
    }

    // Re-do the upgrade.
    psram_do_upgrade(h->start, h->size);
 800501e:	6860      	ldr	r0, [r4, #4]
 8005020:	68a1      	ldr	r1, [r4, #8]
 8005022:	f7ff ff81 	bl	8004f28 <psram_do_upgrade>
 8005026:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800502a:	490c      	ldr	r1, [pc, #48]	; (800505c <psram_recover_firmware+0x9c>)
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800502c:	4b0c      	ldr	r3, [pc, #48]	; (8005060 <psram_recover_firmware+0xa0>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800502e:	68ca      	ldr	r2, [r1, #12]
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8005030:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8005034:	4313      	orrs	r3, r2
 8005036:	60cb      	str	r3, [r1, #12]
 8005038:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 800503c:	bf00      	nop
 800503e:	e7fd      	b.n	800503c <psram_recover_firmware+0x7c>
 8005040:	907ff800 	.word	0x907ff800
 8005044:	dbcc8350 	.word	0xdbcc8350
 8005048:	bafcfba3 	.word	0xbafcfba3
 800504c:	903fffff 	.word	0x903fffff
 8005050:	0800e4ef 	.word	0x0800e4ef
 8005054:	0800e4f9 	.word	0x0800e4f9
 8005058:	0800e505 	.word	0x0800e505
 800505c:	e000ed00 	.word	0xe000ed00
 8005060:	05fa0004 	.word	0x05fa0004

08005064 <sdcard_light>:
// sdcard_light()
//
    void inline
sdcard_light(bool on)
{
    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7, !!on);    // turn LED off
 8005064:	4602      	mov	r2, r0
 8005066:	2180      	movs	r1, #128	; 0x80
 8005068:	4801      	ldr	r0, [pc, #4]	; (8005070 <sdcard_light+0xc>)
 800506a:	f7fc b925 	b.w	80012b8 <HAL_GPIO_WritePin>
 800506e:	bf00      	nop
 8005070:	48000800 	.word	0x48000800

08005074 <sdcard_is_inserted>:

// sdcard_is_inserted()
//
    bool
sdcard_is_inserted(void)
{
 8005074:	b508      	push	{r3, lr}
    return !!HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13); 
 8005076:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 800507a:	4803      	ldr	r0, [pc, #12]	; (8005088 <sdcard_is_inserted+0x14>)
 800507c:	f7fc f916 	bl	80012ac <HAL_GPIO_ReadPin>
}
 8005080:	3000      	adds	r0, #0
 8005082:	bf18      	it	ne
 8005084:	2001      	movne	r0, #1
 8005086:	bd08      	pop	{r3, pc}
 8005088:	48000800 	.word	0x48000800

0800508c <sdcard_try_file>:

// sdcard_try_file()
//
    void
sdcard_try_file(uint32_t blk_pos)
{
 800508c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800508e:	4604      	mov	r4, r0
 8005090:	b08b      	sub	sp, #44	; 0x2c
    oled_show(screen_verify);
 8005092:	4829      	ldr	r0, [pc, #164]	; (8005138 <sdcard_try_file+0xac>)
 8005094:	f7fb feae 	bl	8000df4 <oled_show>

    // read full possible file into PSRAM, assume continguous, and big enough
    uint8_t *tmp = (uint8_t *)PSRAM_BASE;
    
    int rv = HAL_SD_ReadBlocks(&hsd, tmp, blk_pos, FW_MAX_LENGTH_MK4 / 512, 60000);
 8005098:	f64e 2360 	movw	r3, #60000	; 0xea60
 800509c:	9300      	str	r3, [sp, #0]
 800509e:	4622      	mov	r2, r4
 80050a0:	f44f 6370 	mov.w	r3, #3840	; 0xf00
 80050a4:	f04f 4110 	mov.w	r1, #2415919104	; 0x90000000
 80050a8:	4824      	ldr	r0, [pc, #144]	; (800513c <sdcard_try_file+0xb0>)
 80050aa:	f006 fde3 	bl	800bc74 <HAL_SD_ReadBlocks>
    if(rv != HAL_OK) return;
 80050ae:	2800      	cmp	r0, #0
 80050b0:	d140      	bne.n	8005134 <sdcard_try_file+0xa8>
    } DFUElement_t;

    const DFUFile_t   *file = (const DFUFile_t *)ptr;
    ptr += sizeof(DFUFile_t);

    for(int idx=0; idx<file->targets; idx++) {
 80050b2:	f04f 4310 	mov.w	r3, #2415919104	; 0x90000000

        for(int ei=0; ei<target->elements; ei++) {
            const DFUElement_t   *elem = (const DFUElement_t *)ptr;
            ptr += sizeof(DFUElement_t);

            if(elem->addr == FIRMWARE_START) {
 80050b6:	4d22      	ldr	r5, [pc, #136]	; (8005140 <sdcard_try_file+0xb4>)
    } DFUElement_t;

    const DFUFile_t   *file = (const DFUFile_t *)ptr;
    ptr += sizeof(DFUFile_t);

    for(int idx=0; idx<file->targets; idx++) {
 80050b8:	7a99      	ldrb	r1, [r3, #10]
 80050ba:	330b      	adds	r3, #11
 80050bc:	4288      	cmp	r0, r1
 80050be:	da18      	bge.n	80050f2 <sdcard_try_file+0x66>
        const DFUTarget_t   *target = (const DFUTarget_t *)ptr;
        ptr += sizeof(DFUTarget_t);

        for(int ei=0; ei<target->elements; ei++) {
 80050c0:	f8d3 610e 	ldr.w	r6, [r3, #270]	; 0x10e
 80050c4:	2200      	movs	r2, #0
    const DFUFile_t   *file = (const DFUFile_t *)ptr;
    ptr += sizeof(DFUFile_t);

    for(int idx=0; idx<file->targets; idx++) {
        const DFUTarget_t   *target = (const DFUTarget_t *)ptr;
        ptr += sizeof(DFUTarget_t);
 80050c6:	f503 7389 	add.w	r3, r3, #274	; 0x112

        for(int ei=0; ei<target->elements; ei++) {
 80050ca:	4296      	cmp	r6, r2
 80050cc:	d00f      	beq.n	80050ee <sdcard_try_file+0x62>
            const DFUElement_t   *elem = (const DFUElement_t *)ptr;
            ptr += sizeof(DFUElement_t);

            if(elem->addr == FIRMWARE_START) {
 80050ce:	681f      	ldr	r7, [r3, #0]
 80050d0:	42af      	cmp	r7, r5
        const DFUTarget_t   *target = (const DFUTarget_t *)ptr;
        ptr += sizeof(DFUTarget_t);

        for(int ei=0; ei<target->elements; ei++) {
            const DFUElement_t   *elem = (const DFUElement_t *)ptr;
            ptr += sizeof(DFUElement_t);
 80050d2:	f103 0408 	add.w	r4, r3, #8

            if(elem->addr == FIRMWARE_START) {
 80050d6:	d107      	bne.n	80050e8 <sdcard_try_file+0x5c>
                *target_size = elem->size;
 80050d8:	685d      	ldr	r5, [r3, #4]
    uint32_t    len = 0;
    const uint8_t *start = dfu_hdr_parse(tmp, &len);
    if(!start) return;

    uint8_t world_check[32];
    bool ok = verify_firmware_in_ram(start, len, world_check);
 80050da:	aa02      	add	r2, sp, #8
 80050dc:	4629      	mov	r1, r5
 80050de:	4620      	mov	r0, r4
 80050e0:	f7fc fdda 	bl	8001c98 <verify_firmware_in_ram>

    // msg already printed, if corrupt image
    if(!ok) return;
 80050e4:	b330      	cbz	r0, 8005134 <sdcard_try_file+0xa8>
 80050e6:	e006      	b.n	80050f6 <sdcard_try_file+0x6a>

    for(int idx=0; idx<file->targets; idx++) {
        const DFUTarget_t   *target = (const DFUTarget_t *)ptr;
        ptr += sizeof(DFUTarget_t);

        for(int ei=0; ei<target->elements; ei++) {
 80050e8:	3201      	adds	r2, #1
            const DFUElement_t   *elem = (const DFUElement_t *)ptr;
            ptr += sizeof(DFUElement_t);
 80050ea:	4623      	mov	r3, r4
 80050ec:	e7ed      	b.n	80050ca <sdcard_try_file+0x3e>
    } DFUElement_t;

    const DFUFile_t   *file = (const DFUFile_t *)ptr;
    ptr += sizeof(DFUFile_t);

    for(int idx=0; idx<file->targets; idx++) {
 80050ee:	3001      	adds	r0, #1
 80050f0:	e7e4      	b.n	80050bc <sdcard_try_file+0x30>
        }
    }

    // Mk3 and earlier firmwares will fail here because the load address is
    // different from Mk4 images.
    puts("DFU parse fail");
 80050f2:	4814      	ldr	r0, [pc, #80]	; (8005144 <sdcard_try_file+0xb8>)
 80050f4:	e007      	b.n	8005106 <sdcard_try_file+0x7a>

    // msg already printed, if corrupt image
    if(!ok) return;

    // it is a valid, signed image
    puts("good firmware");
 80050f6:	4814      	ldr	r0, [pc, #80]	; (8005148 <sdcard_try_file+0xbc>)
 80050f8:	f7ff fddc 	bl	8004cb4 <puts>

    // Check we have the **right** firmware, based on the world check sum
    // but don't set the light at this point.
    // - this includes check over bootrom (ourselves)
    if(!verify_world_checksum(world_check)) {
 80050fc:	a802      	add	r0, sp, #8
 80050fe:	f7fc fe1b 	bl	8001d38 <verify_world_checksum>
 8005102:	b918      	cbnz	r0, 800510c <sdcard_try_file+0x80>
        puts("wrong world");
 8005104:	4811      	ldr	r0, [pc, #68]	; (800514c <sdcard_try_file+0xc0>)
 8005106:	f7ff fdd5 	bl	8004cb4 <puts>
 800510a:	e013      	b.n	8005134 <sdcard_try_file+0xa8>
        return;
    }

    sdcard_light(false);
 800510c:	2000      	movs	r0, #0
 800510e:	f7ff ffa9 	bl	8005064 <sdcard_light>

    // Do the upgrade, using PSRAM data.
    psram_do_upgrade(start, len);
 8005112:	4629      	mov	r1, r5
 8005114:	4620      	mov	r0, r4
 8005116:	f7ff ff07 	bl	8004f28 <psram_do_upgrade>
 800511a:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800511e:	490c      	ldr	r1, [pc, #48]	; (8005150 <sdcard_try_file+0xc4>)
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8005120:	4b0c      	ldr	r3, [pc, #48]	; (8005154 <sdcard_try_file+0xc8>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8005122:	68ca      	ldr	r2, [r1, #12]
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8005124:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8005128:	4313      	orrs	r3, r2
 800512a:	60cb      	str	r3, [r1, #12]
 800512c:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 8005130:	bf00      	nop
 8005132:	e7fd      	b.n	8005130 <sdcard_try_file+0xa4>

    // done
    NVIC_SystemReset();
}
 8005134:	b00b      	add	sp, #44	; 0x2c
 8005136:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005138:	0800d622 	.word	0x0800d622
 800513c:	200003c4 	.word	0x200003c4
 8005140:	08020000 	.word	0x08020000
 8005144:	0800e53c 	.word	0x0800e53c
 8005148:	0800e54b 	.word	0x0800e54b
 800514c:	0800e559 	.word	0x0800e559
 8005150:	e000ed00 	.word	0xe000ed00
 8005154:	05fa0004 	.word	0x05fa0004

08005158 <sdcard_search>:

// sdcard_search()
//
    void
sdcard_search(void)
{
 8005158:	b5f0      	push	{r4, r5, r6, r7, lr}
    oled_show(screen_search);
 800515a:	4850      	ldr	r0, [pc, #320]	; (800529c <sdcard_search+0x144>)

// sdcard_search()
//
    void
sdcard_search(void)
{
 800515c:	f5ad 7d05 	sub.w	sp, sp, #532	; 0x214
    oled_show(screen_search);
 8005160:	f7fb fe48 	bl	8000df4 <oled_show>

    if(!sdcard_is_inserted()) return;
 8005164:	f7ff ff86 	bl	8005074 <sdcard_is_inserted>
 8005168:	2800      	cmp	r0, #0
 800516a:	f000 8094 	beq.w	8005296 <sdcard_search+0x13e>
    static void
sdcard_setup(void)
{
    // pinout setup

    __HAL_RCC_SDMMC1_CLK_ENABLE();
 800516e:	4e4c      	ldr	r6, [pc, #304]	; (80052a0 <sdcard_search+0x148>)
    if(!sdcard_is_inserted()) return;

    uint32_t num_blocks;

    // open card (power it) and get details, do setup
    puts2("SDCard: ");
 8005170:	484c      	ldr	r0, [pc, #304]	; (80052a4 <sdcard_search+0x14c>)

    __HAL_RCC_SDMMC1_CLK_ENABLE();

    // Configure pins: Port C: C8-C13, PD2=CMD
    // - C7 (light), and C13 (detect) already setup in gpio_setup
    {   GPIO_InitTypeDef setup = {
 8005172:	4c4d      	ldr	r4, [pc, #308]	; (80052a8 <sdcard_search+0x150>)
    if(!sdcard_is_inserted()) return;

    uint32_t num_blocks;

    // open card (power it) and get details, do setup
    puts2("SDCard: ");
 8005174:	f7ff fd10 	bl	8004b98 <puts2>
    static void
sdcard_setup(void)
{
    // pinout setup

    __HAL_RCC_SDMMC1_CLK_ENABLE();
 8005178:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
 800517a:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800517e:	64f3      	str	r3, [r6, #76]	; 0x4c
 8005180:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
 8005182:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8005186:	9303      	str	r3, [sp, #12]
 8005188:	9b03      	ldr	r3, [sp, #12]

    // Configure pins: Port C: C8-C13, PD2=CMD
    // - C7 (light), and C13 (detect) already setup in gpio_setup
    {   GPIO_InitTypeDef setup = {
 800518a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800518c:	ad04      	add	r5, sp, #16
 800518e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8005190:	f854 3b04 	ldr.w	r3, [r4], #4
            .Mode = GPIO_MODE_AF_PP,            // not sure
            .Pull = GPIO_PULLUP,
            .Speed = GPIO_SPEED_FREQ_VERY_HIGH,
            .Alternate = GPIO_AF12_SDMMC1,
        };
        HAL_GPIO_Init(GPIOC, &setup);
 8005194:	4845      	ldr	r0, [pc, #276]	; (80052ac <sdcard_search+0x154>)

    __HAL_RCC_SDMMC1_CLK_ENABLE();

    // Configure pins: Port C: C8-C13, PD2=CMD
    // - C7 (light), and C13 (detect) already setup in gpio_setup
    {   GPIO_InitTypeDef setup = {
 8005196:	602b      	str	r3, [r5, #0]
            .Mode = GPIO_MODE_AF_PP,            // not sure
            .Pull = GPIO_PULLUP,
            .Speed = GPIO_SPEED_FREQ_VERY_HIGH,
            .Alternate = GPIO_AF12_SDMMC1,
        };
        HAL_GPIO_Init(GPIOC, &setup);
 8005198:	a904      	add	r1, sp, #16
 800519a:	f7fb ff11 	bl	8000fc0 <HAL_GPIO_Init>
    }

    // PD2 = CMD
    {   GPIO_InitTypeDef setup = {
 800519e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80051a0:	af04      	add	r7, sp, #16
 80051a2:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 80051a4:	6823      	ldr	r3, [r4, #0]
            .Mode = GPIO_MODE_AF_PP,            // not sure
            .Pull = GPIO_PULLUP,
            .Speed = GPIO_SPEED_FREQ_VERY_HIGH,
            .Alternate = GPIO_AF12_SDMMC1,
        };
        HAL_GPIO_Init(GPIOD, &setup);
 80051a6:	4842      	ldr	r0, [pc, #264]	; (80052b0 <sdcard_search+0x158>)
        };
        HAL_GPIO_Init(GPIOC, &setup);
    }

    // PD2 = CMD
    {   GPIO_InitTypeDef setup = {
 80051a8:	602b      	str	r3, [r5, #0]
            .Mode = GPIO_MODE_AF_PP,            // not sure
            .Pull = GPIO_PULLUP,
            .Speed = GPIO_SPEED_FREQ_VERY_HIGH,
            .Alternate = GPIO_AF12_SDMMC1,
        };
        HAL_GPIO_Init(GPIOD, &setup);
 80051aa:	a904      	add	r1, sp, #16
 80051ac:	f7fb ff08 	bl	8000fc0 <HAL_GPIO_Init>
    }

    // reset module
    __HAL_RCC_SDMMC1_FORCE_RESET();
 80051b0:	6af3      	ldr	r3, [r6, #44]	; 0x2c
// sdcard_probe()
//
    static bool
sdcard_probe(uint32_t *num_blocks)
{
    memset(&hsd, 0, sizeof(SD_HandleTypeDef));
 80051b2:	4c40      	ldr	r4, [pc, #256]	; (80052b4 <sdcard_search+0x15c>)
        };
        HAL_GPIO_Init(GPIOD, &setup);
    }

    // reset module
    __HAL_RCC_SDMMC1_FORCE_RESET();
 80051b4:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 80051b8:	62f3      	str	r3, [r6, #44]	; 0x2c
    __HAL_RCC_SDMMC1_RELEASE_RESET();
 80051ba:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 80051bc:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 80051c0:	62f3      	str	r3, [r6, #44]	; 0x2c
// sdcard_probe()
//
    static bool
sdcard_probe(uint32_t *num_blocks)
{
    memset(&hsd, 0, sizeof(SD_HandleTypeDef));
 80051c2:	2280      	movs	r2, #128	; 0x80
 80051c4:	2100      	movs	r1, #0
 80051c6:	4620      	mov	r0, r4
 80051c8:	f008 f97d 	bl	800d4c6 <memset>

    puts2("SDCard: ");
 80051cc:	4835      	ldr	r0, [pc, #212]	; (80052a4 <sdcard_search+0x14c>)
 80051ce:	f7ff fce3 	bl	8004b98 <puts2>

    hsd.Instance = SDMMC1;
 80051d2:	4b39      	ldr	r3, [pc, #228]	; (80052b8 <sdcard_search+0x160>)
 80051d4:	6023      	str	r3, [r4, #0]
    hsd.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
 80051d6:	2300      	movs	r3, #0
 80051d8:	6063      	str	r3, [r4, #4]
    hsd.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_ENABLE;
 80051da:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    hsd.Init.BusWide = SDMMC_BUS_WIDE_1B;
 80051de:	60e3      	str	r3, [r4, #12]
    hsd.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
 80051e0:	6123      	str	r3, [r4, #16]
    hsd.Init.ClockDiv = SDMMC_TRANSFER_CLK_DIV;

    int rv = HAL_SD_Init(&hsd);
 80051e2:	4620      	mov	r0, r4
    hsd.Instance = SDMMC1;
    hsd.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
    hsd.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_ENABLE;
    hsd.Init.BusWide = SDMMC_BUS_WIDE_1B;
    hsd.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
    hsd.Init.ClockDiv = SDMMC_TRANSFER_CLK_DIV;
 80051e4:	2303      	movs	r3, #3

    puts2("SDCard: ");

    hsd.Instance = SDMMC1;
    hsd.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
    hsd.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_ENABLE;
 80051e6:	60a2      	str	r2, [r4, #8]
    hsd.Init.BusWide = SDMMC_BUS_WIDE_1B;
    hsd.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
    hsd.Init.ClockDiv = SDMMC_TRANSFER_CLK_DIV;
 80051e8:	6163      	str	r3, [r4, #20]

    int rv = HAL_SD_Init(&hsd);
 80051ea:	f007 fad3 	bl	800c794 <HAL_SD_Init>
    if(rv != HAL_OK) {
 80051ee:	4605      	mov	r5, r0
 80051f0:	b108      	cbz	r0, 80051f6 <sdcard_search+0x9e>
        puts("init fail");
 80051f2:	4832      	ldr	r0, [pc, #200]	; (80052bc <sdcard_search+0x164>)
 80051f4:	e02e      	b.n	8005254 <sdcard_search+0xfc>
        return false;
    }

    sdcard_light(true);
 80051f6:	2001      	movs	r0, #1
 80051f8:	f7ff ff34 	bl	8005064 <sdcard_light>

    rv = HAL_SD_ConfigSpeedBusOperation(&hsd, SDMMC_SPEED_MODE_AUTO);
 80051fc:	4629      	mov	r1, r5
 80051fe:	4620      	mov	r0, r4
 8005200:	f007 fb9a 	bl	800c938 <HAL_SD_ConfigSpeedBusOperation>
    if(rv != HAL_OK) {
 8005204:	b108      	cbz	r0, 800520a <sdcard_search+0xb2>
        puts("speed");
 8005206:	482e      	ldr	r0, [pc, #184]	; (80052c0 <sdcard_search+0x168>)
 8005208:	e024      	b.n	8005254 <sdcard_search+0xfc>
        return false;
    }

    // configure the SD bus width for 4-bit wide operation
    rv = HAL_SD_ConfigWideBusOperation(&hsd, SDMMC_BUS_WIDE_4B);
 800520a:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 800520e:	4620      	mov	r0, r4
 8005210:	f007 f9ee 	bl	800c5f0 <HAL_SD_ConfigWideBusOperation>
    if(rv != HAL_OK) {
 8005214:	4605      	mov	r5, r0
 8005216:	b108      	cbz	r0, 800521c <sdcard_search+0xc4>
        puts("wide");
 8005218:	482a      	ldr	r0, [pc, #168]	; (80052c4 <sdcard_search+0x16c>)
 800521a:	e01b      	b.n	8005254 <sdcard_search+0xfc>
        return false;
    }

    if(hsd.SdCard.BlockSize != 512) {
 800521c:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800521e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8005222:	d001      	beq.n	8005228 <sdcard_search+0xd0>
        puts("bsize?");
 8005224:	4828      	ldr	r0, [pc, #160]	; (80052c8 <sdcard_search+0x170>)
 8005226:	e015      	b.n	8005254 <sdcard_search+0xfc>
        return false;
    }

    *num_blocks = hsd.SdCard.BlockNbr;

    puts("ok");
 8005228:	4828      	ldr	r0, [pc, #160]	; (80052cc <sdcard_search+0x174>)
    if(hsd.SdCard.BlockSize != 512) {
        puts("bsize?");
        return false;
    }

    *num_blocks = hsd.SdCard.BlockNbr;
 800522a:	6ce6      	ldr	r6, [r4, #76]	; 0x4c

    puts("ok");
 800522c:	f7ff fd42 	bl	8004cb4 <puts>
 8005230:	462c      	mov	r4, r5
 8005232:	e002      	b.n	800523a <sdcard_search+0xe2>
            sdcard_try_file(pos);

            goto redraw;
        }

        if(pos % 128 == 0) {
 8005234:	0663      	lsls	r3, r4, #25
 8005236:	d023      	beq.n	8005280 <sdcard_search+0x128>
    puts2("SDCard: ");
    sdcard_setup();
    if(!sdcard_probe(&num_blocks)) return;

    uint8_t     blk[512];
    for(int pos=0; pos<num_blocks; pos += 1) {
 8005238:	3401      	adds	r4, #1
 800523a:	42b4      	cmp	r4, r6
 800523c:	d02b      	beq.n	8005296 <sdcard_search+0x13e>
        // read a single block
        int rv = HAL_SD_ReadBlocks(&hsd, blk, pos, 1, 60000);
 800523e:	f64e 2360 	movw	r3, #60000	; 0xea60
 8005242:	9300      	str	r3, [sp, #0]
 8005244:	4622      	mov	r2, r4
 8005246:	2301      	movs	r3, #1
 8005248:	a904      	add	r1, sp, #16
 800524a:	481a      	ldr	r0, [pc, #104]	; (80052b4 <sdcard_search+0x15c>)
 800524c:	f006 fd12 	bl	800bc74 <HAL_SD_ReadBlocks>
        if(rv != HAL_OK) {
 8005250:	b118      	cbz	r0, 800525a <sdcard_search+0x102>
            puts("fail read");
 8005252:	481f      	ldr	r0, [pc, #124]	; (80052d0 <sdcard_search+0x178>)
 8005254:	f7ff fd2e 	bl	8004cb4 <puts>

            return;
 8005258:	e01d      	b.n	8005296 <sdcard_search+0x13e>
        }

        if(memcmp(blk, "DfuSe", 5) == 0) {
 800525a:	2205      	movs	r2, #5
 800525c:	491d      	ldr	r1, [pc, #116]	; (80052d4 <sdcard_search+0x17c>)
 800525e:	a804      	add	r0, sp, #16
 8005260:	f008 f8fc 	bl	800d45c <memcmp>
 8005264:	2800      	cmp	r0, #0
 8005266:	d1e5      	bne.n	8005234 <sdcard_search+0xdc>
            // candidate file found
            puts2("found @ ");
 8005268:	481b      	ldr	r0, [pc, #108]	; (80052d8 <sdcard_search+0x180>)
 800526a:	f7ff fc95 	bl	8004b98 <puts2>
            puthex8(pos);
 800526e:	4620      	mov	r0, r4
 8005270:	f7ff fcee 	bl	8004c50 <puthex8>
            putchar('\n');
 8005274:	200a      	movs	r0, #10
 8005276:	f7ff fca3 	bl	8004bc0 <putchar>

            sdcard_try_file(pos);
 800527a:	4620      	mov	r0, r4
 800527c:	f7ff ff06 	bl	800508c <sdcard_try_file>
            goto redraw;
        }

        if(pos % 128 == 0) {
        redraw:
            oled_show_progress(screen_search, pos*100 / num_blocks);
 8005280:	2164      	movs	r1, #100	; 0x64
 8005282:	4361      	muls	r1, r4
 8005284:	4805      	ldr	r0, [pc, #20]	; (800529c <sdcard_search+0x144>)
 8005286:	fbb1 f1f6 	udiv	r1, r1, r6
 800528a:	f7fb fdf5 	bl	8000e78 <oled_show_progress>
            sdcard_light(true);
 800528e:	2001      	movs	r0, #1
 8005290:	f7ff fee8 	bl	8005064 <sdcard_light>
 8005294:	e7d0      	b.n	8005238 <sdcard_search+0xe0>
        }
    }

}
 8005296:	f50d 7d05 	add.w	sp, sp, #532	; 0x214
 800529a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800529c:	0800debd 	.word	0x0800debd
 80052a0:	40021000 	.word	0x40021000
 80052a4:	0800e565 	.word	0x0800e565
 80052a8:	0800e514 	.word	0x0800e514
 80052ac:	48000800 	.word	0x48000800
 80052b0:	48000c00 	.word	0x48000c00
 80052b4:	200003c4 	.word	0x200003c4
 80052b8:	50062400 	.word	0x50062400
 80052bc:	0800e56e 	.word	0x0800e56e
 80052c0:	0800e578 	.word	0x0800e578
 80052c4:	0800e57e 	.word	0x0800e57e
 80052c8:	0800e583 	.word	0x0800e583
 80052cc:	0800e58a 	.word	0x0800e58a
 80052d0:	0800e58d 	.word	0x0800e58d
 80052d4:	0800e597 	.word	0x0800e597
 80052d8:	0800e59d 	.word	0x0800e59d

080052dc <sdcard_recovery>:

// sdcard_recovery()
//
    void
sdcard_recovery(void)
{
 80052dc:	b508      	push	{r3, lr}
    // Use SDCard to recover. Must be precise version they tried to
    // install before, and will be slow AF.

    puts("Recovery mode.");
 80052de:	480b      	ldr	r0, [pc, #44]	; (800530c <sdcard_recovery+0x30>)
 80052e0:	f7ff fce8 	bl	8004cb4 <puts>

    while(1) {
        // .. need them to insert a card
        
        sdcard_light(false);
 80052e4:	2000      	movs	r0, #0
 80052e6:	f7ff febd 	bl	8005064 <sdcard_light>
        while(!sdcard_is_inserted()) {
 80052ea:	f7ff fec3 	bl	8005074 <sdcard_is_inserted>
 80052ee:	b930      	cbnz	r0, 80052fe <sdcard_recovery+0x22>
            oled_show(screen_recovery);
 80052f0:	4807      	ldr	r0, [pc, #28]	; (8005310 <sdcard_recovery+0x34>)
 80052f2:	f7fb fd7f 	bl	8000df4 <oled_show>
            delay_ms(200);
 80052f6:	20c8      	movs	r0, #200	; 0xc8
 80052f8:	f7fe fac6 	bl	8003888 <delay_ms>
 80052fc:	e7f5      	b.n	80052ea <sdcard_recovery+0xe>
        }
            
        // look for binary, will reset system if successful
        sdcard_light(true);
 80052fe:	2001      	movs	r0, #1
 8005300:	f7ff feb0 	bl	8005064 <sdcard_light>
        sdcard_search();
 8005304:	f7ff ff28 	bl	8005158 <sdcard_search>
    }
 8005308:	e7ec      	b.n	80052e4 <sdcard_recovery+0x8>
 800530a:	bf00      	nop
 800530c:	0800e5a6 	.word	0x0800e5a6
 8005310:	0800dfed 	.word	0x0800dfed

08005314 <HAL_HASHEx_SHA256_Accmlt>:
#include <string.h>

// so we don't need stm32l4xx_hal_hash_ex.c
HAL_StatusTypeDef HAL_HASHEx_SHA256_Accmlt(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
  return HASH_Accumulate(hhash, pInBuffer, Size,HASH_ALGOSELECTION_SHA256);
 8005314:	4b01      	ldr	r3, [pc, #4]	; (800531c <HAL_HASHEx_SHA256_Accmlt+0x8>)
 8005316:	f005 b9e3 	b.w	800a6e0 <HASH_Accumulate>
 800531a:	bf00      	nop
 800531c:	00040080 	.word	0x00040080

08005320 <HAL_HASHEx_SHA256_Start>:
}

HAL_StatusTypeDef HAL_HASHEx_SHA256_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout)
{
 8005320:	b513      	push	{r0, r1, r4, lr}
  return HASH_Start(hhash, pInBuffer, Size, pOutBuffer, Timeout, HASH_ALGOSELECTION_SHA256);
 8005322:	4c04      	ldr	r4, [pc, #16]	; (8005334 <HAL_HASHEx_SHA256_Start+0x14>)
 8005324:	9401      	str	r4, [sp, #4]
 8005326:	9c04      	ldr	r4, [sp, #16]
 8005328:	9400      	str	r4, [sp, #0]
 800532a:	f005 f933 	bl	800a594 <HASH_Start>
}
 800532e:	b002      	add	sp, #8
 8005330:	bd10      	pop	{r4, pc}
 8005332:	bf00      	nop
 8005334:	00040080 	.word	0x00040080

08005338 <HAL_HMACEx_SHA256_Start>:

HAL_StatusTypeDef HAL_HMACEx_SHA256_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout)
{
 8005338:	b513      	push	{r0, r1, r4, lr}
  return HMAC_Start(hhash, pInBuffer, Size, pOutBuffer, Timeout, HASH_ALGOSELECTION_SHA256);
 800533a:	4c04      	ldr	r4, [pc, #16]	; (800534c <HAL_HMACEx_SHA256_Start+0x14>)
 800533c:	9401      	str	r4, [sp, #4]
 800533e:	9c04      	ldr	r4, [sp, #16]
 8005340:	9400      	str	r4, [sp, #0]
 8005342:	f005 fb79 	bl	800aa38 <HMAC_Start>
}
 8005346:	b002      	add	sp, #8
 8005348:	bd10      	pop	{r4, pc}
 800534a:	bf00      	nop
 800534c:	00040080 	.word	0x00040080

08005350 <sha256_init>:

void sha256_init(SHA256_CTX *ctx)
{
 8005350:	b510      	push	{r4, lr}
    memset(ctx, 0, sizeof(SHA256_CTX));
 8005352:	224c      	movs	r2, #76	; 0x4c
{
  return HMAC_Start(hhash, pInBuffer, Size, pOutBuffer, Timeout, HASH_ALGOSELECTION_SHA256);
}

void sha256_init(SHA256_CTX *ctx)
{
 8005354:	4604      	mov	r4, r0
    memset(ctx, 0, sizeof(SHA256_CTX));
 8005356:	2100      	movs	r1, #0
 8005358:	f008 f8b5 	bl	800d4c6 <memset>

#if 1
    ctx->num_pending = 0;
 800535c:	2300      	movs	r3, #0
 800535e:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
    ctx->hh.Init.DataType = HASH_DATATYPE_8B;
 8005362:	2320      	movs	r3, #32
 8005364:	6023      	str	r3, [r4, #0]
    HAL_HASH_Init(&ctx->hh);
 8005366:	4620      	mov	r0, r4
    __HAL_HASH_RESET_MDMAT();

    MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT,
            HASH_ALGOSELECTION_SHA256 | HASH_CR_INIT);
#endif
}
 8005368:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    memset(ctx, 0, sizeof(SHA256_CTX));

#if 1
    ctx->num_pending = 0;
    ctx->hh.Init.DataType = HASH_DATATYPE_8B;
    HAL_HASH_Init(&ctx->hh);
 800536c:	f004 bf9c 	b.w	800a2a8 <HAL_HASH_Init>

08005370 <sha256_update>:
            HASH_ALGOSELECTION_SHA256 | HASH_CR_INIT);
#endif
}

void sha256_update(SHA256_CTX *ctx, const uint8_t data[], uint32_t len)
{
 8005370:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    HAL_StatusTypeDef rv;

    // clear out any pending bytes
    if(ctx->num_pending + len >= 4) {
 8005372:	f890 3048 	ldrb.w	r3, [r0, #72]	; 0x48
 8005376:	4413      	add	r3, r2
 8005378:	2b03      	cmp	r3, #3
            HASH_ALGOSELECTION_SHA256 | HASH_CR_INIT);
#endif
}

void sha256_update(SHA256_CTX *ctx, const uint8_t data[], uint32_t len)
{
 800537a:	4605      	mov	r5, r0
 800537c:	460e      	mov	r6, r1
 800537e:	4614      	mov	r4, r2
    HAL_StatusTypeDef rv;

    // clear out any pending bytes
    if(ctx->num_pending + len >= 4) {
 8005380:	d91c      	bls.n	80053bc <sha256_update+0x4c>
        while(ctx->num_pending != 4) {
 8005382:	f895 3048 	ldrb.w	r3, [r5, #72]	; 0x48
 8005386:	2b04      	cmp	r3, #4
 8005388:	d009      	beq.n	800539e <sha256_update+0x2e>
            ctx->pending[ctx->num_pending++] = *data;
 800538a:	1c5a      	adds	r2, r3, #1
 800538c:	f885 2048 	strb.w	r2, [r5, #72]	; 0x48
 8005390:	442b      	add	r3, r5
 8005392:	f816 2b01 	ldrb.w	r2, [r6], #1
 8005396:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
            data += 1;
            len -= 1;
            if(!len) break;
 800539a:	3c01      	subs	r4, #1
 800539c:	d1f1      	bne.n	8005382 <sha256_update+0x12>
        }
        if(ctx->num_pending == 4) {
 800539e:	f895 2048 	ldrb.w	r2, [r5, #72]	; 0x48
 80053a2:	2a04      	cmp	r2, #4
 80053a4:	d10a      	bne.n	80053bc <sha256_update+0x4c>
#if 1
            rv = HAL_HASHEx_SHA256_Accumulate(&ctx->hh, ctx->pending, 4);
 80053a6:	f105 0144 	add.w	r1, r5, #68	; 0x44
 80053aa:	4628      	mov	r0, r5
 80053ac:	f7ff ffb2 	bl	8005314 <HAL_HASHEx_SHA256_Accmlt>
            ASSERT(rv == HAL_OK);
 80053b0:	b110      	cbz	r0, 80053b8 <sha256_update+0x48>
 80053b2:	4811      	ldr	r0, [pc, #68]	; (80053f8 <sha256_update+0x88>)
 80053b4:	f7fb fb12 	bl	80009dc <fatal_error>
#else
            HASH->DIN = *(uint32_t*)&ctx->pending;
#endif
            ctx->num_pending = 0;
 80053b8:	f885 0048 	strb.w	r0, [r5, #72]	; 0x48
        }
    }

    // write full blocks
    uint32_t blocks = len / 4;
    if(blocks) {
 80053bc:	08a7      	lsrs	r7, r4, #2
 80053be:	d00b      	beq.n	80053d8 <sha256_update+0x68>
#if 1
        rv = HAL_HASHEx_SHA256_Accumulate(&ctx->hh, (uint8_t *)data, blocks*4);
 80053c0:	00bf      	lsls	r7, r7, #2
 80053c2:	463a      	mov	r2, r7
 80053c4:	4631      	mov	r1, r6
 80053c6:	4628      	mov	r0, r5
 80053c8:	f7ff ffa4 	bl	8005314 <HAL_HASHEx_SHA256_Accmlt>
        ASSERT(rv == HAL_OK);
 80053cc:	2800      	cmp	r0, #0
 80053ce:	d1f0      	bne.n	80053b2 <sha256_update+0x42>
            uint32_t    tmp;
            memcpy(&tmp, data, 4);
            HASH->DIN = tmp;
        }
#endif
        len -= blocks*4;
 80053d0:	1be4      	subs	r4, r4, r7
        data += blocks*4;
    }

    // save runt for later
    ASSERT(len <= 3);
 80053d2:	2c03      	cmp	r4, #3
            memcpy(&tmp, data, 4);
            HASH->DIN = tmp;
        }
#endif
        len -= blocks*4;
        data += blocks*4;
 80053d4:	443e      	add	r6, r7
    }

    // save runt for later
    ASSERT(len <= 3);
 80053d6:	d8ec      	bhi.n	80053b2 <sha256_update+0x42>
 80053d8:	4434      	add	r4, r6
    while(len) {
 80053da:	42a6      	cmp	r6, r4
 80053dc:	d00a      	beq.n	80053f4 <sha256_update+0x84>
        ctx->pending[ctx->num_pending++] = *data;
 80053de:	f895 3048 	ldrb.w	r3, [r5, #72]	; 0x48
 80053e2:	1c5a      	adds	r2, r3, #1
 80053e4:	f885 2048 	strb.w	r2, [r5, #72]	; 0x48
 80053e8:	442b      	add	r3, r5
 80053ea:	f816 2b01 	ldrb.w	r2, [r6], #1
 80053ee:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 80053f2:	e7f2      	b.n	80053da <sha256_update+0x6a>
        data++;
        len--;
    }
}
 80053f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80053f6:	bf00      	nop
 80053f8:	0800d550 	.word	0x0800d550

080053fc <sha256_final>:

void sha256_final(SHA256_CTX *ctx, uint8_t digest[32])
{
 80053fc:	b513      	push	{r0, r1, r4, lr}
    // Do final 0-3 bytes, pad and return digest.
#if 1
    HAL_StatusTypeDef rv = HAL_HASHEx_SHA256_Start(&ctx->hh,
 80053fe:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8005402:	f890 2048 	ldrb.w	r2, [r0, #72]	; 0x48
 8005406:	9300      	str	r3, [sp, #0]
 8005408:	460b      	mov	r3, r1
 800540a:	f100 0144 	add.w	r1, r0, #68	; 0x44
 800540e:	f7ff ff87 	bl	8005320 <HAL_HASHEx_SHA256_Start>
                                ctx->pending, ctx->num_pending, digest, HAL_MAX_DELAY);
    ASSERT(rv == HAL_OK);
 8005412:	b110      	cbz	r0, 800541a <sha256_final+0x1e>
 8005414:	4802      	ldr	r0, [pc, #8]	; (8005420 <sha256_final+0x24>)
 8005416:	f7fb fae1 	bl	80009dc <fatal_error>
    tmp = __REV(HASH_DIGEST->HR[6]);
    memcpy(out, &tmp, 4); out += 4;
    tmp = __REV(HASH_DIGEST->HR[7]);
    memcpy(out, &tmp, 4);
#endif
}
 800541a:	b002      	add	sp, #8
 800541c:	bd10      	pop	{r4, pc}
 800541e:	bf00      	nop
 8005420:	0800d550 	.word	0x0800d550

08005424 <sha256_single>:
//
// single-shot version (best)
//
    void
sha256_single(const uint8_t data[], uint32_t len, uint8_t digest[32])
{
 8005424:	b570      	push	{r4, r5, r6, lr}
 8005426:	b094      	sub	sp, #80	; 0x50
 8005428:	4604      	mov	r4, r0
 800542a:	460d      	mov	r5, r1
 800542c:	4616      	mov	r6, r2
    HASH_HandleTypeDef  hh = {0};
 800542e:	2100      	movs	r1, #0
 8005430:	2244      	movs	r2, #68	; 0x44
 8005432:	a803      	add	r0, sp, #12
 8005434:	f008 f847 	bl	800d4c6 <memset>

    hh.Init.DataType = HASH_DATATYPE_8B;
 8005438:	2320      	movs	r3, #32

    HAL_HASH_Init(&hh);
 800543a:	a803      	add	r0, sp, #12
    void
sha256_single(const uint8_t data[], uint32_t len, uint8_t digest[32])
{
    HASH_HandleTypeDef  hh = {0};

    hh.Init.DataType = HASH_DATATYPE_8B;
 800543c:	9303      	str	r3, [sp, #12]

    HAL_HASH_Init(&hh);
 800543e:	f004 ff33 	bl	800a2a8 <HAL_HASH_Init>

    // It's called "Start" but it handles the runt packet, so really can only
    // be used once at end of message, or for whole message.
    HAL_StatusTypeDef rv = HAL_HASHEx_SHA256_Start(&hh, (uint8_t *)data, len,
 8005442:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8005446:	9300      	str	r3, [sp, #0]
 8005448:	462a      	mov	r2, r5
 800544a:	4633      	mov	r3, r6
 800544c:	4621      	mov	r1, r4
 800544e:	a803      	add	r0, sp, #12
 8005450:	f7ff ff66 	bl	8005320 <HAL_HASHEx_SHA256_Start>
                                                    digest, HAL_MAX_DELAY);
    ASSERT(rv == HAL_OK);
 8005454:	b110      	cbz	r0, 800545c <sha256_single+0x38>
 8005456:	4802      	ldr	r0, [pc, #8]	; (8005460 <sha256_single+0x3c>)
 8005458:	f7fb fac0 	bl	80009dc <fatal_error>
}
 800545c:	b014      	add	sp, #80	; 0x50
 800545e:	bd70      	pop	{r4, r5, r6, pc}
 8005460:	0800d550 	.word	0x0800d550

08005464 <hmac_sha256_init>:
// hmac_sha256_init()
//
    void
hmac_sha256_init(HMAC_CTX *ctx)
{
    memset(ctx, 0, sizeof(HMAC_CTX));
 8005464:	f44f 7282 	mov.w	r2, #260	; 0x104
 8005468:	2100      	movs	r1, #0
 800546a:	f008 b82c 	b.w	800d4c6 <memset>
	...

08005470 <hmac_sha256_update>:

// hmac_sha256_update()
//
    void
hmac_sha256_update(HMAC_CTX *ctx, const uint8_t data[], uint32_t len)
{
 8005470:	b538      	push	{r3, r4, r5, lr}
 8005472:	4604      	mov	r4, r0
    // simple append
    ASSERT(ctx->num_pending + len < sizeof(ctx->pending));
 8005474:	f8d0 0100 	ldr.w	r0, [r0, #256]	; 0x100
 8005478:	1883      	adds	r3, r0, r2
 800547a:	2bff      	cmp	r3, #255	; 0xff

// hmac_sha256_update()
//
    void
hmac_sha256_update(HMAC_CTX *ctx, const uint8_t data[], uint32_t len)
{
 800547c:	4615      	mov	r5, r2
    // simple append
    ASSERT(ctx->num_pending + len < sizeof(ctx->pending));
 800547e:	d902      	bls.n	8005486 <hmac_sha256_update+0x16>
 8005480:	4805      	ldr	r0, [pc, #20]	; (8005498 <hmac_sha256_update+0x28>)
 8005482:	f7fb faab 	bl	80009dc <fatal_error>

    memcpy(ctx->pending+ctx->num_pending, data, len);
 8005486:	4420      	add	r0, r4
 8005488:	f007 fff7 	bl	800d47a <memcpy>

    ctx->num_pending += len;
 800548c:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
 8005490:	441d      	add	r5, r3
 8005492:	f8c4 5100 	str.w	r5, [r4, #256]	; 0x100
 8005496:	bd38      	pop	{r3, r4, r5, pc}
 8005498:	0800d550 	.word	0x0800d550

0800549c <hmac_sha256_final>:

// hmac_sha256_final()
//
    void
hmac_sha256_final(HMAC_CTX *ctx, const uint8_t key[32], uint8_t digest[32])
{
 800549c:	b570      	push	{r4, r5, r6, lr}
 800549e:	b094      	sub	sp, #80	; 0x50
 80054a0:	4604      	mov	r4, r0
 80054a2:	460e      	mov	r6, r1
 80054a4:	4615      	mov	r5, r2
    HASH_HandleTypeDef  hh = {0};
 80054a6:	2100      	movs	r1, #0
 80054a8:	2244      	movs	r2, #68	; 0x44
 80054aa:	a803      	add	r0, sp, #12
 80054ac:	f008 f80b 	bl	800d4c6 <memset>

    hh.Init.DataType = HASH_DATATYPE_8B;
 80054b0:	2220      	movs	r2, #32
    hh.Init.pKey = (uint8_t *)key;      // const viol due to API dumbness
    hh.Init.KeySize = 32;

    HAL_HASH_Init(&hh);
 80054b2:	a803      	add	r0, sp, #12
    void
hmac_sha256_final(HMAC_CTX *ctx, const uint8_t key[32], uint8_t digest[32])
{
    HASH_HandleTypeDef  hh = {0};

    hh.Init.DataType = HASH_DATATYPE_8B;
 80054b4:	9203      	str	r2, [sp, #12]
    hh.Init.pKey = (uint8_t *)key;      // const viol due to API dumbness
    hh.Init.KeySize = 32;
 80054b6:	9204      	str	r2, [sp, #16]
hmac_sha256_final(HMAC_CTX *ctx, const uint8_t key[32], uint8_t digest[32])
{
    HASH_HandleTypeDef  hh = {0};

    hh.Init.DataType = HASH_DATATYPE_8B;
    hh.Init.pKey = (uint8_t *)key;      // const viol due to API dumbness
 80054b8:	9605      	str	r6, [sp, #20]
    hh.Init.KeySize = 32;

    HAL_HASH_Init(&hh);
 80054ba:	f004 fef5 	bl	800a2a8 <HAL_HASH_Init>

    HAL_StatusTypeDef rv = HAL_HMACEx_SHA256_Start(&hh,
 80054be:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80054c2:	9300      	str	r3, [sp, #0]
 80054c4:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
 80054c8:	462b      	mov	r3, r5
 80054ca:	4621      	mov	r1, r4
 80054cc:	a803      	add	r0, sp, #12
 80054ce:	f7ff ff33 	bl	8005338 <HAL_HMACEx_SHA256_Start>
                                ctx->pending, ctx->num_pending, digest, HAL_MAX_DELAY);
    ASSERT(rv == HAL_OK);
 80054d2:	b110      	cbz	r0, 80054da <hmac_sha256_final+0x3e>
 80054d4:	4802      	ldr	r0, [pc, #8]	; (80054e0 <hmac_sha256_final+0x44>)
 80054d6:	f7fb fa81 	bl	80009dc <fatal_error>
}
 80054da:	b014      	add	sp, #80	; 0x50
 80054dc:	bd70      	pop	{r4, r5, r6, pc}
 80054de:	bf00      	nop
 80054e0:	0800d550 	.word	0x0800d550

080054e4 <uECC_vli_mult>:

#if !asm_mult
uECC_VLI_API void uECC_vli_mult(uECC_word_t *result,
                                const uECC_word_t *left,
                                const uECC_word_t *right,
                                wordcount_t num_words) {
 80054e4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    );
    
#else /* Thumb-1 */
    uint32_t r4, r5, r6, r7;

    __asm__ volatile (
 80054e8:	3b01      	subs	r3, #1
 80054ea:	009b      	lsls	r3, r3, #2
 80054ec:	4698      	mov	r8, r3
 80054ee:	005b      	lsls	r3, r3, #1
 80054f0:	4699      	mov	r9, r3
 80054f2:	2300      	movs	r3, #0
 80054f4:	2400      	movs	r4, #0
 80054f6:	2500      	movs	r5, #0
 80054f8:	2600      	movs	r6, #0
 80054fa:	b401      	push	{r0}
 80054fc:	2700      	movs	r7, #0
 80054fe:	e002      	b.n	8005506 <uECC_vli_mult+0x22>
 8005500:	0037      	movs	r7, r6
 8005502:	4640      	mov	r0, r8
 8005504:	1a3f      	subs	r7, r7, r0
 8005506:	b478      	push	{r3, r4, r5, r6}
 8005508:	1bf0      	subs	r0, r6, r7
 800550a:	5814      	ldr	r4, [r2, r0]
 800550c:	59c8      	ldr	r0, [r1, r7]
 800550e:	0c03      	lsrs	r3, r0, #16
 8005510:	b280      	uxth	r0, r0
 8005512:	0c25      	lsrs	r5, r4, #16
 8005514:	b2a4      	uxth	r4, r4
 8005516:	001e      	movs	r6, r3
 8005518:	436e      	muls	r6, r5
 800551a:	4363      	muls	r3, r4
 800551c:	4345      	muls	r5, r0
 800551e:	4360      	muls	r0, r4
 8005520:	2400      	movs	r4, #0
 8005522:	195b      	adds	r3, r3, r5
 8005524:	4164      	adcs	r4, r4
 8005526:	0424      	lsls	r4, r4, #16
 8005528:	1936      	adds	r6, r6, r4
 800552a:	041c      	lsls	r4, r3, #16
 800552c:	0c1b      	lsrs	r3, r3, #16
 800552e:	1900      	adds	r0, r0, r4
 8005530:	415e      	adcs	r6, r3
 8005532:	bc38      	pop	{r3, r4, r5}
 8005534:	181b      	adds	r3, r3, r0
 8005536:	4174      	adcs	r4, r6
 8005538:	2000      	movs	r0, #0
 800553a:	4145      	adcs	r5, r0
 800553c:	bc40      	pop	{r6}
 800553e:	3704      	adds	r7, #4
 8005540:	4547      	cmp	r7, r8
 8005542:	dc01      	bgt.n	8005548 <uECC_vli_mult+0x64>
 8005544:	42b7      	cmp	r7, r6
 8005546:	ddde      	ble.n	8005506 <uECC_vli_mult+0x22>
 8005548:	9800      	ldr	r0, [sp, #0]
 800554a:	5183      	str	r3, [r0, r6]
 800554c:	4623      	mov	r3, r4
 800554e:	462c      	mov	r4, r5
 8005550:	2500      	movs	r5, #0
 8005552:	3604      	adds	r6, #4
 8005554:	4546      	cmp	r6, r8
 8005556:	ddd1      	ble.n	80054fc <uECC_vli_mult+0x18>
 8005558:	454e      	cmp	r6, r9
 800555a:	ddd1      	ble.n	8005500 <uECC_vli_mult+0x1c>
 800555c:	5183      	str	r3, [r0, r6]
 800555e:	bc01      	pop	{r0}
 8005560:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08005564 <uECC_vli_clear>:
}

#if !asm_clear
uECC_VLI_API void uECC_vli_clear(uECC_word_t *vli, wordcount_t num_words) {
    wordcount_t i;
    for (i = 0; i < num_words; ++i) {
 8005564:	2200      	movs	r2, #0
void uECC_set_rng(uECC_RNG_Function rng_function) {
    g_rng_function = rng_function;
}

#if !asm_clear
uECC_VLI_API void uECC_vli_clear(uECC_word_t *vli, wordcount_t num_words) {
 8005566:	b510      	push	{r4, lr}
    wordcount_t i;
    for (i = 0; i < num_words; ++i) {
        vli[i] = 0;
 8005568:	4614      	mov	r4, r2
}

#if !asm_clear
uECC_VLI_API void uECC_vli_clear(uECC_word_t *vli, wordcount_t num_words) {
    wordcount_t i;
    for (i = 0; i < num_words; ++i) {
 800556a:	b253      	sxtb	r3, r2
 800556c:	428b      	cmp	r3, r1
 800556e:	da04      	bge.n	800557a <uECC_vli_clear+0x16>
        vli[i] = 0;
 8005570:	b21b      	sxth	r3, r3
 8005572:	3201      	adds	r2, #1
 8005574:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
 8005578:	e7f7      	b.n	800556a <uECC_vli_clear+0x6>
    }
}
 800557a:	bd10      	pop	{r4, pc}

0800557c <uECC_vli_isZero>:
#endif /* !asm_clear */

/* Constant-time comparison to zero - secure way to compare long integers */
/* Returns 1 if vli == 0, 0 otherwise. */
uECC_VLI_API uECC_word_t uECC_vli_isZero(const uECC_word_t *vli, wordcount_t num_words) {
 800557c:	b510      	push	{r4, lr}
    uECC_word_t bits = 0;
    wordcount_t i;
    for (i = 0; i < num_words; ++i) {
 800557e:	2300      	movs	r3, #0
#endif /* !asm_clear */

/* Constant-time comparison to zero - secure way to compare long integers */
/* Returns 1 if vli == 0, 0 otherwise. */
uECC_VLI_API uECC_word_t uECC_vli_isZero(const uECC_word_t *vli, wordcount_t num_words) {
    uECC_word_t bits = 0;
 8005580:	461a      	mov	r2, r3
    wordcount_t i;
    for (i = 0; i < num_words; ++i) {
 8005582:	b25c      	sxtb	r4, r3
 8005584:	428c      	cmp	r4, r1
 8005586:	da04      	bge.n	8005592 <uECC_vli_isZero+0x16>
        bits |= vli[i];
 8005588:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
 800558c:	3301      	adds	r3, #1
 800558e:	4322      	orrs	r2, r4
 8005590:	e7f7      	b.n	8005582 <uECC_vli_isZero+0x6>
    }
    return (bits == 0);
}
 8005592:	fab2 f082 	clz	r0, r2
 8005596:	0940      	lsrs	r0, r0, #5
 8005598:	bd10      	pop	{r4, pc}

0800559a <uECC_vli_testBit>:

/* Returns nonzero if bit 'bit' of vli is set. */
uECC_VLI_API uECC_word_t uECC_vli_testBit(const uECC_word_t *vli, bitcount_t bit) {
    return (vli[bit >> uECC_WORD_BITS_SHIFT] & ((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
 800559a:	114a      	asrs	r2, r1, #5
 800559c:	2301      	movs	r3, #1
 800559e:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
 80055a2:	f001 011f 	and.w	r1, r1, #31
 80055a6:	fa03 f101 	lsl.w	r1, r3, r1
}
 80055aa:	4008      	ands	r0, r1
 80055ac:	4770      	bx	lr

080055ae <uECC_vli_numBits>:

    return (i + 1);
}

/* Counts the number of bits required to represent vli. */
uECC_VLI_API bitcount_t uECC_vli_numBits(const uECC_word_t *vli, const wordcount_t max_words) {
 80055ae:	3901      	subs	r1, #1
 80055b0:	b2c9      	uxtb	r1, r1
/* Counts the number of words in vli. */
static wordcount_t vli_numDigits(const uECC_word_t *vli, const wordcount_t max_words) {
    wordcount_t i;
    /* Search from the end until we find a non-zero digit.
       We do it in reverse because we expect that most digits will be nonzero. */
    for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
 80055b2:	b24b      	sxtb	r3, r1
 80055b4:	2b00      	cmp	r3, #0
 80055b6:	da0b      	bge.n	80055d0 <uECC_vli_numBits+0x22>
    }

    return (i + 1);
 80055b8:	3101      	adds	r1, #1
uECC_VLI_API bitcount_t uECC_vli_numBits(const uECC_word_t *vli, const wordcount_t max_words) {
    uECC_word_t i;
    uECC_word_t digit;

    wordcount_t num_digits = vli_numDigits(vli, max_words);
    if (num_digits == 0) {
 80055ba:	f011 03ff 	ands.w	r3, r1, #255	; 0xff
 80055be:	d015      	beq.n	80055ec <uECC_vli_numBits+0x3e>
        return 0;
    }

    digit = vli[num_digits - 1];
 80055c0:	b259      	sxtb	r1, r3
 80055c2:	f101 4380 	add.w	r3, r1, #1073741824	; 0x40000000
 80055c6:	3b01      	subs	r3, #1
 80055c8:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
    for (i = 0; digit; ++i) {
 80055cc:	2300      	movs	r3, #0
 80055ce:	e004      	b.n	80055da <uECC_vli_numBits+0x2c>
/* Counts the number of words in vli. */
static wordcount_t vli_numDigits(const uECC_word_t *vli, const wordcount_t max_words) {
    wordcount_t i;
    /* Search from the end until we find a non-zero digit.
       We do it in reverse because we expect that most digits will be nonzero. */
    for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
 80055d0:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80055d4:	2b00      	cmp	r3, #0
 80055d6:	d0ea      	beq.n	80055ae <uECC_vli_numBits>
 80055d8:	e7ee      	b.n	80055b8 <uECC_vli_numBits+0xa>
    if (num_digits == 0) {
        return 0;
    }

    digit = vli[num_digits - 1];
    for (i = 0; digit; ++i) {
 80055da:	b112      	cbz	r2, 80055e2 <uECC_vli_numBits+0x34>
        digit >>= 1;
 80055dc:	0852      	lsrs	r2, r2, #1
    if (num_digits == 0) {
        return 0;
    }

    digit = vli[num_digits - 1];
    for (i = 0; digit; ++i) {
 80055de:	3301      	adds	r3, #1
 80055e0:	e7fb      	b.n	80055da <uECC_vli_numBits+0x2c>
        digit >>= 1;
    }

    return (((bitcount_t)(num_digits - 1) << uECC_WORD_BITS_SHIFT) + i);
 80055e2:	1e48      	subs	r0, r1, #1
 80055e4:	eb03 1040 	add.w	r0, r3, r0, lsl #5
 80055e8:	b280      	uxth	r0, r0
 80055ea:	e000      	b.n	80055ee <uECC_vli_numBits+0x40>
    uECC_word_t i;
    uECC_word_t digit;

    wordcount_t num_digits = vli_numDigits(vli, max_words);
    if (num_digits == 0) {
        return 0;
 80055ec:	4618      	mov	r0, r3
    for (i = 0; digit; ++i) {
        digit >>= 1;
    }

    return (((bitcount_t)(num_digits - 1) << uECC_WORD_BITS_SHIFT) + i);
}
 80055ee:	b200      	sxth	r0, r0
 80055f0:	4770      	bx	lr

080055f2 <uECC_vli_set>:

/* Sets dest = src. */
#if !asm_set
uECC_VLI_API void uECC_vli_set(uECC_word_t *dest, const uECC_word_t *src, wordcount_t num_words) {
 80055f2:	b530      	push	{r4, r5, lr}
    wordcount_t i;
    for (i = 0; i < num_words; ++i) {
 80055f4:	2400      	movs	r4, #0
 80055f6:	b263      	sxtb	r3, r4
 80055f8:	4293      	cmp	r3, r2
 80055fa:	da06      	bge.n	800560a <uECC_vli_set+0x18>
        dest[i] = src[i];
 80055fc:	b21b      	sxth	r3, r3
 80055fe:	3401      	adds	r4, #1
 8005600:	f851 5023 	ldr.w	r5, [r1, r3, lsl #2]
 8005604:	f840 5023 	str.w	r5, [r0, r3, lsl #2]
 8005608:	e7f5      	b.n	80055f6 <uECC_vli_set+0x4>
    }
}
 800560a:	bd30      	pop	{r4, r5, pc}

0800560c <uECC_vli_cmp_unsafe>:
#endif /* !asm_set */

/* Returns sign of left - right. */
static cmpresult_t uECC_vli_cmp_unsafe(const uECC_word_t *left,
                                       const uECC_word_t *right,
                                       wordcount_t num_words) {
 800560c:	b510      	push	{r4, lr}
 800560e:	3a01      	subs	r2, #1
 8005610:	b2d2      	uxtb	r2, r2
    wordcount_t i;
    for (i = num_words - 1; i >= 0; --i) {
 8005612:	b253      	sxtb	r3, r2
 8005614:	2b00      	cmp	r3, #0
 8005616:	db09      	blt.n	800562c <uECC_vli_cmp_unsafe+0x20>
        if (left[i] > right[i]) {
 8005618:	b21b      	sxth	r3, r3
 800561a:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
 800561e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8005622:	429c      	cmp	r4, r3
 8005624:	d804      	bhi.n	8005630 <uECC_vli_cmp_unsafe+0x24>
            return 1;
        } else if (left[i] < right[i]) {
 8005626:	d2f2      	bcs.n	800560e <uECC_vli_cmp_unsafe+0x2>
            return -1;
 8005628:	20ff      	movs	r0, #255	; 0xff
 800562a:	e002      	b.n	8005632 <uECC_vli_cmp_unsafe+0x26>
        }
    }
    return 0;
 800562c:	2000      	movs	r0, #0
 800562e:	e000      	b.n	8005632 <uECC_vli_cmp_unsafe+0x26>
                                       const uECC_word_t *right,
                                       wordcount_t num_words) {
    wordcount_t i;
    for (i = num_words - 1; i >= 0; --i) {
        if (left[i] > right[i]) {
            return 1;
 8005630:	2001      	movs	r0, #1
        } else if (left[i] < right[i]) {
            return -1;
        }
    }
    return 0;
}
 8005632:	b240      	sxtb	r0, r0
 8005634:	bd10      	pop	{r4, pc}

08005636 <uECC_vli_rshift1>:
}
#endif

/* Computes vli = vli >> 1. */
#if !asm_rshift1
uECC_VLI_API void uECC_vli_rshift1(uECC_word_t *vli, wordcount_t num_words) {
 8005636:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    uECC_word_t *end = vli;
    uECC_word_t carry = 0;
 800563a:	2300      	movs	r3, #0
    
    vli += num_words;
    while (vli-- > end) {
 800563c:	4288      	cmp	r0, r1
 800563e:	d206      	bcs.n	800564e <uECC_vli_rshift1+0x18>
        uECC_word_t temp = *vli;
 8005640:	f851 2d04 	ldr.w	r2, [r1, #-4]!
        *vli = (temp >> 1) | carry;
 8005644:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
 8005648:	600b      	str	r3, [r1, #0]
        carry = temp << (uECC_WORD_BITS - 1);
 800564a:	07d3      	lsls	r3, r2, #31
 800564c:	e7f6      	b.n	800563c <uECC_vli_rshift1+0x6>
    }
}
 800564e:	4770      	bx	lr

08005650 <uECC_vli_modMult>:
/* Computes result = (left * right) % mod. */
uECC_VLI_API void uECC_vli_modMult(uECC_word_t *result,
                                   const uECC_word_t *left,
                                   const uECC_word_t *right,
                                   const uECC_word_t *mod,
                                   wordcount_t num_words) {
 8005650:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005654:	b0b5      	sub	sp, #212	; 0xd4
    uECC_word_t product[2 * uECC_MAX_WORDS];
    uECC_vli_mult(product, left, right, num_words);
 8005656:	ad04      	add	r5, sp, #16
/* Computes result = (left * right) % mod. */
uECC_VLI_API void uECC_vli_modMult(uECC_word_t *result,
                                   const uECC_word_t *left,
                                   const uECC_word_t *right,
                                   const uECC_word_t *mod,
                                   wordcount_t num_words) {
 8005658:	f99d 40f8 	ldrsb.w	r4, [sp, #248]	; 0xf8
 800565c:	4699      	mov	r9, r3
 800565e:	4680      	mov	r8, r0
    uECC_word_t product[2 * uECC_MAX_WORDS];
    uECC_vli_mult(product, left, right, num_words);
 8005660:	4623      	mov	r3, r4
 8005662:	4628      	mov	r0, r5
 8005664:	f7ff ff3e 	bl	80054e4 <uECC_vli_mult>
                                uECC_word_t *product,
                                const uECC_word_t *mod,
                                wordcount_t num_words) {
    uECC_word_t mod_multiple[2 * uECC_MAX_WORDS];
    uECC_word_t tmp[2 * uECC_MAX_WORDS];
    uECC_word_t *v[2] = {tmp, product};
 8005668:	ab24      	add	r3, sp, #144	; 0x90
    uECC_word_t index;
    
    /* Shift mod so its highest set bit is at the maximum position. */
    bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) - uECC_vli_numBits(mod, num_words);
 800566a:	4621      	mov	r1, r4
 800566c:	4648      	mov	r0, r9
                                uECC_word_t *product,
                                const uECC_word_t *mod,
                                wordcount_t num_words) {
    uECC_word_t mod_multiple[2 * uECC_MAX_WORDS];
    uECC_word_t tmp[2 * uECC_MAX_WORDS];
    uECC_word_t *v[2] = {tmp, product};
 800566e:	9302      	str	r3, [sp, #8]
 8005670:	9503      	str	r5, [sp, #12]
    uECC_word_t index;
    
    /* Shift mod so its highest set bit is at the maximum position. */
    bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) - uECC_vli_numBits(mod, num_words);
 8005672:	f7ff ff9c 	bl	80055ae <uECC_vli_numBits>
 8005676:	ebc0 1084 	rsb	r0, r0, r4, lsl #6
 800567a:	b285      	uxth	r5, r0
    wordcount_t word_shift = shift / uECC_WORD_BITS;
    wordcount_t bit_shift = shift % uECC_WORD_BITS;
 800567c:	4b49      	ldr	r3, [pc, #292]	; (80057a4 <uECC_vli_modMult+0x154>)
    uECC_word_t *v[2] = {tmp, product};
    uECC_word_t index;
    
    /* Shift mod so its highest set bit is at the maximum position. */
    bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) - uECC_vli_numBits(mod, num_words);
    wordcount_t word_shift = shift / uECC_WORD_BITS;
 800567e:	b22a      	sxth	r2, r5
    wordcount_t bit_shift = shift % uECC_WORD_BITS;
 8005680:	4013      	ands	r3, r2
 8005682:	2b00      	cmp	r3, #0
 8005684:	bfbc      	itt	lt
 8005686:	f103 33ff 	addlt.w	r3, r3, #4294967295	; 0xffffffff
 800568a:	f063 031f 	ornlt	r3, r3, #31
    uECC_word_t *v[2] = {tmp, product};
    uECC_word_t index;
    
    /* Shift mod so its highest set bit is at the maximum position. */
    bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) - uECC_vli_numBits(mod, num_words);
    wordcount_t word_shift = shift / uECC_WORD_BITS;
 800568e:	f04f 0720 	mov.w	r7, #32
 8005692:	fb92 f7f7 	sdiv	r7, r2, r7
 8005696:	b2ff      	uxtb	r7, r7
    wordcount_t bit_shift = shift % uECC_WORD_BITS;
 8005698:	bfb8      	it	lt
 800569a:	3301      	addlt	r3, #1
    uECC_word_t carry = 0;
    uECC_vli_clear(mod_multiple, word_shift);
 800569c:	b27f      	sxtb	r7, r7
    uECC_word_t index;
    
    /* Shift mod so its highest set bit is at the maximum position. */
    bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) - uECC_vli_numBits(mod, num_words);
    wordcount_t word_shift = shift / uECC_WORD_BITS;
    wordcount_t bit_shift = shift % uECC_WORD_BITS;
 800569e:	b29e      	uxth	r6, r3
    uECC_word_t carry = 0;
    uECC_vli_clear(mod_multiple, word_shift);
 80056a0:	a814      	add	r0, sp, #80	; 0x50
 80056a2:	4639      	mov	r1, r7
 80056a4:	f7ff ff5e 	bl	8005564 <uECC_vli_clear>
    if (bit_shift > 0) {
 80056a8:	b233      	sxth	r3, r6
 80056aa:	2b00      	cmp	r3, #0
 80056ac:	b238      	sxth	r0, r7
 80056ae:	dd14      	ble.n	80056da <uECC_vli_modMult+0x8a>
 80056b0:	aa14      	add	r2, sp, #80	; 0x50
 80056b2:	2100      	movs	r1, #0
 80056b4:	eb02 0080 	add.w	r0, r2, r0, lsl #2
        for(index = 0; index < (uECC_word_t)num_words; ++index) {
            mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;
            carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
 80056b8:	f1c3 0720 	rsb	r7, r3, #32
    bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) - uECC_vli_numBits(mod, num_words);
    wordcount_t word_shift = shift / uECC_WORD_BITS;
    wordcount_t bit_shift = shift % uECC_WORD_BITS;
    uECC_word_t carry = 0;
    uECC_vli_clear(mod_multiple, word_shift);
    if (bit_shift > 0) {
 80056bc:	460a      	mov	r2, r1
        for(index = 0; index < (uECC_word_t)num_words; ++index) {
 80056be:	42a2      	cmp	r2, r4
 80056c0:	d212      	bcs.n	80056e8 <uECC_vli_modMult+0x98>
            mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;
 80056c2:	f859 6022 	ldr.w	r6, [r9, r2, lsl #2]
 80056c6:	fa06 fe03 	lsl.w	lr, r6, r3
 80056ca:	ea4e 0101 	orr.w	r1, lr, r1
 80056ce:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
            carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
 80056d2:	fa26 f107 	lsr.w	r1, r6, r7
    wordcount_t word_shift = shift / uECC_WORD_BITS;
    wordcount_t bit_shift = shift % uECC_WORD_BITS;
    uECC_word_t carry = 0;
    uECC_vli_clear(mod_multiple, word_shift);
    if (bit_shift > 0) {
        for(index = 0; index < (uECC_word_t)num_words; ++index) {
 80056d6:	3201      	adds	r2, #1
 80056d8:	e7f1      	b.n	80056be <uECC_vli_modMult+0x6e>
            mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;
            carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
        }
    } else {
        uECC_vli_set(mod_multiple + word_shift, mod, num_words);
 80056da:	ab14      	add	r3, sp, #80	; 0x50
 80056dc:	4622      	mov	r2, r4
 80056de:	4649      	mov	r1, r9
 80056e0:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 80056e4:	f7ff ff85 	bl	80055f2 <uECC_vli_set>
 80056e8:	b227      	sxth	r7, r4
 80056ea:	007b      	lsls	r3, r7, #1
 80056ec:	9301      	str	r3, [sp, #4]
            v[1 - index][i] = diff;
        }
        index = !(index ^ borrow); /* Swap the index if there was no borrow */
        uECC_vli_rshift1(mod_multiple, num_words);
        mod_multiple[num_words - 1] |= mod_multiple[num_words] << (uECC_WORD_BITS - 1);
        uECC_vli_rshift1(mod_multiple + num_words, num_words);
 80056ee:	ab14      	add	r3, sp, #80	; 0x50
 80056f0:	eb03 0787 	add.w	r7, r3, r7, lsl #2
            }
            v[1 - index][i] = diff;
        }
        index = !(index ^ borrow); /* Swap the index if there was no borrow */
        uECC_vli_rshift1(mod_multiple, num_words);
        mod_multiple[num_words - 1] |= mod_multiple[num_words] << (uECC_WORD_BITS - 1);
 80056f4:	f104 39ff 	add.w	r9, r4, #4294967295	; 0xffffffff
 80056f8:	ab34      	add	r3, sp, #208	; 0xd0
        uECC_vli_rshift1(mod_multiple + num_words, num_words);
 80056fa:	2601      	movs	r6, #1
            }
            v[1 - index][i] = diff;
        }
        index = !(index ^ borrow); /* Swap the index if there was no borrow */
        uECC_vli_rshift1(mod_multiple, num_words);
        mod_multiple[num_words - 1] |= mod_multiple[num_words] << (uECC_WORD_BITS - 1);
 80056fc:	eb03 0989 	add.w	r9, r3, r9, lsl #2
        }
    } else {
        uECC_vli_set(mod_multiple + word_shift, mod, num_words);
    }

    for (index = 1; shift >= 0; --shift) {
 8005700:	042b      	lsls	r3, r5, #16
 8005702:	d442      	bmi.n	800578a <uECC_vli_modMult+0x13a>
        uECC_word_t borrow = 0;
        wordcount_t i;
        for (i = 0; i < num_words * 2; ++i) {
            uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
 8005704:	ab34      	add	r3, sp, #208	; 0xd0
        }
    } else {
        uECC_vli_set(mod_multiple + word_shift, mod, num_words);
    }

    for (index = 1; shift >= 0; --shift) {
 8005706:	2200      	movs	r2, #0
        for (i = 0; i < num_words * 2; ++i) {
            uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
            if (diff != v[index][i]) {
                borrow = (diff > v[index][i]);
            }
            v[1 - index][i] = diff;
 8005708:	f1c6 0001 	rsb	r0, r6, #1
        }
    } else {
        uECC_vli_set(mod_multiple + word_shift, mod, num_words);
    }

    for (index = 1; shift >= 0; --shift) {
 800570c:	4696      	mov	lr, r2
        uECC_word_t borrow = 0;
        wordcount_t i;
        for (i = 0; i < num_words * 2; ++i) {
            uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
 800570e:	eb03 0a86 	add.w	sl, r3, r6, lsl #2
            if (diff != v[index][i]) {
                borrow = (diff > v[index][i]);
            }
            v[1 - index][i] = diff;
 8005712:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    }

    for (index = 1; shift >= 0; --shift) {
        uECC_word_t borrow = 0;
        wordcount_t i;
        for (i = 0; i < num_words * 2; ++i) {
 8005716:	9b01      	ldr	r3, [sp, #4]
 8005718:	b251      	sxtb	r1, r2
 800571a:	4299      	cmp	r1, r3
 800571c:	da1b      	bge.n	8005756 <uECC_vli_modMult+0x106>
            uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
 800571e:	fa0f fc81 	sxth.w	ip, r1
 8005722:	f85a 3cc8 	ldr.w	r3, [sl, #-200]
 8005726:	f853 b02c 	ldr.w	fp, [r3, ip, lsl #2]
 800572a:	ab34      	add	r3, sp, #208	; 0xd0
 800572c:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8005730:	f851 3c80 	ldr.w	r3, [r1, #-128]
 8005734:	ebc3 030b 	rsb	r3, r3, fp
 8005738:	ebce 0303 	rsb	r3, lr, r3
            if (diff != v[index][i]) {
 800573c:	459b      	cmp	fp, r3
 800573e:	d004      	beq.n	800574a <uECC_vli_modMult+0xfa>
                borrow = (diff > v[index][i]);
 8005740:	bf34      	ite	cc
 8005742:	f04f 0e01 	movcc.w	lr, #1
 8005746:	f04f 0e00 	movcs.w	lr, #0
            }
            v[1 - index][i] = diff;
 800574a:	f850 1cc8 	ldr.w	r1, [r0, #-200]
 800574e:	3201      	adds	r2, #1
 8005750:	f841 302c 	str.w	r3, [r1, ip, lsl #2]
 8005754:	e7df      	b.n	8005716 <uECC_vli_modMult+0xc6>
        }
        index = !(index ^ borrow); /* Swap the index if there was no borrow */
 8005756:	ebce 0206 	rsb	r2, lr, r6
 800575a:	4256      	negs	r6, r2
        uECC_vli_rshift1(mod_multiple, num_words);
 800575c:	4621      	mov	r1, r4
 800575e:	a814      	add	r0, sp, #80	; 0x50
            if (diff != v[index][i]) {
                borrow = (diff > v[index][i]);
            }
            v[1 - index][i] = diff;
        }
        index = !(index ^ borrow); /* Swap the index if there was no borrow */
 8005760:	4156      	adcs	r6, r2
        uECC_vli_rshift1(mod_multiple, num_words);
 8005762:	f7ff ff68 	bl	8005636 <uECC_vli_rshift1>
        mod_multiple[num_words - 1] |= mod_multiple[num_words] << (uECC_WORD_BITS - 1);
 8005766:	ab34      	add	r3, sp, #208	; 0xd0
 8005768:	eb03 0384 	add.w	r3, r3, r4, lsl #2
        uECC_vli_rshift1(mod_multiple + num_words, num_words);
 800576c:	4621      	mov	r1, r4
            }
            v[1 - index][i] = diff;
        }
        index = !(index ^ borrow); /* Swap the index if there was no borrow */
        uECC_vli_rshift1(mod_multiple, num_words);
        mod_multiple[num_words - 1] |= mod_multiple[num_words] << (uECC_WORD_BITS - 1);
 800576e:	f853 2c80 	ldr.w	r2, [r3, #-128]
 8005772:	f859 3c80 	ldr.w	r3, [r9, #-128]
        uECC_vli_rshift1(mod_multiple + num_words, num_words);
 8005776:	4638      	mov	r0, r7
            }
            v[1 - index][i] = diff;
        }
        index = !(index ^ borrow); /* Swap the index if there was no borrow */
        uECC_vli_rshift1(mod_multiple, num_words);
        mod_multiple[num_words - 1] |= mod_multiple[num_words] << (uECC_WORD_BITS - 1);
 8005778:	ea43 73c2 	orr.w	r3, r3, r2, lsl #31
 800577c:	3d01      	subs	r5, #1
 800577e:	f849 3c80 	str.w	r3, [r9, #-128]
 8005782:	b2ad      	uxth	r5, r5
        uECC_vli_rshift1(mod_multiple + num_words, num_words);
 8005784:	f7ff ff57 	bl	8005636 <uECC_vli_rshift1>
 8005788:	e7ba      	b.n	8005700 <uECC_vli_modMult+0xb0>
    }
    uECC_vli_set(result, v[index], num_words);
 800578a:	ab34      	add	r3, sp, #208	; 0xd0
 800578c:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 8005790:	4622      	mov	r2, r4
 8005792:	f856 1cc8 	ldr.w	r1, [r6, #-200]
 8005796:	4640      	mov	r0, r8
 8005798:	f7ff ff2b 	bl	80055f2 <uECC_vli_set>
                                   const uECC_word_t *mod,
                                   wordcount_t num_words) {
    uECC_word_t product[2 * uECC_MAX_WORDS];
    uECC_vli_mult(product, left, right, num_words);
    uECC_vli_mmod(result, product, mod, num_words);
}
 800579c:	b035      	add	sp, #212	; 0xd4
 800579e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80057a2:	bf00      	nop
 80057a4:	8000001f 	.word	0x8000001f

080057a8 <uECC_vli_modMult_fast>:

uECC_VLI_API void uECC_vli_modMult_fast(uECC_word_t *result,
                                        const uECC_word_t *left,
                                        const uECC_word_t *right,
                                        uECC_Curve curve) {
 80057a8:	b530      	push	{r4, r5, lr}
 80057aa:	461c      	mov	r4, r3
 80057ac:	b091      	sub	sp, #68	; 0x44
 80057ae:	4605      	mov	r5, r0
    uECC_word_t product[2 * uECC_MAX_WORDS];
    uECC_vli_mult(product, left, right, curve->num_words);
 80057b0:	f993 3000 	ldrsb.w	r3, [r3]
 80057b4:	4668      	mov	r0, sp
 80057b6:	f7ff fe95 	bl	80054e4 <uECC_vli_mult>
#if (uECC_OPTIMIZATION_LEVEL > 0)
    curve->mmod_fast(result, product);
 80057ba:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
 80057be:	4669      	mov	r1, sp
 80057c0:	4628      	mov	r0, r5
 80057c2:	4798      	blx	r3
#else
    uECC_vli_mmod(result, product, curve->p, curve->num_words);
#endif
}
 80057c4:	b011      	add	sp, #68	; 0x44
 80057c6:	bd30      	pop	{r4, r5, pc}

080057c8 <uECC_vli_modSquare_fast>:
#endif /* uECC_ENABLE_VLI_API */

uECC_VLI_API void uECC_vli_modSquare_fast(uECC_word_t *result,
                                          const uECC_word_t *left,
                                          uECC_Curve curve) {
    uECC_vli_modMult_fast(result, left, left, curve);
 80057c8:	4613      	mov	r3, r2
 80057ca:	460a      	mov	r2, r1
 80057cc:	f7ff bfec 	b.w	80057a8 <uECC_vli_modMult_fast>

080057d0 <apply_z>:

/* Modify (x1, y1) => (x1 * z^2, y1 * z^3) */
static void apply_z(uECC_word_t * X1,
                    uECC_word_t * Y1,
                    const uECC_word_t * const Z,
                    uECC_Curve curve) {
 80057d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80057d2:	4615      	mov	r5, r2
 80057d4:	b089      	sub	sp, #36	; 0x24
 80057d6:	461c      	mov	r4, r3
 80057d8:	4607      	mov	r7, r0
 80057da:	460e      	mov	r6, r1
    uECC_word_t t1[uECC_MAX_WORDS];

    uECC_vli_modSquare_fast(t1, Z, curve);    /* z^2 */
 80057dc:	461a      	mov	r2, r3
 80057de:	4629      	mov	r1, r5
 80057e0:	4668      	mov	r0, sp
 80057e2:	f7ff fff1 	bl	80057c8 <uECC_vli_modSquare_fast>
    uECC_vli_modMult_fast(X1, X1, t1, curve); /* x1 * z^2 */
 80057e6:	4623      	mov	r3, r4
 80057e8:	466a      	mov	r2, sp
 80057ea:	4639      	mov	r1, r7
 80057ec:	4638      	mov	r0, r7
 80057ee:	f7ff ffdb 	bl	80057a8 <uECC_vli_modMult_fast>
    uECC_vli_modMult_fast(t1, t1, Z, curve);  /* z^3 */
 80057f2:	4623      	mov	r3, r4
 80057f4:	462a      	mov	r2, r5
 80057f6:	4669      	mov	r1, sp
 80057f8:	4668      	mov	r0, sp
 80057fa:	f7ff ffd5 	bl	80057a8 <uECC_vli_modMult_fast>
    uECC_vli_modMult_fast(Y1, Y1, t1, curve); /* y1 * z^3 */
 80057fe:	4623      	mov	r3, r4
 8005800:	466a      	mov	r2, sp
 8005802:	4631      	mov	r1, r6
 8005804:	4630      	mov	r0, r6
 8005806:	f7ff ffcf 	bl	80057a8 <uECC_vli_modMult_fast>
}
 800580a:	b009      	add	sp, #36	; 0x24
 800580c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800580e <uECC_vli_nativeToBytes>:

#else

uECC_VLI_API void uECC_vli_nativeToBytes(uint8_t *bytes,
                                         int num_bytes,
                                         const uECC_word_t *native) {
 800580e:	b5f0      	push	{r4, r5, r6, r7, lr}
    wordcount_t i;
    for (i = 0; i < num_bytes; ++i) {
 8005810:	2500      	movs	r5, #0
        unsigned b = num_bytes - 1 - i;
 8005812:	1e4f      	subs	r7, r1, #1

uECC_VLI_API void uECC_vli_nativeToBytes(uint8_t *bytes,
                                         int num_bytes,
                                         const uECC_word_t *native) {
    wordcount_t i;
    for (i = 0; i < num_bytes; ++i) {
 8005814:	b26c      	sxtb	r4, r5
 8005816:	428c      	cmp	r4, r1
 8005818:	f105 0501 	add.w	r5, r5, #1
 800581c:	da0a      	bge.n	8005834 <uECC_vli_nativeToBytes+0x26>
        unsigned b = num_bytes - 1 - i;
 800581e:	1b3b      	subs	r3, r7, r4
        bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));
 8005820:	089e      	lsrs	r6, r3, #2
 8005822:	f003 0303 	and.w	r3, r3, #3
 8005826:	f852 6026 	ldr.w	r6, [r2, r6, lsl #2]
 800582a:	00db      	lsls	r3, r3, #3
 800582c:	fa26 f303 	lsr.w	r3, r6, r3
 8005830:	5503      	strb	r3, [r0, r4]
 8005832:	e7ef      	b.n	8005814 <uECC_vli_nativeToBytes+0x6>
    }
}
 8005834:	bdf0      	pop	{r4, r5, r6, r7, pc}

08005836 <uECC_vli_bytesToNative>:

uECC_VLI_API void uECC_vli_bytesToNative(uECC_word_t *native,
                                         const uint8_t *bytes,
                                         int num_bytes) {
 8005836:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005838:	4616      	mov	r6, r2
    wordcount_t i;
    uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
 800583a:	1cd3      	adds	r3, r2, #3
    }
}

uECC_VLI_API void uECC_vli_bytesToNative(uECC_word_t *native,
                                         const uint8_t *bytes,
                                         int num_bytes) {
 800583c:	460d      	mov	r5, r1
    wordcount_t i;
    uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
 800583e:	2104      	movs	r1, #4
 8005840:	fb93 f1f1 	sdiv	r1, r3, r1
 8005844:	b249      	sxtb	r1, r1
    }
}

uECC_VLI_API void uECC_vli_bytesToNative(uECC_word_t *native,
                                         const uint8_t *bytes,
                                         int num_bytes) {
 8005846:	4604      	mov	r4, r0
    wordcount_t i;
    uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
    for (i = 0; i < num_bytes; ++i) {
        unsigned b = num_bytes - 1 - i;
 8005848:	1e77      	subs	r7, r6, #1

uECC_VLI_API void uECC_vli_bytesToNative(uECC_word_t *native,
                                         const uint8_t *bytes,
                                         int num_bytes) {
    wordcount_t i;
    uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
 800584a:	f7ff fe8b 	bl	8005564 <uECC_vli_clear>
    for (i = 0; i < num_bytes; ++i) {
 800584e:	2200      	movs	r2, #0
 8005850:	b251      	sxtb	r1, r2
 8005852:	428e      	cmp	r6, r1
 8005854:	f102 0201 	add.w	r2, r2, #1
 8005858:	dd0d      	ble.n	8005876 <uECC_vli_bytesToNative+0x40>
        unsigned b = num_bytes - 1 - i;
 800585a:	1a7b      	subs	r3, r7, r1
        native[b / uECC_WORD_SIZE] |= 
 800585c:	0898      	lsrs	r0, r3, #2
 800585e:	5c69      	ldrb	r1, [r5, r1]
 8005860:	f003 0303 	and.w	r3, r3, #3
 8005864:	00db      	lsls	r3, r3, #3
 8005866:	fa01 f303 	lsl.w	r3, r1, r3
 800586a:	f854 1020 	ldr.w	r1, [r4, r0, lsl #2]
 800586e:	430b      	orrs	r3, r1
 8005870:	f844 3020 	str.w	r3, [r4, r0, lsl #2]
 8005874:	e7ec      	b.n	8005850 <uECC_vli_bytesToNative+0x1a>
            (uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
    }
}
 8005876:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08005878 <HMAC_init>:
    return 0;
}

/* Compute an HMAC using K as a key (as in RFC 6979). Note that K is always
   the same size as the hash result size. */
static void HMAC_init(uECC_HashContext *hash_context, const uint8_t *K) {
 8005878:	b570      	push	{r4, r5, r6, lr}
    uint8_t *pad = hash_context->tmp + 2 * hash_context->result_size;
 800587a:	6943      	ldr	r3, [r0, #20]
 800587c:	6905      	ldr	r5, [r0, #16]
    return 0;
}

/* Compute an HMAC using K as a key (as in RFC 6979). Note that K is always
   the same size as the hash result size. */
static void HMAC_init(uECC_HashContext *hash_context, const uint8_t *K) {
 800587e:	4604      	mov	r4, r0
    uint8_t *pad = hash_context->tmp + 2 * hash_context->result_size;
 8005880:	eb03 0545 	add.w	r5, r3, r5, lsl #1
    unsigned i;
    for (i = 0; i < hash_context->result_size; ++i)
 8005884:	2300      	movs	r3, #0
 8005886:	6922      	ldr	r2, [r4, #16]
 8005888:	4293      	cmp	r3, r2
 800588a:	d205      	bcs.n	8005898 <HMAC_init+0x20>
        pad[i] = K[i] ^ 0x36;
 800588c:	5cca      	ldrb	r2, [r1, r3]
 800588e:	f082 0236 	eor.w	r2, r2, #54	; 0x36
 8005892:	54ea      	strb	r2, [r5, r3]
/* Compute an HMAC using K as a key (as in RFC 6979). Note that K is always
   the same size as the hash result size. */
static void HMAC_init(uECC_HashContext *hash_context, const uint8_t *K) {
    uint8_t *pad = hash_context->tmp + 2 * hash_context->result_size;
    unsigned i;
    for (i = 0; i < hash_context->result_size; ++i)
 8005894:	3301      	adds	r3, #1
 8005896:	e7f6      	b.n	8005886 <HMAC_init+0xe>
 8005898:	442b      	add	r3, r5
        pad[i] = K[i] ^ 0x36;
    for (; i < hash_context->block_size; ++i)
        pad[i] = 0x36;
 800589a:	2036      	movs	r0, #54	; 0x36
static void HMAC_init(uECC_HashContext *hash_context, const uint8_t *K) {
    uint8_t *pad = hash_context->tmp + 2 * hash_context->result_size;
    unsigned i;
    for (i = 0; i < hash_context->result_size; ++i)
        pad[i] = K[i] ^ 0x36;
    for (; i < hash_context->block_size; ++i)
 800589c:	68e1      	ldr	r1, [r4, #12]
 800589e:	1b5a      	subs	r2, r3, r5
 80058a0:	4291      	cmp	r1, r2
 80058a2:	d902      	bls.n	80058aa <HMAC_init+0x32>
        pad[i] = 0x36;
 80058a4:	f803 0b01 	strb.w	r0, [r3], #1
 80058a8:	e7f8      	b.n	800589c <HMAC_init+0x24>

    hash_context->init_hash(hash_context);
 80058aa:	6823      	ldr	r3, [r4, #0]
 80058ac:	4620      	mov	r0, r4
 80058ae:	4798      	blx	r3
    hash_context->update_hash(hash_context, pad, hash_context->block_size);
 80058b0:	6863      	ldr	r3, [r4, #4]
 80058b2:	68e2      	ldr	r2, [r4, #12]
 80058b4:	4629      	mov	r1, r5
 80058b6:	4620      	mov	r0, r4
}
 80058b8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        pad[i] = K[i] ^ 0x36;
    for (; i < hash_context->block_size; ++i)
        pad[i] = 0x36;

    hash_context->init_hash(hash_context);
    hash_context->update_hash(hash_context, pad, hash_context->block_size);
 80058bc:	4718      	bx	r3

080058be <HMAC_update>:
}

static void HMAC_update(uECC_HashContext *hash_context,
                        const uint8_t *message,
                        unsigned message_size) {
    hash_context->update_hash(hash_context, message, message_size);
 80058be:	6843      	ldr	r3, [r0, #4]
 80058c0:	4718      	bx	r3

080058c2 <HMAC_finish>:
}

static void HMAC_finish(uECC_HashContext *hash_context, const uint8_t *K, uint8_t *result) {
 80058c2:	b570      	push	{r4, r5, r6, lr}
    uint8_t *pad = hash_context->tmp + 2 * hash_context->result_size;
 80058c4:	6943      	ldr	r3, [r0, #20]
 80058c6:	6905      	ldr	r5, [r0, #16]
                        const uint8_t *message,
                        unsigned message_size) {
    hash_context->update_hash(hash_context, message, message_size);
}

static void HMAC_finish(uECC_HashContext *hash_context, const uint8_t *K, uint8_t *result) {
 80058c8:	4604      	mov	r4, r0
    uint8_t *pad = hash_context->tmp + 2 * hash_context->result_size;
 80058ca:	eb03 0545 	add.w	r5, r3, r5, lsl #1
                        const uint8_t *message,
                        unsigned message_size) {
    hash_context->update_hash(hash_context, message, message_size);
}

static void HMAC_finish(uECC_HashContext *hash_context, const uint8_t *K, uint8_t *result) {
 80058ce:	4616      	mov	r6, r2
    uint8_t *pad = hash_context->tmp + 2 * hash_context->result_size;
    unsigned i;
    for (i = 0; i < hash_context->result_size; ++i)
 80058d0:	2300      	movs	r3, #0
 80058d2:	6922      	ldr	r2, [r4, #16]
 80058d4:	4293      	cmp	r3, r2
 80058d6:	d205      	bcs.n	80058e4 <HMAC_finish+0x22>
        pad[i] = K[i] ^ 0x5c;
 80058d8:	5cca      	ldrb	r2, [r1, r3]
 80058da:	f082 025c 	eor.w	r2, r2, #92	; 0x5c
 80058de:	54ea      	strb	r2, [r5, r3]
}

static void HMAC_finish(uECC_HashContext *hash_context, const uint8_t *K, uint8_t *result) {
    uint8_t *pad = hash_context->tmp + 2 * hash_context->result_size;
    unsigned i;
    for (i = 0; i < hash_context->result_size; ++i)
 80058e0:	3301      	adds	r3, #1
 80058e2:	e7f6      	b.n	80058d2 <HMAC_finish+0x10>
 80058e4:	442b      	add	r3, r5
        pad[i] = K[i] ^ 0x5c;
    for (; i < hash_context->block_size; ++i)
        pad[i] = 0x5c;
 80058e6:	205c      	movs	r0, #92	; 0x5c
static void HMAC_finish(uECC_HashContext *hash_context, const uint8_t *K, uint8_t *result) {
    uint8_t *pad = hash_context->tmp + 2 * hash_context->result_size;
    unsigned i;
    for (i = 0; i < hash_context->result_size; ++i)
        pad[i] = K[i] ^ 0x5c;
    for (; i < hash_context->block_size; ++i)
 80058e8:	68e1      	ldr	r1, [r4, #12]
 80058ea:	1b5a      	subs	r2, r3, r5
 80058ec:	4291      	cmp	r1, r2
 80058ee:	d902      	bls.n	80058f6 <HMAC_finish+0x34>
        pad[i] = 0x5c;
 80058f0:	f803 0b01 	strb.w	r0, [r3], #1
 80058f4:	e7f8      	b.n	80058e8 <HMAC_finish+0x26>

    hash_context->finish_hash(hash_context, result);
 80058f6:	4631      	mov	r1, r6
 80058f8:	68a3      	ldr	r3, [r4, #8]
 80058fa:	4620      	mov	r0, r4
 80058fc:	4798      	blx	r3

    hash_context->init_hash(hash_context);
 80058fe:	6823      	ldr	r3, [r4, #0]
 8005900:	4620      	mov	r0, r4
 8005902:	4798      	blx	r3
    hash_context->update_hash(hash_context, pad, hash_context->block_size);
 8005904:	6863      	ldr	r3, [r4, #4]
 8005906:	68e2      	ldr	r2, [r4, #12]
 8005908:	4629      	mov	r1, r5
 800590a:	4620      	mov	r0, r4
 800590c:	4798      	blx	r3
    hash_context->update_hash(hash_context, result, hash_context->result_size);
 800590e:	6863      	ldr	r3, [r4, #4]
 8005910:	6922      	ldr	r2, [r4, #16]
 8005912:	4631      	mov	r1, r6
 8005914:	4620      	mov	r0, r4
 8005916:	4798      	blx	r3
    hash_context->finish_hash(hash_context, result);
 8005918:	68a3      	ldr	r3, [r4, #8]
 800591a:	4631      	mov	r1, r6
 800591c:	4620      	mov	r0, r4
}
 800591e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    hash_context->finish_hash(hash_context, result);

    hash_context->init_hash(hash_context);
    hash_context->update_hash(hash_context, pad, hash_context->block_size);
    hash_context->update_hash(hash_context, result, hash_context->result_size);
    hash_context->finish_hash(hash_context, result);
 8005922:	4718      	bx	r3

08005924 <update_V>:
}

/* V = HMAC_K(V) */
static void update_V(uECC_HashContext *hash_context, uint8_t *K, uint8_t *V) {
 8005924:	b570      	push	{r4, r5, r6, lr}
 8005926:	4604      	mov	r4, r0
 8005928:	4615      	mov	r5, r2
 800592a:	460e      	mov	r6, r1
    HMAC_init(hash_context, K);
 800592c:	f7ff ffa4 	bl	8005878 <HMAC_init>
    HMAC_update(hash_context, V, hash_context->result_size);
 8005930:	6922      	ldr	r2, [r4, #16]
 8005932:	4629      	mov	r1, r5
 8005934:	4620      	mov	r0, r4
 8005936:	f7ff ffc2 	bl	80058be <HMAC_update>
    HMAC_finish(hash_context, K, V);
 800593a:	462a      	mov	r2, r5
 800593c:	4631      	mov	r1, r6
 800593e:	4620      	mov	r0, r4
}
 8005940:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

/* V = HMAC_K(V) */
static void update_V(uECC_HashContext *hash_context, uint8_t *K, uint8_t *V) {
    HMAC_init(hash_context, K);
    HMAC_update(hash_context, V, hash_context->result_size);
    HMAC_finish(hash_context, K, V);
 8005944:	f7ff bfbd 	b.w	80058c2 <HMAC_finish>

08005948 <uECC_vli_add.isra.0>:
    #define RESUME_SYNTAX ".syntax divided \n\t"
#endif

#if (uECC_OPTIMIZATION_LEVEL >= 2)

uECC_VLI_API uECC_word_t uECC_vli_add(uECC_word_t *result,
 8005948:	b530      	push	{r4, r5, lr}
#endif
    uint32_t carry;
    uint32_t left_word;
    uint32_t right_word;
    
    __asm__ volatile (
 800594a:	4603      	mov	r3, r0
 800594c:	2000      	movs	r0, #0
 800594e:	c910      	ldmia	r1!, {r4}
 8005950:	ca20      	ldmia	r2!, {r5}
 8005952:	1964      	adds	r4, r4, r5
 8005954:	c310      	stmia	r3!, {r4}
 8005956:	c910      	ldmia	r1!, {r4}
 8005958:	ca20      	ldmia	r2!, {r5}
 800595a:	416c      	adcs	r4, r5
 800595c:	c310      	stmia	r3!, {r4}
 800595e:	c910      	ldmia	r1!, {r4}
 8005960:	ca20      	ldmia	r2!, {r5}
 8005962:	416c      	adcs	r4, r5
 8005964:	c310      	stmia	r3!, {r4}
 8005966:	c910      	ldmia	r1!, {r4}
 8005968:	ca20      	ldmia	r2!, {r5}
 800596a:	416c      	adcs	r4, r5
 800596c:	c310      	stmia	r3!, {r4}
 800596e:	c910      	ldmia	r1!, {r4}
 8005970:	ca20      	ldmia	r2!, {r5}
 8005972:	416c      	adcs	r4, r5
 8005974:	c310      	stmia	r3!, {r4}
 8005976:	c910      	ldmia	r1!, {r4}
 8005978:	ca20      	ldmia	r2!, {r5}
 800597a:	416c      	adcs	r4, r5
 800597c:	c310      	stmia	r3!, {r4}
 800597e:	c910      	ldmia	r1!, {r4}
 8005980:	ca20      	ldmia	r2!, {r5}
 8005982:	416c      	adcs	r4, r5
 8005984:	c310      	stmia	r3!, {r4}
 8005986:	c910      	ldmia	r1!, {r4}
 8005988:	ca20      	ldmia	r2!, {r5}
 800598a:	416c      	adcs	r4, r5
 800598c:	c310      	stmia	r3!, {r4}
 800598e:	4140      	adcs	r0, r0
          [right] REG_WRITE_LO (right_word)
        :
        : "cc", "memory"
    );
    return carry;
}
 8005990:	bd30      	pop	{r4, r5, pc}

08005992 <mod_sqrt_default>:

#if uECC_SUPPORT_COMPRESSED_POINT
#if uECC_SUPPORTS_secp160r1 || uECC_SUPPORTS_secp192r1 || \
    uECC_SUPPORTS_secp256r1 || uECC_SUPPORTS_secp256k1
/* Compute a = sqrt(a) (mod curve_p). */
static void mod_sqrt_default(uECC_word_t *a, uECC_Curve curve) {
 8005992:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005996:	b090      	sub	sp, #64	; 0x40
 8005998:	460e      	mov	r6, r1
    bitcount_t i;
    uECC_word_t p1[uECC_MAX_WORDS] = {1};
 800599a:	2220      	movs	r2, #32
 800599c:	2100      	movs	r1, #0

#if uECC_SUPPORT_COMPRESSED_POINT
#if uECC_SUPPORTS_secp160r1 || uECC_SUPPORTS_secp192r1 || \
    uECC_SUPPORTS_secp256r1 || uECC_SUPPORTS_secp256k1
/* Compute a = sqrt(a) (mod curve_p). */
static void mod_sqrt_default(uECC_word_t *a, uECC_Curve curve) {
 800599e:	4607      	mov	r7, r0
    bitcount_t i;
    uECC_word_t p1[uECC_MAX_WORDS] = {1};
 80059a0:	4668      	mov	r0, sp
 80059a2:	f007 fd90 	bl	800d4c6 <memset>
    uECC_word_t l_result[uECC_MAX_WORDS] = {1};
 80059a6:	2220      	movs	r2, #32
#if uECC_SUPPORTS_secp160r1 || uECC_SUPPORTS_secp192r1 || \
    uECC_SUPPORTS_secp256r1 || uECC_SUPPORTS_secp256k1
/* Compute a = sqrt(a) (mod curve_p). */
static void mod_sqrt_default(uECC_word_t *a, uECC_Curve curve) {
    bitcount_t i;
    uECC_word_t p1[uECC_MAX_WORDS] = {1};
 80059a8:	2401      	movs	r4, #1
    uECC_word_t l_result[uECC_MAX_WORDS] = {1};
 80059aa:	2100      	movs	r1, #0
 80059ac:	eb0d 0002 	add.w	r0, sp, r2
#if uECC_SUPPORTS_secp160r1 || uECC_SUPPORTS_secp192r1 || \
    uECC_SUPPORTS_secp256r1 || uECC_SUPPORTS_secp256k1
/* Compute a = sqrt(a) (mod curve_p). */
static void mod_sqrt_default(uECC_word_t *a, uECC_Curve curve) {
    bitcount_t i;
    uECC_word_t p1[uECC_MAX_WORDS] = {1};
 80059b0:	9400      	str	r4, [sp, #0]
    uECC_word_t l_result[uECC_MAX_WORDS] = {1};
 80059b2:	f007 fd88 	bl	800d4c6 <memset>
    wordcount_t num_words = curve->num_words;
 80059b6:	4631      	mov	r1, r6
    
    /* When curve->p == 3 (mod 4), we can compute
       sqrt(a) = a^((curve->p + 1) / 4) (mod curve->p). */
    uECC_vli_add(p1, curve->p, p1, num_words); /* p1 = curve_p + 1 */
 80059b8:	466a      	mov	r2, sp
/* Compute a = sqrt(a) (mod curve_p). */
static void mod_sqrt_default(uECC_word_t *a, uECC_Curve curve) {
    bitcount_t i;
    uECC_word_t p1[uECC_MAX_WORDS] = {1};
    uECC_word_t l_result[uECC_MAX_WORDS] = {1};
    wordcount_t num_words = curve->num_words;
 80059ba:	f811 5b04 	ldrb.w	r5, [r1], #4
    uECC_SUPPORTS_secp256r1 || uECC_SUPPORTS_secp256k1
/* Compute a = sqrt(a) (mod curve_p). */
static void mod_sqrt_default(uECC_word_t *a, uECC_Curve curve) {
    bitcount_t i;
    uECC_word_t p1[uECC_MAX_WORDS] = {1};
    uECC_word_t l_result[uECC_MAX_WORDS] = {1};
 80059be:	9408      	str	r4, [sp, #32]
    wordcount_t num_words = curve->num_words;
    
    /* When curve->p == 3 (mod 4), we can compute
       sqrt(a) = a^((curve->p + 1) / 4) (mod curve->p). */
    uECC_vli_add(p1, curve->p, p1, num_words); /* p1 = curve_p + 1 */
 80059c0:	4668      	mov	r0, sp
    for (i = uECC_vli_numBits(p1, num_words) - 1; i > 1; --i) {
 80059c2:	b26d      	sxtb	r5, r5
    uECC_word_t l_result[uECC_MAX_WORDS] = {1};
    wordcount_t num_words = curve->num_words;
    
    /* When curve->p == 3 (mod 4), we can compute
       sqrt(a) = a^((curve->p + 1) / 4) (mod curve->p). */
    uECC_vli_add(p1, curve->p, p1, num_words); /* p1 = curve_p + 1 */
 80059c4:	f7ff ffc0 	bl	8005948 <uECC_vli_add.isra.0>
    for (i = uECC_vli_numBits(p1, num_words) - 1; i > 1; --i) {
 80059c8:	4629      	mov	r1, r5
 80059ca:	4668      	mov	r0, sp
 80059cc:	f7ff fdef 	bl	80055ae <uECC_vli_numBits>
 80059d0:	3801      	subs	r0, #1
 80059d2:	b284      	uxth	r4, r0
 80059d4:	fa0f f884 	sxth.w	r8, r4
 80059d8:	f1b8 0f01 	cmp.w	r8, #1
 80059dc:	dd12      	ble.n	8005a04 <mod_sqrt_default+0x72>
        uECC_vli_modSquare_fast(l_result, l_result, curve);
 80059de:	a908      	add	r1, sp, #32
 80059e0:	4608      	mov	r0, r1
 80059e2:	4632      	mov	r2, r6
 80059e4:	f7ff fef0 	bl	80057c8 <uECC_vli_modSquare_fast>
        if (uECC_vli_testBit(p1, i)) {
 80059e8:	4641      	mov	r1, r8
 80059ea:	4668      	mov	r0, sp
 80059ec:	f7ff fdd5 	bl	800559a <uECC_vli_testBit>
 80059f0:	b128      	cbz	r0, 80059fe <mod_sqrt_default+0x6c>
            uECC_vli_modMult_fast(l_result, l_result, a, curve);
 80059f2:	a908      	add	r1, sp, #32
 80059f4:	4633      	mov	r3, r6
 80059f6:	463a      	mov	r2, r7
 80059f8:	4608      	mov	r0, r1
 80059fa:	f7ff fed5 	bl	80057a8 <uECC_vli_modMult_fast>
 80059fe:	3c01      	subs	r4, #1
 8005a00:	b2a4      	uxth	r4, r4
 8005a02:	e7e7      	b.n	80059d4 <mod_sqrt_default+0x42>
        }
    }
    uECC_vli_set(a, l_result, num_words);
 8005a04:	462a      	mov	r2, r5
 8005a06:	a908      	add	r1, sp, #32
 8005a08:	4638      	mov	r0, r7
 8005a0a:	f7ff fdf2 	bl	80055f2 <uECC_vli_set>
}
 8005a0e:	b010      	add	sp, #64	; 0x40
 8005a10:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08005a14 <omega_mult_secp256k1>:
    /* add the 2^32 multiple */
    result[4 + num_words_secp256k1] =
        uECC_vli_add(result + 4, result + 4, right, num_words_secp256k1); 
}
#elif uECC_WORD_SIZE == 4
static void omega_mult_secp256k1(uint32_t * result, const uint32_t * right) {
 8005a14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005a16:	460a      	mov	r2, r1
 8005a18:	4604      	mov	r4, r0
 8005a1a:	1f0d      	subs	r5, r1, #4
 8005a1c:	1f06      	subs	r6, r0, #4
 8005a1e:	f101 071c 	add.w	r7, r1, #28
    /* Multiply by (2^9 + 2^8 + 2^7 + 2^6 + 2^4 + 1). */
    uint32_t carry = 0;
 8005a22:	2300      	movs	r3, #0
    wordcount_t k;
    
    for (k = 0; k < num_words_secp256k1; ++k) {
        uint64_t p = (uint64_t)0x3D1 * right[k] + carry;
 8005a24:	f240 3ed1 	movw	lr, #977	; 0x3d1
 8005a28:	f855 cf04 	ldr.w	ip, [r5, #4]!
 8005a2c:	4618      	mov	r0, r3
 8005a2e:	2100      	movs	r1, #0
 8005a30:	fbee 010c 	umlal	r0, r1, lr, ip
static void omega_mult_secp256k1(uint32_t * result, const uint32_t * right) {
    /* Multiply by (2^9 + 2^8 + 2^7 + 2^6 + 2^4 + 1). */
    uint32_t carry = 0;
    wordcount_t k;
    
    for (k = 0; k < num_words_secp256k1; ++k) {
 8005a34:	42af      	cmp	r7, r5
        uint64_t p = (uint64_t)0x3D1 * right[k] + carry;
        result[k] = p;
 8005a36:	f846 0f04 	str.w	r0, [r6, #4]!
        carry = p >> 32;
 8005a3a:	460b      	mov	r3, r1
static void omega_mult_secp256k1(uint32_t * result, const uint32_t * right) {
    /* Multiply by (2^9 + 2^8 + 2^7 + 2^6 + 2^4 + 1). */
    uint32_t carry = 0;
    wordcount_t k;
    
    for (k = 0; k < num_words_secp256k1; ++k) {
 8005a3c:	d1f4      	bne.n	8005a28 <omega_mult_secp256k1+0x14>
        uint64_t p = (uint64_t)0x3D1 * right[k] + carry;
        result[k] = p;
        carry = p >> 32;
    }
    result[num_words_secp256k1] = carry;
 8005a3e:	6221      	str	r1, [r4, #32]
    /* add the 2^32 multiple */
    result[1 + num_words_secp256k1] =
        uECC_vli_add(result + 1, result + 1, right, num_words_secp256k1); 
 8005a40:	1d21      	adds	r1, r4, #4
 8005a42:	4608      	mov	r0, r1
 8005a44:	f7ff ff80 	bl	8005948 <uECC_vli_add.isra.0>
        result[k] = p;
        carry = p >> 32;
    }
    result[num_words_secp256k1] = carry;
    /* add the 2^32 multiple */
    result[1 + num_words_secp256k1] =
 8005a48:	6260      	str	r0, [r4, #36]	; 0x24
 8005a4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08005a4c <regularize_k>:
}

static uECC_word_t regularize_k(const uECC_word_t * const k,
                                uECC_word_t *k0,
                                uECC_word_t *k1,
                                uECC_Curve curve) {
 8005a4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005a4e:	460e      	mov	r6, r1
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    bitcount_t num_n_bits = curve->num_n_bits;
    uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
 8005a50:	f103 0524 	add.w	r5, r3, #36	; 0x24
}

static uECC_word_t regularize_k(const uECC_word_t * const k,
                                uECC_word_t *k0,
                                uECC_word_t *k1,
                                uECC_Curve curve) {
 8005a54:	4617      	mov	r7, r2
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    bitcount_t num_n_bits = curve->num_n_bits;
    uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
 8005a56:	4601      	mov	r1, r0
 8005a58:	462a      	mov	r2, r5
 8005a5a:	4630      	mov	r0, r6

static uECC_word_t regularize_k(const uECC_word_t * const k,
                                uECC_word_t *k0,
                                uECC_word_t *k1,
                                uECC_Curve curve) {
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8005a5c:	885c      	ldrh	r4, [r3, #2]
    bitcount_t num_n_bits = curve->num_n_bits;
    uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
 8005a5e:	f7ff ff73 	bl	8005948 <uECC_vli_add.isra.0>
 8005a62:	b980      	cbnz	r0, 8005a86 <regularize_k+0x3a>

static uECC_word_t regularize_k(const uECC_word_t * const k,
                                uECC_word_t *k0,
                                uECC_word_t *k1,
                                uECC_Curve curve) {
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8005a64:	b221      	sxth	r1, r4
 8005a66:	f101 031f 	add.w	r3, r1, #31
 8005a6a:	2220      	movs	r2, #32
 8005a6c:	fb93 f3f2 	sdiv	r3, r3, r2
    bitcount_t num_n_bits = curve->num_n_bits;
    uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
 8005a70:	b25b      	sxtb	r3, r3
 8005a72:	ebb1 1f43 	cmp.w	r1, r3, lsl #5
 8005a76:	da08      	bge.n	8005a8a <regularize_k+0x3e>
        (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
         uECC_vli_testBit(k0, num_n_bits));
 8005a78:	4630      	mov	r0, r6
 8005a7a:	f7ff fd8e 	bl	800559a <uECC_vli_testBit>
                                uECC_word_t *k0,
                                uECC_word_t *k1,
                                uECC_Curve curve) {
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    bitcount_t num_n_bits = curve->num_n_bits;
    uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
 8005a7e:	1c04      	adds	r4, r0, #0
 8005a80:	bf18      	it	ne
 8005a82:	2401      	movne	r4, #1
 8005a84:	e002      	b.n	8005a8c <regularize_k+0x40>
 8005a86:	2401      	movs	r4, #1
 8005a88:	e000      	b.n	8005a8c <regularize_k+0x40>
 8005a8a:	4604      	mov	r4, r0
        (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
         uECC_vli_testBit(k0, num_n_bits));
    uECC_vli_add(k1, k0, curve->n, num_n_words);
 8005a8c:	462a      	mov	r2, r5
 8005a8e:	4631      	mov	r1, r6
 8005a90:	4638      	mov	r0, r7
 8005a92:	f7ff ff59 	bl	8005948 <uECC_vli_add.isra.0>
    return carry;
}
 8005a96:	4620      	mov	r0, r4
 8005a98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08005a9a <uECC_vli_sub.isra.1>:
#define asm_add 1

uECC_VLI_API uECC_word_t uECC_vli_sub(uECC_word_t *result,
 8005a9a:	b530      	push	{r4, r5, lr}
#endif
    uint32_t carry;
    uint32_t left_word;
    uint32_t right_word;
    
    __asm__ volatile (
 8005a9c:	2300      	movs	r3, #0
 8005a9e:	c910      	ldmia	r1!, {r4}
 8005aa0:	ca20      	ldmia	r2!, {r5}
 8005aa2:	1b64      	subs	r4, r4, r5
 8005aa4:	c010      	stmia	r0!, {r4}
 8005aa6:	c910      	ldmia	r1!, {r4}
 8005aa8:	ca20      	ldmia	r2!, {r5}
 8005aaa:	41ac      	sbcs	r4, r5
 8005aac:	c010      	stmia	r0!, {r4}
 8005aae:	c910      	ldmia	r1!, {r4}
 8005ab0:	ca20      	ldmia	r2!, {r5}
 8005ab2:	41ac      	sbcs	r4, r5
 8005ab4:	c010      	stmia	r0!, {r4}
 8005ab6:	c910      	ldmia	r1!, {r4}
 8005ab8:	ca20      	ldmia	r2!, {r5}
 8005aba:	41ac      	sbcs	r4, r5
 8005abc:	c010      	stmia	r0!, {r4}
 8005abe:	c910      	ldmia	r1!, {r4}
 8005ac0:	ca20      	ldmia	r2!, {r5}
 8005ac2:	41ac      	sbcs	r4, r5
 8005ac4:	c010      	stmia	r0!, {r4}
 8005ac6:	c910      	ldmia	r1!, {r4}
 8005ac8:	ca20      	ldmia	r2!, {r5}
 8005aca:	41ac      	sbcs	r4, r5
 8005acc:	c010      	stmia	r0!, {r4}
 8005ace:	c910      	ldmia	r1!, {r4}
 8005ad0:	ca20      	ldmia	r2!, {r5}
 8005ad2:	41ac      	sbcs	r4, r5
 8005ad4:	c010      	stmia	r0!, {r4}
 8005ad6:	c910      	ldmia	r1!, {r4}
 8005ad8:	ca20      	ldmia	r2!, {r5}
 8005ada:	41ac      	sbcs	r4, r5
 8005adc:	c010      	stmia	r0!, {r4}
 8005ade:	415b      	adcs	r3, r3
        :
        : "cc", "memory"
    );
    return !carry; /* Note that on ARM, carry flag set means "no borrow" when subtracting
                      (for some reason...) */
}
 8005ae0:	fab3 f083 	clz	r0, r3
 8005ae4:	0940      	lsrs	r0, r0, #5
 8005ae6:	bd30      	pop	{r4, r5, pc}

08005ae8 <uECC_vli_cmp>:

#ifndef NO_SIGNING
/* Returns sign of left - right, in constant time. */
uECC_VLI_API cmpresult_t uECC_vli_cmp(const uECC_word_t *left,
                                      const uECC_word_t *right,
                                      wordcount_t num_words) {
 8005ae8:	b530      	push	{r4, r5, lr}
 8005aea:	b089      	sub	sp, #36	; 0x24
 8005aec:	4615      	mov	r5, r2
    uECC_word_t tmp[uECC_MAX_WORDS];
    uECC_word_t neg = !!uECC_vli_sub(tmp, left, right, num_words);
 8005aee:	460a      	mov	r2, r1
 8005af0:	4601      	mov	r1, r0
 8005af2:	4668      	mov	r0, sp
 8005af4:	f7ff ffd1 	bl	8005a9a <uECC_vli_sub.isra.1>
    uECC_word_t equal = uECC_vli_isZero(tmp, num_words);
 8005af8:	4629      	mov	r1, r5
/* Returns sign of left - right, in constant time. */
uECC_VLI_API cmpresult_t uECC_vli_cmp(const uECC_word_t *left,
                                      const uECC_word_t *right,
                                      wordcount_t num_words) {
    uECC_word_t tmp[uECC_MAX_WORDS];
    uECC_word_t neg = !!uECC_vli_sub(tmp, left, right, num_words);
 8005afa:	4604      	mov	r4, r0
    uECC_word_t equal = uECC_vli_isZero(tmp, num_words);
 8005afc:	4668      	mov	r0, sp
 8005afe:	f7ff fd3d 	bl	800557c <uECC_vli_isZero>
    return (!equal - 2 * neg);
 8005b02:	3400      	adds	r4, #0
 8005b04:	bf18      	it	ne
 8005b06:	2401      	movne	r4, #1
 8005b08:	0064      	lsls	r4, r4, #1
}
 8005b0a:	2800      	cmp	r0, #0
 8005b0c:	bf14      	ite	ne
 8005b0e:	4260      	negne	r0, r4
 8005b10:	f1c4 0001 	rsbeq	r0, r4, #1
 8005b14:	b009      	add	sp, #36	; 0x24
 8005b16:	bd30      	pop	{r4, r5, pc}

08005b18 <uECC_generate_random_int>:
#ifndef NO_SIGNING
/* Generates a random integer in the range 0 < random < top.
   Both random and top have num_words words. */
uECC_VLI_API int uECC_generate_random_int(uECC_word_t *random,
                                          const uECC_word_t *top,
                                          wordcount_t num_words) {
 8005b18:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005b1c:	468a      	mov	sl, r1
    uECC_word_t mask = (uECC_word_t)-1;
    uECC_word_t tries;
    bitcount_t num_bits = uECC_vli_numBits(top, num_words);

    if (!g_rng_function) {
 8005b1e:	4f1b      	ldr	r7, [pc, #108]	; (8005b8c <uECC_generate_random_int+0x74>)
#ifndef NO_SIGNING
/* Generates a random integer in the range 0 < random < top.
   Both random and top have num_words words. */
uECC_VLI_API int uECC_generate_random_int(uECC_word_t *random,
                                          const uECC_word_t *top,
                                          wordcount_t num_words) {
 8005b20:	4606      	mov	r6, r0
    uECC_word_t mask = (uECC_word_t)-1;
    uECC_word_t tries;
    bitcount_t num_bits = uECC_vli_numBits(top, num_words);
 8005b22:	4611      	mov	r1, r2
 8005b24:	4650      	mov	r0, sl
#ifndef NO_SIGNING
/* Generates a random integer in the range 0 < random < top.
   Both random and top have num_words words. */
uECC_VLI_API int uECC_generate_random_int(uECC_word_t *random,
                                          const uECC_word_t *top,
                                          wordcount_t num_words) {
 8005b26:	4615      	mov	r5, r2
    uECC_word_t mask = (uECC_word_t)-1;
    uECC_word_t tries;
    bitcount_t num_bits = uECC_vli_numBits(top, num_words);
 8005b28:	f7ff fd41 	bl	80055ae <uECC_vli_numBits>

    if (!g_rng_function) {
 8005b2c:	683b      	ldr	r3, [r7, #0]
 8005b2e:	b913      	cbnz	r3, 8005b36 <uECC_generate_random_int+0x1e>
        return 0;
 8005b30:	2000      	movs	r0, #0
 8005b32:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    }

    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
        if (!g_rng_function((uint8_t *)random, num_words * uECC_WORD_SIZE)) {
 8005b36:	2404      	movs	r4, #4
            return 0;
	    }
        random[num_words - 1] &= mask >> ((bitcount_t)(num_words * uECC_WORD_SIZE * 8 - num_bits));
 8005b38:	ebc0 1045 	rsb	r0, r0, r5, lsl #5
    if (!g_rng_function) {
        return 0;
    }

    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
        if (!g_rng_function((uint8_t *)random, num_words * uECC_WORD_SIZE)) {
 8005b3c:	fb15 fb04 	smulbb	fp, r5, r4
            return 0;
	    }
        random[num_words - 1] &= mask >> ((bitcount_t)(num_words * uECC_WORD_SIZE * 8 - num_bits));
 8005b40:	b200      	sxth	r0, r0
 8005b42:	fb04 6405 	mla	r4, r4, r5, r6
 8005b46:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
 8005b4a:	3c04      	subs	r4, #4
 8005b4c:	fa29 f900 	lsr.w	r9, r9, r0
 8005b50:	f04f 0840 	mov.w	r8, #64	; 0x40
    if (!g_rng_function) {
        return 0;
    }

    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
        if (!g_rng_function((uint8_t *)random, num_words * uECC_WORD_SIZE)) {
 8005b54:	683b      	ldr	r3, [r7, #0]
 8005b56:	4659      	mov	r1, fp
 8005b58:	4630      	mov	r0, r6
 8005b5a:	4798      	blx	r3
 8005b5c:	2800      	cmp	r0, #0
 8005b5e:	d0e7      	beq.n	8005b30 <uECC_generate_random_int+0x18>
            return 0;
	    }
        random[num_words - 1] &= mask >> ((bitcount_t)(num_words * uECC_WORD_SIZE * 8 - num_bits));
 8005b60:	6823      	ldr	r3, [r4, #0]
 8005b62:	ea03 0309 	and.w	r3, r3, r9
 8005b66:	6023      	str	r3, [r4, #0]
        if (!uECC_vli_isZero(random, num_words) &&
 8005b68:	4629      	mov	r1, r5
 8005b6a:	4630      	mov	r0, r6
 8005b6c:	f7ff fd06 	bl	800557c <uECC_vli_isZero>
 8005b70:	b118      	cbz	r0, 8005b7a <uECC_generate_random_int+0x62>

    if (!g_rng_function) {
        return 0;
    }

    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
 8005b72:	f1b8 0801 	subs.w	r8, r8, #1
 8005b76:	d1ed      	bne.n	8005b54 <uECC_generate_random_int+0x3c>
 8005b78:	e7da      	b.n	8005b30 <uECC_generate_random_int+0x18>
        if (!g_rng_function((uint8_t *)random, num_words * uECC_WORD_SIZE)) {
            return 0;
	    }
        random[num_words - 1] &= mask >> ((bitcount_t)(num_words * uECC_WORD_SIZE * 8 - num_bits));
        if (!uECC_vli_isZero(random, num_words) &&
		        uECC_vli_cmp(top, random, num_words) == 1) {
 8005b7a:	462a      	mov	r2, r5
 8005b7c:	4631      	mov	r1, r6
 8005b7e:	4650      	mov	r0, sl
 8005b80:	f7ff ffb2 	bl	8005ae8 <uECC_vli_cmp>
    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
        if (!g_rng_function((uint8_t *)random, num_words * uECC_WORD_SIZE)) {
            return 0;
	    }
        random[num_words - 1] &= mask >> ((bitcount_t)(num_words * uECC_WORD_SIZE * 8 - num_bits));
        if (!uECC_vli_isZero(random, num_words) &&
 8005b84:	2801      	cmp	r0, #1
 8005b86:	d1f4      	bne.n	8005b72 <uECC_generate_random_int+0x5a>
		        uECC_vli_cmp(top, random, num_words) == 1) {
            return 1;
        }
    }
    return 0;
}
 8005b88:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005b8c:	20000234 	.word	0x20000234

08005b90 <uECC_vli_modAdd>:
   Assumes that left < mod and right < mod, and that result does not overlap mod. */
uECC_VLI_API void uECC_vli_modAdd(uECC_word_t *result,
                                  const uECC_word_t *left,
                                  const uECC_word_t *right,
                                  const uECC_word_t *mod,
                                  wordcount_t num_words) {
 8005b90:	b570      	push	{r4, r5, r6, lr}
 8005b92:	4604      	mov	r4, r0
 8005b94:	461d      	mov	r5, r3
 8005b96:	f99d 6010 	ldrsb.w	r6, [sp, #16]
    uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
 8005b9a:	f7ff fed5 	bl	8005948 <uECC_vli_add.isra.0>
    if (carry || uECC_vli_cmp_unsafe(mod, result, num_words) != 1) {
 8005b9e:	b930      	cbnz	r0, 8005bae <uECC_vli_modAdd+0x1e>
 8005ba0:	4632      	mov	r2, r6
 8005ba2:	4621      	mov	r1, r4
 8005ba4:	4628      	mov	r0, r5
 8005ba6:	f7ff fd31 	bl	800560c <uECC_vli_cmp_unsafe>
 8005baa:	2801      	cmp	r0, #1
 8005bac:	d006      	beq.n	8005bbc <uECC_vli_modAdd+0x2c>
        /* result > mod (result = mod + remainder), so subtract mod to get remainder. */
        uECC_vli_sub(result, result, mod, num_words);
 8005bae:	462a      	mov	r2, r5
 8005bb0:	4621      	mov	r1, r4
 8005bb2:	4620      	mov	r0, r4
    }
}
 8005bb4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
                                  const uECC_word_t *mod,
                                  wordcount_t num_words) {
    uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
    if (carry || uECC_vli_cmp_unsafe(mod, result, num_words) != 1) {
        /* result > mod (result = mod + remainder), so subtract mod to get remainder. */
        uECC_vli_sub(result, result, mod, num_words);
 8005bb8:	f7ff bf6f 	b.w	8005a9a <uECC_vli_sub.isra.1>
 8005bbc:	bd70      	pop	{r4, r5, r6, pc}

08005bbe <x_side_secp256k1>:
    uECC_vli_modMult_fast(Y1, Y1, t4, curve);                   /* t2 = B * (A - x3) */
    uECC_vli_modSub(Y1, Y1, t5, curve->p, num_words_secp256k1); /* t2 = B * (A - x3) - y1^4 = y3 */
}

/* Computes result = x^3 + b. result must not overlap x. */
static void x_side_secp256k1(uECC_word_t *result, const uECC_word_t *x, uECC_Curve curve) {
 8005bbe:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8005bc0:	4604      	mov	r4, r0
 8005bc2:	4615      	mov	r5, r2
 8005bc4:	460e      	mov	r6, r1
    uECC_vli_modSquare_fast(result, x, curve);                                /* r = x^2 */
 8005bc6:	f7ff fdff 	bl	80057c8 <uECC_vli_modSquare_fast>
    uECC_vli_modMult_fast(result, result, x, curve);                          /* r = x^3 */
 8005bca:	462b      	mov	r3, r5
 8005bcc:	4632      	mov	r2, r6
 8005bce:	4621      	mov	r1, r4
 8005bd0:	4620      	mov	r0, r4
 8005bd2:	f7ff fde9 	bl	80057a8 <uECC_vli_modMult_fast>
    uECC_vli_modAdd(result, result, curve->b, curve->p, num_words_secp256k1); /* r = x^3 + b */
 8005bd6:	2308      	movs	r3, #8
 8005bd8:	9300      	str	r3, [sp, #0]
 8005bda:	f105 0284 	add.w	r2, r5, #132	; 0x84
 8005bde:	1d2b      	adds	r3, r5, #4
 8005be0:	4621      	mov	r1, r4
 8005be2:	4620      	mov	r0, r4
 8005be4:	f7ff ffd4 	bl	8005b90 <uECC_vli_modAdd>
}
 8005be8:	b002      	add	sp, #8
 8005bea:	bd70      	pop	{r4, r5, r6, pc}

08005bec <vli_mmod_fast_secp256r1>:
            carry -= uECC_vli_sub(result, result, curve_secp256r1.p, num_words_secp256r1);
        }
    }
}
#elif uECC_WORD_SIZE == 4
static void vli_mmod_fast_secp256r1(uint32_t *result, uint32_t *product) {
 8005bec:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint32_t tmp[num_words_secp256r1];
    int carry;
    
    /* t */
    uECC_vli_set(result, product, num_words_secp256r1);
 8005bee:	2208      	movs	r2, #8
            carry -= uECC_vli_sub(result, result, curve_secp256r1.p, num_words_secp256r1);
        }
    }
}
#elif uECC_WORD_SIZE == 4
static void vli_mmod_fast_secp256r1(uint32_t *result, uint32_t *product) {
 8005bf0:	b089      	sub	sp, #36	; 0x24
 8005bf2:	460c      	mov	r4, r1
 8005bf4:	4606      	mov	r6, r0
    uint32_t tmp[num_words_secp256r1];
    int carry;
    
    /* t */
    uECC_vli_set(result, product, num_words_secp256r1);
 8005bf6:	f7ff fcfc 	bl	80055f2 <uECC_vli_set>
    
    /* s1 */
    tmp[0] = tmp[1] = tmp[2] = 0;
    tmp[3] = product[11];
 8005bfa:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 8005bfc:	9303      	str	r3, [sp, #12]
    tmp[4] = product[12];
 8005bfe:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 8005c00:	9304      	str	r3, [sp, #16]
    tmp[5] = product[13];
 8005c02:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 8005c04:	9305      	str	r3, [sp, #20]
    tmp[6] = product[14];
 8005c06:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 8005c08:	9306      	str	r3, [sp, #24]
    
    /* t */
    uECC_vli_set(result, product, num_words_secp256r1);
    
    /* s1 */
    tmp[0] = tmp[1] = tmp[2] = 0;
 8005c0a:	2700      	movs	r7, #0
    tmp[3] = product[11];
    tmp[4] = product[12];
    tmp[5] = product[13];
    tmp[6] = product[14];
    tmp[7] = product[15];
 8005c0c:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 8005c0e:	9307      	str	r3, [sp, #28]
    carry = uECC_vli_add(tmp, tmp, tmp, num_words_secp256r1);
 8005c10:	466a      	mov	r2, sp
 8005c12:	4669      	mov	r1, sp
 8005c14:	4668      	mov	r0, sp
    
    /* t */
    uECC_vli_set(result, product, num_words_secp256r1);
    
    /* s1 */
    tmp[0] = tmp[1] = tmp[2] = 0;
 8005c16:	9702      	str	r7, [sp, #8]
 8005c18:	9701      	str	r7, [sp, #4]
 8005c1a:	9700      	str	r7, [sp, #0]
    tmp[3] = product[11];
    tmp[4] = product[12];
    tmp[5] = product[13];
    tmp[6] = product[14];
    tmp[7] = product[15];
    carry = uECC_vli_add(tmp, tmp, tmp, num_words_secp256r1);
 8005c1c:	f7ff fe94 	bl	8005948 <uECC_vli_add.isra.0>
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005c20:	466a      	mov	r2, sp
    tmp[3] = product[11];
    tmp[4] = product[12];
    tmp[5] = product[13];
    tmp[6] = product[14];
    tmp[7] = product[15];
    carry = uECC_vli_add(tmp, tmp, tmp, num_words_secp256r1);
 8005c22:	4605      	mov	r5, r0
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005c24:	4631      	mov	r1, r6
 8005c26:	4630      	mov	r0, r6
 8005c28:	f7ff fe8e 	bl	8005948 <uECC_vli_add.isra.0>
    
    /* s2 */
    tmp[3] = product[12];
 8005c2c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005c2e:	9303      	str	r3, [sp, #12]
    tmp[4] = product[13];
 8005c30:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005c32:	9304      	str	r3, [sp, #16]
    tmp[5] = product[14];
 8005c34:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005c36:	9305      	str	r3, [sp, #20]
    tmp[4] = product[12];
    tmp[5] = product[13];
    tmp[6] = product[14];
    tmp[7] = product[15];
    carry = uECC_vli_add(tmp, tmp, tmp, num_words_secp256r1);
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005c38:	4405      	add	r5, r0
    
    /* s2 */
    tmp[3] = product[12];
    tmp[4] = product[13];
    tmp[5] = product[14];
    tmp[6] = product[15];
 8005c3a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005c3c:	9306      	str	r3, [sp, #24]
    tmp[7] = 0;
    carry += uECC_vli_add(tmp, tmp, tmp, num_words_secp256r1);
 8005c3e:	466a      	mov	r2, sp
 8005c40:	4669      	mov	r1, sp
 8005c42:	4668      	mov	r0, sp
    /* s2 */
    tmp[3] = product[12];
    tmp[4] = product[13];
    tmp[5] = product[14];
    tmp[6] = product[15];
    tmp[7] = 0;
 8005c44:	9707      	str	r7, [sp, #28]
    carry += uECC_vli_add(tmp, tmp, tmp, num_words_secp256r1);
 8005c46:	f7ff fe7f 	bl	8005948 <uECC_vli_add.isra.0>
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005c4a:	466a      	mov	r2, sp
    tmp[3] = product[12];
    tmp[4] = product[13];
    tmp[5] = product[14];
    tmp[6] = product[15];
    tmp[7] = 0;
    carry += uECC_vli_add(tmp, tmp, tmp, num_words_secp256r1);
 8005c4c:	4405      	add	r5, r0
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005c4e:	4631      	mov	r1, r6
 8005c50:	4630      	mov	r0, r6
 8005c52:	f7ff fe79 	bl	8005948 <uECC_vli_add.isra.0>
    
    /* s3 */
    tmp[0] = product[8];
 8005c56:	6a23      	ldr	r3, [r4, #32]
 8005c58:	9300      	str	r3, [sp, #0]
    tmp[1] = product[9];
 8005c5a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005c5c:	9301      	str	r3, [sp, #4]
    tmp[2] = product[10];
 8005c5e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8005c60:	9302      	str	r3, [sp, #8]
    tmp[3] = tmp[4] = tmp[5] = 0;
    tmp[6] = product[14];
 8005c62:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005c64:	9306      	str	r3, [sp, #24]
    tmp[4] = product[13];
    tmp[5] = product[14];
    tmp[6] = product[15];
    tmp[7] = 0;
    carry += uECC_vli_add(tmp, tmp, tmp, num_words_secp256r1);
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005c66:	4405      	add	r5, r0
    tmp[0] = product[8];
    tmp[1] = product[9];
    tmp[2] = product[10];
    tmp[3] = tmp[4] = tmp[5] = 0;
    tmp[6] = product[14];
    tmp[7] = product[15];
 8005c68:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005c6a:	9307      	str	r3, [sp, #28]
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005c6c:	466a      	mov	r2, sp
 8005c6e:	4631      	mov	r1, r6
 8005c70:	4630      	mov	r0, r6
    
    /* s3 */
    tmp[0] = product[8];
    tmp[1] = product[9];
    tmp[2] = product[10];
    tmp[3] = tmp[4] = tmp[5] = 0;
 8005c72:	9705      	str	r7, [sp, #20]
 8005c74:	9704      	str	r7, [sp, #16]
 8005c76:	9703      	str	r7, [sp, #12]
    tmp[6] = product[14];
    tmp[7] = product[15];
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005c78:	f7ff fe66 	bl	8005948 <uECC_vli_add.isra.0>
    
    /* s4 */
    tmp[0] = product[9];
 8005c7c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005c7e:	9300      	str	r3, [sp, #0]
    tmp[1] = product[10];
 8005c80:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    tmp[2] = product[11];
    tmp[3] = product[13];
    tmp[4] = product[14];
 8005c82:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    tmp[7] = product[15];
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
    
    /* s4 */
    tmp[0] = product[9];
    tmp[1] = product[10];
 8005c84:	9301      	str	r3, [sp, #4]
    tmp[2] = product[11];
 8005c86:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8005c88:	9302      	str	r3, [sp, #8]
    tmp[3] = product[13];
    tmp[4] = product[14];
 8005c8a:	9204      	str	r2, [sp, #16]
    
    /* s4 */
    tmp[0] = product[9];
    tmp[1] = product[10];
    tmp[2] = product[11];
    tmp[3] = product[13];
 8005c8c:	6b63      	ldr	r3, [r4, #52]	; 0x34
    tmp[4] = product[14];
    tmp[5] = product[15];
 8005c8e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    
    /* s4 */
    tmp[0] = product[9];
    tmp[1] = product[10];
    tmp[2] = product[11];
    tmp[3] = product[13];
 8005c90:	9303      	str	r3, [sp, #12]
    tmp[1] = product[9];
    tmp[2] = product[10];
    tmp[3] = tmp[4] = tmp[5] = 0;
    tmp[6] = product[14];
    tmp[7] = product[15];
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005c92:	4405      	add	r5, r0
    tmp[0] = product[9];
    tmp[1] = product[10];
    tmp[2] = product[11];
    tmp[3] = product[13];
    tmp[4] = product[14];
    tmp[5] = product[15];
 8005c94:	9205      	str	r2, [sp, #20]
    tmp[6] = product[13];
 8005c96:	9306      	str	r3, [sp, #24]
    tmp[7] = product[8];
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005c98:	466a      	mov	r2, sp
    tmp[2] = product[11];
    tmp[3] = product[13];
    tmp[4] = product[14];
    tmp[5] = product[15];
    tmp[6] = product[13];
    tmp[7] = product[8];
 8005c9a:	6a23      	ldr	r3, [r4, #32]
 8005c9c:	9307      	str	r3, [sp, #28]
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005c9e:	4631      	mov	r1, r6
 8005ca0:	4630      	mov	r0, r6
 8005ca2:	f7ff fe51 	bl	8005948 <uECC_vli_add.isra.0>
    
    /* d1 */
    tmp[0] = product[11];
 8005ca6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8005ca8:	9300      	str	r3, [sp, #0]
    tmp[1] = product[12];
 8005caa:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005cac:	9301      	str	r3, [sp, #4]
    tmp[2] = product[13];
 8005cae:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005cb0:	9302      	str	r3, [sp, #8]
    tmp[3] = tmp[4] = tmp[5] = 0;
    tmp[6] = product[8];
 8005cb2:	6a23      	ldr	r3, [r4, #32]
 8005cb4:	9306      	str	r3, [sp, #24]
    tmp[3] = product[13];
    tmp[4] = product[14];
    tmp[5] = product[15];
    tmp[6] = product[13];
    tmp[7] = product[8];
    carry += uECC_vli_add(result, result, tmp, num_words_secp256r1);
 8005cb6:	4405      	add	r5, r0
    tmp[0] = product[11];
    tmp[1] = product[12];
    tmp[2] = product[13];
    tmp[3] = tmp[4] = tmp[5] = 0;
    tmp[6] = product[8];
    tmp[7] = product[10];
 8005cb8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8005cba:	9307      	str	r3, [sp, #28]
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
 8005cbc:	466a      	mov	r2, sp
 8005cbe:	4631      	mov	r1, r6
 8005cc0:	4630      	mov	r0, r6
    
    /* d1 */
    tmp[0] = product[11];
    tmp[1] = product[12];
    tmp[2] = product[13];
    tmp[3] = tmp[4] = tmp[5] = 0;
 8005cc2:	9705      	str	r7, [sp, #20]
 8005cc4:	9704      	str	r7, [sp, #16]
 8005cc6:	9703      	str	r7, [sp, #12]
    tmp[6] = product[8];
    tmp[7] = product[10];
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
 8005cc8:	f7ff fee7 	bl	8005a9a <uECC_vli_sub.isra.1>
    
    /* d2 */
    tmp[0] = product[12];
 8005ccc:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005cce:	9300      	str	r3, [sp, #0]
    tmp[1] = product[13];
 8005cd0:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005cd2:	9301      	str	r3, [sp, #4]
    tmp[2] = product[14];
 8005cd4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005cd6:	9302      	str	r3, [sp, #8]
    tmp[3] = product[15];
 8005cd8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005cda:	9303      	str	r3, [sp, #12]
    tmp[4] = tmp[5] = 0;
    tmp[6] = product[9];
 8005cdc:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005cde:	9306      	str	r3, [sp, #24]
    tmp[1] = product[12];
    tmp[2] = product[13];
    tmp[3] = tmp[4] = tmp[5] = 0;
    tmp[6] = product[8];
    tmp[7] = product[10];
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
 8005ce0:	1a2d      	subs	r5, r5, r0
    tmp[1] = product[13];
    tmp[2] = product[14];
    tmp[3] = product[15];
    tmp[4] = tmp[5] = 0;
    tmp[6] = product[9];
    tmp[7] = product[11];
 8005ce2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8005ce4:	9307      	str	r3, [sp, #28]
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
 8005ce6:	466a      	mov	r2, sp
 8005ce8:	4631      	mov	r1, r6
 8005cea:	4630      	mov	r0, r6
    /* d2 */
    tmp[0] = product[12];
    tmp[1] = product[13];
    tmp[2] = product[14];
    tmp[3] = product[15];
    tmp[4] = tmp[5] = 0;
 8005cec:	9705      	str	r7, [sp, #20]
 8005cee:	9704      	str	r7, [sp, #16]
    tmp[6] = product[9];
    tmp[7] = product[11];
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
 8005cf0:	f7ff fed3 	bl	8005a9a <uECC_vli_sub.isra.1>
    
    /* d3 */
    tmp[0] = product[13];
 8005cf4:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005cf6:	9300      	str	r3, [sp, #0]
    tmp[1] = product[14];
 8005cf8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005cfa:	9301      	str	r3, [sp, #4]
    tmp[2] = product[15];
 8005cfc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005cfe:	9302      	str	r3, [sp, #8]
    tmp[3] = product[8];
 8005d00:	6a23      	ldr	r3, [r4, #32]
 8005d02:	9303      	str	r3, [sp, #12]
    tmp[4] = product[9];
 8005d04:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005d06:	9304      	str	r3, [sp, #16]
    tmp[5] = product[10];
 8005d08:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8005d0a:	9305      	str	r3, [sp, #20]
    tmp[2] = product[14];
    tmp[3] = product[15];
    tmp[4] = tmp[5] = 0;
    tmp[6] = product[9];
    tmp[7] = product[11];
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
 8005d0c:	1a2d      	subs	r5, r5, r0
    tmp[2] = product[15];
    tmp[3] = product[8];
    tmp[4] = product[9];
    tmp[5] = product[10];
    tmp[6] = 0;
    tmp[7] = product[12];
 8005d0e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005d10:	9307      	str	r3, [sp, #28]
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
 8005d12:	466a      	mov	r2, sp
 8005d14:	4631      	mov	r1, r6
 8005d16:	4630      	mov	r0, r6
    tmp[1] = product[14];
    tmp[2] = product[15];
    tmp[3] = product[8];
    tmp[4] = product[9];
    tmp[5] = product[10];
    tmp[6] = 0;
 8005d18:	9706      	str	r7, [sp, #24]
    tmp[7] = product[12];
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
 8005d1a:	f7ff febe 	bl	8005a9a <uECC_vli_sub.isra.1>
    
    /* d4 */
    tmp[0] = product[14];
 8005d1e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005d20:	9300      	str	r3, [sp, #0]
    tmp[1] = product[15];
 8005d22:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005d24:	9301      	str	r3, [sp, #4]
    tmp[2] = 0;
    tmp[3] = product[9];
 8005d26:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005d28:	9303      	str	r3, [sp, #12]
    tmp[4] = product[10];
 8005d2a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8005d2c:	9304      	str	r3, [sp, #16]
    tmp[5] = product[11];
 8005d2e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8005d30:	9305      	str	r3, [sp, #20]
    tmp[3] = product[8];
    tmp[4] = product[9];
    tmp[5] = product[10];
    tmp[6] = 0;
    tmp[7] = product[12];
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
 8005d32:	1a2d      	subs	r5, r5, r0
    tmp[2] = 0;
    tmp[3] = product[9];
    tmp[4] = product[10];
    tmp[5] = product[11];
    tmp[6] = 0;
    tmp[7] = product[13];
 8005d34:	6b63      	ldr	r3, [r4, #52]	; 0x34
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
    
    /* d4 */
    tmp[0] = product[14];
    tmp[1] = product[15];
    tmp[2] = 0;
 8005d36:	9702      	str	r7, [sp, #8]
    tmp[3] = product[9];
    tmp[4] = product[10];
    tmp[5] = product[11];
    tmp[6] = 0;
    tmp[7] = product[13];
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
 8005d38:	466a      	mov	r2, sp
 8005d3a:	4631      	mov	r1, r6
 8005d3c:	4630      	mov	r0, r6
    tmp[1] = product[15];
    tmp[2] = 0;
    tmp[3] = product[9];
    tmp[4] = product[10];
    tmp[5] = product[11];
    tmp[6] = 0;
 8005d3e:	9706      	str	r7, [sp, #24]
    tmp[7] = product[13];
 8005d40:	9307      	str	r3, [sp, #28]
    carry -= uECC_vli_sub(result, result, tmp, num_words_secp256r1);
 8005d42:	f7ff feaa 	bl	8005a9a <uECC_vli_sub.isra.1>
    
    if (carry < 0) {
 8005d46:	1a2d      	subs	r5, r5, r0
 8005d48:	d514      	bpl.n	8005d74 <vli_mmod_fast_secp256r1+0x188>
        do {
            carry += uECC_vli_add(result, result, curve_secp256r1.p, num_words_secp256r1);
 8005d4a:	4a0d      	ldr	r2, [pc, #52]	; (8005d80 <vli_mmod_fast_secp256r1+0x194>)
 8005d4c:	4631      	mov	r1, r6
 8005d4e:	4630      	mov	r0, r6
 8005d50:	f7ff fdfa 	bl	8005948 <uECC_vli_add.isra.0>
        } while (carry < 0);
 8005d54:	182d      	adds	r5, r5, r0
 8005d56:	d4f8      	bmi.n	8005d4a <vli_mmod_fast_secp256r1+0x15e>
 8005d58:	e00f      	b.n	8005d7a <vli_mmod_fast_secp256r1+0x18e>
    } else {
        while (carry || uECC_vli_cmp_unsafe(curve_secp256r1.p, result, num_words_secp256r1) != 1) {
 8005d5a:	2208      	movs	r2, #8
 8005d5c:	4631      	mov	r1, r6
 8005d5e:	4808      	ldr	r0, [pc, #32]	; (8005d80 <vli_mmod_fast_secp256r1+0x194>)
 8005d60:	f7ff fc54 	bl	800560c <uECC_vli_cmp_unsafe>
 8005d64:	2801      	cmp	r0, #1
 8005d66:	d008      	beq.n	8005d7a <vli_mmod_fast_secp256r1+0x18e>
            carry -= uECC_vli_sub(result, result, curve_secp256r1.p, num_words_secp256r1);
 8005d68:	4a05      	ldr	r2, [pc, #20]	; (8005d80 <vli_mmod_fast_secp256r1+0x194>)
 8005d6a:	4631      	mov	r1, r6
 8005d6c:	4630      	mov	r0, r6
 8005d6e:	f7ff fe94 	bl	8005a9a <uECC_vli_sub.isra.1>
 8005d72:	1a2d      	subs	r5, r5, r0
    if (carry < 0) {
        do {
            carry += uECC_vli_add(result, result, curve_secp256r1.p, num_words_secp256r1);
        } while (carry < 0);
    } else {
        while (carry || uECC_vli_cmp_unsafe(curve_secp256r1.p, result, num_words_secp256r1) != 1) {
 8005d74:	2d00      	cmp	r5, #0
 8005d76:	d0f0      	beq.n	8005d5a <vli_mmod_fast_secp256r1+0x16e>
 8005d78:	e7f6      	b.n	8005d68 <vli_mmod_fast_secp256r1+0x17c>
            carry -= uECC_vli_sub(result, result, curve_secp256r1.p, num_words_secp256r1);
        }
    }
}
 8005d7a:	b009      	add	sp, #36	; 0x24
 8005d7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005d7e:	bf00      	nop
 8005d80:	0800e670 	.word	0x0800e670

08005d84 <vli_mmod_fast_secp256k1>:
    uECC_vli_modAdd(result, result, curve->b, curve->p, num_words_secp256k1); /* r = x^3 + b */
}

#if (uECC_OPTIMIZATION_LEVEL > 0)
static void omega_mult_secp256k1(uECC_word_t *result, const uECC_word_t *right);
static void vli_mmod_fast_secp256k1(uECC_word_t *result, uECC_word_t *product) {
 8005d84:	b570      	push	{r4, r5, r6, lr}
 8005d86:	b090      	sub	sp, #64	; 0x40
 8005d88:	460e      	mov	r6, r1
 8005d8a:	4604      	mov	r4, r0
    uECC_word_t tmp[2 * num_words_secp256k1];
    uECC_word_t carry;
    
    uECC_vli_clear(tmp, num_words_secp256k1);
 8005d8c:	2108      	movs	r1, #8
 8005d8e:	4668      	mov	r0, sp
 8005d90:	f7ff fbe8 	bl	8005564 <uECC_vli_clear>
    uECC_vli_clear(tmp + num_words_secp256k1, num_words_secp256k1);
 8005d94:	2108      	movs	r1, #8
 8005d96:	a808      	add	r0, sp, #32
 8005d98:	f7ff fbe4 	bl	8005564 <uECC_vli_clear>
    
    omega_mult_secp256k1(tmp, product + num_words_secp256k1); /* (Rq, q) = q * c */
 8005d9c:	f106 0120 	add.w	r1, r6, #32
 8005da0:	4668      	mov	r0, sp
 8005da2:	f7ff fe37 	bl	8005a14 <omega_mult_secp256k1>
    
    carry = uECC_vli_add(result, product, tmp, num_words_secp256k1); /* (C, r) = r + q       */
 8005da6:	466a      	mov	r2, sp
 8005da8:	4631      	mov	r1, r6
 8005daa:	4620      	mov	r0, r4
 8005dac:	f7ff fdcc 	bl	8005948 <uECC_vli_add.isra.0>
    uECC_vli_clear(product, num_words_secp256k1);
 8005db0:	2108      	movs	r1, #8
    uECC_vli_clear(tmp, num_words_secp256k1);
    uECC_vli_clear(tmp + num_words_secp256k1, num_words_secp256k1);
    
    omega_mult_secp256k1(tmp, product + num_words_secp256k1); /* (Rq, q) = q * c */
    
    carry = uECC_vli_add(result, product, tmp, num_words_secp256k1); /* (C, r) = r + q       */
 8005db2:	4605      	mov	r5, r0
    uECC_vli_clear(product, num_words_secp256k1);
 8005db4:	4630      	mov	r0, r6
 8005db6:	f7ff fbd5 	bl	8005564 <uECC_vli_clear>
    omega_mult_secp256k1(product, tmp + num_words_secp256k1); /* Rq*c */
 8005dba:	a908      	add	r1, sp, #32
 8005dbc:	4630      	mov	r0, r6
 8005dbe:	f7ff fe29 	bl	8005a14 <omega_mult_secp256k1>
    carry += uECC_vli_add(result, result, product, num_words_secp256k1); /* (C1, r) = r + Rq*c */
 8005dc2:	4632      	mov	r2, r6
 8005dc4:	4621      	mov	r1, r4
 8005dc6:	4620      	mov	r0, r4
 8005dc8:	f7ff fdbe 	bl	8005948 <uECC_vli_add.isra.0>
 8005dcc:	4405      	add	r5, r0
    
    while (carry > 0) {
 8005dce:	b135      	cbz	r5, 8005dde <vli_mmod_fast_secp256k1+0x5a>
        --carry;
        uECC_vli_sub(result, result, curve_secp256k1.p, num_words_secp256k1);
 8005dd0:	4a0a      	ldr	r2, [pc, #40]	; (8005dfc <vli_mmod_fast_secp256k1+0x78>)
 8005dd2:	4621      	mov	r1, r4
 8005dd4:	4620      	mov	r0, r4
    uECC_vli_clear(product, num_words_secp256k1);
    omega_mult_secp256k1(product, tmp + num_words_secp256k1); /* Rq*c */
    carry += uECC_vli_add(result, result, product, num_words_secp256k1); /* (C1, r) = r + Rq*c */
    
    while (carry > 0) {
        --carry;
 8005dd6:	3d01      	subs	r5, #1
        uECC_vli_sub(result, result, curve_secp256k1.p, num_words_secp256k1);
 8005dd8:	f7ff fe5f 	bl	8005a9a <uECC_vli_sub.isra.1>
 8005ddc:	e7f7      	b.n	8005dce <vli_mmod_fast_secp256k1+0x4a>
    }
    if (uECC_vli_cmp_unsafe(result, curve_secp256k1.p, num_words_secp256k1) > 0) {
 8005dde:	2208      	movs	r2, #8
 8005de0:	4906      	ldr	r1, [pc, #24]	; (8005dfc <vli_mmod_fast_secp256k1+0x78>)
 8005de2:	4620      	mov	r0, r4
 8005de4:	f7ff fc12 	bl	800560c <uECC_vli_cmp_unsafe>
 8005de8:	2800      	cmp	r0, #0
 8005dea:	dd04      	ble.n	8005df6 <vli_mmod_fast_secp256k1+0x72>
        uECC_vli_sub(result, result, curve_secp256k1.p, num_words_secp256k1);
 8005dec:	4a03      	ldr	r2, [pc, #12]	; (8005dfc <vli_mmod_fast_secp256k1+0x78>)
 8005dee:	4621      	mov	r1, r4
 8005df0:	4620      	mov	r0, r4
 8005df2:	f7ff fe52 	bl	8005a9a <uECC_vli_sub.isra.1>
    }
}
 8005df6:	b010      	add	sp, #64	; 0x40
 8005df8:	bd70      	pop	{r4, r5, r6, pc}
 8005dfa:	bf00      	nop
 8005dfc:	0800e5bc 	.word	0x0800e5bc

08005e00 <bits2int>:
/* -------- ECDSA code -------- */

static void bits2int(uECC_word_t *native,
                     const uint8_t *bits,
                     unsigned bits_size,
                     uECC_Curve curve) {
 8005e00:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    unsigned num_n_bytes = BITS_TO_BYTES(curve->num_n_bits);
 8005e04:	f9b3 5002 	ldrsh.w	r5, [r3, #2]
/* -------- ECDSA code -------- */

static void bits2int(uECC_word_t *native,
                     const uint8_t *bits,
                     unsigned bits_size,
                     uECC_Curve curve) {
 8005e08:	4689      	mov	r9, r1
    unsigned num_n_bytes = BITS_TO_BYTES(curve->num_n_bits);
 8005e0a:	2408      	movs	r4, #8
 8005e0c:	1de9      	adds	r1, r5, #7
    unsigned num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8005e0e:	351f      	adds	r5, #31

static void bits2int(uECC_word_t *native,
                     const uint8_t *bits,
                     unsigned bits_size,
                     uECC_Curve curve) {
    unsigned num_n_bytes = BITS_TO_BYTES(curve->num_n_bits);
 8005e10:	fb91 f4f4 	sdiv	r4, r1, r4
    unsigned num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8005e14:	2120      	movs	r1, #32
 8005e16:	4294      	cmp	r4, r2
 8005e18:	fb95 f5f1 	sdiv	r5, r5, r1
    if (bits_size > num_n_bytes) {
        bits_size = num_n_bytes;
    }
    uECC_vli_clear(native, num_n_words);
 8005e1c:	fa4f f885 	sxtb.w	r8, r5
 8005e20:	bf28      	it	cs
 8005e22:	4614      	movcs	r4, r2
/* -------- ECDSA code -------- */

static void bits2int(uECC_word_t *native,
                     const uint8_t *bits,
                     unsigned bits_size,
                     uECC_Curve curve) {
 8005e24:	461f      	mov	r7, r3
    unsigned num_n_bytes = BITS_TO_BYTES(curve->num_n_bits);
    unsigned num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    if (bits_size > num_n_bytes) {
        bits_size = num_n_bytes;
    }
    uECC_vli_clear(native, num_n_words);
 8005e26:	4641      	mov	r1, r8
/* -------- ECDSA code -------- */

static void bits2int(uECC_word_t *native,
                     const uint8_t *bits,
                     unsigned bits_size,
                     uECC_Curve curve) {
 8005e28:	4606      	mov	r6, r0
    unsigned num_n_bytes = BITS_TO_BYTES(curve->num_n_bits);
    unsigned num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    if (bits_size > num_n_bytes) {
        bits_size = num_n_bytes;
    }
    uECC_vli_clear(native, num_n_words);
 8005e2a:	f7ff fb9b 	bl	8005564 <uECC_vli_clear>
    uECC_vli_bytesToNative(native, bits, bits_size);
 8005e2e:	4622      	mov	r2, r4
 8005e30:	4649      	mov	r1, r9
 8005e32:	f7ff fd00 	bl	8005836 <uECC_vli_bytesToNative>
    if (bits_size * 8 <= (unsigned)curve->num_n_bits) {
 8005e36:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8005e3a:	00e4      	lsls	r4, r4, #3
 8005e3c:	429c      	cmp	r4, r3
 8005e3e:	d91f      	bls.n	8005e80 <bits2int+0x80>
        return;
    }
    int shift = bits_size * 8 - curve->num_n_bits;
 8005e40:	1ae4      	subs	r4, r4, r3
 8005e42:	eb06 0185 	add.w	r1, r6, r5, lsl #2
    uECC_word_t carry = 0;
 8005e46:	2300      	movs	r3, #0
    uECC_word_t *ptr = native + num_n_words;
    while (ptr-- > native) {
        uECC_word_t temp = *ptr;
        *ptr = (temp >> shift) | carry;
        carry = temp << (uECC_WORD_BITS - shift);
 8005e48:	f1c4 0020 	rsb	r0, r4, #32
        return;
    }
    int shift = bits_size * 8 - curve->num_n_bits;
    uECC_word_t carry = 0;
    uECC_word_t *ptr = native + num_n_words;
    while (ptr-- > native) {
 8005e4c:	428e      	cmp	r6, r1
 8005e4e:	d208      	bcs.n	8005e62 <bits2int+0x62>
        uECC_word_t temp = *ptr;
 8005e50:	f851 2d04 	ldr.w	r2, [r1, #-4]!
        *ptr = (temp >> shift) | carry;
 8005e54:	fa22 f504 	lsr.w	r5, r2, r4
 8005e58:	432b      	orrs	r3, r5
 8005e5a:	600b      	str	r3, [r1, #0]
        carry = temp << (uECC_WORD_BITS - shift);
 8005e5c:	fa02 f300 	lsl.w	r3, r2, r0
 8005e60:	e7f4      	b.n	8005e4c <bits2int+0x4c>
    }

    /* Reduce mod curve_n */
    if (uECC_vli_cmp_unsafe(curve->n, native, num_n_words) != 1) {
 8005e62:	3724      	adds	r7, #36	; 0x24
 8005e64:	4642      	mov	r2, r8
 8005e66:	4631      	mov	r1, r6
 8005e68:	4638      	mov	r0, r7
 8005e6a:	f7ff fbcf 	bl	800560c <uECC_vli_cmp_unsafe>
 8005e6e:	2801      	cmp	r0, #1
 8005e70:	d006      	beq.n	8005e80 <bits2int+0x80>
        uECC_vli_sub(native, native, curve->n, num_n_words);
 8005e72:	463a      	mov	r2, r7
 8005e74:	4631      	mov	r1, r6
 8005e76:	4630      	mov	r0, r6
    }
}
 8005e78:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        carry = temp << (uECC_WORD_BITS - shift);
    }

    /* Reduce mod curve_n */
    if (uECC_vli_cmp_unsafe(curve->n, native, num_n_words) != 1) {
        uECC_vli_sub(native, native, curve->n, num_n_words);
 8005e7c:	f7ff be0d 	b.w	8005a9a <uECC_vli_sub.isra.1>
 8005e80:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08005e84 <uECC_vli_modSub.isra.2>:
    }
}

/* Computes result = (left - right) % mod.
   Assumes that left < mod and right < mod, and that result does not overlap mod. */
uECC_VLI_API void uECC_vli_modSub(uECC_word_t *result,
 8005e84:	b538      	push	{r3, r4, r5, lr}
 8005e86:	4604      	mov	r4, r0
 8005e88:	461d      	mov	r5, r3
                                  const uECC_word_t *left,
                                  const uECC_word_t *right,
                                  const uECC_word_t *mod,
                                  wordcount_t num_words) {
    uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
 8005e8a:	f7ff fe06 	bl	8005a9a <uECC_vli_sub.isra.1>
    if (l_borrow) {
 8005e8e:	b130      	cbz	r0, 8005e9e <uECC_vli_modSub.isra.2+0x1a>
        /* In this case, result == -diff == (max int) - diff. Since -x % d == d - x,
           we can get the correct result from result + mod (with overflow). */
        uECC_vli_add(result, result, mod, num_words);
 8005e90:	462a      	mov	r2, r5
 8005e92:	4621      	mov	r1, r4
 8005e94:	4620      	mov	r0, r4
    }
}
 8005e96:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
                                  wordcount_t num_words) {
    uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
    if (l_borrow) {
        /* In this case, result == -diff == (max int) - diff. Since -x % d == d - x,
           we can get the correct result from result + mod (with overflow). */
        uECC_vli_add(result, result, mod, num_words);
 8005e9a:	f7ff bd55 	b.w	8005948 <uECC_vli_add.isra.0>
 8005e9e:	bd38      	pop	{r3, r4, r5, pc}

08005ea0 <double_jacobian_default>:
#if uECC_SUPPORTS_secp160r1 || uECC_SUPPORTS_secp192r1 || \
    uECC_SUPPORTS_secp224r1 || uECC_SUPPORTS_secp256r1
static void double_jacobian_default(uECC_word_t * X1,
                                    uECC_word_t * Y1,
                                    uECC_word_t * Z1,
                                    uECC_Curve curve) {
 8005ea0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    /* t1 = X, t2 = Y, t3 = Z */
    uECC_word_t t4[uECC_MAX_WORDS];
    uECC_word_t t5[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;

    if (uECC_vli_isZero(Z1, num_words)) {
 8005ea4:	f993 6000 	ldrsb.w	r6, [r3]
#if uECC_SUPPORTS_secp160r1 || uECC_SUPPORTS_secp192r1 || \
    uECC_SUPPORTS_secp224r1 || uECC_SUPPORTS_secp256r1
static void double_jacobian_default(uECC_word_t * X1,
                                    uECC_word_t * Y1,
                                    uECC_word_t * Z1,
                                    uECC_Curve curve) {
 8005ea8:	b092      	sub	sp, #72	; 0x48
 8005eaa:	4604      	mov	r4, r0
 8005eac:	4689      	mov	r9, r1
    /* t1 = X, t2 = Y, t3 = Z */
    uECC_word_t t4[uECC_MAX_WORDS];
    uECC_word_t t5[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;

    if (uECC_vli_isZero(Z1, num_words)) {
 8005eae:	4610      	mov	r0, r2
 8005eb0:	4631      	mov	r1, r6
#if uECC_SUPPORTS_secp160r1 || uECC_SUPPORTS_secp192r1 || \
    uECC_SUPPORTS_secp224r1 || uECC_SUPPORTS_secp256r1
static void double_jacobian_default(uECC_word_t * X1,
                                    uECC_word_t * Y1,
                                    uECC_word_t * Z1,
                                    uECC_Curve curve) {
 8005eb2:	4615      	mov	r5, r2
 8005eb4:	4698      	mov	r8, r3
    /* t1 = X, t2 = Y, t3 = Z */
    uECC_word_t t4[uECC_MAX_WORDS];
    uECC_word_t t5[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;

    if (uECC_vli_isZero(Z1, num_words)) {
 8005eb6:	f7ff fb61 	bl	800557c <uECC_vli_isZero>
 8005eba:	2800      	cmp	r0, #0
 8005ebc:	f040 8092 	bne.w	8005fe4 <double_jacobian_default+0x144>
        return;
    }

    uECC_vli_modSquare_fast(t4, Y1, curve);   /* t4 = y1^2 */
 8005ec0:	4642      	mov	r2, r8
 8005ec2:	4649      	mov	r1, r9
 8005ec4:	a802      	add	r0, sp, #8
 8005ec6:	f7ff fc7f 	bl	80057c8 <uECC_vli_modSquare_fast>
    uECC_vli_modMult_fast(t5, X1, t4, curve); /* t5 = x1*y1^2 = A */
 8005eca:	4643      	mov	r3, r8
 8005ecc:	aa02      	add	r2, sp, #8
 8005ece:	4621      	mov	r1, r4
 8005ed0:	a80a      	add	r0, sp, #40	; 0x28
 8005ed2:	f7ff fc69 	bl	80057a8 <uECC_vli_modMult_fast>
    uECC_vli_modSquare_fast(t4, t4, curve);   /* t4 = y1^4 */
 8005ed6:	a902      	add	r1, sp, #8
 8005ed8:	4608      	mov	r0, r1
 8005eda:	4642      	mov	r2, r8
 8005edc:	f7ff fc74 	bl	80057c8 <uECC_vli_modSquare_fast>
    uECC_vli_modMult_fast(Y1, Y1, Z1, curve); /* t2 = y1*z1 = z3 */
 8005ee0:	4643      	mov	r3, r8
 8005ee2:	462a      	mov	r2, r5
 8005ee4:	4649      	mov	r1, r9
 8005ee6:	4648      	mov	r0, r9
 8005ee8:	f7ff fc5e 	bl	80057a8 <uECC_vli_modMult_fast>
    uECC_vli_modSquare_fast(Z1, Z1, curve);   /* t3 = z1^2 */

    uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
 8005eec:	f108 0704 	add.w	r7, r8, #4

    uECC_vli_modSquare_fast(t4, Y1, curve);   /* t4 = y1^2 */
    uECC_vli_modMult_fast(t5, X1, t4, curve); /* t5 = x1*y1^2 = A */
    uECC_vli_modSquare_fast(t4, t4, curve);   /* t4 = y1^4 */
    uECC_vli_modMult_fast(Y1, Y1, Z1, curve); /* t2 = y1*z1 = z3 */
    uECC_vli_modSquare_fast(Z1, Z1, curve);   /* t3 = z1^2 */
 8005ef0:	4642      	mov	r2, r8
 8005ef2:	4629      	mov	r1, r5
 8005ef4:	4628      	mov	r0, r5
 8005ef6:	f7ff fc67 	bl	80057c8 <uECC_vli_modSquare_fast>

    uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
 8005efa:	463b      	mov	r3, r7
 8005efc:	462a      	mov	r2, r5
 8005efe:	4621      	mov	r1, r4
 8005f00:	4620      	mov	r0, r4
 8005f02:	9600      	str	r6, [sp, #0]
 8005f04:	f7ff fe44 	bl	8005b90 <uECC_vli_modAdd>
    uECC_vli_modAdd(Z1, Z1, Z1, curve->p, num_words); /* t3 = 2*z1^2 */
 8005f08:	463b      	mov	r3, r7
 8005f0a:	462a      	mov	r2, r5
 8005f0c:	4629      	mov	r1, r5
 8005f0e:	4628      	mov	r0, r5
 8005f10:	9600      	str	r6, [sp, #0]
 8005f12:	f7ff fe3d 	bl	8005b90 <uECC_vli_modAdd>
    uECC_vli_modSub(Z1, X1, Z1, curve->p, num_words); /* t3 = x1 - z1^2 */
 8005f16:	463b      	mov	r3, r7
 8005f18:	462a      	mov	r2, r5
 8005f1a:	4621      	mov	r1, r4
 8005f1c:	4628      	mov	r0, r5
 8005f1e:	f7ff ffb1 	bl	8005e84 <uECC_vli_modSub.isra.2>
    uECC_vli_modMult_fast(X1, X1, Z1, curve);                /* t1 = x1^2 - z1^4 */
 8005f22:	4643      	mov	r3, r8
 8005f24:	462a      	mov	r2, r5
 8005f26:	4621      	mov	r1, r4
 8005f28:	4620      	mov	r0, r4
 8005f2a:	f7ff fc3d 	bl	80057a8 <uECC_vli_modMult_fast>

    uECC_vli_modAdd(Z1, X1, X1, curve->p, num_words); /* t3 = 2*(x1^2 - z1^4) */
 8005f2e:	463b      	mov	r3, r7
 8005f30:	4622      	mov	r2, r4
 8005f32:	4621      	mov	r1, r4
 8005f34:	4628      	mov	r0, r5
 8005f36:	9600      	str	r6, [sp, #0]
 8005f38:	f7ff fe2a 	bl	8005b90 <uECC_vli_modAdd>
    uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = 3*(x1^2 - z1^4) */
 8005f3c:	463b      	mov	r3, r7
 8005f3e:	9600      	str	r6, [sp, #0]
 8005f40:	462a      	mov	r2, r5
 8005f42:	4621      	mov	r1, r4
 8005f44:	4620      	mov	r0, r4
 8005f46:	f7ff fe23 	bl	8005b90 <uECC_vli_modAdd>
    if (uECC_vli_testBit(X1, 0)) {
 8005f4a:	6823      	ldr	r3, [r4, #0]
 8005f4c:	07db      	lsls	r3, r3, #31
 8005f4e:	d513      	bpl.n	8005f78 <double_jacobian_default+0xd8>
        uECC_word_t l_carry = uECC_vli_add(X1, X1, curve->p, num_words);
 8005f50:	463a      	mov	r2, r7
 8005f52:	4621      	mov	r1, r4
 8005f54:	4620      	mov	r0, r4
 8005f56:	f7ff fcf7 	bl	8005948 <uECC_vli_add.isra.0>
        uECC_vli_rshift1(X1, num_words);
 8005f5a:	4631      	mov	r1, r6
    uECC_vli_modMult_fast(X1, X1, Z1, curve);                /* t1 = x1^2 - z1^4 */

    uECC_vli_modAdd(Z1, X1, X1, curve->p, num_words); /* t3 = 2*(x1^2 - z1^4) */
    uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = 3*(x1^2 - z1^4) */
    if (uECC_vli_testBit(X1, 0)) {
        uECC_word_t l_carry = uECC_vli_add(X1, X1, curve->p, num_words);
 8005f5c:	4682      	mov	sl, r0
        uECC_vli_rshift1(X1, num_words);
 8005f5e:	4620      	mov	r0, r4
 8005f60:	f7ff fb69 	bl	8005636 <uECC_vli_rshift1>
        X1[num_words - 1] |= l_carry << (uECC_WORD_BITS - 1);
 8005f64:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
 8005f68:	3b01      	subs	r3, #1
 8005f6a:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
 8005f6e:	ea40 70ca 	orr.w	r0, r0, sl, lsl #31
 8005f72:	f844 0023 	str.w	r0, [r4, r3, lsl #2]
 8005f76:	e003      	b.n	8005f80 <double_jacobian_default+0xe0>
    } else {
        uECC_vli_rshift1(X1, num_words);
 8005f78:	4631      	mov	r1, r6
 8005f7a:	4620      	mov	r0, r4
 8005f7c:	f7ff fb5b 	bl	8005636 <uECC_vli_rshift1>
    }
    /* t1 = 3/2*(x1^2 - z1^4) = B */

    uECC_vli_modSquare_fast(Z1, X1, curve);                  /* t3 = B^2 */
 8005f80:	4642      	mov	r2, r8
 8005f82:	4621      	mov	r1, r4
 8005f84:	4628      	mov	r0, r5
 8005f86:	f7ff fc1f 	bl	80057c8 <uECC_vli_modSquare_fast>
    uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - A */
 8005f8a:	463b      	mov	r3, r7
 8005f8c:	aa0a      	add	r2, sp, #40	; 0x28
 8005f8e:	4629      	mov	r1, r5
 8005f90:	4628      	mov	r0, r5
 8005f92:	f7ff ff77 	bl	8005e84 <uECC_vli_modSub.isra.2>
    uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - 2A = x3 */
 8005f96:	463b      	mov	r3, r7
 8005f98:	aa0a      	add	r2, sp, #40	; 0x28
 8005f9a:	4629      	mov	r1, r5
 8005f9c:	4628      	mov	r0, r5
 8005f9e:	f7ff ff71 	bl	8005e84 <uECC_vli_modSub.isra.2>
    uECC_vli_modSub(t5, t5, Z1, curve->p, num_words); /* t5 = A - x3 */
 8005fa2:	a90a      	add	r1, sp, #40	; 0x28
 8005fa4:	4608      	mov	r0, r1
 8005fa6:	463b      	mov	r3, r7
 8005fa8:	462a      	mov	r2, r5
 8005faa:	f7ff ff6b 	bl	8005e84 <uECC_vli_modSub.isra.2>
    uECC_vli_modMult_fast(X1, X1, t5, curve);                /* t1 = B * (A - x3) */
 8005fae:	4643      	mov	r3, r8
 8005fb0:	aa0a      	add	r2, sp, #40	; 0x28
 8005fb2:	4621      	mov	r1, r4
 8005fb4:	4620      	mov	r0, r4
 8005fb6:	f7ff fbf7 	bl	80057a8 <uECC_vli_modMult_fast>
    uECC_vli_modSub(t4, X1, t4, curve->p, num_words); /* t4 = B * (A - x3) - y1^4 = y3 */
 8005fba:	aa02      	add	r2, sp, #8
 8005fbc:	463b      	mov	r3, r7
 8005fbe:	4610      	mov	r0, r2
 8005fc0:	4621      	mov	r1, r4
 8005fc2:	f7ff ff5f 	bl	8005e84 <uECC_vli_modSub.isra.2>

    uECC_vli_set(X1, Z1, num_words);
 8005fc6:	4632      	mov	r2, r6
 8005fc8:	4629      	mov	r1, r5
 8005fca:	4620      	mov	r0, r4
 8005fcc:	f7ff fb11 	bl	80055f2 <uECC_vli_set>
    uECC_vli_set(Z1, Y1, num_words);
 8005fd0:	4632      	mov	r2, r6
 8005fd2:	4649      	mov	r1, r9
 8005fd4:	4628      	mov	r0, r5
 8005fd6:	f7ff fb0c 	bl	80055f2 <uECC_vli_set>
    uECC_vli_set(Y1, t4, num_words);
 8005fda:	4632      	mov	r2, r6
 8005fdc:	a902      	add	r1, sp, #8
 8005fde:	4648      	mov	r0, r9
 8005fe0:	f7ff fb07 	bl	80055f2 <uECC_vli_set>
}
 8005fe4:	b012      	add	sp, #72	; 0x48
 8005fe6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08005fea <x_side_default>:

/* Computes result = x^3 + ax + b. result must not overlap x. */
static void x_side_default(uECC_word_t *result, const uECC_word_t *x, uECC_Curve curve) {
 8005fea:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005fee:	4615      	mov	r5, r2
 8005ff0:	b08a      	sub	sp, #40	; 0x28
 8005ff2:	4604      	mov	r4, r0
 8005ff4:	4688      	mov	r8, r1
    uECC_word_t _3[uECC_MAX_WORDS] = {3}; /* -a = 3 */
 8005ff6:	2220      	movs	r2, #32
 8005ff8:	2100      	movs	r1, #0
 8005ffa:	a802      	add	r0, sp, #8
 8005ffc:	f007 fa63 	bl	800d4c6 <memset>
    wordcount_t num_words = curve->num_words;

    uECC_vli_modSquare_fast(result, x, curve);                             /* r = x^2 */
    uECC_vli_modSub(result, result, _3, curve->p, num_words);       /* r = x^2 - 3 */
 8006000:	1d2f      	adds	r7, r5, #4
    uECC_vli_set(Y1, t4, num_words);
}

/* Computes result = x^3 + ax + b. result must not overlap x. */
static void x_side_default(uECC_word_t *result, const uECC_word_t *x, uECC_Curve curve) {
    uECC_word_t _3[uECC_MAX_WORDS] = {3}; /* -a = 3 */
 8006002:	2303      	movs	r3, #3
    wordcount_t num_words = curve->num_words;
 8006004:	782e      	ldrb	r6, [r5, #0]
    uECC_vli_set(Y1, t4, num_words);
}

/* Computes result = x^3 + ax + b. result must not overlap x. */
static void x_side_default(uECC_word_t *result, const uECC_word_t *x, uECC_Curve curve) {
    uECC_word_t _3[uECC_MAX_WORDS] = {3}; /* -a = 3 */
 8006006:	9302      	str	r3, [sp, #8]
    wordcount_t num_words = curve->num_words;

    uECC_vli_modSquare_fast(result, x, curve);                             /* r = x^2 */
 8006008:	462a      	mov	r2, r5
 800600a:	4641      	mov	r1, r8
 800600c:	4620      	mov	r0, r4
 800600e:	f7ff fbdb 	bl	80057c8 <uECC_vli_modSquare_fast>
    uECC_vli_modSub(result, result, _3, curve->p, num_words);       /* r = x^2 - 3 */
 8006012:	463b      	mov	r3, r7
 8006014:	aa02      	add	r2, sp, #8
 8006016:	4621      	mov	r1, r4
 8006018:	4620      	mov	r0, r4
 800601a:	f7ff ff33 	bl	8005e84 <uECC_vli_modSub.isra.2>
    uECC_vli_modMult_fast(result, result, x, curve);                       /* r = x^3 - 3x */
    uECC_vli_modAdd(result, result, curve->b, curve->p, num_words); /* r = x^3 - 3x + b */
 800601e:	b276      	sxtb	r6, r6
    uECC_word_t _3[uECC_MAX_WORDS] = {3}; /* -a = 3 */
    wordcount_t num_words = curve->num_words;

    uECC_vli_modSquare_fast(result, x, curve);                             /* r = x^2 */
    uECC_vli_modSub(result, result, _3, curve->p, num_words);       /* r = x^2 - 3 */
    uECC_vli_modMult_fast(result, result, x, curve);                       /* r = x^3 - 3x */
 8006020:	462b      	mov	r3, r5
 8006022:	4642      	mov	r2, r8
 8006024:	4621      	mov	r1, r4
 8006026:	4620      	mov	r0, r4
 8006028:	f7ff fbbe 	bl	80057a8 <uECC_vli_modMult_fast>
    uECC_vli_modAdd(result, result, curve->b, curve->p, num_words); /* r = x^3 - 3x + b */
 800602c:	9600      	str	r6, [sp, #0]
 800602e:	463b      	mov	r3, r7
 8006030:	f105 0284 	add.w	r2, r5, #132	; 0x84
 8006034:	4621      	mov	r1, r4
 8006036:	4620      	mov	r0, r4
 8006038:	f7ff fdaa 	bl	8005b90 <uECC_vli_modAdd>
}
 800603c:	b00a      	add	sp, #40	; 0x28
 800603e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08006042 <XYcZ_add>:
*/
static void XYcZ_add(uECC_word_t * X1,
                     uECC_word_t * Y1,
                     uECC_word_t * X2,
                     uECC_word_t * Y2,
                     uECC_Curve curve) {
 8006042:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8006046:	b089      	sub	sp, #36	; 0x24
 8006048:	4614      	mov	r4, r2
    /* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
    uECC_word_t t5[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;
 800604a:	9d10      	ldr	r5, [sp, #64]	; 0x40
 800604c:	f815 9b04 	ldrb.w	r9, [r5], #4
*/
static void XYcZ_add(uECC_word_t * X1,
                     uECC_word_t * Y1,
                     uECC_word_t * X2,
                     uECC_word_t * Y2,
                     uECC_Curve curve) {
 8006050:	461e      	mov	r6, r3
 8006052:	4607      	mov	r7, r0
 8006054:	4688      	mov	r8, r1
    /* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
    uECC_word_t t5[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;
    
    uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
 8006056:	462b      	mov	r3, r5
 8006058:	4602      	mov	r2, r0
 800605a:	4621      	mov	r1, r4
 800605c:	4668      	mov	r0, sp
 800605e:	f7ff ff11 	bl	8005e84 <uECC_vli_modSub.isra.2>
    uECC_vli_modSquare_fast(t5, t5, curve);                  /* t5 = (x2 - x1)^2 = A */
 8006062:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8006064:	4669      	mov	r1, sp
 8006066:	4668      	mov	r0, sp
 8006068:	f7ff fbae 	bl	80057c8 <uECC_vli_modSquare_fast>
    uECC_vli_modMult_fast(X1, X1, t5, curve);                /* t1 = x1*A = B */
 800606c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800606e:	466a      	mov	r2, sp
 8006070:	4639      	mov	r1, r7
 8006072:	4638      	mov	r0, r7
 8006074:	f7ff fb98 	bl	80057a8 <uECC_vli_modMult_fast>
    uECC_vli_modMult_fast(X2, X2, t5, curve);                /* t3 = x2*A = C */
 8006078:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800607a:	466a      	mov	r2, sp
 800607c:	4621      	mov	r1, r4
 800607e:	4620      	mov	r0, r4
 8006080:	f7ff fb92 	bl	80057a8 <uECC_vli_modMult_fast>
    uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
 8006084:	462b      	mov	r3, r5
 8006086:	4642      	mov	r2, r8
 8006088:	4631      	mov	r1, r6
 800608a:	4630      	mov	r0, r6
 800608c:	f7ff fefa 	bl	8005e84 <uECC_vli_modSub.isra.2>
    uECC_vli_modSquare_fast(t5, Y2, curve);                  /* t5 = (y2 - y1)^2 = D */
 8006090:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8006092:	4631      	mov	r1, r6
 8006094:	4668      	mov	r0, sp
 8006096:	f7ff fb97 	bl	80057c8 <uECC_vli_modSquare_fast>
                                                        
    uECC_vli_modSub(t5, t5, X1, curve->p, num_words); /* t5 = D - B */
 800609a:	462b      	mov	r3, r5
 800609c:	463a      	mov	r2, r7
 800609e:	4669      	mov	r1, sp
 80060a0:	4668      	mov	r0, sp
 80060a2:	f7ff feef 	bl	8005e84 <uECC_vli_modSub.isra.2>
    uECC_vli_modSub(t5, t5, X2, curve->p, num_words); /* t5 = D - B - C = x3 */
 80060a6:	462b      	mov	r3, r5
 80060a8:	4622      	mov	r2, r4
 80060aa:	4669      	mov	r1, sp
 80060ac:	4668      	mov	r0, sp
 80060ae:	f7ff fee9 	bl	8005e84 <uECC_vli_modSub.isra.2>
    uECC_vli_modSub(X2, X2, X1, curve->p, num_words); /* t3 = C - B */
 80060b2:	462b      	mov	r3, r5
 80060b4:	463a      	mov	r2, r7
 80060b6:	4621      	mov	r1, r4
 80060b8:	4620      	mov	r0, r4
 80060ba:	f7ff fee3 	bl	8005e84 <uECC_vli_modSub.isra.2>
    uECC_vli_modMult_fast(Y1, Y1, X2, curve);                /* t2 = y1*(C - B) */
 80060be:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80060c0:	4622      	mov	r2, r4
 80060c2:	4641      	mov	r1, r8
 80060c4:	4640      	mov	r0, r8
 80060c6:	f7ff fb6f 	bl	80057a8 <uECC_vli_modMult_fast>
    uECC_vli_modSub(X2, X1, t5, curve->p, num_words); /* t3 = B - x3 */
 80060ca:	462b      	mov	r3, r5
 80060cc:	466a      	mov	r2, sp
 80060ce:	4639      	mov	r1, r7
 80060d0:	4620      	mov	r0, r4
 80060d2:	f7ff fed7 	bl	8005e84 <uECC_vli_modSub.isra.2>
    uECC_vli_modMult_fast(Y2, Y2, X2, curve);                /* t4 = (y2 - y1)*(B - x3) */
 80060d6:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80060d8:	4622      	mov	r2, r4
 80060da:	4631      	mov	r1, r6
 80060dc:	4630      	mov	r0, r6
 80060de:	f7ff fb63 	bl	80057a8 <uECC_vli_modMult_fast>
    uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y3 */
 80060e2:	462b      	mov	r3, r5
 80060e4:	4642      	mov	r2, r8
 80060e6:	4631      	mov	r1, r6
 80060e8:	4630      	mov	r0, r6
 80060ea:	f7ff fecb 	bl	8005e84 <uECC_vli_modSub.isra.2>
    
    uECC_vli_set(X2, t5, num_words);
 80060ee:	fa4f f289 	sxtb.w	r2, r9
 80060f2:	4669      	mov	r1, sp
 80060f4:	4620      	mov	r0, r4
 80060f6:	f7ff fa7c 	bl	80055f2 <uECC_vli_set>
}
 80060fa:	b009      	add	sp, #36	; 0x24
 80060fc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08006100 <XYcZ_addC>:
*/
static void XYcZ_addC(uECC_word_t * X1,
                      uECC_word_t * Y1,
                      uECC_word_t * X2,
                      uECC_word_t * Y2,
                      uECC_Curve curve) {
 8006100:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8006104:	b09b      	sub	sp, #108	; 0x6c
 8006106:	4615      	mov	r5, r2
    /* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
    uECC_word_t t5[uECC_MAX_WORDS];
    uECC_word_t t6[uECC_MAX_WORDS];
    uECC_word_t t7[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;
 8006108:	9c22      	ldr	r4, [sp, #136]	; 0x88
 800610a:	f814 9b04 	ldrb.w	r9, [r4], #4
*/
static void XYcZ_addC(uECC_word_t * X1,
                      uECC_word_t * Y1,
                      uECC_word_t * X2,
                      uECC_word_t * Y2,
                      uECC_Curve curve) {
 800610e:	461f      	mov	r7, r3
 8006110:	4606      	mov	r6, r0
 8006112:	4688      	mov	r8, r1
    uECC_word_t t5[uECC_MAX_WORDS];
    uECC_word_t t6[uECC_MAX_WORDS];
    uECC_word_t t7[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;
    
    uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
 8006114:	4623      	mov	r3, r4
 8006116:	4602      	mov	r2, r0
 8006118:	4629      	mov	r1, r5
 800611a:	a802      	add	r0, sp, #8
 800611c:	f7ff feb2 	bl	8005e84 <uECC_vli_modSub.isra.2>
    uECC_vli_modSquare_fast(t5, t5, curve);                  /* t5 = (x2 - x1)^2 = A */
 8006120:	a902      	add	r1, sp, #8
 8006122:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8006124:	4608      	mov	r0, r1
 8006126:	f7ff fb4f 	bl	80057c8 <uECC_vli_modSquare_fast>
    uECC_vli_modMult_fast(X1, X1, t5, curve);                /* t1 = x1*A = B */
 800612a:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800612c:	aa02      	add	r2, sp, #8
 800612e:	4631      	mov	r1, r6
 8006130:	4630      	mov	r0, r6
 8006132:	f7ff fb39 	bl	80057a8 <uECC_vli_modMult_fast>
    uECC_vli_modMult_fast(X2, X2, t5, curve);                /* t3 = x2*A = C */
    uECC_vli_modAdd(t5, Y2, Y1, curve->p, num_words); /* t5 = y2 + y1 */
 8006136:	fa4f f989 	sxtb.w	r9, r9
    wordcount_t num_words = curve->num_words;
    
    uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
    uECC_vli_modSquare_fast(t5, t5, curve);                  /* t5 = (x2 - x1)^2 = A */
    uECC_vli_modMult_fast(X1, X1, t5, curve);                /* t1 = x1*A = B */
    uECC_vli_modMult_fast(X2, X2, t5, curve);                /* t3 = x2*A = C */
 800613a:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800613c:	aa02      	add	r2, sp, #8
 800613e:	4629      	mov	r1, r5
 8006140:	4628      	mov	r0, r5
 8006142:	f7ff fb31 	bl	80057a8 <uECC_vli_modMult_fast>
    uECC_vli_modAdd(t5, Y2, Y1, curve->p, num_words); /* t5 = y2 + y1 */
 8006146:	4623      	mov	r3, r4
 8006148:	4642      	mov	r2, r8
 800614a:	4639      	mov	r1, r7
 800614c:	a802      	add	r0, sp, #8
 800614e:	f8cd 9000 	str.w	r9, [sp]
 8006152:	f7ff fd1d 	bl	8005b90 <uECC_vli_modAdd>
    uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
 8006156:	4623      	mov	r3, r4
 8006158:	4642      	mov	r2, r8
 800615a:	4639      	mov	r1, r7
 800615c:	4638      	mov	r0, r7
 800615e:	f7ff fe91 	bl	8005e84 <uECC_vli_modSub.isra.2>
                                                        
    uECC_vli_modSub(t6, X2, X1, curve->p, num_words); /* t6 = C - B */
 8006162:	4623      	mov	r3, r4
 8006164:	4632      	mov	r2, r6
 8006166:	4629      	mov	r1, r5
 8006168:	a80a      	add	r0, sp, #40	; 0x28
 800616a:	f7ff fe8b 	bl	8005e84 <uECC_vli_modSub.isra.2>
    uECC_vli_modMult_fast(Y1, Y1, t6, curve);                /* t2 = y1 * (C - B) = E */
 800616e:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8006170:	aa0a      	add	r2, sp, #40	; 0x28
 8006172:	4641      	mov	r1, r8
 8006174:	4640      	mov	r0, r8
 8006176:	f7ff fb17 	bl	80057a8 <uECC_vli_modMult_fast>
    uECC_vli_modAdd(t6, X1, X2, curve->p, num_words); /* t6 = B + C */
 800617a:	4623      	mov	r3, r4
 800617c:	462a      	mov	r2, r5
 800617e:	4631      	mov	r1, r6
 8006180:	a80a      	add	r0, sp, #40	; 0x28
 8006182:	f8cd 9000 	str.w	r9, [sp]
 8006186:	f7ff fd03 	bl	8005b90 <uECC_vli_modAdd>
    uECC_vli_modSquare_fast(X2, Y2, curve);                  /* t3 = (y2 - y1)^2 = D */
 800618a:	9a22      	ldr	r2, [sp, #136]	; 0x88
 800618c:	4639      	mov	r1, r7
 800618e:	4628      	mov	r0, r5
 8006190:	f7ff fb1a 	bl	80057c8 <uECC_vli_modSquare_fast>
    uECC_vli_modSub(X2, X2, t6, curve->p, num_words); /* t3 = D - (B + C) = x3 */
 8006194:	4623      	mov	r3, r4
 8006196:	aa0a      	add	r2, sp, #40	; 0x28
 8006198:	4629      	mov	r1, r5
 800619a:	4628      	mov	r0, r5
 800619c:	f7ff fe72 	bl	8005e84 <uECC_vli_modSub.isra.2>
                                                        
    uECC_vli_modSub(t7, X1, X2, curve->p, num_words); /* t7 = B - x3 */
 80061a0:	4623      	mov	r3, r4
 80061a2:	462a      	mov	r2, r5
 80061a4:	4631      	mov	r1, r6
 80061a6:	a812      	add	r0, sp, #72	; 0x48
 80061a8:	f7ff fe6c 	bl	8005e84 <uECC_vli_modSub.isra.2>
    uECC_vli_modMult_fast(Y2, Y2, t7, curve);                /* t4 = (y2 - y1)*(B - x3) */
 80061ac:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80061ae:	aa12      	add	r2, sp, #72	; 0x48
 80061b0:	4639      	mov	r1, r7
 80061b2:	4638      	mov	r0, r7
 80061b4:	f7ff faf8 	bl	80057a8 <uECC_vli_modMult_fast>
    uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = (y2 - y1)*(B - x3) - E = y3 */
 80061b8:	4623      	mov	r3, r4
 80061ba:	4642      	mov	r2, r8
 80061bc:	4639      	mov	r1, r7
 80061be:	4638      	mov	r0, r7
 80061c0:	f7ff fe60 	bl	8005e84 <uECC_vli_modSub.isra.2>
                                                        
    uECC_vli_modSquare_fast(t7, t5, curve);                  /* t7 = (y2 + y1)^2 = F */
 80061c4:	9a22      	ldr	r2, [sp, #136]	; 0x88
 80061c6:	a902      	add	r1, sp, #8
 80061c8:	a812      	add	r0, sp, #72	; 0x48
 80061ca:	f7ff fafd 	bl	80057c8 <uECC_vli_modSquare_fast>
    uECC_vli_modSub(t7, t7, t6, curve->p, num_words); /* t7 = F - (B + C) = x3' */
 80061ce:	a912      	add	r1, sp, #72	; 0x48
 80061d0:	4623      	mov	r3, r4
 80061d2:	aa0a      	add	r2, sp, #40	; 0x28
 80061d4:	4608      	mov	r0, r1
 80061d6:	f7ff fe55 	bl	8005e84 <uECC_vli_modSub.isra.2>
    uECC_vli_modSub(t6, t7, X1, curve->p, num_words); /* t6 = x3' - B */
 80061da:	4623      	mov	r3, r4
 80061dc:	4632      	mov	r2, r6
 80061de:	a912      	add	r1, sp, #72	; 0x48
 80061e0:	a80a      	add	r0, sp, #40	; 0x28
 80061e2:	f7ff fe4f 	bl	8005e84 <uECC_vli_modSub.isra.2>
    uECC_vli_modMult_fast(t6, t6, t5, curve);                /* t6 = (y2+y1)*(x3' - B) */
 80061e6:	a90a      	add	r1, sp, #40	; 0x28
 80061e8:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80061ea:	aa02      	add	r2, sp, #8
 80061ec:	4608      	mov	r0, r1
 80061ee:	f7ff fadb 	bl	80057a8 <uECC_vli_modMult_fast>
    uECC_vli_modSub(Y1, t6, Y1, curve->p, num_words); /* t2 = (y2+y1)*(x3' - B) - E = y3' */
 80061f2:	4623      	mov	r3, r4
 80061f4:	4642      	mov	r2, r8
 80061f6:	a90a      	add	r1, sp, #40	; 0x28
 80061f8:	4640      	mov	r0, r8
 80061fa:	f7ff fe43 	bl	8005e84 <uECC_vli_modSub.isra.2>
    
    uECC_vli_set(X1, t7, num_words);
 80061fe:	464a      	mov	r2, r9
 8006200:	a912      	add	r1, sp, #72	; 0x48
 8006202:	4630      	mov	r0, r6
 8006204:	f7ff f9f5 	bl	80055f2 <uECC_vli_set>
}
 8006208:	b01b      	add	sp, #108	; 0x6c
 800620a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800620e <vli_modInv_update>:
#define EVEN(vli) (!(vli[0] & 1))
static void vli_modInv_update(uECC_word_t *uv,
                              const uECC_word_t *mod,
                              wordcount_t num_words) {
    uECC_word_t carry = 0;
    if (!EVEN(uv)) {
 800620e:	6803      	ldr	r3, [r0, #0]
#endif /* uECC_SQUARE_FUNC */

#define EVEN(vli) (!(vli[0] & 1))
static void vli_modInv_update(uECC_word_t *uv,
                              const uECC_word_t *mod,
                              wordcount_t num_words) {
 8006210:	b570      	push	{r4, r5, r6, lr}
    uECC_word_t carry = 0;
    if (!EVEN(uv)) {
 8006212:	f013 0501 	ands.w	r5, r3, #1
#endif /* uECC_SQUARE_FUNC */

#define EVEN(vli) (!(vli[0] & 1))
static void vli_modInv_update(uECC_word_t *uv,
                              const uECC_word_t *mod,
                              wordcount_t num_words) {
 8006216:	4606      	mov	r6, r0
 8006218:	4614      	mov	r4, r2
    uECC_word_t carry = 0;
    if (!EVEN(uv)) {
 800621a:	d004      	beq.n	8006226 <vli_modInv_update+0x18>
        carry = uECC_vli_add(uv, uv, mod, num_words);
 800621c:	460a      	mov	r2, r1
 800621e:	4601      	mov	r1, r0
 8006220:	f7ff fb92 	bl	8005948 <uECC_vli_add.isra.0>
 8006224:	4605      	mov	r5, r0
    }
    uECC_vli_rshift1(uv, num_words);
 8006226:	4621      	mov	r1, r4
 8006228:	4630      	mov	r0, r6
 800622a:	f7ff fa04 	bl	8005636 <uECC_vli_rshift1>
    if (carry) {
 800622e:	b145      	cbz	r5, 8006242 <vli_modInv_update+0x34>
        uv[num_words - 1] |= HIGH_BIT_SET;
 8006230:	f104 4280 	add.w	r2, r4, #1073741824	; 0x40000000
 8006234:	3a01      	subs	r2, #1
 8006236:	f856 3022 	ldr.w	r3, [r6, r2, lsl #2]
 800623a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800623e:	f846 3022 	str.w	r3, [r6, r2, lsl #2]
 8006242:	bd70      	pop	{r4, r5, r6, pc}

08006244 <uECC_vli_modInv>:
/* Computes result = (1 / input) % mod. All VLIs are the same size.
   See "From Euclid's GCD to Montgomery Multiplication to the Great Divide" */
uECC_VLI_API void uECC_vli_modInv(uECC_word_t *result,
                                  const uECC_word_t *input,
                                  const uECC_word_t *mod,
                                  wordcount_t num_words) {
 8006244:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006246:	460f      	mov	r7, r1
 8006248:	b0a1      	sub	sp, #132	; 0x84
 800624a:	4606      	mov	r6, r0
    uECC_word_t a[uECC_MAX_WORDS], b[uECC_MAX_WORDS], u[uECC_MAX_WORDS], v[uECC_MAX_WORDS];
    cmpresult_t cmpResult;
    
    if (uECC_vli_isZero(input, num_words)) {
 800624c:	4619      	mov	r1, r3
 800624e:	4638      	mov	r0, r7
/* Computes result = (1 / input) % mod. All VLIs are the same size.
   See "From Euclid's GCD to Montgomery Multiplication to the Great Divide" */
uECC_VLI_API void uECC_vli_modInv(uECC_word_t *result,
                                  const uECC_word_t *input,
                                  const uECC_word_t *mod,
                                  wordcount_t num_words) {
 8006250:	4615      	mov	r5, r2
 8006252:	461c      	mov	r4, r3
    uECC_word_t a[uECC_MAX_WORDS], b[uECC_MAX_WORDS], u[uECC_MAX_WORDS], v[uECC_MAX_WORDS];
    cmpresult_t cmpResult;
    
    if (uECC_vli_isZero(input, num_words)) {
 8006254:	f7ff f992 	bl	800557c <uECC_vli_isZero>
 8006258:	b120      	cbz	r0, 8006264 <uECC_vli_modInv+0x20>
        uECC_vli_clear(result, num_words);
 800625a:	4621      	mov	r1, r4
 800625c:	4630      	mov	r0, r6
 800625e:	f7ff f981 	bl	8005564 <uECC_vli_clear>
 8006262:	e06f      	b.n	8006344 <uECC_vli_modInv+0x100>
        return;
    }

    uECC_vli_set(a, input, num_words);
 8006264:	4622      	mov	r2, r4
 8006266:	4639      	mov	r1, r7
 8006268:	4668      	mov	r0, sp
 800626a:	f7ff f9c2 	bl	80055f2 <uECC_vli_set>
    uECC_vli_set(b, mod, num_words);
 800626e:	4622      	mov	r2, r4
 8006270:	4629      	mov	r1, r5
 8006272:	a808      	add	r0, sp, #32
 8006274:	f7ff f9bd 	bl	80055f2 <uECC_vli_set>
    uECC_vli_clear(u, num_words);
 8006278:	4621      	mov	r1, r4
 800627a:	a810      	add	r0, sp, #64	; 0x40
 800627c:	f7ff f972 	bl	8005564 <uECC_vli_clear>
    u[0] = 1;
 8006280:	2301      	movs	r3, #1
    uECC_vli_clear(v, num_words);
 8006282:	4621      	mov	r1, r4
 8006284:	a818      	add	r0, sp, #96	; 0x60
    }

    uECC_vli_set(a, input, num_words);
    uECC_vli_set(b, mod, num_words);
    uECC_vli_clear(u, num_words);
    u[0] = 1;
 8006286:	9310      	str	r3, [sp, #64]	; 0x40
    uECC_vli_clear(v, num_words);
 8006288:	f7ff f96c 	bl	8005564 <uECC_vli_clear>
    while ((cmpResult = uECC_vli_cmp_unsafe(a, b, num_words)) != 0) {
 800628c:	4622      	mov	r2, r4
 800628e:	a908      	add	r1, sp, #32
 8006290:	4668      	mov	r0, sp
 8006292:	f7ff f9bb 	bl	800560c <uECC_vli_cmp_unsafe>
 8006296:	2800      	cmp	r0, #0
 8006298:	d04f      	beq.n	800633a <uECC_vli_modInv+0xf6>
        if (EVEN(a)) {
 800629a:	9b00      	ldr	r3, [sp, #0]
 800629c:	07da      	lsls	r2, r3, #31
 800629e:	d404      	bmi.n	80062aa <uECC_vli_modInv+0x66>
            uECC_vli_rshift1(a, num_words);
 80062a0:	4621      	mov	r1, r4
 80062a2:	4668      	mov	r0, sp
 80062a4:	f7ff f9c7 	bl	8005636 <uECC_vli_rshift1>
 80062a8:	e023      	b.n	80062f2 <uECC_vli_modInv+0xae>
            vli_modInv_update(u, mod, num_words);
        } else if (EVEN(b)) {
 80062aa:	9b08      	ldr	r3, [sp, #32]
 80062ac:	07db      	lsls	r3, r3, #31
 80062ae:	d404      	bmi.n	80062ba <uECC_vli_modInv+0x76>
            uECC_vli_rshift1(b, num_words);
 80062b0:	4621      	mov	r1, r4
 80062b2:	a808      	add	r0, sp, #32
 80062b4:	f7ff f9bf 	bl	8005636 <uECC_vli_rshift1>
 80062b8:	e039      	b.n	800632e <uECC_vli_modInv+0xea>
            vli_modInv_update(v, mod, num_words);
        } else if (cmpResult > 0) {
 80062ba:	2800      	cmp	r0, #0
 80062bc:	dd1d      	ble.n	80062fa <uECC_vli_modInv+0xb6>
            uECC_vli_sub(a, a, b, num_words);
 80062be:	aa08      	add	r2, sp, #32
 80062c0:	4669      	mov	r1, sp
 80062c2:	4668      	mov	r0, sp
 80062c4:	f7ff fbe9 	bl	8005a9a <uECC_vli_sub.isra.1>
            uECC_vli_rshift1(a, num_words);
 80062c8:	4621      	mov	r1, r4
 80062ca:	4668      	mov	r0, sp
 80062cc:	f7ff f9b3 	bl	8005636 <uECC_vli_rshift1>
            if (uECC_vli_cmp_unsafe(u, v, num_words) < 0) {
 80062d0:	4622      	mov	r2, r4
 80062d2:	a918      	add	r1, sp, #96	; 0x60
 80062d4:	a810      	add	r0, sp, #64	; 0x40
 80062d6:	f7ff f999 	bl	800560c <uECC_vli_cmp_unsafe>
 80062da:	2800      	cmp	r0, #0
 80062dc:	da04      	bge.n	80062e8 <uECC_vli_modInv+0xa4>
                uECC_vli_add(u, u, mod, num_words);
 80062de:	a910      	add	r1, sp, #64	; 0x40
 80062e0:	462a      	mov	r2, r5
 80062e2:	4608      	mov	r0, r1
 80062e4:	f7ff fb30 	bl	8005948 <uECC_vli_add.isra.0>
            }
            uECC_vli_sub(u, u, v, num_words);
 80062e8:	a910      	add	r1, sp, #64	; 0x40
 80062ea:	aa18      	add	r2, sp, #96	; 0x60
 80062ec:	4608      	mov	r0, r1
 80062ee:	f7ff fbd4 	bl	8005a9a <uECC_vli_sub.isra.1>
            vli_modInv_update(u, mod, num_words);
 80062f2:	4622      	mov	r2, r4
 80062f4:	4629      	mov	r1, r5
 80062f6:	a810      	add	r0, sp, #64	; 0x40
 80062f8:	e01c      	b.n	8006334 <uECC_vli_modInv+0xf0>
        } else {
            uECC_vli_sub(b, b, a, num_words);
 80062fa:	a908      	add	r1, sp, #32
 80062fc:	466a      	mov	r2, sp
 80062fe:	4608      	mov	r0, r1
 8006300:	f7ff fbcb 	bl	8005a9a <uECC_vli_sub.isra.1>
            uECC_vli_rshift1(b, num_words);
 8006304:	4621      	mov	r1, r4
 8006306:	a808      	add	r0, sp, #32
 8006308:	f7ff f995 	bl	8005636 <uECC_vli_rshift1>
            if (uECC_vli_cmp_unsafe(v, u, num_words) < 0) {
 800630c:	4622      	mov	r2, r4
 800630e:	a910      	add	r1, sp, #64	; 0x40
 8006310:	a818      	add	r0, sp, #96	; 0x60
 8006312:	f7ff f97b 	bl	800560c <uECC_vli_cmp_unsafe>
 8006316:	2800      	cmp	r0, #0
 8006318:	da04      	bge.n	8006324 <uECC_vli_modInv+0xe0>
                uECC_vli_add(v, v, mod, num_words);
 800631a:	a918      	add	r1, sp, #96	; 0x60
 800631c:	462a      	mov	r2, r5
 800631e:	4608      	mov	r0, r1
 8006320:	f7ff fb12 	bl	8005948 <uECC_vli_add.isra.0>
            }
            uECC_vli_sub(v, v, u, num_words);
 8006324:	a918      	add	r1, sp, #96	; 0x60
 8006326:	aa10      	add	r2, sp, #64	; 0x40
 8006328:	4608      	mov	r0, r1
 800632a:	f7ff fbb6 	bl	8005a9a <uECC_vli_sub.isra.1>
            vli_modInv_update(v, mod, num_words);
 800632e:	4622      	mov	r2, r4
 8006330:	4629      	mov	r1, r5
 8006332:	a818      	add	r0, sp, #96	; 0x60
 8006334:	f7ff ff6b 	bl	800620e <vli_modInv_update>
 8006338:	e7a8      	b.n	800628c <uECC_vli_modInv+0x48>
        }
    }
    uECC_vli_set(result, u, num_words);
 800633a:	4622      	mov	r2, r4
 800633c:	a910      	add	r1, sp, #64	; 0x40
 800633e:	4630      	mov	r0, r6
 8006340:	f7ff f957 	bl	80055f2 <uECC_vli_set>
}
 8006344:	b021      	add	sp, #132	; 0x84
 8006346:	bdf0      	pop	{r4, r5, r6, r7, pc}

08006348 <EccPoint_mult>:
static void EccPoint_mult(uECC_word_t * result,
                          const uECC_word_t * point,
                          const uECC_word_t * scalar,
                          const uECC_word_t * initial_Z,
                          bitcount_t num_bits,
                          uECC_Curve curve) {
 8006348:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800634c:	b0b1      	sub	sp, #196	; 0xc4
 800634e:	461e      	mov	r6, r3
 8006350:	9c3b      	ldr	r4, [sp, #236]	; 0xec
 8006352:	9004      	str	r0, [sp, #16]
    uECC_word_t z[uECC_MAX_WORDS];
    bitcount_t i;
    uECC_word_t nb;
    wordcount_t num_words = curve->num_words;
    
    uECC_vli_set(Rx[1], point, num_words);
 8006354:	f994 8000 	ldrsb.w	r8, [r4]
static void EccPoint_mult(uECC_word_t * result,
                          const uECC_word_t * point,
                          const uECC_word_t * scalar,
                          const uECC_word_t * initial_Z,
                          bitcount_t num_bits,
                          uECC_Curve curve) {
 8006358:	9206      	str	r2, [sp, #24]
    uECC_word_t z[uECC_MAX_WORDS];
    bitcount_t i;
    uECC_word_t nb;
    wordcount_t num_words = curve->num_words;
    
    uECC_vli_set(Rx[1], point, num_words);
 800635a:	a818      	add	r0, sp, #96	; 0x60
 800635c:	4642      	mov	r2, r8
static void EccPoint_mult(uECC_word_t * result,
                          const uECC_word_t * point,
                          const uECC_word_t * scalar,
                          const uECC_word_t * initial_Z,
                          bitcount_t num_bits,
                          uECC_Curve curve) {
 800635e:	9105      	str	r1, [sp, #20]
    uECC_word_t z[uECC_MAX_WORDS];
    bitcount_t i;
    uECC_word_t nb;
    wordcount_t num_words = curve->num_words;
    
    uECC_vli_set(Rx[1], point, num_words);
 8006360:	f7ff f947 	bl	80055f2 <uECC_vli_set>
    uECC_vli_set(Ry[1], point + num_words, num_words);
 8006364:	ea4f 0388 	mov.w	r3, r8, lsl #2
 8006368:	9302      	str	r3, [sp, #8]
 800636a:	9a02      	ldr	r2, [sp, #8]
 800636c:	9b05      	ldr	r3, [sp, #20]
 800636e:	4413      	add	r3, r2
 8006370:	4619      	mov	r1, r3
 8006372:	4642      	mov	r2, r8
 8006374:	a828      	add	r0, sp, #160	; 0xa0
 8006376:	9303      	str	r3, [sp, #12]
 8006378:	f7ff f93b 	bl	80055f2 <uECC_vli_set>
 800637c:	f994 5000 	ldrsb.w	r5, [r4]
                                uECC_word_t * Y2,
                                const uECC_word_t * const initial_Z,
                                uECC_Curve curve) {
    uECC_word_t z[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;
    if (initial_Z) {
 8006380:	b12e      	cbz	r6, 800638e <EccPoint_mult+0x46>
        uECC_vli_set(z, initial_Z, num_words);
 8006382:	462a      	mov	r2, r5
 8006384:	4631      	mov	r1, r6
 8006386:	a808      	add	r0, sp, #32
 8006388:	f7ff f933 	bl	80055f2 <uECC_vli_set>
 800638c:	e005      	b.n	800639a <EccPoint_mult+0x52>
    } else {
        uECC_vli_clear(z, num_words);
 800638e:	4629      	mov	r1, r5
 8006390:	a808      	add	r0, sp, #32
 8006392:	f7ff f8e7 	bl	8005564 <uECC_vli_clear>
        z[0] = 1;
 8006396:	2301      	movs	r3, #1
 8006398:	9308      	str	r3, [sp, #32]
    }

    uECC_vli_set(X2, X1, num_words);
 800639a:	af10      	add	r7, sp, #64	; 0x40
 800639c:	462a      	mov	r2, r5
 800639e:	a918      	add	r1, sp, #96	; 0x60
 80063a0:	4638      	mov	r0, r7
    uECC_vli_set(Y2, Y1, num_words);
 80063a2:	f10d 0980 	add.w	r9, sp, #128	; 0x80
    } else {
        uECC_vli_clear(z, num_words);
        z[0] = 1;
    }

    uECC_vli_set(X2, X1, num_words);
 80063a6:	f7ff f924 	bl	80055f2 <uECC_vli_set>
    uECC_vli_set(Y2, Y1, num_words);
 80063aa:	462a      	mov	r2, r5
 80063ac:	a928      	add	r1, sp, #160	; 0xa0
 80063ae:	4648      	mov	r0, r9
 80063b0:	f7ff f91f 	bl	80055f2 <uECC_vli_set>

    apply_z(X1, Y1, z, curve);
 80063b4:	4623      	mov	r3, r4
 80063b6:	aa08      	add	r2, sp, #32
 80063b8:	a928      	add	r1, sp, #160	; 0xa0
 80063ba:	a818      	add	r0, sp, #96	; 0x60
 80063bc:	f7ff fa08 	bl	80057d0 <apply_z>
    curve->double_jacobian(X1, Y1, z, curve);
 80063c0:	4623      	mov	r3, r4
 80063c2:	aa08      	add	r2, sp, #32
 80063c4:	a928      	add	r1, sp, #160	; 0xa0
 80063c6:	a818      	add	r0, sp, #96	; 0x60
 80063c8:	f8d4 50a4 	ldr.w	r5, [r4, #164]	; 0xa4
 80063cc:	47a8      	blx	r5
    apply_z(X2, Y2, z, curve);
 80063ce:	4623      	mov	r3, r4
 80063d0:	aa08      	add	r2, sp, #32
 80063d2:	4649      	mov	r1, r9
 80063d4:	4638      	mov	r0, r7
 80063d6:	f7ff f9fb 	bl	80057d0 <apply_z>
    uECC_vli_set(Rx[1], point, num_words);
    uECC_vli_set(Ry[1], point + num_words, num_words);

    XYcZ_initial_double(Rx[1], Ry[1], Rx[0], Ry[0], initial_Z, curve);

    for (i = num_bits - 2; i > 0; --i) {
 80063da:	f9bd 60e8 	ldrsh.w	r6, [sp, #232]	; 0xe8
        nb = !uECC_vli_testBit(scalar, i);
        XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
 80063de:	9707      	str	r7, [sp, #28]
    uECC_vli_set(Rx[1], point, num_words);
    uECC_vli_set(Ry[1], point + num_words, num_words);

    XYcZ_initial_double(Rx[1], Ry[1], Rx[0], Ry[0], initial_Z, curve);

    for (i = num_bits - 2; i > 0; --i) {
 80063e0:	3e02      	subs	r6, #2
 80063e2:	b2b6      	uxth	r6, r6
 80063e4:	b231      	sxth	r1, r6
 80063e6:	2900      	cmp	r1, #0
 80063e8:	dd22      	ble.n	8006430 <EccPoint_mult+0xe8>
        nb = !uECC_vli_testBit(scalar, i);
 80063ea:	9806      	ldr	r0, [sp, #24]
 80063ec:	f7ff f8d5 	bl	800559a <uECC_vli_testBit>
 80063f0:	fab0 f080 	clz	r0, r0
 80063f4:	0940      	lsrs	r0, r0, #5
        XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
 80063f6:	9b07      	ldr	r3, [sp, #28]
 80063f8:	9400      	str	r4, [sp, #0]
 80063fa:	f1c0 0701 	rsb	r7, r0, #1
 80063fe:	017f      	lsls	r7, r7, #5
 8006400:	0140      	lsls	r0, r0, #5
 8006402:	eb03 0b07 	add.w	fp, r3, r7
 8006406:	eb03 0a00 	add.w	sl, r3, r0
 800640a:	eb09 0500 	add.w	r5, r9, r0
 800640e:	444f      	add	r7, r9
 8006410:	462b      	mov	r3, r5
 8006412:	4652      	mov	r2, sl
 8006414:	4639      	mov	r1, r7
 8006416:	4658      	mov	r0, fp
 8006418:	f7ff fe72 	bl	8006100 <XYcZ_addC>
 800641c:	3e01      	subs	r6, #1
        XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
 800641e:	9400      	str	r4, [sp, #0]
 8006420:	463b      	mov	r3, r7
 8006422:	465a      	mov	r2, fp
 8006424:	4629      	mov	r1, r5
 8006426:	4650      	mov	r0, sl
 8006428:	f7ff fe0b 	bl	8006042 <XYcZ_add>
 800642c:	b2b6      	uxth	r6, r6
 800642e:	e7d9      	b.n	80063e4 <EccPoint_mult+0x9c>
 8006430:	9b06      	ldr	r3, [sp, #24]
 8006432:	681d      	ldr	r5, [r3, #0]
    }

    nb = !uECC_vli_testBit(scalar, 0);
    XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
 8006434:	9400      	str	r4, [sp, #0]
 8006436:	f005 0501 	and.w	r5, r5, #1
 800643a:	f085 0501 	eor.w	r5, r5, #1
 800643e:	f1c5 0601 	rsb	r6, r5, #1
 8006442:	ab10      	add	r3, sp, #64	; 0x40
 8006444:	0176      	lsls	r6, r6, #5
 8006446:	199f      	adds	r7, r3, r6
 8006448:	ab20      	add	r3, sp, #128	; 0x80
 800644a:	441e      	add	r6, r3
 800644c:	016d      	lsls	r5, r5, #5
 800644e:	ab10      	add	r3, sp, #64	; 0x40
 8006450:	eb03 0905 	add.w	r9, r3, r5
 8006454:	ab20      	add	r3, sp, #128	; 0x80
 8006456:	441d      	add	r5, r3
    
    /* Find final 1/Z value. */
    uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */
 8006458:	f104 0a04 	add.w	sl, r4, #4
        XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
        XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
    }

    nb = !uECC_vli_testBit(scalar, 0);
    XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
 800645c:	462b      	mov	r3, r5
 800645e:	464a      	mov	r2, r9
 8006460:	4631      	mov	r1, r6
 8006462:	4638      	mov	r0, r7
 8006464:	f7ff fe4c 	bl	8006100 <XYcZ_addC>
    
    /* Find final 1/Z value. */
    uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */
 8006468:	4653      	mov	r3, sl
 800646a:	aa10      	add	r2, sp, #64	; 0x40
 800646c:	a918      	add	r1, sp, #96	; 0x60
 800646e:	a808      	add	r0, sp, #32
 8006470:	f7ff fd08 	bl	8005e84 <uECC_vli_modSub.isra.2>
    uECC_vli_modMult_fast(z, z, Ry[1 - nb], curve);               /* Yb * (X1 - X0) */
 8006474:	a908      	add	r1, sp, #32
 8006476:	4623      	mov	r3, r4
 8006478:	4632      	mov	r2, r6
 800647a:	4608      	mov	r0, r1
 800647c:	f7ff f994 	bl	80057a8 <uECC_vli_modMult_fast>
    uECC_vli_modMult_fast(z, z, point, curve);                    /* xP * Yb * (X1 - X0) */
 8006480:	a908      	add	r1, sp, #32
 8006482:	4623      	mov	r3, r4
 8006484:	9a05      	ldr	r2, [sp, #20]
 8006486:	4608      	mov	r0, r1
 8006488:	f7ff f98e 	bl	80057a8 <uECC_vli_modMult_fast>
    uECC_vli_modInv(z, z, curve->p, num_words);            /* 1 / (xP * Yb * (X1 - X0)) */
 800648c:	a908      	add	r1, sp, #32
 800648e:	4643      	mov	r3, r8
 8006490:	4652      	mov	r2, sl
 8006492:	4608      	mov	r0, r1
 8006494:	f7ff fed6 	bl	8006244 <uECC_vli_modInv>
    /* yP / (xP * Yb * (X1 - X0)) */
    uECC_vli_modMult_fast(z, z, point + num_words, curve); 
 8006498:	a908      	add	r1, sp, #32
 800649a:	4623      	mov	r3, r4
 800649c:	9a03      	ldr	r2, [sp, #12]
 800649e:	4608      	mov	r0, r1
 80064a0:	f7ff f982 	bl	80057a8 <uECC_vli_modMult_fast>
    uECC_vli_modMult_fast(z, z, Rx[1 - nb], curve); /* Xb * yP / (xP * Yb * (X1 - X0)) */
 80064a4:	a908      	add	r1, sp, #32
 80064a6:	4623      	mov	r3, r4
 80064a8:	463a      	mov	r2, r7
 80064aa:	4608      	mov	r0, r1
 80064ac:	f7ff f97c 	bl	80057a8 <uECC_vli_modMult_fast>
    /* End 1/Z calculation */

    XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
 80064b0:	9400      	str	r4, [sp, #0]
 80064b2:	4633      	mov	r3, r6
 80064b4:	463a      	mov	r2, r7
 80064b6:	4629      	mov	r1, r5
 80064b8:	4648      	mov	r0, r9
 80064ba:	f7ff fdc2 	bl	8006042 <XYcZ_add>
    apply_z(Rx[0], Ry[0], z, curve);
 80064be:	4623      	mov	r3, r4
 80064c0:	aa08      	add	r2, sp, #32
 80064c2:	a920      	add	r1, sp, #128	; 0x80
 80064c4:	a810      	add	r0, sp, #64	; 0x40
 80064c6:	f7ff f983 	bl	80057d0 <apply_z>
    
    uECC_vli_set(result, Rx[0], num_words);
 80064ca:	4642      	mov	r2, r8
 80064cc:	a910      	add	r1, sp, #64	; 0x40
 80064ce:	9804      	ldr	r0, [sp, #16]
 80064d0:	f7ff f88f 	bl	80055f2 <uECC_vli_set>
    uECC_vli_set(result + num_words, Ry[0], num_words);
 80064d4:	9b04      	ldr	r3, [sp, #16]
 80064d6:	9c02      	ldr	r4, [sp, #8]
 80064d8:	4423      	add	r3, r4
 80064da:	4642      	mov	r2, r8
 80064dc:	a920      	add	r1, sp, #128	; 0x80
 80064de:	4618      	mov	r0, r3
 80064e0:	f7ff f887 	bl	80055f2 <uECC_vli_set>
}
 80064e4:	b031      	add	sp, #196	; 0xc4
 80064e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080064ea <EccPoint_compute_public_key>:
    return carry;
}

static uECC_word_t EccPoint_compute_public_key(uECC_word_t *result,
                                               uECC_word_t *private,
                                               uECC_Curve curve) {
 80064ea:	b530      	push	{r4, r5, lr}
 80064ec:	4614      	mov	r4, r2
 80064ee:	b095      	sub	sp, #84	; 0x54
 80064f0:	4605      	mov	r5, r0
    uECC_word_t tmp1[uECC_MAX_WORDS];
    uECC_word_t tmp2[uECC_MAX_WORDS];
    uECC_word_t *p2[2] = {tmp1, tmp2};
 80064f2:	aa0c      	add	r2, sp, #48	; 0x30
    uECC_word_t carry;

    /* Regularize the bitcount for the private key so that attackers cannot use a side channel
       attack to learn the number of leading zeros. */
    carry = regularize_k(private, tmp1, tmp2, curve);
 80064f4:	4623      	mov	r3, r4
    return carry;
}

static uECC_word_t EccPoint_compute_public_key(uECC_word_t *result,
                                               uECC_word_t *private,
                                               uECC_Curve curve) {
 80064f6:	4608      	mov	r0, r1
    uECC_word_t tmp1[uECC_MAX_WORDS];
    uECC_word_t tmp2[uECC_MAX_WORDS];
    uECC_word_t *p2[2] = {tmp1, tmp2};
 80064f8:	a904      	add	r1, sp, #16
 80064fa:	9102      	str	r1, [sp, #8]
 80064fc:	9203      	str	r2, [sp, #12]
    uECC_word_t carry;

    /* Regularize the bitcount for the private key so that attackers cannot use a side channel
       attack to learn the number of leading zeros. */
    carry = regularize_k(private, tmp1, tmp2, curve);
 80064fe:	f7ff faa5 	bl	8005a4c <regularize_k>

    EccPoint_mult(result, curve->G, p2[!carry], 0, curve->num_n_bits + 1, curve);
 8006502:	fab0 f080 	clz	r0, r0
 8006506:	ab14      	add	r3, sp, #80	; 0x50
 8006508:	0940      	lsrs	r0, r0, #5
 800650a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800650e:	8863      	ldrh	r3, [r4, #2]
 8006510:	9401      	str	r4, [sp, #4]
 8006512:	3301      	adds	r3, #1
 8006514:	b21b      	sxth	r3, r3
 8006516:	9300      	str	r3, [sp, #0]
 8006518:	f850 2c48 	ldr.w	r2, [r0, #-72]
 800651c:	2300      	movs	r3, #0
 800651e:	f104 0144 	add.w	r1, r4, #68	; 0x44
 8006522:	4628      	mov	r0, r5
 8006524:	f7ff ff10 	bl	8006348 <EccPoint_mult>

    if (EccPoint_isZero(result, curve)) {
 8006528:	7821      	ldrb	r1, [r4, #0]
 800652a:	0049      	lsls	r1, r1, #1
 800652c:	b249      	sxtb	r1, r1
 800652e:	4628      	mov	r0, r5
 8006530:	f7ff f824 	bl	800557c <uECC_vli_isZero>
        return 0;
    }
    return 1;
}
 8006534:	fab0 f080 	clz	r0, r0
 8006538:	0940      	lsrs	r0, r0, #5
 800653a:	b015      	add	sp, #84	; 0x54
 800653c:	bd30      	pop	{r4, r5, pc}
	...

08006540 <uECC_sign_with_k>:
static int uECC_sign_with_k(const uint8_t *private_key,
                            const uint8_t *message_hash,
                            unsigned hash_size,
                            uECC_word_t *k,
                            uint8_t *signature,
                            uECC_Curve curve) {
 8006540:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006544:	b0ab      	sub	sp, #172	; 0xac
 8006546:	461e      	mov	r6, r3
 8006548:	9d35      	ldr	r5, [sp, #212]	; 0xd4
 800654a:	9005      	str	r0, [sp, #20]
    uECC_word_t tmp[uECC_MAX_WORDS];
    uECC_word_t s[uECC_MAX_WORDS];
    uECC_word_t *k2[2] = {tmp, s};
    uECC_word_t p[uECC_MAX_WORDS * 2];
    uECC_word_t carry;
    wordcount_t num_words = curve->num_words;
 800654c:	f895 9000 	ldrb.w	r9, [r5]
static int uECC_sign_with_k(const uint8_t *private_key,
                            const uint8_t *message_hash,
                            unsigned hash_size,
                            uECC_word_t *k,
                            uint8_t *signature,
                            uECC_Curve curve) {
 8006550:	9106      	str	r1, [sp, #24]
    wordcount_t num_words = curve->num_words;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    bitcount_t num_n_bits = curve->num_n_bits;
    
    /* Make sure 0 < k < curve_n */
    if (uECC_vli_isZero(k, num_words) || uECC_vli_cmp(curve->n, k, num_n_words) != 1) {
 8006552:	fa4f fa89 	sxtb.w	sl, r9
                            uECC_word_t *k,
                            uint8_t *signature,
                            uECC_Curve curve) {
    uECC_word_t tmp[uECC_MAX_WORDS];
    uECC_word_t s[uECC_MAX_WORDS];
    uECC_word_t *k2[2] = {tmp, s};
 8006556:	ab12      	add	r3, sp, #72	; 0x48
 8006558:	f10d 0828 	add.w	r8, sp, #40	; 0x28
    wordcount_t num_words = curve->num_words;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    bitcount_t num_n_bits = curve->num_n_bits;
    
    /* Make sure 0 < k < curve_n */
    if (uECC_vli_isZero(k, num_words) || uECC_vli_cmp(curve->n, k, num_n_words) != 1) {
 800655c:	4651      	mov	r1, sl
 800655e:	4630      	mov	r0, r6
static int uECC_sign_with_k(const uint8_t *private_key,
                            const uint8_t *message_hash,
                            unsigned hash_size,
                            uECC_word_t *k,
                            uint8_t *signature,
                            uECC_Curve curve) {
 8006560:	9207      	str	r2, [sp, #28]
    uECC_word_t tmp[uECC_MAX_WORDS];
    uECC_word_t s[uECC_MAX_WORDS];
    uECC_word_t *k2[2] = {tmp, s};
 8006562:	f8cd 8020 	str.w	r8, [sp, #32]
 8006566:	9309      	str	r3, [sp, #36]	; 0x24
    wordcount_t num_words = curve->num_words;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    bitcount_t num_n_bits = curve->num_n_bits;
    
    /* Make sure 0 < k < curve_n */
    if (uECC_vli_isZero(k, num_words) || uECC_vli_cmp(curve->n, k, num_n_words) != 1) {
 8006568:	f7ff f808 	bl	800557c <uECC_vli_isZero>
 800656c:	9003      	str	r0, [sp, #12]
 800656e:	b108      	cbz	r0, 8006574 <uECC_sign_with_k+0x34>
        return 0;
 8006570:	2000      	movs	r0, #0
 8006572:	e0a9      	b.n	80066c8 <uECC_sign_with_k+0x188>
    uECC_word_t s[uECC_MAX_WORDS];
    uECC_word_t *k2[2] = {tmp, s};
    uECC_word_t p[uECC_MAX_WORDS * 2];
    uECC_word_t carry;
    wordcount_t num_words = curve->num_words;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8006574:	f8b5 b002 	ldrh.w	fp, [r5, #2]
 8006578:	fa0f f48b 	sxth.w	r4, fp
 800657c:	2320      	movs	r3, #32
 800657e:	341f      	adds	r4, #31
    bitcount_t num_n_bits = curve->num_n_bits;
    
    /* Make sure 0 < k < curve_n */
    if (uECC_vli_isZero(k, num_words) || uECC_vli_cmp(curve->n, k, num_n_words) != 1) {
 8006580:	f105 0724 	add.w	r7, r5, #36	; 0x24
    uECC_word_t s[uECC_MAX_WORDS];
    uECC_word_t *k2[2] = {tmp, s};
    uECC_word_t p[uECC_MAX_WORDS * 2];
    uECC_word_t carry;
    wordcount_t num_words = curve->num_words;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8006584:	fb94 f4f3 	sdiv	r4, r4, r3
    bitcount_t num_n_bits = curve->num_n_bits;
    
    /* Make sure 0 < k < curve_n */
    if (uECC_vli_isZero(k, num_words) || uECC_vli_cmp(curve->n, k, num_n_words) != 1) {
 8006588:	b264      	sxtb	r4, r4
 800658a:	4622      	mov	r2, r4
 800658c:	4631      	mov	r1, r6
 800658e:	4638      	mov	r0, r7
 8006590:	f7ff faaa 	bl	8005ae8 <uECC_vli_cmp>
 8006594:	2801      	cmp	r0, #1
 8006596:	9004      	str	r0, [sp, #16]
 8006598:	d1ea      	bne.n	8006570 <uECC_sign_with_k+0x30>
        return 0;
    }
    
    carry = regularize_k(k, tmp, s, curve);
 800659a:	462b      	mov	r3, r5
 800659c:	aa12      	add	r2, sp, #72	; 0x48
 800659e:	4641      	mov	r1, r8
 80065a0:	4630      	mov	r0, r6
 80065a2:	f7ff fa53 	bl	8005a4c <regularize_k>
    EccPoint_mult(p, curve->G, k2[!carry], 0, num_n_bits + 1, curve);
 80065a6:	fab0 f080 	clz	r0, r0
 80065aa:	ab2a      	add	r3, sp, #168	; 0xa8
 80065ac:	0940      	lsrs	r0, r0, #5
 80065ae:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 80065b2:	f10b 0301 	add.w	r3, fp, #1
 80065b6:	b21b      	sxth	r3, r3
 80065b8:	9300      	str	r3, [sp, #0]
 80065ba:	9501      	str	r5, [sp, #4]
 80065bc:	f850 2c88 	ldr.w	r2, [r0, #-136]
 80065c0:	9b03      	ldr	r3, [sp, #12]
 80065c2:	f105 0144 	add.w	r1, r5, #68	; 0x44
 80065c6:	a81a      	add	r0, sp, #104	; 0x68
 80065c8:	f7ff febe 	bl	8006348 <EccPoint_mult>
    if (uECC_vli_isZero(p, num_words)) {
 80065cc:	4651      	mov	r1, sl
 80065ce:	a81a      	add	r0, sp, #104	; 0x68
 80065d0:	f7fe ffd4 	bl	800557c <uECC_vli_isZero>
 80065d4:	2800      	cmp	r0, #0
 80065d6:	d1cb      	bne.n	8006570 <uECC_sign_with_k+0x30>
        return 0;
    }

	// github.com/kmackay/micro-ecc/issues/65
	uECC_recid = (p[curve->num_words] & 0x01);
 80065d8:	f995 3000 	ldrsb.w	r3, [r5]
 80065dc:	aa2a      	add	r2, sp, #168	; 0xa8
 80065de:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80065e2:	4a3b      	ldr	r2, [pc, #236]	; (80066d0 <uECC_sign_with_k+0x190>)
 80065e4:	f853 3c40 	ldr.w	r3, [r3, #-64]
 80065e8:	f003 0301 	and.w	r3, r3, #1
 80065ec:	7013      	strb	r3, [r2, #0]
    
    /* If an RNG function was specified, get a random number
       to prevent side channel analysis of k. */
    if (!g_rng_function) {
 80065ee:	4b39      	ldr	r3, [pc, #228]	; (80066d4 <uECC_sign_with_k+0x194>)
 80065f0:	681b      	ldr	r3, [r3, #0]
 80065f2:	b933      	cbnz	r3, 8006602 <uECC_sign_with_k+0xc2>
        uECC_vli_clear(tmp, num_n_words);
 80065f4:	4621      	mov	r1, r4
 80065f6:	4640      	mov	r0, r8
 80065f8:	f7fe ffb4 	bl	8005564 <uECC_vli_clear>
        tmp[0] = 1;
 80065fc:	9b04      	ldr	r3, [sp, #16]
 80065fe:	930a      	str	r3, [sp, #40]	; 0x28
 8006600:	e006      	b.n	8006610 <uECC_sign_with_k+0xd0>
    } else if (!uECC_generate_random_int(tmp, curve->n, num_n_words)) {
 8006602:	4622      	mov	r2, r4
 8006604:	4639      	mov	r1, r7
 8006606:	4640      	mov	r0, r8
 8006608:	f7ff fa86 	bl	8005b18 <uECC_generate_random_int>
 800660c:	2800      	cmp	r0, #0
 800660e:	d0af      	beq.n	8006570 <uECC_sign_with_k+0x30>
        return 0;
    }

    /* Prevent side channel analysis of uECC_vli_modInv() to determine
       bits of k / the private key by premultiplying by a random number */
    uECC_vli_modMult(k, k, tmp, curve->n, num_n_words); /* k' = rand * k */
 8006610:	463b      	mov	r3, r7
 8006612:	aa0a      	add	r2, sp, #40	; 0x28
 8006614:	4631      	mov	r1, r6
 8006616:	4630      	mov	r0, r6
 8006618:	9400      	str	r4, [sp, #0]
 800661a:	f7ff f819 	bl	8005650 <uECC_vli_modMult>
    uECC_vli_modInv(k, k, curve->n, num_n_words);       /* k = 1 / k' */
 800661e:	4623      	mov	r3, r4
 8006620:	463a      	mov	r2, r7
 8006622:	4631      	mov	r1, r6
 8006624:	4630      	mov	r0, r6
 8006626:	f7ff fe0d 	bl	8006244 <uECC_vli_modInv>
    uECC_vli_modMult(k, k, tmp, curve->n, num_n_words); /* k = 1 / k */
 800662a:	463b      	mov	r3, r7
 800662c:	aa0a      	add	r2, sp, #40	; 0x28
 800662e:	4631      	mov	r1, r6
 8006630:	4630      	mov	r0, r6
 8006632:	9400      	str	r4, [sp, #0]
 8006634:	f7ff f80c 	bl	8005650 <uECC_vli_modMult>
    
    uECC_vli_nativeToBytes(signature, curve->num_bytes, p); /* store r */
 8006638:	aa1a      	add	r2, sp, #104	; 0x68
 800663a:	f995 1001 	ldrsb.w	r1, [r5, #1]
 800663e:	9834      	ldr	r0, [sp, #208]	; 0xd0
 8006640:	f7ff f8e5 	bl	800580e <uECC_vli_nativeToBytes>
    
    uECC_vli_bytesToNative(tmp, private_key, BITS_TO_BYTES(curve->num_n_bits)); /* tmp = d */
 8006644:	f9b5 3002 	ldrsh.w	r3, [r5, #2]
 8006648:	9905      	ldr	r1, [sp, #20]
 800664a:	3307      	adds	r3, #7
 800664c:	a80a      	add	r0, sp, #40	; 0x28
 800664e:	2208      	movs	r2, #8
 8006650:	fb93 f2f2 	sdiv	r2, r3, r2
 8006654:	f7ff f8ef 	bl	8005836 <uECC_vli_bytesToNative>

    s[num_n_words - 1] = 0;
 8006658:	aa2a      	add	r2, sp, #168	; 0xa8
 800665a:	1e63      	subs	r3, r4, #1
 800665c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8006660:	2200      	movs	r2, #0
 8006662:	f843 2c60 	str.w	r2, [r3, #-96]
    uECC_vli_set(s, p, num_words);
 8006666:	a91a      	add	r1, sp, #104	; 0x68
 8006668:	fa4f f289 	sxtb.w	r2, r9
 800666c:	a812      	add	r0, sp, #72	; 0x48
 800666e:	f7fe ffc0 	bl	80055f2 <uECC_vli_set>
    uECC_vli_modMult(s, tmp, s, curve->n, num_n_words); /* s = r*d */
 8006672:	aa12      	add	r2, sp, #72	; 0x48
 8006674:	4610      	mov	r0, r2
 8006676:	463b      	mov	r3, r7
 8006678:	a90a      	add	r1, sp, #40	; 0x28
 800667a:	9400      	str	r4, [sp, #0]
 800667c:	f7fe ffe8 	bl	8005650 <uECC_vli_modMult>

    bits2int(tmp, message_hash, hash_size, curve);
 8006680:	462b      	mov	r3, r5
 8006682:	9a07      	ldr	r2, [sp, #28]
 8006684:	9906      	ldr	r1, [sp, #24]
 8006686:	a80a      	add	r0, sp, #40	; 0x28
 8006688:	f7ff fbba 	bl	8005e00 <bits2int>
    uECC_vli_modAdd(s, tmp, s, curve->n, num_n_words); /* s = e + r*d */
 800668c:	aa12      	add	r2, sp, #72	; 0x48
 800668e:	4610      	mov	r0, r2
 8006690:	463b      	mov	r3, r7
 8006692:	a90a      	add	r1, sp, #40	; 0x28
 8006694:	9400      	str	r4, [sp, #0]
 8006696:	f7ff fa7b 	bl	8005b90 <uECC_vli_modAdd>
    uECC_vli_modMult(s, s, k, curve->n, num_n_words);  /* s = (e + r*d) / k */
 800669a:	a912      	add	r1, sp, #72	; 0x48
 800669c:	4608      	mov	r0, r1
 800669e:	463b      	mov	r3, r7
 80066a0:	4632      	mov	r2, r6
 80066a2:	9400      	str	r4, [sp, #0]
 80066a4:	f7fe ffd4 	bl	8005650 <uECC_vli_modMult>
    if (uECC_vli_numBits(s, num_n_words) > (bitcount_t)curve->num_bytes * 8) {
 80066a8:	4621      	mov	r1, r4
 80066aa:	a812      	add	r0, sp, #72	; 0x48
 80066ac:	f7fe ff7f 	bl	80055ae <uECC_vli_numBits>
 80066b0:	f995 1001 	ldrsb.w	r1, [r5, #1]
 80066b4:	ebb0 0fc1 	cmp.w	r0, r1, lsl #3
 80066b8:	f73f af5a 	bgt.w	8006570 <uECC_sign_with_k+0x30>
        return 0;
    }
    uECC_vli_nativeToBytes(signature + curve->num_bytes, curve->num_bytes, s);
 80066bc:	9b34      	ldr	r3, [sp, #208]	; 0xd0
 80066be:	aa12      	add	r2, sp, #72	; 0x48
 80066c0:	1858      	adds	r0, r3, r1
 80066c2:	f7ff f8a4 	bl	800580e <uECC_vli_nativeToBytes>
    return 1;
 80066c6:	2001      	movs	r0, #1
}
 80066c8:	b02b      	add	sp, #172	; 0xac
 80066ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80066ce:	bf00      	nop
 80066d0:	20000444 	.word	0x20000444
 80066d4:	20000234 	.word	0x20000234

080066d8 <double_jacobian_secp256k1>:

/* Double in place */
static void double_jacobian_secp256k1(uECC_word_t * X1,
                                      uECC_word_t * Y1,
                                      uECC_word_t * Z1,
                                      uECC_Curve curve) {
 80066d8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80066dc:	4605      	mov	r5, r0
 80066de:	b093      	sub	sp, #76	; 0x4c
 80066e0:	460c      	mov	r4, r1
    /* t1 = X, t2 = Y, t3 = Z */
    uECC_word_t t4[num_words_secp256k1];
    uECC_word_t t5[num_words_secp256k1];
    
    if (uECC_vli_isZero(Z1, num_words_secp256k1)) {
 80066e2:	4610      	mov	r0, r2
 80066e4:	2108      	movs	r1, #8

/* Double in place */
static void double_jacobian_secp256k1(uECC_word_t * X1,
                                      uECC_word_t * Y1,
                                      uECC_word_t * Z1,
                                      uECC_Curve curve) {
 80066e6:	4617      	mov	r7, r2
 80066e8:	461e      	mov	r6, r3
    /* t1 = X, t2 = Y, t3 = Z */
    uECC_word_t t4[num_words_secp256k1];
    uECC_word_t t5[num_words_secp256k1];
    
    if (uECC_vli_isZero(Z1, num_words_secp256k1)) {
 80066ea:	f7fe ff47 	bl	800557c <uECC_vli_isZero>
 80066ee:	2800      	cmp	r0, #0
 80066f0:	d166      	bne.n	80067c0 <double_jacobian_secp256k1+0xe8>
        return;
    }
    
    uECC_vli_modSquare_fast(t5, Y1, curve);   /* t5 = y1^2 */
 80066f2:	4632      	mov	r2, r6
 80066f4:	4621      	mov	r1, r4
 80066f6:	a80a      	add	r0, sp, #40	; 0x28
 80066f8:	f7ff f866 	bl	80057c8 <uECC_vli_modSquare_fast>
    uECC_vli_modMult_fast(t4, X1, t5, curve); /* t4 = x1*y1^2 = A */
 80066fc:	4633      	mov	r3, r6
 80066fe:	aa0a      	add	r2, sp, #40	; 0x28
 8006700:	4629      	mov	r1, r5
 8006702:	a802      	add	r0, sp, #8
 8006704:	f7ff f850 	bl	80057a8 <uECC_vli_modMult_fast>
    uECC_vli_modSquare_fast(X1, X1, curve);   /* t1 = x1^2 */
 8006708:	4632      	mov	r2, r6
 800670a:	4629      	mov	r1, r5
 800670c:	4628      	mov	r0, r5
 800670e:	f7ff f85b 	bl	80057c8 <uECC_vli_modSquare_fast>
    uECC_vli_modSquare_fast(t5, t5, curve);   /* t5 = y1^4 */
 8006712:	a90a      	add	r1, sp, #40	; 0x28
 8006714:	4608      	mov	r0, r1
 8006716:	4632      	mov	r2, r6
 8006718:	f7ff f856 	bl	80057c8 <uECC_vli_modSquare_fast>
    uECC_vli_modMult_fast(Z1, Y1, Z1, curve); /* t3 = y1*z1 = z3 */
    
    uECC_vli_modAdd(Y1, X1, X1, curve->p, num_words_secp256k1); /* t2 = 2*x1^2 */
 800671c:	f04f 0808 	mov.w	r8, #8
    
    uECC_vli_modSquare_fast(t5, Y1, curve);   /* t5 = y1^2 */
    uECC_vli_modMult_fast(t4, X1, t5, curve); /* t4 = x1*y1^2 = A */
    uECC_vli_modSquare_fast(X1, X1, curve);   /* t1 = x1^2 */
    uECC_vli_modSquare_fast(t5, t5, curve);   /* t5 = y1^4 */
    uECC_vli_modMult_fast(Z1, Y1, Z1, curve); /* t3 = y1*z1 = z3 */
 8006720:	463a      	mov	r2, r7
 8006722:	4638      	mov	r0, r7
 8006724:	4633      	mov	r3, r6
 8006726:	4621      	mov	r1, r4
    
    uECC_vli_modAdd(Y1, X1, X1, curve->p, num_words_secp256k1); /* t2 = 2*x1^2 */
 8006728:	1d37      	adds	r7, r6, #4
    
    uECC_vli_modSquare_fast(t5, Y1, curve);   /* t5 = y1^2 */
    uECC_vli_modMult_fast(t4, X1, t5, curve); /* t4 = x1*y1^2 = A */
    uECC_vli_modSquare_fast(X1, X1, curve);   /* t1 = x1^2 */
    uECC_vli_modSquare_fast(t5, t5, curve);   /* t5 = y1^4 */
    uECC_vli_modMult_fast(Z1, Y1, Z1, curve); /* t3 = y1*z1 = z3 */
 800672a:	f7ff f83d 	bl	80057a8 <uECC_vli_modMult_fast>
    
    uECC_vli_modAdd(Y1, X1, X1, curve->p, num_words_secp256k1); /* t2 = 2*x1^2 */
 800672e:	463b      	mov	r3, r7
 8006730:	462a      	mov	r2, r5
 8006732:	4629      	mov	r1, r5
 8006734:	4620      	mov	r0, r4
 8006736:	f8cd 8000 	str.w	r8, [sp]
 800673a:	f7ff fa29 	bl	8005b90 <uECC_vli_modAdd>
    uECC_vli_modAdd(Y1, Y1, X1, curve->p, num_words_secp256k1); /* t2 = 3*x1^2 */
 800673e:	463b      	mov	r3, r7
 8006740:	f8cd 8000 	str.w	r8, [sp]
 8006744:	462a      	mov	r2, r5
 8006746:	4621      	mov	r1, r4
 8006748:	4620      	mov	r0, r4
 800674a:	f7ff fa21 	bl	8005b90 <uECC_vli_modAdd>
    if (uECC_vli_testBit(Y1, 0)) {
 800674e:	6823      	ldr	r3, [r4, #0]
 8006750:	07db      	lsls	r3, r3, #31
 8006752:	d50e      	bpl.n	8006772 <double_jacobian_secp256k1+0x9a>
        uECC_word_t carry = uECC_vli_add(Y1, Y1, curve->p, num_words_secp256k1);
 8006754:	463a      	mov	r2, r7
 8006756:	4621      	mov	r1, r4
 8006758:	4620      	mov	r0, r4
 800675a:	f7ff f8f5 	bl	8005948 <uECC_vli_add.isra.0>
        uECC_vli_rshift1(Y1, num_words_secp256k1);
 800675e:	4641      	mov	r1, r8
    uECC_vli_modMult_fast(Z1, Y1, Z1, curve); /* t3 = y1*z1 = z3 */
    
    uECC_vli_modAdd(Y1, X1, X1, curve->p, num_words_secp256k1); /* t2 = 2*x1^2 */
    uECC_vli_modAdd(Y1, Y1, X1, curve->p, num_words_secp256k1); /* t2 = 3*x1^2 */
    if (uECC_vli_testBit(Y1, 0)) {
        uECC_word_t carry = uECC_vli_add(Y1, Y1, curve->p, num_words_secp256k1);
 8006760:	4681      	mov	r9, r0
        uECC_vli_rshift1(Y1, num_words_secp256k1);
 8006762:	4620      	mov	r0, r4
 8006764:	f7fe ff67 	bl	8005636 <uECC_vli_rshift1>
        Y1[num_words_secp256k1 - 1] |= carry << (uECC_WORD_BITS - 1);
 8006768:	69e0      	ldr	r0, [r4, #28]
 800676a:	ea40 70c9 	orr.w	r0, r0, r9, lsl #31
 800676e:	61e0      	str	r0, [r4, #28]
 8006770:	e003      	b.n	800677a <double_jacobian_secp256k1+0xa2>
    } else {
        uECC_vli_rshift1(Y1, num_words_secp256k1);
 8006772:	4641      	mov	r1, r8
 8006774:	4620      	mov	r0, r4
 8006776:	f7fe ff5e 	bl	8005636 <uECC_vli_rshift1>
    }
    /* t2 = 3/2*(x1^2) = B */
    
    uECC_vli_modSquare_fast(X1, Y1, curve);                     /* t1 = B^2 */
 800677a:	4632      	mov	r2, r6
 800677c:	4621      	mov	r1, r4
 800677e:	4628      	mov	r0, r5
 8006780:	f7ff f822 	bl	80057c8 <uECC_vli_modSquare_fast>
    uECC_vli_modSub(X1, X1, t4, curve->p, num_words_secp256k1); /* t1 = B^2 - A */
 8006784:	463b      	mov	r3, r7
 8006786:	aa02      	add	r2, sp, #8
 8006788:	4629      	mov	r1, r5
 800678a:	4628      	mov	r0, r5
 800678c:	f7ff fb7a 	bl	8005e84 <uECC_vli_modSub.isra.2>
    uECC_vli_modSub(X1, X1, t4, curve->p, num_words_secp256k1); /* t1 = B^2 - 2A = x3 */
 8006790:	463b      	mov	r3, r7
 8006792:	aa02      	add	r2, sp, #8
 8006794:	4629      	mov	r1, r5
 8006796:	4628      	mov	r0, r5
 8006798:	f7ff fb74 	bl	8005e84 <uECC_vli_modSub.isra.2>
    
    uECC_vli_modSub(t4, t4, X1, curve->p, num_words_secp256k1); /* t4 = A - x3 */
 800679c:	a902      	add	r1, sp, #8
 800679e:	4608      	mov	r0, r1
 80067a0:	463b      	mov	r3, r7
 80067a2:	462a      	mov	r2, r5
 80067a4:	f7ff fb6e 	bl	8005e84 <uECC_vli_modSub.isra.2>
    uECC_vli_modMult_fast(Y1, Y1, t4, curve);                   /* t2 = B * (A - x3) */
 80067a8:	4633      	mov	r3, r6
 80067aa:	aa02      	add	r2, sp, #8
 80067ac:	4621      	mov	r1, r4
 80067ae:	4620      	mov	r0, r4
 80067b0:	f7fe fffa 	bl	80057a8 <uECC_vli_modMult_fast>
    uECC_vli_modSub(Y1, Y1, t5, curve->p, num_words_secp256k1); /* t2 = B * (A - x3) - y1^4 = y3 */
 80067b4:	463b      	mov	r3, r7
 80067b6:	aa0a      	add	r2, sp, #40	; 0x28
 80067b8:	4621      	mov	r1, r4
 80067ba:	4620      	mov	r0, r4
 80067bc:	f7ff fb62 	bl	8005e84 <uECC_vli_modSub.isra.2>
}
 80067c0:	b013      	add	sp, #76	; 0x4c
 80067c2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	...

080067c8 <uECC_set_rng>:

// PDG: added prototype
int uECC_valid_point(const uECC_word_t *point, uECC_Curve curve);

void uECC_set_rng(uECC_RNG_Function rng_function) {
    g_rng_function = rng_function;
 80067c8:	4b01      	ldr	r3, [pc, #4]	; (80067d0 <uECC_set_rng+0x8>)
 80067ca:	6018      	str	r0, [r3, #0]
 80067cc:	4770      	bx	lr
 80067ce:	bf00      	nop
 80067d0:	20000234 	.word	0x20000234

080067d4 <uECC_secp256r1>:
#if (uECC_OPTIMIZATION_LEVEL > 0)
    &vli_mmod_fast_secp256r1
#endif
};

uECC_Curve uECC_secp256r1(void) { return &curve_secp256r1; }
 80067d4:	4800      	ldr	r0, [pc, #0]	; (80067d8 <uECC_secp256r1+0x4>)
 80067d6:	4770      	bx	lr
 80067d8:	0800e66c 	.word	0x0800e66c

080067dc <uECC_secp256k1>:
#if (uECC_OPTIMIZATION_LEVEL > 0)
    &vli_mmod_fast_secp256k1
#endif
};

uECC_Curve uECC_secp256k1(void) { return &curve_secp256k1; }
 80067dc:	4800      	ldr	r0, [pc, #0]	; (80067e0 <uECC_secp256k1+0x4>)
 80067de:	4770      	bx	lr
 80067e0:	0800e5b8 	.word	0x0800e5b8

080067e4 <uECC_make_key>:
    return 0;
}

int uECC_make_key(uint8_t *public_key,
                  uint8_t *private_key,
                  uECC_Curve curve) {
 80067e4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80067e8:	4606      	mov	r6, r0
 80067ea:	b099      	sub	sp, #100	; 0x64
 80067ec:	460f      	mov	r7, r1
 80067ee:	4614      	mov	r4, r2
 80067f0:	2540      	movs	r5, #64	; 0x40
    uECC_word_t private[uECC_MAX_WORDS];
    uECC_word_t public[uECC_MAX_WORDS * 2];
    uECC_word_t tries;

    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
        if (!uECC_generate_random_int(private, curve->n, BITS_TO_WORDS(curve->num_n_bits))) {
 80067f2:	f04f 0820 	mov.w	r8, #32
 80067f6:	f102 0924 	add.w	r9, r2, #36	; 0x24
 80067fa:	f9b4 2002 	ldrsh.w	r2, [r4, #2]
 80067fe:	4649      	mov	r1, r9
 8006800:	321f      	adds	r2, #31
 8006802:	4668      	mov	r0, sp
 8006804:	fb92 f2f8 	sdiv	r2, r2, r8
 8006808:	b252      	sxtb	r2, r2
 800680a:	f7ff f985 	bl	8005b18 <uECC_generate_random_int>
 800680e:	b908      	cbnz	r0, 8006814 <uECC_make_key+0x30>
            return 0;
 8006810:	2000      	movs	r0, #0
 8006812:	e024      	b.n	800685e <uECC_make_key+0x7a>
        }

        if (EccPoint_compute_public_key(public, private, curve)) {
 8006814:	4622      	mov	r2, r4
 8006816:	4669      	mov	r1, sp
 8006818:	a808      	add	r0, sp, #32
 800681a:	f7ff fe66 	bl	80064ea <EccPoint_compute_public_key>
 800681e:	b1d8      	cbz	r0, 8006858 <uECC_make_key+0x74>
            uECC_vli_nativeToBytes(private_key, BITS_TO_BYTES(curve->num_n_bits), private);
 8006820:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
 8006824:	466a      	mov	r2, sp
 8006826:	3307      	adds	r3, #7
 8006828:	4638      	mov	r0, r7
 800682a:	2108      	movs	r1, #8
 800682c:	fb93 f1f1 	sdiv	r1, r3, r1
 8006830:	f7fe ffed 	bl	800580e <uECC_vli_nativeToBytes>
            uECC_vli_nativeToBytes(public_key, curve->num_bytes, public);
 8006834:	aa08      	add	r2, sp, #32
 8006836:	f994 1001 	ldrsb.w	r1, [r4, #1]
 800683a:	4630      	mov	r0, r6
 800683c:	f7fe ffe7 	bl	800580e <uECC_vli_nativeToBytes>
            uECC_vli_nativeToBytes(
 8006840:	f994 2000 	ldrsb.w	r2, [r4]
 8006844:	f994 1001 	ldrsb.w	r1, [r4, #1]
 8006848:	ab08      	add	r3, sp, #32
 800684a:	1870      	adds	r0, r6, r1
 800684c:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8006850:	f7fe ffdd 	bl	800580e <uECC_vli_nativeToBytes>
                public_key + curve->num_bytes, curve->num_bytes, public + curve->num_words);
            return 1;
 8006854:	2001      	movs	r0, #1
 8006856:	e002      	b.n	800685e <uECC_make_key+0x7a>
                  uECC_Curve curve) {
    uECC_word_t private[uECC_MAX_WORDS];
    uECC_word_t public[uECC_MAX_WORDS * 2];
    uECC_word_t tries;

    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
 8006858:	3d01      	subs	r5, #1
 800685a:	d1ce      	bne.n	80067fa <uECC_make_key+0x16>
 800685c:	e7d8      	b.n	8006810 <uECC_make_key+0x2c>
                public_key + curve->num_bytes, curve->num_bytes, public + curve->num_words);
            return 1;
        }
    }
    return 0;
}
 800685e:	b019      	add	sp, #100	; 0x64
 8006860:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08006864 <uECC_shared_secret>:

int uECC_shared_secret(const uint8_t *public_key,
                       const uint8_t *private_key,
                       uint8_t *secret,
                       uECC_Curve curve) {
 8006864:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8006868:	461c      	mov	r4, r3
 800686a:	b0a4      	sub	sp, #144	; 0x90
    uECC_word_t private[uECC_MAX_WORDS];
    uECC_word_t tmp[uECC_MAX_WORDS];
    uECC_word_t *p2[2] = {private, tmp};
    uECC_word_t *initial_Z = 0;
    uECC_word_t carry;
    wordcount_t num_words = curve->num_words;
 800686c:	f893 9000 	ldrb.w	r9, [r3]
    wordcount_t num_bytes = curve->num_bytes;
 8006870:	785e      	ldrb	r6, [r3, #1]
    
    uECC_vli_bytesToNative(private, private_key, BITS_TO_BYTES(curve->num_n_bits));
 8006872:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
                       uint8_t *secret,
                       uECC_Curve curve) {
    uECC_word_t public[uECC_MAX_WORDS * 2];
    uECC_word_t private[uECC_MAX_WORDS];
    uECC_word_t tmp[uECC_MAX_WORDS];
    uECC_word_t *p2[2] = {private, tmp};
 8006876:	ad04      	add	r5, sp, #16
    uECC_word_t *initial_Z = 0;
    uECC_word_t carry;
    wordcount_t num_words = curve->num_words;
    wordcount_t num_bytes = curve->num_bytes;
    
    uECC_vli_bytesToNative(private, private_key, BITS_TO_BYTES(curve->num_n_bits));
 8006878:	3307      	adds	r3, #7
}

int uECC_shared_secret(const uint8_t *public_key,
                       const uint8_t *private_key,
                       uint8_t *secret,
                       uECC_Curve curve) {
 800687a:	4682      	mov	sl, r0
    uECC_word_t public[uECC_MAX_WORDS * 2];
    uECC_word_t private[uECC_MAX_WORDS];
    uECC_word_t tmp[uECC_MAX_WORDS];
    uECC_word_t *p2[2] = {private, tmp};
 800687c:	af0c      	add	r7, sp, #48	; 0x30
    uECC_word_t *initial_Z = 0;
    uECC_word_t carry;
    wordcount_t num_words = curve->num_words;
    wordcount_t num_bytes = curve->num_bytes;
    
    uECC_vli_bytesToNative(private, private_key, BITS_TO_BYTES(curve->num_n_bits));
 800687e:	4628      	mov	r0, r5
    uECC_vli_bytesToNative(public, public_key, num_bytes);
 8006880:	b276      	sxtb	r6, r6
}

int uECC_shared_secret(const uint8_t *public_key,
                       const uint8_t *private_key,
                       uint8_t *secret,
                       uECC_Curve curve) {
 8006882:	4690      	mov	r8, r2
    uECC_word_t *initial_Z = 0;
    uECC_word_t carry;
    wordcount_t num_words = curve->num_words;
    wordcount_t num_bytes = curve->num_bytes;
    
    uECC_vli_bytesToNative(private, private_key, BITS_TO_BYTES(curve->num_n_bits));
 8006884:	2208      	movs	r2, #8
 8006886:	fb93 f2f2 	sdiv	r2, r3, r2
                       uint8_t *secret,
                       uECC_Curve curve) {
    uECC_word_t public[uECC_MAX_WORDS * 2];
    uECC_word_t private[uECC_MAX_WORDS];
    uECC_word_t tmp[uECC_MAX_WORDS];
    uECC_word_t *p2[2] = {private, tmp};
 800688a:	9502      	str	r5, [sp, #8]
 800688c:	9703      	str	r7, [sp, #12]
    uECC_word_t *initial_Z = 0;
    uECC_word_t carry;
    wordcount_t num_words = curve->num_words;
    wordcount_t num_bytes = curve->num_bytes;
    
    uECC_vli_bytesToNative(private, private_key, BITS_TO_BYTES(curve->num_n_bits));
 800688e:	f7fe ffd2 	bl	8005836 <uECC_vli_bytesToNative>
    uECC_vli_bytesToNative(public, public_key, num_bytes);
 8006892:	4632      	mov	r2, r6
 8006894:	4651      	mov	r1, sl
 8006896:	a814      	add	r0, sp, #80	; 0x50
 8006898:	f7fe ffcd 	bl	8005836 <uECC_vli_bytesToNative>
    uECC_vli_bytesToNative(public + num_words, public_key + num_bytes, num_bytes);
 800689c:	fa4f f989 	sxtb.w	r9, r9
 80068a0:	ab14      	add	r3, sp, #80	; 0x50
 80068a2:	eb03 0089 	add.w	r0, r3, r9, lsl #2
 80068a6:	4632      	mov	r2, r6
 80068a8:	eb0a 0106 	add.w	r1, sl, r6
 80068ac:	f7fe ffc3 	bl	8005836 <uECC_vli_bytesToNative>
    
    /* Regularize the bitcount for the private key so that attackers cannot use a side channel
       attack to learn the number of leading zeros. */
    carry = regularize_k(private, private, tmp, curve);
 80068b0:	4623      	mov	r3, r4
 80068b2:	463a      	mov	r2, r7
 80068b4:	4629      	mov	r1, r5
 80068b6:	4628      	mov	r0, r5
 80068b8:	f7ff f8c8 	bl	8005a4c <regularize_k>
    
    /* If an RNG function was specified, try to get a random initial Z value to improve
       protection against side-channel attacks. */
    if (g_rng_function) {
 80068bc:	4b18      	ldr	r3, [pc, #96]	; (8006920 <uECC_shared_secret+0xbc>)
 80068be:	681f      	ldr	r7, [r3, #0]
    uECC_vli_bytesToNative(public, public_key, num_bytes);
    uECC_vli_bytesToNative(public + num_words, public_key + num_bytes, num_bytes);
    
    /* Regularize the bitcount for the private key so that attackers cannot use a side channel
       attack to learn the number of leading zeros. */
    carry = regularize_k(private, private, tmp, curve);
 80068c0:	4605      	mov	r5, r0
    
    /* If an RNG function was specified, try to get a random initial Z value to improve
       protection against side-channel attacks. */
    if (g_rng_function) {
 80068c2:	b157      	cbz	r7, 80068da <uECC_shared_secret+0x76>
        if (!uECC_generate_random_int(p2[carry], curve->p, num_words)) {
 80068c4:	ab24      	add	r3, sp, #144	; 0x90
 80068c6:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 80068ca:	464a      	mov	r2, r9
 80068cc:	f853 7c88 	ldr.w	r7, [r3, #-136]
 80068d0:	1d21      	adds	r1, r4, #4
 80068d2:	4638      	mov	r0, r7
 80068d4:	f7ff f920 	bl	8005b18 <uECC_generate_random_int>
 80068d8:	b1f8      	cbz	r0, 800691a <uECC_shared_secret+0xb6>
            return 0;
        }
        initial_Z = p2[carry];
    }
    
    EccPoint_mult(public, public, p2[!carry], initial_Z, curve->num_n_bits + 1, curve);
 80068da:	fab5 f085 	clz	r0, r5
 80068de:	ab24      	add	r3, sp, #144	; 0x90
 80068e0:	0940      	lsrs	r0, r0, #5
 80068e2:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 80068e6:	8863      	ldrh	r3, [r4, #2]
 80068e8:	9401      	str	r4, [sp, #4]
 80068ea:	3301      	adds	r3, #1
 80068ec:	b21b      	sxth	r3, r3
 80068ee:	9300      	str	r3, [sp, #0]
 80068f0:	a914      	add	r1, sp, #80	; 0x50
 80068f2:	463b      	mov	r3, r7
 80068f4:	f850 2c88 	ldr.w	r2, [r0, #-136]
 80068f8:	4608      	mov	r0, r1
 80068fa:	f7ff fd25 	bl	8006348 <EccPoint_mult>
    uECC_vli_nativeToBytes(secret, num_bytes, public);
 80068fe:	aa14      	add	r2, sp, #80	; 0x50
 8006900:	4631      	mov	r1, r6
 8006902:	4640      	mov	r0, r8
 8006904:	f7fe ff83 	bl	800580e <uECC_vli_nativeToBytes>
    return !EccPoint_isZero(public, curve);
 8006908:	7821      	ldrb	r1, [r4, #0]
 800690a:	0049      	lsls	r1, r1, #1
 800690c:	b249      	sxtb	r1, r1
 800690e:	a814      	add	r0, sp, #80	; 0x50
 8006910:	f7fe fe34 	bl	800557c <uECC_vli_isZero>
 8006914:	fab0 f080 	clz	r0, r0
 8006918:	0940      	lsrs	r0, r0, #5
}
 800691a:	b024      	add	sp, #144	; 0x90
 800691c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8006920:	20000234 	.word	0x20000234

08006924 <uECC_compress>:
#endif

#if uECC_SUPPORT_COMPRESSED_POINT
void uECC_compress(const uint8_t *public_key, uint8_t *compressed, uECC_Curve curve) {
 8006924:	b530      	push	{r4, r5, lr}
    wordcount_t i;
    for (i = 0; i < curve->num_bytes; ++i) {
 8006926:	2400      	movs	r4, #0
 8006928:	b2e3      	uxtb	r3, r4
 800692a:	f992 5001 	ldrsb.w	r5, [r2, #1]
 800692e:	b25b      	sxtb	r3, r3
 8006930:	42ab      	cmp	r3, r5
 8006932:	f104 0401 	add.w	r4, r4, #1
 8006936:	da03      	bge.n	8006940 <uECC_compress+0x1c>
        compressed[i+1] = public_key[i];
 8006938:	5cc5      	ldrb	r5, [r0, r3]
 800693a:	440b      	add	r3, r1
 800693c:	705d      	strb	r5, [r3, #1]
 800693e:	e7f3      	b.n	8006928 <uECC_compress+0x4>
    }
    compressed[0] = 2 + (public_key[curve->num_bytes * 2 - 1] & 0x01);
 8006940:	eb00 0045 	add.w	r0, r0, r5, lsl #1
 8006944:	f810 3c01 	ldrb.w	r3, [r0, #-1]
 8006948:	f003 0301 	and.w	r3, r3, #1
 800694c:	3302      	adds	r3, #2
 800694e:	700b      	strb	r3, [r1, #0]
 8006950:	bd30      	pop	{r4, r5, pc}

08006952 <uECC_decompress>:
}

void uECC_decompress(const uint8_t *compressed, uint8_t *public_key, uECC_Curve curve) {
 8006952:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uECC_word_t point[uECC_MAX_WORDS * 2];
    uECC_word_t *y = point + curve->num_words;
 8006956:	f992 7000 	ldrsb.w	r7, [r2]
        compressed[i+1] = public_key[i];
    }
    compressed[0] = 2 + (public_key[curve->num_bytes * 2 - 1] & 0x01);
}

void uECC_decompress(const uint8_t *compressed, uint8_t *public_key, uECC_Curve curve) {
 800695a:	b090      	sub	sp, #64	; 0x40
 800695c:	4614      	mov	r4, r2
 800695e:	4680      	mov	r8, r0
    uECC_word_t point[uECC_MAX_WORDS * 2];
    uECC_word_t *y = point + curve->num_words;
 8006960:	eb0d 0587 	add.w	r5, sp, r7, lsl #2
    uECC_vli_bytesToNative(point, compressed + 1, curve->num_bytes);
 8006964:	f992 2001 	ldrsb.w	r2, [r2, #1]
        compressed[i+1] = public_key[i];
    }
    compressed[0] = 2 + (public_key[curve->num_bytes * 2 - 1] & 0x01);
}

void uECC_decompress(const uint8_t *compressed, uint8_t *public_key, uECC_Curve curve) {
 8006968:	460e      	mov	r6, r1
    uECC_word_t point[uECC_MAX_WORDS * 2];
    uECC_word_t *y = point + curve->num_words;
    uECC_vli_bytesToNative(point, compressed + 1, curve->num_bytes);
 800696a:	1c41      	adds	r1, r0, #1
 800696c:	4668      	mov	r0, sp
 800696e:	f7fe ff62 	bl	8005836 <uECC_vli_bytesToNative>
    curve->x_side(y, point, curve);
 8006972:	4622      	mov	r2, r4
 8006974:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 8006978:	4669      	mov	r1, sp
 800697a:	4628      	mov	r0, r5
 800697c:	4798      	blx	r3
    curve->mod_sqrt(y, curve);
 800697e:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 8006982:	4621      	mov	r1, r4
 8006984:	4628      	mov	r0, r5
 8006986:	4798      	blx	r3
    
    if ((y[0] & 0x01) != (compressed[0] & 0x01)) {
 8006988:	f898 2000 	ldrb.w	r2, [r8]
 800698c:	f85d 3027 	ldr.w	r3, [sp, r7, lsl #2]
 8006990:	4053      	eors	r3, r2
 8006992:	07db      	lsls	r3, r3, #31
 8006994:	d504      	bpl.n	80069a0 <uECC_decompress+0x4e>
        uECC_vli_sub(y, curve->p, y, curve->num_words);
 8006996:	462a      	mov	r2, r5
 8006998:	1d21      	adds	r1, r4, #4
 800699a:	4628      	mov	r0, r5
 800699c:	f7ff f87d 	bl	8005a9a <uECC_vli_sub.isra.1>
    }
    
    uECC_vli_nativeToBytes(public_key, curve->num_bytes, point);
 80069a0:	466a      	mov	r2, sp
 80069a2:	f994 1001 	ldrsb.w	r1, [r4, #1]
 80069a6:	4630      	mov	r0, r6
 80069a8:	f7fe ff31 	bl	800580e <uECC_vli_nativeToBytes>
    uECC_vli_nativeToBytes(public_key + curve->num_bytes, curve->num_bytes, y);
 80069ac:	f994 1001 	ldrsb.w	r1, [r4, #1]
 80069b0:	462a      	mov	r2, r5
 80069b2:	1870      	adds	r0, r6, r1
 80069b4:	f7fe ff2b 	bl	800580e <uECC_vli_nativeToBytes>
}
 80069b8:	b010      	add	sp, #64	; 0x40
 80069ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080069be <uECC_valid_point>:
#endif /* uECC_SUPPORT_COMPRESSED_POINT */

#ifndef NO_SIGNING
int uECC_valid_point(const uECC_word_t *point, uECC_Curve curve) {
 80069be:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    uECC_word_t tmp1[uECC_MAX_WORDS];
    uECC_word_t tmp2[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;
 80069c2:	780e      	ldrb	r6, [r1, #0]

    /* The point at infinity is invalid. */
    if (EccPoint_isZero(point, curve)) {
 80069c4:	b2f5      	uxtb	r5, r6
    uECC_vli_nativeToBytes(public_key + curve->num_bytes, curve->num_bytes, y);
}
#endif /* uECC_SUPPORT_COMPRESSED_POINT */

#ifndef NO_SIGNING
int uECC_valid_point(const uECC_word_t *point, uECC_Curve curve) {
 80069c6:	460f      	mov	r7, r1
    uECC_word_t tmp1[uECC_MAX_WORDS];
    uECC_word_t tmp2[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;

    /* The point at infinity is invalid. */
    if (EccPoint_isZero(point, curve)) {
 80069c8:	0069      	lsls	r1, r5, #1
    uECC_vli_nativeToBytes(public_key + curve->num_bytes, curve->num_bytes, y);
}
#endif /* uECC_SUPPORT_COMPRESSED_POINT */

#ifndef NO_SIGNING
int uECC_valid_point(const uECC_word_t *point, uECC_Curve curve) {
 80069ca:	b090      	sub	sp, #64	; 0x40
    uECC_word_t tmp1[uECC_MAX_WORDS];
    uECC_word_t tmp2[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;

    /* The point at infinity is invalid. */
    if (EccPoint_isZero(point, curve)) {
 80069cc:	b249      	sxtb	r1, r1
    uECC_vli_nativeToBytes(public_key + curve->num_bytes, curve->num_bytes, y);
}
#endif /* uECC_SUPPORT_COMPRESSED_POINT */

#ifndef NO_SIGNING
int uECC_valid_point(const uECC_word_t *point, uECC_Curve curve) {
 80069ce:	4680      	mov	r8, r0
    uECC_word_t tmp1[uECC_MAX_WORDS];
    uECC_word_t tmp2[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;

    /* The point at infinity is invalid. */
    if (EccPoint_isZero(point, curve)) {
 80069d0:	f7fe fdd4 	bl	800557c <uECC_vli_isZero>
 80069d4:	4604      	mov	r4, r0
 80069d6:	bb98      	cbnz	r0, 8006a40 <uECC_valid_point+0x82>
        return 0;
    }
    
    /* x and y must be smaller than p. */
    if (uECC_vli_cmp_unsafe(curve->p, point, num_words) != 1 ||
 80069d8:	f107 0a04 	add.w	sl, r7, #4
 80069dc:	b276      	sxtb	r6, r6
 80069de:	4632      	mov	r2, r6
 80069e0:	4641      	mov	r1, r8
 80069e2:	4650      	mov	r0, sl
 80069e4:	f7fe fe12 	bl	800560c <uECC_vli_cmp_unsafe>
 80069e8:	2801      	cmp	r0, #1
 80069ea:	d12b      	bne.n	8006a44 <uECC_valid_point+0x86>
            uECC_vli_cmp_unsafe(curve->p, point + num_words, num_words) != 1) {
 80069ec:	eb08 0986 	add.w	r9, r8, r6, lsl #2
 80069f0:	4632      	mov	r2, r6
 80069f2:	4649      	mov	r1, r9
 80069f4:	4650      	mov	r0, sl
 80069f6:	f7fe fe09 	bl	800560c <uECC_vli_cmp_unsafe>
    if (EccPoint_isZero(point, curve)) {
        return 0;
    }
    
    /* x and y must be smaller than p. */
    if (uECC_vli_cmp_unsafe(curve->p, point, num_words) != 1 ||
 80069fa:	2801      	cmp	r0, #1
 80069fc:	d122      	bne.n	8006a44 <uECC_valid_point+0x86>
            uECC_vli_cmp_unsafe(curve->p, point + num_words, num_words) != 1) {
        return 0;
    }
    
    uECC_vli_modSquare_fast(tmp1, point + num_words, curve);
 80069fe:	463a      	mov	r2, r7
 8006a00:	4649      	mov	r1, r9
 8006a02:	4668      	mov	r0, sp
 8006a04:	f7fe fee0 	bl	80057c8 <uECC_vli_modSquare_fast>
    curve->x_side(tmp2, point, curve); /* tmp2 = x^3 + ax + b */
 8006a08:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8006a0c:	a808      	add	r0, sp, #32
 8006a0e:	463a      	mov	r2, r7
 8006a10:	4641      	mov	r1, r8
 8006a12:	4798      	blx	r3
uECC_VLI_API uECC_word_t uECC_vli_equal(const uECC_word_t *left,
                                        const uECC_word_t *right,
                                        wordcount_t num_words) {
    uECC_word_t diff = 0;
    wordcount_t i;
    for (i = num_words - 1; i >= 0; --i) {
 8006a14:	1e6b      	subs	r3, r5, #1
 8006a16:	b2db      	uxtb	r3, r3
/* Constant-time comparison function - secure way to compare long integers */
/* Returns one if left == right, zero otherwise. */
uECC_VLI_API uECC_word_t uECC_vli_equal(const uECC_word_t *left,
                                        const uECC_word_t *right,
                                        wordcount_t num_words) {
    uECC_word_t diff = 0;
 8006a18:	4620      	mov	r0, r4
    wordcount_t i;
    for (i = num_words - 1; i >= 0; --i) {
 8006a1a:	b25a      	sxtb	r2, r3
 8006a1c:	2a00      	cmp	r2, #0
 8006a1e:	db0b      	blt.n	8006a38 <uECC_valid_point+0x7a>
        diff |= (left[i] ^ right[i]);
 8006a20:	a910      	add	r1, sp, #64	; 0x40
 8006a22:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 8006a26:	3b01      	subs	r3, #1
 8006a28:	f852 1c40 	ldr.w	r1, [r2, #-64]
 8006a2c:	f852 2c20 	ldr.w	r2, [r2, #-32]
 8006a30:	404a      	eors	r2, r1
 8006a32:	4310      	orrs	r0, r2
 8006a34:	b2db      	uxtb	r3, r3
 8006a36:	e7f0      	b.n	8006a1a <uECC_valid_point+0x5c>
    
    uECC_vli_modSquare_fast(tmp1, point + num_words, curve);
    curve->x_side(tmp2, point, curve); /* tmp2 = x^3 + ax + b */
    
    /* Make sure that y^2 == x^3 + ax + b */
    return (int)(uECC_vli_equal(tmp1, tmp2, num_words));
 8006a38:	fab0 f080 	clz	r0, r0
 8006a3c:	0940      	lsrs	r0, r0, #5
 8006a3e:	e002      	b.n	8006a46 <uECC_valid_point+0x88>
    uECC_word_t tmp2[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;

    /* The point at infinity is invalid. */
    if (EccPoint_isZero(point, curve)) {
        return 0;
 8006a40:	2000      	movs	r0, #0
 8006a42:	e000      	b.n	8006a46 <uECC_valid_point+0x88>
 8006a44:	4620      	mov	r0, r4
    uECC_vli_modSquare_fast(tmp1, point + num_words, curve);
    curve->x_side(tmp2, point, curve); /* tmp2 = x^3 + ax + b */
    
    /* Make sure that y^2 == x^3 + ax + b */
    return (int)(uECC_vli_equal(tmp1, tmp2, num_words));
}
 8006a46:	b010      	add	sp, #64	; 0x40
 8006a48:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08006a4c <uECC_valid_public_key>:

int uECC_valid_public_key(const uint8_t *public_key, uECC_Curve curve) {
 8006a4c:	b530      	push	{r4, r5, lr}
 8006a4e:	460c      	mov	r4, r1
 8006a50:	b091      	sub	sp, #68	; 0x44
 8006a52:	4605      	mov	r5, r0
    uECC_word_t public[uECC_MAX_WORDS * 2];

    uECC_vli_bytesToNative(public, public_key, curve->num_bytes);
 8006a54:	f991 2001 	ldrsb.w	r2, [r1, #1]
 8006a58:	4601      	mov	r1, r0
 8006a5a:	4668      	mov	r0, sp
 8006a5c:	f7fe feeb 	bl	8005836 <uECC_vli_bytesToNative>
    uECC_vli_bytesToNative(
 8006a60:	f994 2001 	ldrsb.w	r2, [r4, #1]
 8006a64:	f994 0000 	ldrsb.w	r0, [r4]
 8006a68:	18a9      	adds	r1, r5, r2
 8006a6a:	eb0d 0080 	add.w	r0, sp, r0, lsl #2
 8006a6e:	f7fe fee2 	bl	8005836 <uECC_vli_bytesToNative>
        public + curve->num_words, public_key + curve->num_bytes, curve->num_bytes);
    return uECC_valid_point(public, curve);
 8006a72:	4621      	mov	r1, r4
 8006a74:	4668      	mov	r0, sp
 8006a76:	f7ff ffa2 	bl	80069be <uECC_valid_point>
}
 8006a7a:	b011      	add	sp, #68	; 0x44
 8006a7c:	bd30      	pop	{r4, r5, pc}

08006a7e <uECC_compute_public_key>:

int uECC_compute_public_key(const uint8_t *private_key, uint8_t *public_key, uECC_Curve curve) {
 8006a7e:	b570      	push	{r4, r5, r6, lr}
    uECC_word_t private[uECC_MAX_WORDS];
    uECC_word_t public[uECC_MAX_WORDS * 2];

    uECC_vli_bytesToNative(private, private_key, BITS_TO_BYTES(curve->num_n_bits));
 8006a80:	f9b2 3002 	ldrsh.w	r3, [r2, #2]
    uECC_vli_bytesToNative(
        public + curve->num_words, public_key + curve->num_bytes, curve->num_bytes);
    return uECC_valid_point(public, curve);
}

int uECC_compute_public_key(const uint8_t *private_key, uint8_t *public_key, uECC_Curve curve) {
 8006a84:	b098      	sub	sp, #96	; 0x60
 8006a86:	4615      	mov	r5, r2
    uECC_word_t private[uECC_MAX_WORDS];
    uECC_word_t public[uECC_MAX_WORDS * 2];

    uECC_vli_bytesToNative(private, private_key, BITS_TO_BYTES(curve->num_n_bits));
 8006a88:	3307      	adds	r3, #7
    uECC_vli_bytesToNative(
        public + curve->num_words, public_key + curve->num_bytes, curve->num_bytes);
    return uECC_valid_point(public, curve);
}

int uECC_compute_public_key(const uint8_t *private_key, uint8_t *public_key, uECC_Curve curve) {
 8006a8a:	460e      	mov	r6, r1
    uECC_word_t private[uECC_MAX_WORDS];
    uECC_word_t public[uECC_MAX_WORDS * 2];

    uECC_vli_bytesToNative(private, private_key, BITS_TO_BYTES(curve->num_n_bits));
 8006a8c:	2208      	movs	r2, #8
 8006a8e:	4601      	mov	r1, r0
 8006a90:	fb93 f2f2 	sdiv	r2, r3, r2
 8006a94:	4668      	mov	r0, sp
 8006a96:	f7fe fece 	bl	8005836 <uECC_vli_bytesToNative>

    /* Make sure the private key is in the range [1, n-1]. */
    if (uECC_vli_isZero(private, BITS_TO_WORDS(curve->num_n_bits))) {
 8006a9a:	f9b5 4002 	ldrsh.w	r4, [r5, #2]
 8006a9e:	2220      	movs	r2, #32
 8006aa0:	341f      	adds	r4, #31
 8006aa2:	fb94 f4f2 	sdiv	r4, r4, r2
 8006aa6:	b264      	sxtb	r4, r4
 8006aa8:	4621      	mov	r1, r4
 8006aaa:	4668      	mov	r0, sp
 8006aac:	f7fe fd66 	bl	800557c <uECC_vli_isZero>
 8006ab0:	b108      	cbz	r0, 8006ab6 <uECC_compute_public_key+0x38>
        return 0;
 8006ab2:	2000      	movs	r0, #0
 8006ab4:	e020      	b.n	8006af8 <uECC_compute_public_key+0x7a>
    }

    if (uECC_vli_cmp(curve->n, private, BITS_TO_WORDS(curve->num_n_bits)) != 1) {
 8006ab6:	4622      	mov	r2, r4
 8006ab8:	4669      	mov	r1, sp
 8006aba:	f105 0024 	add.w	r0, r5, #36	; 0x24
 8006abe:	f7ff f813 	bl	8005ae8 <uECC_vli_cmp>
 8006ac2:	2801      	cmp	r0, #1
 8006ac4:	4604      	mov	r4, r0
 8006ac6:	d1f4      	bne.n	8006ab2 <uECC_compute_public_key+0x34>
        return 0;
    }

    /* Compute public key. */
    if (!EccPoint_compute_public_key(public, private, curve)) {
 8006ac8:	462a      	mov	r2, r5
 8006aca:	4669      	mov	r1, sp
 8006acc:	a808      	add	r0, sp, #32
 8006ace:	f7ff fd0c 	bl	80064ea <EccPoint_compute_public_key>
 8006ad2:	2800      	cmp	r0, #0
 8006ad4:	d0ed      	beq.n	8006ab2 <uECC_compute_public_key+0x34>
        return 0;
    }

    uECC_vli_nativeToBytes(public_key, curve->num_bytes, public);
 8006ad6:	aa08      	add	r2, sp, #32
 8006ad8:	f995 1001 	ldrsb.w	r1, [r5, #1]
 8006adc:	4630      	mov	r0, r6
 8006ade:	f7fe fe96 	bl	800580e <uECC_vli_nativeToBytes>
    uECC_vli_nativeToBytes(
 8006ae2:	f995 2000 	ldrsb.w	r2, [r5]
 8006ae6:	f995 1001 	ldrsb.w	r1, [r5, #1]
 8006aea:	ab08      	add	r3, sp, #32
 8006aec:	1870      	adds	r0, r6, r1
 8006aee:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8006af2:	f7fe fe8c 	bl	800580e <uECC_vli_nativeToBytes>
        public_key + curve->num_bytes, curve->num_bytes, public + curve->num_words);
    return 1;
 8006af6:	4620      	mov	r0, r4
}
 8006af8:	b018      	add	sp, #96	; 0x60
 8006afa:	bd70      	pop	{r4, r5, r6, pc}

08006afc <uECC_sign>:

int uECC_sign(const uint8_t *private_key,
              const uint8_t *message_hash,
              unsigned hash_size,
              uint8_t *signature,
              uECC_Curve curve) {
 8006afc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006b00:	b08b      	sub	sp, #44	; 0x2c
 8006b02:	4606      	mov	r6, r0
 8006b04:	9d14      	ldr	r5, [sp, #80]	; 0x50
 8006b06:	460f      	mov	r7, r1
 8006b08:	4690      	mov	r8, r2
 8006b0a:	4699      	mov	r9, r3
 8006b0c:	2440      	movs	r4, #64	; 0x40
    uECC_word_t k[uECC_MAX_WORDS];
    uECC_word_t tries;

    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
        if (!uECC_generate_random_int(k, curve->n, BITS_TO_WORDS(curve->num_n_bits))) {
 8006b0e:	f04f 0a20 	mov.w	sl, #32
 8006b12:	f105 0b24 	add.w	fp, r5, #36	; 0x24
 8006b16:	f9b5 2002 	ldrsh.w	r2, [r5, #2]
 8006b1a:	4659      	mov	r1, fp
 8006b1c:	321f      	adds	r2, #31
 8006b1e:	a802      	add	r0, sp, #8
 8006b20:	fb92 f2fa 	sdiv	r2, r2, sl
 8006b24:	b252      	sxtb	r2, r2
 8006b26:	f7fe fff7 	bl	8005b18 <uECC_generate_random_int>
 8006b2a:	b908      	cbnz	r0, 8006b30 <uECC_sign+0x34>
            return 0;
 8006b2c:	2000      	movs	r0, #0
 8006b2e:	e00d      	b.n	8006b4c <uECC_sign+0x50>
        }

        if (uECC_sign_with_k(private_key, message_hash, hash_size, k, signature, curve)) {
 8006b30:	9501      	str	r5, [sp, #4]
 8006b32:	f8cd 9000 	str.w	r9, [sp]
 8006b36:	ab02      	add	r3, sp, #8
 8006b38:	4642      	mov	r2, r8
 8006b3a:	4639      	mov	r1, r7
 8006b3c:	4630      	mov	r0, r6
 8006b3e:	f7ff fcff 	bl	8006540 <uECC_sign_with_k>
 8006b42:	b910      	cbnz	r0, 8006b4a <uECC_sign+0x4e>
              uint8_t *signature,
              uECC_Curve curve) {
    uECC_word_t k[uECC_MAX_WORDS];
    uECC_word_t tries;

    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
 8006b44:	3c01      	subs	r4, #1
 8006b46:	d1e6      	bne.n	8006b16 <uECC_sign+0x1a>
 8006b48:	e7f0      	b.n	8006b2c <uECC_sign+0x30>
        if (!uECC_generate_random_int(k, curve->n, BITS_TO_WORDS(curve->num_n_bits))) {
            return 0;
        }

        if (uECC_sign_with_k(private_key, message_hash, hash_size, k, signature, curve)) {
            return 1;
 8006b4a:	2001      	movs	r0, #1
        }
    }
    return 0;
}
 8006b4c:	b00b      	add	sp, #44	; 0x2c
 8006b4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08006b52 <uECC_sign_deterministic>:
int uECC_sign_deterministic(const uint8_t *private_key,
                            const uint8_t *message_hash,
                            unsigned hash_size,
                            uECC_HashContext *hash_context,
                            uint8_t *signature,
                            uECC_Curve curve) {
 8006b52:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006b56:	b091      	sub	sp, #68	; 0x44
 8006b58:	4692      	mov	sl, r2
    uint8_t *K = hash_context->tmp;
    uint8_t *V = K + hash_context->result_size;
    wordcount_t num_bytes = curve->num_bytes;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8006b5a:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
                            const uint8_t *message_hash,
                            unsigned hash_size,
                            uECC_HashContext *hash_context,
                            uint8_t *signature,
                            uECC_Curve curve) {
    uint8_t *K = hash_context->tmp;
 8006b5c:	695d      	ldr	r5, [r3, #20]
    uint8_t *V = K + hash_context->result_size;
    wordcount_t num_bytes = curve->num_bytes;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8006b5e:	f8b2 b002 	ldrh.w	fp, [r2, #2]
                            unsigned hash_size,
                            uECC_HashContext *hash_context,
                            uint8_t *signature,
                            uECC_Curve curve) {
    uint8_t *K = hash_context->tmp;
    uint8_t *V = K + hash_context->result_size;
 8006b62:	691e      	ldr	r6, [r3, #16]
int uECC_sign_deterministic(const uint8_t *private_key,
                            const uint8_t *message_hash,
                            unsigned hash_size,
                            uECC_HashContext *hash_context,
                            uint8_t *signature,
                            uECC_Curve curve) {
 8006b64:	461c      	mov	r4, r3
    uint8_t *K = hash_context->tmp;
    uint8_t *V = K + hash_context->result_size;
    wordcount_t num_bytes = curve->num_bytes;
 8006b66:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8006b68:	fa0f f28b 	sxth.w	r2, fp
 8006b6c:	9203      	str	r2, [sp, #12]
 8006b6e:	2720      	movs	r7, #32
 8006b70:	321f      	adds	r2, #31
                            uECC_HashContext *hash_context,
                            uint8_t *signature,
                            uECC_Curve curve) {
    uint8_t *K = hash_context->tmp;
    uint8_t *V = K + hash_context->result_size;
    wordcount_t num_bytes = curve->num_bytes;
 8006b72:	785b      	ldrb	r3, [r3, #1]
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8006b74:	fb92 f7f7 	sdiv	r7, r2, r7
    bitcount_t num_n_bits = curve->num_n_bits;
    uECC_word_t tries;
    unsigned i;
    for (i = 0; i < hash_context->result_size; ++i) {
 8006b78:	2200      	movs	r2, #0
int uECC_sign_deterministic(const uint8_t *private_key,
                            const uint8_t *message_hash,
                            unsigned hash_size,
                            uECC_HashContext *hash_context,
                            uint8_t *signature,
                            uECC_Curve curve) {
 8006b7a:	4680      	mov	r8, r0
 8006b7c:	4689      	mov	r9, r1
    uint8_t *K = hash_context->tmp;
    uint8_t *V = K + hash_context->result_size;
 8006b7e:	442e      	add	r6, r5
    wordcount_t num_bytes = curve->num_bytes;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8006b80:	b2ff      	uxtb	r7, r7
    bitcount_t num_n_bits = curve->num_n_bits;
    uECC_word_t tries;
    unsigned i;
    for (i = 0; i < hash_context->result_size; ++i) {
        V[i] = 0x01;
 8006b82:	2001      	movs	r0, #1
        K[i] = 0;
 8006b84:	4696      	mov	lr, r2
    wordcount_t num_bytes = curve->num_bytes;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    bitcount_t num_n_bits = curve->num_n_bits;
    uECC_word_t tries;
    unsigned i;
    for (i = 0; i < hash_context->result_size; ++i) {
 8006b86:	6921      	ldr	r1, [r4, #16]
 8006b88:	428a      	cmp	r2, r1
 8006b8a:	d204      	bcs.n	8006b96 <uECC_sign_deterministic+0x44>
        V[i] = 0x01;
 8006b8c:	54b0      	strb	r0, [r6, r2]
        K[i] = 0;
 8006b8e:	f805 e002 	strb.w	lr, [r5, r2]
    wordcount_t num_bytes = curve->num_bytes;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    bitcount_t num_n_bits = curve->num_n_bits;
    uECC_word_t tries;
    unsigned i;
    for (i = 0; i < hash_context->result_size; ++i) {
 8006b92:	3201      	adds	r2, #1
 8006b94:	e7f7      	b.n	8006b86 <uECC_sign_deterministic+0x34>
        V[i] = 0x01;
        K[i] = 0;
    }
    
    /* K = HMAC_K(V || 0x00 || int2octets(x) || h(m)) */
    HMAC_init(hash_context, K);
 8006b96:	4629      	mov	r1, r5
 8006b98:	4620      	mov	r0, r4
 8006b9a:	9304      	str	r3, [sp, #16]
 8006b9c:	f7fe fe6c 	bl	8005878 <HMAC_init>
    V[hash_context->result_size] = 0x00;
 8006ba0:	6922      	ldr	r2, [r4, #16]
 8006ba2:	2100      	movs	r1, #0
 8006ba4:	54b1      	strb	r1, [r6, r2]
    HMAC_update(hash_context, V, hash_context->result_size + 1);
 8006ba6:	6922      	ldr	r2, [r4, #16]
 8006ba8:	4631      	mov	r1, r6
 8006baa:	3201      	adds	r2, #1
 8006bac:	4620      	mov	r0, r4
 8006bae:	f7fe fe86 	bl	80058be <HMAC_update>
    HMAC_update(hash_context, private_key, num_bytes);
 8006bb2:	9b04      	ldr	r3, [sp, #16]
 8006bb4:	b25b      	sxtb	r3, r3
 8006bb6:	461a      	mov	r2, r3
 8006bb8:	4641      	mov	r1, r8
 8006bba:	4620      	mov	r0, r4
 8006bbc:	9304      	str	r3, [sp, #16]
 8006bbe:	f7fe fe7e 	bl	80058be <HMAC_update>
    HMAC_update(hash_context, message_hash, hash_size);
 8006bc2:	4652      	mov	r2, sl
 8006bc4:	4649      	mov	r1, r9
 8006bc6:	4620      	mov	r0, r4
 8006bc8:	f7fe fe79 	bl	80058be <HMAC_update>
    HMAC_finish(hash_context, K, K);
 8006bcc:	462a      	mov	r2, r5
 8006bce:	4629      	mov	r1, r5
 8006bd0:	4620      	mov	r0, r4
 8006bd2:	f7fe fe76 	bl	80058c2 <HMAC_finish>

    update_V(hash_context, K, V);
 8006bd6:	4632      	mov	r2, r6
 8006bd8:	4629      	mov	r1, r5
 8006bda:	4620      	mov	r0, r4
 8006bdc:	f7fe fea2 	bl	8005924 <update_V>
    
    /* K = HMAC_K(V || 0x01 || int2octets(x) || h(m)) */
    HMAC_init(hash_context, K);
 8006be0:	4629      	mov	r1, r5
 8006be2:	4620      	mov	r0, r4
 8006be4:	f7fe fe48 	bl	8005878 <HMAC_init>
    V[hash_context->result_size] = 0x01;
 8006be8:	6922      	ldr	r2, [r4, #16]
 8006bea:	2101      	movs	r1, #1
 8006bec:	54b1      	strb	r1, [r6, r2]
    HMAC_update(hash_context, V, hash_context->result_size + 1);
 8006bee:	6922      	ldr	r2, [r4, #16]
 8006bf0:	4620      	mov	r0, r4
 8006bf2:	440a      	add	r2, r1
 8006bf4:	4631      	mov	r1, r6
 8006bf6:	f7fe fe62 	bl	80058be <HMAC_update>
    HMAC_update(hash_context, private_key, num_bytes);
 8006bfa:	9b04      	ldr	r3, [sp, #16]
 8006bfc:	4641      	mov	r1, r8
 8006bfe:	461a      	mov	r2, r3
 8006c00:	4620      	mov	r0, r4
 8006c02:	f7fe fe5c 	bl	80058be <HMAC_update>
    HMAC_update(hash_context, message_hash, hash_size);
 8006c06:	4652      	mov	r2, sl
 8006c08:	4649      	mov	r1, r9
 8006c0a:	4620      	mov	r0, r4
 8006c0c:	f7fe fe57 	bl	80058be <HMAC_update>
    HMAC_finish(hash_context, K, K);
 8006c10:	462a      	mov	r2, r5
 8006c12:	4629      	mov	r1, r5
 8006c14:	4620      	mov	r0, r4
 8006c16:	f7fe fe54 	bl	80058c2 <HMAC_finish>
        wordcount_t T_bytes = 0;
        for (;;) {
            update_V(hash_context, K, V);
            for (i = 0; i < hash_context->result_size; ++i) {
                T_ptr[T_bytes++] = V[i];
                if (T_bytes >= num_n_words * uECC_WORD_SIZE) {
 8006c1a:	b27f      	sxtb	r7, r7
    HMAC_update(hash_context, V, hash_context->result_size + 1);
    HMAC_update(hash_context, private_key, num_bytes);
    HMAC_update(hash_context, message_hash, hash_size);
    HMAC_finish(hash_context, K, K);

    update_V(hash_context, K, V);
 8006c1c:	4632      	mov	r2, r6
 8006c1e:	4629      	mov	r1, r5
 8006c20:	4620      	mov	r0, r4
 8006c22:	f7fe fe7f 	bl	8005924 <update_V>
 8006c26:	b23b      	sxth	r3, r7
 8006c28:	009a      	lsls	r2, r3, #2
        }
    filled:
        if ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8 > num_n_bits) {
            uECC_word_t mask = (uECC_word_t)-1;
            T[num_n_words - 1] &=
                mask >> ((bitcount_t)(num_n_words * uECC_WORD_SIZE * 8 - num_n_bits));
 8006c2a:	ebcb 1b47 	rsb	fp, fp, r7, lsl #5
 8006c2e:	015b      	lsls	r3, r3, #5
 8006c30:	9306      	str	r3, [sp, #24]
 8006c32:	fa0f fb8b 	sxth.w	fp, fp
 8006c36:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8006c3a:	fa23 f30b 	lsr.w	r3, r3, fp
 8006c3e:	9307      	str	r3, [sp, #28]
 8006c40:	2340      	movs	r3, #64	; 0x40
 8006c42:	9304      	str	r3, [sp, #16]
            }
        }
    filled:
        if ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8 > num_n_bits) {
            uECC_word_t mask = (uECC_word_t)-1;
            T[num_n_words - 1] &=
 8006c44:	3f01      	subs	r7, #1
 8006c46:	446b      	add	r3, sp
 8006c48:	9205      	str	r2, [sp, #20]
 8006c4a:	eb03 0787 	add.w	r7, r3, r7, lsl #2
                mask >> ((bitcount_t)(num_n_words * uECC_WORD_SIZE * 8 - num_n_bits));
 8006c4e:	f04f 0b00 	mov.w	fp, #0
    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
        uECC_word_t T[uECC_MAX_WORDS];
        uint8_t *T_ptr = (uint8_t *)T;
        wordcount_t T_bytes = 0;
        for (;;) {
            update_V(hash_context, K, V);
 8006c52:	4629      	mov	r1, r5
 8006c54:	4620      	mov	r0, r4
 8006c56:	4632      	mov	r2, r6
 8006c58:	f7fe fe64 	bl	8005924 <update_V>
 8006c5c:	6921      	ldr	r1, [r4, #16]
 8006c5e:	4630      	mov	r0, r6
 8006c60:	4431      	add	r1, r6
            for (i = 0; i < hash_context->result_size; ++i) {
 8006c62:	4288      	cmp	r0, r1
 8006c64:	d0f5      	beq.n	8006c52 <uECC_sign_deterministic+0x100>
                T_ptr[T_bytes++] = V[i];
 8006c66:	ab10      	add	r3, sp, #64	; 0x40
 8006c68:	fa43 f38b 	sxtab	r3, r3, fp
 8006c6c:	f810 eb01 	ldrb.w	lr, [r0], #1
 8006c70:	f803 ec20 	strb.w	lr, [r3, #-32]
 8006c74:	f10b 0201 	add.w	r2, fp, #1
 8006c78:	b2d2      	uxtb	r2, r2
                if (T_bytes >= num_n_words * uECC_WORD_SIZE) {
 8006c7a:	9b05      	ldr	r3, [sp, #20]
 8006c7c:	fa4f fe82 	sxtb.w	lr, r2
 8006c80:	459e      	cmp	lr, r3
 8006c82:	da01      	bge.n	8006c88 <uECC_sign_deterministic+0x136>
        uint8_t *T_ptr = (uint8_t *)T;
        wordcount_t T_bytes = 0;
        for (;;) {
            update_V(hash_context, K, V);
            for (i = 0; i < hash_context->result_size; ++i) {
                T_ptr[T_bytes++] = V[i];
 8006c84:	4693      	mov	fp, r2
 8006c86:	e7ec      	b.n	8006c62 <uECC_sign_deterministic+0x110>
                    goto filled;
                }
            }
        }
    filled:
        if ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8 > num_n_bits) {
 8006c88:	9b03      	ldr	r3, [sp, #12]
 8006c8a:	9a06      	ldr	r2, [sp, #24]
 8006c8c:	4293      	cmp	r3, r2
            uECC_word_t mask = (uECC_word_t)-1;
            T[num_n_words - 1] &=
 8006c8e:	bfbf      	itttt	lt
 8006c90:	f857 3c20 	ldrlt.w	r3, [r7, #-32]
 8006c94:	9a07      	ldrlt	r2, [sp, #28]
 8006c96:	4013      	andlt	r3, r2
 8006c98:	f847 3c20 	strlt.w	r3, [r7, #-32]
                mask >> ((bitcount_t)(num_n_words * uECC_WORD_SIZE * 8 - num_n_bits));
        }
    
        if (uECC_sign_with_k(private_key, message_hash, hash_size, T, signature, curve)) {
 8006c9c:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8006c9e:	9301      	str	r3, [sp, #4]
 8006ca0:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8006ca2:	9300      	str	r3, [sp, #0]
 8006ca4:	4652      	mov	r2, sl
 8006ca6:	ab08      	add	r3, sp, #32
 8006ca8:	4649      	mov	r1, r9
 8006caa:	4640      	mov	r0, r8
 8006cac:	f7ff fc48 	bl	8006540 <uECC_sign_with_k>
 8006cb0:	4683      	mov	fp, r0
 8006cb2:	b110      	cbz	r0, 8006cba <uECC_sign_deterministic+0x168>
            return 1;
 8006cb4:	f04f 0b01 	mov.w	fp, #1
 8006cb8:	e01a      	b.n	8006cf0 <uECC_sign_deterministic+0x19e>
        }

        /* K = HMAC_K(V || 0x00) */
        HMAC_init(hash_context, K);
 8006cba:	4629      	mov	r1, r5
 8006cbc:	4620      	mov	r0, r4
 8006cbe:	f7fe fddb 	bl	8005878 <HMAC_init>
        V[hash_context->result_size] = 0x00;
 8006cc2:	6922      	ldr	r2, [r4, #16]
 8006cc4:	f806 b002 	strb.w	fp, [r6, r2]
        HMAC_update(hash_context, V, hash_context->result_size + 1);
 8006cc8:	6922      	ldr	r2, [r4, #16]
 8006cca:	4631      	mov	r1, r6
 8006ccc:	3201      	adds	r2, #1
 8006cce:	4620      	mov	r0, r4
 8006cd0:	f7fe fdf5 	bl	80058be <HMAC_update>
        HMAC_finish(hash_context, K, K);
 8006cd4:	462a      	mov	r2, r5
 8006cd6:	4629      	mov	r1, r5
 8006cd8:	4620      	mov	r0, r4
 8006cda:	f7fe fdf2 	bl	80058c2 <HMAC_finish>

        update_V(hash_context, K, V);
 8006cde:	4632      	mov	r2, r6
 8006ce0:	4629      	mov	r1, r5
 8006ce2:	4620      	mov	r0, r4
 8006ce4:	f7fe fe1e 	bl	8005924 <update_V>
    HMAC_update(hash_context, message_hash, hash_size);
    HMAC_finish(hash_context, K, K);

    update_V(hash_context, K, V);

    for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
 8006ce8:	9b04      	ldr	r3, [sp, #16]
 8006cea:	3b01      	subs	r3, #1
 8006cec:	9304      	str	r3, [sp, #16]
 8006cee:	d1ae      	bne.n	8006c4e <uECC_sign_deterministic+0xfc>
        HMAC_finish(hash_context, K, K);

        update_V(hash_context, K, V);
    }
    return 0;
}
 8006cf0:	4658      	mov	r0, fp
 8006cf2:	b011      	add	sp, #68	; 0x44
 8006cf4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08006cf8 <uECC_verify>:

int uECC_verify(const uint8_t *public_key,
                const uint8_t *message_hash,
                unsigned hash_size,
                const uint8_t *signature,
                uECC_Curve curve) {
 8006cf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006cfc:	b0ff      	sub	sp, #508	; 0x1fc
 8006cfe:	461c      	mov	r4, r3
 8006d00:	9d88      	ldr	r5, [sp, #544]	; 0x220
 8006d02:	9209      	str	r2, [sp, #36]	; 0x24
    const uECC_word_t *points[4];
    const uECC_word_t *point;
    bitcount_t num_bits;
    bitcount_t i;
    uECC_word_t r[uECC_MAX_WORDS], s[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;
 8006d04:	782b      	ldrb	r3, [r5, #0]
 8006d06:	9303      	str	r3, [sp, #12]
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8006d08:	f9b5 3002 	ldrsh.w	r3, [r5, #2]

int uECC_verify(const uint8_t *public_key,
                const uint8_t *message_hash,
                unsigned hash_size,
                const uint8_t *signature,
                uECC_Curve curve) {
 8006d0c:	9106      	str	r1, [sp, #24]
    const uECC_word_t *point;
    bitcount_t num_bits;
    bitcount_t i;
    uECC_word_t r[uECC_MAX_WORDS], s[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 8006d0e:	2220      	movs	r2, #32
 8006d10:	331f      	adds	r3, #31
 8006d12:	fb93 f3f2 	sdiv	r3, r3, r2
 8006d16:	b2db      	uxtb	r3, r3
 8006d18:	9305      	str	r3, [sp, #20]
    
    rx[num_n_words - 1] = 0;
 8006d1a:	f99d 9014 	ldrsb.w	r9, [sp, #20]
    r[num_n_words - 1] = 0;
    s[num_n_words - 1] = 0;

    uECC_vli_bytesToNative(public, public_key, curve->num_bytes);
 8006d1e:	f995 2001 	ldrsb.w	r2, [r5, #1]
    bitcount_t i;
    uECC_word_t r[uECC_MAX_WORDS], s[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    
    rx[num_n_words - 1] = 0;
 8006d22:	f109 38ff 	add.w	r8, r9, #4294967295	; 0xffffffff
 8006d26:	ab26      	add	r3, sp, #152	; 0x98
 8006d28:	f04f 0b00 	mov.w	fp, #0
 8006d2c:	f843 b028 	str.w	fp, [r3, r8, lsl #2]
    r[num_n_words - 1] = 0;
 8006d30:	ab7e      	add	r3, sp, #504	; 0x1f8
 8006d32:	eb03 0388 	add.w	r3, r3, r8, lsl #2
    s[num_n_words - 1] = 0;

    uECC_vli_bytesToNative(public, public_key, curve->num_bytes);
 8006d36:	4601      	mov	r1, r0

int uECC_verify(const uint8_t *public_key,
                const uint8_t *message_hash,
                unsigned hash_size,
                const uint8_t *signature,
                uECC_Curve curve) {
 8006d38:	4607      	mov	r7, r0
    
    rx[num_n_words - 1] = 0;
    r[num_n_words - 1] = 0;
    s[num_n_words - 1] = 0;

    uECC_vli_bytesToNative(public, public_key, curve->num_bytes);
 8006d3a:	a85e      	add	r0, sp, #376	; 0x178
    uECC_word_t r[uECC_MAX_WORDS], s[uECC_MAX_WORDS];
    wordcount_t num_words = curve->num_words;
    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
    
    rx[num_n_words - 1] = 0;
    r[num_n_words - 1] = 0;
 8006d3c:	f843 bcc0 	str.w	fp, [r3, #-192]
    s[num_n_words - 1] = 0;
 8006d40:	f843 bca0 	str.w	fp, [r3, #-160]

    uECC_vli_bytesToNative(public, public_key, curve->num_bytes);
 8006d44:	f7fe fd77 	bl	8005836 <uECC_vli_bytesToNative>
    uECC_vli_bytesToNative(
        public + num_words, public_key + curve->num_bytes, curve->num_bytes);
 8006d48:	f99d 600c 	ldrsb.w	r6, [sp, #12]
 8006d4c:	00b3      	lsls	r3, r6, #2
 8006d4e:	9308      	str	r3, [sp, #32]
    rx[num_n_words - 1] = 0;
    r[num_n_words - 1] = 0;
    s[num_n_words - 1] = 0;

    uECC_vli_bytesToNative(public, public_key, curve->num_bytes);
    uECC_vli_bytesToNative(
 8006d50:	00b2      	lsls	r2, r6, #2
 8006d52:	ab5e      	add	r3, sp, #376	; 0x178
 8006d54:	4413      	add	r3, r2
 8006d56:	f995 2001 	ldrsb.w	r2, [r5, #1]
 8006d5a:	9304      	str	r3, [sp, #16]
 8006d5c:	4618      	mov	r0, r3
 8006d5e:	18b9      	adds	r1, r7, r2
 8006d60:	f7fe fd69 	bl	8005836 <uECC_vli_bytesToNative>
        public + num_words, public_key + curve->num_bytes, curve->num_bytes);
    uECC_vli_bytesToNative(r, signature, curve->num_bytes);
 8006d64:	4621      	mov	r1, r4
 8006d66:	f995 2001 	ldrsb.w	r2, [r5, #1]
 8006d6a:	a84e      	add	r0, sp, #312	; 0x138
 8006d6c:	f7fe fd63 	bl	8005836 <uECC_vli_bytesToNative>
    uECC_vli_bytesToNative(s, signature + curve->num_bytes, curve->num_bytes);
 8006d70:	f995 2001 	ldrsb.w	r2, [r5, #1]
 8006d74:	a856      	add	r0, sp, #344	; 0x158
 8006d76:	18a1      	adds	r1, r4, r2
 8006d78:	f7fe fd5d 	bl	8005836 <uECC_vli_bytesToNative>
    
    /* r, s must not be 0. */
    if (uECC_vli_isZero(r, num_words) || uECC_vli_isZero(s, num_words)) {
 8006d7c:	4631      	mov	r1, r6
 8006d7e:	a84e      	add	r0, sp, #312	; 0x138
 8006d80:	f7fe fbfc 	bl	800557c <uECC_vli_isZero>
 8006d84:	4604      	mov	r4, r0
 8006d86:	2800      	cmp	r0, #0
 8006d88:	f040 8138 	bne.w	8006ffc <uECC_verify+0x304>
 8006d8c:	4631      	mov	r1, r6
 8006d8e:	a856      	add	r0, sp, #344	; 0x158
 8006d90:	f7fe fbf4 	bl	800557c <uECC_vli_isZero>
 8006d94:	9002      	str	r0, [sp, #8]
 8006d96:	2800      	cmp	r0, #0
 8006d98:	f040 8132 	bne.w	8007000 <uECC_verify+0x308>
        return 0;
    }

    /* r, s must be < n. */
    if (uECC_vli_cmp_unsafe(curve->n, r, num_n_words) != 1 ||
 8006d9c:	f105 0a24 	add.w	sl, r5, #36	; 0x24
 8006da0:	464a      	mov	r2, r9
 8006da2:	a94e      	add	r1, sp, #312	; 0x138
 8006da4:	4650      	mov	r0, sl
 8006da6:	f7fe fc31 	bl	800560c <uECC_vli_cmp_unsafe>
 8006daa:	2801      	cmp	r0, #1
 8006dac:	f040 812a 	bne.w	8007004 <uECC_verify+0x30c>
            uECC_vli_cmp_unsafe(curve->n, s, num_n_words) != 1) {
 8006db0:	464a      	mov	r2, r9
 8006db2:	a956      	add	r1, sp, #344	; 0x158
 8006db4:	4650      	mov	r0, sl
 8006db6:	f7fe fc29 	bl	800560c <uECC_vli_cmp_unsafe>
    if (uECC_vli_isZero(r, num_words) || uECC_vli_isZero(s, num_words)) {
        return 0;
    }

    /* r, s must be < n. */
    if (uECC_vli_cmp_unsafe(curve->n, r, num_n_words) != 1 ||
 8006dba:	2801      	cmp	r0, #1
            uECC_vli_cmp_unsafe(curve->n, s, num_n_words) != 1) {
 8006dbc:	9007      	str	r0, [sp, #28]
    if (uECC_vli_isZero(r, num_words) || uECC_vli_isZero(s, num_words)) {
        return 0;
    }

    /* r, s must be < n. */
    if (uECC_vli_cmp_unsafe(curve->n, r, num_n_words) != 1 ||
 8006dbe:	f040 8121 	bne.w	8007004 <uECC_verify+0x30c>
            uECC_vli_cmp_unsafe(curve->n, s, num_n_words) != 1) {
        return 0;
    }

    /* Calculate u1 and u2. */
    uECC_vli_modInv(z, s, curve->n, num_n_words); /* z = 1/s */
 8006dc2:	ac1e      	add	r4, sp, #120	; 0x78
    u1[num_n_words - 1] = 0;
 8006dc4:	af0e      	add	r7, sp, #56	; 0x38
            uECC_vli_cmp_unsafe(curve->n, s, num_n_words) != 1) {
        return 0;
    }

    /* Calculate u1 and u2. */
    uECC_vli_modInv(z, s, curve->n, num_n_words); /* z = 1/s */
 8006dc6:	464b      	mov	r3, r9
 8006dc8:	4652      	mov	r2, sl
 8006dca:	a956      	add	r1, sp, #344	; 0x158
 8006dcc:	4620      	mov	r0, r4
 8006dce:	f7ff fa39 	bl	8006244 <uECC_vli_modInv>
    u1[num_n_words - 1] = 0;
 8006dd2:	9b02      	ldr	r3, [sp, #8]
 8006dd4:	f847 3028 	str.w	r3, [r7, r8, lsl #2]
    bits2int(u1, message_hash, hash_size, curve);
 8006dd8:	4638      	mov	r0, r7
 8006dda:	462b      	mov	r3, r5
 8006ddc:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8006dde:	9906      	ldr	r1, [sp, #24]
 8006de0:	f7ff f80e 	bl	8005e00 <bits2int>
    uECC_vli_modMult(u1, u1, z, curve->n, num_n_words); /* u1 = e/s */
 8006de4:	4639      	mov	r1, r7
 8006de6:	4638      	mov	r0, r7
 8006de8:	f8cd 9000 	str.w	r9, [sp]
 8006dec:	4653      	mov	r3, sl
 8006dee:	4622      	mov	r2, r4
 8006df0:	f7fe fc2e 	bl	8005650 <uECC_vli_modMult>
    uECC_vli_modMult(u2, r, z, curve->n, num_n_words); /* u2 = r/s */
    
    /* Calculate sum = G + Q. */
    uECC_vli_set(sum, public, num_words);
 8006df4:	f50d 78dc 	add.w	r8, sp, #440	; 0x1b8
    /* Calculate u1 and u2. */
    uECC_vli_modInv(z, s, curve->n, num_n_words); /* z = 1/s */
    u1[num_n_words - 1] = 0;
    bits2int(u1, message_hash, hash_size, curve);
    uECC_vli_modMult(u1, u1, z, curve->n, num_n_words); /* u1 = e/s */
    uECC_vli_modMult(u2, r, z, curve->n, num_n_words); /* u2 = r/s */
 8006df8:	4653      	mov	r3, sl
 8006dfa:	f8cd 9000 	str.w	r9, [sp]
 8006dfe:	4622      	mov	r2, r4
 8006e00:	a94e      	add	r1, sp, #312	; 0x138
 8006e02:	a816      	add	r0, sp, #88	; 0x58
 8006e04:	f7fe fc24 	bl	8005650 <uECC_vli_modMult>
    
    /* Calculate sum = G + Q. */
    uECC_vli_set(sum, public, num_words);
 8006e08:	4640      	mov	r0, r8
 8006e0a:	4632      	mov	r2, r6
 8006e0c:	a95e      	add	r1, sp, #376	; 0x178
 8006e0e:	f7fe fbf0 	bl	80055f2 <uECC_vli_set>
    uECC_vli_set(sum + num_words, public + num_words, num_words);
 8006e12:	00b3      	lsls	r3, r6, #2
 8006e14:	eb08 0b03 	add.w	fp, r8, r3
 8006e18:	4658      	mov	r0, fp
 8006e1a:	4632      	mov	r2, r6
 8006e1c:	9904      	ldr	r1, [sp, #16]
 8006e1e:	f7fe fbe8 	bl	80055f2 <uECC_vli_set>
    uECC_vli_set(tx, curve->G, num_words);
 8006e22:	f105 0344 	add.w	r3, r5, #68	; 0x44
 8006e26:	4619      	mov	r1, r3
 8006e28:	4632      	mov	r2, r6
 8006e2a:	a836      	add	r0, sp, #216	; 0xd8
 8006e2c:	9304      	str	r3, [sp, #16]
 8006e2e:	f7fe fbe0 	bl	80055f2 <uECC_vli_set>
    uECC_vli_set(ty, curve->G + num_words, num_words);
 8006e32:	9b04      	ldr	r3, [sp, #16]
 8006e34:	00b1      	lsls	r1, r6, #2
 8006e36:	1859      	adds	r1, r3, r1
 8006e38:	4632      	mov	r2, r6
 8006e3a:	a83e      	add	r0, sp, #248	; 0xf8
 8006e3c:	f7fe fbd9 	bl	80055f2 <uECC_vli_set>
    uECC_vli_modSub(z, sum, tx, curve->p, num_words); /* z = x2 - x1 */
 8006e40:	1d2b      	adds	r3, r5, #4
 8006e42:	4641      	mov	r1, r8
 8006e44:	aa36      	add	r2, sp, #216	; 0xd8
 8006e46:	4620      	mov	r0, r4
 8006e48:	9306      	str	r3, [sp, #24]
 8006e4a:	f7ff f81b 	bl	8005e84 <uECC_vli_modSub.isra.2>
    XYcZ_add(tx, ty, sum, sum + num_words, curve);
 8006e4e:	465b      	mov	r3, fp
 8006e50:	4642      	mov	r2, r8
 8006e52:	a93e      	add	r1, sp, #248	; 0xf8
 8006e54:	a836      	add	r0, sp, #216	; 0xd8
 8006e56:	9500      	str	r5, [sp, #0]
 8006e58:	f7ff f8f3 	bl	8006042 <XYcZ_add>
    uECC_vli_modInv(z, z, curve->p, num_words); /* z = 1/z */
 8006e5c:	4633      	mov	r3, r6
 8006e5e:	1d2a      	adds	r2, r5, #4
 8006e60:	4621      	mov	r1, r4
 8006e62:	4620      	mov	r0, r4
 8006e64:	f7ff f9ee 	bl	8006244 <uECC_vli_modInv>
    apply_z(sum, sum + num_words, z, curve);
 8006e68:	4622      	mov	r2, r4
 8006e6a:	4659      	mov	r1, fp
 8006e6c:	4640      	mov	r0, r8
 8006e6e:	462b      	mov	r3, r5
 8006e70:	f7fe fcae 	bl	80057d0 <apply_z>
    
    /* Use Shamir's trick to calculate u1*G + u2*Q */
    points[0] = 0;
 8006e74:	9b02      	ldr	r3, [sp, #8]
 8006e76:	930a      	str	r3, [sp, #40]	; 0x28
    points[1] = curve->G;
 8006e78:	9b04      	ldr	r3, [sp, #16]
 8006e7a:	930b      	str	r3, [sp, #44]	; 0x2c
    points[2] = public;
    points[3] = sum;
    num_bits = smax(uECC_vli_numBits(u1, num_n_words),
 8006e7c:	4649      	mov	r1, r9
    apply_z(sum, sum + num_words, z, curve);
    
    /* Use Shamir's trick to calculate u1*G + u2*Q */
    points[0] = 0;
    points[1] = curve->G;
    points[2] = public;
 8006e7e:	ab5e      	add	r3, sp, #376	; 0x178
    points[3] = sum;
    num_bits = smax(uECC_vli_numBits(u1, num_n_words),
 8006e80:	4638      	mov	r0, r7
    apply_z(sum, sum + num_words, z, curve);
    
    /* Use Shamir's trick to calculate u1*G + u2*Q */
    points[0] = 0;
    points[1] = curve->G;
    points[2] = public;
 8006e82:	930c      	str	r3, [sp, #48]	; 0x30
    points[3] = sum;
 8006e84:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
    num_bits = smax(uECC_vli_numBits(u1, num_n_words),
 8006e88:	f7fe fb91 	bl	80055ae <uECC_vli_numBits>
 8006e8c:	4649      	mov	r1, r9
 8006e8e:	4680      	mov	r8, r0
 8006e90:	a816      	add	r0, sp, #88	; 0x58
 8006e92:	f7fe fb8c 	bl	80055ae <uECC_vli_numBits>
                    uECC_vli_numBits(u2, num_n_words));
    
    point = points[(!!uECC_vli_testBit(u1, num_bits - 1)) |
 8006e96:	4540      	cmp	r0, r8
 8006e98:	bfb8      	it	lt
 8006e9a:	4640      	movlt	r0, r8
 8006e9c:	fa1f f880 	uxth.w	r8, r0
 8006ea0:	f108 39ff 	add.w	r9, r8, #4294967295	; 0xffffffff
 8006ea4:	fa0f f989 	sxth.w	r9, r9
 8006ea8:	4649      	mov	r1, r9
 8006eaa:	4638      	mov	r0, r7
 8006eac:	f7fe fb75 	bl	800559a <uECC_vli_testBit>
                   ((!!uECC_vli_testBit(u2, num_bits - 1)) << 1)];
 8006eb0:	4649      	mov	r1, r9
    points[2] = public;
    points[3] = sum;
    num_bits = smax(uECC_vli_numBits(u1, num_n_words),
                    uECC_vli_numBits(u2, num_n_words));
    
    point = points[(!!uECC_vli_testBit(u1, num_bits - 1)) |
 8006eb2:	1c07      	adds	r7, r0, #0
                   ((!!uECC_vli_testBit(u2, num_bits - 1)) << 1)];
 8006eb4:	a816      	add	r0, sp, #88	; 0x58
    points[2] = public;
    points[3] = sum;
    num_bits = smax(uECC_vli_numBits(u1, num_n_words),
                    uECC_vli_numBits(u2, num_n_words));
    
    point = points[(!!uECC_vli_testBit(u1, num_bits - 1)) |
 8006eb6:	bf18      	it	ne
 8006eb8:	2701      	movne	r7, #1
                   ((!!uECC_vli_testBit(u2, num_bits - 1)) << 1)];
 8006eba:	f7fe fb6e 	bl	800559a <uECC_vli_testBit>
 8006ebe:	2800      	cmp	r0, #0
 8006ec0:	bf14      	ite	ne
 8006ec2:	2302      	movne	r3, #2
 8006ec4:	2300      	moveq	r3, #0
    points[2] = public;
    points[3] = sum;
    num_bits = smax(uECC_vli_numBits(u1, num_n_words),
                    uECC_vli_numBits(u2, num_n_words));
    
    point = points[(!!uECC_vli_testBit(u1, num_bits - 1)) |
 8006ec6:	431f      	orrs	r7, r3
    XYcZ_add(tx, ty, sum, sum + num_words, curve);
    uECC_vli_modInv(z, z, curve->p, num_words); /* z = 1/z */
    apply_z(sum, sum + num_words, z, curve);
    
    /* Use Shamir's trick to calculate u1*G + u2*Q */
    points[0] = 0;
 8006ec8:	f10d 0b28 	add.w	fp, sp, #40	; 0x28
    num_bits = smax(uECC_vli_numBits(u1, num_n_words),
                    uECC_vli_numBits(u2, num_n_words));
    
    point = points[(!!uECC_vli_testBit(u1, num_bits - 1)) |
                   ((!!uECC_vli_testBit(u2, num_bits - 1)) << 1)];
    uECC_vli_set(rx, point, num_words);
 8006ecc:	4632      	mov	r2, r6
    points[2] = public;
    points[3] = sum;
    num_bits = smax(uECC_vli_numBits(u1, num_n_words),
                    uECC_vli_numBits(u2, num_n_words));
    
    point = points[(!!uECC_vli_testBit(u1, num_bits - 1)) |
 8006ece:	f85b 7027 	ldr.w	r7, [fp, r7, lsl #2]
                   ((!!uECC_vli_testBit(u2, num_bits - 1)) << 1)];
    uECC_vli_set(rx, point, num_words);
 8006ed2:	a826      	add	r0, sp, #152	; 0x98
 8006ed4:	4639      	mov	r1, r7
 8006ed6:	f7fe fb8c 	bl	80055f2 <uECC_vli_set>
    uECC_vli_set(ry, point + num_words, num_words);
 8006eda:	f10d 09b8 	add.w	r9, sp, #184	; 0xb8
 8006ede:	00b3      	lsls	r3, r6, #2
 8006ee0:	18f9      	adds	r1, r7, r3
 8006ee2:	4632      	mov	r2, r6
 8006ee4:	4648      	mov	r0, r9
 8006ee6:	f7fe fb84 	bl	80055f2 <uECC_vli_set>
    uECC_vli_clear(z, num_words);
 8006eea:	4631      	mov	r1, r6
 8006eec:	4620      	mov	r0, r4
 8006eee:	f7fe fb39 	bl	8005564 <uECC_vli_clear>
    z[0] = 1;

    for (i = num_bits - 2; i >= 0; --i) {
 8006ef2:	f1a8 0702 	sub.w	r7, r8, #2
    point = points[(!!uECC_vli_testBit(u1, num_bits - 1)) |
                   ((!!uECC_vli_testBit(u2, num_bits - 1)) << 1)];
    uECC_vli_set(rx, point, num_words);
    uECC_vli_set(ry, point + num_words, num_words);
    uECC_vli_clear(z, num_words);
    z[0] = 1;
 8006ef6:	9b07      	ldr	r3, [sp, #28]
 8006ef8:	6023      	str	r3, [r4, #0]

    for (i = num_bits - 2; i >= 0; --i) {
 8006efa:	b2bf      	uxth	r7, r7
 8006efc:	f10d 0898 	add.w	r8, sp, #152	; 0x98
 8006f00:	fa0f fb87 	sxth.w	fp, r7
 8006f04:	f1bb 0f00 	cmp.w	fp, #0
 8006f08:	db46      	blt.n	8006f98 <uECC_verify+0x2a0>
        uECC_word_t index;
        curve->double_jacobian(rx, ry, z, curve);
 8006f0a:	462b      	mov	r3, r5
 8006f0c:	4622      	mov	r2, r4
 8006f0e:	f8d5 60a4 	ldr.w	r6, [r5, #164]	; 0xa4
 8006f12:	4649      	mov	r1, r9
 8006f14:	4640      	mov	r0, r8
 8006f16:	47b0      	blx	r6
        
        index = (!!uECC_vli_testBit(u1, i)) | ((!!uECC_vli_testBit(u2, i)) << 1);
 8006f18:	4659      	mov	r1, fp
 8006f1a:	a80e      	add	r0, sp, #56	; 0x38
 8006f1c:	f7fe fb3d 	bl	800559a <uECC_vli_testBit>
 8006f20:	4659      	mov	r1, fp
 8006f22:	1c06      	adds	r6, r0, #0
 8006f24:	a816      	add	r0, sp, #88	; 0x58
 8006f26:	bf18      	it	ne
 8006f28:	2601      	movne	r6, #1
 8006f2a:	f7fe fb36 	bl	800559a <uECC_vli_testBit>
 8006f2e:	2800      	cmp	r0, #0
 8006f30:	bf14      	ite	ne
 8006f32:	2302      	movne	r3, #2
 8006f34:	2300      	moveq	r3, #0
        point = points[index];
 8006f36:	431e      	orrs	r6, r3
 8006f38:	ab0a      	add	r3, sp, #40	; 0x28
 8006f3a:	f853 b026 	ldr.w	fp, [r3, r6, lsl #2]
        if (point) {
 8006f3e:	f1bb 0f00 	cmp.w	fp, #0
 8006f42:	d026      	beq.n	8006f92 <uECC_verify+0x29a>
            uECC_vli_set(tx, point, num_words);
 8006f44:	f99d 600c 	ldrsb.w	r6, [sp, #12]
 8006f48:	4659      	mov	r1, fp
 8006f4a:	4632      	mov	r2, r6
 8006f4c:	a836      	add	r0, sp, #216	; 0xd8
 8006f4e:	f7fe fb50 	bl	80055f2 <uECC_vli_set>
            uECC_vli_set(ty, point + num_words, num_words);
 8006f52:	9b08      	ldr	r3, [sp, #32]
 8006f54:	4632      	mov	r2, r6
 8006f56:	eb0b 0103 	add.w	r1, fp, r3
 8006f5a:	a83e      	add	r0, sp, #248	; 0xf8
 8006f5c:	f7fe fb49 	bl	80055f2 <uECC_vli_set>
            apply_z(tx, ty, z, curve);
 8006f60:	462b      	mov	r3, r5
 8006f62:	4622      	mov	r2, r4
 8006f64:	a93e      	add	r1, sp, #248	; 0xf8
 8006f66:	a836      	add	r0, sp, #216	; 0xd8
 8006f68:	f7fe fc32 	bl	80057d0 <apply_z>
            uECC_vli_modSub(tz, rx, tx, curve->p, num_words); /* Z = x2 - x1 */
 8006f6c:	9b06      	ldr	r3, [sp, #24]
 8006f6e:	aa36      	add	r2, sp, #216	; 0xd8
 8006f70:	4641      	mov	r1, r8
 8006f72:	a846      	add	r0, sp, #280	; 0x118
 8006f74:	f7fe ff86 	bl	8005e84 <uECC_vli_modSub.isra.2>
            XYcZ_add(tx, ty, rx, ry, curve);
 8006f78:	464b      	mov	r3, r9
 8006f7a:	4642      	mov	r2, r8
 8006f7c:	a93e      	add	r1, sp, #248	; 0xf8
 8006f7e:	a836      	add	r0, sp, #216	; 0xd8
 8006f80:	9500      	str	r5, [sp, #0]
 8006f82:	f7ff f85e 	bl	8006042 <XYcZ_add>
            uECC_vli_modMult_fast(z, z, tz, curve);
 8006f86:	462b      	mov	r3, r5
 8006f88:	aa46      	add	r2, sp, #280	; 0x118
 8006f8a:	4621      	mov	r1, r4
 8006f8c:	4620      	mov	r0, r4
 8006f8e:	f7fe fc0b 	bl	80057a8 <uECC_vli_modMult_fast>
 8006f92:	3f01      	subs	r7, #1
 8006f94:	b2bf      	uxth	r7, r7
 8006f96:	e7b3      	b.n	8006f00 <uECC_verify+0x208>
        }
    }

    uECC_vli_modInv(z, z, curve->p, num_words); /* Z = 1/Z */
 8006f98:	f99d 300c 	ldrsb.w	r3, [sp, #12]
 8006f9c:	9a06      	ldr	r2, [sp, #24]
 8006f9e:	4621      	mov	r1, r4
 8006fa0:	4620      	mov	r0, r4
 8006fa2:	f7ff f94f 	bl	8006244 <uECC_vli_modInv>
    apply_z(rx, ry, z, curve);
 8006fa6:	462b      	mov	r3, r5
 8006fa8:	4622      	mov	r2, r4
 8006faa:	4649      	mov	r1, r9
 8006fac:	4640      	mov	r0, r8
 8006fae:	f7fe fc0f 	bl	80057d0 <apply_z>
    
    /* v = x1 (mod n) */
    if (uECC_vli_cmp_unsafe(curve->n, rx, num_n_words) != 1) {
 8006fb2:	f99d 2014 	ldrsb.w	r2, [sp, #20]
 8006fb6:	4641      	mov	r1, r8
 8006fb8:	4650      	mov	r0, sl
 8006fba:	f7fe fb27 	bl	800560c <uECC_vli_cmp_unsafe>
 8006fbe:	2801      	cmp	r0, #1
 8006fc0:	d004      	beq.n	8006fcc <uECC_verify+0x2d4>
        uECC_vli_sub(rx, rx, curve->n, num_n_words);
 8006fc2:	4652      	mov	r2, sl
 8006fc4:	4641      	mov	r1, r8
 8006fc6:	4640      	mov	r0, r8
 8006fc8:	f7fe fd67 	bl	8005a9a <uECC_vli_sub.isra.1>
uECC_VLI_API uECC_word_t uECC_vli_equal(const uECC_word_t *left,
                                        const uECC_word_t *right,
                                        wordcount_t num_words) {
    uECC_word_t diff = 0;
    wordcount_t i;
    for (i = num_words - 1; i >= 0; --i) {
 8006fcc:	9b03      	ldr	r3, [sp, #12]
 8006fce:	3b01      	subs	r3, #1
 8006fd0:	b2db      	uxtb	r3, r3
/* Constant-time comparison function - secure way to compare long integers */
/* Returns one if left == right, zero otherwise. */
uECC_VLI_API uECC_word_t uECC_vli_equal(const uECC_word_t *left,
                                        const uECC_word_t *right,
                                        wordcount_t num_words) {
    uECC_word_t diff = 0;
 8006fd2:	2000      	movs	r0, #0
    wordcount_t i;
    for (i = num_words - 1; i >= 0; --i) {
 8006fd4:	b25a      	sxtb	r2, r3
 8006fd6:	2a00      	cmp	r2, #0
 8006fd8:	db0c      	blt.n	8006ff4 <uECC_verify+0x2fc>
        diff |= (left[i] ^ right[i]);
 8006fda:	b212      	sxth	r2, r2
 8006fdc:	a97e      	add	r1, sp, #504	; 0x1f8
 8006fde:	eb01 0482 	add.w	r4, r1, r2, lsl #2
 8006fe2:	f858 1022 	ldr.w	r1, [r8, r2, lsl #2]
 8006fe6:	f854 2cc0 	ldr.w	r2, [r4, #-192]
 8006fea:	3b01      	subs	r3, #1
 8006fec:	404a      	eors	r2, r1
 8006fee:	4310      	orrs	r0, r2
 8006ff0:	b2db      	uxtb	r3, r3
 8006ff2:	e7ef      	b.n	8006fd4 <uECC_verify+0x2dc>
    if (uECC_vli_cmp_unsafe(curve->n, rx, num_n_words) != 1) {
        uECC_vli_sub(rx, rx, curve->n, num_n_words);
    }

    /* Accept only if v == r. */
    return (int)(uECC_vli_equal(rx, r, num_words));
 8006ff4:	fab0 f080 	clz	r0, r0
 8006ff8:	0940      	lsrs	r0, r0, #5
 8006ffa:	e004      	b.n	8007006 <uECC_verify+0x30e>
    uECC_vli_bytesToNative(r, signature, curve->num_bytes);
    uECC_vli_bytesToNative(s, signature + curve->num_bytes, curve->num_bytes);
    
    /* r, s must not be 0. */
    if (uECC_vli_isZero(r, num_words) || uECC_vli_isZero(s, num_words)) {
        return 0;
 8006ffc:	4658      	mov	r0, fp
 8006ffe:	e002      	b.n	8007006 <uECC_verify+0x30e>
 8007000:	4620      	mov	r0, r4
 8007002:	e000      	b.n	8007006 <uECC_verify+0x30e>
 8007004:	9802      	ldr	r0, [sp, #8]
        uECC_vli_sub(rx, rx, curve->n, num_n_words);
    }

    /* Accept only if v == r. */
    return (int)(uECC_vli_equal(rx, r, num_words));
}
 8007006:	b07f      	add	sp, #508	; 0x1fc
 8007008:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800700c <HAL_GetTick>:
const uint32_t MSIRangeTable[12] = {100000, 200000, 400000, 800000, 1000000, 2000000, \
                                  4000000, 8000000, 16000000, 24000000, 32000000, 48000000};
uint32_t SystemCoreClock;

// TODO: cleanup HAL stuff to not use this
uint32_t HAL_GetTick(void) { return 53; }
 800700c:	2035      	movs	r0, #53	; 0x35
 800700e:	4770      	bx	lr

08007010 <HAL_InitTick>:
uint32_t uwTickPrio = 0;            /* (1UL << __NVIC_PRIO_BITS); * Invalid priority */

// unwanted junk from stm32l4xx_hal_rcc.c
HAL_StatusTypeDef HAL_InitTick (uint32_t TickPriority) { return 0; }
 8007010:	2000      	movs	r0, #0
 8007012:	4770      	bx	lr

08007014 <HAL_PWREx_GetVoltageRange>:
  *         or PWR_REGULATOR_VOLTAGE_SCALE1_BOOST when applicable)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
#if defined(PWR_CR5_R1MODE)
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8007014:	4b07      	ldr	r3, [pc, #28]	; (8007034 <HAL_PWREx_GetVoltageRange+0x20>)
 8007016:	6818      	ldr	r0, [r3, #0]
 8007018:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 800701c:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 8007020:	d006      	beq.n	8007030 <HAL_PWREx_GetVoltageRange+0x1c>
    {
      return PWR_REGULATOR_VOLTAGE_SCALE2;
    }
    else if (READ_BIT(PWR->CR5, PWR_CR5_R1MODE) == PWR_CR5_R1MODE)
 8007022:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
    {
      /* PWR_CR5_R1MODE bit set means that Range 1 Boost is disabled */
      return PWR_REGULATOR_VOLTAGE_SCALE1;
 8007026:	f410 7080 	ands.w	r0, r0, #256	; 0x100
 800702a:	bf18      	it	ne
 800702c:	f44f 7000 	movne.w	r0, #512	; 0x200
      return PWR_REGULATOR_VOLTAGE_SCALE1_BOOST;
    }
#else
  return  (PWR->CR1 & PWR_CR1_VOS);
#endif
}
 8007030:	4770      	bx	lr
 8007032:	bf00      	nop
 8007034:	40007000 	.word	0x40007000

08007038 <HAL_PWREx_ControlVoltageScaling>:
  *        50 microseconds, HAL_TIMEOUT status is reported.
  * @retval HAL Status
  */
#define PWR_FLAG_SETTING_DELAY_US                      50UL   /*!< Time out value for REGLPF and VOSF flags setting */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
{
 8007038:	4b29      	ldr	r3, [pc, #164]	; (80070e0 <HAL_PWREx_ControlVoltageScaling+0xa8>)

#if defined(PWR_CR5_R1MODE)
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 800703a:	681a      	ldr	r2, [r3, #0]
  uint32_t wait_loop_index;

  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));

#if defined(PWR_CR5_R1MODE)
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
 800703c:	b9f0      	cbnz	r0, 800707c <HAL_PWREx_ControlVoltageScaling+0x44>
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 800703e:	f402 62c0 	and.w	r2, r2, #1536	; 0x600
 8007042:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
    {
      /* Make sure Range 1 Boost is enabled */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8007046:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 800704a:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800704e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

#if defined(PWR_CR5_R1MODE)
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8007052:	d138      	bne.n	80070c6 <HAL_PWREx_ControlVoltageScaling+0x8e>
    {
      /* Make sure Range 1 Boost is enabled */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);

      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8007054:	681a      	ldr	r2, [r3, #0]
 8007056:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 800705a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800705e:	601a      	str	r2, [r3, #0]

      /* Wait until VOSF is cleared */
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
 8007060:	4a20      	ldr	r2, [pc, #128]	; (80070e4 <HAL_PWREx_ControlVoltageScaling+0xac>)
 8007062:	6811      	ldr	r1, [r2, #0]
 8007064:	2232      	movs	r2, #50	; 0x32
 8007066:	434a      	muls	r2, r1
 8007068:	491f      	ldr	r1, [pc, #124]	; (80070e8 <HAL_PWREx_ControlVoltageScaling+0xb0>)
 800706a:	fbb2 f2f1 	udiv	r2, r2, r1
 800706e:	3201      	adds	r2, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8007070:	6959      	ldr	r1, [r3, #20]
 8007072:	0549      	lsls	r1, r1, #21
 8007074:	d521      	bpl.n	80070ba <HAL_PWREx_ControlVoltageScaling+0x82>
 8007076:	b302      	cbz	r2, 80070ba <HAL_PWREx_ControlVoltageScaling+0x82>
      {
        wait_loop_index--;
 8007078:	3a01      	subs	r2, #1
 800707a:	e7f9      	b.n	8007070 <HAL_PWREx_ControlVoltageScaling+0x38>
    {
      /* Enable Range 1 Boost (no issue if bit already reset) */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
    }
  }
  else if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 800707c:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8007080:	d126      	bne.n	80070d0 <HAL_PWREx_ControlVoltageScaling+0x98>
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8007082:	f402 62c0 	and.w	r2, r2, #1536	; 0x600
 8007086:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
    {
      /* Make sure Range 1 Boost is disabled */
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 800708a:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 800708e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8007092:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    }
  }
  else if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8007096:	d120      	bne.n	80070da <HAL_PWREx_ControlVoltageScaling+0xa2>
    {
      /* Make sure Range 1 Boost is disabled */
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);

      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8007098:	681a      	ldr	r2, [r3, #0]
 800709a:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 800709e:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80070a2:	601a      	str	r2, [r3, #0]

      /* Wait until VOSF is cleared */
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
 80070a4:	4a0f      	ldr	r2, [pc, #60]	; (80070e4 <HAL_PWREx_ControlVoltageScaling+0xac>)
 80070a6:	6811      	ldr	r1, [r2, #0]
 80070a8:	2232      	movs	r2, #50	; 0x32
 80070aa:	434a      	muls	r2, r1
 80070ac:	490e      	ldr	r1, [pc, #56]	; (80070e8 <HAL_PWREx_ControlVoltageScaling+0xb0>)
 80070ae:	fbb2 f2f1 	udiv	r2, r2, r1
 80070b2:	3201      	adds	r2, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80070b4:	6959      	ldr	r1, [r3, #20]
 80070b6:	0549      	lsls	r1, r1, #21
 80070b8:	d406      	bmi.n	80070c8 <HAL_PWREx_ControlVoltageScaling+0x90>
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
      {
        wait_loop_index--;
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 80070ba:	4b09      	ldr	r3, [pc, #36]	; (80070e0 <HAL_PWREx_ControlVoltageScaling+0xa8>)
 80070bc:	695b      	ldr	r3, [r3, #20]
 80070be:	0558      	lsls	r0, r3, #21
 80070c0:	d50b      	bpl.n	80070da <HAL_PWREx_ControlVoltageScaling+0xa2>
      {
        return HAL_TIMEOUT;
 80070c2:	2003      	movs	r0, #3
 80070c4:	4770      	bx	lr
 80070c6:	4770      	bx	lr
      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);

      /* Wait until VOSF is cleared */
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 80070c8:	2a00      	cmp	r2, #0
 80070ca:	d0f6      	beq.n	80070ba <HAL_PWREx_ControlVoltageScaling+0x82>
      {
        wait_loop_index--;
 80070cc:	3a01      	subs	r2, #1
 80070ce:	e7f1      	b.n	80070b4 <HAL_PWREx_ControlVoltageScaling+0x7c>
    }
  }
  else
  {
    /* Set Range 2 */
    MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 80070d0:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 80070d4:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80070d8:	601a      	str	r2, [r3, #0]
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
#endif

  return HAL_OK;
 80070da:	2000      	movs	r0, #0
}
 80070dc:	4770      	bx	lr
 80070de:	bf00      	nop
 80070e0:	40007000 	.word	0x40007000
 80070e4:	20000448 	.word	0x20000448
 80070e8:	000f4240 	.word	0x000f4240

080070ec <HAL_SDEx_DriveTransceiver_1_8V_Callback>:

__weak void HAL_SDEx_DriveTransceiver_1_8V_Callback(FlagStatus status)
{
 80070ec:	4770      	bx	lr
	...

080070f0 <se2_write1>:

// se2_write1()
//
    static bool
se2_write1(uint8_t cmd, uint8_t arg)
{
 80070f0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    uint8_t data[3] = { cmd, 1, arg };
 80070f2:	2301      	movs	r3, #1
 80070f4:	f88d 300d 	strb.w	r3, [sp, #13]

    HAL_StatusTypeDef rv = HAL_I2C_Master_Transmit(&i2c_port, I2C_ADDR, 
 80070f8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
// se2_write1()
//
    static bool
se2_write1(uint8_t cmd, uint8_t arg)
{
    uint8_t data[3] = { cmd, 1, arg };
 80070fc:	f88d 000c 	strb.w	r0, [sp, #12]
 8007100:	f88d 100e 	strb.w	r1, [sp, #14]

    HAL_StatusTypeDef rv = HAL_I2C_Master_Transmit(&i2c_port, I2C_ADDR, 
 8007104:	9300      	str	r3, [sp, #0]
 8007106:	aa03      	add	r2, sp, #12
 8007108:	2303      	movs	r3, #3
 800710a:	2136      	movs	r1, #54	; 0x36
 800710c:	4804      	ldr	r0, [pc, #16]	; (8007120 <se2_write1+0x30>)
 800710e:	f004 fb33 	bl	800b778 <HAL_I2C_Master_Transmit>
                                                    data, sizeof(data), HAL_MAX_DELAY);

    return (rv != HAL_OK);
}
 8007112:	3000      	adds	r0, #0
 8007114:	bf18      	it	ne
 8007116:	2001      	movne	r0, #1
 8007118:	b005      	add	sp, #20
 800711a:	f85d fb04 	ldr.w	pc, [sp], #4
 800711e:	bf00      	nop
 8007120:	2000023c 	.word	0x2000023c

08007124 <se2_write_n>:

// se2_write_n()
//
    static bool
se2_write_n(uint8_t cmd, uint8_t *param1, const uint8_t *data_in, uint8_t len)
{
 8007124:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint8_t data[2 + (param1?1:0) + len], *p = data;
 8007126:	2900      	cmp	r1, #0
 8007128:	bf14      	ite	ne
 800712a:	2403      	movne	r4, #3
 800712c:	2402      	moveq	r4, #2
 800712e:	441c      	add	r4, r3

// se2_write_n()
//
    static bool
se2_write_n(uint8_t cmd, uint8_t *param1, const uint8_t *data_in, uint8_t len)
{
 8007130:	4616      	mov	r6, r2
 8007132:	461a      	mov	r2, r3
    uint8_t data[2 + (param1?1:0) + len], *p = data;
 8007134:	f104 0307 	add.w	r3, r4, #7

// se2_write_n()
//
    static bool
se2_write_n(uint8_t cmd, uint8_t *param1, const uint8_t *data_in, uint8_t len)
{
 8007138:	b083      	sub	sp, #12
    uint8_t data[2 + (param1?1:0) + len], *p = data;
 800713a:	f023 0307 	bic.w	r3, r3, #7

// se2_write_n()
//
    static bool
se2_write_n(uint8_t cmd, uint8_t *param1, const uint8_t *data_in, uint8_t len)
{
 800713e:	af02      	add	r7, sp, #8
    uint8_t data[2 + (param1?1:0) + len], *p = data;
 8007140:	ebad 0d03 	sub.w	sp, sp, r3
 8007144:	ad02      	add	r5, sp, #8

    *(p++) = cmd;
    *(p++) = sizeof(data) - 2;
 8007146:	f1a4 0302 	sub.w	r3, r4, #2
    static bool
se2_write_n(uint8_t cmd, uint8_t *param1, const uint8_t *data_in, uint8_t len)
{
    uint8_t data[2 + (param1?1:0) + len], *p = data;

    *(p++) = cmd;
 800714a:	f88d 0008 	strb.w	r0, [sp, #8]
    *(p++) = sizeof(data) - 2;
 800714e:	706b      	strb	r3, [r5, #1]
    if(param1) {
        *(p++) = *param1;
 8007150:	bf1b      	ittet	ne
 8007152:	780b      	ldrbne	r3, [r1, #0]
 8007154:	70ab      	strbne	r3, [r5, #2]
se2_write_n(uint8_t cmd, uint8_t *param1, const uint8_t *data_in, uint8_t len)
{
    uint8_t data[2 + (param1?1:0) + len], *p = data;

    *(p++) = cmd;
    *(p++) = sizeof(data) - 2;
 8007156:	f10d 000a 	addeq.w	r0, sp, #10
    if(param1) {
        *(p++) = *param1;
 800715a:	f10d 000b 	addne.w	r0, sp, #11
    }
    if(len) {
 800715e:	b112      	cbz	r2, 8007166 <se2_write_n+0x42>
        memcpy(p, data_in, len);
 8007160:	4631      	mov	r1, r6
 8007162:	f006 f98a 	bl	800d47a <memcpy>
    }

    HAL_StatusTypeDef rv = HAL_I2C_Master_Transmit(&i2c_port, I2C_ADDR,
 8007166:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800716a:	9300      	str	r3, [sp, #0]
 800716c:	462a      	mov	r2, r5
 800716e:	b2a3      	uxth	r3, r4
 8007170:	2136      	movs	r1, #54	; 0x36
 8007172:	4804      	ldr	r0, [pc, #16]	; (8007184 <se2_write_n+0x60>)
 8007174:	f004 fb00 	bl	800b778 <HAL_I2C_Master_Transmit>
                                                    data, sizeof(data), HAL_MAX_DELAY);

    return (rv != HAL_OK);
}
 8007178:	3000      	adds	r0, #0
 800717a:	bf18      	it	ne
 800717c:	2001      	movne	r0, #1
 800717e:	3704      	adds	r7, #4
 8007180:	46bd      	mov	sp, r7
 8007182:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007184:	2000023c 	.word	0x2000023c

08007188 <se2_read_n>:
se2_read_n(uint8_t len, uint8_t *rx)
{
    // Response time of the chip varies from 0ms (read buffer), is typically
    // 3ms for simple things, and peaks at 200ms for complex ECC stuff.
    // Poll until chip provides an answer.
    ASSERT(len >= 2);
 8007188:	2801      	cmp	r0, #1

// se2_read_n()
//
    static uint8_t
se2_read_n(uint8_t len, uint8_t *rx)
{
 800718a:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 800718e:	4604      	mov	r4, r0
 8007190:	460e      	mov	r6, r1
    // Response time of the chip varies from 0ms (read buffer), is typically
    // 3ms for simple things, and peaks at 200ms for complex ECC stuff.
    // Poll until chip provides an answer.
    ASSERT(len >= 2);
 8007192:	d802      	bhi.n	800719a <se2_read_n+0x12>
 8007194:	4810      	ldr	r0, [pc, #64]	; (80071d8 <se2_read_n+0x50>)
 8007196:	f7f9 fc21 	bl	80009dc <fatal_error>
 800719a:	f44f 7596 	mov.w	r5, #300	; 0x12c

    for(int tries=0; tries<300; tries++) {
        HAL_StatusTypeDef rv = HAL_I2C_Master_Receive(&i2c_port, I2C_ADDR, rx, len, HAL_MAX_DELAY);
 800719e:	b287      	uxth	r7, r0
 80071a0:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
 80071a4:	f8cd 8000 	str.w	r8, [sp]
 80071a8:	463b      	mov	r3, r7
 80071aa:	4632      	mov	r2, r6
 80071ac:	2136      	movs	r1, #54	; 0x36
 80071ae:	480b      	ldr	r0, [pc, #44]	; (80071dc <se2_read_n+0x54>)
 80071b0:	f004 fb92 	bl	800b8d8 <HAL_I2C_Master_Receive>
        if(rv == HAL_OK) {
 80071b4:	b928      	cbnz	r0, 80071c2 <se2_read_n+0x3a>
            if(rx[0] != len-1) {
 80071b6:	7833      	ldrb	r3, [r6, #0]
 80071b8:	3c01      	subs	r4, #1
 80071ba:	42a3      	cmp	r3, r4
 80071bc:	d108      	bne.n	80071d0 <se2_read_n+0x48>
                return RC_WRONG_SIZE;
            }

            return rx[1];
 80071be:	7870      	ldrb	r0, [r6, #1]
 80071c0:	e007      	b.n	80071d2 <se2_read_n+0x4a>
        }

        delay_ms(1);
 80071c2:	2001      	movs	r0, #1
 80071c4:	f7fc fb60 	bl	8003888 <delay_ms>
    // Response time of the chip varies from 0ms (read buffer), is typically
    // 3ms for simple things, and peaks at 200ms for complex ECC stuff.
    // Poll until chip provides an answer.
    ASSERT(len >= 2);

    for(int tries=0; tries<300; tries++) {
 80071c8:	3d01      	subs	r5, #1
 80071ca:	d1eb      	bne.n	80071a4 <se2_read_n+0x1c>

        delay_ms(1);
    }

    // timeout
    return RC_NO_ACK;
 80071cc:	200f      	movs	r0, #15
 80071ce:	e000      	b.n	80071d2 <se2_read_n+0x4a>

    for(int tries=0; tries<300; tries++) {
        HAL_StatusTypeDef rv = HAL_I2C_Master_Receive(&i2c_port, I2C_ADDR, rx, len, HAL_MAX_DELAY);
        if(rv == HAL_OK) {
            if(rx[0] != len-1) {
                return RC_WRONG_SIZE;
 80071d0:	201f      	movs	r0, #31
        delay_ms(1);
    }

    // timeout
    return RC_NO_ACK;
}
 80071d2:	b002      	add	sp, #8
 80071d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80071d8:	0800d550 	.word	0x0800d550
 80071dc:	2000023c 	.word	0x2000023c

080071e0 <se2_read1>:

// se2_read1()
//
    static uint8_t
se2_read1(void)
{
 80071e0:	b507      	push	{r0, r1, r2, lr}
    // many commands return a single (framed) status byte, where 0xAA == success
    uint8_t rx[2];

    return se2_read_n(2, rx);
 80071e2:	2002      	movs	r0, #2
 80071e4:	a901      	add	r1, sp, #4
 80071e6:	f7ff ffcf 	bl	8007188 <se2_read_n>
}
 80071ea:	b003      	add	sp, #12
 80071ec:	f85d fb04 	ldr.w	pc, [sp], #4

080071f0 <rng_for_uECC>:

// rng_for_uECC()
//
    static int
rng_for_uECC(uint8_t *dest, unsigned size)
{
 80071f0:	b508      	push	{r3, lr}
    'dest' was filled with random data, or 0 if the random data could not be generated.
    The filled-in values should be either truly random, or from a cryptographically-secure PRNG.

    typedef int (*uECC_RNG_Function)(uint8_t *dest, unsigned size);
    */
    rng_buffer(dest, size);
 80071f2:	f7fb fa89 	bl	8002708 <rng_buffer>

    return 1;
}
 80071f6:	2001      	movs	r0, #1
 80071f8:	bd08      	pop	{r3, pc}
	...

080071fc <se2_write_buffer>:

// se2_write_buffer()
//
    static void
se2_write_buffer(const uint8_t *data, int len)
{
 80071fc:	b508      	push	{r3, lr}
    // no response to this command, just blindly write it
    CALL_CHECK(se2_write_n(0x87, NULL, data, len));
 80071fe:	4602      	mov	r2, r0
 8007200:	b2cb      	uxtb	r3, r1
 8007202:	2087      	movs	r0, #135	; 0x87
 8007204:	2100      	movs	r1, #0
 8007206:	f7ff ff8d 	bl	8007124 <se2_write_n>
 800720a:	b118      	cbz	r0, 8007214 <se2_write_buffer+0x18>
 800720c:	21be      	movs	r1, #190	; 0xbe
 800720e:	4802      	ldr	r0, [pc, #8]	; (8007218 <se2_write_buffer+0x1c>)
 8007210:	f006 f968 	bl	800d4e4 <longjmp>
 8007214:	bd08      	pop	{r3, pc}
 8007216:	bf00      	nop
 8007218:	20000288 	.word	0x20000288

0800721c <se2_write_page>:
//
// Caution: Can be read and/or intercepted.
//
    void
se2_write_page(uint8_t page_num, const uint8_t data[32])
{
 800721c:	b513      	push	{r0, r1, r4, lr}
 800721e:	ac02      	add	r4, sp, #8
    CALL_CHECK(se2_write_n(0x96, &page_num, data, 32));
 8007220:	460a      	mov	r2, r1
//
// Caution: Can be read and/or intercepted.
//
    void
se2_write_page(uint8_t page_num, const uint8_t data[32])
{
 8007222:	f804 0d01 	strb.w	r0, [r4, #-1]!
    CALL_CHECK(se2_write_n(0x96, &page_num, data, 32));
 8007226:	2320      	movs	r3, #32
 8007228:	4621      	mov	r1, r4
 800722a:	2096      	movs	r0, #150	; 0x96
 800722c:	f7ff ff7a 	bl	8007124 <se2_write_n>
 8007230:	b108      	cbz	r0, 8007236 <se2_write_page+0x1a>
 8007232:	21c8      	movs	r1, #200	; 0xc8
 8007234:	e004      	b.n	8007240 <se2_write_page+0x24>

    CHECK_RIGHT(se2_read1() == RC_SUCCESS);
 8007236:	f7ff ffd3 	bl	80071e0 <se2_read1>
 800723a:	28aa      	cmp	r0, #170	; 0xaa
 800723c:	d003      	beq.n	8007246 <se2_write_page+0x2a>
 800723e:	21ca      	movs	r1, #202	; 0xca
 8007240:	4802      	ldr	r0, [pc, #8]	; (800724c <se2_write_page+0x30>)
 8007242:	f006 f94f 	bl	800d4e4 <longjmp>
}
 8007246:	b002      	add	sp, #8
 8007248:	bd10      	pop	{r4, pc}
 800724a:	bf00      	nop
 800724c:	20000288 	.word	0x20000288

08007250 <se2_pick_keypair>:
//
    void
se2_pick_keypair(uint8_t pubkey_num, bool lock)
{
    // use device RNG to pick a keypair
    ASSERT(pubkey_num < 2);
 8007250:	2801      	cmp	r0, #1

// se2_pick_keypair()
//
    void
se2_pick_keypair(uint8_t pubkey_num, bool lock)
{
 8007252:	b508      	push	{r3, lr}
    // use device RNG to pick a keypair
    ASSERT(pubkey_num < 2);
 8007254:	d902      	bls.n	800725c <se2_pick_keypair+0xc>
 8007256:	480a      	ldr	r0, [pc, #40]	; (8007280 <se2_pick_keypair+0x30>)
 8007258:	f7f9 fbc0 	bl	80009dc <fatal_error>

    int wpe = lock ? 0x1 : 0x0;
    CALL_CHECK(se2_write1(0xcb, (wpe <<6) | pubkey_num));
 800725c:	ea40 1181 	orr.w	r1, r0, r1, lsl #6
 8007260:	b2c9      	uxtb	r1, r1
 8007262:	20cb      	movs	r0, #203	; 0xcb
 8007264:	f7ff ff44 	bl	80070f0 <se2_write1>
 8007268:	b108      	cbz	r0, 800726e <se2_pick_keypair+0x1e>
 800726a:	21d6      	movs	r1, #214	; 0xd6
 800726c:	e004      	b.n	8007278 <se2_pick_keypair+0x28>

    CHECK_RIGHT(se2_read1() == RC_SUCCESS);
 800726e:	f7ff ffb7 	bl	80071e0 <se2_read1>
 8007272:	28aa      	cmp	r0, #170	; 0xaa
 8007274:	d003      	beq.n	800727e <se2_pick_keypair+0x2e>
 8007276:	21d8      	movs	r1, #216	; 0xd8
 8007278:	4802      	ldr	r0, [pc, #8]	; (8007284 <se2_pick_keypair+0x34>)
 800727a:	f006 f933 	bl	800d4e4 <longjmp>
 800727e:	bd08      	pop	{r3, pc}
 8007280:	0800d550 	.word	0x0800d550
 8007284:	20000288 	.word	0x20000288

08007288 <se2_verify_page>:

// se2_verify_page()
//
    bool
se2_verify_page(uint8_t page_num, uint8_t data[32], int keynum, const uint8_t *secret)
{
 8007288:	b570      	push	{r4, r5, r6, lr}
 800728a:	b0dc      	sub	sp, #368	; 0x170
 800728c:	460d      	mov	r5, r1
 800728e:	f88d 0007 	strb.w	r0, [sp, #7]
    // "Compute and Read Page Authentication" using HMAC secret A or S

    // .. pick a nonce
    uint8_t chal[32];
    rng_buffer(chal, sizeof(chal));
 8007292:	2120      	movs	r1, #32
 8007294:	a802      	add	r0, sp, #8

// se2_verify_page()
//
    bool
se2_verify_page(uint8_t page_num, uint8_t data[32], int keynum, const uint8_t *secret)
{
 8007296:	4616      	mov	r6, r2
 8007298:	461c      	mov	r4, r3
    // "Compute and Read Page Authentication" using HMAC secret A or S

    // .. pick a nonce
    uint8_t chal[32];
    rng_buffer(chal, sizeof(chal));
 800729a:	f7fb fa35 	bl	8002708 <rng_buffer>
    se2_write_buffer(chal, sizeof(chal));
 800729e:	2120      	movs	r1, #32
 80072a0:	a802      	add	r0, sp, #8
 80072a2:	f7ff ffab 	bl	80071fc <se2_write_buffer>
    
    // .. do it (HMAC method, not ECDSA)
    CALL_CHECK(se2_write1(0xa5, (keynum<<5) | page_num));
 80072a6:	f89d 1007 	ldrb.w	r1, [sp, #7]
 80072aa:	ea41 1146 	orr.w	r1, r1, r6, lsl #5
 80072ae:	b2c9      	uxtb	r1, r1
 80072b0:	20a5      	movs	r0, #165	; 0xa5
 80072b2:	f7ff ff1d 	bl	80070f0 <se2_write1>
 80072b6:	b108      	cbz	r0, 80072bc <se2_verify_page+0x34>
 80072b8:	21e8      	movs	r1, #232	; 0xe8
 80072ba:	e006      	b.n	80072ca <se2_verify_page+0x42>

    uint8_t check[34];
    CHECK_RIGHT(se2_read_n(sizeof(check), check) == RC_SUCCESS);
 80072bc:	a912      	add	r1, sp, #72	; 0x48
 80072be:	2022      	movs	r0, #34	; 0x22
 80072c0:	f7ff ff62 	bl	8007188 <se2_read_n>
 80072c4:	28aa      	cmp	r0, #170	; 0xaa
 80072c6:	d003      	beq.n	80072d0 <se2_verify_page+0x48>
 80072c8:	21eb      	movs	r1, #235	; 0xeb
 80072ca:	481b      	ldr	r0, [pc, #108]	; (8007338 <se2_verify_page+0xb0>)
 80072cc:	f006 f90a 	bl	800d4e4 <longjmp>

    // .. see if we can arrive at same HMAC result.

    HMAC_CTX ctx;
    hmac_sha256_init(&ctx);
 80072d0:	a81b      	add	r0, sp, #108	; 0x6c
 80072d2:	f7fe f8c7 	bl	8005464 <hmac_sha256_init>

    //  msg = self.rom_id + expected + chal + bytes([page_num]) + self.manid
    hmac_sha256_update(&ctx, SE2_SECRETS->romid, 8);
 80072d6:	4b19      	ldr	r3, [pc, #100]	; (800733c <se2_verify_page+0xb4>)
 80072d8:	4a19      	ldr	r2, [pc, #100]	; (8007340 <se2_verify_page+0xb8>)
 80072da:	f893 10b0 	ldrb.w	r1, [r3, #176]	; 0xb0
 80072de:	4b19      	ldr	r3, [pc, #100]	; (8007344 <se2_verify_page+0xbc>)
 80072e0:	29ff      	cmp	r1, #255	; 0xff
 80072e2:	bf0c      	ite	eq
 80072e4:	4619      	moveq	r1, r3
 80072e6:	4611      	movne	r1, r2
 80072e8:	a81b      	add	r0, sp, #108	; 0x6c
 80072ea:	2208      	movs	r2, #8
 80072ec:	3160      	adds	r1, #96	; 0x60
 80072ee:	f7fe f8bf 	bl	8005470 <hmac_sha256_update>
    hmac_sha256_update(&ctx, data, 32);
 80072f2:	4629      	mov	r1, r5
 80072f4:	a81b      	add	r0, sp, #108	; 0x6c
 80072f6:	2220      	movs	r2, #32
 80072f8:	f7fe f8ba 	bl	8005470 <hmac_sha256_update>
    hmac_sha256_update(&ctx, chal, 32);
 80072fc:	a902      	add	r1, sp, #8
 80072fe:	a81b      	add	r0, sp, #108	; 0x6c
 8007300:	2220      	movs	r2, #32
 8007302:	f7fe f8b5 	bl	8005470 <hmac_sha256_update>
    hmac_sha256_update(&ctx, &page_num, 1);
 8007306:	f10d 0107 	add.w	r1, sp, #7
 800730a:	a81b      	add	r0, sp, #108	; 0x6c
 800730c:	2201      	movs	r2, #1
 800730e:	f7fe f8af 	bl	8005470 <hmac_sha256_update>
    hmac_sha256_update(&ctx, DEV_MANID, 2);
 8007312:	a81b      	add	r0, sp, #108	; 0x6c
 8007314:	2202      	movs	r2, #2
 8007316:	490c      	ldr	r1, [pc, #48]	; (8007348 <se2_verify_page+0xc0>)
 8007318:	f7fe f8aa 	bl	8005470 <hmac_sha256_update>

    uint8_t expect[32];
    hmac_sha256_final(&ctx, secret, expect);
 800731c:	aa0a      	add	r2, sp, #40	; 0x28
 800731e:	4621      	mov	r1, r4
 8007320:	a81b      	add	r0, sp, #108	; 0x6c
 8007322:	f7fe f8bb 	bl	800549c <hmac_sha256_final>

    return check_equal(expect, check+2, 32);
 8007326:	2220      	movs	r2, #32
 8007328:	f10d 014a 	add.w	r1, sp, #74	; 0x4a
 800732c:	a80a      	add	r0, sp, #40	; 0x28
 800732e:	f7fb f99a 	bl	8002666 <check_equal>
}
 8007332:	b05c      	add	sp, #368	; 0x170
 8007334:	bd70      	pop	{r4, r5, r6, pc}
 8007336:	bf00      	nop
 8007338:	20000288 	.word	0x20000288
 800733c:	0801e000 	.word	0x0801e000
 8007340:	0801e0b0 	.word	0x0801e0b0
 8007344:	200002e4 	.word	0x200002e4
 8007348:	0800e77f 	.word	0x0800e77f

0800734c <se2_read_page>:
// Must always authenticate what we read, because just normal read (no encryption)
// does not have any MiTM protection at all.
//
    void
se2_read_page(uint8_t page_num, uint8_t data[32], bool verify)
{
 800734c:	b570      	push	{r4, r5, r6, lr}
 800734e:	4604      	mov	r4, r0
 8007350:	b08a      	sub	sp, #40	; 0x28
 8007352:	460d      	mov	r5, r1
    CALL_CHECK(se2_write1(0x69, page_num));
 8007354:	4601      	mov	r1, r0
 8007356:	2069      	movs	r0, #105	; 0x69
// Must always authenticate what we read, because just normal read (no encryption)
// does not have any MiTM protection at all.
//
    void
se2_read_page(uint8_t page_num, uint8_t data[32], bool verify)
{
 8007358:	4616      	mov	r6, r2
    CALL_CHECK(se2_write1(0x69, page_num));
 800735a:	f7ff fec9 	bl	80070f0 <se2_write1>
 800735e:	b110      	cbz	r0, 8007366 <se2_read_page+0x1a>
 8007360:	f240 1107 	movw	r1, #263	; 0x107
 8007364:	e007      	b.n	8007376 <se2_read_page+0x2a>

    uint8_t rx[2+32];
    CHECK_RIGHT(se2_read_n(sizeof(rx), rx) == RC_SUCCESS);
 8007366:	a901      	add	r1, sp, #4
 8007368:	2022      	movs	r0, #34	; 0x22
 800736a:	f7ff ff0d 	bl	8007188 <se2_read_n>
 800736e:	28aa      	cmp	r0, #170	; 0xaa
 8007370:	d004      	beq.n	800737c <se2_read_page+0x30>
 8007372:	f44f 7185 	mov.w	r1, #266	; 0x10a
 8007376:	4818      	ldr	r0, [pc, #96]	; (80073d8 <se2_read_page+0x8c>)
 8007378:	f006 f8b4 	bl	800d4e4 <longjmp>

    CHECK_RIGHT(rx[0] == 33);
 800737c:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8007380:	2b21      	cmp	r3, #33	; 0x21
 8007382:	d002      	beq.n	800738a <se2_read_page+0x3e>
 8007384:	f44f 7186 	mov.w	r1, #268	; 0x10c
 8007388:	e7f5      	b.n	8007376 <se2_read_page+0x2a>
    CHECK_RIGHT(rx[1] == RC_SUCCESS);
 800738a:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800738e:	2baa      	cmp	r3, #170	; 0xaa
 8007390:	d002      	beq.n	8007398 <se2_read_page+0x4c>
 8007392:	f240 110d 	movw	r1, #269	; 0x10d
 8007396:	e7ee      	b.n	8007376 <se2_read_page+0x2a>

    memcpy(data, rx+2, 32);
 8007398:	f10d 0306 	add.w	r3, sp, #6
 800739c:	462a      	mov	r2, r5
 800739e:	f10d 0126 	add.w	r1, sp, #38	; 0x26
 80073a2:	f853 0b04 	ldr.w	r0, [r3], #4
 80073a6:	f842 0b04 	str.w	r0, [r2], #4
 80073aa:	428b      	cmp	r3, r1
 80073ac:	d1f9      	bne.n	80073a2 <se2_read_page+0x56>

    if(!verify) return;
 80073ae:	b186      	cbz	r6, 80073d2 <se2_read_page+0x86>

    CHECK_RIGHT(se2_verify_page(page_num, data, 0, SE2_SECRETS->pairing));
 80073b0:	4b0a      	ldr	r3, [pc, #40]	; (80073dc <se2_read_page+0x90>)
 80073b2:	4a0b      	ldr	r2, [pc, #44]	; (80073e0 <se2_read_page+0x94>)
 80073b4:	f893 10b0 	ldrb.w	r1, [r3, #176]	; 0xb0
 80073b8:	4b0a      	ldr	r3, [pc, #40]	; (80073e4 <se2_read_page+0x98>)
 80073ba:	4620      	mov	r0, r4
 80073bc:	29ff      	cmp	r1, #255	; 0xff
 80073be:	bf18      	it	ne
 80073c0:	4613      	movne	r3, r2
 80073c2:	2200      	movs	r2, #0
 80073c4:	4629      	mov	r1, r5
 80073c6:	f7ff ff5f 	bl	8007288 <se2_verify_page>
 80073ca:	b910      	cbnz	r0, 80073d2 <se2_read_page+0x86>
 80073cc:	f240 1113 	movw	r1, #275	; 0x113
 80073d0:	e7d1      	b.n	8007376 <se2_read_page+0x2a>
}
 80073d2:	b00a      	add	sp, #40	; 0x28
 80073d4:	bd70      	pop	{r4, r5, r6, pc}
 80073d6:	bf00      	nop
 80073d8:	20000288 	.word	0x20000288
 80073dc:	0801e000 	.word	0x0801e000
 80073e0:	0801e0b0 	.word	0x0801e0b0
 80073e4:	200002e4 	.word	0x200002e4

080073e8 <se2_read_encrypted>:
// - use key to read, but must also do verify because no replay protection otherwise
// - page must be protected with EPH or ECH, and of course !RP
//
    void
se2_read_encrypted(uint8_t page_num, uint8_t data[32], int keynum, const uint8_t *secret)
{
 80073e8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80073ea:	b0d7      	sub	sp, #348	; 0x15c
 80073ec:	461e      	mov	r6, r3
    // only supporting secret A or S.
    ASSERT((keynum == 0) || (keynum == 2));
 80073ee:	f032 0302 	bics.w	r3, r2, #2
// - use key to read, but must also do verify because no replay protection otherwise
// - page must be protected with EPH or ECH, and of course !RP
//
    void
se2_read_encrypted(uint8_t page_num, uint8_t data[32], int keynum, const uint8_t *secret)
{
 80073f2:	460c      	mov	r4, r1
 80073f4:	4615      	mov	r5, r2
 80073f6:	f88d 0007 	strb.w	r0, [sp, #7]
    // only supporting secret A or S.
    ASSERT((keynum == 0) || (keynum == 2));
 80073fa:	d002      	beq.n	8007402 <se2_read_encrypted+0x1a>
 80073fc:	4835      	ldr	r0, [pc, #212]	; (80074d4 <se2_read_encrypted+0xec>)
 80073fe:	f7f9 faed 	bl	80009dc <fatal_error>

    CALL_CHECK(se2_write1(0x4b, (keynum << 6) | page_num));
 8007402:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8007406:	ea41 1182 	orr.w	r1, r1, r2, lsl #6
 800740a:	b2c9      	uxtb	r1, r1
 800740c:	204b      	movs	r0, #75	; 0x4b
 800740e:	f7ff fe6f 	bl	80070f0 <se2_write1>
 8007412:	b110      	cbz	r0, 800741a <se2_read_encrypted+0x32>
 8007414:	f240 1163 	movw	r1, #355	; 0x163
 8007418:	e007      	b.n	800742a <se2_read_encrypted+0x42>

    uint8_t rx[2+8+32];
    CHECK_RIGHT(se2_read_n(sizeof(rx), rx) == RC_SUCCESS);
 800741a:	a90a      	add	r1, sp, #40	; 0x28
 800741c:	202a      	movs	r0, #42	; 0x2a
 800741e:	f7ff feb3 	bl	8007188 <se2_read_n>
 8007422:	28aa      	cmp	r0, #170	; 0xaa
 8007424:	d004      	beq.n	8007430 <se2_read_encrypted+0x48>
 8007426:	f44f 71b3 	mov.w	r1, #358	; 0x166
 800742a:	482b      	ldr	r0, [pc, #172]	; (80074d8 <se2_read_encrypted+0xf0>)
 800742c:	f006 f85a 	bl	800d4e4 <longjmp>

    CHECK_RIGHT(rx[1] == RC_SUCCESS);
 8007430:	f89d 3029 	ldrb.w	r3, [sp, #41]	; 0x29
 8007434:	2baa      	cmp	r3, #170	; 0xaa
 8007436:	d002      	beq.n	800743e <se2_read_encrypted+0x56>
 8007438:	f44f 71b4 	mov.w	r1, #360	; 0x168
 800743c:	e7f5      	b.n	800742a <se2_read_encrypted+0x42>

    // .. decrypt result.
    uint8_t *chal = rx+2;
    memcpy(data, rx+2+8, 32);
 800743e:	f10d 0332 	add.w	r3, sp, #50	; 0x32
 8007442:	4622      	mov	r2, r4
 8007444:	f10d 0152 	add.w	r1, sp, #82	; 0x52
 8007448:	f853 0b04 	ldr.w	r0, [r3], #4
 800744c:	f842 0b04 	str.w	r0, [r2], #4
 8007450:	428b      	cmp	r3, r1
 8007452:	d1f9      	bne.n	8007448 <se2_read_encrypted+0x60>

    HMAC_CTX ctx;
    hmac_sha256_init(&ctx);
 8007454:	a815      	add	r0, sp, #84	; 0x54
 8007456:	f7fe f805 	bl	8005464 <hmac_sha256_init>

    //  msg = chal + self.rom_id + bytes([page_num]) + self.manid
    hmac_sha256_update(&ctx, chal, 8);
 800745a:	2208      	movs	r2, #8
 800745c:	f10d 012a 	add.w	r1, sp, #42	; 0x2a
 8007460:	a815      	add	r0, sp, #84	; 0x54
 8007462:	f7fe f805 	bl	8005470 <hmac_sha256_update>
    hmac_sha256_update(&ctx, SE2_SECRETS->romid, 8);
 8007466:	4b1d      	ldr	r3, [pc, #116]	; (80074dc <se2_read_encrypted+0xf4>)
 8007468:	4a1d      	ldr	r2, [pc, #116]	; (80074e0 <se2_read_encrypted+0xf8>)
 800746a:	f893 10b0 	ldrb.w	r1, [r3, #176]	; 0xb0
 800746e:	4b1d      	ldr	r3, [pc, #116]	; (80074e4 <se2_read_encrypted+0xfc>)
 8007470:	29ff      	cmp	r1, #255	; 0xff
 8007472:	bf0c      	ite	eq
 8007474:	4619      	moveq	r1, r3
 8007476:	4611      	movne	r1, r2
 8007478:	3160      	adds	r1, #96	; 0x60
 800747a:	2208      	movs	r2, #8
 800747c:	a815      	add	r0, sp, #84	; 0x54
 800747e:	f7fd fff7 	bl	8005470 <hmac_sha256_update>
    hmac_sha256_update(&ctx, &page_num, 1);
 8007482:	2201      	movs	r2, #1
 8007484:	f10d 0107 	add.w	r1, sp, #7
 8007488:	a815      	add	r0, sp, #84	; 0x54
 800748a:	f7fd fff1 	bl	8005470 <hmac_sha256_update>
    hmac_sha256_update(&ctx, DEV_MANID, 2);

    uint8_t otp[32];
    hmac_sha256_final(&ctx, secret, otp);
 800748e:	af02      	add	r7, sp, #8

    //  msg = chal + self.rom_id + bytes([page_num]) + self.manid
    hmac_sha256_update(&ctx, chal, 8);
    hmac_sha256_update(&ctx, SE2_SECRETS->romid, 8);
    hmac_sha256_update(&ctx, &page_num, 1);
    hmac_sha256_update(&ctx, DEV_MANID, 2);
 8007490:	2202      	movs	r2, #2
 8007492:	4915      	ldr	r1, [pc, #84]	; (80074e8 <se2_read_encrypted+0x100>)
 8007494:	a815      	add	r0, sp, #84	; 0x54
 8007496:	f7fd ffeb 	bl	8005470 <hmac_sha256_update>

    uint8_t otp[32];
    hmac_sha256_final(&ctx, secret, otp);
 800749a:	463a      	mov	r2, r7
 800749c:	4631      	mov	r1, r6
 800749e:	a815      	add	r0, sp, #84	; 0x54
 80074a0:	f7fd fffc 	bl	800549c <hmac_sha256_final>
 80074a4:	4622      	mov	r2, r4
 80074a6:	2300      	movs	r3, #0
		*(acc) ^= *(more);
 80074a8:	7810      	ldrb	r0, [r2, #0]
 80074aa:	5cf9      	ldrb	r1, [r7, r3]
 80074ac:	3301      	adds	r3, #1
 80074ae:	4041      	eors	r1, r0
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 80074b0:	2b20      	cmp	r3, #32
		*(acc) ^= *(more);
 80074b2:	f802 1b01 	strb.w	r1, [r2], #1
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 80074b6:	d1f7      	bne.n	80074a8 <se2_read_encrypted+0xc0>

    xor_mixin(data, otp, 32);

    // CRITICAL: verify right result using a nonce we pick!
    CHECK_RIGHT(se2_verify_page(page_num, data, keynum, secret));
 80074b8:	4633      	mov	r3, r6
 80074ba:	462a      	mov	r2, r5
 80074bc:	4621      	mov	r1, r4
 80074be:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80074c2:	f7ff fee1 	bl	8007288 <se2_verify_page>
 80074c6:	b910      	cbnz	r0, 80074ce <se2_read_encrypted+0xe6>
 80074c8:	f240 117d 	movw	r1, #381	; 0x17d
 80074cc:	e7ad      	b.n	800742a <se2_read_encrypted+0x42>
}
 80074ce:	b057      	add	sp, #348	; 0x15c
 80074d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80074d2:	bf00      	nop
 80074d4:	0800d550 	.word	0x0800d550
 80074d8:	20000288 	.word	0x20000288
 80074dc:	0801e000 	.word	0x0801e000
 80074e0:	0801e0b0 	.word	0x0801e0b0
 80074e4:	200002e4 	.word	0x200002e4
 80074e8:	0800e77f 	.word	0x0800e77f

080074ec <se2_write_encrypted>:
// - needs existing value to pass auth challenge (so we re-read it)
// - so cannot be used on read-protected pages like keys
//
    void
se2_write_encrypted(uint8_t page_num, const uint8_t data[32], int keynum, const uint8_t *secret)
{
 80074ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80074f0:	460f      	mov	r7, r1
    // only supporting secret A or S.
    ASSERT((keynum == 0) || (keynum == 2));
 80074f2:	f032 0102 	bics.w	r1, r2, #2
// - needs existing value to pass auth challenge (so we re-read it)
// - so cannot be used on read-protected pages like keys
//
    void
se2_write_encrypted(uint8_t page_num, const uint8_t data[32], int keynum, const uint8_t *secret)
{
 80074f6:	b0e4      	sub	sp, #400	; 0x190
 80074f8:	4606      	mov	r6, r0
 80074fa:	4690      	mov	r8, r2
 80074fc:	4699      	mov	r9, r3
    // only supporting secret A or S.
    ASSERT((keynum == 0) || (keynum == 2));
 80074fe:	d002      	beq.n	8007506 <se2_write_encrypted+0x1a>
 8007500:	484d      	ldr	r0, [pc, #308]	; (8007638 <se2_write_encrypted+0x14c>)
 8007502:	f7f9 fa6b 	bl	80009dc <fatal_error>

    // need old value to for authentication purposes
    uint8_t     old_data[32];
    se2_read_encrypted(page_num, old_data, keynum, secret);
 8007506:	a901      	add	r1, sp, #4
 8007508:	f7ff ff6e 	bl	80073e8 <se2_read_encrypted>

    uint8_t PGDV = page_num | 0x80;
 800750c:	f066 037f 	orn	r3, r6, #127	; 0x7f

    // pick a nonce
    // (hmac auth + chal) will be written to the "buffer"
    uint8_t chal_check[32+8];
    rng_buffer(&chal_check[32], 8);
 8007510:	2108      	movs	r1, #8
 8007512:	a821      	add	r0, sp, #132	; 0x84

    // need old value to for authentication purposes
    uint8_t     old_data[32];
    se2_read_encrypted(page_num, old_data, keynum, secret);

    uint8_t PGDV = page_num | 0x80;
 8007514:	f88d 3002 	strb.w	r3, [sp, #2]

    // pick a nonce
    // (hmac auth + chal) will be written to the "buffer"
    uint8_t chal_check[32+8];
    rng_buffer(&chal_check[32], 8);
 8007518:	f7fb f8f6 	bl	8002708 <rng_buffer>

    HMAC_CTX ctx;
    hmac_sha256_init(&ctx);
 800751c:	a823      	add	r0, sp, #140	; 0x8c
 800751e:	f7fd ffa1 	bl	8005464 <hmac_sha256_init>

    // msg = chal + self.rom_id + PGDV + self.manid
    hmac_sha256_update(&ctx, &chal_check[32], 8);
 8007522:	2208      	movs	r2, #8
 8007524:	a921      	add	r1, sp, #132	; 0x84
 8007526:	a823      	add	r0, sp, #140	; 0x8c
 8007528:	f7fd ffa2 	bl	8005470 <hmac_sha256_update>
    hmac_sha256_update(&ctx, SE2_SECRETS->romid, 8);
 800752c:	4b43      	ldr	r3, [pc, #268]	; (800763c <se2_write_encrypted+0x150>)
 800752e:	4a44      	ldr	r2, [pc, #272]	; (8007640 <se2_write_encrypted+0x154>)
 8007530:	f893 10b0 	ldrb.w	r1, [r3, #176]	; 0xb0
 8007534:	4b43      	ldr	r3, [pc, #268]	; (8007644 <se2_write_encrypted+0x158>)
 8007536:	29ff      	cmp	r1, #255	; 0xff
 8007538:	bf0c      	ite	eq
 800753a:	4619      	moveq	r1, r3
 800753c:	4611      	movne	r1, r2
 800753e:	3160      	adds	r1, #96	; 0x60
 8007540:	2208      	movs	r2, #8
 8007542:	a823      	add	r0, sp, #140	; 0x8c
 8007544:	f7fd ff94 	bl	8005470 <hmac_sha256_update>
    hmac_sha256_update(&ctx, &PGDV, 1);
 8007548:	2201      	movs	r2, #1
 800754a:	f10d 0102 	add.w	r1, sp, #2
 800754e:	a823      	add	r0, sp, #140	; 0x8c
 8007550:	f7fd ff8e 	bl	8005470 <hmac_sha256_update>
    hmac_sha256_update(&ctx, DEV_MANID, 2);
 8007554:	2202      	movs	r2, #2
 8007556:	493c      	ldr	r1, [pc, #240]	; (8007648 <se2_write_encrypted+0x15c>)
 8007558:	a823      	add	r0, sp, #140	; 0x8c
 800755a:	f7fd ff89 	bl	8005470 <hmac_sha256_update>
    ASSERT(ctx.num_pending == 19);
 800755e:	9b63      	ldr	r3, [sp, #396]	; 0x18c
 8007560:	2b13      	cmp	r3, #19
 8007562:	d1cd      	bne.n	8007500 <se2_write_encrypted+0x14>

    uint8_t otp[32];
    hmac_sha256_final(&ctx, secret, otp);
 8007564:	f10d 0a24 	add.w	sl, sp, #36	; 0x24
 8007568:	4652      	mov	r2, sl
 800756a:	4649      	mov	r1, r9
 800756c:	a823      	add	r0, sp, #140	; 0x8c

    // encrypt new value
    uint8_t tmp[32];
    memcpy(tmp, data, 32);
 800756e:	ad11      	add	r5, sp, #68	; 0x44
    hmac_sha256_update(&ctx, &PGDV, 1);
    hmac_sha256_update(&ctx, DEV_MANID, 2);
    ASSERT(ctx.num_pending == 19);

    uint8_t otp[32];
    hmac_sha256_final(&ctx, secret, otp);
 8007570:	f7fd ff94 	bl	800549c <hmac_sha256_final>

    // encrypt new value
    uint8_t tmp[32];
    memcpy(tmp, data, 32);
 8007574:	462c      	mov	r4, r5
 8007576:	463b      	mov	r3, r7
 8007578:	f107 0e20 	add.w	lr, r7, #32
 800757c:	6818      	ldr	r0, [r3, #0]
 800757e:	6859      	ldr	r1, [r3, #4]
 8007580:	4622      	mov	r2, r4
 8007582:	c203      	stmia	r2!, {r0, r1}
 8007584:	3308      	adds	r3, #8
 8007586:	4573      	cmp	r3, lr
 8007588:	4614      	mov	r4, r2
 800758a:	d1f7      	bne.n	800757c <se2_write_encrypted+0x90>
 800758c:	2400      	movs	r4, #0
		*(acc) ^= *(more);
 800758e:	5d2a      	ldrb	r2, [r5, r4]
 8007590:	f81a 3004 	ldrb.w	r3, [sl, r4]
 8007594:	4053      	eors	r3, r2
 8007596:	552b      	strb	r3, [r5, r4]
 8007598:	3401      	adds	r4, #1
bool check_equal(const void *aV, const void *bV, int len);

// XOR-mixin more bytes; acc = acc XOR more for each byte
void static inline xor_mixin(uint8_t *acc, const uint8_t *more, int len)
{
	for(; len; len--, more++, acc++) {
 800759a:	2c20      	cmp	r4, #32
 800759c:	d1f7      	bne.n	800758e <se2_write_encrypted+0xa2>
    xor_mixin(tmp, otp, 32);

    // "tmp" now encrypted, but also need right auth value in buffer

    // msg2 = self.rom_id + old_data + new_data + PGDV + self.manid
    hmac_sha256_init(&ctx);
 800759e:	a823      	add	r0, sp, #140	; 0x8c
 80075a0:	f7fd ff60 	bl	8005464 <hmac_sha256_init>
    hmac_sha256_update(&ctx, SE2_SECRETS->romid, 8);
 80075a4:	4b25      	ldr	r3, [pc, #148]	; (800763c <se2_write_encrypted+0x150>)
 80075a6:	4a26      	ldr	r2, [pc, #152]	; (8007640 <se2_write_encrypted+0x154>)
 80075a8:	f893 10b0 	ldrb.w	r1, [r3, #176]	; 0xb0
 80075ac:	4b25      	ldr	r3, [pc, #148]	; (8007644 <se2_write_encrypted+0x158>)
 80075ae:	29ff      	cmp	r1, #255	; 0xff
 80075b0:	bf0c      	ite	eq
 80075b2:	4619      	moveq	r1, r3
 80075b4:	4611      	movne	r1, r2
 80075b6:	3160      	adds	r1, #96	; 0x60
 80075b8:	2208      	movs	r2, #8
 80075ba:	a823      	add	r0, sp, #140	; 0x8c
 80075bc:	f7fd ff58 	bl	8005470 <hmac_sha256_update>
    hmac_sha256_update(&ctx, old_data, 32);
 80075c0:	4622      	mov	r2, r4
 80075c2:	a901      	add	r1, sp, #4
 80075c4:	a823      	add	r0, sp, #140	; 0x8c
 80075c6:	f7fd ff53 	bl	8005470 <hmac_sha256_update>
    hmac_sha256_update(&ctx, data, 32);
 80075ca:	4622      	mov	r2, r4
 80075cc:	4639      	mov	r1, r7
 80075ce:	a823      	add	r0, sp, #140	; 0x8c
 80075d0:	f7fd ff4e 	bl	8005470 <hmac_sha256_update>
    hmac_sha256_update(&ctx, &PGDV, 1);
 80075d4:	2201      	movs	r2, #1
 80075d6:	f10d 0102 	add.w	r1, sp, #2
 80075da:	a823      	add	r0, sp, #140	; 0x8c
 80075dc:	f7fd ff48 	bl	8005470 <hmac_sha256_update>
    hmac_sha256_update(&ctx, DEV_MANID, 2);
 80075e0:	2202      	movs	r2, #2
 80075e2:	4919      	ldr	r1, [pc, #100]	; (8007648 <se2_write_encrypted+0x15c>)
 80075e4:	a823      	add	r0, sp, #140	; 0x8c
 80075e6:	f7fd ff43 	bl	8005470 <hmac_sha256_update>

    ASSERT(ctx.num_pending == 75);
 80075ea:	9b63      	ldr	r3, [sp, #396]	; 0x18c
 80075ec:	2b4b      	cmp	r3, #75	; 0x4b
 80075ee:	d187      	bne.n	8007500 <se2_write_encrypted+0x14>
    hmac_sha256_final(&ctx, secret, chal_check);
 80075f0:	aa19      	add	r2, sp, #100	; 0x64
 80075f2:	4649      	mov	r1, r9
 80075f4:	a823      	add	r0, sp, #140	; 0x8c
 80075f6:	f7fd ff51 	bl	800549c <hmac_sha256_final>

    // send chip both our nonce (challenge) and also HMAC auth check value
    se2_write_buffer(chal_check, sizeof(chal_check));
 80075fa:	2128      	movs	r1, #40	; 0x28
 80075fc:	a819      	add	r0, sp, #100	; 0x64
 80075fe:	f7ff fdfd 	bl	80071fc <se2_write_buffer>

    // send encrypted data now
    uint8_t pn = (keynum << 6) | page_num;
 8007602:	ea46 1688 	orr.w	r6, r6, r8, lsl #6
    CALL_CHECK(se2_write_n(0x99, &pn, tmp, 32));
 8007606:	4623      	mov	r3, r4
 8007608:	462a      	mov	r2, r5
 800760a:	f10d 0103 	add.w	r1, sp, #3
 800760e:	2099      	movs	r0, #153	; 0x99

    // send chip both our nonce (challenge) and also HMAC auth check value
    se2_write_buffer(chal_check, sizeof(chal_check));

    // send encrypted data now
    uint8_t pn = (keynum << 6) | page_num;
 8007610:	f88d 6003 	strb.w	r6, [sp, #3]
    CALL_CHECK(se2_write_n(0x99, &pn, tmp, 32));
 8007614:	f7ff fd86 	bl	8007124 <se2_write_n>
 8007618:	b110      	cbz	r0, 8007620 <se2_write_encrypted+0x134>
 800761a:	f240 1151 	movw	r1, #337	; 0x151
 800761e:	e005      	b.n	800762c <se2_write_encrypted+0x140>

    CHECK_RIGHT(se2_read1() == RC_SUCCESS);
 8007620:	f7ff fdde 	bl	80071e0 <se2_read1>
 8007624:	28aa      	cmp	r0, #170	; 0xaa
 8007626:	d004      	beq.n	8007632 <se2_write_encrypted+0x146>
 8007628:	f240 1153 	movw	r1, #339	; 0x153
 800762c:	4807      	ldr	r0, [pc, #28]	; (800764c <se2_write_encrypted+0x160>)
 800762e:	f005 ff59 	bl	800d4e4 <longjmp>
}
 8007632:	b064      	add	sp, #400	; 0x190
 8007634:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8007638:	0800d550 	.word	0x0800d550
 800763c:	0801e000 	.word	0x0801e000
 8007640:	0801e0b0 	.word	0x0801e0b0
 8007644:	200002e4 	.word	0x200002e4
 8007648:	0800e77f 	.word	0x0800e77f
 800764c:	20000288 	.word	0x20000288

08007650 <se2_get_protection>:
//
// Caution: Use only in a controlled environment! No MiTM protection.
//
    uint8_t
se2_get_protection(uint8_t page_num)
{
 8007650:	b508      	push	{r3, lr}
    CALL_CHECK(se2_write1(0xaa, page_num));
 8007652:	4601      	mov	r1, r0
 8007654:	20aa      	movs	r0, #170	; 0xaa
 8007656:	f7ff fd4b 	bl	80070f0 <se2_write1>
 800765a:	b120      	cbz	r0, 8007666 <se2_get_protection+0x16>
 800765c:	f44f 71c4 	mov.w	r1, #392	; 0x188
 8007660:	4803      	ldr	r0, [pc, #12]	; (8007670 <se2_get_protection+0x20>)
 8007662:	f005 ff3f 	bl	800d4e4 <longjmp>

    return se2_read1();
}
 8007666:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    uint8_t
se2_get_protection(uint8_t page_num)
{
    CALL_CHECK(se2_write1(0xaa, page_num));

    return se2_read1();
 800766a:	f7ff bdb9 	b.w	80071e0 <se2_read1>
 800766e:	bf00      	nop
 8007670:	20000288 	.word	0x20000288

08007674 <se2_set_protection>:
//
// Caution: Use only in a controlled environment! No MiTM protection.
//
    void
se2_set_protection(uint8_t page_num, uint8_t flags)
{
 8007674:	b530      	push	{r4, r5, lr}
 8007676:	b085      	sub	sp, #20
 8007678:	460c      	mov	r4, r1
 800767a:	4605      	mov	r5, r0
    if(se2_get_protection(page_num) == flags) {
 800767c:	f7ff ffe8 	bl	8007650 <se2_get_protection>
 8007680:	42a0      	cmp	r0, r4
 8007682:	d01f      	beq.n	80076c4 <se2_set_protection+0x50>
// se2_write2()
//
    static bool
se2_write2(uint8_t cmd, uint8_t arg1, uint8_t arg2)
{
    uint8_t data[4] = { cmd, 2, arg1, arg2 };
 8007684:	23c3      	movs	r3, #195	; 0xc3
 8007686:	f88d 300c 	strb.w	r3, [sp, #12]
 800768a:	2302      	movs	r3, #2
 800768c:	f88d 300d 	strb.w	r3, [sp, #13]

    HAL_StatusTypeDef rv = HAL_I2C_Master_Transmit(&i2c_port, I2C_ADDR,
 8007690:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8007694:	9300      	str	r3, [sp, #0]
 8007696:	aa03      	add	r2, sp, #12
 8007698:	2304      	movs	r3, #4
 800769a:	2136      	movs	r1, #54	; 0x36
 800769c:	480a      	ldr	r0, [pc, #40]	; (80076c8 <se2_set_protection+0x54>)
// se2_write2()
//
    static bool
se2_write2(uint8_t cmd, uint8_t arg1, uint8_t arg2)
{
    uint8_t data[4] = { cmd, 2, arg1, arg2 };
 800769e:	f88d 500e 	strb.w	r5, [sp, #14]
 80076a2:	f88d 400f 	strb.w	r4, [sp, #15]

    HAL_StatusTypeDef rv = HAL_I2C_Master_Transmit(&i2c_port, I2C_ADDR,
 80076a6:	f004 f867 	bl	800b778 <HAL_I2C_Master_Transmit>
{
    if(se2_get_protection(page_num) == flags) {
        return;
    }

    CALL_CHECK(se2_write2(0xc3, page_num, flags));
 80076aa:	b110      	cbz	r0, 80076b2 <se2_set_protection+0x3e>
 80076ac:	f44f 71cc 	mov.w	r1, #408	; 0x198
 80076b0:	e005      	b.n	80076be <se2_set_protection+0x4a>

    CHECK_RIGHT(se2_read1() == RC_SUCCESS);
 80076b2:	f7ff fd95 	bl	80071e0 <se2_read1>
 80076b6:	28aa      	cmp	r0, #170	; 0xaa
 80076b8:	d004      	beq.n	80076c4 <se2_set_protection+0x50>
 80076ba:	f44f 71cd 	mov.w	r1, #410	; 0x19a
 80076be:	4803      	ldr	r0, [pc, #12]	; (80076cc <se2_set_protection+0x58>)
 80076c0:	f005 ff10 	bl	800d4e4 <longjmp>
}
 80076c4:	b005      	add	sp, #20
 80076c6:	bd30      	pop	{r4, r5, pc}
 80076c8:	2000023c 	.word	0x2000023c
 80076cc:	20000288 	.word	0x20000288

080076d0 <se2_probe>:

// se2_probe()
//
    void
se2_probe(void)
{
 80076d0:	b500      	push	{lr}
    // error handling.
    if(setjmp(error_env)) {
 80076d2:	4812      	ldr	r0, [pc, #72]	; (800771c <se2_probe+0x4c>)

// se2_probe()
//
    void
se2_probe(void)
{
 80076d4:	b089      	sub	sp, #36	; 0x24
    // error handling.
    if(setjmp(error_env)) {
 80076d6:	f005 feff 	bl	800d4d8 <setjmp>
 80076da:	b120      	cbz	r0, 80076e6 <se2_probe+0x16>
        oled_show(screen_se2_issue);
 80076dc:	4810      	ldr	r0, [pc, #64]	; (8007720 <se2_probe+0x50>)
 80076de:	f7f9 fb89 	bl	8000df4 <oled_show>
        LOCKUP_FOREVER();
 80076e2:	bf30      	wfi
 80076e4:	e7fd      	b.n	80076e2 <se2_probe+0x12>
        // not reached
    }

    // See what's attached. Read serial number and verify it using shared secret
    rng_delay();
 80076e6:	f7fb f826 	bl	8002736 <rng_delay>
    if(rom_secrets->se2.pairing[0] == 0xff) {
 80076ea:	4b0e      	ldr	r3, [pc, #56]	; (8007724 <se2_probe+0x54>)
 80076ec:	f893 30b0 	ldrb.w	r3, [r3, #176]	; 0xb0
 80076f0:	2bff      	cmp	r3, #255	; 0xff
 80076f2:	d00f      	beq.n	8007714 <se2_probe+0x44>
        // chip not setup yet, ok in factory
    } else {
        // This is also verifying the pairing secret, effectively.
        uint8_t tmp[32];
        se2_read_page(PGN_ROM_OPTIONS, tmp, true);
 80076f4:	2201      	movs	r2, #1
 80076f6:	4669      	mov	r1, sp
 80076f8:	201c      	movs	r0, #28
 80076fa:	f7ff fe27 	bl	800734c <se2_read_page>

        CHECK_RIGHT(check_equal(&tmp[24], rom_secrets->se2.romid, 8));
 80076fe:	2208      	movs	r2, #8
 8007700:	4909      	ldr	r1, [pc, #36]	; (8007728 <se2_probe+0x58>)
 8007702:	a806      	add	r0, sp, #24
 8007704:	f7fa ffaf 	bl	8002666 <check_equal>
 8007708:	b920      	cbnz	r0, 8007714 <se2_probe+0x44>
 800770a:	f44f 71d9 	mov.w	r1, #434	; 0x1b2
 800770e:	4803      	ldr	r0, [pc, #12]	; (800771c <se2_probe+0x4c>)
 8007710:	f005 fee8 	bl	800d4e4 <longjmp>
    }
}
 8007714:	b009      	add	sp, #36	; 0x24
 8007716:	f85d fb04 	ldr.w	pc, [sp], #4
 800771a:	bf00      	nop
 800771c:	20000288 	.word	0x20000288
 8007720:	0800da3a 	.word	0x0800da3a
 8007724:	0801e000 	.word	0x0801e000
 8007728:	0801e110 	.word	0x0801e110

0800772c <se2_clear_volatile>:
// No command to reset the volatile state on this chip! Could
// be sensitive at times. 608 has a watchdog for this!!
//
    void
se2_clear_volatile(void)
{
 800772c:	b530      	push	{r4, r5, lr}
    // funny business means MitM?
    if(setjmp(error_env)) fatal_mitm();
 800772e:	481e      	ldr	r0, [pc, #120]	; (80077a8 <se2_clear_volatile+0x7c>)
// No command to reset the volatile state on this chip! Could
// be sensitive at times. 608 has a watchdog for this!!
//
    void
se2_clear_volatile(void)
{
 8007730:	b08d      	sub	sp, #52	; 0x34
    // funny business means MitM?
    if(setjmp(error_env)) fatal_mitm();
 8007732:	f005 fed1 	bl	800d4d8 <setjmp>
 8007736:	4604      	mov	r4, r0
 8007738:	b108      	cbz	r0, 800773e <se2_clear_volatile+0x12>
 800773a:	f7f9 f959 	bl	80009f0 <fatal_mitm>

    uint8_t z32[32] = {0};
 800773e:	2520      	movs	r5, #32
 8007740:	462a      	mov	r2, r5
 8007742:	4601      	mov	r1, r0
 8007744:	a804      	add	r0, sp, #16
 8007746:	f005 febe 	bl	800d4c6 <memset>

    se2_write_page(PGN_PUBKEY_S+0, z32);
 800774a:	a904      	add	r1, sp, #16
 800774c:	201e      	movs	r0, #30
 800774e:	f7ff fd65 	bl	800721c <se2_write_page>
    se2_write_page(PGN_PUBKEY_S+1, z32);
 8007752:	a904      	add	r1, sp, #16
 8007754:	201f      	movs	r0, #31
 8007756:	f7ff fd61 	bl	800721c <se2_write_page>

    se2_write_buffer(z32, 32);
 800775a:	4629      	mov	r1, r5
 800775c:	a804      	add	r0, sp, #16
 800775e:	f7ff fd4d 	bl	80071fc <se2_write_buffer>
// se2_write2()
//
    static bool
se2_write2(uint8_t cmd, uint8_t arg1, uint8_t arg2)
{
    uint8_t data[4] = { cmd, 2, arg1, arg2 };
 8007762:	233c      	movs	r3, #60	; 0x3c
 8007764:	f88d 300c 	strb.w	r3, [sp, #12]
 8007768:	2302      	movs	r3, #2
 800776a:	f88d 300d 	strb.w	r3, [sp, #13]
 800776e:	2380      	movs	r3, #128	; 0x80
 8007770:	f88d 300e 	strb.w	r3, [sp, #14]

    HAL_StatusTypeDef rv = HAL_I2C_Master_Transmit(&i2c_port, I2C_ADDR,
 8007774:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8007778:	9300      	str	r3, [sp, #0]
 800777a:	aa03      	add	r2, sp, #12
 800777c:	2304      	movs	r3, #4
 800777e:	2136      	movs	r1, #54	; 0x36
 8007780:	480a      	ldr	r0, [pc, #40]	; (80077ac <se2_clear_volatile+0x80>)
// se2_write2()
//
    static bool
se2_write2(uint8_t cmd, uint8_t arg1, uint8_t arg2)
{
    uint8_t data[4] = { cmd, 2, arg1, arg2 };
 8007782:	f88d 400f 	strb.w	r4, [sp, #15]

    HAL_StatusTypeDef rv = HAL_I2C_Master_Transmit(&i2c_port, I2C_ADDR,
 8007786:	f003 fff7 	bl	800b778 <HAL_I2C_Master_Transmit>

    se2_write_buffer(z32, 32);

    // rotate the secret S ... not ideal but only way I've got to change it
    // - also clears ECDH_SECRET_S flag
    CALL_CHECK(se2_write2(0x3c, (2<<6), 0));
 800778a:	b110      	cbz	r0, 8007792 <se2_clear_volatile+0x66>
 800778c:	f44f 71e5 	mov.w	r1, #458	; 0x1ca
 8007790:	e005      	b.n	800779e <se2_clear_volatile+0x72>
    CHECK_RIGHT(se2_read1() == RC_SUCCESS);
 8007792:	f7ff fd25 	bl	80071e0 <se2_read1>
 8007796:	28aa      	cmp	r0, #170	; 0xaa
 8007798:	d004      	beq.n	80077a4 <se2_clear_volatile+0x78>
 800779a:	f240 11cb 	movw	r1, #459	; 0x1cb
 800779e:	4802      	ldr	r0, [pc, #8]	; (80077a8 <se2_clear_volatile+0x7c>)
 80077a0:	f005 fea0 	bl	800d4e4 <longjmp>
}
 80077a4:	b00d      	add	sp, #52	; 0x34
 80077a6:	bd30      	pop	{r4, r5, pc}
 80077a8:	20000288 	.word	0x20000288
 80077ac:	2000023c 	.word	0x2000023c

080077b0 <se2_setup_config>:
// But once started, we assume operation in a safe trusted environment
// (ie. the Coinkite factory in Toronto).
//
    void
se2_setup_config(void)
{
 80077b0:	b570      	push	{r4, r5, r6, lr}
    // error handling.
    if((setjmp(error_env))) {
 80077b2:	484f      	ldr	r0, [pc, #316]	; (80078f0 <se2_setup_config+0x140>)
// But once started, we assume operation in a safe trusted environment
// (ie. the Coinkite factory in Toronto).
//
    void
se2_setup_config(void)
{
 80077b4:	b088      	sub	sp, #32
    // error handling.
    if((setjmp(error_env))) {
 80077b6:	f005 fe8f 	bl	800d4d8 <setjmp>
 80077ba:	4605      	mov	r5, r0
 80077bc:	b120      	cbz	r0, 80077c8 <se2_setup_config+0x18>
        oled_show(screen_se2_issue);
 80077be:	484d      	ldr	r0, [pc, #308]	; (80078f4 <se2_setup_config+0x144>)
 80077c0:	f7f9 fb18 	bl	8000df4 <oled_show>

        LOCKUP_FOREVER();
 80077c4:	bf30      	wfi
 80077c6:	e7fd      	b.n	80077c4 <se2_setup_config+0x14>
    }

    if(rom_secrets->se2.pairing[0] != 0xff) {
 80077c8:	4b4b      	ldr	r3, [pc, #300]	; (80078f8 <se2_setup_config+0x148>)
 80077ca:	f893 10b0 	ldrb.w	r1, [r3, #176]	; 0xb0
 80077ce:	29ff      	cmp	r1, #255	; 0xff
 80077d0:	f040 808c 	bne.w	80078ec <se2_setup_config+0x13c>
        // we've been here, so nothing more to do / anything we do will fail, etc.
        return;
    }

    // Global (ram) copy of values to be writen, so we can use them during setup
    memset(&_tbd, 0xff, sizeof(_tbd));
 80077d4:	4c49      	ldr	r4, [pc, #292]	; (80078fc <se2_setup_config+0x14c>)
 80077d6:	22e0      	movs	r2, #224	; 0xe0
 80077d8:	4620      	mov	r0, r4
 80077da:	f005 fe74 	bl	800d4c6 <memset>

    // pick internal keys
    rng_buffer(_tbd.tpin_key, 32);
 80077de:	2120      	movs	r1, #32
 80077e0:	f104 0080 	add.w	r0, r4, #128	; 0x80
 80077e4:	f7fa ff90 	bl	8002708 <rng_buffer>

    // capture serial of device
    uint8_t tmp[32];
    se2_read_page(PGN_ROM_OPTIONS, tmp, false);
 80077e8:	462a      	mov	r2, r5
 80077ea:	4669      	mov	r1, sp
 80077ec:	201c      	movs	r0, #28
 80077ee:	f7ff fdad 	bl	800734c <se2_read_page>

    ASSERT(tmp[1] == 0x00);     // check ANON is not set
 80077f2:	f89d 5001 	ldrb.w	r5, [sp, #1]
 80077f6:	b115      	cbz	r5, 80077fe <se2_setup_config+0x4e>
 80077f8:	4841      	ldr	r0, [pc, #260]	; (8007900 <se2_setup_config+0x150>)
 80077fa:	f7f9 f8ef 	bl	80009dc <fatal_error>

    memcpy(_tbd.romid, tmp+24, 8);
 80077fe:	ab06      	add	r3, sp, #24
 8007800:	cb03      	ldmia	r3!, {r0, r1}
 8007802:	6620      	str	r0, [r4, #96]	; 0x60
 8007804:	6661      	str	r1, [r4, #100]	; 0x64

    // forget a secret - B (will not be used)
    rng_buffer(tmp, 32);
 8007806:	4668      	mov	r0, sp
 8007808:	2120      	movs	r1, #32
 800780a:	f7fa ff7d 	bl	8002708 <rng_buffer>
    se2_write_page(PGN_SECRET_B, tmp);
 800780e:	4669      	mov	r1, sp
 8007810:	201a      	movs	r0, #26
 8007812:	f7ff fd03 	bl	800721c <se2_write_page>

    // have chip pick a keypair, record public part for later
    se2_pick_keypair(0, true);
 8007816:	2101      	movs	r1, #1
 8007818:	4628      	mov	r0, r5
 800781a:	f7ff fd19 	bl	8007250 <se2_pick_keypair>
    se2_read_page(PGN_PUBKEY_A,   &_tbd.pubkey_A[0], false);
 800781e:	462a      	mov	r2, r5
 8007820:	f104 0120 	add.w	r1, r4, #32
 8007824:	2010      	movs	r0, #16
 8007826:	f7ff fd91 	bl	800734c <se2_read_page>
    se2_read_page(PGN_PUBKEY_A+1, &_tbd.pubkey_A[32], false);

    // Burn privkey B with garbage. Invalid ECC key like this cannot
    // be used (except to make errors)
    memset(tmp, 0, 32);
 800782a:	2620      	movs	r6, #32
    se2_write_page(PGN_SECRET_B, tmp);

    // have chip pick a keypair, record public part for later
    se2_pick_keypair(0, true);
    se2_read_page(PGN_PUBKEY_A,   &_tbd.pubkey_A[0], false);
    se2_read_page(PGN_PUBKEY_A+1, &_tbd.pubkey_A[32], false);
 800782c:	462a      	mov	r2, r5
 800782e:	f104 0140 	add.w	r1, r4, #64	; 0x40
 8007832:	2011      	movs	r0, #17
 8007834:	f7ff fd8a 	bl	800734c <se2_read_page>

    // Burn privkey B with garbage. Invalid ECC key like this cannot
    // be used (except to make errors)
    memset(tmp, 0, 32);
 8007838:	4632      	mov	r2, r6
 800783a:	4629      	mov	r1, r5
 800783c:	4668      	mov	r0, sp
 800783e:	f005 fe42 	bl	800d4c6 <memset>
    se2_write_page(PGN_PRIVKEY_B, tmp);
 8007842:	4669      	mov	r1, sp
 8007844:	2017      	movs	r0, #23
 8007846:	f7ff fce9 	bl	800721c <se2_write_page>
    se2_write_page(PGN_PRIVKEY_B+1, tmp);
 800784a:	4669      	mov	r1, sp
 800784c:	2018      	movs	r0, #24
 800784e:	f7ff fce5 	bl	800721c <se2_write_page>
    se2_write_page(PGN_PUBKEY_B, tmp);
 8007852:	4669      	mov	r1, sp
 8007854:	2012      	movs	r0, #18
 8007856:	f7ff fce1 	bl	800721c <se2_write_page>
    se2_write_page(PGN_PUBKEY_B+1, tmp);
 800785a:	4669      	mov	r1, sp
 800785c:	2013      	movs	r0, #19
 800785e:	f7ff fcdd 	bl	800721c <se2_write_page>

    // pick a paring secret (A)
    do {
        rng_buffer(_tbd.pairing, 32);
 8007862:	4631      	mov	r1, r6
 8007864:	4620      	mov	r0, r4
 8007866:	f7fa ff4f 	bl	8002708 <rng_buffer>
    } while(_tbd.pairing[0] == 0xff);
 800786a:	7823      	ldrb	r3, [r4, #0]
 800786c:	2bff      	cmp	r3, #255	; 0xff
 800786e:	d0f8      	beq.n	8007862 <se2_setup_config+0xb2>
    se2_write_page(PGN_SECRET_A, _tbd.pairing);
 8007870:	4621      	mov	r1, r4
 8007872:	2019      	movs	r0, #25
 8007874:	f7ff fcd2 	bl	800721c <se2_write_page>

    // called the "easy" key, this one requires only SE2 pairing to read/write
    // - so we can wipe it anytime as part of bricking (maybe)
    // - but also so that more than just the paired pubkey w/ SE1 is needed
    rng_buffer(tmp, 32);
 8007878:	2120      	movs	r1, #32
 800787a:	4668      	mov	r0, sp
 800787c:	f7fa ff44 	bl	8002708 <rng_buffer>
    se2_write_page(PGN_SE2_EASY_KEY, tmp);
 8007880:	4669      	mov	r1, sp
 8007882:	200e      	movs	r0, #14
 8007884:	f7ff fcca 	bl	800721c <se2_write_page>

    // wipe all trick pins and data slots
    memset(tmp, 0, 32);
 8007888:	2220      	movs	r2, #32
 800788a:	2100      	movs	r1, #0
 800788c:	4668      	mov	r0, sp
 800788e:	f005 fe1a 	bl	800d4c6 <memset>
    se2_write_page(PGN_SECRET_A, _tbd.pairing);

    // called the "easy" key, this one requires only SE2 pairing to read/write
    // - so we can wipe it anytime as part of bricking (maybe)
    // - but also so that more than just the paired pubkey w/ SE1 is needed
    rng_buffer(tmp, 32);
 8007892:	466c      	mov	r4, sp
    se2_write_page(PGN_SE2_EASY_KEY, tmp);

    // wipe all trick pins and data slots
    memset(tmp, 0, 32);
    for(int pn=0; pn <= PGN_LAST_TRICK; pn++) {
 8007894:	2500      	movs	r5, #0
        se2_write_page(pn, tmp);
 8007896:	b2e8      	uxtb	r0, r5
 8007898:	4621      	mov	r1, r4
    rng_buffer(tmp, 32);
    se2_write_page(PGN_SE2_EASY_KEY, tmp);

    // wipe all trick pins and data slots
    memset(tmp, 0, 32);
    for(int pn=0; pn <= PGN_LAST_TRICK; pn++) {
 800789a:	3501      	adds	r5, #1
        se2_write_page(pn, tmp);
 800789c:	f7ff fcbe 	bl	800721c <se2_write_page>
    rng_buffer(tmp, 32);
    se2_write_page(PGN_SE2_EASY_KEY, tmp);

    // wipe all trick pins and data slots
    memset(tmp, 0, 32);
    for(int pn=0; pn <= PGN_LAST_TRICK; pn++) {
 80078a0:	2d0e      	cmp	r5, #14
 80078a2:	d1f8      	bne.n	8007896 <se2_setup_config+0xe6>
        se2_write_page(pn, tmp);
    }

    // save the shared secrets for ourselves, in flash
    flash_save_se2_data(&_tbd);
 80078a4:	4815      	ldr	r0, [pc, #84]	; (80078fc <se2_setup_config+0x14c>)
 80078a6:	f7fa fca1 	bl	80021ec <flash_save_se2_data>

    // Now safe to lock down the SE2; failures up to this point could be
    // recovered by picking new values. After this, if main flash corrupt, no
    // way to read these values back, nor replace them with new ones.
    se2_set_protection(PGN_SECRET_A, PROT_WP);
 80078aa:	2102      	movs	r1, #2
 80078ac:	2019      	movs	r0, #25
 80078ae:	f7ff fee1 	bl	8007674 <se2_set_protection>
    se2_set_protection(PGN_SECRET_B, PROT_WP);
 80078b2:	2102      	movs	r1, #2
 80078b4:	201a      	movs	r0, #26
 80078b6:	f7ff fedd 	bl	8007674 <se2_set_protection>
    se2_set_protection(PGN_PUBKEY_A, PROT_WP);
 80078ba:	2102      	movs	r1, #2
 80078bc:	2010      	movs	r0, #16
 80078be:	f7ff fed9 	bl	8007674 <se2_set_protection>
    se2_set_protection(PGN_PUBKEY_B, PROT_WP);
 80078c2:	2102      	movs	r1, #2
 80078c4:	2012      	movs	r0, #18
 80078c6:	f7ff fed5 	bl	8007674 <se2_set_protection>

    se2_set_protection(PGN_SE2_EASY_KEY, PROT_EPH);
 80078ca:	4628      	mov	r0, r5
 80078cc:	2110      	movs	r1, #16
 80078ce:	f7ff fed1 	bl	8007674 <se2_set_protection>
 80078d2:	2400      	movs	r4, #0
    for(int pn=0; pn <= PGN_LAST_TRICK; pn++) {
        se2_set_protection(pn, PROT_EPH);
 80078d4:	2510      	movs	r5, #16
 80078d6:	b2e0      	uxtb	r0, r4
 80078d8:	4629      	mov	r1, r5
    se2_set_protection(PGN_SECRET_B, PROT_WP);
    se2_set_protection(PGN_PUBKEY_A, PROT_WP);
    se2_set_protection(PGN_PUBKEY_B, PROT_WP);

    se2_set_protection(PGN_SE2_EASY_KEY, PROT_EPH);
    for(int pn=0; pn <= PGN_LAST_TRICK; pn++) {
 80078da:	3401      	adds	r4, #1
        se2_set_protection(pn, PROT_EPH);
 80078dc:	f7ff feca 	bl	8007674 <se2_set_protection>
    se2_set_protection(PGN_SECRET_B, PROT_WP);
    se2_set_protection(PGN_PUBKEY_A, PROT_WP);
    se2_set_protection(PGN_PUBKEY_B, PROT_WP);

    se2_set_protection(PGN_SE2_EASY_KEY, PROT_EPH);
    for(int pn=0; pn <= PGN_LAST_TRICK; pn++) {
 80078e0:	2c0e      	cmp	r4, #14
 80078e2:	d1f8      	bne.n	80078d6 <se2_setup_config+0x126>
        se2_set_protection(pn, PROT_EPH);
    }

    se2_set_protection(PGN_ROM_OPTIONS, PROT_APH);       // not planning to change
 80078e4:	2108      	movs	r1, #8
 80078e6:	201c      	movs	r0, #28
 80078e8:	f7ff fec4 	bl	8007674 <se2_set_protection>

    // NOTE: PGN_SE2_HARD_KEY and PUBKEY_C not yet known
}
 80078ec:	b008      	add	sp, #32
 80078ee:	bd70      	pop	{r4, r5, r6, pc}
 80078f0:	20000288 	.word	0x20000288
 80078f4:	0800da3a 	.word	0x0800da3a
 80078f8:	0801e000 	.word	0x0801e000
 80078fc:	200002e4 	.word	0x200002e4
 8007900:	0800d550 	.word	0x0800d550

08007904 <se2_save_auth_pubkey>:
// Record and enable an ECC pubkey for joining purposes.
// - trusted env. so no need for encrypted comms
//
    void
se2_save_auth_pubkey(const uint8_t pubkey[64])
{
 8007904:	b510      	push	{r4, lr}
 8007906:	b08a      	sub	sp, #40	; 0x28
 8007908:	9001      	str	r0, [sp, #4]
    if(setjmp(error_env)) fatal_mitm();
 800790a:	481e      	ldr	r0, [pc, #120]	; (8007984 <se2_save_auth_pubkey+0x80>)
 800790c:	f005 fde4 	bl	800d4d8 <setjmp>
 8007910:	b108      	cbz	r0, 8007916 <se2_save_auth_pubkey+0x12>
 8007912:	f7f9 f86d 	bl	80009f0 <fatal_mitm>

    ASSERT(check_all_ones(rom_secrets->se2.auth_pubkey, 64));
 8007916:	2140      	movs	r1, #64	; 0x40
 8007918:	481b      	ldr	r0, [pc, #108]	; (8007988 <se2_save_auth_pubkey+0x84>)
 800791a:	f7fa fe85 	bl	8002628 <check_all_ones>
 800791e:	b910      	cbnz	r0, 8007926 <se2_save_auth_pubkey+0x22>
 8007920:	481a      	ldr	r0, [pc, #104]	; (800798c <se2_save_auth_pubkey+0x88>)
 8007922:	f7f9 f85b 	bl	80009dc <fatal_error>
    memcpy(&_tbd, &rom_secrets->se2, sizeof(_tbd));
 8007926:	4c1a      	ldr	r4, [pc, #104]	; (8007990 <se2_save_auth_pubkey+0x8c>)
 8007928:	491a      	ldr	r1, [pc, #104]	; (8007994 <se2_save_auth_pubkey+0x90>)
 800792a:	22e0      	movs	r2, #224	; 0xe0
 800792c:	4620      	mov	r0, r4
 800792e:	f005 fda4 	bl	800d47a <memcpy>

    // pick the "hard" key now
    uint8_t     tmp[32];
    rng_buffer(tmp, 32);
 8007932:	2120      	movs	r1, #32
 8007934:	a802      	add	r0, sp, #8
 8007936:	f7fa fee7 	bl	8002708 <rng_buffer>
    se2_write_page(PGN_SE2_HARD_KEY, tmp);
 800793a:	a902      	add	r1, sp, #8
 800793c:	200f      	movs	r0, #15
 800793e:	f7ff fc6d 	bl	800721c <se2_write_page>

    // save SE1 pubkey into "pubkey C"
    se2_write_page(PGN_PUBKEY_C, &pubkey[0]);
 8007942:	9901      	ldr	r1, [sp, #4]
 8007944:	2014      	movs	r0, #20
 8007946:	f7ff fc69 	bl	800721c <se2_write_page>
    se2_write_page(PGN_PUBKEY_C+1, &pubkey[32]);
 800794a:	9b01      	ldr	r3, [sp, #4]
 800794c:	2015      	movs	r0, #21
 800794e:	f103 0120 	add.w	r1, r3, #32
 8007952:	f7ff fc63 	bl	800721c <se2_write_page>

    memcpy(_tbd.auth_pubkey, pubkey, 64);
 8007956:	9b01      	ldr	r3, [sp, #4]
 8007958:	34a0      	adds	r4, #160	; 0xa0
 800795a:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800795e:	f853 1b04 	ldr.w	r1, [r3], #4
 8007962:	f844 1b04 	str.w	r1, [r4], #4
 8007966:	4293      	cmp	r3, r2
 8007968:	d1f9      	bne.n	800795e <se2_save_auth_pubkey+0x5a>

    // commit pubkey to mcu flash
    flash_save_se2_data(&_tbd);
 800796a:	4809      	ldr	r0, [pc, #36]	; (8007990 <se2_save_auth_pubkey+0x8c>)
 800796c:	f7fa fc3e 	bl	80021ec <flash_save_se2_data>

    // lock it all up
    se2_set_protection(PGN_SE2_HARD_KEY, PROT_WP | PROT_ECH | PROT_ECW);
 8007970:	21c2      	movs	r1, #194	; 0xc2
 8007972:	200f      	movs	r0, #15
 8007974:	f7ff fe7e 	bl	8007674 <se2_set_protection>
    se2_set_protection(PGN_PUBKEY_C, PROT_WP | PROT_RP | PROT_AUTH);
 8007978:	2123      	movs	r1, #35	; 0x23
 800797a:	2014      	movs	r0, #20
 800797c:	f7ff fe7a 	bl	8007674 <se2_set_protection>
}
 8007980:	b00a      	add	sp, #40	; 0x28
 8007982:	bd10      	pop	{r4, pc}
 8007984:	20000288 	.word	0x20000288
 8007988:	0801e150 	.word	0x0801e150
 800798c:	0800d550 	.word	0x0800d550
 8007990:	200002e4 	.word	0x200002e4
 8007994:	0801e0b0 	.word	0x0801e0b0

08007998 <trick_pin_hash>:
// - unrelated to hashing of any other PIN codes
// - so doing hmac-sha256 with unique key
//
    void
trick_pin_hash(const char *pin, int pin_len, uint8_t tpin_hash[32])
{
 8007998:	b570      	push	{r4, r5, r6, lr}
    ASSERT(pin_len >= 0);           // 12-12 typical, but empty = blank PIN
 800799a:	1e0e      	subs	r6, r1, #0
// - unrelated to hashing of any other PIN codes
// - so doing hmac-sha256 with unique key
//
    void
trick_pin_hash(const char *pin, int pin_len, uint8_t tpin_hash[32])
{
 800799c:	b0c2      	sub	sp, #264	; 0x108
 800799e:	4605      	mov	r5, r0
 80079a0:	4614      	mov	r4, r2
    ASSERT(pin_len >= 0);           // 12-12 typical, but empty = blank PIN
 80079a2:	da02      	bge.n	80079aa <trick_pin_hash+0x12>
 80079a4:	4812      	ldr	r0, [pc, #72]	; (80079f0 <trick_pin_hash+0x58>)
 80079a6:	f7f9 f819 	bl	80009dc <fatal_error>

    HMAC_CTX ctx;

    hmac_sha256_init(&ctx);
 80079aa:	a801      	add	r0, sp, #4
 80079ac:	f7fd fd5a 	bl	8005464 <hmac_sha256_init>
    hmac_sha256_update(&ctx, (uint8_t *)pin, pin_len);
 80079b0:	4632      	mov	r2, r6
 80079b2:	4629      	mov	r1, r5
 80079b4:	a801      	add	r0, sp, #4
 80079b6:	f7fd fd5b 	bl	8005470 <hmac_sha256_update>
    hmac_sha256_final(&ctx, SE2_SECRETS->tpin_key, tpin_hash);
 80079ba:	4b0e      	ldr	r3, [pc, #56]	; (80079f4 <trick_pin_hash+0x5c>)
 80079bc:	4a0e      	ldr	r2, [pc, #56]	; (80079f8 <trick_pin_hash+0x60>)
 80079be:	f893 10b0 	ldrb.w	r1, [r3, #176]	; 0xb0
 80079c2:	4b0e      	ldr	r3, [pc, #56]	; (80079fc <trick_pin_hash+0x64>)
 80079c4:	29ff      	cmp	r1, #255	; 0xff
 80079c6:	bf0c      	ite	eq
 80079c8:	4619      	moveq	r1, r3
 80079ca:	4611      	movne	r1, r2
 80079cc:	a801      	add	r0, sp, #4
 80079ce:	4622      	mov	r2, r4
 80079d0:	3180      	adds	r1, #128	; 0x80
 80079d2:	f7fd fd63 	bl	800549c <hmac_sha256_final>

    // and a double SHA for good measure
    sha256_single(tpin_hash, 32, tpin_hash);
 80079d6:	4622      	mov	r2, r4
 80079d8:	4620      	mov	r0, r4
 80079da:	2120      	movs	r1, #32
 80079dc:	f7fd fd22 	bl	8005424 <sha256_single>
    sha256_single(tpin_hash, 32, tpin_hash);
 80079e0:	4622      	mov	r2, r4
 80079e2:	2120      	movs	r1, #32
 80079e4:	4620      	mov	r0, r4
 80079e6:	f7fd fd1d 	bl	8005424 <sha256_single>
}
 80079ea:	b042      	add	sp, #264	; 0x108
 80079ec:	bd70      	pop	{r4, r5, r6, pc}
 80079ee:	bf00      	nop
 80079f0:	0800d550 	.word	0x0800d550
 80079f4:	0801e000 	.word	0x0801e000
 80079f8:	0801e0b0 	.word	0x0801e0b0
 80079fc:	200002e4 	.word	0x200002e4

08007a00 <p256_gen_keypair>:

// p256_gen_keypair()
//
    void
p256_gen_keypair(uint8_t privkey[32], uint8_t pubkey[64])
{
 8007a00:	b538      	push	{r3, r4, r5, lr}
 8007a02:	4605      	mov	r5, r0
    uECC_set_rng(rng_for_uECC);
 8007a04:	4808      	ldr	r0, [pc, #32]	; (8007a28 <p256_gen_keypair+0x28>)

// p256_gen_keypair()
//
    void
p256_gen_keypair(uint8_t privkey[32], uint8_t pubkey[64])
{
 8007a06:	460c      	mov	r4, r1
    uECC_set_rng(rng_for_uECC);
 8007a08:	f7fe fede 	bl	80067c8 <uECC_set_rng>

    int ok = uECC_make_key(pubkey, privkey, uECC_secp256r1());
 8007a0c:	f7fe fee2 	bl	80067d4 <uECC_secp256r1>
 8007a10:	4629      	mov	r1, r5
 8007a12:	4602      	mov	r2, r0
 8007a14:	4620      	mov	r0, r4
 8007a16:	f7fe fee5 	bl	80067e4 <uECC_make_key>
    ASSERT(ok == 1);
 8007a1a:	2801      	cmp	r0, #1
 8007a1c:	d002      	beq.n	8007a24 <p256_gen_keypair+0x24>
 8007a1e:	4803      	ldr	r0, [pc, #12]	; (8007a2c <p256_gen_keypair+0x2c>)
 8007a20:	f7f8 ffdc 	bl	80009dc <fatal_error>
 8007a24:	bd38      	pop	{r3, r4, r5, pc}
 8007a26:	bf00      	nop
 8007a28:	080071f1 	.word	0x080071f1
 8007a2c:	0800d550 	.word	0x0800d550

08007a30 <ps256_ecdh>:

// ps256_ecdh()
//
    void
ps256_ecdh(const uint8_t pubkey[64], const uint8_t privkey[32], uint8_t result[32])
{
 8007a30:	b570      	push	{r4, r5, r6, lr}
 8007a32:	4604      	mov	r4, r0
    uECC_set_rng(rng_for_uECC);
 8007a34:	4809      	ldr	r0, [pc, #36]	; (8007a5c <ps256_ecdh+0x2c>)

// ps256_ecdh()
//
    void
ps256_ecdh(const uint8_t pubkey[64], const uint8_t privkey[32], uint8_t result[32])
{
 8007a36:	460d      	mov	r5, r1
 8007a38:	4616      	mov	r6, r2
    uECC_set_rng(rng_for_uECC);
 8007a3a:	f7fe fec5 	bl	80067c8 <uECC_set_rng>

    int ok = uECC_shared_secret(pubkey, privkey, result, uECC_secp256r1());
 8007a3e:	f7fe fec9 	bl	80067d4 <uECC_secp256r1>
 8007a42:	4632      	mov	r2, r6
 8007a44:	4603      	mov	r3, r0
 8007a46:	4629      	mov	r1, r5
 8007a48:	4620      	mov	r0, r4
 8007a4a:	f7fe ff0b 	bl	8006864 <uECC_shared_secret>
    ASSERT(ok == 1);
 8007a4e:	2801      	cmp	r0, #1
 8007a50:	d002      	beq.n	8007a58 <ps256_ecdh+0x28>
 8007a52:	4803      	ldr	r0, [pc, #12]	; (8007a60 <ps256_ecdh+0x30>)
 8007a54:	f7f8 ffc2 	bl	80009dc <fatal_error>
 8007a58:	bd70      	pop	{r4, r5, r6, pc}
 8007a5a:	bf00      	nop
 8007a5c:	080071f1 	.word	0x080071f1
 8007a60:	0800d550 	.word	0x0800d550

08007a64 <se2_read_hard_secret>:

// se2_read_hard_secret()
//
    static bool
se2_read_hard_secret(uint8_t hard_key[32], const uint8_t pin_digest[32])
{
 8007a64:	b510      	push	{r4, lr}
 8007a66:	b0e8      	sub	sp, #416	; 0x1a0
 8007a68:	9002      	str	r0, [sp, #8]
    if(setjmp(error_env)) {
 8007a6a:	4837      	ldr	r0, [pc, #220]	; (8007b48 <se2_read_hard_secret+0xe4>)

// se2_read_hard_secret()
//
    static bool
se2_read_hard_secret(uint8_t hard_key[32], const uint8_t pin_digest[32])
{
 8007a6c:	9103      	str	r1, [sp, #12]
    if(setjmp(error_env)) {
 8007a6e:	f005 fd33 	bl	800d4d8 <setjmp>
 8007a72:	2800      	cmp	r0, #0
 8007a74:	d164      	bne.n	8007b40 <se2_read_hard_secret+0xdc>
    //
    SHA256_CTX ctx;

    // pick a temp key pair, share public part w/ SE2
    uint8_t tmp_privkey[32], tmp_pubkey[64];
    p256_gen_keypair(tmp_privkey, tmp_pubkey);
 8007a76:	a925      	add	r1, sp, #148	; 0x94
 8007a78:	a805      	add	r0, sp, #20
 8007a7a:	f7ff ffc1 	bl	8007a00 <p256_gen_keypair>

    // - this can be mitm-ed, but we sign it next so doesn't matter
    se2_write_page(PGN_PUBKEY_S, &tmp_pubkey[0]);
 8007a7e:	a925      	add	r1, sp, #148	; 0x94
 8007a80:	201e      	movs	r0, #30
 8007a82:	f7ff fbcb 	bl	800721c <se2_write_page>
    se2_write_page(PGN_PUBKEY_S+1, &tmp_pubkey[32]);
 8007a86:	a92d      	add	r1, sp, #180	; 0xb4
 8007a88:	201f      	movs	r0, #31
 8007a8a:	f7ff fbc7 	bl	800721c <se2_write_page>

    // pick nonce
    uint8_t chal[32+32];
    rng_buffer(chal, sizeof(chal));
 8007a8e:	2140      	movs	r1, #64	; 0x40
 8007a90:	a835      	add	r0, sp, #212	; 0xd4
 8007a92:	f7fa fe39 	bl	8002708 <rng_buffer>
    se2_write_buffer(chal, sizeof(chal));
 8007a96:	2140      	movs	r1, #64	; 0x40
 8007a98:	a835      	add	r0, sp, #212	; 0xd4
 8007a9a:	f7ff fbaf 	bl	80071fc <se2_write_buffer>

    // md = ngu.hash.sha256s(T_pubkey + chal[0:32])
    sha256_init(&ctx);
 8007a9e:	a855      	add	r0, sp, #340	; 0x154
 8007aa0:	f7fd fc56 	bl	8005350 <sha256_init>
    sha256_update(&ctx, tmp_pubkey, 64);
 8007aa4:	2240      	movs	r2, #64	; 0x40
 8007aa6:	a925      	add	r1, sp, #148	; 0x94
 8007aa8:	a855      	add	r0, sp, #340	; 0x154
 8007aaa:	f7fd fc61 	bl	8005370 <sha256_update>
    sha256_update(&ctx, chal, 32);      // only first 32 bytes
 8007aae:	2220      	movs	r2, #32
 8007ab0:	a935      	add	r1, sp, #212	; 0xd4
 8007ab2:	a855      	add	r0, sp, #340	; 0x154
 8007ab4:	f7fd fc5c 	bl	8005370 <sha256_update>

    uint8_t md[32];
    sha256_final(&ctx, md);
 8007ab8:	a90d      	add	r1, sp, #52	; 0x34
 8007aba:	a855      	add	r0, sp, #340	; 0x154
 8007abc:	f7fd fc9e 	bl	80053fc <sha256_final>
    // Get that digest signed by SE1 now, and doing that requires
    // the main pin, because the required slot requires auth by that key.
    // - this is the critical step attackers would not be able to emulate w/o SE1 contents
    // - fails here if PIN wrong
    uint8_t signature[64];
    int arc = ae_sign_authed(KEYNUM_joiner_key, md, signature, KEYNUM_main_pin, pin_digest);
 8007ac0:	9b03      	ldr	r3, [sp, #12]
 8007ac2:	9300      	str	r3, [sp, #0]
 8007ac4:	aa45      	add	r2, sp, #276	; 0x114
 8007ac6:	2303      	movs	r3, #3
 8007ac8:	a90d      	add	r1, sp, #52	; 0x34
 8007aca:	2007      	movs	r0, #7
 8007acc:	f7fb f96e 	bl	8002dac <ae_sign_authed>
    CHECK_RIGHT(arc == 0);
 8007ad0:	4604      	mov	r4, r0
 8007ad2:	b110      	cbz	r0, 8007ada <se2_read_hard_secret+0x76>
 8007ad4:	f240 411a 	movw	r1, #1050	; 0x41a
 8007ad8:	e00f      	b.n	8007afa <se2_read_hard_secret+0x96>

    // "Authenticate ECDSA Public Key" = 0xA8
    // cs_offset=32   ecdh_keynum=0=pubA ECDH=1 WR=0
    uint8_t param = ((32-1) << 3) | (0 << 2) | 0x2;
 8007ada:	23fa      	movs	r3, #250	; 0xfa
 8007adc:	f88d 3013 	strb.w	r3, [sp, #19]
    se2_write_n(0xA8, &param, signature, 64);
 8007ae0:	aa45      	add	r2, sp, #276	; 0x114
 8007ae2:	2340      	movs	r3, #64	; 0x40
 8007ae4:	f10d 0113 	add.w	r1, sp, #19
 8007ae8:	20a8      	movs	r0, #168	; 0xa8
 8007aea:	f7ff fb1b 	bl	8007124 <se2_write_n>
    CHECK_RIGHT(se2_read1() == RC_SUCCESS);
 8007aee:	f7ff fb77 	bl	80071e0 <se2_read1>
 8007af2:	28aa      	cmp	r0, #170	; 0xaa
 8007af4:	d004      	beq.n	8007b00 <se2_read_hard_secret+0x9c>
 8007af6:	f44f 6184 	mov.w	r1, #1056	; 0x420
 8007afa:	4813      	ldr	r0, [pc, #76]	; (8007b48 <se2_read_hard_secret+0xe4>)
 8007afc:	f005 fcf2 	bl	800d4e4 <longjmp>

    uint8_t shared_x[32], shared_secret[32];
    ps256_ecdh(rom_secrets->se2.pubkey_A, tmp_privkey, shared_x);
 8007b00:	aa15      	add	r2, sp, #84	; 0x54
 8007b02:	a905      	add	r1, sp, #20
 8007b04:	4811      	ldr	r0, [pc, #68]	; (8007b4c <se2_read_hard_secret+0xe8>)
 8007b06:	f7ff ff93 	bl	8007a30 <ps256_ecdh>

    // shared secret S will be SHA over X of shared ECDH point + chal[32:]
    //  s = ngu.hash.sha256s(x + chal[32:])
    sha256_init(&ctx);
 8007b0a:	a855      	add	r0, sp, #340	; 0x154
 8007b0c:	f7fd fc20 	bl	8005350 <sha256_init>
    sha256_update(&ctx, shared_x, 32);
 8007b10:	2220      	movs	r2, #32
 8007b12:	a915      	add	r1, sp, #84	; 0x54
 8007b14:	a855      	add	r0, sp, #340	; 0x154
 8007b16:	f7fd fc2b 	bl	8005370 <sha256_update>
    sha256_update(&ctx, &chal[32], 32);      // second half
 8007b1a:	2220      	movs	r2, #32
 8007b1c:	a93d      	add	r1, sp, #244	; 0xf4
 8007b1e:	a855      	add	r0, sp, #340	; 0x154
 8007b20:	f7fd fc26 	bl	8005370 <sha256_update>
    sha256_final(&ctx, shared_secret);
 8007b24:	a91d      	add	r1, sp, #116	; 0x74
 8007b26:	a855      	add	r0, sp, #340	; 0x154
 8007b28:	f7fd fc68 	bl	80053fc <sha256_final>

    se2_read_encrypted(PGN_SE2_HARD_KEY, hard_key, 2, shared_secret);
 8007b2c:	200f      	movs	r0, #15
 8007b2e:	ab1d      	add	r3, sp, #116	; 0x74
 8007b30:	2202      	movs	r2, #2
 8007b32:	9902      	ldr	r1, [sp, #8]
 8007b34:	f7ff fc58 	bl	80073e8 <se2_read_encrypted>

    // CONCERN: secret "S" is retained in SE2's sram. No API to clear it.
    // - but you'd need to see our copy of that value to make use of it
    // - and PIN checked already to get here, so you could re-do anyway
    se2_clear_volatile();
 8007b38:	f7ff fdf8 	bl	800772c <se2_clear_volatile>

    return false;
 8007b3c:	4620      	mov	r0, r4
 8007b3e:	e000      	b.n	8007b42 <se2_read_hard_secret+0xde>
    static bool
se2_read_hard_secret(uint8_t hard_key[32], const uint8_t pin_digest[32])
{
    if(setjmp(error_env)) {
        DEBUG("se2_read_hard_secret");
        return true;
 8007b40:	2001      	movs	r0, #1
    // - but you'd need to see our copy of that value to make use of it
    // - and PIN checked already to get here, so you could re-do anyway
    se2_clear_volatile();

    return false;
}
 8007b42:	b068      	add	sp, #416	; 0x1a0
 8007b44:	bd10      	pop	{r4, pc}
 8007b46:	bf00      	nop
 8007b48:	20000288 	.word	0x20000288
 8007b4c:	0801e0d0 	.word	0x0801e0d0

08007b50 <se2_calc_seed_key>:

// se2_calc_seed_key()
//
    static bool
se2_calc_seed_key(uint8_t aes_key[32], const mcu_key_t *mcu_key, const uint8_t pin_digest[32])
{
 8007b50:	b570      	push	{r4, r5, r6, lr}
 8007b52:	b0d2      	sub	sp, #328	; 0x148
 8007b54:	4614      	mov	r4, r2
    // Gather key parts from all over. Combine them w/ HMAC into a AES-256 key
    uint8_t se1_easy_key[32], se1_hard_key[32];
    se2_read_encrypted(PGN_SE2_EASY_KEY, se1_easy_key, 0, rom_secrets->se2.pairing);
 8007b56:	4b15      	ldr	r3, [pc, #84]	; (8007bac <se2_calc_seed_key+0x5c>)
 8007b58:	2200      	movs	r2, #0

// se2_calc_seed_key()
//
    static bool
se2_calc_seed_key(uint8_t aes_key[32], const mcu_key_t *mcu_key, const uint8_t pin_digest[32])
{
 8007b5a:	4605      	mov	r5, r0
 8007b5c:	460e      	mov	r6, r1
    // Gather key parts from all over. Combine them w/ HMAC into a AES-256 key
    uint8_t se1_easy_key[32], se1_hard_key[32];
    se2_read_encrypted(PGN_SE2_EASY_KEY, se1_easy_key, 0, rom_secrets->se2.pairing);
 8007b5e:	200e      	movs	r0, #14
 8007b60:	a901      	add	r1, sp, #4
 8007b62:	f7ff fc41 	bl	80073e8 <se2_read_encrypted>

    if(se2_read_hard_secret(se1_hard_key, pin_digest)) return true;
 8007b66:	4621      	mov	r1, r4
 8007b68:	a809      	add	r0, sp, #36	; 0x24
 8007b6a:	f7ff ff7b 	bl	8007a64 <se2_read_hard_secret>
 8007b6e:	4604      	mov	r4, r0
 8007b70:	b9c8      	cbnz	r0, 8007ba6 <se2_calc_seed_key+0x56>

    HMAC_CTX ctx;
    hmac_sha256_init(&ctx);
 8007b72:	a811      	add	r0, sp, #68	; 0x44
 8007b74:	f7fd fc76 	bl	8005464 <hmac_sha256_init>
    hmac_sha256_update(&ctx, mcu_key->value, 32);
 8007b78:	2220      	movs	r2, #32
 8007b7a:	4631      	mov	r1, r6
 8007b7c:	a811      	add	r0, sp, #68	; 0x44
 8007b7e:	f7fd fc77 	bl	8005470 <hmac_sha256_update>
    hmac_sha256_update(&ctx, se1_hard_key, 32);
 8007b82:	2220      	movs	r2, #32
 8007b84:	a909      	add	r1, sp, #36	; 0x24
 8007b86:	a811      	add	r0, sp, #68	; 0x44
 8007b88:	f7fd fc72 	bl	8005470 <hmac_sha256_update>
    hmac_sha256_update(&ctx, se1_easy_key, 32);
 8007b8c:	2220      	movs	r2, #32
 8007b8e:	a901      	add	r1, sp, #4
 8007b90:	a811      	add	r0, sp, #68	; 0x44
 8007b92:	f7fd fc6d 	bl	8005470 <hmac_sha256_update>

    // combine them all using anther MCU key via HMAC-SHA256
    hmac_sha256_final(&ctx, rom_secrets->mcu_hmac_key, aes_key);
 8007b96:	a811      	add	r0, sp, #68	; 0x44
 8007b98:	462a      	mov	r2, r5
 8007b9a:	4905      	ldr	r1, [pc, #20]	; (8007bb0 <se2_calc_seed_key+0x60>)
 8007b9c:	f7fd fc7e 	bl	800549c <hmac_sha256_final>
    hmac_sha256_init(&ctx);     // clear secrets
 8007ba0:	a811      	add	r0, sp, #68	; 0x44
 8007ba2:	f7fd fc5f 	bl	8005464 <hmac_sha256_init>

    //puts2("aeskey="); hex_dump(aes_key, 32);
    return false;
}
 8007ba6:	4620      	mov	r0, r4
 8007ba8:	b052      	add	sp, #328	; 0x148
 8007baa:	bd70      	pop	{r4, r5, r6, pc}
 8007bac:	0801e0b0 	.word	0x0801e0b0
 8007bb0:	0801e090 	.word	0x0801e090

08007bb4 <se2_setup>:

// se2_setup()
//
    void
se2_setup(void)
{
 8007bb4:	b5f0      	push	{r4, r5, r6, r7, lr}
    if(i2c_port.Instance == I2C2) {
 8007bb6:	4e1b      	ldr	r6, [pc, #108]	; (8007c24 <se2_setup+0x70>)
 8007bb8:	4f1b      	ldr	r7, [pc, #108]	; (8007c28 <se2_setup+0x74>)
 8007bba:	6833      	ldr	r3, [r6, #0]
 8007bbc:	42bb      	cmp	r3, r7

// se2_setup()
//
    void
se2_setup(void)
{
 8007bbe:	b089      	sub	sp, #36	; 0x24
    if(i2c_port.Instance == I2C2) {
 8007bc0:	d02d      	beq.n	8007c1e <se2_setup+0x6a>
    STATIC_ASSERT(offsetof(trick_slot_t, pin_len) == 8+64+16);
    STATIC_ASSERT(offsetof(trick_slot_t, blank_slots) == 8+64+16+4);
    STATIC_ASSERT(offsetof(trick_slot_t, spare) == 8+64+16+4+4);

    // unlikely we need:
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007bc2:	4b1a      	ldr	r3, [pc, #104]	; (8007c2c <se2_setup+0x78>)
    __HAL_RCC_I2C2_CLK_ENABLE();

    // I2C2 bus is dedicated to our DS28C36B part.
    // - B13 and B14
    GPIO_InitTypeDef setup = {
 8007bc4:	4d1a      	ldr	r5, [pc, #104]	; (8007c30 <se2_setup+0x7c>)
    STATIC_ASSERT(offsetof(trick_slot_t, pin_len) == 8+64+16);
    STATIC_ASSERT(offsetof(trick_slot_t, blank_slots) == 8+64+16+4);
    STATIC_ASSERT(offsetof(trick_slot_t, spare) == 8+64+16+4+4);

    // unlikely we need:
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007bc6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8007bc8:	f042 0202 	orr.w	r2, r2, #2
 8007bcc:	64da      	str	r2, [r3, #76]	; 0x4c
 8007bce:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8007bd0:	f002 0202 	and.w	r2, r2, #2
 8007bd4:	9201      	str	r2, [sp, #4]
 8007bd6:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_I2C2_CLK_ENABLE();
 8007bd8:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8007bda:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8007bde:	659a      	str	r2, [r3, #88]	; 0x58
 8007be0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8007be2:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8007be6:	9302      	str	r3, [sp, #8]
 8007be8:	9b02      	ldr	r3, [sp, #8]

    // I2C2 bus is dedicated to our DS28C36B part.
    // - B13 and B14
    GPIO_InitTypeDef setup = {
 8007bea:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8007bec:	ac03      	add	r4, sp, #12
 8007bee:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8007bf0:	682b      	ldr	r3, [r5, #0]
        .Mode = GPIO_MODE_AF_OD,
        .Pull = GPIO_NOPULL,
        .Speed = GPIO_SPEED_FREQ_VERY_HIGH,
        .Alternate = GPIO_AF4_I2C2,
    };
    HAL_GPIO_Init(GPIOB, &setup);
 8007bf2:	4810      	ldr	r0, [pc, #64]	; (8007c34 <se2_setup+0x80>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
    __HAL_RCC_I2C2_CLK_ENABLE();

    // I2C2 bus is dedicated to our DS28C36B part.
    // - B13 and B14
    GPIO_InitTypeDef setup = {
 8007bf4:	6023      	str	r3, [r4, #0]
        .Mode = GPIO_MODE_AF_OD,
        .Pull = GPIO_NOPULL,
        .Speed = GPIO_SPEED_FREQ_VERY_HIGH,
        .Alternate = GPIO_AF4_I2C2,
    };
    HAL_GPIO_Init(GPIOB, &setup);
 8007bf6:	a903      	add	r1, sp, #12
 8007bf8:	f7f9 f9e2 	bl	8000fc0 <HAL_GPIO_Init>

    // Setup HAL device
    memset(&i2c_port, 0, sizeof(i2c_port));
 8007bfc:	224c      	movs	r2, #76	; 0x4c
 8007bfe:	2100      	movs	r1, #0
 8007c00:	4630      	mov	r0, r6
 8007c02:	f005 fc60 	bl	800d4c6 <memset>
    i2c_port.Instance = I2C2;

    // see I2C_InitTypeDef
    i2c_port.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8007c06:	2301      	movs	r3, #1
 8007c08:	60f3      	str	r3, [r6, #12]
    //i2c_port.Init.Timing = 0x0050174f;     // ie. 1Mhz "fast mode plus" in CubeMX @ 120Mhz
    i2c_port.Init.Timing = 0x00b03fb8;     // 400khz "fast mode" in CubeMX @ 120Mhz (measured ok)
    //i2c_port.Init.Timing = 0xf01075ff;     // 40khz "std mode" in CubeMX @ 120Mhz (works)
    i2c_port.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;

    HAL_StatusTypeDef rv = HAL_I2C_Init(&i2c_port);
 8007c0a:	4630      	mov	r0, r6
    i2c_port.Instance = I2C2;

    // see I2C_InitTypeDef
    i2c_port.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
    //i2c_port.Init.Timing = 0x0050174f;     // ie. 1Mhz "fast mode plus" in CubeMX @ 120Mhz
    i2c_port.Init.Timing = 0x00b03fb8;     // 400khz "fast mode" in CubeMX @ 120Mhz (measured ok)
 8007c0c:	4b0a      	ldr	r3, [pc, #40]	; (8007c38 <se2_setup+0x84>)
    };
    HAL_GPIO_Init(GPIOB, &setup);

    // Setup HAL device
    memset(&i2c_port, 0, sizeof(i2c_port));
    i2c_port.Instance = I2C2;
 8007c0e:	6037      	str	r7, [r6, #0]

    // see I2C_InitTypeDef
    i2c_port.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
    //i2c_port.Init.Timing = 0x0050174f;     // ie. 1Mhz "fast mode plus" in CubeMX @ 120Mhz
    i2c_port.Init.Timing = 0x00b03fb8;     // 400khz "fast mode" in CubeMX @ 120Mhz (measured ok)
 8007c10:	6073      	str	r3, [r6, #4]
    //i2c_port.Init.Timing = 0xf01075ff;     // 40khz "std mode" in CubeMX @ 120Mhz (works)
    i2c_port.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;

    HAL_StatusTypeDef rv = HAL_I2C_Init(&i2c_port);
 8007c12:	f003 fd5f 	bl	800b6d4 <HAL_I2C_Init>
    ASSERT(rv == HAL_OK);
 8007c16:	b110      	cbz	r0, 8007c1e <se2_setup+0x6a>
 8007c18:	4808      	ldr	r0, [pc, #32]	; (8007c3c <se2_setup+0x88>)
 8007c1a:	f7f8 fedf 	bl	80009dc <fatal_error>

    // compile time checks
    STATIC_ASSERT(offsetof(rom_secrets_t, se2) % 8 == 0);
    STATIC_ASSERT(PGN_LAST_TRICK < PGN_SE2_EASY_KEY);
}
 8007c1e:	b009      	add	sp, #36	; 0x24
 8007c20:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007c22:	bf00      	nop
 8007c24:	2000023c 	.word	0x2000023c
 8007c28:	40005800 	.word	0x40005800
 8007c2c:	40021000 	.word	0x40021000
 8007c30:	0800e768 	.word	0x0800e768
 8007c34:	48000400 	.word	0x48000400
 8007c38:	00b03fb8 	.word	0x00b03fb8
 8007c3c:	0800d550 	.word	0x0800d550

08007c40 <se2_clear_tricks>:
//
// Wipe all the trick PIN's and their data.
//
    void
se2_clear_tricks(void)
{
 8007c40:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007c42:	b089      	sub	sp, #36	; 0x24
    se2_setup();
 8007c44:	f7ff ffb6 	bl	8007bb4 <se2_setup>

    // funny business means MitM?
    if(setjmp(error_env)) fatal_mitm();
 8007c48:	480f      	ldr	r0, [pc, #60]	; (8007c88 <se2_clear_tricks+0x48>)
 8007c4a:	f005 fc45 	bl	800d4d8 <setjmp>
 8007c4e:	4604      	mov	r4, r0
 8007c50:	b108      	cbz	r0, 8007c56 <se2_clear_tricks+0x16>
 8007c52:	f7f8 fecd 	bl	80009f0 <fatal_mitm>

    // wipe with all zeros
    uint8_t tmp[32] = {0};
 8007c56:	4601      	mov	r1, r0
 8007c58:	2220      	movs	r2, #32
 8007c5a:	4668      	mov	r0, sp
 8007c5c:	f005 fc33 	bl	800d4c6 <memset>
    for(int pn=0; pn <= PGN_LAST_TRICK; pn++) {
        se2_write_encrypted(pn, tmp, 0, SE2_SECRETS->pairing);
 8007c60:	4f0a      	ldr	r7, [pc, #40]	; (8007c8c <se2_clear_tricks+0x4c>)
 8007c62:	4e0b      	ldr	r6, [pc, #44]	; (8007c90 <se2_clear_tricks+0x50>)
 8007c64:	4d0b      	ldr	r5, [pc, #44]	; (8007c94 <se2_clear_tricks+0x54>)
 8007c66:	f897 30b0 	ldrb.w	r3, [r7, #176]	; 0xb0
 8007c6a:	b2e0      	uxtb	r0, r4
 8007c6c:	2bff      	cmp	r3, #255	; 0xff
 8007c6e:	bf0c      	ite	eq
 8007c70:	4633      	moveq	r3, r6
 8007c72:	462b      	movne	r3, r5
 8007c74:	2200      	movs	r2, #0
 8007c76:	4669      	mov	r1, sp
    // funny business means MitM?
    if(setjmp(error_env)) fatal_mitm();

    // wipe with all zeros
    uint8_t tmp[32] = {0};
    for(int pn=0; pn <= PGN_LAST_TRICK; pn++) {
 8007c78:	3401      	adds	r4, #1
        se2_write_encrypted(pn, tmp, 0, SE2_SECRETS->pairing);
 8007c7a:	f7ff fc37 	bl	80074ec <se2_write_encrypted>
    // funny business means MitM?
    if(setjmp(error_env)) fatal_mitm();

    // wipe with all zeros
    uint8_t tmp[32] = {0};
    for(int pn=0; pn <= PGN_LAST_TRICK; pn++) {
 8007c7e:	2c0e      	cmp	r4, #14
 8007c80:	d1f1      	bne.n	8007c66 <se2_clear_tricks+0x26>
        se2_write_encrypted(pn, tmp, 0, SE2_SECRETS->pairing);
    }
}
 8007c82:	b009      	add	sp, #36	; 0x24
 8007c84:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007c86:	bf00      	nop
 8007c88:	20000288 	.word	0x20000288
 8007c8c:	0801e000 	.word	0x0801e000
 8007c90:	200002e4 	.word	0x200002e4
 8007c94:	0801e0b0 	.word	0x0801e0b0

08007c98 <se2_read_trick_data>:
//
// Read 1 or 2 data slots that immediately follow a trick PIN slot.
//
    void
se2_read_trick_data(int slot_num, uint16_t tc_flags, uint8_t data[64])
{
 8007c98:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 8007c9c:	9002      	str	r0, [sp, #8]
    if(setjmp(error_env)) fatal_mitm();
 8007c9e:	4818      	ldr	r0, [pc, #96]	; (8007d00 <se2_read_trick_data+0x68>)
//
// Read 1 or 2 data slots that immediately follow a trick PIN slot.
//
    void
se2_read_trick_data(int slot_num, uint16_t tc_flags, uint8_t data[64])
{
 8007ca0:	9103      	str	r1, [sp, #12]
 8007ca2:	9201      	str	r2, [sp, #4]
    if(setjmp(error_env)) fatal_mitm();
 8007ca4:	f005 fc18 	bl	800d4d8 <setjmp>
 8007ca8:	4605      	mov	r5, r0
 8007caa:	b108      	cbz	r0, 8007cb0 <se2_read_trick_data+0x18>
 8007cac:	f7f8 fea0 	bl	80009f0 <fatal_mitm>

    se2_setup();
    se2_read_encrypted(slot_num+1, &data[0], 0, SE2_SECRETS->pairing);
 8007cb0:	f8df 8058 	ldr.w	r8, [pc, #88]	; 8007d0c <se2_read_trick_data+0x74>
 8007cb4:	4f13      	ldr	r7, [pc, #76]	; (8007d04 <se2_read_trick_data+0x6c>)
 8007cb6:	4e14      	ldr	r6, [pc, #80]	; (8007d08 <se2_read_trick_data+0x70>)
    void
se2_read_trick_data(int slot_num, uint16_t tc_flags, uint8_t data[64])
{
    if(setjmp(error_env)) fatal_mitm();

    se2_setup();
 8007cb8:	f7ff ff7c 	bl	8007bb4 <se2_setup>
    se2_read_encrypted(slot_num+1, &data[0], 0, SE2_SECRETS->pairing);
 8007cbc:	f89d 4008 	ldrb.w	r4, [sp, #8]
 8007cc0:	f898 30b0 	ldrb.w	r3, [r8, #176]	; 0xb0
 8007cc4:	9901      	ldr	r1, [sp, #4]
 8007cc6:	1c60      	adds	r0, r4, #1
 8007cc8:	2bff      	cmp	r3, #255	; 0xff
 8007cca:	bf0c      	ite	eq
 8007ccc:	463b      	moveq	r3, r7
 8007cce:	4633      	movne	r3, r6
 8007cd0:	462a      	mov	r2, r5
 8007cd2:	b2c0      	uxtb	r0, r0
 8007cd4:	f7ff fb88 	bl	80073e8 <se2_read_encrypted>

    if(tc_flags & TC_XPRV_WALLET) {
 8007cd8:	9b03      	ldr	r3, [sp, #12]
 8007cda:	051b      	lsls	r3, r3, #20
 8007cdc:	d50c      	bpl.n	8007cf8 <se2_read_trick_data+0x60>
        se2_read_encrypted(slot_num+2, &data[32], 0, SE2_SECRETS->pairing);
 8007cde:	f898 30b0 	ldrb.w	r3, [r8, #176]	; 0xb0
 8007ce2:	9901      	ldr	r1, [sp, #4]
 8007ce4:	1ca0      	adds	r0, r4, #2
 8007ce6:	2bff      	cmp	r3, #255	; 0xff
 8007ce8:	bf0c      	ite	eq
 8007cea:	463b      	moveq	r3, r7
 8007cec:	4633      	movne	r3, r6
 8007cee:	462a      	mov	r2, r5
 8007cf0:	3120      	adds	r1, #32
 8007cf2:	b2c0      	uxtb	r0, r0
 8007cf4:	f7ff fb78 	bl	80073e8 <se2_read_encrypted>
    }
}
 8007cf8:	b004      	add	sp, #16
 8007cfa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8007cfe:	bf00      	nop
 8007d00:	20000288 	.word	0x20000288
 8007d04:	200002e4 	.word	0x200002e4
 8007d08:	0801e0b0 	.word	0x0801e0b0
 8007d0c:	0801e000 	.word	0x0801e000

08007d10 <se2_test_trick_pin>:
// - if not in safety mode, the side-effect (brick, etc) will have happened before this returns
// - will always check all slots so bus traffic doesn't change based on result.
//
    bool
se2_test_trick_pin(const char *pin, int pin_len, trick_slot_t *found_slot, bool safety_mode)
{
 8007d10:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8007d14:	b0fd      	sub	sp, #500	; 0x1f4
 8007d16:	e88d 000c 	stmia.w	sp, {r2, r3}
 8007d1a:	9003      	str	r0, [sp, #12]
 8007d1c:	9102      	str	r1, [sp, #8]
    se2_setup();
 8007d1e:	f7ff ff49 	bl	8007bb4 <se2_setup>

    // error handling.
    if(setjmp(error_env)) {
 8007d22:	4866      	ldr	r0, [pc, #408]	; (8007ebc <se2_test_trick_pin+0x1ac>)
 8007d24:	f005 fbd8 	bl	800d4d8 <setjmp>
 8007d28:	4604      	mov	r4, r0
 8007d2a:	b128      	cbz	r0, 8007d38 <se2_test_trick_pin+0x28>
        // remember messing w/ i2c bus during operation could lead here.
        if(!safety_mode) fatal_mitm();
 8007d2c:	9b01      	ldr	r3, [sp, #4]
 8007d2e:	b10b      	cbz	r3, 8007d34 <se2_test_trick_pin+0x24>

        return false;
 8007d30:	2000      	movs	r0, #0
 8007d32:	e0c0      	b.n	8007eb6 <se2_test_trick_pin+0x1a6>
    se2_setup();

    // error handling.
    if(setjmp(error_env)) {
        // remember messing w/ i2c bus during operation could lead here.
        if(!safety_mode) fatal_mitm();
 8007d34:	f7f8 fe5c 	bl	80009f0 <fatal_mitm>

        return false;
    }

    // zero-length pin not allowed
    if(!pin_len) return false;
 8007d38:	9b02      	ldr	r3, [sp, #8]
 8007d3a:	2b00      	cmp	r3, #0
 8007d3c:	d0f8      	beq.n	8007d30 <se2_test_trick_pin+0x20>

    uint8_t     tpin_hash[32];
    trick_pin_hash(pin, pin_len, tpin_hash);
 8007d3e:	aa04      	add	r2, sp, #16
 8007d40:	4619      	mov	r1, r3
 8007d42:	9803      	ldr	r0, [sp, #12]

    // always read all data first, and without any time differences
    uint8_t slots[NUM_TRICKS][32];
    int pn = PGN_TRICK(0);
    for(int i=0; i<NUM_TRICKS; i++, pn++) {
        se2_read_encrypted(pn, slots[i], 0, SE2_SECRETS->pairing);
 8007d44:	f8df 818c 	ldr.w	r8, [pc, #396]	; 8007ed4 <se2_test_trick_pin+0x1c4>
 8007d48:	4f5d      	ldr	r7, [pc, #372]	; (8007ec0 <se2_test_trick_pin+0x1b0>)
 8007d4a:	4d5e      	ldr	r5, [pc, #376]	; (8007ec4 <se2_test_trick_pin+0x1b4>)

    // zero-length pin not allowed
    if(!pin_len) return false;

    uint8_t     tpin_hash[32];
    trick_pin_hash(pin, pin_len, tpin_hash);
 8007d4c:	f7ff fe24 	bl	8007998 <trick_pin_hash>

    // always read all data first, and without any time differences
    uint8_t slots[NUM_TRICKS][32];
    int pn = PGN_TRICK(0);
    for(int i=0; i<NUM_TRICKS; i++, pn++) {
        se2_read_encrypted(pn, slots[i], 0, SE2_SECRETS->pairing);
 8007d50:	f898 30b0 	ldrb.w	r3, [r8, #176]	; 0xb0
 8007d54:	ae0c      	add	r6, sp, #48	; 0x30
 8007d56:	2bff      	cmp	r3, #255	; 0xff
 8007d58:	bf0c      	ite	eq
 8007d5a:	463b      	moveq	r3, r7
 8007d5c:	462b      	movne	r3, r5
 8007d5e:	eb06 1144 	add.w	r1, r6, r4, lsl #5
 8007d62:	b2e0      	uxtb	r0, r4
 8007d64:	2200      	movs	r2, #0
    trick_pin_hash(pin, pin_len, tpin_hash);

    // always read all data first, and without any time differences
    uint8_t slots[NUM_TRICKS][32];
    int pn = PGN_TRICK(0);
    for(int i=0; i<NUM_TRICKS; i++, pn++) {
 8007d66:	3401      	adds	r4, #1
        se2_read_encrypted(pn, slots[i], 0, SE2_SECRETS->pairing);
 8007d68:	f7ff fb3e 	bl	80073e8 <se2_read_encrypted>
    trick_pin_hash(pin, pin_len, tpin_hash);

    // always read all data first, and without any time differences
    uint8_t slots[NUM_TRICKS][32];
    int pn = PGN_TRICK(0);
    for(int i=0; i<NUM_TRICKS; i++, pn++) {
 8007d6c:	2c0e      	cmp	r4, #14
 8007d6e:	d1ef      	bne.n	8007d50 <se2_test_trick_pin+0x40>
        se2_read_encrypted(pn, slots[i], 0, SE2_SECRETS->pairing);
    }
    se2_clear_volatile();
 8007d70:	f7ff fcdc 	bl	800772c <se2_clear_volatile>
 8007d74:	2500      	movs	r5, #0
 8007d76:	462f      	mov	r7, r5
 8007d78:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    // Look for matches
    int found = -1;
    uint32_t blank = 0;
    for(int i=0; i<NUM_TRICKS; i++) {
        uint8_t *here = &slots[i][0];
        if(check_equal(here, tpin_hash, 28)) {
 8007d7c:	f04f 091c 	mov.w	r9, #28
 8007d80:	eb06 1845 	add.w	r8, r6, r5, lsl #5
 8007d84:	464a      	mov	r2, r9
 8007d86:	a904      	add	r1, sp, #16
 8007d88:	4640      	mov	r0, r8
 8007d8a:	f7fa fc6c 	bl	8002666 <check_equal>
            // we have a winner... but keep checking
            found = i;
        }
        blank |= (!!check_all_zeros(here, 32)) << i;
 8007d8e:	2120      	movs	r1, #32
    // Look for matches
    int found = -1;
    uint32_t blank = 0;
    for(int i=0; i<NUM_TRICKS; i++) {
        uint8_t *here = &slots[i][0];
        if(check_equal(here, tpin_hash, 28)) {
 8007d90:	2800      	cmp	r0, #0
 8007d92:	bf18      	it	ne
 8007d94:	462c      	movne	r4, r5
            // we have a winner... but keep checking
            found = i;
        }
        blank |= (!!check_all_zeros(here, 32)) << i;
 8007d96:	4640      	mov	r0, r8
 8007d98:	f7fa fc56 	bl	8002648 <check_all_zeros>
 8007d9c:	40a8      	lsls	r0, r5
    se2_clear_volatile();
    
    // Look for matches
    int found = -1;
    uint32_t blank = 0;
    for(int i=0; i<NUM_TRICKS; i++) {
 8007d9e:	3501      	adds	r5, #1
 8007da0:	2d0e      	cmp	r5, #14
        uint8_t *here = &slots[i][0];
        if(check_equal(here, tpin_hash, 28)) {
            // we have a winner... but keep checking
            found = i;
        }
        blank |= (!!check_all_zeros(here, 32)) << i;
 8007da2:	ea47 0700 	orr.w	r7, r7, r0
    se2_clear_volatile();
    
    // Look for matches
    int found = -1;
    uint32_t blank = 0;
    for(int i=0; i<NUM_TRICKS; i++) {
 8007da6:	d1eb      	bne.n	8007d80 <se2_test_trick_pin+0x70>
            // we have a winner... but keep checking
            found = i;
        }
        blank |= (!!check_all_zeros(here, 32)) << i;
    }
    rng_delay();
 8007da8:	f7fa fcc5 	bl	8002736 <rng_delay>

    memset(found_slot, 0, sizeof(trick_slot_t));
 8007dac:	2280      	movs	r2, #128	; 0x80
 8007dae:	2100      	movs	r1, #0
 8007db0:	9800      	ldr	r0, [sp, #0]
 8007db2:	f005 fb88 	bl	800d4c6 <memset>

    if(safety_mode) {
 8007db6:	9b01      	ldr	r3, [sp, #4]
 8007db8:	b10b      	cbz	r3, 8007dbe <se2_test_trick_pin+0xae>
        // tell them which slots are available, iff working after main pin is set
        found_slot->blank_slots = blank;
 8007dba:	9b00      	ldr	r3, [sp, #0]
 8007dbc:	65df      	str	r7, [r3, #92]	; 0x5c
    }

    if(found >= 0) {
 8007dbe:	1c63      	adds	r3, r4, #1
 8007dc0:	d106      	bne.n	8007dd0 <se2_test_trick_pin+0xc0>

        return true;
    } else {
    fake_out:
        // do similar work? 
        found_slot->slot_num = -1;
 8007dc2:	9a00      	ldr	r2, [sp, #0]
 8007dc4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8007dc8:	6013      	str	r3, [r2, #0]
        rng_delay();
 8007dca:	f7fa fcb4 	bl	8002736 <rng_delay>
 8007dce:	e7af      	b.n	8007d30 <se2_test_trick_pin+0x20>
        found_slot->blank_slots = blank;
    }

    if(found >= 0) {
        // match found
        found_slot->slot_num = found;
 8007dd0:	9b00      	ldr	r3, [sp, #0]

        // 28 bytes are the PIN hash, last 4 bytes is our meta-data.
        // following slot(s) may hold wallet data (32-64 bytes)
        memcpy(&found_slot->tc_flags, &slots[found][28], 2);
 8007dd2:	9800      	ldr	r0, [sp, #0]
        found_slot->blank_slots = blank;
    }

    if(found >= 0) {
        // match found
        found_slot->slot_num = found;
 8007dd4:	601c      	str	r4, [r3, #0]

        // 28 bytes are the PIN hash, last 4 bytes is our meta-data.
        // following slot(s) may hold wallet data (32-64 bytes)
        memcpy(&found_slot->tc_flags, &slots[found][28], 2);
 8007dd6:	0163      	lsls	r3, r4, #5
 8007dd8:	aa0c      	add	r2, sp, #48	; 0x30
 8007dda:	f103 011c 	add.w	r1, r3, #28
        memcpy(&found_slot->tc_arg, &slots[found][30], 2);
 8007dde:	331e      	adds	r3, #30
        // match found
        found_slot->slot_num = found;

        // 28 bytes are the PIN hash, last 4 bytes is our meta-data.
        // following slot(s) may hold wallet data (32-64 bytes)
        memcpy(&found_slot->tc_flags, &slots[found][28], 2);
 8007de0:	5a51      	ldrh	r1, [r2, r1]
 8007de2:	8081      	strh	r1, [r0, #4]
        memcpy(&found_slot->tc_arg, &slots[found][30], 2);

        uint16_t todo = found_slot->tc_flags;
 8007de4:	8885      	ldrh	r5, [r0, #4]
        found_slot->slot_num = found;

        // 28 bytes are the PIN hash, last 4 bytes is our meta-data.
        // following slot(s) may hold wallet data (32-64 bytes)
        memcpy(&found_slot->tc_flags, &slots[found][28], 2);
        memcpy(&found_slot->tc_arg, &slots[found][30], 2);
 8007de6:	5ad3      	ldrh	r3, [r2, r3]
 8007de8:	80c3      	strh	r3, [r0, #6]

        uint16_t todo = found_slot->tc_flags;

        // hmm: don't need this data if safety is off.. but we have it anyway
        if(found_slot->tc_flags & TC_WORD_WALLET) {
 8007dea:	04ef      	lsls	r7, r5, #19
        // 28 bytes are the PIN hash, last 4 bytes is our meta-data.
        // following slot(s) may hold wallet data (32-64 bytes)
        memcpy(&found_slot->tc_flags, &slots[found][28], 2);
        memcpy(&found_slot->tc_arg, &slots[found][30], 2);

        uint16_t todo = found_slot->tc_flags;
 8007dec:	4603      	mov	r3, r0

        // hmm: don't need this data if safety is off.. but we have it anyway
        if(found_slot->tc_flags & TC_WORD_WALLET) {
 8007dee:	d511      	bpl.n	8007e14 <se2_test_trick_pin+0x104>
            // it's a 24-word BIP-39 seed phrase, un-encrypted.
            if(found+1 < NUM_TRICKS) {
 8007df0:	2c0c      	cmp	r4, #12
 8007df2:	dc35      	bgt.n	8007e60 <se2_test_trick_pin+0x150>
                memcpy(found_slot->xdata, &slots[found+1][0], 32);
 8007df4:	3401      	adds	r4, #1
 8007df6:	eb02 1444 	add.w	r4, r2, r4, lsl #5
 8007dfa:	3308      	adds	r3, #8
 8007dfc:	f104 0620 	add.w	r6, r4, #32
 8007e00:	4622      	mov	r2, r4
 8007e02:	ca03      	ldmia	r2!, {r0, r1}
 8007e04:	42b2      	cmp	r2, r6
 8007e06:	6018      	str	r0, [r3, #0]
 8007e08:	6059      	str	r1, [r3, #4]
 8007e0a:	4614      	mov	r4, r2
 8007e0c:	f103 0308 	add.w	r3, r3, #8
 8007e10:	d1f6      	bne.n	8007e00 <se2_test_trick_pin+0xf0>
 8007e12:	e025      	b.n	8007e60 <se2_test_trick_pin+0x150>
            }
        } else if(found_slot->tc_flags & TC_XPRV_WALLET) {
 8007e14:	052e      	lsls	r6, r5, #20
 8007e16:	d523      	bpl.n	8007e60 <se2_test_trick_pin+0x150>
            // it's an xprv-based wallet
            if(found+2 < NUM_TRICKS) {
 8007e18:	2c0b      	cmp	r4, #11
 8007e1a:	dc21      	bgt.n	8007e60 <se2_test_trick_pin+0x150>
                memcpy(&found_slot->xdata[0], &slots[found+1][0], 32);
 8007e1c:	1c63      	adds	r3, r4, #1
 8007e1e:	eb02 1343 	add.w	r3, r2, r3, lsl #5
 8007e22:	9a00      	ldr	r2, [sp, #0]
 8007e24:	f103 0720 	add.w	r7, r3, #32
 8007e28:	3208      	adds	r2, #8
 8007e2a:	461e      	mov	r6, r3
 8007e2c:	ce03      	ldmia	r6!, {r0, r1}
 8007e2e:	42be      	cmp	r6, r7
 8007e30:	6010      	str	r0, [r2, #0]
 8007e32:	6051      	str	r1, [r2, #4]
 8007e34:	4633      	mov	r3, r6
 8007e36:	f102 0208 	add.w	r2, r2, #8
 8007e3a:	d1f6      	bne.n	8007e2a <se2_test_trick_pin+0x11a>
                memcpy(&found_slot->xdata[32], &slots[found+2][0], 32);
 8007e3c:	ab7c      	add	r3, sp, #496	; 0x1f0
 8007e3e:	eb03 1444 	add.w	r4, r3, r4, lsl #5
 8007e42:	9b00      	ldr	r3, [sp, #0]
 8007e44:	f5a4 76b0 	sub.w	r6, r4, #352	; 0x160
 8007e48:	3328      	adds	r3, #40	; 0x28
 8007e4a:	f5a4 74c0 	sub.w	r4, r4, #384	; 0x180
 8007e4e:	4622      	mov	r2, r4
 8007e50:	ca03      	ldmia	r2!, {r0, r1}
 8007e52:	42b2      	cmp	r2, r6
 8007e54:	6018      	str	r0, [r3, #0]
 8007e56:	6059      	str	r1, [r3, #4]
 8007e58:	4614      	mov	r4, r2
 8007e5a:	f103 0308 	add.w	r3, r3, #8
 8007e5e:	d1f6      	bne.n	8007e4e <se2_test_trick_pin+0x13e>
            }
        }

        if(!safety_mode && todo) {
 8007e60:	9b01      	ldr	r3, [sp, #4]
 8007e62:	b10b      	cbz	r3, 8007e68 <se2_test_trick_pin+0x158>
                goto fake_out;
            }
            // TC_DELTA_MODE implemented by caller
        }

        return true;
 8007e64:	2001      	movs	r0, #1
 8007e66:	e026      	b.n	8007eb6 <se2_test_trick_pin+0x1a6>
                memcpy(&found_slot->xdata[0], &slots[found+1][0], 32);
                memcpy(&found_slot->xdata[32], &slots[found+2][0], 32);
            }
        }

        if(!safety_mode && todo) {
 8007e68:	2d00      	cmp	r5, #0
 8007e6a:	d0fb      	beq.n	8007e64 <se2_test_trick_pin+0x154>
            puthex4(todo);
            putchar(' ');
#endif

            // code here to brick or wipe
            if(todo & TC_WIPE) {
 8007e6c:	0428      	lsls	r0, r5, #16
 8007e6e:	d50a      	bpl.n	8007e86 <se2_test_trick_pin+0x176>
                // wipe keys - useful to combine with other stuff
                // .. see below if not combined w/ a fatal action
                mcu_key_clear(NULL);
 8007e70:	9801      	ldr	r0, [sp, #4]
 8007e72:	f7fa fb01 	bl	8002478 <mcu_key_clear>
                DEBUG("wiped");

                if(todo == TC_WIPE) {
 8007e76:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
 8007e7a:	d104      	bne.n	8007e86 <se2_test_trick_pin+0x176>
                    // we wiped, but no faking it out or rebooting, so
                    // show attacker we are wiped, and die.
                    // - need to still allow WIPE+WALLET case
                    oled_show(screen_wiped);
 8007e7c:	4812      	ldr	r0, [pc, #72]	; (8007ec8 <se2_test_trick_pin+0x1b8>)
 8007e7e:	f7f8 ffb9 	bl	8000df4 <oled_show>
                    LOCKUP_FOREVER();
 8007e82:	bf30      	wfi
 8007e84:	e7fd      	b.n	8007e82 <se2_test_trick_pin+0x172>
                }
            }
            if(todo & TC_BRICK) {
 8007e86:	0469      	lsls	r1, r5, #17
 8007e88:	d40d      	bmi.n	8007ea6 <se2_test_trick_pin+0x196>
                fast_brick();
                // NOT REACHED; unit locks up w/ msg shown
            }
            if(todo & TC_REBOOT) {
 8007e8a:	05aa      	lsls	r2, r5, #22
 8007e8c:	d510      	bpl.n	8007eb0 <se2_test_trick_pin+0x1a0>
 8007e8e:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8007e92:	490e      	ldr	r1, [pc, #56]	; (8007ecc <se2_test_trick_pin+0x1bc>)
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8007e94:	4b0e      	ldr	r3, [pc, #56]	; (8007ed0 <se2_test_trick_pin+0x1c0>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8007e96:	68ca      	ldr	r2, [r1, #12]
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8007e98:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8007e9c:	4313      	orrs	r3, r2
 8007e9e:	60cb      	str	r3, [r1, #12]
 8007ea0:	f3bf 8f4f 	dsb	sy
 8007ea4:	e002      	b.n	8007eac <se2_test_trick_pin+0x19c>
                    oled_show(screen_wiped);
                    LOCKUP_FOREVER();
                }
            }
            if(todo & TC_BRICK) {
                fast_brick();
 8007ea6:	f7fa fb85 	bl	80025b4 <fast_brick>
 8007eaa:	e7ee      	b.n	8007e8a <se2_test_trick_pin+0x17a>
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 8007eac:	bf00      	nop
 8007eae:	e7fd      	b.n	8007eac <se2_test_trick_pin+0x19c>
            }
            if(todo & TC_REBOOT) {
                // just reboot, but might look like we wiped secret
                NVIC_SystemReset();
            }
            if(todo & TC_FAKE_OUT) {
 8007eb0:	04ab      	lsls	r3, r5, #18
 8007eb2:	d486      	bmi.n	8007dc2 <se2_test_trick_pin+0xb2>
 8007eb4:	e7d6      	b.n	8007e64 <se2_test_trick_pin+0x154>
        found_slot->slot_num = -1;
        rng_delay();

        return false;
    }
}
 8007eb6:	b07d      	add	sp, #500	; 0x1f4
 8007eb8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8007ebc:	20000288 	.word	0x20000288
 8007ec0:	200002e4 	.word	0x200002e4
 8007ec4:	0801e0b0 	.word	0x0801e0b0
 8007ec8:	0800dd2e 	.word	0x0800dd2e
 8007ecc:	e000ed00 	.word	0xe000ed00
 8007ed0:	05fa0004 	.word	0x05fa0004
 8007ed4:	0801e000 	.word	0x0801e000

08007ed8 <se2_handle_bad_pin>:
// Attacker (or confused owner) has just given a wrong PIN code (didn't match true
// PIN nor any trick PIN)... maybe do something special.
//
    void 
se2_handle_bad_pin(int num_fails)
{
 8007ed8:	b510      	push	{r4, lr}
 8007eda:	b0a2      	sub	sp, #136	; 0x88
 8007edc:	4604      	mov	r4, r0
    trick_slot_t    slot;

    bool is_trick = se2_test_trick_pin("!p", 2, &slot, true);
 8007ede:	2301      	movs	r3, #1
 8007ee0:	aa02      	add	r2, sp, #8
 8007ee2:	2102      	movs	r1, #2
 8007ee4:	4810      	ldr	r0, [pc, #64]	; (8007f28 <se2_handle_bad_pin+0x50>)
 8007ee6:	f7ff ff13 	bl	8007d10 <se2_test_trick_pin>
    if(!is_trick) return;
 8007eea:	b1d8      	cbz	r0, 8007f24 <se2_handle_bad_pin+0x4c>

    // Are we configured to do something in this case?
    if(num_fails >= slot.tc_arg) {
 8007eec:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8007ef0:	42a3      	cmp	r3, r4
 8007ef2:	dc17      	bgt.n	8007f24 <se2_handle_bad_pin+0x4c>
        if(slot.tc_flags & TC_WIPE) {
 8007ef4:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
 8007ef8:	2b00      	cmp	r3, #0
 8007efa:	da0d      	bge.n	8007f18 <se2_handle_bad_pin+0x40>
            // Wipe keys and stop. They can power cycle and keep trying
            // so only do this if a valid key currently exists.
            bool valid;
            const mcu_key_t *cur = mcu_key_get(&valid);
 8007efc:	f10d 0007 	add.w	r0, sp, #7
 8007f00:	f7fa fa9a 	bl	8002438 <mcu_key_get>

            if(valid) {
 8007f04:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8007f08:	b133      	cbz	r3, 8007f18 <se2_handle_bad_pin+0x40>
                mcu_key_clear(cur);
 8007f0a:	f7fa fab5 	bl	8002478 <mcu_key_clear>
                oled_show(screen_wiped);
 8007f0e:	4807      	ldr	r0, [pc, #28]	; (8007f2c <se2_handle_bad_pin+0x54>)
 8007f10:	f7f8 ff70 	bl	8000df4 <oled_show>

                LOCKUP_FOREVER();
 8007f14:	bf30      	wfi
 8007f16:	e7fd      	b.n	8007f14 <se2_handle_bad_pin+0x3c>
            }
        }

        if(slot.tc_flags & TC_BRICK) {
 8007f18:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 8007f1c:	045b      	lsls	r3, r3, #17
 8007f1e:	d501      	bpl.n	8007f24 <se2_handle_bad_pin+0x4c>
            // Not mutually exclusive: if both flags are set, the first
            // time it's triggered the seed will be wiped (and then lockup)
            // Next wrong pin will not have a seed to clear, and so this
            // brick code will happen.
            fast_brick();
 8007f20:	f7fa fb48 	bl	80025b4 <fast_brick>
        }
    }
}
 8007f24:	b022      	add	sp, #136	; 0x88
 8007f26:	bd10      	pop	{r4, pc}
 8007f28:	0800e77c 	.word	0x0800e77c
 8007f2c:	0800dd2e 	.word	0x0800dd2e

08007f30 <se2_save_trick>:
//
// Save trick setup. T if okay
//
    int
se2_save_trick(const trick_slot_t *config)
{
 8007f30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007f34:	b092      	sub	sp, #72	; 0x48
 8007f36:	9001      	str	r0, [sp, #4]
    se2_setup();
 8007f38:	f7ff fe3c 	bl	8007bb4 <se2_setup>
    if(setjmp(error_env)) {
 8007f3c:	4845      	ldr	r0, [pc, #276]	; (8008054 <se2_save_trick+0x124>)
 8007f3e:	f005 facb 	bl	800d4d8 <setjmp>
 8007f42:	4604      	mov	r4, r0
 8007f44:	2800      	cmp	r0, #0
 8007f46:	d17c      	bne.n	8008042 <se2_save_trick+0x112>
        return EPIN_SE2_FAIL;
    }

    if((config->slot_num < 0) || (config->slot_num >= NUM_TRICKS) ) {
 8007f48:	9b01      	ldr	r3, [sp, #4]
 8007f4a:	681b      	ldr	r3, [r3, #0]
 8007f4c:	2b0d      	cmp	r3, #13
 8007f4e:	d87b      	bhi.n	8008048 <se2_save_trick+0x118>
        return EPIN_RANGE_ERR;
    }
    if((config->slot_num >= NUM_TRICKS-1) && (config->tc_flags & TC_WORD_WALLET) ) {
 8007f50:	d104      	bne.n	8007f5c <se2_save_trick+0x2c>
 8007f52:	9b01      	ldr	r3, [sp, #4]
 8007f54:	889b      	ldrh	r3, [r3, #4]
 8007f56:	04d9      	lsls	r1, r3, #19
 8007f58:	d502      	bpl.n	8007f60 <se2_save_trick+0x30>
 8007f5a:	e075      	b.n	8008048 <se2_save_trick+0x118>
        // last slot cannot hold a seed-word wallet.
        return EPIN_RANGE_ERR;
    }
    if((config->slot_num >= NUM_TRICKS-2) && (config->tc_flags & TC_XPRV_WALLET) ) {
 8007f5c:	2b0c      	cmp	r3, #12
 8007f5e:	d103      	bne.n	8007f68 <se2_save_trick+0x38>
 8007f60:	9b01      	ldr	r3, [sp, #4]
 8007f62:	889b      	ldrh	r3, [r3, #4]
 8007f64:	051a      	lsls	r2, r3, #20
 8007f66:	d46f      	bmi.n	8008048 <se2_save_trick+0x118>
        // last slot cannot hold an xprv wallet.
        return EPIN_RANGE_ERR;
    }
    if(config->pin_len > sizeof(config->pin)) {
 8007f68:	9b01      	ldr	r3, [sp, #4]
 8007f6a:	6d99      	ldr	r1, [r3, #88]	; 0x58
 8007f6c:	2910      	cmp	r1, #16
 8007f6e:	d86b      	bhi.n	8008048 <se2_save_trick+0x118>
        return EPIN_RANGE_ERR;
    }

    if(config->blank_slots) {
 8007f70:	6ddd      	ldr	r5, [r3, #92]	; 0x5c
 8007f72:	b1fd      	cbz	r5, 8007fb4 <se2_save_trick+0x84>
        // blank indicated slots
        uint8_t zeros[32] = { 0 };
 8007f74:	2220      	movs	r2, #32
 8007f76:	2100      	movs	r1, #0
 8007f78:	a802      	add	r0, sp, #8
 8007f7a:	f005 faa4 	bl	800d4c6 <memset>

        for(int i=0; i<NUM_TRICKS; i++) {
            uint32_t mask = (1 << i);

            if(mask & config->blank_slots) {
                se2_write_encrypted(PGN_TRICK(i), zeros, 0, SE2_SECRETS->pairing);
 8007f7e:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 8008060 <se2_save_trick+0x130>
 8007f82:	4f35      	ldr	r7, [pc, #212]	; (8008058 <se2_save_trick+0x128>)
 8007f84:	4e35      	ldr	r6, [pc, #212]	; (800805c <se2_save_trick+0x12c>)

    if(config->blank_slots) {
        // blank indicated slots
        uint8_t zeros[32] = { 0 };

        for(int i=0; i<NUM_TRICKS; i++) {
 8007f86:	2500      	movs	r5, #0
            uint32_t mask = (1 << i);

            if(mask & config->blank_slots) {
 8007f88:	9a01      	ldr	r2, [sp, #4]
 8007f8a:	2301      	movs	r3, #1
 8007f8c:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 8007f8e:	40ab      	lsls	r3, r5
 8007f90:	4213      	tst	r3, r2
 8007f92:	d103      	bne.n	8007f9c <se2_save_trick+0x6c>

    if(config->blank_slots) {
        // blank indicated slots
        uint8_t zeros[32] = { 0 };

        for(int i=0; i<NUM_TRICKS; i++) {
 8007f94:	3501      	adds	r5, #1
 8007f96:	2d0e      	cmp	r5, #14
 8007f98:	d1f6      	bne.n	8007f88 <se2_save_trick+0x58>
 8007f9a:	e057      	b.n	800804c <se2_save_trick+0x11c>
            uint32_t mask = (1 << i);

            if(mask & config->blank_slots) {
                se2_write_encrypted(PGN_TRICK(i), zeros, 0, SE2_SECRETS->pairing);
 8007f9c:	f898 30b0 	ldrb.w	r3, [r8, #176]	; 0xb0
 8007fa0:	2200      	movs	r2, #0
 8007fa2:	2bff      	cmp	r3, #255	; 0xff
 8007fa4:	bf0c      	ite	eq
 8007fa6:	463b      	moveq	r3, r7
 8007fa8:	4633      	movne	r3, r6
 8007faa:	a902      	add	r1, sp, #8
 8007fac:	b2e8      	uxtb	r0, r5
 8007fae:	f7ff fa9d 	bl	80074ec <se2_write_encrypted>
 8007fb2:	e7ef      	b.n	8007f94 <se2_save_trick+0x64>
            }
        }
    } else {
        // construct data to save
        uint8_t     tpin_digest[32];
        trick_pin_hash(config->pin, config->pin_len, tpin_digest);
 8007fb4:	9b01      	ldr	r3, [sp, #4]

        memcpy(&tpin_digest[28], &config->tc_flags, 2);
        memcpy(&tpin_digest[30], &config->tc_arg, 2);

        // write into SE2
        se2_write_encrypted(PGN_TRICK(config->slot_num), tpin_digest, 0, SE2_SECRETS->pairing);
 8007fb6:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 8008060 <se2_save_trick+0x130>
 8007fba:	4f27      	ldr	r7, [pc, #156]	; (8008058 <se2_save_trick+0x128>)
 8007fbc:	4e27      	ldr	r6, [pc, #156]	; (800805c <se2_save_trick+0x12c>)
            }
        }
    } else {
        // construct data to save
        uint8_t     tpin_digest[32];
        trick_pin_hash(config->pin, config->pin_len, tpin_digest);
 8007fbe:	f103 0048 	add.w	r0, r3, #72	; 0x48
 8007fc2:	aa0a      	add	r2, sp, #40	; 0x28
 8007fc4:	f7ff fce8 	bl	8007998 <trick_pin_hash>

        memcpy(&tpin_digest[28], &config->tc_flags, 2);
 8007fc8:	9b01      	ldr	r3, [sp, #4]
        memcpy(&tpin_digest[30], &config->tc_arg, 2);

        // write into SE2
        se2_write_encrypted(PGN_TRICK(config->slot_num), tpin_digest, 0, SE2_SECRETS->pairing);
 8007fca:	9801      	ldr	r0, [sp, #4]
    } else {
        // construct data to save
        uint8_t     tpin_digest[32];
        trick_pin_hash(config->pin, config->pin_len, tpin_digest);

        memcpy(&tpin_digest[28], &config->tc_flags, 2);
 8007fcc:	889b      	ldrh	r3, [r3, #4]
 8007fce:	f8ad 3044 	strh.w	r3, [sp, #68]	; 0x44
        memcpy(&tpin_digest[30], &config->tc_arg, 2);
 8007fd2:	9b01      	ldr	r3, [sp, #4]

        // write into SE2
        se2_write_encrypted(PGN_TRICK(config->slot_num), tpin_digest, 0, SE2_SECRETS->pairing);
 8007fd4:	7800      	ldrb	r0, [r0, #0]
        // construct data to save
        uint8_t     tpin_digest[32];
        trick_pin_hash(config->pin, config->pin_len, tpin_digest);

        memcpy(&tpin_digest[28], &config->tc_flags, 2);
        memcpy(&tpin_digest[30], &config->tc_arg, 2);
 8007fd6:	88db      	ldrh	r3, [r3, #6]
 8007fd8:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46

        // write into SE2
        se2_write_encrypted(PGN_TRICK(config->slot_num), tpin_digest, 0, SE2_SECRETS->pairing);
 8007fdc:	f898 30b0 	ldrb.w	r3, [r8, #176]	; 0xb0
 8007fe0:	462a      	mov	r2, r5
 8007fe2:	2bff      	cmp	r3, #255	; 0xff
 8007fe4:	bf0c      	ite	eq
 8007fe6:	463b      	moveq	r3, r7
 8007fe8:	4633      	movne	r3, r6
 8007fea:	a90a      	add	r1, sp, #40	; 0x28
 8007fec:	f7ff fa7e 	bl	80074ec <se2_write_encrypted>

        if(config->tc_flags & (TC_WORD_WALLET | TC_XPRV_WALLET)) {
 8007ff0:	9b01      	ldr	r3, [sp, #4]
 8007ff2:	889b      	ldrh	r3, [r3, #4]
 8007ff4:	f403 53c0 	and.w	r3, r3, #6144	; 0x1800
 8007ff8:	b9a3      	cbnz	r3, 8008024 <se2_save_trick+0xf4>
            se2_write_encrypted(PGN_TRICK(config->slot_num+1), &config->xdata[0],
                                                                    0, SE2_SECRETS->pairing);
        }
        if(config->tc_flags & TC_XPRV_WALLET) {
 8007ffa:	9b01      	ldr	r3, [sp, #4]
 8007ffc:	889b      	ldrh	r3, [r3, #4]
 8007ffe:	051b      	lsls	r3, r3, #20
 8008000:	d524      	bpl.n	800804c <se2_save_trick+0x11c>
            se2_write_encrypted(PGN_TRICK(config->slot_num+2), &config->xdata[32],
 8008002:	9901      	ldr	r1, [sp, #4]
                                                                    0, SE2_SECRETS->pairing);
 8008004:	4b16      	ldr	r3, [pc, #88]	; (8008060 <se2_save_trick+0x130>)
        if(config->tc_flags & (TC_WORD_WALLET | TC_XPRV_WALLET)) {
            se2_write_encrypted(PGN_TRICK(config->slot_num+1), &config->xdata[0],
                                                                    0, SE2_SECRETS->pairing);
        }
        if(config->tc_flags & TC_XPRV_WALLET) {
            se2_write_encrypted(PGN_TRICK(config->slot_num+2), &config->xdata[32],
 8008006:	f851 0b28 	ldr.w	r0, [r1], #40
                                                                    0, SE2_SECRETS->pairing);
 800800a:	f893 50b0 	ldrb.w	r5, [r3, #176]	; 0xb0
        if(config->tc_flags & (TC_WORD_WALLET | TC_XPRV_WALLET)) {
            se2_write_encrypted(PGN_TRICK(config->slot_num+1), &config->xdata[0],
                                                                    0, SE2_SECRETS->pairing);
        }
        if(config->tc_flags & TC_XPRV_WALLET) {
            se2_write_encrypted(PGN_TRICK(config->slot_num+2), &config->xdata[32],
 800800e:	4a13      	ldr	r2, [pc, #76]	; (800805c <se2_save_trick+0x12c>)
 8008010:	4b11      	ldr	r3, [pc, #68]	; (8008058 <se2_save_trick+0x128>)
 8008012:	3002      	adds	r0, #2
 8008014:	2dff      	cmp	r5, #255	; 0xff
 8008016:	bf18      	it	ne
 8008018:	4613      	movne	r3, r2
 800801a:	b2c0      	uxtb	r0, r0
 800801c:	2200      	movs	r2, #0
 800801e:	f7ff fa65 	bl	80074ec <se2_write_encrypted>
 8008022:	e013      	b.n	800804c <se2_save_trick+0x11c>

        // write into SE2
        se2_write_encrypted(PGN_TRICK(config->slot_num), tpin_digest, 0, SE2_SECRETS->pairing);

        if(config->tc_flags & (TC_WORD_WALLET | TC_XPRV_WALLET)) {
            se2_write_encrypted(PGN_TRICK(config->slot_num+1), &config->xdata[0],
 8008024:	9901      	ldr	r1, [sp, #4]
                                                                    0, SE2_SECRETS->pairing);
 8008026:	f898 30b0 	ldrb.w	r3, [r8, #176]	; 0xb0

        // write into SE2
        se2_write_encrypted(PGN_TRICK(config->slot_num), tpin_digest, 0, SE2_SECRETS->pairing);

        if(config->tc_flags & (TC_WORD_WALLET | TC_XPRV_WALLET)) {
            se2_write_encrypted(PGN_TRICK(config->slot_num+1), &config->xdata[0],
 800802a:	f851 0b08 	ldr.w	r0, [r1], #8
 800802e:	3001      	adds	r0, #1
 8008030:	2bff      	cmp	r3, #255	; 0xff
 8008032:	bf0c      	ite	eq
 8008034:	463b      	moveq	r3, r7
 8008036:	4633      	movne	r3, r6
 8008038:	462a      	mov	r2, r5
 800803a:	b2c0      	uxtb	r0, r0
 800803c:	f7ff fa56 	bl	80074ec <se2_write_encrypted>
 8008040:	e7db      	b.n	8007ffa <se2_save_trick+0xca>
    int
se2_save_trick(const trick_slot_t *config)
{
    se2_setup();
    if(setjmp(error_env)) {
        return EPIN_SE2_FAIL;
 8008042:	f06f 0472 	mvn.w	r4, #114	; 0x72
 8008046:	e001      	b.n	800804c <se2_save_trick+0x11c>
    }

    if((config->slot_num < 0) || (config->slot_num >= NUM_TRICKS) ) {
        return EPIN_RANGE_ERR;
 8008048:	f06f 0466 	mvn.w	r4, #102	; 0x66
                                                                    0, SE2_SECRETS->pairing);
        }
    }

    return 0;
}
 800804c:	4620      	mov	r0, r4
 800804e:	b012      	add	sp, #72	; 0x48
 8008050:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008054:	20000288 	.word	0x20000288
 8008058:	200002e4 	.word	0x200002e4
 800805c:	0801e0b0 	.word	0x0801e0b0
 8008060:	0801e000 	.word	0x0801e000

08008064 <se2_encrypt_secret>:
//
    bool
se2_encrypt_secret(const uint8_t secret[], int secret_len, int offset, 
    uint8_t main_slot[], uint8_t *check_value,
    const uint8_t pin_digest[32])
{
 8008064:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008068:	f5ad 7d11 	sub.w	sp, sp, #580	; 0x244
 800806c:	469a      	mov	sl, r3
 800806e:	4683      	mov	fp, r0
 8008070:	4689      	mov	r9, r1
 8008072:	4690      	mov	r8, r2
 8008074:	9f9a      	ldr	r7, [sp, #616]	; 0x268
    se2_setup();
 8008076:	f7ff fd9d 	bl	8007bb4 <se2_setup>

    bool is_valid;
    const mcu_key_t *cur = mcu_key_get(&is_valid);
 800807a:	f10d 000b 	add.w	r0, sp, #11
 800807e:	f7fa f9db 	bl	8002438 <mcu_key_get>

    if(!is_valid) {
 8008082:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8008086:	b923      	cbnz	r3, 8008092 <se2_encrypt_secret+0x2e>
        if(!check_value) {
 8008088:	b90f      	cbnz	r7, 800808e <se2_encrypt_secret+0x2a>
            // problem: we are not writing the check value but it would be changed.
            // ie: change long secret before real secret--unlikely
            return true;
 800808a:	2601      	movs	r6, #1
 800808c:	e032      	b.n	80080f4 <se2_encrypt_secret+0x90>
        }

        // pick a fresh MCU key if we don't have one; can do that
        // because we are encryption and saving (presumably for first time)
        // - will become a brick if no more slots
        cur = mcu_key_pick();     
 800808e:	f7fa fa35 	bl	80024fc <mcu_key_pick>
    }

    uint8_t aes_key[32];
    if(se2_calc_seed_key(aes_key, cur, pin_digest)) return true;
 8008092:	4601      	mov	r1, r0
 8008094:	9a9b      	ldr	r2, [sp, #620]	; 0x26c
 8008096:	a807      	add	r0, sp, #28
 8008098:	f7ff fd5a 	bl	8007b50 <se2_calc_seed_key>
 800809c:	4606      	mov	r6, r0
 800809e:	2800      	cmp	r0, #0
 80080a0:	d1f3      	bne.n	800808a <se2_encrypt_secret+0x26>

    uint8_t nonce[16];
    memcpy(nonce, rom_secrets->mcu_hmac_key, sizeof(nonce)-1);
 80080a2:	4b17      	ldr	r3, [pc, #92]	; (8008100 <se2_encrypt_secret+0x9c>)
 80080a4:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80080a6:	ad03      	add	r5, sp, #12
 80080a8:	462c      	mov	r4, r5
 80080aa:	c407      	stmia	r4!, {r0, r1, r2}
 80080ac:	f824 3b02 	strh.w	r3, [r4], #2
 80080b0:	0c1b      	lsrs	r3, r3, #16
 80080b2:	7023      	strb	r3, [r4, #0]
    nonce[15] = offset / AES_BLOCK_SIZE;

    // encrypt the secret
    AES_CTX ctx;
    aes_init(&ctx);
 80080b4:	a80f      	add	r0, sp, #60	; 0x3c
    uint8_t aes_key[32];
    if(se2_calc_seed_key(aes_key, cur, pin_digest)) return true;

    uint8_t nonce[16];
    memcpy(nonce, rom_secrets->mcu_hmac_key, sizeof(nonce)-1);
    nonce[15] = offset / AES_BLOCK_SIZE;
 80080b6:	2310      	movs	r3, #16
 80080b8:	fb98 f8f3 	sdiv	r8, r8, r3
 80080bc:	f88d 801b 	strb.w	r8, [sp, #27]

    // encrypt the secret
    AES_CTX ctx;
    aes_init(&ctx);
 80080c0:	f000 f886 	bl	80081d0 <aes_init>
    aes_add(&ctx, secret, secret_len);
 80080c4:	464a      	mov	r2, r9
 80080c6:	4659      	mov	r1, fp
 80080c8:	a80f      	add	r0, sp, #60	; 0x3c
 80080ca:	f000 f887 	bl	80081dc <aes_add>
    aes_done(&ctx, main_slot, secret_len, aes_key, nonce);
 80080ce:	9500      	str	r5, [sp, #0]
 80080d0:	ab07      	add	r3, sp, #28
 80080d2:	464a      	mov	r2, r9
 80080d4:	4651      	mov	r1, sl
 80080d6:	a80f      	add	r0, sp, #60	; 0x3c
 80080d8:	f000 f896 	bl	8008208 <aes_done>

    if(check_value) {
 80080dc:	b157      	cbz	r7, 80080f4 <se2_encrypt_secret+0x90>
        // encrypt the check value: 32 zeros
        aes_init(&ctx);
 80080de:	a80f      	add	r0, sp, #60	; 0x3c
 80080e0:	f000 f876 	bl	80081d0 <aes_init>
        ctx.num_pending = 32;
 80080e4:	2220      	movs	r2, #32
        aes_done(&ctx, check_value, 32, aes_key, nonce);
 80080e6:	9500      	str	r5, [sp, #0]
 80080e8:	ab07      	add	r3, sp, #28
 80080ea:	4639      	mov	r1, r7
 80080ec:	a80f      	add	r0, sp, #60	; 0x3c
    aes_done(&ctx, main_slot, secret_len, aes_key, nonce);

    if(check_value) {
        // encrypt the check value: 32 zeros
        aes_init(&ctx);
        ctx.num_pending = 32;
 80080ee:	928f      	str	r2, [sp, #572]	; 0x23c
        aes_done(&ctx, check_value, 32, aes_key, nonce);
 80080f0:	f000 f88a 	bl	8008208 <aes_done>
    }

    return false;
}
 80080f4:	4630      	mov	r0, r6
 80080f6:	f50d 7d11 	add.w	sp, sp, #580	; 0x244
 80080fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80080fe:	bf00      	nop
 8008100:	0801e090 	.word	0x0801e090

08008104 <se2_decrypt_secret>:
//
    void
se2_decrypt_secret(uint8_t secret[], int secret_len, int offset,
        const uint8_t main_slot[], const uint8_t *check_value,
        const uint8_t pin_digest[32], bool *is_valid)
{
 8008104:	b530      	push	{r4, r5, lr}
 8008106:	f5ad 7d1f 	sub.w	sp, sp, #636	; 0x27c
 800810a:	9307      	str	r3, [sp, #28]
 800810c:	9005      	str	r0, [sp, #20]
 800810e:	9103      	str	r1, [sp, #12]
 8008110:	9206      	str	r2, [sp, #24]
    se2_setup();
 8008112:	f7ff fd4f 	bl	8007bb4 <se2_setup>

    const mcu_key_t *cur = mcu_key_get(is_valid);
 8008116:	98a4      	ldr	r0, [sp, #656]	; 0x290
 8008118:	f7fa f98e 	bl	8002438 <mcu_key_get>
    if(!*is_valid) {
 800811c:	9ba4      	ldr	r3, [sp, #656]	; 0x290
        const uint8_t main_slot[], const uint8_t *check_value,
        const uint8_t pin_digest[32], bool *is_valid)
{
    se2_setup();

    const mcu_key_t *cur = mcu_key_get(is_valid);
 800811e:	9004      	str	r0, [sp, #16]
    if(!*is_valid) {
 8008120:	781b      	ldrb	r3, [r3, #0]
 8008122:	2b00      	cmp	r3, #0
 8008124:	d046      	beq.n	80081b4 <se2_decrypt_secret+0xb0>
        // no key set? won't be able to decrypt.
        return;
    }

    int line_num;
    if((line_num = setjmp(error_env))) {
 8008126:	4825      	ldr	r0, [pc, #148]	; (80081bc <se2_decrypt_secret+0xb8>)
 8008128:	f005 f9d6 	bl	800d4d8 <setjmp>
 800812c:	b118      	cbz	r0, 8008136 <se2_decrypt_secret+0x32>
        // internal failures / broken i2c buses will come here
        //puts2("se2_decrypt_secret: se2.c:"); putdec4(line_num); putchar('\n');
        *is_valid = false;
 800812e:	9aa4      	ldr	r2, [sp, #656]	; 0x290
 8008130:	2300      	movs	r3, #0
 8008132:	7013      	strb	r3, [r2, #0]
        return;
 8008134:	e03e      	b.n	80081b4 <se2_decrypt_secret+0xb0>
    }

    AES_CTX ctx;
    uint8_t aes_key[32];
    if(se2_calc_seed_key(aes_key, cur, pin_digest)) {
 8008136:	9aa3      	ldr	r2, [sp, #652]	; 0x28c
 8008138:	9904      	ldr	r1, [sp, #16]
 800813a:	a80d      	add	r0, sp, #52	; 0x34
 800813c:	f7ff fd08 	bl	8007b50 <se2_calc_seed_key>
 8008140:	2800      	cmp	r0, #0
 8008142:	d1f4      	bne.n	800812e <se2_decrypt_secret+0x2a>
        *is_valid = false;
        return;
    }

    uint8_t nonce[16];
    memcpy(nonce, rom_secrets->mcu_hmac_key, sizeof(nonce)-1);
 8008144:	4b1e      	ldr	r3, [pc, #120]	; (80081c0 <se2_decrypt_secret+0xbc>)
 8008146:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8008148:	ad09      	add	r5, sp, #36	; 0x24
 800814a:	462c      	mov	r4, r5
 800814c:	c407      	stmia	r4!, {r0, r1, r2}
 800814e:	f824 3b02 	strh.w	r3, [r4], #2
 8008152:	0c1b      	lsrs	r3, r3, #16
 8008154:	7023      	strb	r3, [r4, #0]
    nonce[15] = offset / AES_BLOCK_SIZE;
 8008156:	9a06      	ldr	r2, [sp, #24]
 8008158:	2310      	movs	r3, #16
 800815a:	fb92 f3f3 	sdiv	r3, r2, r3
 800815e:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33

    if(check_value) {
 8008162:	9ba2      	ldr	r3, [sp, #648]	; 0x288
 8008164:	b1b3      	cbz	r3, 8008194 <se2_decrypt_secret+0x90>
        // decrypt the check value
        aes_init(&ctx);
 8008166:	a81d      	add	r0, sp, #116	; 0x74
 8008168:	f000 f832 	bl	80081d0 <aes_init>
        aes_add(&ctx, check_value, 32);
 800816c:	2220      	movs	r2, #32
 800816e:	99a2      	ldr	r1, [sp, #648]	; 0x288
 8008170:	a81d      	add	r0, sp, #116	; 0x74
 8008172:	f000 f833 	bl	80081dc <aes_add>
        uint8_t got[32];
        aes_done(&ctx, got, 32, aes_key, nonce);
 8008176:	a915      	add	r1, sp, #84	; 0x54
 8008178:	a81d      	add	r0, sp, #116	; 0x74
 800817a:	9500      	str	r5, [sp, #0]
 800817c:	ab0d      	add	r3, sp, #52	; 0x34
 800817e:	2220      	movs	r2, #32
 8008180:	f000 f842 	bl	8008208 <aes_done>

        // does it work?
        if(!check_all_zeros(got, 32)) {
 8008184:	2120      	movs	r1, #32
 8008186:	a815      	add	r0, sp, #84	; 0x54
 8008188:	f7fa fa5e 	bl	8002648 <check_all_zeros>
 800818c:	b910      	cbnz	r0, 8008194 <se2_decrypt_secret+0x90>
            DEBUG("bad chk");
            *is_valid = false;
 800818e:	9ba4      	ldr	r3, [sp, #656]	; 0x290
 8008190:	7018      	strb	r0, [r3, #0]
 8008192:	e00f      	b.n	80081b4 <se2_decrypt_secret+0xb0>
            return;
        }
    }

    // decrypt the real data
    aes_init(&ctx);
 8008194:	a81d      	add	r0, sp, #116	; 0x74
 8008196:	f000 f81b 	bl	80081d0 <aes_init>
    aes_add(&ctx, main_slot, secret_len);
 800819a:	9a03      	ldr	r2, [sp, #12]
 800819c:	9907      	ldr	r1, [sp, #28]
 800819e:	a81d      	add	r0, sp, #116	; 0x74
 80081a0:	f000 f81c 	bl	80081dc <aes_add>
    aes_done(&ctx, secret, secret_len, aes_key, nonce);
 80081a4:	ab09      	add	r3, sp, #36	; 0x24
 80081a6:	9300      	str	r3, [sp, #0]
 80081a8:	9a03      	ldr	r2, [sp, #12]
 80081aa:	9905      	ldr	r1, [sp, #20]
 80081ac:	ab0d      	add	r3, sp, #52	; 0x34
 80081ae:	a81d      	add	r0, sp, #116	; 0x74
 80081b0:	f000 f82a 	bl	8008208 <aes_done>
}
 80081b4:	f50d 7d1f 	add.w	sp, sp, #636	; 0x27c
 80081b8:	bd30      	pop	{r4, r5, pc}
 80081ba:	bf00      	nop
 80081bc:	20000288 	.word	0x20000288
 80081c0:	0801e090 	.word	0x0801e090

080081c4 <word_pump_bytes>:
    uint32_t rv;

    if(((uint32_t)src) & 0x3) {
        memcpy(&rv, *src, 4);
    } else {
        rv = *(uint32_t *)(*src);
 80081c4:	6803      	ldr	r3, [r0, #0]
 80081c6:	f853 2b04 	ldr.w	r2, [r3], #4
    }
    (*src) += 4;
 80081ca:	6003      	str	r3, [r0, #0]

    return __REV(rv);
}
 80081cc:	ba10      	rev	r0, r2
 80081ce:	4770      	bx	lr

080081d0 <aes_init>:
// aes_init()
//
    void
aes_init(AES_CTX *ctx)
{
    memset(ctx, 0, sizeof(AES_CTX));
 80081d0:	f44f 7201 	mov.w	r2, #516	; 0x204
 80081d4:	2100      	movs	r1, #0
 80081d6:	f005 b976 	b.w	800d4c6 <memset>
	...

080081dc <aes_add>:
//
// - capture more data to be encrypted/decrypted
//
    void
aes_add(AES_CTX *ctx, const uint8_t data_in[], uint32_t len)
{
 80081dc:	b538      	push	{r3, r4, r5, lr}
 80081de:	4604      	mov	r4, r0
    memcpy(ctx->pending+ctx->num_pending, data_in, len);
 80081e0:	f8d0 0200 	ldr.w	r0, [r0, #512]	; 0x200
 80081e4:	4420      	add	r0, r4
//
// - capture more data to be encrypted/decrypted
//
    void
aes_add(AES_CTX *ctx, const uint8_t data_in[], uint32_t len)
{
 80081e6:	4615      	mov	r5, r2
    memcpy(ctx->pending+ctx->num_pending, data_in, len);
 80081e8:	f005 f947 	bl	800d47a <memcpy>
    ctx->num_pending += len;
 80081ec:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
 80081f0:	442a      	add	r2, r5

    ASSERT(ctx->num_pending < sizeof(ctx->pending));
 80081f2:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
//
    void
aes_add(AES_CTX *ctx, const uint8_t data_in[], uint32_t len)
{
    memcpy(ctx->pending+ctx->num_pending, data_in, len);
    ctx->num_pending += len;
 80081f6:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200

    ASSERT(ctx->num_pending < sizeof(ctx->pending));
 80081fa:	d302      	bcc.n	8008202 <aes_add+0x26>
 80081fc:	4801      	ldr	r0, [pc, #4]	; (8008204 <aes_add+0x28>)
 80081fe:	f7f8 fbed 	bl	80009dc <fatal_error>
 8008202:	bd38      	pop	{r3, r4, r5, pc}
 8008204:	0800d550 	.word	0x0800d550

08008208 <aes_done>:
//
// Do the decryption.
//
    void
aes_done(AES_CTX *ctx, uint8_t data_out[], uint32_t len, const uint8_t key[32], const uint8_t nonce[AES_BLOCK_SIZE])
{
 8008208:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800820c:	4690      	mov	r8, r2
    ASSERT(len <= ctx->num_pending);
 800820e:	f8d0 2200 	ldr.w	r2, [r0, #512]	; 0x200
//
// Do the decryption.
//
    void
aes_done(AES_CTX *ctx, uint8_t data_out[], uint32_t len, const uint8_t key[32], const uint8_t nonce[AES_BLOCK_SIZE])
{
 8008212:	b085      	sub	sp, #20
    ASSERT(len <= ctx->num_pending);
 8008214:	4542      	cmp	r2, r8
//
// Do the decryption.
//
    void
aes_done(AES_CTX *ctx, uint8_t data_out[], uint32_t len, const uint8_t key[32], const uint8_t nonce[AES_BLOCK_SIZE])
{
 8008216:	4606      	mov	r6, r0
 8008218:	460f      	mov	r7, r1
 800821a:	f8dd 9030 	ldr.w	r9, [sp, #48]	; 0x30
    ASSERT(len <= ctx->num_pending);
 800821e:	d202      	bcs.n	8008226 <aes_done+0x1e>
 8008220:	4855      	ldr	r0, [pc, #340]	; (8008378 <aes_done+0x170>)
 8008222:	f7f8 fbdb 	bl	80009dc <fatal_error>

    // enable clock to block
    __HAL_RCC_AES_CLK_ENABLE();
 8008226:	4c55      	ldr	r4, [pc, #340]	; (800837c <aes_done+0x174>)

    // most changes have to be made w/ module disabled
    AES->CR &= ~AES_CR_EN;
 8008228:	4955      	ldr	r1, [pc, #340]	; (8008380 <aes_done+0x178>)
aes_done(AES_CTX *ctx, uint8_t data_out[], uint32_t len, const uint8_t key[32], const uint8_t nonce[AES_BLOCK_SIZE])
{
    ASSERT(len <= ctx->num_pending);

    // enable clock to block
    __HAL_RCC_AES_CLK_ENABLE();
 800822a:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 800822c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8008230:	64e2      	str	r2, [r4, #76]	; 0x4c
 8008232:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 8008234:	f402 3280 	and.w	r2, r2, #65536	; 0x10000
 8008238:	9201      	str	r2, [sp, #4]
 800823a:	9a01      	ldr	r2, [sp, #4]

    // most changes have to be made w/ module disabled
    AES->CR &= ~AES_CR_EN;
 800823c:	680a      	ldr	r2, [r1, #0]
 800823e:	f022 0201 	bic.w	r2, r2, #1
 8008242:	600a      	str	r2, [r1, #0]

    // set the key size and operation mode
    MODIFY_REG(AES->CR, AES_CR_KEYSIZE, CRYP_KEYSIZE_256B);
 8008244:	680a      	ldr	r2, [r1, #0]
 8008246:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 800824a:	600a      	str	r2, [r1, #0]
    MODIFY_REG(AES->CR, AES_CR_DATATYPE|AES_CR_MODE|AES_CR_CHMOD, 
 800824c:	680a      	ldr	r2, [r1, #0]
 800824e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
            CRYP_DATATYPE_8B | CRYP_ALGOMODE_ENCRYPT | CRYP_CHAINMODE_AES_CTR);

    // load key and IV values
    const uint8_t *K = key;
 8008252:	ad04      	add	r5, sp, #16
    // most changes have to be made w/ module disabled
    AES->CR &= ~AES_CR_EN;

    // set the key size and operation mode
    MODIFY_REG(AES->CR, AES_CR_KEYSIZE, CRYP_KEYSIZE_256B);
    MODIFY_REG(AES->CR, AES_CR_DATATYPE|AES_CR_MODE|AES_CR_CHMOD, 
 8008254:	f022 027e 	bic.w	r2, r2, #126	; 0x7e
 8008258:	f042 0244 	orr.w	r2, r2, #68	; 0x44
 800825c:	600a      	str	r2, [r1, #0]
            CRYP_DATATYPE_8B | CRYP_ALGOMODE_ENCRYPT | CRYP_CHAINMODE_AES_CTR);

    // load key and IV values
    const uint8_t *K = key;
 800825e:	f845 3d08 	str.w	r3, [r5, #-8]!
    AES->KEYR7 = word_pump_bytes(&K);
 8008262:	4628      	mov	r0, r5
 8008264:	f7ff ffae 	bl	80081c4 <word_pump_bytes>
 8008268:	63c8      	str	r0, [r1, #60]	; 0x3c
    AES->KEYR6 = word_pump_bytes(&K);
 800826a:	4628      	mov	r0, r5
 800826c:	f7ff ffaa 	bl	80081c4 <word_pump_bytes>
 8008270:	6388      	str	r0, [r1, #56]	; 0x38
    AES->KEYR5 = word_pump_bytes(&K);
 8008272:	4628      	mov	r0, r5
 8008274:	f7ff ffa6 	bl	80081c4 <word_pump_bytes>
 8008278:	6348      	str	r0, [r1, #52]	; 0x34
    AES->KEYR4 = word_pump_bytes(&K);
 800827a:	4628      	mov	r0, r5
 800827c:	f7ff ffa2 	bl	80081c4 <word_pump_bytes>
 8008280:	6308      	str	r0, [r1, #48]	; 0x30
    AES->KEYR3 = word_pump_bytes(&K);
 8008282:	4628      	mov	r0, r5
 8008284:	f7ff ff9e 	bl	80081c4 <word_pump_bytes>
 8008288:	61c8      	str	r0, [r1, #28]
    AES->KEYR2 = word_pump_bytes(&K);
 800828a:	4628      	mov	r0, r5
 800828c:	f7ff ff9a 	bl	80081c4 <word_pump_bytes>
 8008290:	6188      	str	r0, [r1, #24]
    AES->KEYR1 = word_pump_bytes(&K);
 8008292:	4628      	mov	r0, r5
 8008294:	f7ff ff96 	bl	80081c4 <word_pump_bytes>
 8008298:	6148      	str	r0, [r1, #20]
    AES->KEYR0 = word_pump_bytes(&K);
 800829a:	4628      	mov	r0, r5
 800829c:	f7ff ff92 	bl	80081c4 <word_pump_bytes>
 80082a0:	6108      	str	r0, [r1, #16]

    if(nonce) {
 80082a2:	f1b9 0f00 	cmp.w	r9, #0
 80082a6:	d013      	beq.n	80082d0 <aes_done+0xc8>
        const uint8_t *N = nonce;
 80082a8:	ad04      	add	r5, sp, #16
 80082aa:	f845 9d04 	str.w	r9, [r5, #-4]!
        AES->IVR3 = word_pump_bytes(&N);
 80082ae:	4628      	mov	r0, r5
 80082b0:	f7ff ff88 	bl	80081c4 <word_pump_bytes>
 80082b4:	62c8      	str	r0, [r1, #44]	; 0x2c
        AES->IVR2 = word_pump_bytes(&N);
 80082b6:	4628      	mov	r0, r5
 80082b8:	f7ff ff84 	bl	80081c4 <word_pump_bytes>
 80082bc:	6288      	str	r0, [r1, #40]	; 0x28
        AES->IVR1 = word_pump_bytes(&N);
 80082be:	4628      	mov	r0, r5
 80082c0:	f7ff ff80 	bl	80081c4 <word_pump_bytes>
 80082c4:	6248      	str	r0, [r1, #36]	; 0x24
        AES->IVR0 = word_pump_bytes(&N);
 80082c6:	4628      	mov	r0, r5
 80082c8:	f7ff ff7c 	bl	80081c4 <word_pump_bytes>
 80082cc:	6208      	str	r0, [r1, #32]
 80082ce:	e007      	b.n	80082e0 <aes_done+0xd8>
    } else {
        AES->IVR3 = 0;
 80082d0:	f8c1 902c 	str.w	r9, [r1, #44]	; 0x2c
        AES->IVR2 = 0;
 80082d4:	f8c1 9028 	str.w	r9, [r1, #40]	; 0x28
        AES->IVR1 = 0;
 80082d8:	f8c1 9024 	str.w	r9, [r1, #36]	; 0x24
        AES->IVR0 = 0;          // maybe should be byte-swapped one, but whatever
 80082dc:	f8c1 9020 	str.w	r9, [r1, #32]
    }

    // Enable the Peripheral
    AES->CR |= AES_CR_EN;
 80082e0:	4a27      	ldr	r2, [pc, #156]	; (8008380 <aes_done+0x178>)

    ASSERT((((uint32_t)&ctx->pending) & 3) == 0);      // safe because of special attr

    uint32_t    *p = (uint32_t *)ctx->pending;
    for(int i=0; i < ctx->num_pending; i += 16) {
 80082e2:	f8d6 0200 	ldr.w	r0, [r6, #512]	; 0x200
        AES->IVR1 = 0;
        AES->IVR0 = 0;          // maybe should be byte-swapped one, but whatever
    }

    // Enable the Peripheral
    AES->CR |= AES_CR_EN;
 80082e6:	6813      	ldr	r3, [r2, #0]
 80082e8:	f043 0301 	orr.w	r3, r3, #1
 80082ec:	6013      	str	r3, [r2, #0]
 80082ee:	4615      	mov	r5, r2

    ASSERT((((uint32_t)&ctx->pending) & 3) == 0);      // safe because of special attr

    uint32_t    *p = (uint32_t *)ctx->pending;
 80082f0:	4633      	mov	r3, r6
    for(int i=0; i < ctx->num_pending; i += 16) {
 80082f2:	1b99      	subs	r1, r3, r6
 80082f4:	4281      	cmp	r1, r0
 80082f6:	da1c      	bge.n	8008332 <aes_done+0x12a>
        // Write the block to the AES engine
        AES->DINR = *p; p++;
 80082f8:	6819      	ldr	r1, [r3, #0]
 80082fa:	6091      	str	r1, [r2, #8]
        AES->DINR = *p; p++;
 80082fc:	6859      	ldr	r1, [r3, #4]
 80082fe:	6091      	str	r1, [r2, #8]
        AES->DINR = *p; p++;
 8008300:	6899      	ldr	r1, [r3, #8]
 8008302:	6091      	str	r1, [r2, #8]
        AES->DINR = *p; p++;
 8008304:	68d9      	ldr	r1, [r3, #12]
 8008306:	6091      	str	r1, [r2, #8]
 8008308:	3310      	adds	r3, #16

        // Wait for CCF flag to be raised
        while(HAL_IS_BIT_CLR(AES->SR, AES_SR_CCF)) {
 800830a:	6869      	ldr	r1, [r5, #4]
 800830c:	07c9      	lsls	r1, r1, #31
 800830e:	d5fc      	bpl.n	800830a <aes_done+0x102>
            // no timeout -- just 75 cycles?
        }

        // clear CCF flag
        SET_BIT(AES->CR, CRYP_CCF_CLEAR);
 8008310:	6829      	ldr	r1, [r5, #0]
 8008312:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 8008316:	6029      	str	r1, [r5, #0]

        // work in place, overwrite what we just wrote
        uint32_t    *out = p - 4;
        *out = AES->DOUTR; out++;
 8008318:	68e9      	ldr	r1, [r5, #12]
 800831a:	f843 1c10 	str.w	r1, [r3, #-16]
        *out = AES->DOUTR; out++;
 800831e:	68e9      	ldr	r1, [r5, #12]
 8008320:	f843 1c0c 	str.w	r1, [r3, #-12]
        *out = AES->DOUTR; out++;
 8008324:	68e9      	ldr	r1, [r5, #12]
 8008326:	f843 1c08 	str.w	r1, [r3, #-8]
        *out = AES->DOUTR;
 800832a:	68e9      	ldr	r1, [r5, #12]
 800832c:	f843 1c04 	str.w	r1, [r3, #-4]
 8008330:	e7df      	b.n	80082f2 <aes_done+0xea>
    }

    memcpy(data_out, ctx->pending, len);
 8008332:	4642      	mov	r2, r8
 8008334:	4631      	mov	r1, r6
 8008336:	4638      	mov	r0, r7
 8008338:	f005 f89f 	bl	800d47a <memcpy>

    memset(ctx, 0, sizeof(AES_CTX));
 800833c:	f44f 7201 	mov.w	r2, #516	; 0x204
 8008340:	2100      	movs	r1, #0
 8008342:	4630      	mov	r0, r6
 8008344:	f005 f8bf 	bl	800d4c6 <memset>

    // reset state of chip block, and leave clock off as well
    __HAL_RCC_AES_CLK_ENABLE();
 8008348:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800834a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800834e:	64e3      	str	r3, [r4, #76]	; 0x4c
 8008350:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8008352:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8008356:	9303      	str	r3, [sp, #12]
 8008358:	9b03      	ldr	r3, [sp, #12]
    __HAL_RCC_AES_FORCE_RESET();
 800835a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800835c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8008360:	62e3      	str	r3, [r4, #44]	; 0x2c
    __HAL_RCC_AES_RELEASE_RESET();
 8008362:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8008364:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8008368:	62e3      	str	r3, [r4, #44]	; 0x2c
    __HAL_RCC_AES_CLK_DISABLE();
 800836a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800836c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8008370:	64e3      	str	r3, [r4, #76]	; 0x4c
}
 8008372:	b005      	add	sp, #20
 8008374:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8008378:	0800d550 	.word	0x0800d550
 800837c:	40021000 	.word	0x40021000
 8008380:	50060000 	.word	0x50060000

08008384 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 8008384:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint32_t vos;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */

  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8008386:	4d1c      	ldr	r5, [pc, #112]	; (80083f8 <RCC_SetFlashLatencyFromMSIRange+0x74>)
 8008388:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800838a:	00d9      	lsls	r1, r3, #3
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 800838c:	4604      	mov	r4, r0
  uint32_t vos;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */

  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 800838e:	d502      	bpl.n	8008396 <RCC_SetFlashLatencyFromMSIRange+0x12>
  {
    vos = HAL_PWREx_GetVoltageRange();
 8008390:	f7fe fe40 	bl	8007014 <HAL_PWREx_GetVoltageRange>
 8008394:	e00e      	b.n	80083b4 <RCC_SetFlashLatencyFromMSIRange+0x30>
  }
  else
  {
    __HAL_RCC_PWR_CLK_ENABLE();
 8008396:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8008398:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800839c:	65ab      	str	r3, [r5, #88]	; 0x58
 800839e:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80083a0:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80083a4:	9301      	str	r3, [sp, #4]
 80083a6:	9b01      	ldr	r3, [sp, #4]
    vos = HAL_PWREx_GetVoltageRange();
 80083a8:	f7fe fe34 	bl	8007014 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
 80083ac:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80083ae:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80083b2:	65ab      	str	r3, [r5, #88]	; 0x58
  }

  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 80083b4:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 80083b8:	d106      	bne.n	80083c8 <RCC_SetFlashLatencyFromMSIRange+0x44>
  {
    if(msirange > RCC_MSIRANGE_8)
 80083ba:	2c80      	cmp	r4, #128	; 0x80
 80083bc:	d90b      	bls.n	80083d6 <RCC_SetFlashLatencyFromMSIRange+0x52>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
 80083be:	2ca0      	cmp	r4, #160	; 0xa0
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else
      {
        /* MSI 24Mhz or 32Mhz */
        latency = FLASH_LATENCY_1; /* 1WS */
 80083c0:	bf8c      	ite	hi
 80083c2:	2302      	movhi	r3, #2
 80083c4:	2301      	movls	r3, #1
 80083c6:	e009      	b.n	80083dc <RCC_SetFlashLatencyFromMSIRange+0x58>
  }
  else
  {
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
    defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    if(msirange >= RCC_MSIRANGE_8)
 80083c8:	2c7f      	cmp	r4, #127	; 0x7f
 80083ca:	d806      	bhi.n	80083da <RCC_SetFlashLatencyFromMSIRange+0x56>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
      {
        /* MSI 48Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
 80083cc:	f1a4 0270 	sub.w	r2, r4, #112	; 0x70
 80083d0:	4253      	negs	r3, r2
 80083d2:	4153      	adcs	r3, r2
 80083d4:	e002      	b.n	80083dc <RCC_SetFlashLatencyFromMSIRange+0x58>
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
  uint32_t vos;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 80083d6:	2300      	movs	r3, #0
 80083d8:	e000      	b.n	80083dc <RCC_SetFlashLatencyFromMSIRange+0x58>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
      {
        /* MSI 48Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
 80083da:	2302      	movs	r3, #2
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#endif
  }

  __HAL_FLASH_SET_LATENCY(latency);
 80083dc:	4907      	ldr	r1, [pc, #28]	; (80083fc <RCC_SetFlashLatencyFromMSIRange+0x78>)
 80083de:	680a      	ldr	r2, [r1, #0]
 80083e0:	f022 020f 	bic.w	r2, r2, #15
 80083e4:	431a      	orrs	r2, r3
 80083e6:	600a      	str	r2, [r1, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if(__HAL_FLASH_GET_LATENCY() != latency)
 80083e8:	6808      	ldr	r0, [r1, #0]
 80083ea:	f000 000f 	and.w	r0, r0, #15
  {
    return HAL_ERROR;
  }

  return HAL_OK;
}
 80083ee:	1ac0      	subs	r0, r0, r3
 80083f0:	bf18      	it	ne
 80083f2:	2001      	movne	r0, #1
 80083f4:	b003      	add	sp, #12
 80083f6:	bd30      	pop	{r4, r5, pc}
 80083f8:	40021000 	.word	0x40021000
 80083fc:	40022000 	.word	0x40022000

08008400 <HAL_RCC_DeInit>:
  *            - Peripheral clock sources
  *            - LSI, LSE and RTC clocks (Backup domain)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_DeInit(void)
{
 8008400:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart;

  /* Reset to default System clock */
  /* Set MSION bit */
  SET_BIT(RCC->CR, RCC_CR_MSION);
 8008402:	4c34      	ldr	r4, [pc, #208]	; (80084d4 <HAL_RCC_DeInit+0xd4>)
 8008404:	6823      	ldr	r3, [r4, #0]
 8008406:	f043 0301 	orr.w	r3, r3, #1
 800840a:	6023      	str	r3, [r4, #0]

  /* Insure MSIRDY bit is set before writing default MSIRANGE value */
  /* Get start tick */
  tickstart = HAL_GetTick();
 800840c:	f7fe fdfe 	bl	800700c <HAL_GetTick>
 8008410:	4605      	mov	r5, r0

  /* Wait till MSI is ready */
  while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8008412:	6823      	ldr	r3, [r4, #0]
 8008414:	4a2f      	ldr	r2, [pc, #188]	; (80084d4 <HAL_RCC_DeInit+0xd4>)
 8008416:	079b      	lsls	r3, r3, #30
 8008418:	d406      	bmi.n	8008428 <HAL_RCC_DeInit+0x28>
  {
    if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800841a:	f7fe fdf7 	bl	800700c <HAL_GetTick>
 800841e:	1b40      	subs	r0, r0, r5
 8008420:	2802      	cmp	r0, #2
 8008422:	d9f6      	bls.n	8008412 <HAL_RCC_DeInit+0x12>
    {
      return HAL_TIMEOUT;
 8008424:	2503      	movs	r5, #3
 8008426:	e052      	b.n	80084ce <HAL_RCC_DeInit+0xce>
    }
  }

  /* Set MSIRANGE default value */
  MODIFY_REG(RCC->CR, RCC_CR_MSIRANGE, RCC_MSIRANGE_6);
 8008428:	6813      	ldr	r3, [r2, #0]
 800842a:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800842e:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 8008432:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register (MSI is selected as system clock source) */
  CLEAR_REG(RCC->CFGR);
 8008434:	2300      	movs	r3, #0
 8008436:	6093      	str	r3, [r2, #8]

  /* Update the SystemCoreClock global variable for MSI as system clock source */
  SystemCoreClock = MSI_VALUE;
 8008438:	4b27      	ldr	r3, [pc, #156]	; (80084d8 <HAL_RCC_DeInit+0xd8>)
 800843a:	4a28      	ldr	r2, [pc, #160]	; (80084dc <HAL_RCC_DeInit+0xdc>)
 800843c:	601a      	str	r2, [r3, #0]

  /* Configure the source of time base considering new system clock settings  */
  if(HAL_InitTick(uwTickPrio) != HAL_OK)
 800843e:	4b28      	ldr	r3, [pc, #160]	; (80084e0 <HAL_RCC_DeInit+0xe0>)
 8008440:	6818      	ldr	r0, [r3, #0]
 8008442:	f7fe fde5 	bl	8007010 <HAL_InitTick>
 8008446:	4605      	mov	r5, r0
 8008448:	2800      	cmp	r0, #0
 800844a:	d13f      	bne.n	80084cc <HAL_RCC_DeInit+0xcc>
    return HAL_ERROR;
  }

  /* Insure MSI selected as system clock source */
  /* Get start tick */
  tickstart = HAL_GetTick();
 800844c:	f7fe fdde 	bl	800700c <HAL_GetTick>

  /* Wait till system clock source is ready */
  while(READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
  {
    if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8008450:	f241 3788 	movw	r7, #5000	; 0x1388
    return HAL_ERROR;
  }

  /* Insure MSI selected as system clock source */
  /* Get start tick */
  tickstart = HAL_GetTick();
 8008454:	4606      	mov	r6, r0

  /* Wait till system clock source is ready */
  while(READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
 8008456:	68a3      	ldr	r3, [r4, #8]
 8008458:	4a1e      	ldr	r2, [pc, #120]	; (80084d4 <HAL_RCC_DeInit+0xd4>)
 800845a:	f013 0f0c 	tst.w	r3, #12
 800845e:	d005      	beq.n	800846c <HAL_RCC_DeInit+0x6c>
  {
    if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8008460:	f7fe fdd4 	bl	800700c <HAL_GetTick>
 8008464:	1b80      	subs	r0, r0, r6
 8008466:	42b8      	cmp	r0, r7
 8008468:	d9f5      	bls.n	8008456 <HAL_RCC_DeInit+0x56>
 800846a:	e7db      	b.n	8008424 <HAL_RCC_DeInit+0x24>
  }

  /* Reset HSION, HSIKERON, HSIASFS, HSEON, HSECSSON, PLLON, PLLSAIxON bits */
#if defined(RCC_PLLSAI2_SUPPORT)

  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSION | RCC_CR_HSIKERON| RCC_CR_HSIASFS | RCC_CR_PLLON | RCC_CR_PLLSAI1ON | RCC_CR_PLLSAI2ON);
 800846c:	6811      	ldr	r1, [r2, #0]
 800846e:	4b1d      	ldr	r3, [pc, #116]	; (80084e4 <HAL_RCC_DeInit+0xe4>)
 8008470:	400b      	ands	r3, r1
 8008472:	6013      	str	r3, [r2, #0]

#endif /* RCC_PLLSAI2_SUPPORT */

  /* Insure PLLRDY, PLLSAI1RDY and PLLSAI2RDY (if present) are reset */
  /* Get start tick */
  tickstart = HAL_GetTick();
 8008474:	f7fe fdca 	bl	800700c <HAL_GetTick>
 8008478:	4606      	mov	r6, r0

#if defined(RCC_PLLSAI2_SUPPORT)

  while(READ_BIT(RCC->CR, RCC_CR_PLLRDY | RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY) != 0U)
 800847a:	6822      	ldr	r2, [r4, #0]
 800847c:	4b15      	ldr	r3, [pc, #84]	; (80084d4 <HAL_RCC_DeInit+0xd4>)
 800847e:	f012 5228 	ands.w	r2, r2, #704643072	; 0x2a000000
 8008482:	d005      	beq.n	8008490 <HAL_RCC_DeInit+0x90>

  while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)

#endif
  {
    if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8008484:	f7fe fdc2 	bl	800700c <HAL_GetTick>
 8008488:	1b80      	subs	r0, r0, r6
 800848a:	2802      	cmp	r0, #2
 800848c:	d9f5      	bls.n	800847a <HAL_RCC_DeInit+0x7a>
 800848e:	e7c9      	b.n	8008424 <HAL_RCC_DeInit+0x24>
      return HAL_TIMEOUT;
    }
  }

  /* Reset PLLCFGR register */
  CLEAR_REG(RCC->PLLCFGR);
 8008490:	60da      	str	r2, [r3, #12]
  SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN_4 );
 8008492:	68d9      	ldr	r1, [r3, #12]
 8008494:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 8008498:	60d9      	str	r1, [r3, #12]

#if defined(RCC_PLLSAI1_SUPPORT)

  /* Reset PLLSAI1CFGR register */
  CLEAR_REG(RCC->PLLSAI1CFGR);
 800849a:	611a      	str	r2, [r3, #16]
  SET_BIT(RCC->PLLSAI1CFGR,  RCC_PLLSAI1CFGR_PLLSAI1N_4 );
 800849c:	6919      	ldr	r1, [r3, #16]
 800849e:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 80084a2:	6119      	str	r1, [r3, #16]
#endif /* RCC_PLLSAI1_SUPPORT */

#if defined(RCC_PLLSAI2_SUPPORT)

  /* Reset PLLSAI2CFGR register */
  CLEAR_REG(RCC->PLLSAI2CFGR);
 80084a4:	615a      	str	r2, [r3, #20]
  SET_BIT(RCC->PLLSAI2CFGR,  RCC_PLLSAI2CFGR_PLLSAI2N_4 );
 80084a6:	6959      	ldr	r1, [r3, #20]
 80084a8:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 80084ac:	6159      	str	r1, [r3, #20]

#endif /* RCC_PLLSAI2_SUPPORT */

  /* Reset HSEBYP bit */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
 80084ae:	6819      	ldr	r1, [r3, #0]
 80084b0:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 80084b4:	6019      	str	r1, [r3, #0]

  /* Disable all interrupts */
  CLEAR_REG(RCC->CIER);
 80084b6:	619a      	str	r2, [r3, #24]

  /* Clear all interrupt flags */
  WRITE_REG(RCC->CICR, 0xFFFFFFFFU);
 80084b8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80084bc:	621a      	str	r2, [r3, #32]

  /* Clear all reset flags */
  SET_BIT(RCC->CSR, RCC_CSR_RMVF);
 80084be:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 80084c2:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 80084c6:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

  return HAL_OK;
 80084ca:	e000      	b.n	80084ce <HAL_RCC_DeInit+0xce>
  SystemCoreClock = MSI_VALUE;

  /* Configure the source of time base considering new system clock settings  */
  if(HAL_InitTick(uwTickPrio) != HAL_OK)
  {
    return HAL_ERROR;
 80084cc:	2501      	movs	r5, #1

  /* Clear all reset flags */
  SET_BIT(RCC->CSR, RCC_CSR_RMVF);

  return HAL_OK;
}
 80084ce:	4628      	mov	r0, r5
 80084d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80084d2:	bf00      	nop
 80084d4:	40021000 	.word	0x40021000
 80084d8:	20000448 	.word	0x20000448
 80084dc:	003d0900 	.word	0x003d0900
 80084e0:	20000238 	.word	0x20000238
 80084e4:	eafef4ff 	.word	0xeafef4ff

080084e8 <HAL_RCC_MCOConfig>:
  *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
  *            @arg @ref RCC_MCODIV_16  division by 16 applied to MCO clock
  * @retval None
  */
void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 80084e8:	b570      	push	{r4, r5, r6, lr}

  /* Prevent unused argument(s) compilation warning if no assert_param check */
  UNUSED(RCC_MCOx);

  /* MCO Clock Enable */
  __MCO1_CLK_ENABLE();
 80084ea:	4c11      	ldr	r4, [pc, #68]	; (8008530 <HAL_RCC_MCOConfig+0x48>)
 80084ec:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80084ee:	f043 0301 	orr.w	r3, r3, #1
 80084f2:	64e3      	str	r3, [r4, #76]	; 0x4c
 80084f4:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
  *            @arg @ref RCC_MCODIV_16  division by 16 applied to MCO clock
  * @retval None
  */
void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 80084f6:	b086      	sub	sp, #24

  /* Prevent unused argument(s) compilation warning if no assert_param check */
  UNUSED(RCC_MCOx);

  /* MCO Clock Enable */
  __MCO1_CLK_ENABLE();
 80084f8:	f003 0301 	and.w	r3, r3, #1
 80084fc:	9300      	str	r3, [sp, #0]
 80084fe:	9b00      	ldr	r3, [sp, #0]

  /* Configue the MCO1 pin in alternate function mode */
  GPIO_InitStruct.Pin = MCO1_PIN;
 8008500:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008504:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008506:	2302      	movs	r3, #2
 8008508:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800850a:	9304      	str	r3, [sp, #16]
  *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
  *            @arg @ref RCC_MCODIV_16  division by 16 applied to MCO clock
  * @retval None
  */
void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 800850c:	460d      	mov	r5, r1

  /* Configue the MCO1 pin in alternate function mode */
  GPIO_InitStruct.Pin = MCO1_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800850e:	2300      	movs	r3, #0
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
  HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
 8008510:	a901      	add	r1, sp, #4
 8008512:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  *            @arg @ref RCC_MCODIV_8  division by 8 applied to MCO clock
  *            @arg @ref RCC_MCODIV_16  division by 16 applied to MCO clock
  * @retval None
  */
void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 8008516:	4616      	mov	r6, r2

  /* Configue the MCO1 pin in alternate function mode */
  GPIO_InitStruct.Pin = MCO1_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008518:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 800851a:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
 800851c:	f7f8 fd50 	bl	8000fc0 <HAL_GPIO_Init>

  /* Mask MCOSEL[] and MCOPRE[] bits then set MCO1 clock source and prescaler */
  MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCOSEL | RCC_CFGR_MCOPRE), (RCC_MCOSource | RCC_MCODiv ));
 8008520:	68a2      	ldr	r2, [r4, #8]
 8008522:	f022 42fe 	bic.w	r2, r2, #2130706432	; 0x7f000000
 8008526:	4316      	orrs	r6, r2
 8008528:	4335      	orrs	r5, r6
 800852a:	60a5      	str	r5, [r4, #8]
}
 800852c:	b006      	add	sp, #24
 800852e:	bd70      	pop	{r4, r5, r6, pc}
 8008530:	40021000 	.word	0x40021000

08008534 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t msirange = 0U, sysclockfreq = 0U;
  uint32_t pllvco, pllsource, pllr, pllm;    /* no init needed */
  uint32_t sysclk_source, pll_oscsource;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8008534:	4a24      	ldr	r2, [pc, #144]	; (80085c8 <HAL_RCC_GetSysClockFreq+0x94>)
 8008536:	6893      	ldr	r3, [r2, #8]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8008538:	68d1      	ldr	r1, [r2, #12]

  if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 800853a:	f013 030c 	ands.w	r3, r3, #12
 800853e:	d005      	beq.n	800854c <HAL_RCC_GetSysClockFreq+0x18>
 8008540:	2b0c      	cmp	r3, #12
 8008542:	d114      	bne.n	800856e <HAL_RCC_GetSysClockFreq+0x3a>
     ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 8008544:	f001 0103 	and.w	r1, r1, #3
 8008548:	2901      	cmp	r1, #1
 800854a:	d11a      	bne.n	8008582 <HAL_RCC_GetSysClockFreq+0x4e>
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 800854c:	6810      	ldr	r0, [r2, #0]
 800854e:	491e      	ldr	r1, [pc, #120]	; (80085c8 <HAL_RCC_GetSysClockFreq+0x94>)
 8008550:	0700      	lsls	r0, r0, #28
    { /* MSISRANGE from RCC_CSR applies */
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8008552:	bf54      	ite	pl
 8008554:	f8d1 1094 	ldrpl.w	r1, [r1, #148]	; 0x94
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8008558:	6809      	ldrmi	r1, [r1, #0]
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 800855a:	481c      	ldr	r0, [pc, #112]	; (80085cc <HAL_RCC_GetSysClockFreq+0x98>)
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
    { /* MSISRANGE from RCC_CSR applies */
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 800855c:	bf54      	ite	pl
 800855e:	f3c1 2103 	ubfxpl	r1, r1, #8, #4
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8008562:	f3c1 1103 	ubfxmi	r1, r1, #4, #4
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 8008566:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]

    if(sysclk_source == RCC_CFGR_SWS_MSI)
 800856a:	b35b      	cbz	r3, 80085c4 <HAL_RCC_GetSysClockFreq+0x90>
 800856c:	e006      	b.n	800857c <HAL_RCC_GetSysClockFreq+0x48>
    {
      /* MSI used as system clock source */
      sysclockfreq = msirange;
    }
  }
  else if(sysclk_source == RCC_CFGR_SWS_HSI)
 800856e:	2b04      	cmp	r3, #4
 8008570:	d027      	beq.n	80085c2 <HAL_RCC_GetSysClockFreq+0x8e>
 8008572:	2b08      	cmp	r3, #8
 8008574:	4816      	ldr	r0, [pc, #88]	; (80085d0 <HAL_RCC_GetSysClockFreq+0x9c>)
 8008576:	bf18      	it	ne
 8008578:	2000      	movne	r0, #0
 800857a:	4770      	bx	lr
  else
  {
    /* unexpected case: sysclockfreq at 0 */
  }

  if(sysclk_source == RCC_CFGR_SWS_PLL)
 800857c:	2b0c      	cmp	r3, #12
 800857e:	d001      	beq.n	8008584 <HAL_RCC_GetSysClockFreq+0x50>
 8008580:	e01d      	b.n	80085be <HAL_RCC_GetSysClockFreq+0x8a>
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t msirange = 0U, sysclockfreq = 0U;
 8008582:	2000      	movs	r0, #0
    /* PLL used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE) * PLLN / PLLM
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8008584:	68d3      	ldr	r3, [r2, #12]

    switch (pllsource)
 8008586:	f003 0303 	and.w	r3, r3, #3
 800858a:	2b02      	cmp	r3, #2
 800858c:	d004      	beq.n	8008598 <HAL_RCC_GetSysClockFreq+0x64>
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllvco = HSI_VALUE;
      break;

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pllvco = HSE_VALUE;
 800858e:	4910      	ldr	r1, [pc, #64]	; (80085d0 <HAL_RCC_GetSysClockFreq+0x9c>)
 8008590:	2b03      	cmp	r3, #3
 8008592:	bf08      	it	eq
 8008594:	4608      	moveq	r0, r1
 8008596:	e000      	b.n	800859a <HAL_RCC_GetSysClockFreq+0x66>
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);

    switch (pllsource)
    {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllvco = HSI_VALUE;
 8008598:	480e      	ldr	r0, [pc, #56]	; (80085d4 <HAL_RCC_GetSysClockFreq+0xa0>)
    case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
    default:
      pllvco = msirange;
      break;
    }
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 800859a:	68d3      	ldr	r3, [r2, #12]
    pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 800859c:	68d1      	ldr	r1, [r2, #12]
 800859e:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80085a2:	f3c1 2106 	ubfx	r1, r1, #8, #7
 80085a6:	4348      	muls	r0, r1
 80085a8:	3301      	adds	r3, #1
 80085aa:	fbb0 f3f3 	udiv	r3, r0, r3
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 80085ae:	68d0      	ldr	r0, [r2, #12]
    sysclockfreq = pllvco / pllr;
 80085b0:	f3c0 6041 	ubfx	r0, r0, #25, #2
 80085b4:	3001      	adds	r0, #1
 80085b6:	0040      	lsls	r0, r0, #1
 80085b8:	fbb3 f0f0 	udiv	r0, r3, r0
 80085bc:	4770      	bx	lr
 80085be:	2000      	movs	r0, #0
 80085c0:	4770      	bx	lr
    }
  }
  else if(sysclk_source == RCC_CFGR_SWS_HSI)
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 80085c2:	4804      	ldr	r0, [pc, #16]	; (80085d4 <HAL_RCC_GetSysClockFreq+0xa0>)
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
    sysclockfreq = pllvco / pllr;
  }

  return sysclockfreq;
}
 80085c4:	4770      	bx	lr
 80085c6:	bf00      	nop
 80085c8:	40021000 	.word	0x40021000
 80085cc:	0800e738 	.word	0x0800e738
 80085d0:	007a1200 	.word	0x007a1200
 80085d4:	00f42400 	.word	0x00f42400

080085d8 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80085d8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status;
  uint32_t sysclk_source, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 80085dc:	4605      	mov	r5, r0
 80085de:	2800      	cmp	r0, #0
 80085e0:	f000 82a9 	beq.w	8008b36 <HAL_RCC_OscConfig+0x55e>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 80085e4:	4c9f      	ldr	r4, [pc, #636]	; (8008864 <HAL_RCC_OscConfig+0x28c>)
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80085e6:	6803      	ldr	r3, [r0, #0]
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 80085e8:	68a6      	ldr	r6, [r4, #8]
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 80085ea:	68e7      	ldr	r7, [r4, #12]

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80085ec:	06db      	lsls	r3, r3, #27
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 80085ee:	f006 060c 	and.w	r6, r6, #12
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 80085f2:	f007 0703 	and.w	r7, r7, #3

  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80085f6:	f140 8091 	bpl.w	800871c <HAL_RCC_OscConfig+0x144>
    assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

    /* Check if MSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 80085fa:	b11e      	cbz	r6, 8008604 <HAL_RCC_OscConfig+0x2c>
 80085fc:	2e0c      	cmp	r6, #12
 80085fe:	d155      	bne.n	80086ac <HAL_RCC_OscConfig+0xd4>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_MSI)))
 8008600:	2f01      	cmp	r7, #1
 8008602:	d153      	bne.n	80086ac <HAL_RCC_OscConfig+0xd4>
    {
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8008604:	6823      	ldr	r3, [r4, #0]
 8008606:	0798      	lsls	r0, r3, #30
 8008608:	d503      	bpl.n	8008612 <HAL_RCC_OscConfig+0x3a>
 800860a:	69ab      	ldr	r3, [r5, #24]
 800860c:	2b00      	cmp	r3, #0
 800860e:	f000 8292 	beq.w	8008b36 <HAL_RCC_OscConfig+0x55e>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the CPU clock
           (HCLK) and the supply voltage of the device. */
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8008612:	6822      	ldr	r2, [r4, #0]
 8008614:	4b93      	ldr	r3, [pc, #588]	; (8008864 <HAL_RCC_OscConfig+0x28c>)
 8008616:	6a28      	ldr	r0, [r5, #32]
 8008618:	0711      	lsls	r1, r2, #28
 800861a:	bf56      	itet	pl
 800861c:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
 8008620:	681b      	ldrmi	r3, [r3, #0]
 8008622:	091b      	lsrpl	r3, r3, #4
 8008624:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8008628:	4283      	cmp	r3, r0
 800862a:	d216      	bcs.n	800865a <HAL_RCC_OscConfig+0x82>
        {
          /* First increase number of wait states update if necessary */
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 800862c:	f7ff feaa 	bl	8008384 <RCC_SetFlashLatencyFromMSIRange>
 8008630:	2800      	cmp	r0, #0
 8008632:	f040 8280 	bne.w	8008b36 <HAL_RCC_OscConfig+0x55e>
          {
            return HAL_ERROR;
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8008636:	6823      	ldr	r3, [r4, #0]
 8008638:	f043 0308 	orr.w	r3, r3, #8
 800863c:	6023      	str	r3, [r4, #0]
 800863e:	6823      	ldr	r3, [r4, #0]
 8008640:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8008644:	6a2b      	ldr	r3, [r5, #32]
 8008646:	4313      	orrs	r3, r2
 8008648:	6023      	str	r3, [r4, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800864a:	6863      	ldr	r3, [r4, #4]
 800864c:	69ea      	ldr	r2, [r5, #28]
 800864e:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8008652:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8008656:	6063      	str	r3, [r4, #4]
 8008658:	e015      	b.n	8008686 <HAL_RCC_OscConfig+0xae>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800865a:	6823      	ldr	r3, [r4, #0]
 800865c:	f043 0308 	orr.w	r3, r3, #8
 8008660:	6023      	str	r3, [r4, #0]
 8008662:	6823      	ldr	r3, [r4, #0]
 8008664:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8008668:	4303      	orrs	r3, r0
 800866a:	6023      	str	r3, [r4, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800866c:	6863      	ldr	r3, [r4, #4]
 800866e:	69ea      	ldr	r2, [r5, #28]
 8008670:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8008674:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8008678:	6063      	str	r3, [r4, #4]

          /* Decrease number of wait states update if necessary */
          /* Only possible when MSI is the System clock source  */
          if(sysclk_source == RCC_CFGR_SWS_MSI)
 800867a:	b926      	cbnz	r6, 8008686 <HAL_RCC_OscConfig+0xae>
          {
            if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 800867c:	f7ff fe82 	bl	8008384 <RCC_SetFlashLatencyFromMSIRange>
 8008680:	2800      	cmp	r0, #0
 8008682:	f040 8258 	bne.w	8008b36 <HAL_RCC_OscConfig+0x55e>
            }
          }
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8008686:	f7ff ff55 	bl	8008534 <HAL_RCC_GetSysClockFreq>
 800868a:	68a3      	ldr	r3, [r4, #8]
 800868c:	4a76      	ldr	r2, [pc, #472]	; (8008868 <HAL_RCC_OscConfig+0x290>)
 800868e:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8008692:	5cd3      	ldrb	r3, [r2, r3]
 8008694:	f003 031f 	and.w	r3, r3, #31
 8008698:	40d8      	lsrs	r0, r3
 800869a:	4b74      	ldr	r3, [pc, #464]	; (800886c <HAL_RCC_OscConfig+0x294>)
 800869c:	6018      	str	r0, [r3, #0]

        /* Configure the source of time base considering new system clocks settings*/
        status = HAL_InitTick(uwTickPrio);
 800869e:	4b74      	ldr	r3, [pc, #464]	; (8008870 <HAL_RCC_OscConfig+0x298>)
 80086a0:	6818      	ldr	r0, [r3, #0]
 80086a2:	f7fe fcb5 	bl	8007010 <HAL_InitTick>
        if(status != HAL_OK)
 80086a6:	2800      	cmp	r0, #0
 80086a8:	d038      	beq.n	800871c <HAL_RCC_OscConfig+0x144>
 80086aa:	e245      	b.n	8008b38 <HAL_RCC_OscConfig+0x560>
      }
    }
    else
    {
      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 80086ac:	69ab      	ldr	r3, [r5, #24]
 80086ae:	b323      	cbz	r3, 80086fa <HAL_RCC_OscConfig+0x122>
      {
        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 80086b0:	6823      	ldr	r3, [r4, #0]
 80086b2:	f043 0301 	orr.w	r3, r3, #1
 80086b6:	6023      	str	r3, [r4, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();
 80086b8:	f7fe fca8 	bl	800700c <HAL_GetTick>
 80086bc:	4680      	mov	r8, r0

        /* Wait till MSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 80086be:	6822      	ldr	r2, [r4, #0]
 80086c0:	4b68      	ldr	r3, [pc, #416]	; (8008864 <HAL_RCC_OscConfig+0x28c>)
 80086c2:	0792      	lsls	r2, r2, #30
 80086c4:	d407      	bmi.n	80086d6 <HAL_RCC_OscConfig+0xfe>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80086c6:	f7fe fca1 	bl	800700c <HAL_GetTick>
 80086ca:	ebc8 0000 	rsb	r0, r8, r0
 80086ce:	2802      	cmp	r0, #2
 80086d0:	d9f5      	bls.n	80086be <HAL_RCC_OscConfig+0xe6>
          {
            return HAL_TIMEOUT;
 80086d2:	2003      	movs	r0, #3
 80086d4:	e230      	b.n	8008b38 <HAL_RCC_OscConfig+0x560>
          }
        }
         /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80086d6:	681a      	ldr	r2, [r3, #0]
 80086d8:	f042 0208 	orr.w	r2, r2, #8
 80086dc:	601a      	str	r2, [r3, #0]
 80086de:	681a      	ldr	r2, [r3, #0]
 80086e0:	f022 01f0 	bic.w	r1, r2, #240	; 0xf0
 80086e4:	6a2a      	ldr	r2, [r5, #32]
 80086e6:	430a      	orrs	r2, r1
 80086e8:	601a      	str	r2, [r3, #0]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80086ea:	685a      	ldr	r2, [r3, #4]
 80086ec:	69e9      	ldr	r1, [r5, #28]
 80086ee:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 80086f2:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80086f6:	605a      	str	r2, [r3, #4]
 80086f8:	e010      	b.n	800871c <HAL_RCC_OscConfig+0x144>

      }
      else
      {
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 80086fa:	6823      	ldr	r3, [r4, #0]
 80086fc:	f023 0301 	bic.w	r3, r3, #1
 8008700:	6023      	str	r3, [r4, #0]

        /* Get timeout */
        tickstart = HAL_GetTick();
 8008702:	f7fe fc83 	bl	800700c <HAL_GetTick>
 8008706:	4680      	mov	r8, r0

        /* Wait till MSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
 8008708:	6823      	ldr	r3, [r4, #0]
 800870a:	0798      	lsls	r0, r3, #30
 800870c:	d506      	bpl.n	800871c <HAL_RCC_OscConfig+0x144>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800870e:	f7fe fc7d 	bl	800700c <HAL_GetTick>
 8008712:	ebc8 0000 	rsb	r0, r8, r0
 8008716:	2802      	cmp	r0, #2
 8008718:	d9f6      	bls.n	8008708 <HAL_RCC_OscConfig+0x130>
 800871a:	e7da      	b.n	80086d2 <HAL_RCC_OscConfig+0xfa>
        }
      }
    }
  }
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800871c:	682b      	ldr	r3, [r5, #0]
 800871e:	07d9      	lsls	r1, r3, #31
 8008720:	d403      	bmi.n	800872a <HAL_RCC_OscConfig+0x152>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8008722:	682b      	ldr	r3, [r5, #0]
 8008724:	079a      	lsls	r2, r3, #30
 8008726:	d440      	bmi.n	80087aa <HAL_RCC_OscConfig+0x1d2>
 8008728:	e07f      	b.n	800882a <HAL_RCC_OscConfig+0x252>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((sysclk_source == RCC_CFGR_SWS_HSE) ||
 800872a:	2e08      	cmp	r6, #8
 800872c:	d003      	beq.n	8008736 <HAL_RCC_OscConfig+0x15e>
 800872e:	2e0c      	cmp	r6, #12
 8008730:	d108      	bne.n	8008744 <HAL_RCC_OscConfig+0x16c>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSE)))
 8008732:	2f03      	cmp	r7, #3
 8008734:	d106      	bne.n	8008744 <HAL_RCC_OscConfig+0x16c>
    {
      if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8008736:	6823      	ldr	r3, [r4, #0]
 8008738:	039b      	lsls	r3, r3, #14
 800873a:	d5f2      	bpl.n	8008722 <HAL_RCC_OscConfig+0x14a>
 800873c:	686b      	ldr	r3, [r5, #4]
 800873e:	2b00      	cmp	r3, #0
 8008740:	d1ef      	bne.n	8008722 <HAL_RCC_OscConfig+0x14a>
 8008742:	e1f8      	b.n	8008b36 <HAL_RCC_OscConfig+0x55e>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8008744:	686b      	ldr	r3, [r5, #4]
 8008746:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800874a:	d006      	beq.n	800875a <HAL_RCC_OscConfig+0x182>
 800874c:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8008750:	d108      	bne.n	8008764 <HAL_RCC_OscConfig+0x18c>
 8008752:	6823      	ldr	r3, [r4, #0]
 8008754:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8008758:	6023      	str	r3, [r4, #0]
 800875a:	6823      	ldr	r3, [r4, #0]
 800875c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8008760:	6023      	str	r3, [r4, #0]
 8008762:	e008      	b.n	8008776 <HAL_RCC_OscConfig+0x19e>
 8008764:	6822      	ldr	r2, [r4, #0]
 8008766:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800876a:	6022      	str	r2, [r4, #0]
 800876c:	6822      	ldr	r2, [r4, #0]
 800876e:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8008772:	6022      	str	r2, [r4, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8008774:	b163      	cbz	r3, 8008790 <HAL_RCC_OscConfig+0x1b8>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8008776:	f7fe fc49 	bl	800700c <HAL_GetTick>
 800877a:	4680      	mov	r8, r0

        /* Wait till HSE is ready */
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 800877c:	6823      	ldr	r3, [r4, #0]
 800877e:	0398      	lsls	r0, r3, #14
 8008780:	d4cf      	bmi.n	8008722 <HAL_RCC_OscConfig+0x14a>
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8008782:	f7fe fc43 	bl	800700c <HAL_GetTick>
 8008786:	ebc8 0000 	rsb	r0, r8, r0
 800878a:	2864      	cmp	r0, #100	; 0x64
 800878c:	d9f6      	bls.n	800877c <HAL_RCC_OscConfig+0x1a4>
 800878e:	e7a0      	b.n	80086d2 <HAL_RCC_OscConfig+0xfa>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8008790:	f7fe fc3c 	bl	800700c <HAL_GetTick>
 8008794:	4680      	mov	r8, r0

        /* Wait till HSE is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8008796:	6823      	ldr	r3, [r4, #0]
 8008798:	0399      	lsls	r1, r3, #14
 800879a:	d5c2      	bpl.n	8008722 <HAL_RCC_OscConfig+0x14a>
        {
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800879c:	f7fe fc36 	bl	800700c <HAL_GetTick>
 80087a0:	ebc8 0000 	rsb	r0, r8, r0
 80087a4:	2864      	cmp	r0, #100	; 0x64
 80087a6:	d9f6      	bls.n	8008796 <HAL_RCC_OscConfig+0x1be>
 80087a8:	e793      	b.n	80086d2 <HAL_RCC_OscConfig+0xfa>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((sysclk_source == RCC_CFGR_SWS_HSI) ||
 80087aa:	2e04      	cmp	r6, #4
 80087ac:	d003      	beq.n	80087b6 <HAL_RCC_OscConfig+0x1de>
 80087ae:	2e0c      	cmp	r6, #12
 80087b0:	d110      	bne.n	80087d4 <HAL_RCC_OscConfig+0x1fc>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSI)))
 80087b2:	2f02      	cmp	r7, #2
 80087b4:	d10e      	bne.n	80087d4 <HAL_RCC_OscConfig+0x1fc>
    {
      /* When HSI is used as system clock it will not be disabled */
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80087b6:	6823      	ldr	r3, [r4, #0]
 80087b8:	055a      	lsls	r2, r3, #21
 80087ba:	d503      	bpl.n	80087c4 <HAL_RCC_OscConfig+0x1ec>
 80087bc:	68eb      	ldr	r3, [r5, #12]
 80087be:	2b00      	cmp	r3, #0
 80087c0:	f000 81b9 	beq.w	8008b36 <HAL_RCC_OscConfig+0x55e>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80087c4:	6863      	ldr	r3, [r4, #4]
 80087c6:	692a      	ldr	r2, [r5, #16]
 80087c8:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 80087cc:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80087d0:	6063      	str	r3, [r4, #4]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((sysclk_source == RCC_CFGR_SWS_HSI) ||
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSI)))
    {
      /* When HSI is used as system clock it will not be disabled */
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80087d2:	e02a      	b.n	800882a <HAL_RCC_OscConfig+0x252>
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80087d4:	68eb      	ldr	r3, [r5, #12]
 80087d6:	b1c3      	cbz	r3, 800880a <HAL_RCC_OscConfig+0x232>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 80087d8:	6823      	ldr	r3, [r4, #0]
 80087da:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80087de:	6023      	str	r3, [r4, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80087e0:	f7fe fc14 	bl	800700c <HAL_GetTick>
 80087e4:	4607      	mov	r7, r0

        /* Wait till HSI is ready */
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 80087e6:	6823      	ldr	r3, [r4, #0]
 80087e8:	4a1e      	ldr	r2, [pc, #120]	; (8008864 <HAL_RCC_OscConfig+0x28c>)
 80087ea:	055b      	lsls	r3, r3, #21
 80087ec:	d405      	bmi.n	80087fa <HAL_RCC_OscConfig+0x222>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80087ee:	f7fe fc0d 	bl	800700c <HAL_GetTick>
 80087f2:	1bc0      	subs	r0, r0, r7
 80087f4:	2802      	cmp	r0, #2
 80087f6:	d9f6      	bls.n	80087e6 <HAL_RCC_OscConfig+0x20e>
 80087f8:	e76b      	b.n	80086d2 <HAL_RCC_OscConfig+0xfa>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80087fa:	6853      	ldr	r3, [r2, #4]
 80087fc:	6929      	ldr	r1, [r5, #16]
 80087fe:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8008802:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8008806:	6053      	str	r3, [r2, #4]
 8008808:	e00f      	b.n	800882a <HAL_RCC_OscConfig+0x252>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800880a:	6823      	ldr	r3, [r4, #0]
 800880c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8008810:	6023      	str	r3, [r4, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8008812:	f7fe fbfb 	bl	800700c <HAL_GetTick>
 8008816:	4607      	mov	r7, r0

        /* Wait till HSI is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8008818:	6823      	ldr	r3, [r4, #0]
 800881a:	0558      	lsls	r0, r3, #21
 800881c:	d505      	bpl.n	800882a <HAL_RCC_OscConfig+0x252>
        {
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800881e:	f7fe fbf5 	bl	800700c <HAL_GetTick>
 8008822:	1bc0      	subs	r0, r0, r7
 8008824:	2802      	cmp	r0, #2
 8008826:	d9f7      	bls.n	8008818 <HAL_RCC_OscConfig+0x240>
 8008828:	e753      	b.n	80086d2 <HAL_RCC_OscConfig+0xfa>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800882a:	682b      	ldr	r3, [r5, #0]
 800882c:	0719      	lsls	r1, r3, #28
 800882e:	d403      	bmi.n	8008838 <HAL_RCC_OscConfig+0x260>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8008830:	682b      	ldr	r3, [r5, #0]
 8008832:	075a      	lsls	r2, r3, #29
 8008834:	d431      	bmi.n	800889a <HAL_RCC_OscConfig+0x2c2>
 8008836:	e09d      	b.n	8008974 <HAL_RCC_OscConfig+0x39c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8008838:	696b      	ldr	r3, [r5, #20]
 800883a:	b1db      	cbz	r3, 8008874 <HAL_RCC_OscConfig+0x29c>
        MODIFY_REG(RCC->CSR, RCC_CSR_LSIPREDIV, RCC_OscInitStruct->LSIDiv);
      }
#endif /* RCC_CSR_LSIPREDIV */

      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800883c:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 8008840:	f043 0301 	orr.w	r3, r3, #1
 8008844:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8008848:	f7fe fbe0 	bl	800700c <HAL_GetTick>
 800884c:	4607      	mov	r7, r0

      /* Wait till LSI is ready */
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 800884e:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 8008852:	079b      	lsls	r3, r3, #30
 8008854:	d4ec      	bmi.n	8008830 <HAL_RCC_OscConfig+0x258>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8008856:	f7fe fbd9 	bl	800700c <HAL_GetTick>
 800885a:	1bc0      	subs	r0, r0, r7
 800885c:	2802      	cmp	r0, #2
 800885e:	d9f6      	bls.n	800884e <HAL_RCC_OscConfig+0x276>
 8008860:	e737      	b.n	80086d2 <HAL_RCC_OscConfig+0xfa>
 8008862:	bf00      	nop
 8008864:	40021000 	.word	0x40021000
 8008868:	0800e720 	.word	0x0800e720
 800886c:	20000448 	.word	0x20000448
 8008870:	20000238 	.word	0x20000238
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8008874:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 8008878:	f023 0301 	bic.w	r3, r3, #1
 800887c:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8008880:	f7fe fbc4 	bl	800700c <HAL_GetTick>
 8008884:	4607      	mov	r7, r0

      /* Wait till LSI is disabled */
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 8008886:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 800888a:	0798      	lsls	r0, r3, #30
 800888c:	d5d0      	bpl.n	8008830 <HAL_RCC_OscConfig+0x258>
      {
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800888e:	f7fe fbbd 	bl	800700c <HAL_GetTick>
 8008892:	1bc0      	subs	r0, r0, r7
 8008894:	2802      	cmp	r0, #2
 8008896:	d9f6      	bls.n	8008886 <HAL_RCC_OscConfig+0x2ae>
 8008898:	e71b      	b.n	80086d2 <HAL_RCC_OscConfig+0xfa>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 800889a:	6da2      	ldr	r2, [r4, #88]	; 0x58
 800889c:	4ba8      	ldr	r3, [pc, #672]	; (8008b40 <HAL_RCC_OscConfig+0x568>)
 800889e:	00d1      	lsls	r1, r2, #3
 80088a0:	d40b      	bmi.n	80088ba <HAL_RCC_OscConfig+0x2e2>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 80088a2:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80088a4:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80088a8:	659a      	str	r2, [r3, #88]	; 0x58
 80088aa:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80088ac:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80088b0:	9301      	str	r3, [sp, #4]
 80088b2:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 80088b4:	f04f 0801 	mov.w	r8, #1
 80088b8:	e001      	b.n	80088be <HAL_RCC_OscConfig+0x2e6>
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
  {
    FlagStatus       pwrclkchanged = RESET;
 80088ba:	f04f 0800 	mov.w	r8, #0
    {
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }

    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80088be:	4fa1      	ldr	r7, [pc, #644]	; (8008b44 <HAL_RCC_OscConfig+0x56c>)
 80088c0:	683b      	ldr	r3, [r7, #0]
 80088c2:	05da      	lsls	r2, r3, #23
 80088c4:	d503      	bpl.n	80088ce <HAL_RCC_OscConfig+0x2f6>
    {
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
    }
#else
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80088c6:	68ab      	ldr	r3, [r5, #8]
 80088c8:	2b01      	cmp	r3, #1
 80088ca:	d111      	bne.n	80088f0 <HAL_RCC_OscConfig+0x318>
 80088cc:	e018      	b.n	8008900 <HAL_RCC_OscConfig+0x328>
    }

    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80088ce:	683b      	ldr	r3, [r7, #0]
 80088d0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80088d4:	603b      	str	r3, [r7, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 80088d6:	f7fe fb99 	bl	800700c <HAL_GetTick>
 80088da:	4681      	mov	r9, r0

      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80088dc:	683b      	ldr	r3, [r7, #0]
 80088de:	05db      	lsls	r3, r3, #23
 80088e0:	d4f1      	bmi.n	80088c6 <HAL_RCC_OscConfig+0x2ee>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80088e2:	f7fe fb93 	bl	800700c <HAL_GetTick>
 80088e6:	ebc9 0000 	rsb	r0, r9, r0
 80088ea:	2802      	cmp	r0, #2
 80088ec:	d9f6      	bls.n	80088dc <HAL_RCC_OscConfig+0x304>
 80088ee:	e6f0      	b.n	80086d2 <HAL_RCC_OscConfig+0xfa>
    {
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
    }
#else
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80088f0:	2b05      	cmp	r3, #5
 80088f2:	d10c      	bne.n	800890e <HAL_RCC_OscConfig+0x336>
 80088f4:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 80088f8:	f043 0304 	orr.w	r3, r3, #4
 80088fc:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
 8008900:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 8008904:	f043 0301 	orr.w	r3, r3, #1
 8008908:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
 800890c:	e00c      	b.n	8008928 <HAL_RCC_OscConfig+0x350>
 800890e:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 8008912:	f022 0201 	bic.w	r2, r2, #1
 8008916:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
 800891a:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 800891e:	f022 0204 	bic.w	r2, r2, #4
 8008922:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
#endif /* RCC_BDCR_LSESYSDIS */

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8008926:	b173      	cbz	r3, 8008946 <HAL_RCC_OscConfig+0x36e>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8008928:	f7fe fb70 	bl	800700c <HAL_GetTick>

      /* Wait till LSE is ready */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800892c:	f241 3988 	movw	r9, #5000	; 0x1388

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8008930:	4607      	mov	r7, r0

      /* Wait till LSE is ready */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8008932:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 8008936:	0798      	lsls	r0, r3, #30
 8008938:	d40e      	bmi.n	8008958 <HAL_RCC_OscConfig+0x380>
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800893a:	f7fe fb67 	bl	800700c <HAL_GetTick>
 800893e:	1bc0      	subs	r0, r0, r7
 8008940:	4548      	cmp	r0, r9
 8008942:	d9f6      	bls.n	8008932 <HAL_RCC_OscConfig+0x35a>
 8008944:	e6c5      	b.n	80086d2 <HAL_RCC_OscConfig+0xfa>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8008946:	f7fe fb61 	bl	800700c <HAL_GetTick>

      /* Wait till LSE is disabled */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800894a:	f241 3988 	movw	r9, #5000	; 0x1388
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800894e:	4607      	mov	r7, r0

      /* Wait till LSE is disabled */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8008950:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 8008954:	0799      	lsls	r1, r3, #30
 8008956:	d407      	bmi.n	8008968 <HAL_RCC_OscConfig+0x390>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSDIS);
#endif /* RCC_BDCR_LSESYSDIS */
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8008958:	f1b8 0f00 	cmp.w	r8, #0
 800895c:	d00a      	beq.n	8008974 <HAL_RCC_OscConfig+0x39c>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800895e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8008960:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8008964:	65a3      	str	r3, [r4, #88]	; 0x58
 8008966:	e005      	b.n	8008974 <HAL_RCC_OscConfig+0x39c>
      tickstart = HAL_GetTick();

      /* Wait till LSE is disabled */
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8008968:	f7fe fb50 	bl	800700c <HAL_GetTick>
 800896c:	1bc0      	subs	r0, r0, r7
 800896e:	4548      	cmp	r0, r9
 8008970:	d9ee      	bls.n	8008950 <HAL_RCC_OscConfig+0x378>
 8008972:	e6ae      	b.n	80086d2 <HAL_RCC_OscConfig+0xfa>
      __HAL_RCC_PWR_CLK_DISABLE();
    }
  }
#if defined(RCC_HSI48_SUPPORT)
  /*------------------------------ HSI48 Configuration -----------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 8008974:	682b      	ldr	r3, [r5, #0]
 8008976:	069a      	lsls	r2, r3, #26
 8008978:	d402      	bmi.n	8008980 <HAL_RCC_OscConfig+0x3a8>
#endif /* RCC_HSI48_SUPPORT */
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 800897a:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800897c:	bb43      	cbnz	r3, 80089d0 <HAL_RCC_OscConfig+0x3f8>
 800897e:	e070      	b.n	8008a62 <HAL_RCC_OscConfig+0x48a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the LSI State */
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 8008980:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8008982:	b193      	cbz	r3, 80089aa <HAL_RCC_OscConfig+0x3d2>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 8008984:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 8008988:	f043 0301 	orr.w	r3, r3, #1
 800898c:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8008990:	f7fe fb3c 	bl	800700c <HAL_GetTick>
 8008994:	4607      	mov	r7, r0

      /* Wait till HSI48 is ready */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 8008996:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 800899a:	079b      	lsls	r3, r3, #30
 800899c:	d4ed      	bmi.n	800897a <HAL_RCC_OscConfig+0x3a2>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800899e:	f7fe fb35 	bl	800700c <HAL_GetTick>
 80089a2:	1bc0      	subs	r0, r0, r7
 80089a4:	2802      	cmp	r0, #2
 80089a6:	d9f6      	bls.n	8008996 <HAL_RCC_OscConfig+0x3be>
 80089a8:	e693      	b.n	80086d2 <HAL_RCC_OscConfig+0xfa>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
 80089aa:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 80089ae:	f023 0301 	bic.w	r3, r3, #1
 80089b2:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80089b6:	f7fe fb29 	bl	800700c <HAL_GetTick>
 80089ba:	4607      	mov	r7, r0

      /* Wait till HSI48 is disabled */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 80089bc:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 80089c0:	0798      	lsls	r0, r3, #30
 80089c2:	d5da      	bpl.n	800897a <HAL_RCC_OscConfig+0x3a2>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 80089c4:	f7fe fb22 	bl	800700c <HAL_GetTick>
 80089c8:	1bc0      	subs	r0, r0, r7
 80089ca:	2802      	cmp	r0, #2
 80089cc:	d9f6      	bls.n	80089bc <HAL_RCC_OscConfig+0x3e4>
 80089ce:	e680      	b.n	80086d2 <HAL_RCC_OscConfig+0xfa>
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
  {
    /* PLL On ? */
    if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 80089d0:	2b02      	cmp	r3, #2
 80089d2:	f040 808f 	bne.w	8008af4 <HAL_RCC_OscConfig+0x51c>
#endif /* RCC_PLLP_SUPPORT */
      assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

      /* Do nothing if PLL configuration is the unchanged */
      pll_config = RCC->PLLCFGR;
 80089d6:	68e3      	ldr	r3, [r4, #12]
      if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 80089d8:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
#endif /* RCC_PLLP_SUPPORT */
      assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

      /* Do nothing if PLL configuration is the unchanged */
      pll_config = RCC->PLLCFGR;
 80089da:	4a59      	ldr	r2, [pc, #356]	; (8008b40 <HAL_RCC_OscConfig+0x568>)
      if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 80089dc:	f003 0003 	and.w	r0, r3, #3
 80089e0:	4288      	cmp	r0, r1
 80089e2:	d040      	beq.n	8008a66 <HAL_RCC_OscConfig+0x48e>
#endif
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)    != ((((RCC_OscInitStruct->PLL.PLLR) >> 1U) - 1U) << RCC_PLLCFGR_PLLR_Pos)))
      {
        /* Check if the PLL is used as system clock or not */
        if(sysclk_source != RCC_CFGR_SWS_PLL)
 80089e4:	2e0c      	cmp	r6, #12
 80089e6:	f000 80a6 	beq.w	8008b36 <HAL_RCC_OscConfig+0x55e>
        {
#if defined(RCC_PLLSAI1_SUPPORT) || defined(RCC_PLLSAI2_SUPPORT)
          /* Check if main PLL can be updated */
          /* Not possible if the source is shared by other enabled PLLSAIx */
          if((READ_BIT(RCC->CR, RCC_CR_PLLSAI1ON) != 0U)
 80089ea:	6822      	ldr	r2, [r4, #0]
 80089ec:	4b54      	ldr	r3, [pc, #336]	; (8008b40 <HAL_RCC_OscConfig+0x568>)
 80089ee:	0151      	lsls	r1, r2, #5
 80089f0:	f100 80a1 	bmi.w	8008b36 <HAL_RCC_OscConfig+0x55e>
#if defined(RCC_PLLSAI2_SUPPORT)
             || (READ_BIT(RCC->CR, RCC_CR_PLLSAI2ON) != 0U)
 80089f4:	681a      	ldr	r2, [r3, #0]
 80089f6:	00d2      	lsls	r2, r2, #3
 80089f8:	f100 809d 	bmi.w	8008b36 <HAL_RCC_OscConfig+0x55e>
          }
          else
#endif /* RCC_PLLSAI1_SUPPORT || RCC_PLLSAI2_SUPPORT */
          {
            /* Disable the main PLL. */
            __HAL_RCC_PLL_DISABLE();
 80089fc:	681a      	ldr	r2, [r3, #0]
 80089fe:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8008a02:	601a      	str	r2, [r3, #0]

            /* Get Start Tick*/
            tickstart = HAL_GetTick();
 8008a04:	f7fe fb02 	bl	800700c <HAL_GetTick>
 8008a08:	4606      	mov	r6, r0

            /* Wait till PLL is ready */
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8008a0a:	6823      	ldr	r3, [r4, #0]
 8008a0c:	484c      	ldr	r0, [pc, #304]	; (8008b40 <HAL_RCC_OscConfig+0x568>)
 8008a0e:	019f      	lsls	r7, r3, #6
 8008a10:	d44d      	bmi.n	8008aae <HAL_RCC_OscConfig+0x4d6>
                return HAL_TIMEOUT;
              }
            }

            /* Configure the main PLL clock source, multiplication and division factors. */
            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8008a12:	68c2      	ldr	r2, [r0, #12]
 8008a14:	4b4c      	ldr	r3, [pc, #304]	; (8008b48 <HAL_RCC_OscConfig+0x570>)
 8008a16:	6b69      	ldr	r1, [r5, #52]	; 0x34
 8008a18:	4013      	ands	r3, r2
 8008a1a:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8008a1e:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8008a20:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 8008a22:	430b      	orrs	r3, r1
 8008a24:	6ba9      	ldr	r1, [r5, #56]	; 0x38
 8008a26:	3a01      	subs	r2, #1
 8008a28:	ea43 63c1 	orr.w	r3, r3, r1, lsl #27
 8008a2c:	ea43 1102 	orr.w	r1, r3, r2, lsl #4
 8008a30:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8008a32:	085b      	lsrs	r3, r3, #1
 8008a34:	3b01      	subs	r3, #1
 8008a36:	ea41 5243 	orr.w	r2, r1, r3, lsl #21
 8008a3a:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 8008a3c:	085b      	lsrs	r3, r3, #1
 8008a3e:	3b01      	subs	r3, #1
 8008a40:	ea42 6343 	orr.w	r3, r2, r3, lsl #25
 8008a44:	60c3      	str	r3, [r0, #12]
#endif
                                 RCC_OscInitStruct->PLL.PLLQ,
                                 RCC_OscInitStruct->PLL.PLLR);

            /* Enable the main PLL. */
            __HAL_RCC_PLL_ENABLE();
 8008a46:	6803      	ldr	r3, [r0, #0]
 8008a48:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8008a4c:	6003      	str	r3, [r0, #0]

            /* Enable PLL System Clock output. */
            __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8008a4e:	68c3      	ldr	r3, [r0, #12]
 8008a50:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8008a54:	60c3      	str	r3, [r0, #12]

            /* Get Start Tick*/
            tickstart = HAL_GetTick();
 8008a56:	f7fe fad9 	bl	800700c <HAL_GetTick>
 8008a5a:	4605      	mov	r5, r0

            /* Wait till PLL is ready */
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8008a5c:	6823      	ldr	r3, [r4, #0]
 8008a5e:	0198      	lsls	r0, r3, #6
 8008a60:	d52b      	bpl.n	8008aba <HAL_RCC_OscConfig+0x4e2>
        /* PLL is already used as System core clock */
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
 8008a62:	2000      	movs	r0, #0
 8008a64:	e068      	b.n	8008b38 <HAL_RCC_OscConfig+0x560>
      assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

      /* Do nothing if PLL configuration is the unchanged */
      pll_config = RCC->PLLCFGR;
      if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 8008a66:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8008a68:	f003 01f0 	and.w	r1, r3, #240	; 0xf0
 8008a6c:	3801      	subs	r0, #1
 8008a6e:	ebb1 1f00 	cmp.w	r1, r0, lsl #4
 8008a72:	d1b7      	bne.n	80089e4 <HAL_RCC_OscConfig+0x40c>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8008a74:	6b68      	ldr	r0, [r5, #52]	; 0x34
 8008a76:	f403 41fe 	and.w	r1, r3, #32512	; 0x7f00
 8008a7a:	ebb1 2f00 	cmp.w	r1, r0, lsl #8
 8008a7e:	d1b1      	bne.n	80089e4 <HAL_RCC_OscConfig+0x40c>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 8008a80:	6ba8      	ldr	r0, [r5, #56]	; 0x38
 8008a82:	f003 4178 	and.w	r1, r3, #4160749568	; 0xf8000000
 8008a86:	ebb1 6fc0 	cmp.w	r1, r0, lsl #27
 8008a8a:	d1ab      	bne.n	80089e4 <HAL_RCC_OscConfig+0x40c>
#if defined(RCC_PLLP_SUPPORT)
#if defined(RCC_PLLP_DIV_2_31_SUPPORT)
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLPDIV) != (RCC_OscInitStruct->PLL.PLLP << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 8008a8c:	6be9      	ldr	r1, [r5, #60]	; 0x3c
 8008a8e:	0849      	lsrs	r1, r1, #1
 8008a90:	f403 00c0 	and.w	r0, r3, #6291456	; 0x600000
 8008a94:	3901      	subs	r1, #1
 8008a96:	ebb0 5f41 	cmp.w	r0, r1, lsl #21
 8008a9a:	d1a3      	bne.n	80089e4 <HAL_RCC_OscConfig+0x40c>
#else
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLP)    != ((RCC_OscInitStruct->PLL.PLLP == RCC_PLLP_DIV7) ? 0U : 1U)) ||
#endif
#endif
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8008a9c:	6c29      	ldr	r1, [r5, #64]	; 0x40
 8008a9e:	0849      	lsrs	r1, r1, #1
 8008aa0:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
 8008aa4:	3901      	subs	r1, #1
 8008aa6:	ebb3 6f41 	cmp.w	r3, r1, lsl #25
 8008aaa:	d19b      	bne.n	80089e4 <HAL_RCC_OscConfig+0x40c>
 8008aac:	e00b      	b.n	8008ac6 <HAL_RCC_OscConfig+0x4ee>
            tickstart = HAL_GetTick();

            /* Wait till PLL is ready */
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
            {
              if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8008aae:	f7fe faad 	bl	800700c <HAL_GetTick>
 8008ab2:	1b80      	subs	r0, r0, r6
 8008ab4:	2802      	cmp	r0, #2
 8008ab6:	d9a8      	bls.n	8008a0a <HAL_RCC_OscConfig+0x432>
 8008ab8:	e60b      	b.n	80086d2 <HAL_RCC_OscConfig+0xfa>
            tickstart = HAL_GetTick();

            /* Wait till PLL is ready */
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
            {
              if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8008aba:	f7fe faa7 	bl	800700c <HAL_GetTick>
 8008abe:	1b40      	subs	r0, r0, r5
 8008ac0:	2802      	cmp	r0, #2
 8008ac2:	d9cb      	bls.n	8008a5c <HAL_RCC_OscConfig+0x484>
 8008ac4:	e605      	b.n	80086d2 <HAL_RCC_OscConfig+0xfa>
      }
      else
      {
        /* PLL configuration is unchanged */
        /* Re-enable PLL if it was disabled (ie. low power mode) */
        if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8008ac6:	6813      	ldr	r3, [r2, #0]
 8008ac8:	0199      	lsls	r1, r3, #6
 8008aca:	d4ca      	bmi.n	8008a62 <HAL_RCC_OscConfig+0x48a>
        {
          /* Enable the main PLL. */
          __HAL_RCC_PLL_ENABLE();
 8008acc:	6813      	ldr	r3, [r2, #0]
 8008ace:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8008ad2:	6013      	str	r3, [r2, #0]

          /* Enable PLL System Clock output. */
          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8008ad4:	68d3      	ldr	r3, [r2, #12]
 8008ad6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8008ada:	60d3      	str	r3, [r2, #12]

          /* Get Start Tick*/
          tickstart = HAL_GetTick();
 8008adc:	f7fe fa96 	bl	800700c <HAL_GetTick>
 8008ae0:	4605      	mov	r5, r0

          /* Wait till PLL is ready */
          while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8008ae2:	6823      	ldr	r3, [r4, #0]
 8008ae4:	019a      	lsls	r2, r3, #6
 8008ae6:	d4bc      	bmi.n	8008a62 <HAL_RCC_OscConfig+0x48a>
          {
            if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8008ae8:	f7fe fa90 	bl	800700c <HAL_GetTick>
 8008aec:	1b40      	subs	r0, r0, r5
 8008aee:	2802      	cmp	r0, #2
 8008af0:	d9f7      	bls.n	8008ae2 <HAL_RCC_OscConfig+0x50a>
 8008af2:	e5ee      	b.n	80086d2 <HAL_RCC_OscConfig+0xfa>
      }
    }
    else
    {
      /* Check that PLL is not used as system clock or not */
      if(sysclk_source != RCC_CFGR_SWS_PLL)
 8008af4:	2e0c      	cmp	r6, #12
 8008af6:	d01e      	beq.n	8008b36 <HAL_RCC_OscConfig+0x55e>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8008af8:	6823      	ldr	r3, [r4, #0]
 8008afa:	4a11      	ldr	r2, [pc, #68]	; (8008b40 <HAL_RCC_OscConfig+0x568>)
 8008afc:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8008b00:	6023      	str	r3, [r4, #0]

        /* Disable all PLL outputs to save power if no PLLs on */
#if defined(RCC_PLLSAI1_SUPPORT) && defined(RCC_CR_PLLSAI2RDY)
        if(READ_BIT(RCC->CR, (RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY)) == 0U)
 8008b02:	6823      	ldr	r3, [r4, #0]
 8008b04:	f013 5f20 	tst.w	r3, #671088640	; 0x28000000
        {
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 8008b08:	bf02      	ittt	eq
 8008b0a:	68d3      	ldreq	r3, [r2, #12]
 8008b0c:	f023 0303 	biceq.w	r3, r3, #3
 8008b10:	60d3      	streq	r3, [r2, #12]
#else
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
#endif /* RCC_PLLSAI1_SUPPORT && RCC_CR_PLLSAI2RDY */

#if defined(RCC_PLLSAI2_SUPPORT)
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
 8008b12:	68e3      	ldr	r3, [r4, #12]
 8008b14:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 8008b18:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8008b1c:	60e3      	str	r3, [r4, #12]
#else
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK);
#endif /* RCC_PLLSAI2_SUPPORT */

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8008b1e:	f7fe fa75 	bl	800700c <HAL_GetTick>
 8008b22:	4605      	mov	r5, r0

        /* Wait till PLL is disabled */
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8008b24:	6823      	ldr	r3, [r4, #0]
 8008b26:	019b      	lsls	r3, r3, #6
 8008b28:	d59b      	bpl.n	8008a62 <HAL_RCC_OscConfig+0x48a>
        {
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8008b2a:	f7fe fa6f 	bl	800700c <HAL_GetTick>
 8008b2e:	1b40      	subs	r0, r0, r5
 8008b30:	2802      	cmp	r0, #2
 8008b32:	d9f7      	bls.n	8008b24 <HAL_RCC_OscConfig+0x54c>
 8008b34:	e5cd      	b.n	80086d2 <HAL_RCC_OscConfig+0xfa>
          }
        }
        else
        {
          /* PLL is already used as System core clock */
          return HAL_ERROR;
 8008b36:	2001      	movs	r0, #1
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
}
 8008b38:	b003      	add	sp, #12
 8008b3a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8008b3e:	bf00      	nop
 8008b40:	40021000 	.word	0x40021000
 8008b44:	40007000 	.word	0x40007000
 8008b48:	019d800c 	.word	0x019d800c

08008b4c <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8008b4c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8008b50:	460f      	mov	r7, r1
  uint32_t hpre = RCC_SYSCLK_DIV1;
#endif
  HAL_StatusTypeDef status;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 8008b52:	4605      	mov	r5, r0
 8008b54:	b910      	cbnz	r0, 8008b5c <HAL_RCC_ClockConfig+0x10>
  {
    return HAL_ERROR;
 8008b56:	2001      	movs	r0, #1
 8008b58:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8008b5c:	4a71      	ldr	r2, [pc, #452]	; (8008d24 <HAL_RCC_ClockConfig+0x1d8>)
 8008b5e:	6813      	ldr	r3, [r2, #0]
 8008b60:	f003 030f 	and.w	r3, r3, #15
 8008b64:	428b      	cmp	r3, r1
 8008b66:	d304      	bcc.n	8008b72 <HAL_RCC_ClockConfig+0x26>
      return HAL_ERROR;
    }
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8008b68:	6828      	ldr	r0, [r5, #0]
 8008b6a:	f010 0601 	ands.w	r6, r0, #1
 8008b6e:	d10b      	bne.n	8008b88 <HAL_RCC_ClockConfig+0x3c>
 8008b70:	e08d      	b.n	8008c8e <HAL_RCC_ClockConfig+0x142>

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8008b72:	6813      	ldr	r3, [r2, #0]
 8008b74:	f023 030f 	bic.w	r3, r3, #15
 8008b78:	430b      	orrs	r3, r1
 8008b7a:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8008b7c:	6813      	ldr	r3, [r2, #0]
 8008b7e:	f003 030f 	and.w	r3, r3, #15
 8008b82:	4299      	cmp	r1, r3
 8008b84:	d1e7      	bne.n	8008b56 <HAL_RCC_ClockConfig+0xa>
 8008b86:	e7ef      	b.n	8008b68 <HAL_RCC_ClockConfig+0x1c>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* PLL is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8008b88:	686b      	ldr	r3, [r5, #4]
 8008b8a:	4c67      	ldr	r4, [pc, #412]	; (8008d28 <HAL_RCC_ClockConfig+0x1dc>)
 8008b8c:	2b03      	cmp	r3, #3
 8008b8e:	d148      	bne.n	8008c22 <HAL_RCC_ClockConfig+0xd6>
    {
      /* Check the PLL ready flag */
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8008b90:	6823      	ldr	r3, [r4, #0]
 8008b92:	019b      	lsls	r3, r3, #6
 8008b94:	d5df      	bpl.n	8008b56 <HAL_RCC_ClockConfig+0xa>
static uint32_t RCC_GetSysClockFreqFromPLLSource(void)
{
  uint32_t msirange = 0U;
  uint32_t pllvco, pllsource, pllr, pllm, sysclockfreq;  /* no init needed */

  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)
 8008b96:	68e3      	ldr	r3, [r4, #12]
 8008b98:	f003 0303 	and.w	r3, r3, #3
 8008b9c:	2b01      	cmp	r3, #1
 8008b9e:	d10d      	bne.n	8008bbc <HAL_RCC_ClockConfig+0x70>
  {
    /* Get MSI range source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 8008ba0:	6823      	ldr	r3, [r4, #0]
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 8008ba2:	4a62      	ldr	r2, [pc, #392]	; (8008d2c <HAL_RCC_ClockConfig+0x1e0>)
  uint32_t pllvco, pllsource, pllr, pllm, sysclockfreq;  /* no init needed */

  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)
  {
    /* Get MSI range source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 8008ba4:	071e      	lsls	r6, r3, #28
    { /* MSISRANGE from RCC_CSR applies */
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8008ba6:	bf55      	itete	pl
 8008ba8:	f8d4 3094 	ldrpl.w	r3, [r4, #148]	; 0x94
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8008bac:	6823      	ldrmi	r3, [r4, #0]
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)
  {
    /* Get MSI range source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
    { /* MSISRANGE from RCC_CSR applies */
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8008bae:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
    }
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8008bb2:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 8008bb6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8008bba:	e000      	b.n	8008bbe <HAL_RCC_ClockConfig+0x72>
  * @brief  Compute SYSCLK frequency based on PLL SYSCLK source.
  * @retval SYSCLK frequency
  */
static uint32_t RCC_GetSysClockFreqFromPLLSource(void)
{
  uint32_t msirange = 0U;
 8008bbc:	2300      	movs	r3, #0
  }

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE) * PLLN / PLLM
     SYSCLK = PLL_VCO / PLLR
   */
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8008bbe:	68e2      	ldr	r2, [r4, #12]

  switch (pllsource)
 8008bc0:	f002 0203 	and.w	r2, r2, #3
 8008bc4:	2a02      	cmp	r2, #2
 8008bc6:	d004      	beq.n	8008bd2 <HAL_RCC_ClockConfig+0x86>
  case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
    pllvco = HSI_VALUE;
    break;

  case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
    pllvco = HSE_VALUE;
 8008bc8:	4959      	ldr	r1, [pc, #356]	; (8008d30 <HAL_RCC_ClockConfig+0x1e4>)
 8008bca:	2a03      	cmp	r2, #3
 8008bcc:	bf08      	it	eq
 8008bce:	460b      	moveq	r3, r1
 8008bd0:	e000      	b.n	8008bd4 <HAL_RCC_ClockConfig+0x88>
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);

  switch (pllsource)
  {
  case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
    pllvco = HSI_VALUE;
 8008bd2:	4b58      	ldr	r3, [pc, #352]	; (8008d34 <HAL_RCC_ClockConfig+0x1e8>)
  case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
  default:
    pllvco = msirange;
    break;
  }
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8008bd4:	68e2      	ldr	r2, [r4, #12]
  pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 8008bd6:	68e1      	ldr	r1, [r4, #12]
  case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
  default:
    pllvco = msirange;
    break;
  }
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8008bd8:	4e53      	ldr	r6, [pc, #332]	; (8008d28 <HAL_RCC_ClockConfig+0x1dc>)
  pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 8008bda:	f3c1 2106 	ubfx	r1, r1, #8, #7
 8008bde:	434b      	muls	r3, r1
  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8008be0:	68e1      	ldr	r1, [r4, #12]
      }
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
    defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
      /* Undershoot management when selection PLL as SYSCLK source and frequency above 80Mhz */
      /* Compute target PLL output frequency */
      if(RCC_GetSysClockFreqFromPLLSource() > 80000000U)
 8008be2:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8008be6:	3201      	adds	r2, #1
 8008be8:	fbb3 f2f2 	udiv	r2, r3, r2
 8008bec:	f3c1 6341 	ubfx	r3, r1, #25, #2
 8008bf0:	3301      	adds	r3, #1
 8008bf2:	005b      	lsls	r3, r3, #1
 8008bf4:	fbb2 f3f3 	udiv	r3, r2, r3
 8008bf8:	4a4f      	ldr	r2, [pc, #316]	; (8008d38 <HAL_RCC_ClockConfig+0x1ec>)
 8008bfa:	4293      	cmp	r3, r2
 8008bfc:	d801      	bhi.n	8008c02 <HAL_RCC_ClockConfig+0xb6>
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
  uint32_t tickstart;
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
    defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  uint32_t hpre = RCC_SYSCLK_DIV1;
 8008bfe:	2600      	movs	r6, #0
 8008c00:	e02a      	b.n	8008c58 <HAL_RCC_ClockConfig+0x10c>
    defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
      /* Undershoot management when selection PLL as SYSCLK source and frequency above 80Mhz */
      /* Compute target PLL output frequency */
      if(RCC_GetSysClockFreqFromPLLSource() > 80000000U)
      {
        if(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)
 8008c02:	68b3      	ldr	r3, [r6, #8]
 8008c04:	f013 0ff0 	tst.w	r3, #240	; 0xf0
 8008c08:	d004      	beq.n	8008c14 <HAL_RCC_ClockConfig+0xc8>
        {
          /* Intermediate step with HCLK prescaler 2 necessary before to go over 80Mhz */
          MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
          hpre = RCC_SYSCLK_DIV2;
        }
        else if((((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK) && (RCC_ClkInitStruct->AHBCLKDivider == RCC_SYSCLK_DIV1))
 8008c0a:	0781      	lsls	r1, r0, #30
 8008c0c:	d5f7      	bpl.n	8008bfe <HAL_RCC_ClockConfig+0xb2>
 8008c0e:	68ab      	ldr	r3, [r5, #8]
 8008c10:	2b00      	cmp	r3, #0
 8008c12:	d1f4      	bne.n	8008bfe <HAL_RCC_ClockConfig+0xb2>
        {
          /* Intermediate step with HCLK prescaler 2 necessary before to go over 80Mhz */
          MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 8008c14:	68b3      	ldr	r3, [r6, #8]
 8008c16:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8008c1a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8008c1e:	60b3      	str	r3, [r6, #8]
 8008c20:	e019      	b.n	8008c56 <HAL_RCC_ClockConfig+0x10a>
#endif
    }
    else
    {
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8008c22:	2b02      	cmp	r3, #2
 8008c24:	d103      	bne.n	8008c2e <HAL_RCC_ClockConfig+0xe2>
      {
        /* Check the HSE ready flag */
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8008c26:	6823      	ldr	r3, [r4, #0]
 8008c28:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8008c2c:	e007      	b.n	8008c3e <HAL_RCC_ClockConfig+0xf2>
        {
          return HAL_ERROR;
        }
      }
      /* MSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8008c2e:	b91b      	cbnz	r3, 8008c38 <HAL_RCC_ClockConfig+0xec>
      {
        /* Check the MSI ready flag */
        if(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8008c30:	6823      	ldr	r3, [r4, #0]
 8008c32:	f013 0f02 	tst.w	r3, #2
 8008c36:	e002      	b.n	8008c3e <HAL_RCC_ClockConfig+0xf2>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8008c38:	6823      	ldr	r3, [r4, #0]
 8008c3a:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8008c3e:	d08a      	beq.n	8008b56 <HAL_RCC_ClockConfig+0xa>
        }
      }
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
    defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
      /* Overshoot management when going down from PLL as SYSCLK source and frequency above 80Mhz */
      if(HAL_RCC_GetSysClockFreq() > 80000000U)
 8008c40:	f7ff fc78 	bl	8008534 <HAL_RCC_GetSysClockFreq>
 8008c44:	4b3c      	ldr	r3, [pc, #240]	; (8008d38 <HAL_RCC_ClockConfig+0x1ec>)
 8008c46:	4298      	cmp	r0, r3
 8008c48:	d9d9      	bls.n	8008bfe <HAL_RCC_ClockConfig+0xb2>
      {
        /* Intermediate step with HCLK prescaler 2 necessary before to go under 80Mhz */
        MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 8008c4a:	68a3      	ldr	r3, [r4, #8]
 8008c4c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8008c50:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8008c54:	60a3      	str	r3, [r4, #8]
        hpre = RCC_SYSCLK_DIV2;
 8008c56:	2680      	movs	r6, #128	; 0x80
      }
#endif

    }

    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8008c58:	68a3      	ldr	r3, [r4, #8]
 8008c5a:	f023 0203 	bic.w	r2, r3, #3
 8008c5e:	686b      	ldr	r3, [r5, #4]
 8008c60:	4313      	orrs	r3, r2
 8008c62:	60a3      	str	r3, [r4, #8]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8008c64:	f7fe f9d2 	bl	800700c <HAL_GetTick>

    while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
    {
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8008c68:	f241 3988 	movw	r9, #5000	; 0x1388
    }

    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8008c6c:	4680      	mov	r8, r0

    while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8008c6e:	68a3      	ldr	r3, [r4, #8]
 8008c70:	686a      	ldr	r2, [r5, #4]
 8008c72:	f003 030c 	and.w	r3, r3, #12
 8008c76:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8008c7a:	d008      	beq.n	8008c8e <HAL_RCC_ClockConfig+0x142>
    {
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8008c7c:	f7fe f9c6 	bl	800700c <HAL_GetTick>
 8008c80:	ebc8 0000 	rsb	r0, r8, r0
 8008c84:	4548      	cmp	r0, r9
 8008c86:	d9f2      	bls.n	8008c6e <HAL_RCC_ClockConfig+0x122>
      {
        return HAL_TIMEOUT;
 8008c88:	2003      	movs	r0, #3

  /* Configure the source of time base considering new system clocks settings*/
  status = HAL_InitTick(uwTickPrio);

  return status;
}
 8008c8a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      }
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8008c8e:	6829      	ldr	r1, [r5, #0]
 8008c90:	078a      	lsls	r2, r1, #30
 8008c92:	d507      	bpl.n	8008ca4 <HAL_RCC_ClockConfig+0x158>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8008c94:	4824      	ldr	r0, [pc, #144]	; (8008d28 <HAL_RCC_ClockConfig+0x1dc>)
 8008c96:	6883      	ldr	r3, [r0, #8]
 8008c98:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8008c9c:	68ab      	ldr	r3, [r5, #8]
 8008c9e:	4313      	orrs	r3, r2
 8008ca0:	6083      	str	r3, [r0, #8]
 8008ca2:	e006      	b.n	8008cb2 <HAL_RCC_ClockConfig+0x166>
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || \
    defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  else
  {
    /* Is intermediate HCLK prescaler 2 applied internally, complete with HCLK prescaler 1 */
    if(hpre == RCC_SYSCLK_DIV2)
 8008ca4:	2e80      	cmp	r6, #128	; 0x80
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
 8008ca6:	bf01      	itttt	eq
 8008ca8:	4a1f      	ldreq	r2, [pc, #124]	; (8008d28 <HAL_RCC_ClockConfig+0x1dc>)
 8008caa:	6893      	ldreq	r3, [r2, #8]
 8008cac:	f023 03f0 	biceq.w	r3, r3, #240	; 0xf0
 8008cb0:	6093      	streq	r3, [r2, #8]
    }
  }
#endif

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8008cb2:	4a1c      	ldr	r2, [pc, #112]	; (8008d24 <HAL_RCC_ClockConfig+0x1d8>)
 8008cb4:	6813      	ldr	r3, [r2, #0]
 8008cb6:	f003 030f 	and.w	r3, r3, #15
 8008cba:	429f      	cmp	r7, r3
 8008cbc:	d30a      	bcc.n	8008cd4 <HAL_RCC_ClockConfig+0x188>
      return HAL_ERROR;
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8008cbe:	f011 0f04 	tst.w	r1, #4
 8008cc2:	4c19      	ldr	r4, [pc, #100]	; (8008d28 <HAL_RCC_ClockConfig+0x1dc>)
 8008cc4:	d012      	beq.n	8008cec <HAL_RCC_ClockConfig+0x1a0>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8008cc6:	68a3      	ldr	r3, [r4, #8]
 8008cc8:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 8008ccc:	68eb      	ldr	r3, [r5, #12]
 8008cce:	4313      	orrs	r3, r2
 8008cd0:	60a3      	str	r3, [r4, #8]
 8008cd2:	e00b      	b.n	8008cec <HAL_RCC_ClockConfig+0x1a0>

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8008cd4:	6813      	ldr	r3, [r2, #0]
 8008cd6:	f023 030f 	bic.w	r3, r3, #15
 8008cda:	433b      	orrs	r3, r7
 8008cdc:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8008cde:	6813      	ldr	r3, [r2, #0]
 8008ce0:	f003 030f 	and.w	r3, r3, #15
 8008ce4:	429f      	cmp	r7, r3
 8008ce6:	f47f af36 	bne.w	8008b56 <HAL_RCC_ClockConfig+0xa>
 8008cea:	e7e8      	b.n	8008cbe <HAL_RCC_ClockConfig+0x172>
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8008cec:	070b      	lsls	r3, r1, #28
 8008cee:	d506      	bpl.n	8008cfe <HAL_RCC_ClockConfig+0x1b2>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8008cf0:	68a3      	ldr	r3, [r4, #8]
 8008cf2:	692a      	ldr	r2, [r5, #16]
 8008cf4:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8008cf8:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 8008cfc:	60a3      	str	r3, [r4, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8008cfe:	f7ff fc19 	bl	8008534 <HAL_RCC_GetSysClockFreq>
 8008d02:	68a3      	ldr	r3, [r4, #8]
 8008d04:	4a0d      	ldr	r2, [pc, #52]	; (8008d3c <HAL_RCC_ClockConfig+0x1f0>)
 8008d06:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8008d0a:	5cd3      	ldrb	r3, [r2, r3]
 8008d0c:	f003 031f 	and.w	r3, r3, #31
 8008d10:	40d8      	lsrs	r0, r3
 8008d12:	4b0b      	ldr	r3, [pc, #44]	; (8008d40 <HAL_RCC_ClockConfig+0x1f4>)
 8008d14:	6018      	str	r0, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  status = HAL_InitTick(uwTickPrio);
 8008d16:	4b0b      	ldr	r3, [pc, #44]	; (8008d44 <HAL_RCC_ClockConfig+0x1f8>)
 8008d18:	6818      	ldr	r0, [r3, #0]

  return status;
}
 8008d1a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);

  /* Configure the source of time base considering new system clocks settings*/
  status = HAL_InitTick(uwTickPrio);
 8008d1e:	f7fe b977 	b.w	8007010 <HAL_InitTick>
 8008d22:	bf00      	nop
 8008d24:	40022000 	.word	0x40022000
 8008d28:	40021000 	.word	0x40021000
 8008d2c:	0800e738 	.word	0x0800e738
 8008d30:	007a1200 	.word	0x007a1200
 8008d34:	00f42400 	.word	0x00f42400
 8008d38:	04c4b400 	.word	0x04c4b400
 8008d3c:	0800e720 	.word	0x0800e720
 8008d40:	20000448 	.word	0x20000448
 8008d44:	20000238 	.word	0x20000238

08008d48 <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 8008d48:	4b01      	ldr	r3, [pc, #4]	; (8008d50 <HAL_RCC_GetHCLKFreq+0x8>)
 8008d4a:	6818      	ldr	r0, [r3, #0]
 8008d4c:	4770      	bx	lr
 8008d4e:	bf00      	nop
 8008d50:	20000448 	.word	0x20000448

08008d54 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 8008d54:	4b05      	ldr	r3, [pc, #20]	; (8008d6c <HAL_RCC_GetPCLK1Freq+0x18>)
 8008d56:	4a06      	ldr	r2, [pc, #24]	; (8008d70 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8008d58:	689b      	ldr	r3, [r3, #8]
 8008d5a:	f3c3 2302 	ubfx	r3, r3, #8, #3
 8008d5e:	5cd3      	ldrb	r3, [r2, r3]
 8008d60:	4a04      	ldr	r2, [pc, #16]	; (8008d74 <HAL_RCC_GetPCLK1Freq+0x20>)
 8008d62:	6810      	ldr	r0, [r2, #0]
 8008d64:	f003 031f 	and.w	r3, r3, #31
}
 8008d68:	40d8      	lsrs	r0, r3
 8008d6a:	4770      	bx	lr
 8008d6c:	40021000 	.word	0x40021000
 8008d70:	0800e730 	.word	0x0800e730
 8008d74:	20000448 	.word	0x20000448

08008d78 <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 8008d78:	4b05      	ldr	r3, [pc, #20]	; (8008d90 <HAL_RCC_GetPCLK2Freq+0x18>)
 8008d7a:	4a06      	ldr	r2, [pc, #24]	; (8008d94 <HAL_RCC_GetPCLK2Freq+0x1c>)
 8008d7c:	689b      	ldr	r3, [r3, #8]
 8008d7e:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 8008d82:	5cd3      	ldrb	r3, [r2, r3]
 8008d84:	4a04      	ldr	r2, [pc, #16]	; (8008d98 <HAL_RCC_GetPCLK2Freq+0x20>)
 8008d86:	6810      	ldr	r0, [r2, #0]
 8008d88:	f003 031f 	and.w	r3, r3, #31
}
 8008d8c:	40d8      	lsrs	r0, r3
 8008d8e:	4770      	bx	lr
 8008d90:	40021000 	.word	0x40021000
 8008d94:	0800e730 	.word	0x0800e730
 8008d98:	20000448 	.word	0x20000448

08008d9c <HAL_RCC_GetOscConfig>:
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != (void *)NULL);

  /* Set all possible values for the Oscillator type parameter ---------------*/
#if defined(RCC_HSI48_SUPPORT)
  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_MSI | \
 8008d9c:	233f      	movs	r3, #63	; 0x3f
 8008d9e:	6003      	str	r3, [r0, #0]
  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_MSI | \
                                      RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;
#endif /* RCC_HSI48_SUPPORT */

  /* Get the HSE configuration -----------------------------------------------*/
  if(READ_BIT(RCC->CR, RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
 8008da0:	4b32      	ldr	r3, [pc, #200]	; (8008e6c <HAL_RCC_GetOscConfig+0xd0>)
 8008da2:	681a      	ldr	r2, [r3, #0]
 8008da4:	0352      	lsls	r2, r2, #13
 8008da6:	d502      	bpl.n	8008dae <HAL_RCC_GetOscConfig+0x12>
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
 8008da8:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
 8008dac:	e005      	b.n	8008dba <HAL_RCC_GetOscConfig+0x1e>
  }
  else if(READ_BIT(RCC->CR, RCC_CR_HSEON) == RCC_CR_HSEON)
 8008dae:	681a      	ldr	r2, [r3, #0]
 8008db0:	f412 3280 	ands.w	r2, r2, #65536	; 0x10000
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_ON;
 8008db4:	bf18      	it	ne
 8008db6:	f44f 3280 	movne.w	r2, #65536	; 0x10000
  }
  else
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
 8008dba:	6042      	str	r2, [r0, #4]
  }

   /* Get the MSI configuration -----------------------------------------------*/
  if(READ_BIT(RCC->CR, RCC_CR_MSION) == RCC_CR_MSION)
 8008dbc:	681a      	ldr	r2, [r3, #0]
 8008dbe:	f012 0201 	ands.w	r2, r2, #1
  {
    RCC_OscInitStruct->MSIState = RCC_MSI_ON;
 8008dc2:	bf18      	it	ne
 8008dc4:	2201      	movne	r2, #1
  }
  else
  {
    RCC_OscInitStruct->MSIState = RCC_MSI_OFF;
 8008dc6:	6182      	str	r2, [r0, #24]
  }

  RCC_OscInitStruct->MSICalibrationValue = READ_BIT(RCC->ICSCR, RCC_ICSCR_MSITRIM) >> RCC_ICSCR_MSITRIM_Pos;
 8008dc8:	685a      	ldr	r2, [r3, #4]
 8008dca:	f3c2 2207 	ubfx	r2, r2, #8, #8
 8008dce:	61c2      	str	r2, [r0, #28]
  RCC_OscInitStruct->MSIClockRange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE);
 8008dd0:	681a      	ldr	r2, [r3, #0]
 8008dd2:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8008dd6:	6202      	str	r2, [r0, #32]

  /* Get the HSI configuration -----------------------------------------------*/
  if(READ_BIT(RCC->CR, RCC_CR_HSION) == RCC_CR_HSION)
 8008dd8:	681a      	ldr	r2, [r3, #0]
 8008dda:	f412 7280 	ands.w	r2, r2, #256	; 0x100
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_ON;
 8008dde:	bf18      	it	ne
 8008de0:	f44f 7280 	movne.w	r2, #256	; 0x100
  }
  else
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
 8008de4:	60c2      	str	r2, [r0, #12]
  }

  RCC_OscInitStruct->HSICalibrationValue = READ_BIT(RCC->ICSCR, RCC_ICSCR_HSITRIM) >> RCC_ICSCR_HSITRIM_Pos;
 8008de6:	685a      	ldr	r2, [r3, #4]
 8008de8:	f3c2 6206 	ubfx	r2, r2, #24, #7
 8008dec:	6102      	str	r2, [r0, #16]

  /* Get the LSE configuration -----------------------------------------------*/
  if(READ_BIT(RCC->BDCR, RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
 8008dee:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8008df2:	0751      	lsls	r1, r2, #29
 8008df4:	d501      	bpl.n	8008dfa <HAL_RCC_GetOscConfig+0x5e>
      RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS_RTC_ONLY;
    }
    else
#endif /* RCC_BDCR_LSESYSDIS */
    {
      RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
 8008df6:	2205      	movs	r2, #5
 8008df8:	e006      	b.n	8008e08 <HAL_RCC_GetOscConfig+0x6c>
    }
  }
  else if(READ_BIT(RCC->BDCR, RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
 8008dfa:	4a1c      	ldr	r2, [pc, #112]	; (8008e6c <HAL_RCC_GetOscConfig+0xd0>)
 8008dfc:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 8008e00:	f012 0201 	ands.w	r2, r2, #1
      RCC_OscInitStruct->LSEState = RCC_LSE_ON_RTC_ONLY;
    }
    else
#endif /* RCC_BDCR_LSESYSDIS */
    {
      RCC_OscInitStruct->LSEState = RCC_LSE_ON;
 8008e04:	bf18      	it	ne
 8008e06:	2201      	movne	r2, #1
    }
  }
  else
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
 8008e08:	6082      	str	r2, [r0, #8]
  }

  /* Get the LSI configuration -----------------------------------------------*/
  if(READ_BIT(RCC->CSR, RCC_CSR_LSION) == RCC_CSR_LSION)
 8008e0a:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8008e0e:	f012 0201 	ands.w	r2, r2, #1
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_ON;
 8008e12:	bf18      	it	ne
 8008e14:	2201      	movne	r2, #1
  }
  else
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
 8008e16:	6142      	str	r2, [r0, #20]
  }
#endif /* RCC_CSR_LSIPREDIV */

#if defined(RCC_HSI48_SUPPORT)
  /* Get the HSI48 configuration ---------------------------------------------*/
  if(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48ON) == RCC_CRRCR_HSI48ON)
 8008e18:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 8008e1c:	f012 0201 	ands.w	r2, r2, #1
  {
    RCC_OscInitStruct->HSI48State = RCC_HSI48_ON;
 8008e20:	bf18      	it	ne
 8008e22:	2201      	movne	r2, #1
  }
  else
  {
    RCC_OscInitStruct->HSI48State = RCC_HSI48_OFF;
 8008e24:	6242      	str	r2, [r0, #36]	; 0x24
#else
  RCC_OscInitStruct->HSI48State = RCC_HSI48_OFF;
#endif /* RCC_HSI48_SUPPORT */

  /* Get the PLL configuration -----------------------------------------------*/
  if(READ_BIT(RCC->CR, RCC_CR_PLLON) == RCC_CR_PLLON)
 8008e26:	681a      	ldr	r2, [r3, #0]
 8008e28:	01d2      	lsls	r2, r2, #7
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
 8008e2a:	bf4c      	ite	mi
 8008e2c:	2202      	movmi	r2, #2
  }
  else
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
 8008e2e:	2201      	movpl	r2, #1
 8008e30:	6282      	str	r2, [r0, #40]	; 0x28
  }
  RCC_OscInitStruct->PLL.PLLSource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8008e32:	68da      	ldr	r2, [r3, #12]
 8008e34:	f002 0203 	and.w	r2, r2, #3
 8008e38:	62c2      	str	r2, [r0, #44]	; 0x2c
  RCC_OscInitStruct->PLL.PLLM = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U;
 8008e3a:	68da      	ldr	r2, [r3, #12]
 8008e3c:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8008e40:	3201      	adds	r2, #1
 8008e42:	6302      	str	r2, [r0, #48]	; 0x30
  RCC_OscInitStruct->PLL.PLLN = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
 8008e44:	68da      	ldr	r2, [r3, #12]
 8008e46:	f3c2 2206 	ubfx	r2, r2, #8, #7
 8008e4a:	6342      	str	r2, [r0, #52]	; 0x34
  RCC_OscInitStruct->PLL.PLLQ = (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U);
 8008e4c:	68da      	ldr	r2, [r3, #12]
 8008e4e:	f3c2 5241 	ubfx	r2, r2, #21, #2
 8008e52:	3201      	adds	r2, #1
 8008e54:	0052      	lsls	r2, r2, #1
 8008e56:	63c2      	str	r2, [r0, #60]	; 0x3c
  RCC_OscInitStruct->PLL.PLLR = (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) << 1U);
 8008e58:	68da      	ldr	r2, [r3, #12]
 8008e5a:	f3c2 6241 	ubfx	r2, r2, #25, #2
 8008e5e:	3201      	adds	r2, #1
 8008e60:	0052      	lsls	r2, r2, #1
 8008e62:	6402      	str	r2, [r0, #64]	; 0x40
#if defined(RCC_PLLP_SUPPORT)
#if defined(RCC_PLLP_DIV_2_31_SUPPORT)
  RCC_OscInitStruct->PLL.PLLP = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLPDIV) >> RCC_PLLCFGR_PLLPDIV_Pos;
 8008e64:	68db      	ldr	r3, [r3, #12]
 8008e66:	0edb      	lsrs	r3, r3, #27
 8008e68:	6383      	str	r3, [r0, #56]	; 0x38
 8008e6a:	4770      	bx	lr
 8008e6c:	40021000 	.word	0x40021000

08008e70 <HAL_RCC_GetClockConfig>:
  /* Check the parameters */
  assert_param(RCC_ClkInitStruct != (void  *)NULL);
  assert_param(pFLatency != (void *)NULL);

  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 8008e70:	230f      	movs	r3, #15
 8008e72:	6003      	str	r3, [r0, #0]

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = READ_BIT(RCC->CFGR, RCC_CFGR_SW);
 8008e74:	4b0b      	ldr	r3, [pc, #44]	; (8008ea4 <HAL_RCC_GetClockConfig+0x34>)
 8008e76:	689a      	ldr	r2, [r3, #8]
 8008e78:	f002 0203 	and.w	r2, r2, #3
 8008e7c:	6042      	str	r2, [r0, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = READ_BIT(RCC->CFGR, RCC_CFGR_HPRE);
 8008e7e:	689a      	ldr	r2, [r3, #8]
 8008e80:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8008e84:	6082      	str	r2, [r0, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1);
 8008e86:	689a      	ldr	r2, [r3, #8]
 8008e88:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8008e8c:	60c2      	str	r2, [r0, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> 3U);
 8008e8e:	689b      	ldr	r3, [r3, #8]
 8008e90:	08db      	lsrs	r3, r3, #3
 8008e92:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8008e96:	6103      	str	r3, [r0, #16]

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = __HAL_FLASH_GET_LATENCY();
 8008e98:	4b03      	ldr	r3, [pc, #12]	; (8008ea8 <HAL_RCC_GetClockConfig+0x38>)
 8008e9a:	681b      	ldr	r3, [r3, #0]
 8008e9c:	f003 030f 	and.w	r3, r3, #15
 8008ea0:	600b      	str	r3, [r1, #0]
 8008ea2:	4770      	bx	lr
 8008ea4:	40021000 	.word	0x40021000
 8008ea8:	40022000 	.word	0x40022000

08008eac <HAL_RCC_EnableCSS>:
  * @note   The Clock Security System can only be cleared by reset.
  * @retval None
  */
void HAL_RCC_EnableCSS(void)
{
  SET_BIT(RCC->CR, RCC_CR_CSSON) ;
 8008eac:	4a02      	ldr	r2, [pc, #8]	; (8008eb8 <HAL_RCC_EnableCSS+0xc>)
 8008eae:	6813      	ldr	r3, [r2, #0]
 8008eb0:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8008eb4:	6013      	str	r3, [r2, #0]
 8008eb6:	4770      	bx	lr
 8008eb8:	40021000 	.word	0x40021000

08008ebc <HAL_RCC_CSSCallback>:
/**
  * @brief  RCC Clock Security System interrupt callback.
  * @retval none
  */
__weak void HAL_RCC_CSSCallback(void)
{
 8008ebc:	4770      	bx	lr
	...

08008ec0 <HAL_RCC_NMI_IRQHandler>:
  * @brief Handle the RCC Clock Security System interrupt request.
  * @note This API should be called under the NMI_Handler().
  * @retval None
  */
void HAL_RCC_NMI_IRQHandler(void)
{
 8008ec0:	b510      	push	{r4, lr}
  /* Check RCC CSSF interrupt flag  */
  if(__HAL_RCC_GET_IT(RCC_IT_CSS))
 8008ec2:	4c05      	ldr	r4, [pc, #20]	; (8008ed8 <HAL_RCC_NMI_IRQHandler+0x18>)
 8008ec4:	69e3      	ldr	r3, [r4, #28]
 8008ec6:	05db      	lsls	r3, r3, #23
 8008ec8:	d504      	bpl.n	8008ed4 <HAL_RCC_NMI_IRQHandler+0x14>
  {
    /* RCC Clock Security System interrupt user callback */
    HAL_RCC_CSSCallback();
 8008eca:	f7ff fff7 	bl	8008ebc <HAL_RCC_CSSCallback>

    /* Clear RCC CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
 8008ece:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008ed2:	6223      	str	r3, [r4, #32]
 8008ed4:	bd10      	pop	{r4, pc}
 8008ed6:	bf00      	nop
 8008ed8:	40021000 	.word	0x40021000

08008edc <RCCEx_GetSAIxPeriphCLKFreq>:
#if defined(RCC_PLLP_SUPPORT)
  uint32_t pllp = 0U;
#endif /* RCC_PLLP_SUPPORT */

  /* Handle SAIs */
  if(PeriphClk == RCC_PERIPHCLK_SAI1)
 8008edc:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
#endif /* RCC_PLLSAI2_SUPPORT */

#if defined(SAI1)

static uint32_t RCCEx_GetSAIxPeriphCLKFreq(uint32_t PeriphClk, uint32_t InputFrequency)
{
 8008ee0:	b510      	push	{r4, lr}
 8008ee2:	4a3e      	ldr	r2, [pc, #248]	; (8008fdc <RCCEx_GetSAIxPeriphCLKFreq+0x100>)
#if defined(RCC_PLLP_SUPPORT)
  uint32_t pllp = 0U;
#endif /* RCC_PLLP_SUPPORT */

  /* Handle SAIs */
  if(PeriphClk == RCC_PERIPHCLK_SAI1)
 8008ee4:	d106      	bne.n	8008ef4 <RCCEx_GetSAIxPeriphCLKFreq+0x18>
  {
    srcclk = __HAL_RCC_GET_SAI1_SOURCE();
 8008ee6:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 8008eea:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
    if(srcclk == RCC_SAI1CLKSOURCE_PIN)
 8008eee:	2b60      	cmp	r3, #96	; 0x60
 8008ef0:	d171      	bne.n	8008fd6 <RCCEx_GetSAIxPeriphCLKFreq+0xfa>
 8008ef2:	e06b      	b.n	8008fcc <RCCEx_GetSAIxPeriphCLKFreq+0xf0>
    /* Else, PLL clock output to check below */
  }
#if defined(SAI2)
  else
  {
    if(PeriphClk == RCC_PERIPHCLK_SAI2)
 8008ef4:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
 8008ef8:	d121      	bne.n	8008f3e <RCCEx_GetSAIxPeriphCLKFreq+0x62>
    {
      srcclk = __HAL_RCC_GET_SAI2_SOURCE();
 8008efa:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 8008efe:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
      if(srcclk == RCC_SAI2CLKSOURCE_PIN)
 8008f02:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8008f06:	d061      	beq.n	8008fcc <RCCEx_GetSAIxPeriphCLKFreq+0xf0>
  if(frequency == 0U)
  {
    pllvco = InputFrequency;

#if defined(SAI2)
    if((srcclk == RCC_SAI1CLKSOURCE_PLL) || (srcclk == RCC_SAI2CLKSOURCE_PLL))
 8008f08:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8008f0c:	d116      	bne.n	8008f3c <RCCEx_GetSAIxPeriphCLKFreq+0x60>
    {
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY) && (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL_SAI3CLK) != 0U))
 8008f0e:	6810      	ldr	r0, [r2, #0]
 8008f10:	4c32      	ldr	r4, [pc, #200]	; (8008fdc <RCCEx_GetSAIxPeriphCLKFreq+0x100>)
 8008f12:	f010 7000 	ands.w	r0, r0, #33554432	; 0x2000000
 8008f16:	d060      	beq.n	8008fda <RCCEx_GetSAIxPeriphCLKFreq+0xfe>
 8008f18:	68e0      	ldr	r0, [r4, #12]
 8008f1a:	f410 3080 	ands.w	r0, r0, #65536	; 0x10000
 8008f1e:	d05c      	beq.n	8008fda <RCCEx_GetSAIxPeriphCLKFreq+0xfe>
      {
        /* f(PLL Source) / PLLM */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 8008f20:	68e0      	ldr	r0, [r4, #12]
        /* f(PLLSAI3CLK) = f(VCO input) * PLLN / PLLP */
        plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
 8008f22:	68e3      	ldr	r3, [r4, #12]
    if((srcclk == RCC_SAI1CLKSOURCE_PLL) || (srcclk == RCC_SAI2CLKSOURCE_PLL))
    {
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY) && (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL_SAI3CLK) != 0U))
      {
        /* f(PLL Source) / PLLM */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 8008f24:	f3c0 1003 	ubfx	r0, r0, #4, #4
 8008f28:	3001      	adds	r0, #1
 8008f2a:	fbb1 f1f0 	udiv	r1, r1, r0
        /* f(PLLSAI3CLK) = f(VCO input) * PLLN / PLLP */
        plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
#if defined(RCC_PLLP_DIV_2_31_SUPPORT)
        pllp = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLPDIV) >> RCC_PLLCFGR_PLLPDIV_Pos;
 8008f2e:	68e0      	ldr	r0, [r4, #12]
#endif
        if(pllp == 0U)
 8008f30:	0ec0      	lsrs	r0, r0, #27
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY) && (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL_SAI3CLK) != 0U))
      {
        /* f(PLL Source) / PLLM */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
        /* f(PLLSAI3CLK) = f(VCO input) * PLLN / PLLP */
        plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
 8008f32:	f3c3 2306 	ubfx	r3, r3, #8, #7
#if defined(RCC_PLLP_DIV_2_31_SUPPORT)
        pllp = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLPDIV) >> RCC_PLLCFGR_PLLPDIV_Pos;
#endif
        if(pllp == 0U)
 8008f36:	d145      	bne.n	8008fc4 <RCCEx_GetSAIxPeriphCLKFreq+0xe8>
        {
          if(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP) != 0U)
 8008f38:	68e2      	ldr	r2, [r4, #12]
 8008f3a:	e03e      	b.n	8008fba <RCCEx_GetSAIxPeriphCLKFreq+0xde>
          }
        }
        frequency = (pllvco * plln) / pllp;
      }
    }
    else if(srcclk == 0U)  /* RCC_SAI1CLKSOURCE_PLLSAI1 || RCC_SAI2CLKSOURCE_PLLSAI1 */
 8008f3c:	b9b3      	cbnz	r3, 8008f6c <RCCEx_GetSAIxPeriphCLKFreq+0x90>
    {
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI1RDY) && (__HAL_RCC_GET_PLLSAI1CLKOUT_CONFIG(RCC_PLLSAI1_SAI1CLK) != 0U))
 8008f3e:	6810      	ldr	r0, [r2, #0]
 8008f40:	4c26      	ldr	r4, [pc, #152]	; (8008fdc <RCCEx_GetSAIxPeriphCLKFreq+0x100>)
 8008f42:	f010 6000 	ands.w	r0, r0, #134217728	; 0x8000000
 8008f46:	d048      	beq.n	8008fda <RCCEx_GetSAIxPeriphCLKFreq+0xfe>
 8008f48:	6920      	ldr	r0, [r4, #16]
 8008f4a:	f410 3080 	ands.w	r0, r0, #65536	; 0x10000
 8008f4e:	d044      	beq.n	8008fda <RCCEx_GetSAIxPeriphCLKFreq+0xfe>
      {
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
        /* PLLSAI1M exists: apply PLLSAI1M divider for PLLSAI1 output computation */
        /* f(PLLSAI1 Source) / PLLSAI1M */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U));
 8008f50:	6920      	ldr	r0, [r4, #16]
#else
        /* f(PLL Source) / PLLM */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
#endif
        /* f(PLLSAI1CLK) = f(VCOSAI1 input) * PLLSAI1N / PLLSAI1P */
        plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
 8008f52:	6923      	ldr	r3, [r4, #16]
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI1RDY) && (__HAL_RCC_GET_PLLSAI1CLKOUT_CONFIG(RCC_PLLSAI1_SAI1CLK) != 0U))
      {
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
        /* PLLSAI1M exists: apply PLLSAI1M divider for PLLSAI1 output computation */
        /* f(PLLSAI1 Source) / PLLSAI1M */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U));
 8008f54:	f3c0 1003 	ubfx	r0, r0, #4, #4
 8008f58:	3001      	adds	r0, #1
 8008f5a:	fbb1 f1f0 	udiv	r1, r1, r0
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
#endif
        /* f(PLLSAI1CLK) = f(VCOSAI1 input) * PLLSAI1N / PLLSAI1P */
        plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
#if defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
        pllp = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1PDIV) >> RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos;
 8008f5e:	6920      	ldr	r0, [r4, #16]
#endif
        if(pllp == 0U)
 8008f60:	0ec0      	lsrs	r0, r0, #27
#else
        /* f(PLL Source) / PLLM */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
#endif
        /* f(PLLSAI1CLK) = f(VCOSAI1 input) * PLLSAI1N / PLLSAI1P */
        plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
 8008f62:	f3c3 2306 	ubfx	r3, r3, #8, #7
#if defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
        pllp = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1PDIV) >> RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos;
#endif
        if(pllp == 0U)
 8008f66:	d12d      	bne.n	8008fc4 <RCCEx_GetSAIxPeriphCLKFreq+0xe8>
        {
          if(READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1P) != 0U)
 8008f68:	6922      	ldr	r2, [r4, #16]
 8008f6a:	e026      	b.n	8008fba <RCCEx_GetSAIxPeriphCLKFreq+0xde>
        }
        frequency = (pllvco * plln) / pllp;
      }
    }
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    else if((srcclk == RCC_SAI1CLKSOURCE_HSI) || (srcclk == RCC_SAI2CLKSOURCE_HSI))
 8008f6c:	2b80      	cmp	r3, #128	; 0x80
 8008f6e:	d002      	beq.n	8008f76 <RCCEx_GetSAIxPeriphCLKFreq+0x9a>
 8008f70:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8008f74:	d106      	bne.n	8008f84 <RCCEx_GetSAIxPeriphCLKFreq+0xa8>
    {
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8008f76:	6813      	ldr	r3, [r2, #0]
      {
        frequency = HSI_VALUE;
 8008f78:	4819      	ldr	r0, [pc, #100]	; (8008fe0 <RCCEx_GetSAIxPeriphCLKFreq+0x104>)
 8008f7a:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8008f7e:	bf08      	it	eq
 8008f80:	2000      	moveq	r0, #0
 8008f82:	bd10      	pop	{r4, pc}
    }
#endif /* SAI2 */

#if defined(RCC_PLLSAI2_SUPPORT)

    else if((srcclk == RCC_SAI1CLKSOURCE_PLLSAI2) || (srcclk == RCC_SAI2CLKSOURCE_PLLSAI2))
 8008f84:	2b20      	cmp	r3, #32
 8008f86:	d002      	beq.n	8008f8e <RCCEx_GetSAIxPeriphCLKFreq+0xb2>
 8008f88:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008f8c:	d121      	bne.n	8008fd2 <RCCEx_GetSAIxPeriphCLKFreq+0xf6>
    {
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI2RDY) && (__HAL_RCC_GET_PLLSAI2CLKOUT_CONFIG(RCC_PLLSAI2_SAI2CLK) != 0U))
 8008f8e:	6810      	ldr	r0, [r2, #0]
 8008f90:	4c12      	ldr	r4, [pc, #72]	; (8008fdc <RCCEx_GetSAIxPeriphCLKFreq+0x100>)
 8008f92:	f010 5000 	ands.w	r0, r0, #536870912	; 0x20000000
 8008f96:	d020      	beq.n	8008fda <RCCEx_GetSAIxPeriphCLKFreq+0xfe>
 8008f98:	6960      	ldr	r0, [r4, #20]
 8008f9a:	f410 3080 	ands.w	r0, r0, #65536	; 0x10000
 8008f9e:	d01c      	beq.n	8008fda <RCCEx_GetSAIxPeriphCLKFreq+0xfe>
      {
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
        /* PLLSAI2M exists: apply PLLSAI2M divider for PLLSAI2 output computation */
        /* f(PLLSAI2 Source) / PLLSAI2M */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2M) >> RCC_PLLSAI2CFGR_PLLSAI2M_Pos) + 1U));
 8008fa0:	6960      	ldr	r0, [r4, #20]
#else
        /* f(PLL Source) / PLLM */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
#endif
        /* f(PLLSAI2CLK) = f(VCOSAI2 input) * PLLSAI2N / PLLSAI2P */
        plln = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> RCC_PLLSAI2CFGR_PLLSAI2N_Pos;
 8008fa2:	6963      	ldr	r3, [r4, #20]
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI2RDY) && (__HAL_RCC_GET_PLLSAI2CLKOUT_CONFIG(RCC_PLLSAI2_SAI2CLK) != 0U))
      {
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
        /* PLLSAI2M exists: apply PLLSAI2M divider for PLLSAI2 output computation */
        /* f(PLLSAI2 Source) / PLLSAI2M */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2M) >> RCC_PLLSAI2CFGR_PLLSAI2M_Pos) + 1U));
 8008fa4:	f3c0 1003 	ubfx	r0, r0, #4, #4
 8008fa8:	3001      	adds	r0, #1
 8008faa:	fbb1 f1f0 	udiv	r1, r1, r0
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
#endif
        /* f(PLLSAI2CLK) = f(VCOSAI2 input) * PLLSAI2N / PLLSAI2P */
        plln = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> RCC_PLLSAI2CFGR_PLLSAI2N_Pos;
#if defined(RCC_PLLSAI2P_DIV_2_31_SUPPORT)
        pllp = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2PDIV) >> RCC_PLLSAI2CFGR_PLLSAI2PDIV_Pos;
 8008fae:	6960      	ldr	r0, [r4, #20]
#endif
        if(pllp == 0U)
 8008fb0:	0ec0      	lsrs	r0, r0, #27
#else
        /* f(PLL Source) / PLLM */
        pllvco = (pllvco / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
#endif
        /* f(PLLSAI2CLK) = f(VCOSAI2 input) * PLLSAI2N / PLLSAI2P */
        plln = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> RCC_PLLSAI2CFGR_PLLSAI2N_Pos;
 8008fb2:	f3c3 2306 	ubfx	r3, r3, #8, #7
#if defined(RCC_PLLSAI2P_DIV_2_31_SUPPORT)
        pllp = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2PDIV) >> RCC_PLLSAI2CFGR_PLLSAI2PDIV_Pos;
#endif
        if(pllp == 0U)
 8008fb6:	d105      	bne.n	8008fc4 <RCCEx_GetSAIxPeriphCLKFreq+0xe8>
        {
          if(READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2P) != 0U)
 8008fb8:	6962      	ldr	r2, [r4, #20]
          {
            pllp = 17U;
          }
          else
          {
            pllp = 7U;
 8008fba:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8008fbe:	bf14      	ite	ne
 8008fc0:	2011      	movne	r0, #17
 8008fc2:	2007      	moveq	r0, #7
          }
        }
        frequency = (pllvco * plln) / pllp;
 8008fc4:	4359      	muls	r1, r3
 8008fc6:	fbb1 f0f0 	udiv	r0, r1, r0
 8008fca:	bd10      	pop	{r4, pc}
 8008fcc:	f64b 3080 	movw	r0, #48000	; 0xbb80
 8008fd0:	bd10      	pop	{r4, pc}
 8008fd2:	2000      	movs	r0, #0
 8008fd4:	bd10      	pop	{r4, pc}
  if(frequency == 0U)
  {
    pllvco = InputFrequency;

#if defined(SAI2)
    if((srcclk == RCC_SAI1CLKSOURCE_PLL) || (srcclk == RCC_SAI2CLKSOURCE_PLL))
 8008fd6:	2b40      	cmp	r3, #64	; 0x40
 8008fd8:	e798      	b.n	8008f0c <RCCEx_GetSAIxPeriphCLKFreq+0x30>
    }
  }


  return frequency;
}
 8008fda:	bd10      	pop	{r4, pc}
 8008fdc:	40021000 	.word	0x40021000
 8008fe0:	00f42400 	.word	0x00f42400

08008fe4 <RCCEx_PLLSAI1_Config>:
  assert_param(IS_RCC_PLLSAI1M_VALUE(PllSai1->PLLSAI1M));
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));

  /* Check that PLLSAI1 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8008fe4:	4b44      	ldr	r3, [pc, #272]	; (80090f8 <RCCEx_PLLSAI1_Config+0x114>)
 8008fe6:	68da      	ldr	r2, [r3, #12]
 8008fe8:	f012 0f03 	tst.w	r2, #3
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_Config(RCC_PLLSAI1InitTypeDef *PllSai1, uint32_t Divider)
{
 8008fec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008ff0:	4604      	mov	r4, r0
 8008ff2:	460f      	mov	r7, r1
 8008ff4:	461d      	mov	r5, r3
 8008ff6:	6800      	ldr	r0, [r0, #0]
  assert_param(IS_RCC_PLLSAI1M_VALUE(PllSai1->PLLSAI1M));
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));

  /* Check that PLLSAI1 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8008ff8:	d006      	beq.n	8009008 <RCCEx_PLLSAI1_Config+0x24>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai1->PLLSAI1Source)
 8008ffa:	68db      	ldr	r3, [r3, #12]
 8008ffc:	f003 0303 	and.w	r3, r3, #3
 8009000:	4283      	cmp	r3, r0
 8009002:	d116      	bne.n	8009032 <RCCEx_PLLSAI1_Config+0x4e>
       ||
 8009004:	b1ab      	cbz	r3, 8009032 <RCCEx_PLLSAI1_Config+0x4e>
 8009006:	e01c      	b.n	8009042 <RCCEx_PLLSAI1_Config+0x5e>
    }
  }
  else
  {
    /* Check PLLSAI1 clock source availability */
    switch(PllSai1->PLLSAI1Source)
 8009008:	2802      	cmp	r0, #2
 800900a:	d007      	beq.n	800901c <RCCEx_PLLSAI1_Config+0x38>
 800900c:	2803      	cmp	r0, #3
 800900e:	d009      	beq.n	8009024 <RCCEx_PLLSAI1_Config+0x40>
 8009010:	2801      	cmp	r0, #1
 8009012:	d10e      	bne.n	8009032 <RCCEx_PLLSAI1_Config+0x4e>
    {
    case RCC_PLLSOURCE_MSI:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 8009014:	681b      	ldr	r3, [r3, #0]
 8009016:	079e      	lsls	r6, r3, #30
 8009018:	d56b      	bpl.n	80090f2 <RCCEx_PLLSAI1_Config+0x10e>
 800901a:	e00d      	b.n	8009038 <RCCEx_PLLSAI1_Config+0x54>
      {
        status = HAL_ERROR;
      }
      break;
    case RCC_PLLSOURCE_HSI:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 800901c:	681b      	ldr	r3, [r3, #0]
 800901e:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8009022:	e005      	b.n	8009030 <RCCEx_PLLSAI1_Config+0x4c>
      {
        status = HAL_ERROR;
      }
      break;
    case RCC_PLLSOURCE_HSE:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
 8009024:	681a      	ldr	r2, [r3, #0]
 8009026:	0391      	lsls	r1, r2, #14
 8009028:	d406      	bmi.n	8009038 <RCCEx_PLLSAI1_Config+0x54>
      {
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 800902a:	681b      	ldr	r3, [r3, #0]
 800902c:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 8009030:	d102      	bne.n	8009038 <RCCEx_PLLSAI1_Config+0x54>
 8009032:	2001      	movs	r0, #1
 8009034:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

    if(status == HAL_OK)
    {
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
      /* Set PLLSAI1 clock source */
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PllSai1->PLLSAI1Source);
 8009038:	68eb      	ldr	r3, [r5, #12]
 800903a:	f023 0303 	bic.w	r3, r3, #3
 800903e:	4318      	orrs	r0, r3
 8009040:	60e8      	str	r0, [r5, #12]
  }

  if(status == HAL_OK)
  {
    /* Disable the PLLSAI1 */
    __HAL_RCC_PLLSAI1_DISABLE();
 8009042:	682b      	ldr	r3, [r5, #0]
 8009044:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8009048:	602b      	str	r3, [r5, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800904a:	f7fd ffdf 	bl	800700c <HAL_GetTick>
 800904e:	4680      	mov	r8, r0

    /* Wait till PLLSAI1 is ready to be updated */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 8009050:	682b      	ldr	r3, [r5, #0]
 8009052:	4e29      	ldr	r6, [pc, #164]	; (80090f8 <RCCEx_PLLSAI1_Config+0x114>)
 8009054:	011a      	lsls	r2, r3, #4
 8009056:	d508      	bpl.n	800906a <RCCEx_PLLSAI1_Config+0x86>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8009058:	f7fd ffd8 	bl	800700c <HAL_GetTick>
 800905c:	ebc8 0000 	rsb	r0, r8, r0
 8009060:	2802      	cmp	r0, #2
 8009062:	d9f5      	bls.n	8009050 <RCCEx_PLLSAI1_Config+0x6c>
      {
        status = HAL_TIMEOUT;
 8009064:	2003      	movs	r0, #3
 8009066:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800906a:	f8d4 e008 	ldr.w	lr, [r4, #8]
 800906e:	6863      	ldr	r3, [r4, #4]
      }
    }

    if(status == HAL_OK)
    {
      if(Divider == DIVIDER_P_UPDATE)
 8009070:	b95f      	cbnz	r7, 800908a <RCCEx_PLLSAI1_Config+0xa6>
        assert_param(IS_RCC_PLLSAI1P_VALUE(PllSai1->PLLSAI1P));
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)

        /* Configure the PLLSAI1 Division factor M, P and Multiplication factor N*/
#if defined(RCC_PLLSAI1P_DIV_2_31_SUPPORT)
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8009072:	6932      	ldr	r2, [r6, #16]
 8009074:	4821      	ldr	r0, [pc, #132]	; (80090fc <RCCEx_PLLSAI1_Config+0x118>)
 8009076:	4010      	ands	r0, r2
 8009078:	68e2      	ldr	r2, [r4, #12]
 800907a:	ea40 200e 	orr.w	r0, r0, lr, lsl #8
 800907e:	ea40 60c2 	orr.w	r0, r0, r2, lsl #27
 8009082:	3b01      	subs	r3, #1
 8009084:	ea40 1303 	orr.w	r3, r0, r3, lsl #4
 8009088:	e01c      	b.n	80090c4 <RCCEx_PLLSAI1_Config+0xe0>
                   ((PllSai1->PLLSAI1P >> 4U) << RCC_PLLSAI1CFGR_PLLSAI1P_Pos));
#endif /* RCC_PLLSAI1P_DIV_2_31_SUPPORT */

#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
      }
      else if(Divider == DIVIDER_Q_UPDATE)
 800908a:	2f01      	cmp	r7, #1
 800908c:	d10d      	bne.n	80090aa <RCCEx_PLLSAI1_Config+0xc6>
      {
        assert_param(IS_RCC_PLLSAI1Q_VALUE(PllSai1->PLLSAI1Q));
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
        /* Configure the PLLSAI1 Division factor M, Q and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR,
 800908e:	6932      	ldr	r2, [r6, #16]
 8009090:	491b      	ldr	r1, [pc, #108]	; (8009100 <RCCEx_PLLSAI1_Config+0x11c>)
 8009092:	4011      	ands	r1, r2
 8009094:	3b01      	subs	r3, #1
 8009096:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
 800909a:	ea41 1103 	orr.w	r1, r1, r3, lsl #4
 800909e:	6923      	ldr	r3, [r4, #16]
 80090a0:	085b      	lsrs	r3, r3, #1
 80090a2:	3b01      	subs	r3, #1
 80090a4:	ea41 5343 	orr.w	r3, r1, r3, lsl #21
 80090a8:	e00c      	b.n	80090c4 <RCCEx_PLLSAI1_Config+0xe0>
      else
      {
        assert_param(IS_RCC_PLLSAI1R_VALUE(PllSai1->PLLSAI1R));
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
        /* Configure the PLLSAI1 Division factor M, R and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR,
 80090aa:	6931      	ldr	r1, [r6, #16]
 80090ac:	4a15      	ldr	r2, [pc, #84]	; (8009104 <RCCEx_PLLSAI1_Config+0x120>)
 80090ae:	400a      	ands	r2, r1
 80090b0:	3b01      	subs	r3, #1
 80090b2:	ea42 220e 	orr.w	r2, r2, lr, lsl #8
 80090b6:	ea42 1203 	orr.w	r2, r2, r3, lsl #4
 80090ba:	6963      	ldr	r3, [r4, #20]
 80090bc:	085b      	lsrs	r3, r3, #1
 80090be:	3b01      	subs	r3, #1
 80090c0:	ea42 6343 	orr.w	r3, r2, r3, lsl #25
 80090c4:	6133      	str	r3, [r6, #16]
                   (((PllSai1->PLLSAI1R >> 1U) - 1U) << RCC_PLLSAI1CFGR_PLLSAI1R_Pos));
#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
      }

      /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
      __HAL_RCC_PLLSAI1_ENABLE();
 80090c6:	682b      	ldr	r3, [r5, #0]
 80090c8:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 80090cc:	602b      	str	r3, [r5, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80090ce:	f7fd ff9d 	bl	800700c <HAL_GetTick>
 80090d2:	4606      	mov	r6, r0

      /* Wait till PLLSAI1 is ready */
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 80090d4:	682b      	ldr	r3, [r5, #0]
 80090d6:	4a08      	ldr	r2, [pc, #32]	; (80090f8 <RCCEx_PLLSAI1_Config+0x114>)
 80090d8:	011b      	lsls	r3, r3, #4
 80090da:	d405      	bmi.n	80090e8 <RCCEx_PLLSAI1_Config+0x104>
      {
        if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 80090dc:	f7fd ff96 	bl	800700c <HAL_GetTick>
 80090e0:	1b80      	subs	r0, r0, r6
 80090e2:	2802      	cmp	r0, #2
 80090e4:	d9f6      	bls.n	80090d4 <RCCEx_PLLSAI1_Config+0xf0>
 80090e6:	e7bd      	b.n	8009064 <RCCEx_PLLSAI1_Config+0x80>
      }

      if(status == HAL_OK)
      {
        /* Configure the PLLSAI1 Clock output(s) */
        __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
 80090e8:	6911      	ldr	r1, [r2, #16]
 80090ea:	69a3      	ldr	r3, [r4, #24]
 80090ec:	430b      	orrs	r3, r1
 80090ee:	6113      	str	r3, [r2, #16]
 80090f0:	2000      	movs	r0, #0
      }
    }
  }

  return status;
}
 80090f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80090f6:	bf00      	nop
 80090f8:	40021000 	.word	0x40021000
 80090fc:	07ff800f 	.word	0x07ff800f
 8009100:	ff9f800f 	.word	0xff9f800f
 8009104:	f9ff800f 	.word	0xf9ff800f

08009108 <RCCEx_PLLSAI2_Config.constprop.1>:
  assert_param(IS_RCC_PLLSAI2M_VALUE(PllSai2->PLLSAI2M));
  assert_param(IS_RCC_PLLSAI2N_VALUE(PllSai2->PLLSAI2N));
  assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PllSai2->PLLSAI2ClockOut));

  /* Check that PLLSAI2 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8009108:	4b31      	ldr	r3, [pc, #196]	; (80091d0 <RCCEx_PLLSAI2_Config.constprop.1+0xc8>)
 800910a:	68da      	ldr	r2, [r3, #12]
 800910c:	f012 0f03 	tst.w	r2, #3
  *
  * @note   PLLSAI2 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI2_Config(RCC_PLLSAI2InitTypeDef *PllSai2, uint32_t Divider)
 8009110:	b570      	push	{r4, r5, r6, lr}
 8009112:	4605      	mov	r5, r0
 8009114:	461c      	mov	r4, r3
 8009116:	6800      	ldr	r0, [r0, #0]
  assert_param(IS_RCC_PLLSAI2M_VALUE(PllSai2->PLLSAI2M));
  assert_param(IS_RCC_PLLSAI2N_VALUE(PllSai2->PLLSAI2N));
  assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PllSai2->PLLSAI2ClockOut));

  /* Check that PLLSAI2 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8009118:	d006      	beq.n	8009128 <RCCEx_PLLSAI2_Config.constprop.1+0x20>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai2->PLLSAI2Source)
 800911a:	68db      	ldr	r3, [r3, #12]
 800911c:	f003 0303 	and.w	r3, r3, #3
 8009120:	4283      	cmp	r3, r0
 8009122:	d116      	bne.n	8009152 <RCCEx_PLLSAI2_Config.constprop.1+0x4a>
       ||
 8009124:	b1ab      	cbz	r3, 8009152 <RCCEx_PLLSAI2_Config.constprop.1+0x4a>
 8009126:	e01b      	b.n	8009160 <RCCEx_PLLSAI2_Config.constprop.1+0x58>
    }
  }
  else
  {
    /* Check PLLSAI2 clock source availability */
    switch(PllSai2->PLLSAI2Source)
 8009128:	2802      	cmp	r0, #2
 800912a:	d007      	beq.n	800913c <RCCEx_PLLSAI2_Config.constprop.1+0x34>
 800912c:	2803      	cmp	r0, #3
 800912e:	d009      	beq.n	8009144 <RCCEx_PLLSAI2_Config.constprop.1+0x3c>
 8009130:	2801      	cmp	r0, #1
 8009132:	d10e      	bne.n	8009152 <RCCEx_PLLSAI2_Config.constprop.1+0x4a>
    {
    case RCC_PLLSOURCE_MSI:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 8009134:	681b      	ldr	r3, [r3, #0]
 8009136:	079e      	lsls	r6, r3, #30
 8009138:	d548      	bpl.n	80091cc <RCCEx_PLLSAI2_Config.constprop.1+0xc4>
 800913a:	e00c      	b.n	8009156 <RCCEx_PLLSAI2_Config.constprop.1+0x4e>
      {
        status = HAL_ERROR;
      }
      break;
    case RCC_PLLSOURCE_HSI:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 800913c:	681b      	ldr	r3, [r3, #0]
 800913e:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8009142:	e005      	b.n	8009150 <RCCEx_PLLSAI2_Config.constprop.1+0x48>
      {
        status = HAL_ERROR;
      }
      break;
    case RCC_PLLSOURCE_HSE:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
 8009144:	681a      	ldr	r2, [r3, #0]
 8009146:	0391      	lsls	r1, r2, #14
 8009148:	d405      	bmi.n	8009156 <RCCEx_PLLSAI2_Config.constprop.1+0x4e>
      {
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 800914a:	681b      	ldr	r3, [r3, #0]
 800914c:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 8009150:	d101      	bne.n	8009156 <RCCEx_PLLSAI2_Config.constprop.1+0x4e>
 8009152:	2001      	movs	r0, #1
 8009154:	bd70      	pop	{r4, r5, r6, pc}

    if(status == HAL_OK)
    {
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
      /* Set PLLSAI2 clock source */
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PllSai2->PLLSAI2Source);
 8009156:	68e3      	ldr	r3, [r4, #12]
 8009158:	f023 0303 	bic.w	r3, r3, #3
 800915c:	4318      	orrs	r0, r3
 800915e:	60e0      	str	r0, [r4, #12]
  }

  if(status == HAL_OK)
  {
    /* Disable the PLLSAI2 */
    __HAL_RCC_PLLSAI2_DISABLE();
 8009160:	6823      	ldr	r3, [r4, #0]
 8009162:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8009166:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8009168:	f7fd ff50 	bl	800700c <HAL_GetTick>
 800916c:	4606      	mov	r6, r0

    /* Wait till PLLSAI2 is ready to be updated */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 800916e:	6823      	ldr	r3, [r4, #0]
 8009170:	4917      	ldr	r1, [pc, #92]	; (80091d0 <RCCEx_PLLSAI2_Config.constprop.1+0xc8>)
 8009172:	009a      	lsls	r2, r3, #2
 8009174:	d506      	bpl.n	8009184 <RCCEx_PLLSAI2_Config.constprop.1+0x7c>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8009176:	f7fd ff49 	bl	800700c <HAL_GetTick>
 800917a:	1b80      	subs	r0, r0, r6
 800917c:	2802      	cmp	r0, #2
 800917e:	d9f6      	bls.n	800916e <RCCEx_PLLSAI2_Config.constprop.1+0x66>
      {
        status = HAL_TIMEOUT;
 8009180:	2003      	movs	r0, #3
 8009182:	bd70      	pop	{r4, r5, r6, pc}
        assert_param(IS_RCC_PLLSAI2P_VALUE(PllSai2->PLLSAI2P));
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)

        /* Configure the PLLSAI2 Division factor M, P and Multiplication factor N*/
#if defined(RCC_PLLSAI2P_DIV_2_31_SUPPORT)
        MODIFY_REG(RCC->PLLSAI2CFGR,
 8009184:	6948      	ldr	r0, [r1, #20]
 8009186:	4b13      	ldr	r3, [pc, #76]	; (80091d4 <RCCEx_PLLSAI2_Config.constprop.1+0xcc>)
 8009188:	68aa      	ldr	r2, [r5, #8]
 800918a:	4003      	ands	r3, r0
 800918c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8009190:	68ea      	ldr	r2, [r5, #12]
 8009192:	ea43 62c2 	orr.w	r2, r3, r2, lsl #27
 8009196:	686b      	ldr	r3, [r5, #4]
 8009198:	3b01      	subs	r3, #1
 800919a:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
 800919e:	614b      	str	r3, [r1, #20]
                   (((PllSai2->PLLSAI2R >> 1U) - 1U) << RCC_PLLSAI2CFGR_PLLSAI2R_Pos));
#endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
      }

      /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
      __HAL_RCC_PLLSAI2_ENABLE();
 80091a0:	680b      	ldr	r3, [r1, #0]
 80091a2:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80091a6:	600b      	str	r3, [r1, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80091a8:	f7fd ff30 	bl	800700c <HAL_GetTick>
 80091ac:	4606      	mov	r6, r0

      /* Wait till PLLSAI2 is ready */
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
 80091ae:	6823      	ldr	r3, [r4, #0]
 80091b0:	4a07      	ldr	r2, [pc, #28]	; (80091d0 <RCCEx_PLLSAI2_Config.constprop.1+0xc8>)
 80091b2:	009b      	lsls	r3, r3, #2
 80091b4:	d405      	bmi.n	80091c2 <RCCEx_PLLSAI2_Config.constprop.1+0xba>
      {
        if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 80091b6:	f7fd ff29 	bl	800700c <HAL_GetTick>
 80091ba:	1b80      	subs	r0, r0, r6
 80091bc:	2802      	cmp	r0, #2
 80091be:	d9f6      	bls.n	80091ae <RCCEx_PLLSAI2_Config.constprop.1+0xa6>
 80091c0:	e7de      	b.n	8009180 <RCCEx_PLLSAI2_Config.constprop.1+0x78>
      }

      if(status == HAL_OK)
      {
        /* Configure the PLLSAI2 Clock output(s) */
        __HAL_RCC_PLLSAI2CLKOUT_ENABLE(PllSai2->PLLSAI2ClockOut);
 80091c2:	6951      	ldr	r1, [r2, #20]
 80091c4:	69ab      	ldr	r3, [r5, #24]
 80091c6:	430b      	orrs	r3, r1
 80091c8:	6153      	str	r3, [r2, #20]
 80091ca:	2000      	movs	r0, #0
      }
    }
  }

  return status;
}
 80091cc:	bd70      	pop	{r4, r5, r6, pc}
 80091ce:	bf00      	nop
 80091d0:	40021000 	.word	0x40021000
 80091d4:	07ff800f 	.word	0x07ff800f

080091d8 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 80091d8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

#if defined(SAI1)

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 80091dc:	6806      	ldr	r6, [r0, #0]
 80091de:	f416 6600 	ands.w	r6, r6, #2048	; 0x800
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 80091e2:	4604      	mov	r4, r0
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

#if defined(SAI1)

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 80091e4:	d026      	beq.n	8009234 <HAL_RCCEx_PeriphCLKConfig+0x5c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLK(PeriphClkInit->Sai1ClockSelection));

    switch(PeriphClkInit->Sai1ClockSelection)
 80091e6:	6ec1      	ldr	r1, [r0, #108]	; 0x6c
 80091e8:	2940      	cmp	r1, #64	; 0x40
 80091ea:	d00c      	beq.n	8009206 <HAL_RCCEx_PeriphCLKConfig+0x2e>
 80091ec:	d806      	bhi.n	80091fc <HAL_RCCEx_PeriphCLKConfig+0x24>
 80091ee:	b181      	cbz	r1, 8009212 <HAL_RCCEx_PeriphCLKConfig+0x3a>
 80091f0:	2920      	cmp	r1, #32
 80091f2:	d11e      	bne.n	8009232 <HAL_RCCEx_PeriphCLKConfig+0x5a>

#if defined(RCC_PLLSAI2_SUPPORT)

    case RCC_SAI1CLKSOURCE_PLLSAI2:  /* PLLSAI2 is used as clock source for SAI1*/
      /* PLLSAI2 input clock, parameters M, N & P configuration clock output (PLLSAI2ClockOut) */
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 80091f4:	3020      	adds	r0, #32
 80091f6:	f7ff ff87 	bl	8009108 <RCCEx_PLLSAI2_Config.constprop.1>
 80091fa:	e00d      	b.n	8009218 <HAL_RCCEx_PeriphCLKConfig+0x40>
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLK(PeriphClkInit->Sai1ClockSelection));

    switch(PeriphClkInit->Sai1ClockSelection)
 80091fc:	2960      	cmp	r1, #96	; 0x60
 80091fe:	d00d      	beq.n	800921c <HAL_RCCEx_PeriphCLKConfig+0x44>
 8009200:	2980      	cmp	r1, #128	; 0x80
 8009202:	d00b      	beq.n	800921c <HAL_RCCEx_PeriphCLKConfig+0x44>
 8009204:	e015      	b.n	8009232 <HAL_RCCEx_PeriphCLKConfig+0x5a>
    {
    case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
      /* Enable SAI Clock output generated from System PLL . */
#if defined(RCC_PLLSAI2_SUPPORT)
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8009206:	4ab5      	ldr	r2, [pc, #724]	; (80094dc <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8009208:	68d3      	ldr	r3, [r2, #12]
 800920a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800920e:	60d3      	str	r3, [r2, #12]
#else
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI2CLK);
#endif /* RCC_PLLSAI2_SUPPORT */
      /* SAI1 clock source config set later after clock selection check */
      break;
 8009210:	e004      	b.n	800921c <HAL_RCCEx_PeriphCLKConfig+0x44>

    case RCC_SAI1CLKSOURCE_PLLSAI1:  /* PLLSAI1 is used as clock source for SAI1*/
      /* PLLSAI1 input clock, parameters M, N & P configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8009212:	3004      	adds	r0, #4
 8009214:	f7ff fee6 	bl	8008fe4 <RCCEx_PLLSAI1_Config>

#if defined(RCC_PLLSAI2_SUPPORT)

    case RCC_SAI1CLKSOURCE_PLLSAI2:  /* PLLSAI2 is used as clock source for SAI1*/
      /* PLLSAI2 input clock, parameters M, N & P configuration clock output (PLLSAI2ClockOut) */
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8009218:	4606      	mov	r6, r0
    default:
      ret = HAL_ERROR;
      break;
    }

    if(ret == HAL_OK)
 800921a:	b958      	cbnz	r0, 8009234 <HAL_RCCEx_PeriphCLKConfig+0x5c>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 800921c:	49af      	ldr	r1, [pc, #700]	; (80094dc <HAL_RCCEx_PeriphCLKConfig+0x304>)
 800921e:	f8d1 309c 	ldr.w	r3, [r1, #156]	; 0x9c
 8009222:	f023 02e0 	bic.w	r2, r3, #224	; 0xe0
 8009226:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8009228:	4313      	orrs	r3, r2
 800922a:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
 800922e:	2600      	movs	r6, #0
 8009230:	e000      	b.n	8009234 <HAL_RCCEx_PeriphCLKConfig+0x5c>
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
      /* SAI1 clock source config set later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8009232:	2601      	movs	r6, #1
#endif /* SAI1 */

#if defined(SAI2)

  /*-------------------------- SAI2 clock source configuration ---------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
 8009234:	6823      	ldr	r3, [r4, #0]
 8009236:	04d8      	lsls	r0, r3, #19
 8009238:	d52c      	bpl.n	8009294 <HAL_RCCEx_PeriphCLKConfig+0xbc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLK(PeriphClkInit->Sai2ClockSelection));

    switch(PeriphClkInit->Sai2ClockSelection)
 800923a:	6f21      	ldr	r1, [r4, #112]	; 0x70
 800923c:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8009240:	d010      	beq.n	8009264 <HAL_RCCEx_PeriphCLKConfig+0x8c>
 8009242:	d808      	bhi.n	8009256 <HAL_RCCEx_PeriphCLKConfig+0x7e>
 8009244:	b1a1      	cbz	r1, 8009270 <HAL_RCCEx_PeriphCLKConfig+0x98>
 8009246:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 800924a:	d122      	bne.n	8009292 <HAL_RCCEx_PeriphCLKConfig+0xba>
      /* SAI2 clock source config set later after clock selection check */
      break;

    case RCC_SAI2CLKSOURCE_PLLSAI2:  /* PLLSAI2 is used as clock source for SAI2*/
      /* PLLSAI2 input clock, parameters M, N & P configuration and clock output (PLLSAI2ClockOut) */
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 800924c:	f104 0020 	add.w	r0, r4, #32
 8009250:	f7ff ff5a 	bl	8009108 <RCCEx_PLLSAI2_Config.constprop.1>
 8009254:	e00f      	b.n	8009276 <HAL_RCCEx_PeriphCLKConfig+0x9e>
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLK(PeriphClkInit->Sai2ClockSelection));

    switch(PeriphClkInit->Sai2ClockSelection)
 8009256:	f5b1 7f40 	cmp.w	r1, #768	; 0x300
 800925a:	d00e      	beq.n	800927a <HAL_RCCEx_PeriphCLKConfig+0xa2>
 800925c:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 8009260:	d00b      	beq.n	800927a <HAL_RCCEx_PeriphCLKConfig+0xa2>
 8009262:	e016      	b.n	8009292 <HAL_RCCEx_PeriphCLKConfig+0xba>
    {
    case RCC_SAI2CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
      /* Enable SAI Clock output generated from System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8009264:	4a9d      	ldr	r2, [pc, #628]	; (80094dc <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8009266:	68d3      	ldr	r3, [r2, #12]
 8009268:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800926c:	60d3      	str	r3, [r2, #12]
 800926e:	e004      	b.n	800927a <HAL_RCCEx_PeriphCLKConfig+0xa2>
      /* SAI2 clock source config set later after clock selection check */
      break;

    case RCC_SAI2CLKSOURCE_PLLSAI1: /* PLLSAI1 is used as clock source for SAI2*/
      /* PLLSAI1 input clock, parameters M, N & P configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8009270:	1d20      	adds	r0, r4, #4
 8009272:	f7ff feb7 	bl	8008fe4 <RCCEx_PLLSAI1_Config>
      /* SAI2 clock source config set later after clock selection check */
      break;

    case RCC_SAI2CLKSOURCE_PLLSAI2:  /* PLLSAI2 is used as clock source for SAI2*/
      /* PLLSAI2 input clock, parameters M, N & P configuration and clock output (PLLSAI2ClockOut) */
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8009276:	4605      	mov	r5, r0
      /* SAI2 clock source config set later after clock selection check */
      break;
 8009278:	e000      	b.n	800927c <HAL_RCCEx_PeriphCLKConfig+0xa4>
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLK(PeriphClkInit->Sai2ClockSelection));

    switch(PeriphClkInit->Sai2ClockSelection)
 800927a:	4635      	mov	r5, r6
    default:
      ret = HAL_ERROR;
      break;
    }

    if(ret == HAL_OK)
 800927c:	b965      	cbnz	r5, 8009298 <HAL_RCCEx_PeriphCLKConfig+0xc0>
    {
      /* Set the source of SAI2 clock*/
      __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 800927e:	4997      	ldr	r1, [pc, #604]	; (80094dc <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8009280:	f8d1 309c 	ldr.w	r3, [r1, #156]	; 0x9c
 8009284:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 8009288:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800928a:	4313      	orrs	r3, r2
 800928c:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
 8009290:	e003      	b.n	800929a <HAL_RCCEx_PeriphCLKConfig+0xc2>
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
      /* SAI2 clock source config set later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8009292:	2601      	movs	r6, #1
 8009294:	4635      	mov	r5, r6
 8009296:	e000      	b.n	800929a <HAL_RCCEx_PeriphCLKConfig+0xc2>
 8009298:	462e      	mov	r6, r5
    }
  }
#endif /* SAI2 */

  /*-------------------------- RTC clock source configuration ----------------------*/
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 800929a:	6823      	ldr	r3, [r4, #0]
 800929c:	0399      	lsls	r1, r3, #14
 800929e:	d554      	bpl.n	800934a <HAL_RCCEx_PeriphCLKConfig+0x172>

    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
 80092a0:	4f8e      	ldr	r7, [pc, #568]	; (80094dc <HAL_RCCEx_PeriphCLKConfig+0x304>)
 80092a2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80092a4:	00da      	lsls	r2, r3, #3
 80092a6:	f140 8189 	bpl.w	80095bc <HAL_RCCEx_PeriphCLKConfig+0x3e4>
#endif /* SAI2 */

  /*-------------------------- RTC clock source configuration ----------------------*/
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
  {
    FlagStatus       pwrclkchanged = RESET;
 80092aa:	f04f 0800 	mov.w	r8, #0
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }

    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80092ae:	f8df 9230 	ldr.w	r9, [pc, #560]	; 80094e0 <HAL_RCCEx_PeriphCLKConfig+0x308>
 80092b2:	f8d9 3000 	ldr.w	r3, [r9]
 80092b6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80092ba:	f8c9 3000 	str.w	r3, [r9]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 80092be:	f7fd fea5 	bl	800700c <HAL_GetTick>
 80092c2:	4682      	mov	sl, r0

    while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == 0U)
 80092c4:	f8d9 3000 	ldr.w	r3, [r9]
 80092c8:	05db      	lsls	r3, r3, #23
 80092ca:	d406      	bmi.n	80092da <HAL_RCCEx_PeriphCLKConfig+0x102>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80092cc:	f7fd fe9e 	bl	800700c <HAL_GetTick>
 80092d0:	ebca 0000 	rsb	r0, sl, r0
 80092d4:	2802      	cmp	r0, #2
 80092d6:	d9f5      	bls.n	80092c4 <HAL_RCCEx_PeriphCLKConfig+0xec>
 80092d8:	e02e      	b.n	8009338 <HAL_RCCEx_PeriphCLKConfig+0x160>
        ret = HAL_TIMEOUT;
        break;
      }
    }

    if(ret == HAL_OK)
 80092da:	bb75      	cbnz	r5, 800933a <HAL_RCCEx_PeriphCLKConfig+0x162>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 80092dc:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80092e0:	4a7e      	ldr	r2, [pc, #504]	; (80094dc <HAL_RCCEx_PeriphCLKConfig+0x304>)

      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 80092e2:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 80092e6:	d015      	beq.n	8009314 <HAL_RCCEx_PeriphCLKConfig+0x13c>
 80092e8:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
 80092ec:	428b      	cmp	r3, r1
 80092ee:	d011      	beq.n	8009314 <HAL_RCCEx_PeriphCLKConfig+0x13c>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 80092f0:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 80092f4:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
 80092f8:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
 80092fc:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 8009300:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);

      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8009304:	f423 7340 	bic.w	r3, r3, #768	; 0x300
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
        __HAL_RCC_BACKUPRESET_RELEASE();
 8009308:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 800930c:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
 8009310:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8009314:	07dd      	lsls	r5, r3, #31
 8009316:	f140 815d 	bpl.w	80095d4 <HAL_RCCEx_PeriphCLKConfig+0x3fc>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800931a:	f7fd fe77 	bl	800700c <HAL_GetTick>

        /* Wait till LSE is ready */
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800931e:	f241 3988 	movw	r9, #5000	; 0x1388

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8009322:	4605      	mov	r5, r0

        /* Wait till LSE is ready */
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8009324:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8009328:	0798      	lsls	r0, r3, #30
 800932a:	f100 8153 	bmi.w	80095d4 <HAL_RCCEx_PeriphCLKConfig+0x3fc>
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800932e:	f7fd fe6d 	bl	800700c <HAL_GetTick>
 8009332:	1b40      	subs	r0, r0, r5
 8009334:	4548      	cmp	r0, r9
 8009336:	d9f5      	bls.n	8009324 <HAL_RCCEx_PeriphCLKConfig+0x14c>

    while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == 0U)
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
      {
        ret = HAL_TIMEOUT;
 8009338:	2503      	movs	r5, #3
      /* set overall return value */
      status = ret;
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 800933a:	f1b8 0f00 	cmp.w	r8, #0
 800933e:	d005      	beq.n	800934c <HAL_RCCEx_PeriphCLKConfig+0x174>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8009340:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8009342:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8009346:	65bb      	str	r3, [r7, #88]	; 0x58
 8009348:	e000      	b.n	800934c <HAL_RCCEx_PeriphCLKConfig+0x174>
 800934a:	4635      	mov	r5, r6
    }
  }

  /*-------------------------- USART1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 800934c:	6823      	ldr	r3, [r4, #0]
 800934e:	07d9      	lsls	r1, r3, #31
 8009350:	d508      	bpl.n	8009364 <HAL_RCCEx_PeriphCLKConfig+0x18c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8009352:	4862      	ldr	r0, [pc, #392]	; (80094dc <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8009354:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8009358:	f022 0103 	bic.w	r1, r2, #3
 800935c:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800935e:	430a      	orrs	r2, r1
 8009360:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- USART2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8009364:	079a      	lsls	r2, r3, #30
 8009366:	d508      	bpl.n	800937a <HAL_RCCEx_PeriphCLKConfig+0x1a2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8009368:	485c      	ldr	r0, [pc, #368]	; (80094dc <HAL_RCCEx_PeriphCLKConfig+0x304>)
 800936a:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 800936e:	f022 010c 	bic.w	r1, r2, #12
 8009372:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8009374:	430a      	orrs	r2, r1
 8009376:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

#if defined(USART3)

  /*-------------------------- USART3 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 800937a:	075f      	lsls	r7, r3, #29
 800937c:	d508      	bpl.n	8009390 <HAL_RCCEx_PeriphCLKConfig+0x1b8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 800937e:	4857      	ldr	r0, [pc, #348]	; (80094dc <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8009380:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8009384:	f022 0130 	bic.w	r1, r2, #48	; 0x30
 8009388:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800938a:	430a      	orrs	r2, r1
 800938c:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
#endif /* USART3 */

#if defined(UART4)

  /*-------------------------- UART4 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8009390:	071e      	lsls	r6, r3, #28
 8009392:	d508      	bpl.n	80093a6 <HAL_RCCEx_PeriphCLKConfig+0x1ce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8009394:	4851      	ldr	r0, [pc, #324]	; (80094dc <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8009396:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 800939a:	f022 01c0 	bic.w	r1, r2, #192	; 0xc0
 800939e:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 80093a0:	430a      	orrs	r2, r1
 80093a2:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
#endif /* UART4 */

#if defined(UART5)

  /*-------------------------- UART5 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 80093a6:	06d8      	lsls	r0, r3, #27
 80093a8:	d508      	bpl.n	80093bc <HAL_RCCEx_PeriphCLKConfig+0x1e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 80093aa:	484c      	ldr	r0, [pc, #304]	; (80094dc <HAL_RCCEx_PeriphCLKConfig+0x304>)
 80093ac:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 80093b0:	f422 7140 	bic.w	r1, r2, #768	; 0x300
 80093b4:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 80093b6:	430a      	orrs	r2, r1
 80093b8:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

#endif /* UART5 */

  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 80093bc:	0699      	lsls	r1, r3, #26
 80093be:	d508      	bpl.n	80093d2 <HAL_RCCEx_PeriphCLKConfig+0x1fa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUART1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 80093c0:	4846      	ldr	r0, [pc, #280]	; (80094dc <HAL_RCCEx_PeriphCLKConfig+0x304>)
 80093c2:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 80093c6:	f422 6140 	bic.w	r1, r2, #3072	; 0xc00
 80093ca:	6d22      	ldr	r2, [r4, #80]	; 0x50
 80093cc:	430a      	orrs	r2, r1
 80093ce:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- LPTIM1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 80093d2:	059a      	lsls	r2, r3, #22
 80093d4:	d508      	bpl.n	80093e8 <HAL_RCCEx_PeriphCLKConfig+0x210>
  {
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 80093d6:	4841      	ldr	r0, [pc, #260]	; (80094dc <HAL_RCCEx_PeriphCLKConfig+0x304>)
 80093d8:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 80093dc:	f422 2140 	bic.w	r1, r2, #786432	; 0xc0000
 80093e0:	6e62      	ldr	r2, [r4, #100]	; 0x64
 80093e2:	430a      	orrs	r2, r1
 80093e4:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- LPTIM2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 80093e8:	055f      	lsls	r7, r3, #21
 80093ea:	d508      	bpl.n	80093fe <HAL_RCCEx_PeriphCLKConfig+0x226>
  {
    assert_param(IS_RCC_LPTIM2CLK(PeriphClkInit->Lptim2ClockSelection));
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 80093ec:	483b      	ldr	r0, [pc, #236]	; (80094dc <HAL_RCCEx_PeriphCLKConfig+0x304>)
 80093ee:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 80093f2:	f422 1140 	bic.w	r1, r2, #3145728	; 0x300000
 80093f6:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 80093f8:	430a      	orrs	r2, r1
 80093fa:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 80093fe:	065e      	lsls	r6, r3, #25
 8009400:	d508      	bpl.n	8009414 <HAL_RCCEx_PeriphCLKConfig+0x23c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8009402:	4836      	ldr	r0, [pc, #216]	; (80094dc <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8009404:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8009408:	f422 5140 	bic.w	r1, r2, #12288	; 0x3000
 800940c:	6d62      	ldr	r2, [r4, #84]	; 0x54
 800940e:	430a      	orrs	r2, r1
 8009410:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

#if defined(I2C2)

  /*-------------------------- I2C2 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8009414:	0618      	lsls	r0, r3, #24
 8009416:	d508      	bpl.n	800942a <HAL_RCCEx_PeriphCLKConfig+0x252>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8009418:	4830      	ldr	r0, [pc, #192]	; (80094dc <HAL_RCCEx_PeriphCLKConfig+0x304>)
 800941a:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 800941e:	f422 4140 	bic.w	r1, r2, #49152	; 0xc000
 8009422:	6da2      	ldr	r2, [r4, #88]	; 0x58
 8009424:	430a      	orrs	r2, r1
 8009426:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

#endif /* I2C2 */

  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 800942a:	05d9      	lsls	r1, r3, #23
 800942c:	d508      	bpl.n	8009440 <HAL_RCCEx_PeriphCLKConfig+0x268>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 800942e:	482b      	ldr	r0, [pc, #172]	; (80094dc <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8009430:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8009434:	f422 3140 	bic.w	r1, r2, #196608	; 0x30000
 8009438:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 800943a:	430a      	orrs	r2, r1
 800943c:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  }

#if defined(I2C4)

  /*-------------------------- I2C4 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8009440:	02da      	lsls	r2, r3, #11
 8009442:	d508      	bpl.n	8009456 <HAL_RCCEx_PeriphCLKConfig+0x27e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8009444:	4825      	ldr	r0, [pc, #148]	; (80094dc <HAL_RCCEx_PeriphCLKConfig+0x304>)
 8009446:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
 800944a:	f022 0103 	bic.w	r1, r2, #3
 800944e:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8009450:	430a      	orrs	r2, r1
 8009452:	f8c0 209c 	str.w	r2, [r0, #156]	; 0x9c
#endif /* I2C4 */

#if defined(USB_OTG_FS) || defined(USB)

  /*-------------------------- USB clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 8009456:	049b      	lsls	r3, r3, #18
 8009458:	d51a      	bpl.n	8009490 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 800945a:	4a20      	ldr	r2, [pc, #128]	; (80094dc <HAL_RCCEx_PeriphCLKConfig+0x304>)
 800945c:	6f61      	ldr	r1, [r4, #116]	; 0x74
 800945e:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8009462:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 8009466:	430b      	orrs	r3, r1

    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8009468:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000

  /*-------------------------- USB clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 800946c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8009470:	d104      	bne.n	800947c <HAL_RCCEx_PeriphCLKConfig+0x2a4>
    {
      /* Enable PLL48M1CLK output clock */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8009472:	68d3      	ldr	r3, [r2, #12]
 8009474:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8009478:	60d3      	str	r3, [r2, #12]
 800947a:	e009      	b.n	8009490 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
    }
    else
    {
#if defined(RCC_PLLSAI1_SUPPORT)
      if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 800947c:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 8009480:	d106      	bne.n	8009490 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
      {
        /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8009482:	2101      	movs	r1, #1
 8009484:	1d20      	adds	r0, r4, #4
 8009486:	f7ff fdad 	bl	8008fe4 <RCCEx_PLLSAI1_Config>
 800948a:	2800      	cmp	r0, #0
 800948c:	bf18      	it	ne
 800948e:	4605      	movne	r5, r0
#endif /* USB_OTG_FS || USB */

#if defined(SDMMC1)

  /*-------------------------- SDMMC1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
 8009490:	6823      	ldr	r3, [r4, #0]
 8009492:	031f      	lsls	r7, r3, #12
 8009494:	d530      	bpl.n	80094f8 <HAL_RCCEx_PeriphCLKConfig+0x320>
  {
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8009496:	6fa1      	ldr	r1, [r4, #120]	; 0x78
 8009498:	4b10      	ldr	r3, [pc, #64]	; (80094dc <HAL_RCCEx_PeriphCLKConfig+0x304>)
 800949a:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
 800949e:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 80094a2:	d107      	bne.n	80094b4 <HAL_RCCEx_PeriphCLKConfig+0x2dc>
 80094a4:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80094a8:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
    }
#if defined(RCC_CCIPR2_SDMMCSEL)
    else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLP) /* PLL "P" ? */
    {
      /* Enable PLLSAI3CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 80094ac:	68da      	ldr	r2, [r3, #12]
 80094ae:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80094b2:	e010      	b.n	80094d6 <HAL_RCCEx_PeriphCLKConfig+0x2fe>

  /*-------------------------- SDMMC1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
  {
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 80094b4:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 80094b8:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
 80094bc:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80094c0:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 80094c4:	430a      	orrs	r2, r1

    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 80094c6:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000

  /*-------------------------- SDMMC1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
  {
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 80094ca:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 80094ce:	d109      	bne.n	80094e4 <HAL_RCCEx_PeriphCLKConfig+0x30c>
    {
      /* Enable PLL48M1CLK output clock */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 80094d0:	68da      	ldr	r2, [r3, #12]
 80094d2:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 80094d6:	60da      	str	r2, [r3, #12]
 80094d8:	e00e      	b.n	80094f8 <HAL_RCCEx_PeriphCLKConfig+0x320>
 80094da:	bf00      	nop
 80094dc:	40021000 	.word	0x40021000
 80094e0:	40007000 	.word	0x40007000
    {
      /* Enable PLLSAI3CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
    }
#endif
    else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
 80094e4:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 80094e8:	d106      	bne.n	80094f8 <HAL_RCCEx_PeriphCLKConfig+0x320>
    {
      /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 80094ea:	2101      	movs	r1, #1
 80094ec:	1d20      	adds	r0, r4, #4
 80094ee:	f7ff fd79 	bl	8008fe4 <RCCEx_PLLSAI1_Config>
 80094f2:	2800      	cmp	r0, #0
 80094f4:	bf18      	it	ne
 80094f6:	4605      	movne	r5, r0
  }

#endif /* SDMMC1 */

  /*-------------------------- RNG clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 80094f8:	6823      	ldr	r3, [r4, #0]
 80094fa:	035e      	lsls	r6, r3, #13
 80094fc:	d51a      	bpl.n	8009534 <HAL_RCCEx_PeriphCLKConfig+0x35c>
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 80094fe:	4a3d      	ldr	r2, [pc, #244]	; (80095f4 <HAL_RCCEx_PeriphCLKConfig+0x41c>)
 8009500:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 8009502:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8009506:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 800950a:	430b      	orrs	r3, r1

    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 800950c:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000

  /*-------------------------- RNG clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8009510:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8009514:	d104      	bne.n	8009520 <HAL_RCCEx_PeriphCLKConfig+0x348>
    {
      /* Enable PLL48M1CLK output clock */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8009516:	68d3      	ldr	r3, [r2, #12]
 8009518:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800951c:	60d3      	str	r3, [r2, #12]
 800951e:	e009      	b.n	8009534 <HAL_RCCEx_PeriphCLKConfig+0x35c>
    }
#if defined(RCC_PLLSAI1_SUPPORT)
    else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
 8009520:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 8009524:	d106      	bne.n	8009534 <HAL_RCCEx_PeriphCLKConfig+0x35c>
    {
      /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8009526:	2101      	movs	r1, #1
 8009528:	1d20      	adds	r0, r4, #4
 800952a:	f7ff fd5b 	bl	8008fe4 <RCCEx_PLLSAI1_Config>
 800952e:	2800      	cmp	r0, #0
 8009530:	bf18      	it	ne
 8009532:	4605      	movne	r5, r0
    }
  }

  /*-------------------------- ADC clock source configuration ----------------------*/
#if !defined(STM32L412xx) && !defined(STM32L422xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8009534:	6823      	ldr	r3, [r4, #0]
 8009536:	0458      	lsls	r0, r3, #17
 8009538:	d513      	bpl.n	8009562 <HAL_RCCEx_PeriphCLKConfig+0x38a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 800953a:	492e      	ldr	r1, [pc, #184]	; (80095f4 <HAL_RCCEx_PeriphCLKConfig+0x41c>)
 800953c:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 8009540:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8009544:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 8009548:	4313      	orrs	r3, r2

#if defined(RCC_PLLSAI1_SUPPORT)
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 800954a:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 800954e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

#if defined(RCC_PLLSAI1_SUPPORT)
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8009552:	d106      	bne.n	8009562 <HAL_RCCEx_PeriphCLKConfig+0x38a>
    {
      /* PLLSAI1 input clock, parameters M, N & R configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_R_UPDATE);
 8009554:	2102      	movs	r1, #2
 8009556:	1d20      	adds	r0, r4, #4
 8009558:	f7ff fd44 	bl	8008fe4 <RCCEx_PLLSAI1_Config>
 800955c:	2800      	cmp	r0, #0
 800955e:	bf18      	it	ne
 8009560:	4605      	movne	r5, r0
#endif /* SWPMI1 */

#if defined(DFSDM1_Filter0)

  /*-------------------------- DFSDM1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 8009562:	6823      	ldr	r3, [r4, #0]
 8009564:	03d9      	lsls	r1, r3, #15
 8009566:	d509      	bpl.n	800957c <HAL_RCCEx_PeriphCLKConfig+0x3a4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 8009568:	4822      	ldr	r0, [pc, #136]	; (80095f4 <HAL_RCCEx_PeriphCLKConfig+0x41c>)
 800956a:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
 800956e:	f022 0104 	bic.w	r1, r2, #4
 8009572:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
 8009576:	430a      	orrs	r2, r1
 8009578:	f8c0 209c 	str.w	r2, [r0, #156]	; 0x9c
  }

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  /*-------------------------- DFSDM1 audio clock source configuration -------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1AUDIO) == RCC_PERIPHCLK_DFSDM1AUDIO)
 800957c:	029a      	lsls	r2, r3, #10
 800957e:	d509      	bpl.n	8009594 <HAL_RCCEx_PeriphCLKConfig+0x3bc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1AUDIOCLKSOURCE(PeriphClkInit->Dfsdm1AudioClockSelection));

    /* Configure the DFSDM1 interface audio clock source */
    __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);
 8009580:	481c      	ldr	r0, [pc, #112]	; (80095f4 <HAL_RCCEx_PeriphCLKConfig+0x41c>)
 8009582:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
 8009586:	f022 0118 	bic.w	r1, r2, #24
 800958a:	f8d4 2088 	ldr.w	r2, [r4, #136]	; 0x88
 800958e:	430a      	orrs	r2, r1
 8009590:	f8c0 209c 	str.w	r2, [r0, #156]	; 0x9c
#endif /* DSI */

#if defined(OCTOSPI1) || defined(OCTOSPI2)

  /*-------------------------- OctoSPIx clock source configuration ----------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_OSPI) == RCC_PERIPHCLK_OSPI)
 8009594:	01db      	lsls	r3, r3, #7
 8009596:	d528      	bpl.n	80095ea <HAL_RCCEx_PeriphCLKConfig+0x412>
  {
    /* Check the parameters */
    assert_param(IS_RCC_OSPICLKSOURCE(PeriphClkInit->OspiClockSelection));

    /* Configure the OctoSPI clock source */
    __HAL_RCC_OSPI_CONFIG(PeriphClkInit->OspiClockSelection);
 8009598:	4a16      	ldr	r2, [pc, #88]	; (80095f4 <HAL_RCCEx_PeriphCLKConfig+0x41c>)
 800959a:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
 800959e:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 80095a2:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 80095a6:	430b      	orrs	r3, r1

    if(PeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL)
 80095a8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
  {
    /* Check the parameters */
    assert_param(IS_RCC_OSPICLKSOURCE(PeriphClkInit->OspiClockSelection));

    /* Configure the OctoSPI clock source */
    __HAL_RCC_OSPI_CONFIG(PeriphClkInit->OspiClockSelection);
 80095ac:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c

    if(PeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL)
 80095b0:	d11b      	bne.n	80095ea <HAL_RCCEx_PeriphCLKConfig+0x412>
    {
      /* Enable PLL48M1CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 80095b2:	68d3      	ldr	r3, [r2, #12]
 80095b4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80095b8:	60d3      	str	r3, [r2, #12]
    }
  }

#endif /* OCTOSPI1 || OCTOSPI2 */

  return status;
 80095ba:	e016      	b.n	80095ea <HAL_RCCEx_PeriphCLKConfig+0x412>
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 80095bc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80095be:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80095c2:	65bb      	str	r3, [r7, #88]	; 0x58
 80095c4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80095c6:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80095ca:	9301      	str	r3, [sp, #4]
 80095cc:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 80095ce:	f04f 0801 	mov.w	r8, #1
 80095d2:	e66c      	b.n	80092ae <HAL_RCCEx_PeriphCLKConfig+0xd6>
      }

      if(ret == HAL_OK)
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80095d4:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80095d8:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 80095dc:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 80095e0:	4313      	orrs	r3, r2
 80095e2:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 80095e6:	4635      	mov	r5, r6
 80095e8:	e6a7      	b.n	800933a <HAL_RCCEx_PeriphCLKConfig+0x162>
  }

#endif /* OCTOSPI1 || OCTOSPI2 */

  return status;
}
 80095ea:	4628      	mov	r0, r5
 80095ec:	b002      	add	sp, #8
 80095ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80095f2:	bf00      	nop
 80095f4:	40021000 	.word	0x40021000

080095f8 <HAL_RCCEx_GetPeriphCLKConfig>:
                                        RCC_PERIPHCLK_SDMMC1  | RCC_PERIPHCLK_RNG    | RCC_PERIPHCLK_ADC    | RCC_PERIPHCLK_SWPMI1 | RCC_PERIPHCLK_DFSDM1 | \
                                        RCC_PERIPHCLK_RTC ;

#elif defined(STM32L4R5xx) || defined(STM32L4S5xx)

  PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_USART1  | RCC_PERIPHCLK_USART2 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_UART4  | RCC_PERIPHCLK_UART5  | \
 80095f8:	4b5b      	ldr	r3, [pc, #364]	; (8009768 <HAL_RCCEx_GetPeriphCLKConfig+0x170>)
 80095fa:	6003      	str	r3, [r0, #0]

#if defined(RCC_PLLSAI1_SUPPORT)

  /* Get the PLLSAI1 Clock configuration -----------------------------------------------*/

  PeriphClkInit->PLLSAI1.PLLSAI1Source = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC) >> RCC_PLLCFGR_PLLSRC_Pos;
 80095fc:	4b5b      	ldr	r3, [pc, #364]	; (800976c <HAL_RCCEx_GetPeriphCLKConfig+0x174>)
 80095fe:	68d9      	ldr	r1, [r3, #12]
 8009600:	f001 0103 	and.w	r1, r1, #3
 8009604:	6041      	str	r1, [r0, #4]
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
  PeriphClkInit->PLLSAI1.PLLSAI1M = (READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U;
 8009606:	691a      	ldr	r2, [r3, #16]
 8009608:	f3c2 1203 	ubfx	r2, r2, #4, #4
 800960c:	3201      	adds	r2, #1
 800960e:	6082      	str	r2, [r0, #8]
#else
  PeriphClkInit->PLLSAI1.PLLSAI1M = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U;
#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
  PeriphClkInit->PLLSAI1.PLLSAI1N = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
 8009610:	691a      	ldr	r2, [r3, #16]
 8009612:	f3c2 2206 	ubfx	r2, r2, #8, #7
 8009616:	60c2      	str	r2, [r0, #12]
  PeriphClkInit->PLLSAI1.PLLSAI1P = ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1P) >> RCC_PLLSAI1CFGR_PLLSAI1P_Pos) << 4U) + 7U;
 8009618:	691a      	ldr	r2, [r3, #16]
 800961a:	0b52      	lsrs	r2, r2, #13
 800961c:	f002 0210 	and.w	r2, r2, #16
 8009620:	3207      	adds	r2, #7
 8009622:	6102      	str	r2, [r0, #16]
  PeriphClkInit->PLLSAI1.PLLSAI1Q = ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) * 2U;
 8009624:	691a      	ldr	r2, [r3, #16]
 8009626:	f3c2 5241 	ubfx	r2, r2, #21, #2
 800962a:	3201      	adds	r2, #1
 800962c:	0052      	lsls	r2, r2, #1
 800962e:	6142      	str	r2, [r0, #20]
  PeriphClkInit->PLLSAI1.PLLSAI1R = ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1R) >> RCC_PLLSAI1CFGR_PLLSAI1R_Pos) + 1U) * 2U;
 8009630:	691a      	ldr	r2, [r3, #16]

#if defined(RCC_PLLSAI2_SUPPORT)

  /* Get the PLLSAI2 Clock configuration -----------------------------------------------*/

  PeriphClkInit->PLLSAI2.PLLSAI2Source = PeriphClkInit->PLLSAI1.PLLSAI1Source;
 8009632:	6201      	str	r1, [r0, #32]
  PeriphClkInit->PLLSAI1.PLLSAI1M = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U;
#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
  PeriphClkInit->PLLSAI1.PLLSAI1N = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
  PeriphClkInit->PLLSAI1.PLLSAI1P = ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1P) >> RCC_PLLSAI1CFGR_PLLSAI1P_Pos) << 4U) + 7U;
  PeriphClkInit->PLLSAI1.PLLSAI1Q = ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) * 2U;
  PeriphClkInit->PLLSAI1.PLLSAI1R = ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1R) >> RCC_PLLSAI1CFGR_PLLSAI1R_Pos) + 1U) * 2U;
 8009634:	f3c2 6241 	ubfx	r2, r2, #25, #2
 8009638:	3201      	adds	r2, #1
 800963a:	0052      	lsls	r2, r2, #1
 800963c:	6182      	str	r2, [r0, #24]

  /* Get the PLLSAI2 Clock configuration -----------------------------------------------*/

  PeriphClkInit->PLLSAI2.PLLSAI2Source = PeriphClkInit->PLLSAI1.PLLSAI1Source;
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
  PeriphClkInit->PLLSAI2.PLLSAI2M = (READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2M) >> RCC_PLLSAI2CFGR_PLLSAI2M_Pos) + 1U;
 800963e:	695a      	ldr	r2, [r3, #20]
 8009640:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8009644:	3201      	adds	r2, #1
 8009646:	6242      	str	r2, [r0, #36]	; 0x24
#else
  PeriphClkInit->PLLSAI2.PLLSAI2M = PeriphClkInit->PLLSAI1.PLLSAI1M;
#endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
  PeriphClkInit->PLLSAI2.PLLSAI2N = READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2N) >> RCC_PLLSAI2CFGR_PLLSAI2N_Pos;
 8009648:	695a      	ldr	r2, [r3, #20]
 800964a:	f3c2 2206 	ubfx	r2, r2, #8, #7
 800964e:	6282      	str	r2, [r0, #40]	; 0x28
  PeriphClkInit->PLLSAI2.PLLSAI2P = ((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2P) >> RCC_PLLSAI2CFGR_PLLSAI2P_Pos) << 4U) + 7U;
 8009650:	695a      	ldr	r2, [r3, #20]
 8009652:	0b52      	lsrs	r2, r2, #13
 8009654:	f002 0210 	and.w	r2, r2, #16
 8009658:	3207      	adds	r2, #7
 800965a:	62c2      	str	r2, [r0, #44]	; 0x2c
#if defined(RCC_PLLSAI2Q_DIV_SUPPORT)
  PeriphClkInit->PLLSAI2.PLLSAI2Q = ((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2Q) >> RCC_PLLSAI2CFGR_PLLSAI2Q_Pos) + 1U) * 2U;
 800965c:	695a      	ldr	r2, [r3, #20]
 800965e:	f3c2 5241 	ubfx	r2, r2, #21, #2
 8009662:	3201      	adds	r2, #1
 8009664:	0052      	lsls	r2, r2, #1
 8009666:	6302      	str	r2, [r0, #48]	; 0x30
#endif /* RCC_PLLSAI2Q_DIV_SUPPORT */
  PeriphClkInit->PLLSAI2.PLLSAI2R = ((READ_BIT(RCC->PLLSAI2CFGR, RCC_PLLSAI2CFGR_PLLSAI2R)>> RCC_PLLSAI2CFGR_PLLSAI2R_Pos) + 1U) * 2U;
 8009668:	695a      	ldr	r2, [r3, #20]
 800966a:	f3c2 6241 	ubfx	r2, r2, #25, #2
 800966e:	3201      	adds	r2, #1
 8009670:	0052      	lsls	r2, r2, #1
 8009672:	6342      	str	r2, [r0, #52]	; 0x34

#endif /* RCC_PLLSAI2_SUPPORT */

  /* Get the USART1 clock source ---------------------------------------------*/
  PeriphClkInit->Usart1ClockSelection  = __HAL_RCC_GET_USART1_SOURCE();
 8009674:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8009678:	f002 0203 	and.w	r2, r2, #3
 800967c:	63c2      	str	r2, [r0, #60]	; 0x3c
  /* Get the USART2 clock source ---------------------------------------------*/
  PeriphClkInit->Usart2ClockSelection  = __HAL_RCC_GET_USART2_SOURCE();
 800967e:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8009682:	f002 020c 	and.w	r2, r2, #12
 8009686:	6402      	str	r2, [r0, #64]	; 0x40

#if defined(USART3)
  /* Get the USART3 clock source ---------------------------------------------*/
  PeriphClkInit->Usart3ClockSelection  = __HAL_RCC_GET_USART3_SOURCE();
 8009688:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800968c:	f002 0230 	and.w	r2, r2, #48	; 0x30
 8009690:	6442      	str	r2, [r0, #68]	; 0x44
#endif /* USART3 */

#if defined(UART4)
  /* Get the UART4 clock source ----------------------------------------------*/
  PeriphClkInit->Uart4ClockSelection   = __HAL_RCC_GET_UART4_SOURCE();
 8009692:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8009696:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
 800969a:	6482      	str	r2, [r0, #72]	; 0x48
#endif /* UART4 */

#if defined(UART5)
  /* Get the UART5 clock source ----------------------------------------------*/
  PeriphClkInit->Uart5ClockSelection   = __HAL_RCC_GET_UART5_SOURCE();
 800969c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80096a0:	f402 7240 	and.w	r2, r2, #768	; 0x300
 80096a4:	64c2      	str	r2, [r0, #76]	; 0x4c
#endif /* UART5 */

  /* Get the LPUART1 clock source --------------------------------------------*/
  PeriphClkInit->Lpuart1ClockSelection = __HAL_RCC_GET_LPUART1_SOURCE();
 80096a6:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80096aa:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
 80096ae:	6502      	str	r2, [r0, #80]	; 0x50

  /* Get the I2C1 clock source -----------------------------------------------*/
  PeriphClkInit->I2c1ClockSelection    = __HAL_RCC_GET_I2C1_SOURCE();
 80096b0:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80096b4:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
 80096b8:	6542      	str	r2, [r0, #84]	; 0x54

#if defined(I2C2)
   /* Get the I2C2 clock source ----------------------------------------------*/
  PeriphClkInit->I2c2ClockSelection    = __HAL_RCC_GET_I2C2_SOURCE();
 80096ba:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80096be:	f402 4240 	and.w	r2, r2, #49152	; 0xc000
 80096c2:	6582      	str	r2, [r0, #88]	; 0x58
#endif /* I2C2 */

  /* Get the I2C3 clock source -----------------------------------------------*/
  PeriphClkInit->I2c3ClockSelection    = __HAL_RCC_GET_I2C3_SOURCE();
 80096c4:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80096c8:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 80096cc:	65c2      	str	r2, [r0, #92]	; 0x5c

#if defined(I2C4)
  /* Get the I2C4 clock source -----------------------------------------------*/
  PeriphClkInit->I2c4ClockSelection    = __HAL_RCC_GET_I2C4_SOURCE();
 80096ce:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 80096d2:	f002 0203 	and.w	r2, r2, #3
 80096d6:	6602      	str	r2, [r0, #96]	; 0x60
#endif /* I2C4 */

  /* Get the LPTIM1 clock source ---------------------------------------------*/
  PeriphClkInit->Lptim1ClockSelection  = __HAL_RCC_GET_LPTIM1_SOURCE();
 80096d8:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80096dc:	f402 2240 	and.w	r2, r2, #786432	; 0xc0000
 80096e0:	6642      	str	r2, [r0, #100]	; 0x64

  /* Get the LPTIM2 clock source ---------------------------------------------*/
  PeriphClkInit->Lptim2ClockSelection  = __HAL_RCC_GET_LPTIM2_SOURCE();
 80096e2:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80096e6:	f402 1240 	and.w	r2, r2, #3145728	; 0x300000
 80096ea:	6682      	str	r2, [r0, #104]	; 0x68

#if defined(SAI1)
  /* Get the SAI1 clock source -----------------------------------------------*/
  PeriphClkInit->Sai1ClockSelection    = __HAL_RCC_GET_SAI1_SOURCE();
 80096ec:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 80096f0:	f002 02e0 	and.w	r2, r2, #224	; 0xe0
 80096f4:	66c2      	str	r2, [r0, #108]	; 0x6c
#endif /* SAI1 */

#if defined(SAI2)
  /* Get the SAI2 clock source -----------------------------------------------*/
  PeriphClkInit->Sai2ClockSelection    = __HAL_RCC_GET_SAI2_SOURCE();
 80096f6:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 80096fa:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 80096fe:	6702      	str	r2, [r0, #112]	; 0x70
#endif /* SAI2 */

  /* Get the RTC clock source ------------------------------------------------*/
  PeriphClkInit->RTCClockSelection     = __HAL_RCC_GET_RTC_SOURCE();
 8009700:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8009704:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8009708:	f8c0 2090 	str.w	r2, [r0, #144]	; 0x90

#if defined(USB_OTG_FS) || defined(USB)
  /* Get the USB clock source ------------------------------------------------*/
  PeriphClkInit->UsbClockSelection   = __HAL_RCC_GET_USB_SOURCE();
 800970c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8009710:	f002 6240 	and.w	r2, r2, #201326592	; 0xc000000
 8009714:	6742      	str	r2, [r0, #116]	; 0x74
#endif /* USB_OTG_FS || USB */

#if defined(SDMMC1)
  /* Get the SDMMC1 clock source ---------------------------------------------*/
  PeriphClkInit->Sdmmc1ClockSelection   = __HAL_RCC_GET_SDMMC1_SOURCE();
 8009716:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 800971a:	0452      	lsls	r2, r2, #17
 800971c:	bf56      	itet	pl
 800971e:	f8d3 2088 	ldrpl.w	r2, [r3, #136]	; 0x88
 8009722:	f44f 4280 	movmi.w	r2, #16384	; 0x4000
 8009726:	f002 6240 	andpl.w	r2, r2, #201326592	; 0xc000000
 800972a:	6782      	str	r2, [r0, #120]	; 0x78
#endif /* SDMMC1 */

  /* Get the RNG clock source ------------------------------------------------*/
  PeriphClkInit->RngClockSelection   = __HAL_RCC_GET_RNG_SOURCE();
 800972c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8009730:	f002 6240 	and.w	r2, r2, #201326592	; 0xc000000
 8009734:	67c2      	str	r2, [r0, #124]	; 0x7c

#if !defined(STM32L412xx) && !defined(STM32L422xx)
  /* Get the ADC clock source ------------------------------------------------*/
  PeriphClkInit->AdcClockSelection     = __HAL_RCC_GET_ADC_SOURCE();
 8009736:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800973a:	f002 5240 	and.w	r2, r2, #805306368	; 0x30000000
 800973e:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
  PeriphClkInit->Swpmi1ClockSelection  = __HAL_RCC_GET_SWPMI1_SOURCE();
#endif /* SWPMI1 */

#if defined(DFSDM1_Filter0)
  /* Get the DFSDM1 clock source ---------------------------------------------*/
  PeriphClkInit->Dfsdm1ClockSelection  = __HAL_RCC_GET_DFSDM1_SOURCE();
 8009742:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 8009746:	f002 0204 	and.w	r2, r2, #4
 800974a:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84

#if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  /* Get the DFSDM1 audio clock source ---------------------------------------*/
  PeriphClkInit->Dfsdm1AudioClockSelection  = __HAL_RCC_GET_DFSDM1AUDIO_SOURCE();
 800974e:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 8009752:	f002 0218 	and.w	r2, r2, #24
 8009756:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  PeriphClkInit->DsiClockSelection = __HAL_RCC_GET_DSI_SOURCE();
#endif /* DSI */

#if defined(OCTOSPI1) || defined(OCTOSPI2)
  /* Get the OctoSPIclock source --------------------------------------------*/
  PeriphClkInit->OspiClockSelection = __HAL_RCC_GET_OSPI_SOURCE();
 800975a:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800975e:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 8009762:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
 8009766:	4770      	bx	lr
 8009768:	013f7fff 	.word	0x013f7fff
 800976c:	40021000 	.word	0x40021000

08009770 <HAL_RCCEx_GetPeriphCLKFreq>:
#endif

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));

  if(PeriphClk == RCC_PERIPHCLK_RTC)
 8009770:	f5b0 3f00 	cmp.w	r0, #131072	; 0x20000
 8009774:	4bbc      	ldr	r3, [pc, #752]	; (8009a68 <HAL_RCCEx_GetPeriphCLKFreq+0x2f8>)
 8009776:	d112      	bne.n	800979e <HAL_RCCEx_GetPeriphCLKFreq+0x2e>
  {
    /* Get the current RTC source */
    srcclk = __HAL_RCC_GET_RTC_SOURCE();
 8009778:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90

    switch(srcclk)
 800977c:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8009780:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8009784:	f000 820a 	beq.w	8009b9c <HAL_RCCEx_GetPeriphCLKFreq+0x42c>
 8009788:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 800978c:	d002      	beq.n	8009794 <HAL_RCCEx_GetPeriphCLKFreq+0x24>
 800978e:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8009792:	e200      	b.n	8009b96 <HAL_RCCEx_GetPeriphCLKFreq+0x426>
        }
      }
      break;
    case RCC_RTCCLKSOURCE_HSE_DIV32:
      /* Check if HSE is ready */
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 8009794:	681b      	ldr	r3, [r3, #0]
      {
        frequency = HSE_VALUE / 32U;
 8009796:	48b5      	ldr	r0, [pc, #724]	; (8009a6c <HAL_RCCEx_GetPeriphCLKFreq+0x2fc>)
 8009798:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 800979c:	e228      	b.n	8009bf0 <HAL_RCCEx_GetPeriphCLKFreq+0x480>
    }
  }
  else
  {
    /* Other external peripheral clock source than RTC */
    pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 800979e:	68da      	ldr	r2, [r3, #12]

    /* Compute PLL clock input */
    switch(pll_oscsource)
 80097a0:	f002 0203 	and.w	r2, r2, #3
 80097a4:	2a02      	cmp	r2, #2
 80097a6:	d015      	beq.n	80097d4 <HAL_RCCEx_GetPeriphCLKFreq+0x64>
 80097a8:	2a03      	cmp	r2, #3
 80097aa:	d018      	beq.n	80097de <HAL_RCCEx_GetPeriphCLKFreq+0x6e>
 80097ac:	2a01      	cmp	r2, #1
 80097ae:	d11d      	bne.n	80097ec <HAL_RCCEx_GetPeriphCLKFreq+0x7c>
    {
    case RCC_PLLSOURCE_MSI:   /* MSI ? */
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIRDY))
 80097b0:	6819      	ldr	r1, [r3, #0]
 80097b2:	f011 0102 	ands.w	r1, r1, #2
 80097b6:	d01a      	beq.n	80097ee <HAL_RCCEx_GetPeriphCLKFreq+0x7e>
      {
        /*MSI frequency range in HZ*/
        pllvco = MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> 4U)];
 80097b8:	681a      	ldr	r2, [r3, #0]
 80097ba:	49ad      	ldr	r1, [pc, #692]	; (8009a70 <HAL_RCCEx_GetPeriphCLKFreq+0x300>)
 80097bc:	0712      	lsls	r2, r2, #28
 80097be:	bf4b      	itete	mi
 80097c0:	681a      	ldrmi	r2, [r3, #0]
 80097c2:	f8d3 2094 	ldrpl.w	r2, [r3, #148]	; 0x94
 80097c6:	f3c2 1203 	ubfxmi	r2, r2, #4, #4
 80097ca:	f3c2 2203 	ubfxpl	r2, r2, #8, #4
 80097ce:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
 80097d2:	e00c      	b.n	80097ee <HAL_RCCEx_GetPeriphCLKFreq+0x7e>
      {
        pllvco = 0U;
      }
      break;
    case RCC_PLLSOURCE_HSI:   /* HSI ? */
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 80097d4:	681a      	ldr	r2, [r3, #0]
      {
        pllvco = HSI_VALUE;
 80097d6:	49a7      	ldr	r1, [pc, #668]	; (8009a74 <HAL_RCCEx_GetPeriphCLKFreq+0x304>)
 80097d8:	f412 6f80 	tst.w	r2, #1024	; 0x400
 80097dc:	e003      	b.n	80097e6 <HAL_RCCEx_GetPeriphCLKFreq+0x76>
      {
        pllvco = 0U;
      }
      break;
    case RCC_PLLSOURCE_HSE:   /* HSE ? */
      if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 80097de:	681a      	ldr	r2, [r3, #0]
      {
        pllvco = HSE_VALUE;
 80097e0:	49a5      	ldr	r1, [pc, #660]	; (8009a78 <HAL_RCCEx_GetPeriphCLKFreq+0x308>)
 80097e2:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 80097e6:	bf08      	it	eq
 80097e8:	2100      	moveq	r1, #0
 80097ea:	e000      	b.n	80097ee <HAL_RCCEx_GetPeriphCLKFreq+0x7e>
        pllvco = 0U;
      }
      break;
    default:
      /* No source */
      pllvco = 0U;
 80097ec:	2100      	movs	r1, #0
      break;
    }

    switch(PeriphClk)
 80097ee:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 80097f2:	f000 81db 	beq.w	8009bac <HAL_RCCEx_GetPeriphCLKFreq+0x43c>
 80097f6:	d826      	bhi.n	8009846 <HAL_RCCEx_GetPeriphCLKFreq+0xd6>
 80097f8:	2810      	cmp	r0, #16
 80097fa:	f000 8123 	beq.w	8009a44 <HAL_RCCEx_GetPeriphCLKFreq+0x2d4>
 80097fe:	d80e      	bhi.n	800981e <HAL_RCCEx_GetPeriphCLKFreq+0xae>
 8009800:	2802      	cmp	r0, #2
 8009802:	f000 80ed 	beq.w	80099e0 <HAL_RCCEx_GetPeriphCLKFreq+0x270>
 8009806:	d803      	bhi.n	8009810 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
 8009808:	2801      	cmp	r0, #1
 800980a:	f000 80da 	beq.w	80099c2 <HAL_RCCEx_GetPeriphCLKFreq+0x252>
 800980e:	e238      	b.n	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 8009810:	2804      	cmp	r0, #4
 8009812:	f000 80fb 	beq.w	8009a0c <HAL_RCCEx_GetPeriphCLKFreq+0x29c>
 8009816:	2808      	cmp	r0, #8
 8009818:	f000 8106 	beq.w	8009a28 <HAL_RCCEx_GetPeriphCLKFreq+0x2b8>
 800981c:	e231      	b.n	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 800981e:	2880      	cmp	r0, #128	; 0x80
 8009820:	f000 8189 	beq.w	8009b36 <HAL_RCCEx_GetPeriphCLKFreq+0x3c6>
 8009824:	d806      	bhi.n	8009834 <HAL_RCCEx_GetPeriphCLKFreq+0xc4>
 8009826:	2820      	cmp	r0, #32
 8009828:	f000 812a 	beq.w	8009a80 <HAL_RCCEx_GetPeriphCLKFreq+0x310>
 800982c:	2840      	cmp	r0, #64	; 0x40
 800982e:	f000 8177 	beq.w	8009b20 <HAL_RCCEx_GetPeriphCLKFreq+0x3b0>
 8009832:	e226      	b.n	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 8009834:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 8009838:	f000 8187 	beq.w	8009b4a <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
 800983c:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8009840:	f000 819a 	beq.w	8009b78 <HAL_RCCEx_GetPeriphCLKFreq+0x408>
 8009844:	e21d      	b.n	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 8009846:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 800984a:	f000 814e 	beq.w	8009aea <HAL_RCCEx_GetPeriphCLKFreq+0x37a>
 800984e:	d811      	bhi.n	8009874 <HAL_RCCEx_GetPeriphCLKFreq+0x104>
 8009850:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
 8009854:	f000 815e 	beq.w	8009b14 <HAL_RCCEx_GetPeriphCLKFreq+0x3a4>
 8009858:	d804      	bhi.n	8009864 <HAL_RCCEx_GetPeriphCLKFreq+0xf4>
 800985a:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
 800985e:	f000 8159 	beq.w	8009b14 <HAL_RCCEx_GetPeriphCLKFreq+0x3a4>
 8009862:	e20e      	b.n	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 8009864:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
 8009868:	d019      	beq.n	800989e <HAL_RCCEx_GetPeriphCLKFreq+0x12e>
 800986a:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
 800986e:	f000 8117 	beq.w	8009aa0 <HAL_RCCEx_GetPeriphCLKFreq+0x330>
 8009872:	e206      	b.n	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 8009874:	f5b0 1f80 	cmp.w	r0, #1048576	; 0x100000
 8009878:	f000 8172 	beq.w	8009b60 <HAL_RCCEx_GetPeriphCLKFreq+0x3f0>
 800987c:	d806      	bhi.n	800988c <HAL_RCCEx_GetPeriphCLKFreq+0x11c>
 800987e:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
 8009882:	d00c      	beq.n	800989e <HAL_RCCEx_GetPeriphCLKFreq+0x12e>
 8009884:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
 8009888:	d025      	beq.n	80098d6 <HAL_RCCEx_GetPeriphCLKFreq+0x166>
 800988a:	e1fa      	b.n	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 800988c:	f5b0 1f00 	cmp.w	r0, #2097152	; 0x200000
 8009890:	f000 8132 	beq.w	8009af8 <HAL_RCCEx_GetPeriphCLKFreq+0x388>
 8009894:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8009898:	f000 81b6 	beq.w	8009c08 <HAL_RCCEx_GetPeriphCLKFreq+0x498>
 800989c:	e1f1      	b.n	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>

    case RCC_PERIPHCLK_SDMMC1:

#endif /* SDMMC1 && !RCC_CCIPR2_SDMMCSEL */
      {
        srcclk = READ_BIT(RCC->CCIPR, RCC_CCIPR_CLK48SEL);
 800989e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80098a2:	4a71      	ldr	r2, [pc, #452]	; (8009a68 <HAL_RCCEx_GetPeriphCLKFreq+0x2f8>)

        switch(srcclk)
 80098a4:	f003 6340 	and.w	r3, r3, #201326592	; 0xc000000
 80098a8:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 80098ac:	d011      	beq.n	80098d2 <HAL_RCCEx_GetPeriphCLKFreq+0x162>
 80098ae:	d805      	bhi.n	80098bc <HAL_RCCEx_GetPeriphCLKFreq+0x14c>
 80098b0:	2b00      	cmp	r3, #0
 80098b2:	f040 81e6 	bne.w	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
          }
          break;
#endif /* RCC_PLLSAI1_SUPPORT */
#if defined(RCC_HSI48_SUPPORT)
        case 0U:
          if(HAL_IS_BIT_SET(RCC->CRRCR, RCC_CRRCR_HSI48RDY)) /* HSI48 ? */
 80098b6:	f8d2 3098 	ldr.w	r3, [r2, #152]	; 0x98
 80098ba:	e07e      	b.n	80099ba <HAL_RCCEx_GetPeriphCLKFreq+0x24a>

#endif /* SDMMC1 && !RCC_CCIPR2_SDMMCSEL */
      {
        srcclk = READ_BIT(RCC->CCIPR, RCC_CCIPR_CLK48SEL);

        switch(srcclk)
 80098bc:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 80098c0:	d005      	beq.n	80098ce <HAL_RCCEx_GetPeriphCLKFreq+0x15e>
 80098c2:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
 80098c6:	f040 81dc 	bne.w	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
        {
        case RCC_CCIPR_CLK48SEL:   /* MSI ? */
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIRDY))
 80098ca:	6810      	ldr	r0, [r2, #0]
 80098cc:	e040      	b.n	8009950 <HAL_RCCEx_GetPeriphCLKFreq+0x1e0>
            /*MSI frequency range in HZ*/
            frequency = MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> 4U)];
          }
          break;
        case RCC_CCIPR_CLK48SEL_1:  /* PLL ? */
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY))
 80098ce:	6813      	ldr	r3, [r2, #0]
 80098d0:	e046      	b.n	8009960 <HAL_RCCEx_GetPeriphCLKFreq+0x1f0>
            }
          }
          break;
#if defined(RCC_PLLSAI1_SUPPORT)
        case RCC_CCIPR_CLK48SEL_0:  /* PLLSAI1 ? */
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI1RDY))
 80098d2:	6813      	ldr	r3, [r2, #0]
 80098d4:	e056      	b.n	8009984 <HAL_RCCEx_GetPeriphCLKFreq+0x214>

#if defined(SDMMC1) && defined(RCC_CCIPR2_SDMMCSEL)

    case RCC_PERIPHCLK_SDMMC1:

      if(HAL_IS_BIT_SET(RCC->CCIPR2, RCC_CCIPR2_SDMMCSEL))  /* PLL "P" ? */
 80098d6:	f8d3 009c 	ldr.w	r0, [r3, #156]	; 0x9c
 80098da:	4a63      	ldr	r2, [pc, #396]	; (8009a68 <HAL_RCCEx_GetPeriphCLKFreq+0x2f8>)
 80098dc:	0440      	lsls	r0, r0, #17
 80098de:	d51d      	bpl.n	800991c <HAL_RCCEx_GetPeriphCLKFreq+0x1ac>
      {
        if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY))
 80098e0:	6812      	ldr	r2, [r2, #0]
 80098e2:	0192      	lsls	r2, r2, #6
 80098e4:	f140 81cd 	bpl.w	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
        {
          if(HAL_IS_BIT_SET(RCC->PLLCFGR, RCC_PLLCFGR_PLLPEN))
 80098e8:	68db      	ldr	r3, [r3, #12]
 80098ea:	4a5f      	ldr	r2, [pc, #380]	; (8009a68 <HAL_RCCEx_GetPeriphCLKFreq+0x2f8>)
 80098ec:	f413 3080 	ands.w	r0, r3, #65536	; 0x10000
 80098f0:	f000 81c8 	beq.w	8009c84 <HAL_RCCEx_GetPeriphCLKFreq+0x514>
          {
            /* f(PLL Source) * PLLN / PLLM */
            plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
 80098f4:	68d0      	ldr	r0, [r2, #12]
            pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 80098f6:	f3c0 2006 	ubfx	r0, r0, #8, #7
 80098fa:	4341      	muls	r1, r0
 80098fc:	68d0      	ldr	r0, [r2, #12]
 80098fe:	f3c0 1003 	ubfx	r0, r0, #4, #4
 8009902:	3001      	adds	r0, #1
 8009904:	fbb1 f1f0 	udiv	r1, r1, r0
            /* f(PLLSAI3CLK) = f(VCO input) / PLLP */
            pllp = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLPDIV) >> RCC_PLLCFGR_PLLPDIV_Pos;
 8009908:	68d0      	ldr	r0, [r2, #12]
            if(pllp == 0U)
 800990a:	0ec0      	lsrs	r0, r0, #27
 800990c:	d152      	bne.n	80099b4 <HAL_RCCEx_GetPeriphCLKFreq+0x244>
            {
              if(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP) != 0U)
 800990e:	68d3      	ldr	r3, [r2, #12]
              {
                pllp = 17U;
              }
              else
              {
                pllp = 7U;
 8009910:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8009914:	bf14      	ite	ne
 8009916:	2011      	movne	r0, #17
 8009918:	2007      	moveq	r0, #7
 800991a:	e04b      	b.n	80099b4 <HAL_RCCEx_GetPeriphCLKFreq+0x244>
          }
        }
      }
      else  /* 48MHz from PLL "Q" or MSI or PLLSAI1Q or HSI48 */
      {
        srcclk = READ_BIT(RCC->CCIPR, RCC_CCIPR_CLK48SEL);
 800991c:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88

        switch(srcclk)
 8009920:	f002 6240 	and.w	r2, r2, #201326592	; 0xc000000
 8009924:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
 8009928:	d02a      	beq.n	8009980 <HAL_RCCEx_GetPeriphCLKFreq+0x210>
 800992a:	d805      	bhi.n	8009938 <HAL_RCCEx_GetPeriphCLKFreq+0x1c8>
 800992c:	2a00      	cmp	r2, #0
 800992e:	f040 81a8 	bne.w	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
              frequency = (pllvco / (((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) << 1U));
            }
          }
          break;
        case 0U:
          if(HAL_IS_BIT_SET(RCC->CRRCR, RCC_CRRCR_HSI48RDY)) /* HSI48 ? */
 8009932:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8009936:	e040      	b.n	80099ba <HAL_RCCEx_GetPeriphCLKFreq+0x24a>
      }
      else  /* 48MHz from PLL "Q" or MSI or PLLSAI1Q or HSI48 */
      {
        srcclk = READ_BIT(RCC->CCIPR, RCC_CCIPR_CLK48SEL);

        switch(srcclk)
 8009938:	f1b2 6f00 	cmp.w	r2, #134217728	; 0x8000000
 800993c:	d00e      	beq.n	800995c <HAL_RCCEx_GetPeriphCLKFreq+0x1ec>
 800993e:	f1b2 6f40 	cmp.w	r2, #201326592	; 0xc000000
 8009942:	f040 819e 	bne.w	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
        {
        case RCC_CCIPR_CLK48SEL:   /* MSI ? */
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIRDY))
 8009946:	f102 5250 	add.w	r2, r2, #872415232	; 0x34000000
 800994a:	6818      	ldr	r0, [r3, #0]
 800994c:	f502 3204 	add.w	r2, r2, #135168	; 0x21000
 8009950:	f010 0002 	ands.w	r0, r0, #2
 8009954:	f000 8196 	beq.w	8009c84 <HAL_RCCEx_GetPeriphCLKFreq+0x514>
          {
            /*MSI frequency range in HZ*/
            frequency = MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> 4U)];
 8009958:	6813      	ldr	r3, [r2, #0]
 800995a:	e169      	b.n	8009c30 <HAL_RCCEx_GetPeriphCLKFreq+0x4c0>
          }
          break;
        case RCC_CCIPR_CLK48SEL_1:  /* PLL "Q" ? */
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY))
 800995c:	4a42      	ldr	r2, [pc, #264]	; (8009a68 <HAL_RCCEx_GetPeriphCLKFreq+0x2f8>)
 800995e:	681b      	ldr	r3, [r3, #0]
 8009960:	f013 7000 	ands.w	r0, r3, #33554432	; 0x2000000
 8009964:	f000 818e 	beq.w	8009c84 <HAL_RCCEx_GetPeriphCLKFreq+0x514>
          {
            if(HAL_IS_BIT_SET(RCC->PLLCFGR, RCC_PLLCFGR_PLLQEN))
 8009968:	68d3      	ldr	r3, [r2, #12]
 800996a:	f413 1080 	ands.w	r0, r3, #1048576	; 0x100000
 800996e:	f000 8189 	beq.w	8009c84 <HAL_RCCEx_GetPeriphCLKFreq+0x514>
            {
              /* f(PLL Source) * PLLN / PLLM */
              plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
 8009972:	68d0      	ldr	r0, [r2, #12]
              pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 8009974:	68d3      	ldr	r3, [r2, #12]
 8009976:	f3c0 2006 	ubfx	r0, r0, #8, #7
 800997a:	4341      	muls	r1, r0
              /* f(PLL48M1CLK) = f(VCO input) / PLLQ */
              frequency = (pllvco / (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U));
 800997c:	68d0      	ldr	r0, [r2, #12]
 800997e:	e010      	b.n	80099a2 <HAL_RCCEx_GetPeriphCLKFreq+0x232>
            }
          }
          break;
        case RCC_CCIPR_CLK48SEL_0:  /* PLLSAI1 ? */
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI1RDY))
 8009980:	4a39      	ldr	r2, [pc, #228]	; (8009a68 <HAL_RCCEx_GetPeriphCLKFreq+0x2f8>)
 8009982:	681b      	ldr	r3, [r3, #0]
 8009984:	f013 6000 	ands.w	r0, r3, #134217728	; 0x8000000
 8009988:	f000 817c 	beq.w	8009c84 <HAL_RCCEx_GetPeriphCLKFreq+0x514>
          {
            if(HAL_IS_BIT_SET(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1QEN))
 800998c:	6913      	ldr	r3, [r2, #16]
 800998e:	f413 1080 	ands.w	r0, r3, #1048576	; 0x100000
 8009992:	f000 8177 	beq.w	8009c84 <HAL_RCCEx_GetPeriphCLKFreq+0x514>
            {
              /* f(PLLSAI1 Source) * PLLSAI1N / PLLSAI1M */
              plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
 8009996:	6910      	ldr	r0, [r2, #16]
              pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U));
 8009998:	6913      	ldr	r3, [r2, #16]
 800999a:	f3c0 2006 	ubfx	r0, r0, #8, #7
 800999e:	4341      	muls	r1, r0
              /* f(PLL48M2CLK) = f(VCOSAI1 input) / PLLSAI1Q */
              frequency = (pllvco / (((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1Q) >> RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) + 1U) << 1U));
 80099a0:	6910      	ldr	r0, [r2, #16]
 80099a2:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80099a6:	f3c0 5041 	ubfx	r0, r0, #21, #2
 80099aa:	3301      	adds	r3, #1
 80099ac:	fbb1 f1f3 	udiv	r1, r1, r3
 80099b0:	3001      	adds	r0, #1
 80099b2:	0040      	lsls	r0, r0, #1
 80099b4:	fbb1 f0f0 	udiv	r0, r1, r0
 80099b8:	4770      	bx	lr
#endif /* RCC_PLLSAI1_SUPPORT */
#if defined(RCC_HSI48_SUPPORT)
        case 0U:
          if(HAL_IS_BIT_SET(RCC->CRRCR, RCC_CRRCR_HSI48RDY)) /* HSI48 ? */
          {
            frequency = HSI48_VALUE;
 80099ba:	f013 0f02 	tst.w	r3, #2
 80099be:	482f      	ldr	r0, [pc, #188]	; (8009a7c <HAL_RCCEx_GetPeriphCLKFreq+0x30c>)
 80099c0:	e116      	b.n	8009bf0 <HAL_RCCEx_GetPeriphCLKFreq+0x480>
#endif /* SDMMC1 && RCC_CCIPR2_SDMMCSEL */

    case RCC_PERIPHCLK_USART1:
      {
        /* Get the current USART1 source */
        srcclk = __HAL_RCC_GET_USART1_SOURCE();
 80099c2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80099c6:	4a28      	ldr	r2, [pc, #160]	; (8009a68 <HAL_RCCEx_GetPeriphCLKFreq+0x2f8>)

        switch(srcclk)
 80099c8:	f003 0303 	and.w	r3, r3, #3
 80099cc:	2b02      	cmp	r3, #2
 80099ce:	f000 810b 	beq.w	8009be8 <HAL_RCCEx_GetPeriphCLKFreq+0x478>
 80099d2:	2b03      	cmp	r3, #3
 80099d4:	f000 810f 	beq.w	8009bf6 <HAL_RCCEx_GetPeriphCLKFreq+0x486>
 80099d8:	2b01      	cmp	r3, #1
 80099da:	f040 808b 	bne.w	8009af4 <HAL_RCCEx_GetPeriphCLKFreq+0x384>
 80099de:	e11f      	b.n	8009c20 <HAL_RCCEx_GetPeriphCLKFreq+0x4b0>
      }

    case RCC_PERIPHCLK_USART2:
      {
        /* Get the current USART2 source */
        srcclk = __HAL_RCC_GET_USART2_SOURCE();
 80099e0:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88

        switch(srcclk)
 80099e4:	f002 020c 	and.w	r2, r2, #12
 80099e8:	2a0c      	cmp	r2, #12
 80099ea:	f200 814a 	bhi.w	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 80099ee:	e8df f012 	tbh	[pc, r2, lsl #1]
 80099f2:	00f0      	.short	0x00f0
 80099f4:	01480148 	.word	0x01480148
 80099f8:	01170148 	.word	0x01170148
 80099fc:	01480148 	.word	0x01480148
 8009a00:	00d80148 	.word	0x00d80148
 8009a04:	01480148 	.word	0x01480148
 8009a08:	00da0148 	.word	0x00da0148
#if defined(USART3)

    case RCC_PERIPHCLK_USART3:
      {
        /* Get the current USART3 source */
        srcclk = __HAL_RCC_GET_USART3_SOURCE();
 8009a0c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88

        switch(srcclk)
 8009a10:	f002 0230 	and.w	r2, r2, #48	; 0x30
 8009a14:	2a10      	cmp	r2, #16
 8009a16:	f000 8103 	beq.w	8009c20 <HAL_RCCEx_GetPeriphCLKFreq+0x4b0>
 8009a1a:	f240 80b5 	bls.w	8009b88 <HAL_RCCEx_GetPeriphCLKFreq+0x418>
 8009a1e:	2a20      	cmp	r2, #32
 8009a20:	f000 80bf 	beq.w	8009ba2 <HAL_RCCEx_GetPeriphCLKFreq+0x432>
 8009a24:	2a30      	cmp	r2, #48	; 0x30
 8009a26:	e0b6      	b.n	8009b96 <HAL_RCCEx_GetPeriphCLKFreq+0x426>
#if defined(UART4)

    case RCC_PERIPHCLK_UART4:
      {
        /* Get the current UART4 source */
        srcclk = __HAL_RCC_GET_UART4_SOURCE();
 8009a28:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88

        switch(srcclk)
 8009a2c:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
 8009a30:	2a40      	cmp	r2, #64	; 0x40
 8009a32:	f000 80f5 	beq.w	8009c20 <HAL_RCCEx_GetPeriphCLKFreq+0x4b0>
 8009a36:	f240 80a7 	bls.w	8009b88 <HAL_RCCEx_GetPeriphCLKFreq+0x418>
 8009a3a:	2a80      	cmp	r2, #128	; 0x80
 8009a3c:	f000 80b1 	beq.w	8009ba2 <HAL_RCCEx_GetPeriphCLKFreq+0x432>
 8009a40:	2ac0      	cmp	r2, #192	; 0xc0
 8009a42:	e0a8      	b.n	8009b96 <HAL_RCCEx_GetPeriphCLKFreq+0x426>
#if defined(UART5)

    case RCC_PERIPHCLK_UART5:
      {
        /* Get the current UART5 source */
        srcclk = __HAL_RCC_GET_UART5_SOURCE();
 8009a44:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8009a48:	4a07      	ldr	r2, [pc, #28]	; (8009a68 <HAL_RCCEx_GetPeriphCLKFreq+0x2f8>)

        switch(srcclk)
 8009a4a:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8009a4e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8009a52:	f000 80e5 	beq.w	8009c20 <HAL_RCCEx_GetPeriphCLKFreq+0x4b0>
 8009a56:	f240 80b2 	bls.w	8009bbe <HAL_RCCEx_GetPeriphCLKFreq+0x44e>
 8009a5a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8009a5e:	f000 80c3 	beq.w	8009be8 <HAL_RCCEx_GetPeriphCLKFreq+0x478>
 8009a62:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8009a66:	e0b2      	b.n	8009bce <HAL_RCCEx_GetPeriphCLKFreq+0x45e>
 8009a68:	40021000 	.word	0x40021000
 8009a6c:	0003d090 	.word	0x0003d090
 8009a70:	0800e738 	.word	0x0800e738
 8009a74:	00f42400 	.word	0x00f42400
 8009a78:	007a1200 	.word	0x007a1200
 8009a7c:	02dc6c00 	.word	0x02dc6c00
#endif /* UART5 */

    case RCC_PERIPHCLK_LPUART1:
      {
        /* Get the current LPUART1 source */
        srcclk = __HAL_RCC_GET_LPUART1_SOURCE();
 8009a80:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88

        switch(srcclk)
 8009a84:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
 8009a88:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 8009a8c:	f000 80c8 	beq.w	8009c20 <HAL_RCCEx_GetPeriphCLKFreq+0x4b0>
 8009a90:	d97a      	bls.n	8009b88 <HAL_RCCEx_GetPeriphCLKFreq+0x418>
 8009a92:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 8009a96:	f000 8084 	beq.w	8009ba2 <HAL_RCCEx_GetPeriphCLKFreq+0x432>
 8009a9a:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
 8009a9e:	e07a      	b.n	8009b96 <HAL_RCCEx_GetPeriphCLKFreq+0x426>
        break;
      }

    case RCC_PERIPHCLK_ADC:
      {
        srcclk = __HAL_RCC_GET_ADC_SOURCE();
 8009aa0:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88

        switch(srcclk)
 8009aa4:	f002 5240 	and.w	r2, r2, #805306368	; 0x30000000
 8009aa8:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
 8009aac:	d004      	beq.n	8009ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x348>
 8009aae:	f1b2 5f40 	cmp.w	r2, #805306368	; 0x30000000
 8009ab2:	f040 80e6 	bne.w	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 8009ab6:	e0b3      	b.n	8009c20 <HAL_RCCEx_GetPeriphCLKFreq+0x4b0>
        case RCC_ADCCLKSOURCE_SYSCLK:
          frequency = HAL_RCC_GetSysClockFreq();
          break;
#if defined(RCC_PLLSAI1_SUPPORT)
        case RCC_ADCCLKSOURCE_PLLSAI1:
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLSAI1RDY) && (__HAL_RCC_GET_PLLSAI1CLKOUT_CONFIG(RCC_PLLSAI1_ADC1CLK) != 0U))
 8009ab8:	4a73      	ldr	r2, [pc, #460]	; (8009c88 <HAL_RCCEx_GetPeriphCLKFreq+0x518>)
 8009aba:	6812      	ldr	r2, [r2, #0]
 8009abc:	0110      	lsls	r0, r2, #4
 8009abe:	f140 80e0 	bpl.w	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 8009ac2:	691b      	ldr	r3, [r3, #16]
 8009ac4:	4a70      	ldr	r2, [pc, #448]	; (8009c88 <HAL_RCCEx_GetPeriphCLKFreq+0x518>)
 8009ac6:	f013 7080 	ands.w	r0, r3, #16777216	; 0x1000000
 8009aca:	f000 80db 	beq.w	8009c84 <HAL_RCCEx_GetPeriphCLKFreq+0x514>
          {
            plln = READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1N) >> RCC_PLLSAI1CFGR_PLLSAI1N_Pos;
 8009ace:	6910      	ldr	r0, [r2, #16]
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
            /* PLLSAI1M exists: apply PLLSAI1M divider for PLLSAI1 output computation */
            /* f(PLLSAI1 Source) * PLLSAI1N / PLLSAI1M */
            pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1M) >> RCC_PLLSAI1CFGR_PLLSAI1M_Pos) + 1U));
 8009ad0:	6913      	ldr	r3, [r2, #16]
 8009ad2:	f3c0 2006 	ubfx	r0, r0, #8, #7
 8009ad6:	4341      	muls	r1, r0
#else
            /* f(PLL Source) * PLLSAI1N / PLLM */
            pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
#endif
            /* f(PLLADC1CLK) = f(VCOSAI1 input) / PLLSAI1R */
            frequency = (pllvco / (((READ_BIT(RCC->PLLSAI1CFGR, RCC_PLLSAI1CFGR_PLLSAI1R) >> RCC_PLLSAI1CFGR_PLLSAI1R_Pos) + 1U) << 1U));
 8009ad8:	6910      	ldr	r0, [r2, #16]
 8009ada:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8009ade:	3301      	adds	r3, #1
 8009ae0:	f3c0 6041 	ubfx	r0, r0, #25, #2
 8009ae4:	fbb1 f1f3 	udiv	r1, r1, r3
 8009ae8:	e762      	b.n	80099b0 <HAL_RCCEx_GetPeriphCLKFreq+0x240>
#if defined(DFSDM1_Filter0)

    case RCC_PERIPHCLK_DFSDM1:
      {
        /* Get the current DFSDM1 source */
        srcclk = __HAL_RCC_GET_DFSDM1_SOURCE();
 8009aea:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c

        if(srcclk == RCC_DFSDM1CLKSOURCE_PCLK2)
 8009aee:	0759      	lsls	r1, r3, #29
 8009af0:	f100 8096 	bmi.w	8009c20 <HAL_RCCEx_GetPeriphCLKFreq+0x4b0>
        {
          frequency = HAL_RCC_GetPCLK2Freq();
 8009af4:	f7ff b940 	b.w	8008d78 <HAL_RCC_GetPCLK2Freq>
#if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)

    case RCC_PERIPHCLK_DFSDM1AUDIO:
      {
        /* Get the current DFSDM1 audio source */
        srcclk = __HAL_RCC_GET_DFSDM1AUDIO_SOURCE();
 8009af8:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 8009afc:	4862      	ldr	r0, [pc, #392]	; (8009c88 <HAL_RCCEx_GetPeriphCLKFreq+0x518>)

        switch(srcclk)
 8009afe:	f002 0218 	and.w	r2, r2, #24
 8009b02:	2a08      	cmp	r2, #8
 8009b04:	d00a      	beq.n	8009b1c <HAL_RCCEx_GetPeriphCLKFreq+0x3ac>
 8009b06:	2a10      	cmp	r2, #16
 8009b08:	d006      	beq.n	8009b18 <HAL_RCCEx_GetPeriphCLKFreq+0x3a8>
 8009b0a:	2a00      	cmp	r2, #0
 8009b0c:	f040 80b9 	bne.w	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
        {
        case RCC_DFSDM1AUDIOCLKSOURCE_SAI1:
          frequency = RCCEx_GetSAIxPeriphCLKFreq(RCC_PERIPHCLK_SAI1, pllvco);
 8009b10:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8009b14:	f7ff b9e2 	b.w	8008edc <RCCEx_GetSAIxPeriphCLKFreq>
          break;
        case RCC_DFSDM1AUDIOCLKSOURCE_MSI:
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIRDY))
 8009b18:	6802      	ldr	r2, [r0, #0]
 8009b1a:	e085      	b.n	8009c28 <HAL_RCCEx_GetPeriphCLKFreq+0x4b8>
            /*MSI frequency range in HZ*/
            frequency = MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> 4U)];
          }
          break;
        case RCC_DFSDM1AUDIOCLKSOURCE_HSI:
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8009b1c:	6803      	ldr	r3, [r0, #0]
 8009b1e:	e064      	b.n	8009bea <HAL_RCCEx_GetPeriphCLKFreq+0x47a>
#endif /* DFSDM1_Filter0 */

    case RCC_PERIPHCLK_I2C1:
      {
        /* Get the current I2C1 source */
        srcclk = __HAL_RCC_GET_I2C1_SOURCE();
 8009b20:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88

        switch(srcclk)
 8009b24:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
 8009b28:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 8009b2c:	d078      	beq.n	8009c20 <HAL_RCCEx_GetPeriphCLKFreq+0x4b0>
 8009b2e:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8009b32:	d129      	bne.n	8009b88 <HAL_RCCEx_GetPeriphCLKFreq+0x418>
 8009b34:	e035      	b.n	8009ba2 <HAL_RCCEx_GetPeriphCLKFreq+0x432>
#if defined(I2C2)

    case RCC_PERIPHCLK_I2C2:
      {
        /* Get the current I2C2 source */
        srcclk = __HAL_RCC_GET_I2C2_SOURCE();
 8009b36:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88

        switch(srcclk)
 8009b3a:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8009b3e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8009b42:	d06d      	beq.n	8009c20 <HAL_RCCEx_GetPeriphCLKFreq+0x4b0>
 8009b44:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8009b48:	e008      	b.n	8009b5c <HAL_RCCEx_GetPeriphCLKFreq+0x3ec>
#endif /* I2C2 */

    case RCC_PERIPHCLK_I2C3:
      {
        /* Get the current I2C3 source */
        srcclk = __HAL_RCC_GET_I2C3_SOURCE();
 8009b4a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88

        switch(srcclk)
 8009b4e:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8009b52:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8009b56:	d063      	beq.n	8009c20 <HAL_RCCEx_GetPeriphCLKFreq+0x4b0>
 8009b58:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8009b5c:	d12f      	bne.n	8009bbe <HAL_RCCEx_GetPeriphCLKFreq+0x44e>
 8009b5e:	e009      	b.n	8009b74 <HAL_RCCEx_GetPeriphCLKFreq+0x404>
#if defined(I2C4)

    case RCC_PERIPHCLK_I2C4:
      {
        /* Get the current I2C4 source */
        srcclk = __HAL_RCC_GET_I2C4_SOURCE();
 8009b60:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c

        switch(srcclk)
 8009b64:	f003 0303 	and.w	r3, r3, #3
 8009b68:	2b01      	cmp	r3, #1
 8009b6a:	d059      	beq.n	8009c20 <HAL_RCCEx_GetPeriphCLKFreq+0x4b0>
 8009b6c:	d331      	bcc.n	8009bd2 <HAL_RCCEx_GetPeriphCLKFreq+0x462>
 8009b6e:	2b02      	cmp	r3, #2
 8009b70:	f040 8087 	bne.w	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
          break;
        case RCC_I2C4CLKSOURCE_SYSCLK:
          frequency = HAL_RCC_GetSysClockFreq();
          break;
        case RCC_I2C4CLKSOURCE_HSI:
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8009b74:	4b44      	ldr	r3, [pc, #272]	; (8009c88 <HAL_RCCEx_GetPeriphCLKFreq+0x518>)
 8009b76:	e014      	b.n	8009ba2 <HAL_RCCEx_GetPeriphCLKFreq+0x432>
#endif /* I2C4 */

    case RCC_PERIPHCLK_LPTIM1:
      {
        /* Get the current LPTIM1 source */
        srcclk = __HAL_RCC_GET_LPTIM1_SOURCE();
 8009b78:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88

        switch(srcclk)
 8009b7c:	f402 2240 	and.w	r2, r2, #786432	; 0xc0000
 8009b80:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
 8009b84:	d009      	beq.n	8009b9a <HAL_RCCEx_GetPeriphCLKFreq+0x42a>
 8009b86:	d801      	bhi.n	8009b8c <HAL_RCCEx_GetPeriphCLKFreq+0x41c>
 8009b88:	b31a      	cbz	r2, 8009bd2 <HAL_RCCEx_GetPeriphCLKFreq+0x462>
 8009b8a:	e07a      	b.n	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 8009b8c:	f5b2 2f00 	cmp.w	r2, #524288	; 0x80000
 8009b90:	d007      	beq.n	8009ba2 <HAL_RCCEx_GetPeriphCLKFreq+0x432>
 8009b92:	f5b2 2f40 	cmp.w	r2, #786432	; 0xc0000
 8009b96:	d174      	bne.n	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 8009b98:	e005      	b.n	8009ba6 <HAL_RCCEx_GetPeriphCLKFreq+0x436>
        {
        case RCC_LPTIM1CLKSOURCE_PCLK1:
          frequency = HAL_RCC_GetPCLK1Freq();
          break;
        case RCC_LPTIM1CLKSOURCE_LSI:
          if(HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY))
 8009b9a:	4b3b      	ldr	r3, [pc, #236]	; (8009c88 <HAL_RCCEx_GetPeriphCLKFreq+0x518>)
 8009b9c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8009ba0:	e01b      	b.n	8009bda <HAL_RCCEx_GetPeriphCLKFreq+0x46a>
              frequency = LSI_VALUE;
            }
          }
          break;
        case RCC_LPTIM1CLKSOURCE_HSI:
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8009ba2:	681b      	ldr	r3, [r3, #0]
 8009ba4:	e021      	b.n	8009bea <HAL_RCCEx_GetPeriphCLKFreq+0x47a>
          {
            frequency = HSI_VALUE;
          }
          break;
        case RCC_LPTIM1CLKSOURCE_LSE:
          if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
 8009ba6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8009baa:	e026      	b.n	8009bfa <HAL_RCCEx_GetPeriphCLKFreq+0x48a>
      }

    case RCC_PERIPHCLK_LPTIM2:
      {
        /* Get the current LPTIM2 source */
       srcclk = __HAL_RCC_GET_LPTIM2_SOURCE();
 8009bac:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8009bb0:	4a35      	ldr	r2, [pc, #212]	; (8009c88 <HAL_RCCEx_GetPeriphCLKFreq+0x518>)

        switch(srcclk)
 8009bb2:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 8009bb6:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8009bba:	d00c      	beq.n	8009bd6 <HAL_RCCEx_GetPeriphCLKFreq+0x466>
 8009bbc:	d802      	bhi.n	8009bc4 <HAL_RCCEx_GetPeriphCLKFreq+0x454>
 8009bbe:	2b00      	cmp	r3, #0
 8009bc0:	d15f      	bne.n	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
 8009bc2:	e006      	b.n	8009bd2 <HAL_RCCEx_GetPeriphCLKFreq+0x462>
 8009bc4:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8009bc8:	d00e      	beq.n	8009be8 <HAL_RCCEx_GetPeriphCLKFreq+0x478>
 8009bca:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 8009bce:	d012      	beq.n	8009bf6 <HAL_RCCEx_GetPeriphCLKFreq+0x486>
 8009bd0:	e057      	b.n	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
        {
        case RCC_LPTIM2CLKSOURCE_PCLK1:
          frequency = HAL_RCC_GetPCLK1Freq();
 8009bd2:	f7ff b8bf 	b.w	8008d54 <HAL_RCC_GetPCLK1Freq>
          break;
        case RCC_LPTIM2CLKSOURCE_LSI:
          if(HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY))
 8009bd6:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
              frequency = LSI_VALUE/128U;
            }
            else
#endif /* RCC_CSR_LSIPREDIV */
            {
              frequency = LSI_VALUE;
 8009bda:	f013 0f02 	tst.w	r3, #2
 8009bde:	bf0c      	ite	eq
 8009be0:	2000      	moveq	r0, #0
 8009be2:	f44f 40fa 	movne.w	r0, #32000	; 0x7d00
 8009be6:	4770      	bx	lr
              frequency = LSI_VALUE;
            }
          }
          break;
        case RCC_LPTIM2CLKSOURCE_HSI:
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8009be8:	6813      	ldr	r3, [r2, #0]
          frequency = HAL_RCC_GetSysClockFreq();
          break;
        case RCC_USART1CLKSOURCE_HSI:
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
          {
            frequency = HSI_VALUE;
 8009bea:	4828      	ldr	r0, [pc, #160]	; (8009c8c <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
 8009bec:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8009bf0:	bf08      	it	eq
 8009bf2:	2000      	moveq	r0, #0
 8009bf4:	4770      	bx	lr
          {
            frequency = HSI_VALUE;
          }
          break;
        case RCC_LPTIM2CLKSOURCE_LSE:
          if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
 8009bf6:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
    {
    case RCC_RTCCLKSOURCE_LSE:
      /* Check if LSE is ready */
      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY))
      {
        frequency = LSE_VALUE;
 8009bfa:	f013 0f02 	tst.w	r3, #2
 8009bfe:	bf0c      	ite	eq
 8009c00:	2000      	moveq	r0, #0
 8009c02:	f44f 4000 	movne.w	r0, #32768	; 0x8000
 8009c06:	4770      	bx	lr
#if defined(OCTOSPI1) || defined(OCTOSPI2)

    case RCC_PERIPHCLK_OSPI:
      {
        /* Get the current OctoSPI clock source */
        srcclk = __HAL_RCC_GET_OSPI_SOURCE();
 8009c08:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c

        switch(srcclk)
 8009c0c:	f402 1240 	and.w	r2, r2, #3145728	; 0x300000
 8009c10:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
 8009c14:	d006      	beq.n	8009c24 <HAL_RCCEx_GetPeriphCLKFreq+0x4b4>
 8009c16:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
 8009c1a:	d017      	beq.n	8009c4c <HAL_RCCEx_GetPeriphCLKFreq+0x4dc>
 8009c1c:	2a00      	cmp	r2, #0
 8009c1e:	d130      	bne.n	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
        {
        case RCC_OSPICLKSOURCE_SYSCLK:
          frequency = HAL_RCC_GetSysClockFreq();
 8009c20:	f7fe bc88 	b.w	8008534 <HAL_RCC_GetSysClockFreq>
          break;
        case RCC_OSPICLKSOURCE_MSI:
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIRDY))
 8009c24:	4a18      	ldr	r2, [pc, #96]	; (8009c88 <HAL_RCCEx_GetPeriphCLKFreq+0x518>)
 8009c26:	6812      	ldr	r2, [r2, #0]
 8009c28:	0792      	lsls	r2, r2, #30
 8009c2a:	d52a      	bpl.n	8009c82 <HAL_RCCEx_GetPeriphCLKFreq+0x512>
          {
            /*MSI frequency range in HZ*/
            frequency = MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> 4U)];
 8009c2c:	4a16      	ldr	r2, [pc, #88]	; (8009c88 <HAL_RCCEx_GetPeriphCLKFreq+0x518>)
 8009c2e:	681b      	ldr	r3, [r3, #0]
 8009c30:	071b      	lsls	r3, r3, #28
 8009c32:	bf4c      	ite	mi
 8009c34:	6813      	ldrmi	r3, [r2, #0]
 8009c36:	f8d2 3094 	ldrpl.w	r3, [r2, #148]	; 0x94
 8009c3a:	4a15      	ldr	r2, [pc, #84]	; (8009c90 <HAL_RCCEx_GetPeriphCLKFreq+0x520>)
 8009c3c:	bf4c      	ite	mi
 8009c3e:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
 8009c42:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 8009c46:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 8009c4a:	4770      	bx	lr
          }
          break;
        case RCC_OSPICLKSOURCE_PLL:
          if(HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLRDY))
 8009c4c:	681b      	ldr	r3, [r3, #0]
 8009c4e:	4a0e      	ldr	r2, [pc, #56]	; (8009c88 <HAL_RCCEx_GetPeriphCLKFreq+0x518>)
 8009c50:	f013 7000 	ands.w	r0, r3, #33554432	; 0x2000000
 8009c54:	d016      	beq.n	8009c84 <HAL_RCCEx_GetPeriphCLKFreq+0x514>
          {
            if(HAL_IS_BIT_SET(RCC->PLLCFGR, RCC_PLLCFGR_PLLQEN))
 8009c56:	68d3      	ldr	r3, [r2, #12]
 8009c58:	f413 1080 	ands.w	r0, r3, #1048576	; 0x100000
 8009c5c:	d012      	beq.n	8009c84 <HAL_RCCEx_GetPeriphCLKFreq+0x514>
            {
              /* f(PLL Source) * PLLN / PLLM */
              plln = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos;
 8009c5e:	68d0      	ldr	r0, [r2, #12]
              pllvco = ((pllvco * plln) / ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U));
 8009c60:	f3c0 2006 	ubfx	r0, r0, #8, #7
 8009c64:	4341      	muls	r1, r0
 8009c66:	68d0      	ldr	r0, [r2, #12]
              /* f(PLL48M1CLK) = f(VCO input) / PLLQ */
              frequency = (pllvco / (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos) + 1U) << 1U));
 8009c68:	68d3      	ldr	r3, [r2, #12]
 8009c6a:	f3c3 5341 	ubfx	r3, r3, #21, #2
 8009c6e:	f3c0 1003 	ubfx	r0, r0, #4, #4
 8009c72:	3301      	adds	r3, #1
 8009c74:	005b      	lsls	r3, r3, #1
 8009c76:	3001      	adds	r0, #1
 8009c78:	fbb1 f0f0 	udiv	r0, r1, r0
 8009c7c:	fbb0 f0f3 	udiv	r0, r0, r3
 8009c80:	4770      	bx	lr
  @endif
  * @retval Frequency in Hz
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
  uint32_t frequency = 0U;
 8009c82:	2000      	movs	r0, #0
      break;
    }
  }

  return(frequency);
}
 8009c84:	4770      	bx	lr
 8009c86:	bf00      	nop
 8009c88:	40021000 	.word	0x40021000
 8009c8c:	00f42400 	.word	0x00f42400
 8009c90:	0800e738 	.word	0x0800e738

08009c94 <HAL_RCCEx_EnablePLLSAI1>:
  * @param  PLLSAI1Init  pointer to an RCC_PLLSAI1InitTypeDef structure that
  *         contains the configuration information for the PLLSAI1
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_EnablePLLSAI1(RCC_PLLSAI1InitTypeDef  *PLLSAI1Init)
{
 8009c94:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_RCC_PLLSAI1Q_VALUE(PLLSAI1Init->PLLSAI1Q));
  assert_param(IS_RCC_PLLSAI1R_VALUE(PLLSAI1Init->PLLSAI1R));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PLLSAI1Init->PLLSAI1ClockOut));

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
 8009c96:	4c21      	ldr	r4, [pc, #132]	; (8009d1c <HAL_RCCEx_EnablePLLSAI1+0x88>)
 8009c98:	6823      	ldr	r3, [r4, #0]
 8009c9a:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8009c9e:	6023      	str	r3, [r4, #0]
  * @param  PLLSAI1Init  pointer to an RCC_PLLSAI1InitTypeDef structure that
  *         contains the configuration information for the PLLSAI1
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_EnablePLLSAI1(RCC_PLLSAI1InitTypeDef  *PLLSAI1Init)
{
 8009ca0:	4605      	mov	r5, r0

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8009ca2:	f7fd f9b3 	bl	800700c <HAL_GetTick>
 8009ca6:	4606      	mov	r6, r0

  /* Wait till PLLSAI1 is ready to be updated */
  while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 8009ca8:	6823      	ldr	r3, [r4, #0]
 8009caa:	481c      	ldr	r0, [pc, #112]	; (8009d1c <HAL_RCCEx_EnablePLLSAI1+0x88>)
 8009cac:	011a      	lsls	r2, r3, #4
 8009cae:	d506      	bpl.n	8009cbe <HAL_RCCEx_EnablePLLSAI1+0x2a>
  {
    if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8009cb0:	f7fd f9ac 	bl	800700c <HAL_GetTick>
 8009cb4:	1b80      	subs	r0, r0, r6
 8009cb6:	2802      	cmp	r0, #2
 8009cb8:	d9f6      	bls.n	8009ca8 <HAL_RCCEx_EnablePLLSAI1+0x14>
    {
      status = HAL_TIMEOUT;
 8009cba:	2003      	movs	r0, #3
 8009cbc:	bd70      	pop	{r4, r5, r6, pc}
  if(status == HAL_OK)
  {
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
    /* Configure the PLLSAI1 Multiplication factor N */
    /* Configure the PLLSAI1 Division factors M, P, Q and R */
    __HAL_RCC_PLLSAI1_CONFIG(PLLSAI1Init->PLLSAI1M, PLLSAI1Init->PLLSAI1N, PLLSAI1Init->PLLSAI1P, PLLSAI1Init->PLLSAI1Q, PLLSAI1Init->PLLSAI1R);
 8009cbe:	6902      	ldr	r2, [r0, #16]
 8009cc0:	4b17      	ldr	r3, [pc, #92]	; (8009d20 <HAL_RCCEx_EnablePLLSAI1+0x8c>)
 8009cc2:	68a9      	ldr	r1, [r5, #8]
 8009cc4:	4013      	ands	r3, r2
 8009cc6:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8009cca:	686a      	ldr	r2, [r5, #4]
 8009ccc:	68e9      	ldr	r1, [r5, #12]
 8009cce:	3a01      	subs	r2, #1
 8009cd0:	ea43 63c1 	orr.w	r3, r3, r1, lsl #27
 8009cd4:	ea43 1102 	orr.w	r1, r3, r2, lsl #4
 8009cd8:	692b      	ldr	r3, [r5, #16]
 8009cda:	085b      	lsrs	r3, r3, #1
 8009cdc:	3b01      	subs	r3, #1
 8009cde:	ea41 5243 	orr.w	r2, r1, r3, lsl #21
 8009ce2:	696b      	ldr	r3, [r5, #20]
 8009ce4:	085b      	lsrs	r3, r3, #1
 8009ce6:	3b01      	subs	r3, #1
 8009ce8:	ea42 6343 	orr.w	r3, r2, r3, lsl #25
 8009cec:	6103      	str	r3, [r0, #16]
    /* Configure the PLLSAI1 Multiplication factor N */
    /* Configure the PLLSAI1 Division factors P, Q and R */
    __HAL_RCC_PLLSAI1_CONFIG(PLLSAI1Init->PLLSAI1N, PLLSAI1Init->PLLSAI1P, PLLSAI1Init->PLLSAI1Q, PLLSAI1Init->PLLSAI1R);
#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
    /* Configure the PLLSAI1 Clock output(s) */
    __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1Init->PLLSAI1ClockOut);
 8009cee:	6902      	ldr	r2, [r0, #16]
 8009cf0:	69ab      	ldr	r3, [r5, #24]
 8009cf2:	4313      	orrs	r3, r2
 8009cf4:	6103      	str	r3, [r0, #16]

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();
 8009cf6:	6803      	ldr	r3, [r0, #0]
 8009cf8:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8009cfc:	6003      	str	r3, [r0, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8009cfe:	f7fd f985 	bl	800700c <HAL_GetTick>
 8009d02:	4605      	mov	r5, r0

    /* Wait till PLLSAI1 is ready */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 8009d04:	6823      	ldr	r3, [r4, #0]
 8009d06:	011b      	lsls	r3, r3, #4
 8009d08:	d405      	bmi.n	8009d16 <HAL_RCCEx_EnablePLLSAI1+0x82>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8009d0a:	f7fd f97f 	bl	800700c <HAL_GetTick>
 8009d0e:	1b40      	subs	r0, r0, r5
 8009d10:	2802      	cmp	r0, #2
 8009d12:	d9f7      	bls.n	8009d04 <HAL_RCCEx_EnablePLLSAI1+0x70>
 8009d14:	e7d1      	b.n	8009cba <HAL_RCCEx_EnablePLLSAI1+0x26>
 8009d16:	2000      	movs	r0, #0
        break;
      }
    }
  }

  return status;
 8009d18:	bd70      	pop	{r4, r5, r6, pc}
 8009d1a:	bf00      	nop
 8009d1c:	40021000 	.word	0x40021000
 8009d20:	019d800f 	.word	0x019d800f

08009d24 <HAL_RCCEx_DisablePLLSAI1>:
/**
  * @brief  Disable PLLSAI1.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_DisablePLLSAI1(void)
{
 8009d24:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
 8009d26:	4c11      	ldr	r4, [pc, #68]	; (8009d6c <HAL_RCCEx_DisablePLLSAI1+0x48>)
 8009d28:	6823      	ldr	r3, [r4, #0]
 8009d2a:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8009d2e:	6023      	str	r3, [r4, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8009d30:	f7fd f96c 	bl	800700c <HAL_GetTick>
 8009d34:	4605      	mov	r5, r0

  /* Wait till PLLSAI1 is ready */
  while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 8009d36:	6820      	ldr	r0, [r4, #0]
 8009d38:	f010 6000 	ands.w	r0, r0, #134217728	; 0x8000000
 8009d3c:	d005      	beq.n	8009d4a <HAL_RCCEx_DisablePLLSAI1+0x26>
  {
    if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8009d3e:	f7fd f965 	bl	800700c <HAL_GetTick>
 8009d42:	1b40      	subs	r0, r0, r5
 8009d44:	2802      	cmp	r0, #2
 8009d46:	d9f6      	bls.n	8009d36 <HAL_RCCEx_DisablePLLSAI1+0x12>
    {
      status = HAL_TIMEOUT;
 8009d48:	2003      	movs	r0, #3
      break;
    }
  }

  /* Disable the PLLSAI1 Clock outputs */
  __HAL_RCC_PLLSAI1CLKOUT_DISABLE(RCC_PLLSAI1CFGR_PLLSAI1PEN|RCC_PLLSAI1CFGR_PLLSAI1QEN|RCC_PLLSAI1CFGR_PLLSAI1REN);
 8009d4a:	6923      	ldr	r3, [r4, #16]
 8009d4c:	4a07      	ldr	r2, [pc, #28]	; (8009d6c <HAL_RCCEx_DisablePLLSAI1+0x48>)
 8009d4e:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 8009d52:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8009d56:	6123      	str	r3, [r4, #16]

  /* Reset PLL source to save power if no PLLs on */
#if defined(RCC_PLLSAI2_SUPPORT)
  if(READ_BIT(RCC->CR, (RCC_CR_PLLRDY | RCC_CR_PLLSAI2RDY)) == 0U)
 8009d58:	6823      	ldr	r3, [r4, #0]
 8009d5a:	f013 5f08 	tst.w	r3, #570425344	; 0x22000000
  {
    MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 8009d5e:	bf02      	ittt	eq
 8009d60:	68d3      	ldreq	r3, [r2, #12]
 8009d62:	f023 0303 	biceq.w	r3, r3, #3
 8009d66:	60d3      	streq	r3, [r2, #12]
    MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
  }
#endif /* RCC_PLLSAI2_SUPPORT */

  return status;
}
 8009d68:	bd38      	pop	{r3, r4, r5, pc}
 8009d6a:	bf00      	nop
 8009d6c:	40021000 	.word	0x40021000

08009d70 <HAL_RCCEx_EnablePLLSAI2>:
  * @param  PLLSAI2Init  pointer to an RCC_PLLSAI2InitTypeDef structure that
  *         contains the configuration information for the PLLSAI2
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_EnablePLLSAI2(RCC_PLLSAI2InitTypeDef  *PLLSAI2Init)
{
 8009d70:	b570      	push	{r4, r5, r6, lr}
#endif /* RCC_PLLSAI2Q_DIV_SUPPORT */
  assert_param(IS_RCC_PLLSAI2R_VALUE(PLLSAI2Init->PLLSAI2R));
  assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PLLSAI2Init->PLLSAI2ClockOut));

  /* Disable the PLLSAI2 */
  __HAL_RCC_PLLSAI2_DISABLE();
 8009d72:	4c21      	ldr	r4, [pc, #132]	; (8009df8 <HAL_RCCEx_EnablePLLSAI2+0x88>)
 8009d74:	6823      	ldr	r3, [r4, #0]
 8009d76:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8009d7a:	6023      	str	r3, [r4, #0]
  * @param  PLLSAI2Init  pointer to an RCC_PLLSAI2InitTypeDef structure that
  *         contains the configuration information for the PLLSAI2
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_EnablePLLSAI2(RCC_PLLSAI2InitTypeDef  *PLLSAI2Init)
{
 8009d7c:	4605      	mov	r5, r0

  /* Disable the PLLSAI2 */
  __HAL_RCC_PLLSAI2_DISABLE();

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8009d7e:	f7fd f945 	bl	800700c <HAL_GetTick>
 8009d82:	4606      	mov	r6, r0

  /* Wait till PLLSAI2 is ready to be updated */
  while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 8009d84:	6823      	ldr	r3, [r4, #0]
 8009d86:	481c      	ldr	r0, [pc, #112]	; (8009df8 <HAL_RCCEx_EnablePLLSAI2+0x88>)
 8009d88:	009a      	lsls	r2, r3, #2
 8009d8a:	d506      	bpl.n	8009d9a <HAL_RCCEx_EnablePLLSAI2+0x2a>
  {
    if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8009d8c:	f7fd f93e 	bl	800700c <HAL_GetTick>
 8009d90:	1b80      	subs	r0, r0, r6
 8009d92:	2802      	cmp	r0, #2
 8009d94:	d9f6      	bls.n	8009d84 <HAL_RCCEx_EnablePLLSAI2+0x14>
    {
      status = HAL_TIMEOUT;
 8009d96:	2003      	movs	r0, #3
 8009d98:	bd70      	pop	{r4, r5, r6, pc}
  if(status == HAL_OK)
  {
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT) && defined(RCC_PLLSAI2Q_DIV_SUPPORT)
    /* Configure the PLLSAI2 Multiplication factor N */
    /* Configure the PLLSAI2 Division factors M, P, Q and R */
    __HAL_RCC_PLLSAI2_CONFIG(PLLSAI2Init->PLLSAI2M, PLLSAI2Init->PLLSAI2N, PLLSAI2Init->PLLSAI2P, PLLSAI2Init->PLLSAI2Q, PLLSAI2Init->PLLSAI2R);
 8009d9a:	6942      	ldr	r2, [r0, #20]
 8009d9c:	4b17      	ldr	r3, [pc, #92]	; (8009dfc <HAL_RCCEx_EnablePLLSAI2+0x8c>)
 8009d9e:	68a9      	ldr	r1, [r5, #8]
 8009da0:	4013      	ands	r3, r2
 8009da2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8009da6:	686a      	ldr	r2, [r5, #4]
 8009da8:	68e9      	ldr	r1, [r5, #12]
 8009daa:	3a01      	subs	r2, #1
 8009dac:	ea43 63c1 	orr.w	r3, r3, r1, lsl #27
 8009db0:	ea43 1102 	orr.w	r1, r3, r2, lsl #4
 8009db4:	692b      	ldr	r3, [r5, #16]
 8009db6:	085b      	lsrs	r3, r3, #1
 8009db8:	3b01      	subs	r3, #1
 8009dba:	ea41 5243 	orr.w	r2, r1, r3, lsl #21
 8009dbe:	696b      	ldr	r3, [r5, #20]
 8009dc0:	085b      	lsrs	r3, r3, #1
 8009dc2:	3b01      	subs	r3, #1
 8009dc4:	ea42 6343 	orr.w	r3, r2, r3, lsl #25
 8009dc8:	6143      	str	r3, [r0, #20]
    /* Configure the PLLSAI2 Multiplication factor N */
    /* Configure the PLLSAI2 Division factors P and R */
    __HAL_RCC_PLLSAI2_CONFIG(PLLSAI2Init->PLLSAI2N, PLLSAI2Init->PLLSAI2P, PLLSAI2Init->PLLSAI2R);
#endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT && RCC_PLLSAI2Q_DIV_SUPPORT */
    /* Configure the PLLSAI2 Clock output(s) */
    __HAL_RCC_PLLSAI2CLKOUT_ENABLE(PLLSAI2Init->PLLSAI2ClockOut);
 8009dca:	6942      	ldr	r2, [r0, #20]
 8009dcc:	69ab      	ldr	r3, [r5, #24]
 8009dce:	4313      	orrs	r3, r2
 8009dd0:	6143      	str	r3, [r0, #20]

    /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
    __HAL_RCC_PLLSAI2_ENABLE();
 8009dd2:	6803      	ldr	r3, [r0, #0]
 8009dd4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8009dd8:	6003      	str	r3, [r0, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8009dda:	f7fd f917 	bl	800700c <HAL_GetTick>
 8009dde:	4605      	mov	r5, r0

    /* Wait till PLLSAI2 is ready */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
 8009de0:	6823      	ldr	r3, [r4, #0]
 8009de2:	009b      	lsls	r3, r3, #2
 8009de4:	d405      	bmi.n	8009df2 <HAL_RCCEx_EnablePLLSAI2+0x82>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8009de6:	f7fd f911 	bl	800700c <HAL_GetTick>
 8009dea:	1b40      	subs	r0, r0, r5
 8009dec:	2802      	cmp	r0, #2
 8009dee:	d9f7      	bls.n	8009de0 <HAL_RCCEx_EnablePLLSAI2+0x70>
 8009df0:	e7d1      	b.n	8009d96 <HAL_RCCEx_EnablePLLSAI2+0x26>
 8009df2:	2000      	movs	r0, #0
        break;
      }
    }
  }

  return status;
 8009df4:	bd70      	pop	{r4, r5, r6, pc}
 8009df6:	bf00      	nop
 8009df8:	40021000 	.word	0x40021000
 8009dfc:	019d800f 	.word	0x019d800f

08009e00 <HAL_RCCEx_DisablePLLSAI2>:
/**
  * @brief  Disable PLLISAI2.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_DisablePLLSAI2(void)
{
 8009e00:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  /* Disable the PLLSAI2 */
  __HAL_RCC_PLLSAI2_DISABLE();
 8009e02:	4c11      	ldr	r4, [pc, #68]	; (8009e48 <HAL_RCCEx_DisablePLLSAI2+0x48>)
 8009e04:	6823      	ldr	r3, [r4, #0]
 8009e06:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8009e0a:	6023      	str	r3, [r4, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8009e0c:	f7fd f8fe 	bl	800700c <HAL_GetTick>
 8009e10:	4605      	mov	r5, r0

  /* Wait till PLLSAI2 is ready */
  while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 8009e12:	6820      	ldr	r0, [r4, #0]
 8009e14:	f010 5000 	ands.w	r0, r0, #536870912	; 0x20000000
 8009e18:	d005      	beq.n	8009e26 <HAL_RCCEx_DisablePLLSAI2+0x26>
  {
    if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8009e1a:	f7fd f8f7 	bl	800700c <HAL_GetTick>
 8009e1e:	1b40      	subs	r0, r0, r5
 8009e20:	2802      	cmp	r0, #2
 8009e22:	d9f6      	bls.n	8009e12 <HAL_RCCEx_DisablePLLSAI2+0x12>
    {
      status = HAL_TIMEOUT;
 8009e24:	2003      	movs	r0, #3
    }
  }

  /* Disable the PLLSAI2 Clock outputs */
#if defined(RCC_PLLSAI2Q_DIV_SUPPORT)
  __HAL_RCC_PLLSAI2CLKOUT_DISABLE(RCC_PLLSAI2CFGR_PLLSAI2PEN|RCC_PLLSAI2CFGR_PLLSAI2QEN|RCC_PLLSAI2CFGR_PLLSAI2REN);
 8009e26:	6963      	ldr	r3, [r4, #20]
 8009e28:	4a07      	ldr	r2, [pc, #28]	; (8009e48 <HAL_RCCEx_DisablePLLSAI2+0x48>)
 8009e2a:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 8009e2e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8009e32:	6163      	str	r3, [r4, #20]
#else
  __HAL_RCC_PLLSAI2CLKOUT_DISABLE(RCC_PLLSAI2CFGR_PLLSAI2PEN|RCC_PLLSAI2CFGR_PLLSAI2REN);
#endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT && RCC_PLLSAI2Q_DIV_SUPPORT */

  /* Reset PLL source to save power if no PLLs on */
  if(READ_BIT(RCC->CR, (RCC_CR_PLLRDY | RCC_CR_PLLSAI1RDY)) == 0U)
 8009e34:	6823      	ldr	r3, [r4, #0]
 8009e36:	f013 6f20 	tst.w	r3, #167772160	; 0xa000000
  {
    MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 8009e3a:	bf02      	ittt	eq
 8009e3c:	68d3      	ldreq	r3, [r2, #12]
 8009e3e:	f023 0303 	biceq.w	r3, r3, #3
 8009e42:	60d3      	streq	r3, [r2, #12]
  }

  return status;
}
 8009e44:	bd38      	pop	{r3, r4, r5, pc}
 8009e46:	bf00      	nop
 8009e48:	40021000 	.word	0x40021000

08009e4c <HAL_RCCEx_WakeUpStopCLKConfig>:
  */
void HAL_RCCEx_WakeUpStopCLKConfig(uint32_t WakeUpClk)
{
  assert_param(IS_RCC_STOP_WAKEUPCLOCK(WakeUpClk));

  __HAL_RCC_WAKEUPSTOP_CLK_CONFIG(WakeUpClk);
 8009e4c:	4a03      	ldr	r2, [pc, #12]	; (8009e5c <HAL_RCCEx_WakeUpStopCLKConfig+0x10>)
 8009e4e:	6893      	ldr	r3, [r2, #8]
 8009e50:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8009e54:	4318      	orrs	r0, r3
 8009e56:	6090      	str	r0, [r2, #8]
 8009e58:	4770      	bx	lr
 8009e5a:	bf00      	nop
 8009e5c:	40021000 	.word	0x40021000

08009e60 <HAL_RCCEx_StandbyMSIRangeConfig>:
  */
void HAL_RCCEx_StandbyMSIRangeConfig(uint32_t MSIRange)
{
  assert_param(IS_RCC_MSI_STANDBY_CLOCK_RANGE(MSIRange));

  __HAL_RCC_MSI_STANDBY_RANGE_CONFIG(MSIRange);
 8009e60:	4a04      	ldr	r2, [pc, #16]	; (8009e74 <HAL_RCCEx_StandbyMSIRangeConfig+0x14>)
 8009e62:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 8009e66:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 8009e6a:	ea43 1000 	orr.w	r0, r3, r0, lsl #4
 8009e6e:	f8c2 0094 	str.w	r0, [r2, #148]	; 0x94
 8009e72:	4770      	bx	lr
 8009e74:	40021000 	.word	0x40021000

08009e78 <HAL_RCCEx_EnableLSECSS>:
  *         clock with HAL_RCCEx_PeriphCLKConfig().
  * @retval None
  */
void HAL_RCCEx_EnableLSECSS(void)
{
  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON);
 8009e78:	4a03      	ldr	r2, [pc, #12]	; (8009e88 <HAL_RCCEx_EnableLSECSS+0x10>)
 8009e7a:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8009e7e:	f043 0320 	orr.w	r3, r3, #32
 8009e82:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8009e86:	4770      	bx	lr
 8009e88:	40021000 	.word	0x40021000

08009e8c <HAL_RCCEx_DisableLSECSS>:
  * @note   LSE Clock Security System can only be disabled after a LSE failure detection.
  * @retval None
  */
void HAL_RCCEx_DisableLSECSS(void)
{
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
 8009e8c:	4b05      	ldr	r3, [pc, #20]	; (8009ea4 <HAL_RCCEx_DisableLSECSS+0x18>)
 8009e8e:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8009e92:	f022 0220 	bic.w	r2, r2, #32
 8009e96:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

  /* Disable LSE CSS IT if any */
  __HAL_RCC_DISABLE_IT(RCC_IT_LSECSS);
 8009e9a:	699a      	ldr	r2, [r3, #24]
 8009e9c:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8009ea0:	619a      	str	r2, [r3, #24]
 8009ea2:	4770      	bx	lr
 8009ea4:	40021000 	.word	0x40021000

08009ea8 <HAL_RCCEx_EnableLSECSS_IT>:
  * @retval None
  */
void HAL_RCCEx_EnableLSECSS_IT(void)
{
  /* Enable LSE CSS */
  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
 8009ea8:	4b0a      	ldr	r3, [pc, #40]	; (8009ed4 <HAL_RCCEx_EnableLSECSS_IT+0x2c>)
 8009eaa:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8009eae:	f042 0220 	orr.w	r2, r2, #32
 8009eb2:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

  /* Enable LSE CSS IT */
  __HAL_RCC_ENABLE_IT(RCC_IT_LSECSS);
 8009eb6:	699a      	ldr	r2, [r3, #24]
 8009eb8:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8009ebc:	619a      	str	r2, [r3, #24]

  /* Enable IT on EXTI Line 19 */
  __HAL_RCC_LSECSS_EXTI_ENABLE_IT();
 8009ebe:	f5a3 3386 	sub.w	r3, r3, #68608	; 0x10c00
 8009ec2:	681a      	ldr	r2, [r3, #0]
 8009ec4:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8009ec8:	601a      	str	r2, [r3, #0]
  __HAL_RCC_LSECSS_EXTI_ENABLE_RISING_EDGE();
 8009eca:	689a      	ldr	r2, [r3, #8]
 8009ecc:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8009ed0:	609a      	str	r2, [r3, #8]
 8009ed2:	4770      	bx	lr
 8009ed4:	40021000 	.word	0x40021000

08009ed8 <HAL_RCCEx_LSECSS_Callback>:
 8009ed8:	4770      	bx	lr
	...

08009edc <HAL_RCCEx_LSECSS_IRQHandler>:
/**
  * @brief Handle the RCC LSE Clock Security System interrupt request.
  * @retval None
  */
void HAL_RCCEx_LSECSS_IRQHandler(void)
{
 8009edc:	b510      	push	{r4, lr}
  /* Check RCC LSE CSSF flag  */
  if(__HAL_RCC_GET_IT(RCC_IT_LSECSS))
 8009ede:	4c05      	ldr	r4, [pc, #20]	; (8009ef4 <HAL_RCCEx_LSECSS_IRQHandler+0x18>)
 8009ee0:	69e3      	ldr	r3, [r4, #28]
 8009ee2:	059b      	lsls	r3, r3, #22
 8009ee4:	d504      	bpl.n	8009ef0 <HAL_RCCEx_LSECSS_IRQHandler+0x14>
  {
    /* RCC LSE Clock Security System interrupt user callback */
    HAL_RCCEx_LSECSS_Callback();
 8009ee6:	f7ff fff7 	bl	8009ed8 <HAL_RCCEx_LSECSS_Callback>

    /* Clear RCC LSE CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_LSECSS);
 8009eea:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009eee:	6223      	str	r3, [r4, #32]
 8009ef0:	bd10      	pop	{r4, pc}
 8009ef2:	bf00      	nop
 8009ef4:	40021000 	.word	0x40021000

08009ef8 <HAL_RCCEx_EnableMSIPLLMode>:
  *         calibration LSE oscillator is to be enabled with HAL_RCC_OscConfig().
  * @retval None
  */
void HAL_RCCEx_EnableMSIPLLMode(void)
{
  SET_BIT(RCC->CR, RCC_CR_MSIPLLEN) ;
 8009ef8:	4a02      	ldr	r2, [pc, #8]	; (8009f04 <HAL_RCCEx_EnableMSIPLLMode+0xc>)
 8009efa:	6813      	ldr	r3, [r2, #0]
 8009efc:	f043 0304 	orr.w	r3, r3, #4
 8009f00:	6013      	str	r3, [r2, #0]
 8009f02:	4770      	bx	lr
 8009f04:	40021000 	.word	0x40021000

08009f08 <HAL_RCCEx_DisableMSIPLLMode>:
  * @note   PLL-mode of the MSI is automatically reset when LSE oscillator is disabled.
  * @retval None
  */
void HAL_RCCEx_DisableMSIPLLMode(void)
{
  CLEAR_BIT(RCC->CR, RCC_CR_MSIPLLEN) ;
 8009f08:	4a02      	ldr	r2, [pc, #8]	; (8009f14 <HAL_RCCEx_DisableMSIPLLMode+0xc>)
 8009f0a:	6813      	ldr	r3, [r2, #0]
 8009f0c:	f023 0304 	bic.w	r3, r3, #4
 8009f10:	6013      	str	r3, [r2, #0]
 8009f12:	4770      	bx	lr
 8009f14:	40021000 	.word	0x40021000

08009f18 <HAL_RCCEx_OCTOSPIDelayConfig>:
void HAL_RCCEx_OCTOSPIDelayConfig(uint32_t Delay1, uint32_t Delay2)
{
  assert_param(IS_RCC_OCTOSPIDELAY(Delay1));
  assert_param(IS_RCC_OCTOSPIDELAY(Delay2));

  MODIFY_REG(RCC->DLYCFGR, RCC_DLYCFGR_OCTOSPI1_DLY|RCC_DLYCFGR_OCTOSPI2_DLY, (Delay1 | (Delay2 << RCC_DLYCFGR_OCTOSPI2_DLY_Pos))) ;
 8009f18:	4a05      	ldr	r2, [pc, #20]	; (8009f30 <HAL_RCCEx_OCTOSPIDelayConfig+0x18>)
 8009f1a:	f8d2 30a4 	ldr.w	r3, [r2, #164]	; 0xa4
 8009f1e:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 8009f22:	4318      	orrs	r0, r3
 8009f24:	ea40 1101 	orr.w	r1, r0, r1, lsl #4
 8009f28:	f8c2 10a4 	str.w	r1, [r2, #164]	; 0xa4
 8009f2c:	4770      	bx	lr
 8009f2e:	bf00      	nop
 8009f30:	40021000 	.word	0x40021000

08009f34 <HAL_RCCEx_CRSConfig>:
  assert_param(IS_RCC_CRS_HSI48CALIBRATION(pInit->HSI48CalibrationValue));

  /* CONFIGURATION */

  /* Before configuration, reset CRS registers to their default values*/
  __HAL_RCC_CRS_FORCE_RESET();
 8009f34:	4b10      	ldr	r3, [pc, #64]	; (8009f78 <HAL_RCCEx_CRSConfig+0x44>)
 8009f36:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8009f38:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8009f3c:	639a      	str	r2, [r3, #56]	; 0x38
  __HAL_RCC_CRS_RELEASE_RESET();
 8009f3e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8009f40:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8009f44:	639a      	str	r2, [r3, #56]	; 0x38

  /* Set the SYNCDIV[2:0] bits according to Prescaler value */
  /* Set the SYNCSRC[1:0] bits according to Source value */
  /* Set the SYNCSPOL bit according to Polarity value */
  value = (pInit->Prescaler | pInit->Source | pInit->Polarity);
 8009f46:	e890 000c 	ldmia.w	r0, {r2, r3}
 8009f4a:	431a      	orrs	r2, r3
 8009f4c:	6883      	ldr	r3, [r0, #8]
 8009f4e:	431a      	orrs	r2, r3
  /* Set the RELOAD[15:0] bits according to ReloadValue value */
  value |= pInit->ReloadValue;
 8009f50:	68c3      	ldr	r3, [r0, #12]
 8009f52:	4313      	orrs	r3, r2
  /* Set the FELIM[7:0] bits according to ErrorLimitValue value */
  value |= (pInit->ErrorLimitValue << CRS_CFGR_FELIM_Pos);
 8009f54:	6902      	ldr	r2, [r0, #16]
 8009f56:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
  WRITE_REG(CRS->CFGR, value);
 8009f5a:	4b08      	ldr	r3, [pc, #32]	; (8009f7c <HAL_RCCEx_CRSConfig+0x48>)
 8009f5c:	605a      	str	r2, [r3, #4]

  /* Adjust HSI48 oscillator smooth trimming */
  /* Set the TRIM[6:0] bits for STM32L412xx/L422xx or TRIM[5:0] bits otherwise
     according to RCC_CRS_HSI48CalibrationValue value */
  MODIFY_REG(CRS->CR, CRS_CR_TRIM, (pInit->HSI48CalibrationValue << CRS_CR_TRIM_Pos));
 8009f5e:	681a      	ldr	r2, [r3, #0]
 8009f60:	6941      	ldr	r1, [r0, #20]
 8009f62:	f422 527c 	bic.w	r2, r2, #16128	; 0x3f00
 8009f66:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8009f6a:	601a      	str	r2, [r3, #0]

  /* START AUTOMATIC SYNCHRONIZATION*/

  /* Enable Automatic trimming & Frequency error counter */
  SET_BIT(CRS->CR, CRS_CR_AUTOTRIMEN | CRS_CR_CEN);
 8009f6c:	681a      	ldr	r2, [r3, #0]
 8009f6e:	f042 0260 	orr.w	r2, r2, #96	; 0x60
 8009f72:	601a      	str	r2, [r3, #0]
 8009f74:	4770      	bx	lr
 8009f76:	bf00      	nop
 8009f78:	40021000 	.word	0x40021000
 8009f7c:	40006000 	.word	0x40006000

08009f80 <HAL_RCCEx_CRSSoftwareSynchronizationGenerate>:
  * @brief  Generate the software synchronization event
  * @retval None
  */
void HAL_RCCEx_CRSSoftwareSynchronizationGenerate(void)
{
  SET_BIT(CRS->CR, CRS_CR_SWSYNC);
 8009f80:	4a02      	ldr	r2, [pc, #8]	; (8009f8c <HAL_RCCEx_CRSSoftwareSynchronizationGenerate+0xc>)
 8009f82:	6813      	ldr	r3, [r2, #0]
 8009f84:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8009f88:	6013      	str	r3, [r2, #0]
 8009f8a:	4770      	bx	lr
 8009f8c:	40006000 	.word	0x40006000

08009f90 <HAL_RCCEx_CRSGetSynchronizationInfo>:
{
  /* Check the parameter */
  assert_param(pSynchroInfo != (void *)NULL);

  /* Get the reload value */
  pSynchroInfo->ReloadValue = (READ_BIT(CRS->CFGR, CRS_CFGR_RELOAD));
 8009f90:	4b07      	ldr	r3, [pc, #28]	; (8009fb0 <HAL_RCCEx_CRSGetSynchronizationInfo+0x20>)
 8009f92:	685a      	ldr	r2, [r3, #4]
 8009f94:	b292      	uxth	r2, r2
 8009f96:	6002      	str	r2, [r0, #0]

  /* Get HSI48 oscillator smooth trimming */
  pSynchroInfo->HSI48CalibrationValue = (READ_BIT(CRS->CR, CRS_CR_TRIM) >> CRS_CR_TRIM_Pos);
 8009f98:	681a      	ldr	r2, [r3, #0]
 8009f9a:	f3c2 2205 	ubfx	r2, r2, #8, #6
 8009f9e:	6042      	str	r2, [r0, #4]

  /* Get Frequency error capture */
  pSynchroInfo->FreqErrorCapture = (READ_BIT(CRS->ISR, CRS_ISR_FECAP) >> CRS_ISR_FECAP_Pos);
 8009fa0:	689a      	ldr	r2, [r3, #8]
 8009fa2:	0c12      	lsrs	r2, r2, #16
 8009fa4:	6082      	str	r2, [r0, #8]

  /* Get Frequency error direction */
  pSynchroInfo->FreqErrorDirection = (READ_BIT(CRS->ISR, CRS_ISR_FEDIR));
 8009fa6:	689b      	ldr	r3, [r3, #8]
 8009fa8:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8009fac:	60c3      	str	r3, [r0, #12]
 8009fae:	4770      	bx	lr
 8009fb0:	40006000 	.word	0x40006000

08009fb4 <HAL_RCCEx_CRSWaitSynchronization>:
*            @arg @ref RCC_CRS_SYNCERR
*            @arg @ref RCC_CRS_SYNCMISS
*            @arg @ref RCC_CRS_TRIMOVF
*/
uint32_t HAL_RCCEx_CRSWaitSynchronization(uint32_t Timeout)
{
 8009fb4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009fb8:	4605      	mov	r5, r0
  uint32_t crsstatus = RCC_CRS_NONE;
  uint32_t tickstart;

  /* Get timeout */
  tickstart = HAL_GetTick();
 8009fba:	f7fd f827 	bl	800700c <HAL_GetTick>
      {
        crsstatus = RCC_CRS_TIMEOUT;
      }
    }
    /* Check CRS SYNCOK flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCOK))
 8009fbe:	4c21      	ldr	r4, [pc, #132]	; (800a044 <HAL_RCCEx_CRSWaitSynchronization+0x90>)
{
  uint32_t crsstatus = RCC_CRS_NONE;
  uint32_t tickstart;

  /* Get timeout */
  tickstart = HAL_GetTick();
 8009fc0:	4607      	mov	r7, r0
 8009fc2:	4626      	mov	r6, r4
    {
      /* CRS SYNC event OK */
      crsstatus |= RCC_CRS_SYNCOK;

      /* Clear CRS SYNC event OK bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCOK);
 8009fc4:	f04f 0801 	mov.w	r8, #1
  tickstart = HAL_GetTick();

  /* Wait for CRS flag or timeout detection */
  do
  {
    if(Timeout != HAL_MAX_DELAY)
 8009fc8:	1c68      	adds	r0, r5, #1
 8009fca:	d101      	bne.n	8009fd0 <HAL_RCCEx_CRSWaitSynchronization+0x1c>
*            @arg @ref RCC_CRS_SYNCERR
*            @arg @ref RCC_CRS_SYNCMISS
*            @arg @ref RCC_CRS_TRIMOVF
*/
uint32_t HAL_RCCEx_CRSWaitSynchronization(uint32_t Timeout)
{
 8009fcc:	2000      	movs	r0, #0
 8009fce:	e007      	b.n	8009fe0 <HAL_RCCEx_CRSWaitSynchronization+0x2c>
  /* Wait for CRS flag or timeout detection */
  do
  {
    if(Timeout != HAL_MAX_DELAY)
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8009fd0:	f7fd f81c 	bl	800700c <HAL_GetTick>
 8009fd4:	1bc0      	subs	r0, r0, r7
 8009fd6:	4285      	cmp	r5, r0
 8009fd8:	d301      	bcc.n	8009fde <HAL_RCCEx_CRSWaitSynchronization+0x2a>
 8009fda:	2d00      	cmp	r5, #0
 8009fdc:	d1f6      	bne.n	8009fcc <HAL_RCCEx_CRSWaitSynchronization+0x18>
      {
        crsstatus = RCC_CRS_TIMEOUT;
 8009fde:	2001      	movs	r0, #1
      }
    }
    /* Check CRS SYNCOK flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCOK))
 8009fe0:	68a3      	ldr	r3, [r4, #8]
 8009fe2:	07d9      	lsls	r1, r3, #31
    {
      /* CRS SYNC event OK */
      crsstatus |= RCC_CRS_SYNCOK;

      /* Clear CRS SYNC event OK bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCOK);
 8009fe4:	bf48      	it	mi
 8009fe6:	f8c4 800c 	strmi.w	r8, [r4, #12]
    }

    /* Check CRS SYNCWARN flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCWARN))
 8009fea:	68b3      	ldr	r3, [r6, #8]
    }
    /* Check CRS SYNCOK flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCOK))
    {
      /* CRS SYNC event OK */
      crsstatus |= RCC_CRS_SYNCOK;
 8009fec:	bf48      	it	mi
 8009fee:	f040 0002 	orrmi.w	r0, r0, #2
      /* Clear CRS SYNC event OK bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCOK);
    }

    /* Check CRS SYNCWARN flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCWARN))
 8009ff2:	079a      	lsls	r2, r3, #30
    {
      /* CRS SYNC warning */
      crsstatus |= RCC_CRS_SYNCWARN;

      /* Clear CRS SYNCWARN bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCWARN);
 8009ff4:	bf44      	itt	mi
 8009ff6:	2302      	movmi	r3, #2
 8009ff8:	60e3      	strmi	r3, [r4, #12]
    }

    /* Check CRS TRIM overflow flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_TRIMOVF))
 8009ffa:	68a3      	ldr	r3, [r4, #8]

    /* Check CRS SYNCWARN flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCWARN))
    {
      /* CRS SYNC warning */
      crsstatus |= RCC_CRS_SYNCWARN;
 8009ffc:	bf48      	it	mi
 8009ffe:	f040 0004 	orrmi.w	r0, r0, #4
      /* Clear CRS SYNCWARN bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCWARN);
    }

    /* Check CRS TRIM overflow flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_TRIMOVF))
 800a002:	055b      	lsls	r3, r3, #21
    {
      /* CRS SYNC Error */
      crsstatus |= RCC_CRS_TRIMOVF;

      /* Clear CRS Error bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_TRIMOVF);
 800a004:	bf44      	itt	mi
 800a006:	2304      	movmi	r3, #4
 800a008:	60e3      	strmi	r3, [r4, #12]
    }

    /* Check CRS Error flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCERR))
 800a00a:	68b3      	ldr	r3, [r6, #8]

    /* Check CRS TRIM overflow flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_TRIMOVF))
    {
      /* CRS SYNC Error */
      crsstatus |= RCC_CRS_TRIMOVF;
 800a00c:	bf48      	it	mi
 800a00e:	f040 0020 	orrmi.w	r0, r0, #32
      /* Clear CRS Error bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_TRIMOVF);
    }

    /* Check CRS Error flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCERR))
 800a012:	05d9      	lsls	r1, r3, #23
    {
      /* CRS SYNC Error */
      crsstatus |= RCC_CRS_SYNCERR;

      /* Clear CRS Error bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCERR);
 800a014:	bf44      	itt	mi
 800a016:	2304      	movmi	r3, #4
 800a018:	60e3      	strmi	r3, [r4, #12]
    }

    /* Check CRS SYNC Missed flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCMISS))
 800a01a:	68a3      	ldr	r3, [r4, #8]

    /* Check CRS Error flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCERR))
    {
      /* CRS SYNC Error */
      crsstatus |= RCC_CRS_SYNCERR;
 800a01c:	bf48      	it	mi
 800a01e:	f040 0008 	orrmi.w	r0, r0, #8
      /* Clear CRS Error bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCERR);
    }

    /* Check CRS SYNC Missed flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCMISS))
 800a022:	059a      	lsls	r2, r3, #22
    {
      /* CRS SYNC Missed */
      crsstatus |= RCC_CRS_SYNCMISS;

      /* Clear CRS SYNC Missed bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCMISS);
 800a024:	bf44      	itt	mi
 800a026:	2304      	movmi	r3, #4
 800a028:	60e3      	strmi	r3, [r4, #12]
    }

    /* Check CRS Expected SYNC flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_ESYNC))
 800a02a:	68b3      	ldr	r3, [r6, #8]

    /* Check CRS SYNC Missed flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCMISS))
    {
      /* CRS SYNC Missed */
      crsstatus |= RCC_CRS_SYNCMISS;
 800a02c:	bf48      	it	mi
 800a02e:	f040 0010 	orrmi.w	r0, r0, #16
      /* Clear CRS SYNC Missed bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCMISS);
    }

    /* Check CRS Expected SYNC flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_ESYNC))
 800a032:	071b      	lsls	r3, r3, #28
    {
      /* frequency error counter reached a zero value */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_ESYNC);
 800a034:	bf44      	itt	mi
 800a036:	2308      	movmi	r3, #8
 800a038:	60e3      	strmi	r3, [r4, #12]
    }
  } while(RCC_CRS_NONE == crsstatus);
 800a03a:	2800      	cmp	r0, #0
 800a03c:	d0c4      	beq.n	8009fc8 <HAL_RCCEx_CRSWaitSynchronization+0x14>

  return crsstatus;
}
 800a03e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800a042:	bf00      	nop
 800a044:	40006000 	.word	0x40006000

0800a048 <HAL_RCCEx_CRS_SyncOkCallback>:
 800a048:	4770      	bx	lr

0800a04a <HAL_RCCEx_CRS_SyncWarnCallback>:
 800a04a:	4770      	bx	lr

0800a04c <HAL_RCCEx_CRS_ExpectedSyncCallback>:
/**
  * @brief  RCCEx Clock Recovery System Expected SYNC interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_CRS_ExpectedSyncCallback(void)
{
 800a04c:	4770      	bx	lr

0800a04e <HAL_RCCEx_CRS_ErrorCallback>:
  *           @arg @ref RCC_CRS_SYNCMISS
  *           @arg @ref RCC_CRS_TRIMOVF
  * @retval none
  */
__weak void HAL_RCCEx_CRS_ErrorCallback(uint32_t Error)
{
 800a04e:	4770      	bx	lr

0800a050 <HAL_RCCEx_CRS_IRQHandler>:
  */
void HAL_RCCEx_CRS_IRQHandler(void)
{
  uint32_t crserror = RCC_CRS_NONE;
  /* Get current IT flags and IT sources values */
  uint32_t itflags = READ_REG(CRS->ISR);
 800a050:	491d      	ldr	r1, [pc, #116]	; (800a0c8 <HAL_RCCEx_CRS_IRQHandler+0x78>)
/**
  * @brief Handle the Clock Recovery System interrupt request.
  * @retval None
  */
void HAL_RCCEx_CRS_IRQHandler(void)
{
 800a052:	b508      	push	{r3, lr}
  uint32_t crserror = RCC_CRS_NONE;
  /* Get current IT flags and IT sources values */
  uint32_t itflags = READ_REG(CRS->ISR);
 800a054:	688b      	ldr	r3, [r1, #8]
  uint32_t itsources = READ_REG(CRS->CR);
 800a056:	680a      	ldr	r2, [r1, #0]

  /* Check CRS SYNCOK flag  */
  if(((itflags & RCC_CRS_FLAG_SYNCOK) != 0U) && ((itsources & RCC_CRS_IT_SYNCOK) != 0U))
 800a058:	f013 0f01 	tst.w	r3, #1
 800a05c:	d007      	beq.n	800a06e <HAL_RCCEx_CRS_IRQHandler+0x1e>
 800a05e:	f012 0f01 	tst.w	r2, #1
 800a062:	d004      	beq.n	800a06e <HAL_RCCEx_CRS_IRQHandler+0x1e>
  {
    /* Clear CRS SYNC event OK flag */
    WRITE_REG(CRS->ICR, CRS_ICR_SYNCOKC);
 800a064:	2301      	movs	r3, #1
 800a066:	60cb      	str	r3, [r1, #12]

    /* user callback */
    HAL_RCCEx_CRS_SyncOkCallback();
 800a068:	f7ff ffee 	bl	800a048 <HAL_RCCEx_CRS_SyncOkCallback>
 800a06c:	bd08      	pop	{r3, pc}
  }
  /* Check CRS SYNCWARN flag  */
  else if(((itflags & RCC_CRS_FLAG_SYNCWARN) != 0U) && ((itsources & RCC_CRS_IT_SYNCWARN) != 0U))
 800a06e:	0799      	lsls	r1, r3, #30
 800a070:	d507      	bpl.n	800a082 <HAL_RCCEx_CRS_IRQHandler+0x32>
 800a072:	0791      	lsls	r1, r2, #30
 800a074:	d505      	bpl.n	800a082 <HAL_RCCEx_CRS_IRQHandler+0x32>
  {
    /* Clear CRS SYNCWARN flag */
    WRITE_REG(CRS->ICR, CRS_ICR_SYNCWARNC);
 800a076:	4b14      	ldr	r3, [pc, #80]	; (800a0c8 <HAL_RCCEx_CRS_IRQHandler+0x78>)
 800a078:	2202      	movs	r2, #2
 800a07a:	60da      	str	r2, [r3, #12]

    /* user callback */
    HAL_RCCEx_CRS_SyncWarnCallback();
 800a07c:	f7ff ffe5 	bl	800a04a <HAL_RCCEx_CRS_SyncWarnCallback>
 800a080:	bd08      	pop	{r3, pc}
  }
  /* Check CRS Expected SYNC flag  */
  else if(((itflags & RCC_CRS_FLAG_ESYNC) != 0U) && ((itsources & RCC_CRS_IT_ESYNC) != 0U))
 800a082:	0719      	lsls	r1, r3, #28
 800a084:	d507      	bpl.n	800a096 <HAL_RCCEx_CRS_IRQHandler+0x46>
 800a086:	0711      	lsls	r1, r2, #28
 800a088:	d505      	bpl.n	800a096 <HAL_RCCEx_CRS_IRQHandler+0x46>
  {
    /* frequency error counter reached a zero value */
    WRITE_REG(CRS->ICR, CRS_ICR_ESYNCC);
 800a08a:	4b0f      	ldr	r3, [pc, #60]	; (800a0c8 <HAL_RCCEx_CRS_IRQHandler+0x78>)
 800a08c:	2208      	movs	r2, #8
 800a08e:	60da      	str	r2, [r3, #12]

    /* user callback */
    HAL_RCCEx_CRS_ExpectedSyncCallback();
 800a090:	f7ff ffdc 	bl	800a04c <HAL_RCCEx_CRS_ExpectedSyncCallback>
 800a094:	bd08      	pop	{r3, pc}
  }
  /* Check CRS Error flags  */
  else
  {
    if(((itflags & RCC_CRS_FLAG_ERR) != 0U) && ((itsources & RCC_CRS_IT_ERR) != 0U))
 800a096:	0759      	lsls	r1, r3, #29
 800a098:	d514      	bpl.n	800a0c4 <HAL_RCCEx_CRS_IRQHandler+0x74>
 800a09a:	0751      	lsls	r1, r2, #29
 800a09c:	d512      	bpl.n	800a0c4 <HAL_RCCEx_CRS_IRQHandler+0x74>
    {
      if((itflags & RCC_CRS_FLAG_SYNCERR) != 0U)
      {
        crserror |= RCC_CRS_SYNCERR;
 800a09e:	f413 7f80 	tst.w	r3, #256	; 0x100
 800a0a2:	bf0c      	ite	eq
 800a0a4:	2000      	moveq	r0, #0
 800a0a6:	2008      	movne	r0, #8
      }
      if((itflags & RCC_CRS_FLAG_SYNCMISS) != 0U)
 800a0a8:	059a      	lsls	r2, r3, #22
      {
        crserror |= RCC_CRS_SYNCMISS;
 800a0aa:	bf48      	it	mi
 800a0ac:	f040 0010 	orrmi.w	r0, r0, #16
      }
      if((itflags & RCC_CRS_FLAG_TRIMOVF) != 0U)
 800a0b0:	055b      	lsls	r3, r3, #21
      {
        crserror |= RCC_CRS_TRIMOVF;
      }

      /* Clear CRS Error flags */
      WRITE_REG(CRS->ICR, CRS_ICR_ERRC);
 800a0b2:	4b05      	ldr	r3, [pc, #20]	; (800a0c8 <HAL_RCCEx_CRS_IRQHandler+0x78>)
 800a0b4:	f04f 0204 	mov.w	r2, #4
      {
        crserror |= RCC_CRS_SYNCMISS;
      }
      if((itflags & RCC_CRS_FLAG_TRIMOVF) != 0U)
      {
        crserror |= RCC_CRS_TRIMOVF;
 800a0b8:	bf48      	it	mi
 800a0ba:	f040 0020 	orrmi.w	r0, r0, #32
      }

      /* Clear CRS Error flags */
      WRITE_REG(CRS->ICR, CRS_ICR_ERRC);
 800a0be:	60da      	str	r2, [r3, #12]

      /* user error callback */
      HAL_RCCEx_CRS_ErrorCallback(crserror);
 800a0c0:	f7ff ffc5 	bl	800a04e <HAL_RCCEx_CRS_ErrorCallback>
 800a0c4:	bd08      	pop	{r3, pc}
 800a0c6:	bf00      	nop
 800a0c8:	40006000 	.word	0x40006000

0800a0cc <HASH_WriteData>:
  *         processing is suspended when possible and the Peripheral feeding point reached at
  *         suspension time is stored in the handle for resumption later on.
  * @retval HAL status
  */
static HAL_StatusTypeDef HASH_WriteData(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
 800a0cc:	b573      	push	{r0, r1, r4, r5, r6, lr}
  uint32_t buffercounter;
  __IO uint32_t inputaddr = (uint32_t) pInBuffer;
 800a0ce:	9101      	str	r1, [sp, #4]

  for(buffercounter = 0U; buffercounter < Size; buffercounter+=4U)
  {
    /* Write input data 4 bytes at a time */
    HASH->DIN = *(uint32_t*)inputaddr;
 800a0d0:	491e      	ldr	r1, [pc, #120]	; (800a14c <HASH_WriteData+0x80>)
static HAL_StatusTypeDef HASH_WriteData(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
  uint32_t buffercounter;
  __IO uint32_t inputaddr = (uint32_t) pInBuffer;

  for(buffercounter = 0U; buffercounter < Size; buffercounter+=4U)
 800a0d2:	2400      	movs	r4, #0
 800a0d4:	4294      	cmp	r4, r2
 800a0d6:	d235      	bcs.n	800a144 <HASH_WriteData+0x78>
  {
    /* Write input data 4 bytes at a time */
    HASH->DIN = *(uint32_t*)inputaddr;
 800a0d8:	9b01      	ldr	r3, [sp, #4]
 800a0da:	681b      	ldr	r3, [r3, #0]
 800a0dc:	604b      	str	r3, [r1, #4]
    inputaddr+=4U;
 800a0de:	9b01      	ldr	r3, [sp, #4]
 800a0e0:	3304      	adds	r3, #4
 800a0e2:	9301      	str	r3, [sp, #4]

    /* If the suspension flag has been raised and if the processing is not about
    to end, suspend processing */
    if ((hhash->SuspendRequest == HAL_HASH_SUSPEND) && ((buffercounter+4U) < Size))
 800a0e4:	f890 3036 	ldrb.w	r3, [r0, #54]	; 0x36
 800a0e8:	2b01      	cmp	r3, #1
 800a0ea:	f104 0504 	add.w	r5, r4, #4
 800a0ee:	d127      	bne.n	800a140 <HASH_WriteData+0x74>
 800a0f0:	42aa      	cmp	r2, r5
 800a0f2:	d925      	bls.n	800a140 <HASH_WriteData+0x74>
    {
      /* Wait for DINIS = 1, which occurs when 16 32-bit locations are free
      in the input buffer */
      if (__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))
 800a0f4:	6a4e      	ldr	r6, [r1, #36]	; 0x24
 800a0f6:	07f6      	lsls	r6, r6, #31
 800a0f8:	d522      	bpl.n	800a140 <HASH_WriteData+0x74>
        /* Reset SuspendRequest */
        hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;

        /* Depending whether the key or the input data were fed to the Peripheral, the feeding point
        reached at suspension time is not saved in the same handle fields */
        if ((hhash->Phase == HAL_HASH_PHASE_PROCESS) || (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_2))
 800a0fa:	f890 102d 	ldrb.w	r1, [r0, #45]	; 0x2d
      /* Wait for DINIS = 1, which occurs when 16 32-bit locations are free
      in the input buffer */
      if (__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))
      {
        /* Reset SuspendRequest */
        hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;
 800a0fe:	2500      	movs	r5, #0

        /* Depending whether the key or the input data were fed to the Peripheral, the feeding point
        reached at suspension time is not saved in the same handle fields */
        if ((hhash->Phase == HAL_HASH_PHASE_PROCESS) || (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_2))
 800a100:	2902      	cmp	r1, #2
      /* Wait for DINIS = 1, which occurs when 16 32-bit locations are free
      in the input buffer */
      if (__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))
      {
        /* Reset SuspendRequest */
        hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;
 800a102:	f880 5036 	strb.w	r5, [r0, #54]	; 0x36

        /* Depending whether the key or the input data were fed to the Peripheral, the feeding point
        reached at suspension time is not saved in the same handle fields */
        if ((hhash->Phase == HAL_HASH_PHASE_PROCESS) || (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_2))
 800a106:	d001      	beq.n	800a10c <HASH_WriteData+0x40>
 800a108:	2904      	cmp	r1, #4
 800a10a:	d105      	bne.n	800a118 <HASH_WriteData+0x4c>
        {
          /* Save current reading and writing locations of Input and Output buffers */
          hhash->pHashInBuffPtr =  (uint8_t *)inputaddr;
 800a10c:	9b01      	ldr	r3, [sp, #4]
 800a10e:	60c3      	str	r3, [r0, #12]
          /* Save the number of bytes that remain to be processed at this point */
          hhash->HashInCount    =  Size - (buffercounter + 4U);
 800a110:	1f13      	subs	r3, r2, #4
 800a112:	1b1a      	subs	r2, r3, r4
 800a114:	6202      	str	r2, [r0, #32]
 800a116:	e00f      	b.n	800a138 <HASH_WriteData+0x6c>
        }
        else if ((hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_1) || (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_3))
 800a118:	2903      	cmp	r1, #3
 800a11a:	d001      	beq.n	800a120 <HASH_WriteData+0x54>
 800a11c:	2905      	cmp	r1, #5
 800a11e:	d105      	bne.n	800a12c <HASH_WriteData+0x60>
        {
          /* Save current reading and writing locations of Input and Output buffers */
          hhash->pHashKeyBuffPtr  =  (uint8_t *)inputaddr;
          /* Save the number of bytes that remain to be processed at this point */
          hhash->HashKeyCount  =  Size - (buffercounter + 4U);
 800a120:	3a04      	subs	r2, #4
          hhash->HashInCount    =  Size - (buffercounter + 4U);
        }
        else if ((hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_1) || (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_3))
        {
          /* Save current reading and writing locations of Input and Output buffers */
          hhash->pHashKeyBuffPtr  =  (uint8_t *)inputaddr;
 800a122:	9b01      	ldr	r3, [sp, #4]
 800a124:	6143      	str	r3, [r0, #20]
          /* Save the number of bytes that remain to be processed at this point */
          hhash->HashKeyCount  =  Size - (buffercounter + 4U);
 800a126:	1b12      	subs	r2, r2, r4
 800a128:	6282      	str	r2, [r0, #40]	; 0x28
 800a12a:	e005      	b.n	800a138 <HASH_WriteData+0x6c>
        }
        else
        {
          /* Unexpected phase: unlock process and report error */
          hhash->State = HAL_HASH_STATE_READY;
 800a12c:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
          __HAL_UNLOCK(hhash);
 800a130:	f880 5034 	strb.w	r5, [r0, #52]	; 0x34
          return HAL_ERROR;
 800a134:	4618      	mov	r0, r3
 800a136:	e006      	b.n	800a146 <HASH_WriteData+0x7a>
        }

        /* Set the HASH state to Suspended and exit to stop entering data */
        hhash->State = HAL_HASH_STATE_SUSPENDED;
 800a138:	2308      	movs	r3, #8
 800a13a:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
 800a13e:	e001      	b.n	800a144 <HASH_WriteData+0x78>
static HAL_StatusTypeDef HASH_WriteData(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
  uint32_t buffercounter;
  __IO uint32_t inputaddr = (uint32_t) pInBuffer;

  for(buffercounter = 0U; buffercounter < Size; buffercounter+=4U)
 800a140:	462c      	mov	r4, r5
 800a142:	e7c7      	b.n	800a0d4 <HASH_WriteData+0x8>
      } /* if (__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))  */
    } /* if ((hhash->SuspendRequest == HAL_HASH_SUSPEND) && ((buffercounter+4) < Size)) */
  }   /* for(buffercounter = 0; buffercounter < Size; buffercounter+=4)                 */

  /* At this point, all the data have been entered to the Peripheral: exit */
  return  HAL_OK;
 800a144:	2000      	movs	r0, #0
}
 800a146:	b002      	add	sp, #8
 800a148:	bd70      	pop	{r4, r5, r6, pc}
 800a14a:	bf00      	nop
 800a14c:	50060400 	.word	0x50060400

0800a150 <HASH_GetDigest>:
  */
static void HASH_GetDigest(uint8_t *pMsgDigest, uint8_t Size)
{
  uint32_t msgdigest = (uint32_t)pMsgDigest;

  switch(Size)
 800a150:	2914      	cmp	r1, #20
 800a152:	d016      	beq.n	800a182 <HASH_GetDigest+0x32>
 800a154:	d802      	bhi.n	800a15c <HASH_GetDigest+0xc>
 800a156:	2910      	cmp	r1, #16
 800a158:	d005      	beq.n	800a166 <HASH_GetDigest+0x16>
 800a15a:	4770      	bx	lr
 800a15c:	291c      	cmp	r1, #28
 800a15e:	d021      	beq.n	800a1a4 <HASH_GetDigest+0x54>
 800a160:	2920      	cmp	r1, #32
 800a162:	d037      	beq.n	800a1d4 <HASH_GetDigest+0x84>
 800a164:	4770      	bx	lr
  {
    /* Read the message digest */
    case 16:  /* MD5 */
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[0]);
 800a166:	4b29      	ldr	r3, [pc, #164]	; (800a20c <HASH_GetDigest+0xbc>)
 800a168:	68da      	ldr	r2, [r3, #12]
  \return               Reversed value
 */
__STATIC_FORCEINLINE uint32_t __REV(uint32_t value)
{
#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
  return __builtin_bswap32(value);
 800a16a:	ba12      	rev	r2, r2
 800a16c:	6002      	str	r2, [r0, #0]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[1]);
 800a16e:	691a      	ldr	r2, [r3, #16]
 800a170:	ba12      	rev	r2, r2
 800a172:	6042      	str	r2, [r0, #4]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[2]);
 800a174:	695a      	ldr	r2, [r3, #20]
 800a176:	ba12      	rev	r2, r2
 800a178:	6082      	str	r2, [r0, #8]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[3]);
 800a17a:	699b      	ldr	r3, [r3, #24]
 800a17c:	ba1b      	rev	r3, r3
 800a17e:	60c3      	str	r3, [r0, #12]
    break;
 800a180:	4770      	bx	lr
    case 20:  /* SHA1 */
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[0]);
 800a182:	4b22      	ldr	r3, [pc, #136]	; (800a20c <HASH_GetDigest+0xbc>)
 800a184:	68da      	ldr	r2, [r3, #12]
 800a186:	ba12      	rev	r2, r2
 800a188:	6002      	str	r2, [r0, #0]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[1]);
 800a18a:	691a      	ldr	r2, [r3, #16]
 800a18c:	ba12      	rev	r2, r2
 800a18e:	6042      	str	r2, [r0, #4]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[2]);
 800a190:	695a      	ldr	r2, [r3, #20]
 800a192:	ba12      	rev	r2, r2
 800a194:	6082      	str	r2, [r0, #8]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[3]);
 800a196:	699a      	ldr	r2, [r3, #24]
 800a198:	ba12      	rev	r2, r2
 800a19a:	60c2      	str	r2, [r0, #12]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[4]);
 800a19c:	69db      	ldr	r3, [r3, #28]
 800a19e:	ba1b      	rev	r3, r3
 800a1a0:	6103      	str	r3, [r0, #16]
    break;
 800a1a2:	4770      	bx	lr
  case 28:  /* SHA224 */
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[0]);
 800a1a4:	4b19      	ldr	r3, [pc, #100]	; (800a20c <HASH_GetDigest+0xbc>)
 800a1a6:	68da      	ldr	r2, [r3, #12]
 800a1a8:	ba12      	rev	r2, r2
 800a1aa:	6002      	str	r2, [r0, #0]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[1]);
 800a1ac:	691a      	ldr	r2, [r3, #16]
 800a1ae:	ba12      	rev	r2, r2
 800a1b0:	6042      	str	r2, [r0, #4]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[2]);
 800a1b2:	695a      	ldr	r2, [r3, #20]
 800a1b4:	ba12      	rev	r2, r2
 800a1b6:	6082      	str	r2, [r0, #8]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[3]);
 800a1b8:	699a      	ldr	r2, [r3, #24]
 800a1ba:	ba12      	rev	r2, r2
 800a1bc:	60c2      	str	r2, [r0, #12]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[4]);
 800a1be:	69db      	ldr	r3, [r3, #28]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[5]);
 800a1c0:	4a13      	ldr	r2, [pc, #76]	; (800a210 <HASH_GetDigest+0xc0>)
 800a1c2:	ba1b      	rev	r3, r3
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[2]);
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[3]);
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[4]);
 800a1c4:	6103      	str	r3, [r0, #16]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[5]);
 800a1c6:	6953      	ldr	r3, [r2, #20]
 800a1c8:	ba1b      	rev	r3, r3
 800a1ca:	6143      	str	r3, [r0, #20]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[6]);
 800a1cc:	6993      	ldr	r3, [r2, #24]
 800a1ce:	ba1b      	rev	r3, r3
 800a1d0:	6183      	str	r3, [r0, #24]
    break;
 800a1d2:	4770      	bx	lr
  case 32:   /* SHA256 */
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[0]);
 800a1d4:	4b0d      	ldr	r3, [pc, #52]	; (800a20c <HASH_GetDigest+0xbc>)
 800a1d6:	68da      	ldr	r2, [r3, #12]
 800a1d8:	ba12      	rev	r2, r2
 800a1da:	6002      	str	r2, [r0, #0]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[1]);
 800a1dc:	691a      	ldr	r2, [r3, #16]
 800a1de:	ba12      	rev	r2, r2
 800a1e0:	6042      	str	r2, [r0, #4]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[2]);
 800a1e2:	695a      	ldr	r2, [r3, #20]
 800a1e4:	ba12      	rev	r2, r2
 800a1e6:	6082      	str	r2, [r0, #8]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[3]);
 800a1e8:	699a      	ldr	r2, [r3, #24]
 800a1ea:	ba12      	rev	r2, r2
 800a1ec:	60c2      	str	r2, [r0, #12]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[4]);
 800a1ee:	69db      	ldr	r3, [r3, #28]
 800a1f0:	ba1b      	rev	r3, r3
 800a1f2:	6103      	str	r3, [r0, #16]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[5]);
 800a1f4:	4b06      	ldr	r3, [pc, #24]	; (800a210 <HASH_GetDigest+0xc0>)
 800a1f6:	695a      	ldr	r2, [r3, #20]
 800a1f8:	ba12      	rev	r2, r2
 800a1fa:	6142      	str	r2, [r0, #20]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[6]);
 800a1fc:	699a      	ldr	r2, [r3, #24]
 800a1fe:	ba12      	rev	r2, r2
 800a200:	6182      	str	r2, [r0, #24]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[7]);
 800a202:	69db      	ldr	r3, [r3, #28]
 800a204:	ba1b      	rev	r3, r3
 800a206:	61c3      	str	r3, [r0, #28]
 800a208:	4770      	bx	lr
 800a20a:	bf00      	nop
 800a20c:	50060400 	.word	0x50060400
 800a210:	50060710 	.word	0x50060710

0800a214 <HASH_WaitOnFlagUntilTimeout>:
  * @param  Status the Flag status (SET or RESET).
  * @param  Timeout Timeout duration.
  * @retval HAL status
  */
static HAL_StatusTypeDef HASH_WaitOnFlagUntilTimeout(HASH_HandleTypeDef *hhash, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
{
 800a214:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800a218:	4604      	mov	r4, r0
 800a21a:	460d      	mov	r5, r1
 800a21c:	4691      	mov	r9, r2
 800a21e:	461e      	mov	r6, r3
  uint32_t tickstart = HAL_GetTick();
 800a220:	f7fc fef4 	bl	800700c <HAL_GetTick>
 800a224:	4f1e      	ldr	r7, [pc, #120]	; (800a2a0 <HASH_WaitOnFlagUntilTimeout+0x8c>)
 800a226:	4680      	mov	r8, r0

  /* Wait until flag is set */
  if(Status == RESET)
 800a228:	f1b9 0f00 	cmp.w	r9, #0
 800a22c:	d116      	bne.n	800a25c <HASH_WaitOnFlagUntilTimeout+0x48>
  {
    while(__HAL_HASH_GET_FLAG(Flag) == RESET)
 800a22e:	2d08      	cmp	r5, #8
 800a230:	bf8c      	ite	hi
 800a232:	683b      	ldrhi	r3, [r7, #0]
 800a234:	6a7b      	ldrls	r3, [r7, #36]	; 0x24
 800a236:	ea35 0303 	bics.w	r3, r5, r3
 800a23a:	bf14      	ite	ne
 800a23c:	2301      	movne	r3, #1
 800a23e:	2300      	moveq	r3, #0
 800a240:	b1bb      	cbz	r3, 800a272 <HASH_WaitOnFlagUntilTimeout+0x5e>
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
 800a242:	1c72      	adds	r2, r6, #1
 800a244:	d0f3      	beq.n	800a22e <HASH_WaitOnFlagUntilTimeout+0x1a>
      {
        if(((HAL_GetTick()-tickstart) > Timeout) || (Timeout == 0U))
 800a246:	f7fc fee1 	bl	800700c <HAL_GetTick>
 800a24a:	ebc8 0000 	rsb	r0, r8, r0
 800a24e:	4286      	cmp	r6, r0
 800a250:	d318      	bcc.n	800a284 <HASH_WaitOnFlagUntilTimeout+0x70>
 800a252:	2e00      	cmp	r6, #0
 800a254:	d1eb      	bne.n	800a22e <HASH_WaitOnFlagUntilTimeout+0x1a>
 800a256:	e015      	b.n	800a284 <HASH_WaitOnFlagUntilTimeout+0x70>
  else
  {
    while(__HAL_HASH_GET_FLAG(Flag) != RESET)
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
 800a258:	1c73      	adds	r3, r6, #1
 800a25a:	d10d      	bne.n	800a278 <HASH_WaitOnFlagUntilTimeout+0x64>
      }
    }
  }
  else
  {
    while(__HAL_HASH_GET_FLAG(Flag) != RESET)
 800a25c:	2d08      	cmp	r5, #8
 800a25e:	bf8c      	ite	hi
 800a260:	683b      	ldrhi	r3, [r7, #0]
 800a262:	6a7b      	ldrls	r3, [r7, #36]	; 0x24
 800a264:	ea35 0303 	bics.w	r3, r5, r3
 800a268:	bf0c      	ite	eq
 800a26a:	2301      	moveq	r3, #1
 800a26c:	2300      	movne	r3, #0
 800a26e:	2b00      	cmp	r3, #0
 800a270:	d1f2      	bne.n	800a258 <HASH_WaitOnFlagUntilTimeout+0x44>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;
 800a272:	2000      	movs	r0, #0
 800a274:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    while(__HAL_HASH_GET_FLAG(Flag) != RESET)
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
      {
        if(((HAL_GetTick()-tickstart) > Timeout) || (Timeout == 0U))
 800a278:	f7fc fec8 	bl	800700c <HAL_GetTick>
 800a27c:	ebc8 0000 	rsb	r0, r8, r0
 800a280:	4286      	cmp	r6, r0
 800a282:	d20a      	bcs.n	800a29a <HASH_WaitOnFlagUntilTimeout+0x86>
        {
          /* Set State to Ready to be able to restart later on */
          hhash->State  = HAL_HASH_STATE_READY;
 800a284:	2301      	movs	r3, #1
 800a286:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
          /* Store time out issue in handle status */
          hhash->Status = HAL_TIMEOUT;
 800a28a:	2003      	movs	r0, #3

          /* Process Unlocked */
          __HAL_UNLOCK(hhash);
 800a28c:	2300      	movs	r3, #0
        if(((HAL_GetTick()-tickstart) > Timeout) || (Timeout == 0U))
        {
          /* Set State to Ready to be able to restart later on */
          hhash->State  = HAL_HASH_STATE_READY;
          /* Store time out issue in handle status */
          hhash->Status = HAL_TIMEOUT;
 800a28e:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c

          /* Process Unlocked */
          __HAL_UNLOCK(hhash);
 800a292:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

          return HAL_TIMEOUT;
 800a296:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    while(__HAL_HASH_GET_FLAG(Flag) != RESET)
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
      {
        if(((HAL_GetTick()-tickstart) > Timeout) || (Timeout == 0U))
 800a29a:	2e00      	cmp	r6, #0
 800a29c:	d1de      	bne.n	800a25c <HASH_WaitOnFlagUntilTimeout+0x48>
 800a29e:	e7f1      	b.n	800a284 <HASH_WaitOnFlagUntilTimeout+0x70>
 800a2a0:	50060400 	.word	0x50060400

0800a2a4 <HAL_HASH_MspInit>:
 800a2a4:	4770      	bx	lr
	...

0800a2a8 <HAL_HASH_Init>:
  *         relevant APIs manage themselves the MDMAT bit.
  * @param  hhash HASH handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASH_Init(HASH_HandleTypeDef *hhash)
{
 800a2a8:	b538      	push	{r3, r4, r5, lr}
  /* Check the hash handle allocation */
  if(hhash == NULL)
 800a2aa:	4604      	mov	r4, r0
 800a2ac:	b340      	cbz	r0, 800a300 <HAL_HASH_Init+0x58>

    /* Init the low level hardware */
    hhash->MspInitCallback(hhash);
  }
#else
  if(hhash->State == HAL_HASH_STATE_RESET)
 800a2ae:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 800a2b2:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800a2b6:	b91b      	cbnz	r3, 800a2c0 <HAL_HASH_Init+0x18>
  {
    /* Allocate lock resource and initialize it */
    hhash->Lock = HAL_UNLOCKED;
 800a2b8:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34

    /* Init the low level hardware */
    HAL_HASH_MspInit(hhash);
 800a2bc:	f7ff fff2 	bl	800a2a4 <HAL_HASH_MspInit>
  }
#endif /* (USE_HAL_HASH_REGISTER_CALLBACKS) */

    /* Change the HASH state */
  hhash->State = HAL_HASH_STATE_BUSY;
 800a2c0:	2302      	movs	r3, #2
 800a2c2:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

  /* Reset HashInCount, HashITCounter, HashBuffSize and NbWordsAlreadyPushed */
  hhash->HashInCount = 0;
 800a2c6:	2000      	movs	r0, #0
  hhash->Phase = HAL_HASH_PHASE_READY;
  /* Reset suspension request flag */
  hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;

  /* Set the data type bit */
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
 800a2c8:	4b0e      	ldr	r3, [pc, #56]	; (800a304 <HAL_HASH_Init+0x5c>)

    /* Change the HASH state */
  hhash->State = HAL_HASH_STATE_BUSY;

  /* Reset HashInCount, HashITCounter, HashBuffSize and NbWordsAlreadyPushed */
  hhash->HashInCount = 0;
 800a2ca:	6220      	str	r0, [r4, #32]
  hhash->HashBuffSize = 0;
 800a2cc:	61e0      	str	r0, [r4, #28]
  hhash->HashITCounter = 0;
 800a2ce:	6260      	str	r0, [r4, #36]	; 0x24
  hhash->NbWordsAlreadyPushed = 0;
 800a2d0:	63a0      	str	r0, [r4, #56]	; 0x38
  hhash->Phase = HAL_HASH_PHASE_READY;
  /* Reset suspension request flag */
  hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;

  /* Set the data type bit */
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
 800a2d2:	681a      	ldr	r2, [r3, #0]
  hhash->HashInCount = 0;
  hhash->HashBuffSize = 0;
  hhash->HashITCounter = 0;
  hhash->NbWordsAlreadyPushed = 0;
  /* Reset digest calculation bridle (MDMAT bit control) */
  hhash->DigestCalculationDisable = RESET;
 800a2d4:	f884 0037 	strb.w	r0, [r4, #55]	; 0x37
  hhash->Phase = HAL_HASH_PHASE_READY;
  /* Reset suspension request flag */
  hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;

  /* Set the data type bit */
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
 800a2d8:	f022 0130 	bic.w	r1, r2, #48	; 0x30
 800a2dc:	6822      	ldr	r2, [r4, #0]
  /* Reset digest calculation bridle (MDMAT bit control) */
  hhash->DigestCalculationDisable = RESET;
  /* Set phase to READY */
  hhash->Phase = HAL_HASH_PHASE_READY;
  /* Reset suspension request flag */
  hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;
 800a2de:	f884 0036 	strb.w	r0, [r4, #54]	; 0x36
  hhash->HashITCounter = 0;
  hhash->NbWordsAlreadyPushed = 0;
  /* Reset digest calculation bridle (MDMAT bit control) */
  hhash->DigestCalculationDisable = RESET;
  /* Set phase to READY */
  hhash->Phase = HAL_HASH_PHASE_READY;
 800a2e2:	2501      	movs	r5, #1
  /* Reset suspension request flag */
  hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;

  /* Set the data type bit */
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
 800a2e4:	430a      	orrs	r2, r1
  hhash->HashITCounter = 0;
  hhash->NbWordsAlreadyPushed = 0;
  /* Reset digest calculation bridle (MDMAT bit control) */
  hhash->DigestCalculationDisable = RESET;
  /* Set phase to READY */
  hhash->Phase = HAL_HASH_PHASE_READY;
 800a2e6:	f884 502d 	strb.w	r5, [r4, #45]	; 0x2d
  /* Reset suspension request flag */
  hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;

  /* Set the data type bit */
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
 800a2ea:	601a      	str	r2, [r3, #0]
  /* Reset MDMAT bit */
__HAL_HASH_RESET_MDMAT();
 800a2ec:	681a      	ldr	r2, [r3, #0]
 800a2ee:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800a2f2:	601a      	str	r2, [r3, #0]
  /* Reset HASH handle status */
  hhash->Status = HAL_OK;

  /* Set the HASH state to Ready */
  hhash->State = HAL_HASH_STATE_READY;
 800a2f4:	f884 5035 	strb.w	r5, [r4, #53]	; 0x35
  /* Set the data type bit */
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
  /* Reset MDMAT bit */
__HAL_HASH_RESET_MDMAT();
  /* Reset HASH handle status */
  hhash->Status = HAL_OK;
 800a2f8:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c

  /* Set the HASH state to Ready */
  hhash->State = HAL_HASH_STATE_READY;

  /* Initialise the error code */
  hhash->ErrorCode = HAL_HASH_ERROR_NONE;
 800a2fc:	63e0      	str	r0, [r4, #60]	; 0x3c

  /* Return function status */
  return HAL_OK;
 800a2fe:	bd38      	pop	{r3, r4, r5, pc}
HAL_StatusTypeDef HAL_HASH_Init(HASH_HandleTypeDef *hhash)
{
  /* Check the hash handle allocation */
  if(hhash == NULL)
  {
    return HAL_ERROR;
 800a300:	2001      	movs	r0, #1
  /* Initialise the error code */
  hhash->ErrorCode = HAL_HASH_ERROR_NONE;

  /* Return function status */
  return HAL_OK;
}
 800a302:	bd38      	pop	{r3, r4, r5, pc}
 800a304:	50060400 	.word	0x50060400

0800a308 <HAL_HASH_MspDeInit>:
 800a308:	4770      	bx	lr

0800a30a <HAL_HASH_InCpltCallback>:
 800a30a:	4770      	bx	lr

0800a30c <HAL_HASH_DgstCpltCallback>:
 800a30c:	4770      	bx	lr

0800a30e <HAL_HASH_ErrorCallback>:
  *         to retrieve the error type.
  * @param  hhash HASH handle.
  * @retval None
  */
__weak void HAL_HASH_ErrorCallback(HASH_HandleTypeDef *hhash)
{
 800a30e:	4770      	bx	lr

0800a310 <HAL_HASH_IRQHandler>:
  *        HAL_HASH_ErrorCallback() API is called so that user code can
  *        manage the error. The error type is available in hhash->Status field.
  * @retval None
  */
void HAL_HASH_IRQHandler(HASH_HandleTypeDef *hhash)
{
 800a310:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *         suspension time is stored in the handle for resumption later on.
  * @retval HAL status
  */
static HAL_StatusTypeDef HASH_IT(HASH_HandleTypeDef *hhash)
{
  if (hhash->State == HAL_HASH_STATE_BUSY)
 800a312:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 800a316:	b2db      	uxtb	r3, r3
 800a318:	2b02      	cmp	r3, #2
  *        HAL_HASH_ErrorCallback() API is called so that user code can
  *        manage the error. The error type is available in hhash->Status field.
  * @retval None
  */
void HAL_HASH_IRQHandler(HASH_HandleTypeDef *hhash)
{
 800a31a:	4604      	mov	r4, r0
  *         suspension time is stored in the handle for resumption later on.
  * @retval HAL status
  */
static HAL_StatusTypeDef HASH_IT(HASH_HandleTypeDef *hhash)
{
  if (hhash->State == HAL_HASH_STATE_BUSY)
 800a31c:	f040 80de 	bne.w	800a4dc <HAL_HASH_IRQHandler+0x1cc>
  {
    /* ITCounter must not be equal to 0 at this point. Report an error if this is the case. */
    if(hhash->HashITCounter == 0U)
 800a320:	6a42      	ldr	r2, [r0, #36]	; 0x24
 800a322:	4d77      	ldr	r5, [pc, #476]	; (800a500 <HAL_HASH_IRQHandler+0x1f0>)
 800a324:	b93a      	cbnz	r2, 800a336 <HAL_HASH_IRQHandler+0x26>
    {
      /* Disable Interrupts */
      __HAL_HASH_DISABLE_IT(HASH_IT_DINI|HASH_IT_DCI);
 800a326:	6a2b      	ldr	r3, [r5, #32]
      /* HASH state set back to Ready to prevent any issue in user code
         present in HAL_HASH_ErrorCallback() */
      hhash->State = HAL_HASH_STATE_READY;
 800a328:	2001      	movs	r0, #1
  {
    /* ITCounter must not be equal to 0 at this point. Report an error if this is the case. */
    if(hhash->HashITCounter == 0U)
    {
      /* Disable Interrupts */
      __HAL_HASH_DISABLE_IT(HASH_IT_DINI|HASH_IT_DCI);
 800a32a:	f023 0303 	bic.w	r3, r3, #3
 800a32e:	622b      	str	r3, [r5, #32]
      /* HASH state set back to Ready to prevent any issue in user code
         present in HAL_HASH_ErrorCallback() */
      hhash->State = HAL_HASH_STATE_READY;
 800a330:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
 800a334:	e0d3      	b.n	800a4de <HAL_HASH_IRQHandler+0x1ce>
      return HAL_ERROR;
    }
    else if (hhash->HashITCounter == 1U)
 800a336:	6a42      	ldr	r2, [r0, #36]	; 0x24
 800a338:	2a01      	cmp	r2, #1
    }
    else
    {
      /* Cruise speed reached, HashITCounter remains equal to 3 until the end of
        the HASH processing or the end of the current step for HMAC processing. */
      hhash->HashITCounter = 3U;
 800a33a:	bf18      	it	ne
 800a33c:	2303      	movne	r3, #3
 800a33e:	6243      	str	r3, [r0, #36]	; 0x24
    }

    /* If digest is ready */
    if (__HAL_HASH_GET_FLAG(HASH_FLAG_DCIS))
 800a340:	6a68      	ldr	r0, [r5, #36]	; 0x24
 800a342:	4b6f      	ldr	r3, [pc, #444]	; (800a500 <HAL_HASH_IRQHandler+0x1f0>)
 800a344:	f010 0002 	ands.w	r0, r0, #2
 800a348:	d025      	beq.n	800a396 <HAL_HASH_IRQHandler+0x86>
    {
      /* Read the digest */
      HASH_GetDigest(hhash->pHashOutBuffPtr, HASH_DIGEST_LENGTH());
 800a34a:	6819      	ldr	r1, [r3, #0]
 800a34c:	4a6d      	ldr	r2, [pc, #436]	; (800a504 <HAL_HASH_IRQHandler+0x1f4>)
 800a34e:	6920      	ldr	r0, [r4, #16]
 800a350:	400a      	ands	r2, r1
 800a352:	b172      	cbz	r2, 800a372 <HAL_HASH_IRQHandler+0x62>
 800a354:	6819      	ldr	r1, [r3, #0]
 800a356:	4a6b      	ldr	r2, [pc, #428]	; (800a504 <HAL_HASH_IRQHandler+0x1f4>)
 800a358:	400a      	ands	r2, r1
 800a35a:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
 800a35e:	d00a      	beq.n	800a376 <HAL_HASH_IRQHandler+0x66>
 800a360:	681a      	ldr	r2, [r3, #0]
 800a362:	4b68      	ldr	r3, [pc, #416]	; (800a504 <HAL_HASH_IRQHandler+0x1f4>)
 800a364:	4967      	ldr	r1, [pc, #412]	; (800a504 <HAL_HASH_IRQHandler+0x1f4>)
 800a366:	4013      	ands	r3, r2
 800a368:	428b      	cmp	r3, r1
 800a36a:	bf0c      	ite	eq
 800a36c:	2120      	moveq	r1, #32
 800a36e:	2110      	movne	r1, #16
 800a370:	e002      	b.n	800a378 <HAL_HASH_IRQHandler+0x68>
 800a372:	2114      	movs	r1, #20
 800a374:	e000      	b.n	800a378 <HAL_HASH_IRQHandler+0x68>
 800a376:	211c      	movs	r1, #28
 800a378:	f7ff feea 	bl	800a150 <HASH_GetDigest>

      /* Disable Interrupts */
      __HAL_HASH_DISABLE_IT(HASH_IT_DINI|HASH_IT_DCI);
 800a37c:	6a2b      	ldr	r3, [r5, #32]
 800a37e:	f023 0303 	bic.w	r3, r3, #3
 800a382:	622b      	str	r3, [r5, #32]
      /* Change the HASH state */
      hhash->State = HAL_HASH_STATE_READY;
 800a384:	2301      	movs	r3, #1
 800a386:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      /* Reset HASH state machine */
      hhash->Phase = HAL_HASH_PHASE_READY;
 800a38a:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
      /* Call digest computation complete call back */
#if (USE_HAL_HASH_REGISTER_CALLBACKS == 1)
      hhash->DgstCpltCallback(hhash);
#else
      HAL_HASH_DgstCpltCallback(hhash);
 800a38e:	4620      	mov	r0, r4
 800a390:	f7ff ffbc 	bl	800a30c <HAL_HASH_DgstCpltCallback>
 800a394:	e0b1      	b.n	800a4fa <HAL_HASH_IRQHandler+0x1ea>

      return HAL_OK;
    }

    /* If Peripheral ready to accept new data */
    if (__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))
 800a396:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800a398:	07d2      	lsls	r2, r2, #31
 800a39a:	f140 80ae 	bpl.w	800a4fa <HAL_HASH_IRQHandler+0x1ea>
    {

      /* If the suspension flag has been raised and if the processing is not about
         to end, suspend processing */
      if ( (hhash->HashInCount != 0U) &&  (hhash->SuspendRequest == HAL_HASH_SUSPEND))
 800a39e:	6a22      	ldr	r2, [r4, #32]
 800a3a0:	b16a      	cbz	r2, 800a3be <HAL_HASH_IRQHandler+0xae>
 800a3a2:	f894 2036 	ldrb.w	r2, [r4, #54]	; 0x36
 800a3a6:	2a01      	cmp	r2, #1
 800a3a8:	d109      	bne.n	800a3be <HAL_HASH_IRQHandler+0xae>
      {
        /* Disable Interrupts */
        __HAL_HASH_DISABLE_IT(HASH_IT_DINI|HASH_IT_DCI);
 800a3aa:	6a1a      	ldr	r2, [r3, #32]
 800a3ac:	f022 0203 	bic.w	r2, r2, #3
 800a3b0:	621a      	str	r2, [r3, #32]

        /* Reset SuspendRequest */
        hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;

        /* Change the HASH state */
        hhash->State = HAL_HASH_STATE_SUSPENDED;
 800a3b2:	2308      	movs	r3, #8
      {
        /* Disable Interrupts */
        __HAL_HASH_DISABLE_IT(HASH_IT_DINI|HASH_IT_DCI);

        /* Reset SuspendRequest */
        hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;
 800a3b4:	f884 0036 	strb.w	r0, [r4, #54]	; 0x36

        /* Change the HASH state */
        hhash->State = HAL_HASH_STATE_SUSPENDED;
 800a3b8:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
 800a3bc:	e08f      	b.n	800a4de <HAL_HASH_IRQHandler+0x1ce>
  uint32_t buffercounter;
  uint32_t inputcounter;
  uint32_t ret = HASH_DIGEST_CALCULATION_NOT_STARTED;

  /* If there are more than 64 bytes remaining to be entered */
  if(hhash->HashInCount > 64U)
 800a3be:	6a23      	ldr	r3, [r4, #32]
 800a3c0:	2b40      	cmp	r3, #64	; 0x40
 800a3c2:	68e3      	ldr	r3, [r4, #12]
 800a3c4:	d91e      	bls.n	800a404 <HAL_HASH_IRQHandler+0xf4>
 800a3c6:	f103 0140 	add.w	r1, r3, #64	; 0x40
  {
    inputaddr = (uint32_t)hhash->pHashInBuffPtr;
 800a3ca:	461a      	mov	r2, r3
    /* Write the Input block in the Data IN register
      (16 32-bit words, or 64 bytes are entered) */
    for(buffercounter = 0U; buffercounter < 64U; buffercounter+=4U)
    {
      HASH->DIN = *(uint32_t*)inputaddr;
 800a3cc:	f852 0b04 	ldr.w	r0, [r2], #4
 800a3d0:	6068      	str	r0, [r5, #4]
  if(hhash->HashInCount > 64U)
  {
    inputaddr = (uint32_t)hhash->pHashInBuffPtr;
    /* Write the Input block in the Data IN register
      (16 32-bit words, or 64 bytes are entered) */
    for(buffercounter = 0U; buffercounter < 64U; buffercounter+=4U)
 800a3d2:	428a      	cmp	r2, r1
 800a3d4:	d1fa      	bne.n	800a3cc <HAL_HASH_IRQHandler+0xbc>
      HASH->DIN = *(uint32_t*)inputaddr;
      inputaddr+=4U;
    }
    /* If this is the start of input data entering, an additional word
      must be entered to start up the HASH processing */
    if(hhash->HashITCounter == 2U)
 800a3d6:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800a3d8:	2902      	cmp	r1, #2
 800a3da:	d10e      	bne.n	800a3fa <HAL_HASH_IRQHandler+0xea>
    {
      HASH->DIN = *(uint32_t*)inputaddr;
 800a3dc:	4a48      	ldr	r2, [pc, #288]	; (800a500 <HAL_HASH_IRQHandler+0x1f0>)
 800a3de:	6c19      	ldr	r1, [r3, #64]	; 0x40
 800a3e0:	6051      	str	r1, [r2, #4]
      if(hhash->HashInCount >= 68U)
 800a3e2:	6a22      	ldr	r2, [r4, #32]
 800a3e4:	2a43      	cmp	r2, #67	; 0x43
      {
        /* There are still data waiting to be entered in the Peripheral.
           Decrement buffer counter and set pointer to the proper
           memory location for the next data entering round. */
        hhash->HashInCount -= 68U;
 800a3e6:	bf83      	ittte	hi
 800a3e8:	6a22      	ldrhi	r2, [r4, #32]
        hhash->pHashInBuffPtr+= 68U;
 800a3ea:	3344      	addhi	r3, #68	; 0x44
      if(hhash->HashInCount >= 68U)
      {
        /* There are still data waiting to be entered in the Peripheral.
           Decrement buffer counter and set pointer to the proper
           memory location for the next data entering round. */
        hhash->HashInCount -= 68U;
 800a3ec:	3a44      	subhi	r2, #68	; 0x44
        hhash->pHashInBuffPtr+= 68U;
      }
      else
      {
        /* All the input buffer has been fed to the HW. */
        hhash->HashInCount = 0U;
 800a3ee:	2300      	movls	r3, #0
      if(hhash->HashInCount >= 68U)
      {
        /* There are still data waiting to be entered in the Peripheral.
           Decrement buffer counter and set pointer to the proper
           memory location for the next data entering round. */
        hhash->HashInCount -= 68U;
 800a3f0:	bf86      	itte	hi
 800a3f2:	6222      	strhi	r2, [r4, #32]
        hhash->pHashInBuffPtr+= 68U;
 800a3f4:	60e3      	strhi	r3, [r4, #12]
      }
      else
      {
        /* All the input buffer has been fed to the HW. */
        hhash->HashInCount = 0U;
 800a3f6:	6223      	strls	r3, [r4, #32]
 800a3f8:	e07f      	b.n	800a4fa <HAL_HASH_IRQHandler+0x1ea>
    else
    {
      /* 64 bytes have been entered and there are still some remaining:
         Decrement buffer counter and set pointer to the proper
        memory location for the next data entering round.*/
      hhash->HashInCount -= 64U;
 800a3fa:	6a23      	ldr	r3, [r4, #32]
      hhash->pHashInBuffPtr+= 64U;
 800a3fc:	60e2      	str	r2, [r4, #12]
    else
    {
      /* 64 bytes have been entered and there are still some remaining:
         Decrement buffer counter and set pointer to the proper
        memory location for the next data entering round.*/
      hhash->HashInCount -= 64U;
 800a3fe:	3b40      	subs	r3, #64	; 0x40
 800a400:	6223      	str	r3, [r4, #32]
 800a402:	e07a      	b.n	800a4fa <HAL_HASH_IRQHandler+0x1ea>
      data entering round. */

    /* Get the buffer address */
    inputaddr = (uint32_t)hhash->pHashInBuffPtr;
    /* Get the buffer counter */
    inputcounter = hhash->HashInCount;
 800a404:	6a22      	ldr	r2, [r4, #32]
    /* Disable Interrupts */
    __HAL_HASH_DISABLE_IT(HASH_IT_DINI);
 800a406:	6a29      	ldr	r1, [r5, #32]
 800a408:	3203      	adds	r2, #3
 800a40a:	f021 0101 	bic.w	r1, r1, #1
 800a40e:	f022 0203 	bic.w	r2, r2, #3
 800a412:	6229      	str	r1, [r5, #32]
 800a414:	441a      	add	r2, r3

    /* Write the Input block in the Data IN register */
    for(buffercounter = 0U; buffercounter < ((inputcounter+3U)/4U); buffercounter++)
 800a416:	429a      	cmp	r2, r3
 800a418:	d003      	beq.n	800a422 <HAL_HASH_IRQHandler+0x112>
    {
      HASH->DIN = *(uint32_t*)inputaddr;
 800a41a:	f853 1b04 	ldr.w	r1, [r3], #4
 800a41e:	6069      	str	r1, [r5, #4]
 800a420:	e7f9      	b.n	800a416 <HAL_HASH_IRQHandler+0x106>
      inputaddr+=4U;
    }

    if (hhash->Accumulation == 1U)
 800a422:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800a424:	2b01      	cmp	r3, #1
 800a426:	d107      	bne.n	800a438 <HAL_HASH_IRQHandler+0x128>
    {
      /* Field accumulation is set, API only feeds data to the Peripheral and under interruption.
         The digest computation will be started when the last buffer data are entered. */

      /* Reset multi buffers accumulation flag */
      hhash->Accumulation = 0U;
 800a428:	2600      	movs	r6, #0
 800a42a:	6426      	str	r6, [r4, #64]	; 0x40
      hhash->State = HAL_HASH_STATE_READY;
      /* Call Input data transfer complete call back */
#if (USE_HAL_HASH_REGISTER_CALLBACKS == 1)
        hhash->InCpltCallback(hhash);
#else
        HAL_HASH_InCpltCallback(hhash);
 800a42c:	4620      	mov	r0, r4
         The digest computation will be started when the last buffer data are entered. */

      /* Reset multi buffers accumulation flag */
      hhash->Accumulation = 0U;
      /* Change the HASH state */
      hhash->State = HAL_HASH_STATE_READY;
 800a42e:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      /* Call Input data transfer complete call back */
#if (USE_HAL_HASH_REGISTER_CALLBACKS == 1)
        hhash->InCpltCallback(hhash);
#else
        HAL_HASH_InCpltCallback(hhash);
 800a432:	f7ff ff6a 	bl	800a30a <HAL_HASH_InCpltCallback>
 800a436:	e004      	b.n	800a442 <HAL_HASH_IRQHandler+0x132>
#endif /* USE_HAL_HASH_REGISTER_CALLBACKS */
    }
    else
    {
      /* Start the Digest calculation */
      __HAL_HASH_START_DIGEST();
 800a438:	68ab      	ldr	r3, [r5, #8]
 800a43a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800a43e:	60ab      	str	r3, [r5, #8]
      /* Return indication that digest calculation has started:
         this return value triggers the call to Input data transfer
         complete call back as well as the proper transition from
         one step to another in HMAC mode. */
      ret = HASH_DIGEST_CALCULATION_STARTED;
 800a440:	2601      	movs	r6, #1
    }
    /* Reset buffer counter */
    hhash->HashInCount = 0;
 800a442:	2300      	movs	r3, #0
 800a444:	6223      	str	r3, [r4, #32]
        return HAL_OK;
      }

      /* Enter input data in the Peripheral thru HASH_Write_Block_Data() call and
        check whether the digest calculation has been triggered */
      if (HASH_Write_Block_Data(hhash) == HASH_DIGEST_CALCULATION_STARTED)
 800a446:	2e00      	cmp	r6, #0
 800a448:	d057      	beq.n	800a4fa <HAL_HASH_IRQHandler+0x1ea>
        /* Call Input data transfer complete call back
           (called at the end of each step for HMAC) */
#if (USE_HAL_HASH_REGISTER_CALLBACKS == 1)
        hhash->InCpltCallback(hhash);
#else
        HAL_HASH_InCpltCallback(hhash);
 800a44a:	4620      	mov	r0, r4
 800a44c:	f7ff ff5d 	bl	800a30a <HAL_HASH_InCpltCallback>
#endif /* USE_HAL_HASH_REGISTER_CALLBACKS */

        if (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_1)
 800a450:	f894 702d 	ldrb.w	r7, [r4, #45]	; 0x2d
 800a454:	2f03      	cmp	r7, #3
 800a456:	d11c      	bne.n	800a492 <HAL_HASH_IRQHandler+0x182>
        {
          /* Wait until Peripheral is not busy anymore */
          if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_BUSY, SET, HASH_TIMEOUTVALUE) != HAL_OK)
 800a458:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800a45c:	4632      	mov	r2, r6
 800a45e:	2108      	movs	r1, #8
 800a460:	4620      	mov	r0, r4
 800a462:	f7ff fed7 	bl	800a214 <HASH_WaitOnFlagUntilTimeout>
 800a466:	b128      	cbz	r0, 800a474 <HAL_HASH_IRQHandler+0x164>
          {
            /* Disable Interrupts */
            __HAL_HASH_DISABLE_IT(HASH_IT_DINI|HASH_IT_DCI);
 800a468:	6a2b      	ldr	r3, [r5, #32]
 800a46a:	f023 0303 	bic.w	r3, r3, #3
 800a46e:	622b      	str	r3, [r5, #32]
            return HAL_TIMEOUT;
 800a470:	4638      	mov	r0, r7
 800a472:	e034      	b.n	800a4de <HAL_HASH_IRQHandler+0x1ce>
          }
          /* Initialization start for HMAC STEP 2 */
          hhash->Phase = HAL_HASH_PHASE_HMAC_STEP_2;        /* Move phase from Step 1 to Step 2 */
 800a474:	2304      	movs	r3, #4
          __HAL_HASH_SET_NBVALIDBITS(hhash->HashBuffSize);  /* Set NBLW for the input message */
 800a476:	69e2      	ldr	r2, [r4, #28]
            /* Disable Interrupts */
            __HAL_HASH_DISABLE_IT(HASH_IT_DINI|HASH_IT_DCI);
            return HAL_TIMEOUT;
          }
          /* Initialization start for HMAC STEP 2 */
          hhash->Phase = HAL_HASH_PHASE_HMAC_STEP_2;        /* Move phase from Step 1 to Step 2 */
 800a478:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
          __HAL_HASH_SET_NBVALIDBITS(hhash->HashBuffSize);  /* Set NBLW for the input message */
 800a47c:	68ab      	ldr	r3, [r5, #8]
 800a47e:	f002 0103 	and.w	r1, r2, #3
 800a482:	f023 031f 	bic.w	r3, r3, #31
 800a486:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800a48a:	60ab      	str	r3, [r5, #8]
          hhash->HashInCount = hhash->HashBuffSize;         /* Set the input data size (in bytes) */
 800a48c:	6222      	str	r2, [r4, #32]
          hhash->pHashInBuffPtr = hhash->pHashMsgBuffPtr;   /* Set the input data address */
 800a48e:	69a3      	ldr	r3, [r4, #24]
 800a490:	e01d      	b.n	800a4ce <HAL_HASH_IRQHandler+0x1be>
          hhash->HashITCounter = 1;                         /* Set ITCounter to 1 to indicate the start of a new phase */
          __HAL_HASH_ENABLE_IT(HASH_IT_DINI);               /* Enable IT (was disabled in HASH_Write_Block_Data) */
        }
        else if (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_2)
 800a492:	2f04      	cmp	r7, #4
 800a494:	d131      	bne.n	800a4fa <HAL_HASH_IRQHandler+0x1ea>
        {
          /* Wait until Peripheral is not busy anymore */
          if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_BUSY, SET, HASH_TIMEOUTVALUE) != HAL_OK)
 800a496:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800a49a:	4632      	mov	r2, r6
 800a49c:	2108      	movs	r1, #8
 800a49e:	4620      	mov	r0, r4
 800a4a0:	f7ff feb8 	bl	800a214 <HASH_WaitOnFlagUntilTimeout>
 800a4a4:	b128      	cbz	r0, 800a4b2 <HAL_HASH_IRQHandler+0x1a2>
          {
            /* Disable Interrupts */
            __HAL_HASH_DISABLE_IT(HASH_IT_DINI|HASH_IT_DCI);
 800a4a6:	6a2b      	ldr	r3, [r5, #32]
 800a4a8:	f023 0303 	bic.w	r3, r3, #3
 800a4ac:	622b      	str	r3, [r5, #32]
            return HAL_TIMEOUT;
 800a4ae:	2003      	movs	r0, #3
 800a4b0:	e015      	b.n	800a4de <HAL_HASH_IRQHandler+0x1ce>
          }
          /* Initialization start for HMAC STEP 3 */
          hhash->Phase = HAL_HASH_PHASE_HMAC_STEP_3;         /* Move phase from Step 2 to Step 3 */
 800a4b2:	2305      	movs	r3, #5
          __HAL_HASH_SET_NBVALIDBITS(hhash->Init.KeySize);   /* Set NBLW for the key */
 800a4b4:	6862      	ldr	r2, [r4, #4]
            /* Disable Interrupts */
            __HAL_HASH_DISABLE_IT(HASH_IT_DINI|HASH_IT_DCI);
            return HAL_TIMEOUT;
          }
          /* Initialization start for HMAC STEP 3 */
          hhash->Phase = HAL_HASH_PHASE_HMAC_STEP_3;         /* Move phase from Step 2 to Step 3 */
 800a4b6:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
          __HAL_HASH_SET_NBVALIDBITS(hhash->Init.KeySize);   /* Set NBLW for the key */
 800a4ba:	68ab      	ldr	r3, [r5, #8]
 800a4bc:	f002 0103 	and.w	r1, r2, #3
 800a4c0:	f023 031f 	bic.w	r3, r3, #31
 800a4c4:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800a4c8:	60ab      	str	r3, [r5, #8]
          hhash->HashInCount = hhash->Init.KeySize;          /* Set the key size (in bytes) */
          hhash->pHashInBuffPtr = hhash->Init.pKey;          /* Set the key address */
 800a4ca:	68a3      	ldr	r3, [r4, #8]
            return HAL_TIMEOUT;
          }
          /* Initialization start for HMAC STEP 3 */
          hhash->Phase = HAL_HASH_PHASE_HMAC_STEP_3;         /* Move phase from Step 2 to Step 3 */
          __HAL_HASH_SET_NBVALIDBITS(hhash->Init.KeySize);   /* Set NBLW for the key */
          hhash->HashInCount = hhash->Init.KeySize;          /* Set the key size (in bytes) */
 800a4cc:	6222      	str	r2, [r4, #32]
          hhash->pHashInBuffPtr = hhash->Init.pKey;          /* Set the key address */
          hhash->HashITCounter = 1;                          /* Set ITCounter to 1 to indicate the start of a new phase */
 800a4ce:	6266      	str	r6, [r4, #36]	; 0x24
          }
          /* Initialization start for HMAC STEP 3 */
          hhash->Phase = HAL_HASH_PHASE_HMAC_STEP_3;         /* Move phase from Step 2 to Step 3 */
          __HAL_HASH_SET_NBVALIDBITS(hhash->Init.KeySize);   /* Set NBLW for the key */
          hhash->HashInCount = hhash->Init.KeySize;          /* Set the key size (in bytes) */
          hhash->pHashInBuffPtr = hhash->Init.pKey;          /* Set the key address */
 800a4d0:	60e3      	str	r3, [r4, #12]
          hhash->HashITCounter = 1;                          /* Set ITCounter to 1 to indicate the start of a new phase */
          __HAL_HASH_ENABLE_IT(HASH_IT_DINI);                /* Enable IT (was disabled in HASH_Write_Block_Data) */
 800a4d2:	6a2b      	ldr	r3, [r5, #32]
 800a4d4:	f043 0301 	orr.w	r3, r3, #1
 800a4d8:	622b      	str	r3, [r5, #32]
 800a4da:	e000      	b.n	800a4de <HAL_HASH_IRQHandler+0x1ce>
    /* Return function status */
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 800a4dc:	2002      	movs	r0, #2
  *        manage the error. The error type is available in hhash->Status field.
  * @retval None
  */
void HAL_HASH_IRQHandler(HASH_HandleTypeDef *hhash)
{
  hhash->Status = HASH_IT(hhash);
 800a4de:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
  if (hhash->Status != HAL_OK)
 800a4e2:	b160      	cbz	r0, 800a4fe <HAL_HASH_IRQHandler+0x1ee>
  {
    hhash->ErrorCode |= HAL_HASH_ERROR_IT;
 800a4e4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800a4e6:	f043 0301 	orr.w	r3, r3, #1
 800a4ea:	63e3      	str	r3, [r4, #60]	; 0x3c
#if (USE_HAL_HASH_REGISTER_CALLBACKS == 1)
    hhash->ErrorCallback(hhash);
#else
    HAL_HASH_ErrorCallback(hhash);
 800a4ec:	4620      	mov	r0, r4
 800a4ee:	f7ff ff0e 	bl	800a30e <HAL_HASH_ErrorCallback>
#endif /* USE_HAL_HASH_REGISTER_CALLBACKS */
    /* After error handling by code user, reset HASH handle HAL status */
    hhash->Status = HAL_OK;
 800a4f2:	2300      	movs	r3, #0
 800a4f4:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  }
}
 800a4f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        }
      } /* if (HASH_Write_Block_Data(hhash) == HASH_DIGEST_CALCULATION_STARTED) */
    }  /* if (__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))*/

    /* Return function status */
    return HAL_OK;
 800a4fa:	2000      	movs	r0, #0
 800a4fc:	e7ef      	b.n	800a4de <HAL_HASH_IRQHandler+0x1ce>
 800a4fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a500:	50060400 	.word	0x50060400
 800a504:	00040080 	.word	0x00040080

0800a508 <HAL_HASH_GetState>:
  * @param  hhash HASH handle.
  * @retval HAL HASH state
  */
HAL_HASH_StateTypeDef HAL_HASH_GetState(HASH_HandleTypeDef *hhash)
{
  return hhash->State;
 800a508:	f890 0035 	ldrb.w	r0, [r0, #53]	; 0x35
}
 800a50c:	4770      	bx	lr

0800a50e <HAL_HASH_GetStatus>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASH_GetStatus(HASH_HandleTypeDef *hhash)
{
  return hhash->Status;
}
 800a50e:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 800a512:	4770      	bx	lr

0800a514 <HAL_HASH_ContextSaving>:

  /* Prevent unused argument(s) compilation warning */
  UNUSED(hhash);

  /* Save IMR register content */
  *(uint32_t*)(mem_ptr) = READ_BIT(HASH->IMR,HASH_IT_DINI|HASH_IT_DCI);
 800a514:	4b0b      	ldr	r3, [pc, #44]	; (800a544 <HAL_HASH_ContextSaving+0x30>)
 800a516:	6a1a      	ldr	r2, [r3, #32]
 800a518:	f002 0203 	and.w	r2, r2, #3
 800a51c:	600a      	str	r2, [r1, #0]
  mem_ptr+=4U;
  /* Save STR register content */
  *(uint32_t*)(mem_ptr) = READ_BIT(HASH->STR,HASH_STR_NBLW);
 800a51e:	689a      	ldr	r2, [r3, #8]
 800a520:	f002 021f 	and.w	r2, r2, #31
 800a524:	604a      	str	r2, [r1, #4]
  mem_ptr+=4U;
  /* Save CR register content */
  *(uint32_t*)(mem_ptr) = READ_BIT(HASH->CR,HASH_CR_DMAE|HASH_CR_DATATYPE|HASH_CR_MODE|HASH_CR_ALGO|HASH_CR_LKEY|HASH_CR_MDMAT);
 800a526:	681a      	ldr	r2, [r3, #0]
 800a528:	4b07      	ldr	r3, [pc, #28]	; (800a548 <HAL_HASH_ContextSaving+0x34>)
 800a52a:	4013      	ands	r3, r2
 800a52c:	608b      	str	r3, [r1, #8]
  mem_ptr+=4U;
  /* By default, save all CSRs registers */
  for (i = HASH_NUMBER_OF_CSR_REGISTERS; i >0U; i--)
 800a52e:	4a07      	ldr	r2, [pc, #28]	; (800a54c <HAL_HASH_ContextSaving+0x38>)
  /* Save STR register content */
  *(uint32_t*)(mem_ptr) = READ_BIT(HASH->STR,HASH_STR_NBLW);
  mem_ptr+=4U;
  /* Save CR register content */
  *(uint32_t*)(mem_ptr) = READ_BIT(HASH->CR,HASH_CR_DMAE|HASH_CR_DATATYPE|HASH_CR_MODE|HASH_CR_ALGO|HASH_CR_LKEY|HASH_CR_MDMAT);
  mem_ptr+=4U;
 800a530:	4b07      	ldr	r3, [pc, #28]	; (800a550 <HAL_HASH_ContextSaving+0x3c>)
 800a532:	310c      	adds	r1, #12
  /* By default, save all CSRs registers */
  for (i = HASH_NUMBER_OF_CSR_REGISTERS; i >0U; i--)
  {
    *(uint32_t*)(mem_ptr) = *(uint32_t*)(csr_ptr);
 800a534:	f853 0f04 	ldr.w	r0, [r3, #4]!
 800a538:	f841 0b04 	str.w	r0, [r1], #4
  mem_ptr+=4U;
  /* Save CR register content */
  *(uint32_t*)(mem_ptr) = READ_BIT(HASH->CR,HASH_CR_DMAE|HASH_CR_DATATYPE|HASH_CR_MODE|HASH_CR_ALGO|HASH_CR_LKEY|HASH_CR_MDMAT);
  mem_ptr+=4U;
  /* By default, save all CSRs registers */
  for (i = HASH_NUMBER_OF_CSR_REGISTERS; i >0U; i--)
 800a53c:	4293      	cmp	r3, r2
 800a53e:	d1f9      	bne.n	800a534 <HAL_HASH_ContextSaving+0x20>
  {
    *(uint32_t*)(mem_ptr) = *(uint32_t*)(csr_ptr);
    mem_ptr+=4U;
    csr_ptr+=4U;
  }
}
 800a540:	4770      	bx	lr
 800a542:	bf00      	nop
 800a544:	50060400 	.word	0x50060400
 800a548:	000520f8 	.word	0x000520f8
 800a54c:	500605cc 	.word	0x500605cc
 800a550:	500604f4 	.word	0x500604f4

0800a554 <HAL_HASH_ContextRestoring>:

  /* Prevent unused argument(s) compilation warning */
  UNUSED(hhash);

  /* Restore IMR register content */
  WRITE_REG(HASH->IMR, (*(uint32_t*)(mem_ptr)));
 800a554:	4b0a      	ldr	r3, [pc, #40]	; (800a580 <HAL_HASH_ContextRestoring+0x2c>)
 800a556:	680a      	ldr	r2, [r1, #0]
 800a558:	621a      	str	r2, [r3, #32]
  mem_ptr+=4U;
  /* Restore STR register content */
  WRITE_REG(HASH->STR, (*(uint32_t*)(mem_ptr)));
 800a55a:	684a      	ldr	r2, [r1, #4]
 800a55c:	609a      	str	r2, [r3, #8]
  mem_ptr+=4U;
  /* Restore CR register content */
  WRITE_REG(HASH->CR, (*(uint32_t*)(mem_ptr)));
 800a55e:	688a      	ldr	r2, [r1, #8]
 800a560:	601a      	str	r2, [r3, #0]
  mem_ptr+=4U;

  /* Reset the HASH processor before restoring the Context
  Swap Registers (CSR) */
  __HAL_HASH_INIT();
 800a562:	681a      	ldr	r2, [r3, #0]
 800a564:	f042 0204 	orr.w	r2, r2, #4
 800a568:	601a      	str	r2, [r3, #0]

  /* By default, restore all CSR registers */
  for (i = HASH_NUMBER_OF_CSR_REGISTERS; i >0U; i--)
 800a56a:	4a06      	ldr	r2, [pc, #24]	; (800a584 <HAL_HASH_ContextRestoring+0x30>)
  WRITE_REG(HASH->CR, (*(uint32_t*)(mem_ptr)));
  mem_ptr+=4U;

  /* Reset the HASH processor before restoring the Context
  Swap Registers (CSR) */
  __HAL_HASH_INIT();
 800a56c:	3108      	adds	r1, #8
  * @retval None
  */
void HAL_HASH_ContextRestoring(HASH_HandleTypeDef *hhash, uint8_t* pMemBuffer)
{
  uint32_t mem_ptr = (uint32_t)pMemBuffer;
  uint32_t csr_ptr = (uint32_t)HASH->CSR;
 800a56e:	33f8      	adds	r3, #248	; 0xf8
  __HAL_HASH_INIT();

  /* By default, restore all CSR registers */
  for (i = HASH_NUMBER_OF_CSR_REGISTERS; i >0U; i--)
  {
    WRITE_REG((*(uint32_t*)(csr_ptr)), (*(uint32_t*)(mem_ptr)));
 800a570:	f851 0f04 	ldr.w	r0, [r1, #4]!
 800a574:	f843 0b04 	str.w	r0, [r3], #4
  /* Reset the HASH processor before restoring the Context
  Swap Registers (CSR) */
  __HAL_HASH_INIT();

  /* By default, restore all CSR registers */
  for (i = HASH_NUMBER_OF_CSR_REGISTERS; i >0U; i--)
 800a578:	4293      	cmp	r3, r2
 800a57a:	d1f9      	bne.n	800a570 <HAL_HASH_ContextRestoring+0x1c>
  {
    WRITE_REG((*(uint32_t*)(csr_ptr)), (*(uint32_t*)(mem_ptr)));
    mem_ptr+=4U;
    csr_ptr+=4U;
  }
}
 800a57c:	4770      	bx	lr
 800a57e:	bf00      	nop
 800a580:	50060400 	.word	0x50060400
 800a584:	500605d0 	.word	0x500605d0

0800a588 <HAL_HASH_SwFeed_ProcessSuspend>:
  * @retval None
  */
void HAL_HASH_SwFeed_ProcessSuspend(HASH_HandleTypeDef *hhash)
{
  /* Set Handle Suspend Request field */
  hhash->SuspendRequest = HAL_HASH_SUSPEND;
 800a588:	2301      	movs	r3, #1
 800a58a:	f880 3036 	strb.w	r3, [r0, #54]	; 0x36
 800a58e:	4770      	bx	lr

0800a590 <HAL_HASH_GetError>:
  * @retval HASH Error Code
*/
uint32_t HAL_HASH_GetError(HASH_HandleTypeDef *hhash)
{
  /* Return HASH Error Code */
  return hhash->ErrorCode;
 800a590:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
}
 800a592:	4770      	bx	lr

0800a594 <HASH_Start>:
  * @param  Timeout Timeout value.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout, uint32_t Algorithm)
{
 800a594:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a596:	461e      	mov	r6, r3
  uint8_t *pInBuffer_tmp;  /* input data address, input parameter of HASH_WriteData()         */
  uint32_t Size_tmp; /* input data size (in bytes), input parameter of HASH_WriteData() */
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 800a598:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 800a59c:	b2db      	uxtb	r3, r3


  /* Initiate HASH processing in case of start or resumption */
if((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 800a59e:	2b01      	cmp	r3, #1
  * @param  Timeout Timeout value.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout, uint32_t Algorithm)
{
 800a5a0:	4604      	mov	r4, r0
  uint32_t Size_tmp; /* input data size (in bytes), input parameter of HASH_WriteData() */
  HAL_HASH_StateTypeDef State_tmp = hhash->State;


  /* Initiate HASH processing in case of start or resumption */
if((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 800a5a2:	d001      	beq.n	800a5a8 <HASH_Start+0x14>
 800a5a4:	2b08      	cmp	r3, #8
 800a5a6:	d17c      	bne.n	800a6a2 <HASH_Start+0x10e>
  {
    /* Check input parameters */
    if ((pInBuffer == NULL) || (pOutBuffer == NULL))
 800a5a8:	b101      	cbz	r1, 800a5ac <HASH_Start+0x18>
 800a5aa:	b91e      	cbnz	r6, 800a5b4 <HASH_Start+0x20>
    {
      hhash->State = HAL_HASH_STATE_READY;
 800a5ac:	2501      	movs	r5, #1
 800a5ae:	f884 5035 	strb.w	r5, [r4, #53]	; 0x35
      return  HAL_ERROR;
 800a5b2:	e079      	b.n	800a6a8 <HASH_Start+0x114>
    }

    /* Process Locked */
    __HAL_LOCK(hhash);
 800a5b4:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 800a5b8:	2b01      	cmp	r3, #1
 800a5ba:	d072      	beq.n	800a6a2 <HASH_Start+0x10e>

    /* Check if initialization phase has not been already performed */
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 800a5bc:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
      hhash->State = HAL_HASH_STATE_READY;
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(hhash);
 800a5c0:	2501      	movs	r5, #1

    /* Check if initialization phase has not been already performed */
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 800a5c2:	42ab      	cmp	r3, r5
      hhash->State = HAL_HASH_STATE_READY;
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(hhash);
 800a5c4:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34

    /* Check if initialization phase has not been already performed */
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 800a5c8:	d118      	bne.n	800a5fc <HASH_Start+0x68>
    {
      /* Change the HASH state */
      hhash->State = HAL_HASH_STATE_BUSY;

      /* Select the HASH algorithm, clear HMAC mode and long key selection bit, reset the HASH processor core */
      MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);
 800a5ca:	4d38      	ldr	r5, [pc, #224]	; (800a6ac <HASH_Start+0x118>)
 800a5cc:	9807      	ldr	r0, [sp, #28]

    /* Check if initialization phase has not been already performed */
    if(hhash->Phase == HAL_HASH_PHASE_READY)
    {
      /* Change the HASH state */
      hhash->State = HAL_HASH_STATE_BUSY;
 800a5ce:	2702      	movs	r7, #2
 800a5d0:	f884 7035 	strb.w	r7, [r4, #53]	; 0x35

      /* Select the HASH algorithm, clear HMAC mode and long key selection bit, reset the HASH processor core */
      MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);
 800a5d4:	682b      	ldr	r3, [r5, #0]
 800a5d6:	f423 23a0 	bic.w	r3, r3, #327680	; 0x50000
 800a5da:	f023 03c4 	bic.w	r3, r3, #196	; 0xc4
 800a5de:	f043 0304 	orr.w	r3, r3, #4
 800a5e2:	4303      	orrs	r3, r0
 800a5e4:	602b      	str	r3, [r5, #0]

      /* Configure the number of valid bits in last word of the message */
      __HAL_HASH_SET_NBVALIDBITS(Size);
 800a5e6:	68a8      	ldr	r0, [r5, #8]
 800a5e8:	f002 0303 	and.w	r3, r2, #3
 800a5ec:	f020 001f 	bic.w	r0, r0, #31
 800a5f0:	ea40 03c3 	orr.w	r3, r0, r3, lsl #3
 800a5f4:	60ab      	str	r3, [r5, #8]
      input parameters of HASH_WriteData() */
      pInBuffer_tmp = pInBuffer;   /* pInBuffer_tmp is set to the input data address */
      Size_tmp = Size;             /* Size_tmp contains the input data size in bytes */

      /* Set the phase */
      hhash->Phase = HAL_HASH_PHASE_PROCESS;
 800a5f6:	f884 702d 	strb.w	r7, [r4, #45]	; 0x2d
 800a5fa:	e018      	b.n	800a62e <HASH_Start+0x9a>
    }
    else if (hhash->Phase == HAL_HASH_PHASE_PROCESS)
 800a5fc:	2b02      	cmp	r3, #2
 800a5fe:	d113      	bne.n	800a628 <HASH_Start+0x94>
    {
      /* if the Peripheral has already been initialized, two cases are possible */

      /* Process resumption time ... */
      if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 800a600:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 800a604:	2b08      	cmp	r3, #8
        /* pInBuffer_tmp and Size_tmp are initialized to be used afterwards as
        input parameters of HASH_WriteData() */
        pInBuffer_tmp = pInBuffer;
        Size_tmp = Size;
        /* Configure the number of valid bits in last word of the message */
        __HAL_HASH_SET_NBVALIDBITS(Size);
 800a606:	bf15      	itete	ne
 800a608:	4d28      	ldrne	r5, [pc, #160]	; (800a6ac <HASH_Start+0x118>)
      {
        /* Since this is resumption, pInBuffer_tmp and Size_tmp are not set
        to the API input parameters but to those saved beforehand by HASH_WriteData()
        when the processing was suspended */
        pInBuffer_tmp = hhash->pHashInBuffPtr;
        Size_tmp = hhash->HashInCount;
 800a60a:	6a22      	ldreq	r2, [r4, #32]
        /* pInBuffer_tmp and Size_tmp are initialized to be used afterwards as
        input parameters of HASH_WriteData() */
        pInBuffer_tmp = pInBuffer;
        Size_tmp = Size;
        /* Configure the number of valid bits in last word of the message */
        __HAL_HASH_SET_NBVALIDBITS(Size);
 800a60c:	68a8      	ldrne	r0, [r5, #8]
      if (hhash->State == HAL_HASH_STATE_SUSPENDED)
      {
        /* Since this is resumption, pInBuffer_tmp and Size_tmp are not set
        to the API input parameters but to those saved beforehand by HASH_WriteData()
        when the processing was suspended */
        pInBuffer_tmp = hhash->pHashInBuffPtr;
 800a60e:	68e1      	ldreq	r1, [r4, #12]
        /* pInBuffer_tmp and Size_tmp are initialized to be used afterwards as
        input parameters of HASH_WriteData() */
        pInBuffer_tmp = pInBuffer;
        Size_tmp = Size;
        /* Configure the number of valid bits in last word of the message */
        __HAL_HASH_SET_NBVALIDBITS(Size);
 800a610:	bf1f      	itttt	ne
 800a612:	f002 0303 	andne.w	r3, r2, #3
 800a616:	f020 001f 	bicne.w	r0, r0, #31
 800a61a:	ea40 03c3 	orrne.w	r3, r0, r3, lsl #3
 800a61e:	60ab      	strne	r3, [r5, #8]
      }
      /* Change the HASH state */
      hhash->State = HAL_HASH_STATE_BUSY;
 800a620:	2302      	movs	r3, #2
 800a622:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
 800a626:	e002      	b.n	800a62e <HASH_Start+0x9a>
    }
    else
    {
      /* Phase error */
      hhash->State = HAL_HASH_STATE_READY;
 800a628:	f884 5035 	strb.w	r5, [r4, #53]	; 0x35
 800a62c:	e035      	b.n	800a69a <HASH_Start+0x106>
      return HAL_ERROR;
    }


    /* Write input buffer in Data register */
    hhash->Status = HASH_WriteData(hhash, pInBuffer_tmp, Size_tmp);
 800a62e:	4620      	mov	r0, r4
 800a630:	f7ff fd4c 	bl	800a0cc <HASH_WriteData>
 800a634:	4605      	mov	r5, r0
 800a636:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
    if (hhash->Status != HAL_OK)
 800a63a:	2800      	cmp	r0, #0
 800a63c:	d134      	bne.n	800a6a8 <HASH_Start+0x114>
    {
      return hhash->Status;
    }

    /* If the process has not been suspended, carry on to digest calculation */
    if (hhash->State != HAL_HASH_STATE_SUSPENDED)
 800a63e:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 800a642:	2b08      	cmp	r3, #8
 800a644:	d029      	beq.n	800a69a <HASH_Start+0x106>
    {
      /* Start the Digest calculation */
      __HAL_HASH_START_DIGEST();
 800a646:	4f19      	ldr	r7, [pc, #100]	; (800a6ac <HASH_Start+0x118>)
 800a648:	68bb      	ldr	r3, [r7, #8]
 800a64a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800a64e:	60bb      	str	r3, [r7, #8]

      /* Wait for DCIS flag to be set */
      if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
 800a650:	4602      	mov	r2, r0
 800a652:	9b06      	ldr	r3, [sp, #24]
 800a654:	2102      	movs	r1, #2
 800a656:	4620      	mov	r0, r4
 800a658:	f7ff fddc 	bl	800a214 <HASH_WaitOnFlagUntilTimeout>
 800a65c:	bb18      	cbnz	r0, 800a6a6 <HASH_Start+0x112>
      {
        return HAL_TIMEOUT;
      }

      /* Read the message digest */
      HASH_GetDigest(pOutBuffer, HASH_DIGEST_LENGTH());
 800a65e:	683a      	ldr	r2, [r7, #0]
 800a660:	4b13      	ldr	r3, [pc, #76]	; (800a6b0 <HASH_Start+0x11c>)
 800a662:	4013      	ands	r3, r2
 800a664:	b173      	cbz	r3, 800a684 <HASH_Start+0xf0>
 800a666:	683a      	ldr	r2, [r7, #0]
 800a668:	4b11      	ldr	r3, [pc, #68]	; (800a6b0 <HASH_Start+0x11c>)
 800a66a:	4013      	ands	r3, r2
 800a66c:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800a670:	d00a      	beq.n	800a688 <HASH_Start+0xf4>
 800a672:	683a      	ldr	r2, [r7, #0]
 800a674:	4b0e      	ldr	r3, [pc, #56]	; (800a6b0 <HASH_Start+0x11c>)
 800a676:	490e      	ldr	r1, [pc, #56]	; (800a6b0 <HASH_Start+0x11c>)
 800a678:	4013      	ands	r3, r2
 800a67a:	428b      	cmp	r3, r1
 800a67c:	bf0c      	ite	eq
 800a67e:	2120      	moveq	r1, #32
 800a680:	2110      	movne	r1, #16
 800a682:	e002      	b.n	800a68a <HASH_Start+0xf6>
 800a684:	2114      	movs	r1, #20
 800a686:	e000      	b.n	800a68a <HASH_Start+0xf6>
 800a688:	211c      	movs	r1, #28
 800a68a:	4630      	mov	r0, r6
 800a68c:	f7ff fd60 	bl	800a150 <HASH_GetDigest>

      /* Change the HASH state */
      hhash->State = HAL_HASH_STATE_READY;
 800a690:	2301      	movs	r3, #1
 800a692:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

      /* Reset HASH state machine */
      hhash->Phase = HAL_HASH_PHASE_READY;
 800a696:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d

    }

    /* Process Unlocked */
    __HAL_UNLOCK(hhash);
 800a69a:	2300      	movs	r3, #0
 800a69c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800a6a0:	e002      	b.n	800a6a8 <HASH_Start+0x114>
    return HAL_OK;

  }
  else
  {
    return HAL_BUSY;
 800a6a2:	2502      	movs	r5, #2
 800a6a4:	e000      	b.n	800a6a8 <HASH_Start+0x114>
      __HAL_HASH_START_DIGEST();

      /* Wait for DCIS flag to be set */
      if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
      {
        return HAL_TIMEOUT;
 800a6a6:	2503      	movs	r5, #3
  }
  else
  {
    return HAL_BUSY;
  }
}
 800a6a8:	4628      	mov	r0, r5
 800a6aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a6ac:	50060400 	.word	0x50060400
 800a6b0:	00040080 	.word	0x00040080

0800a6b4 <HAL_HASH_MD5_Accmlt_End>:
  * @param  pOutBuffer pointer to the computed digest. Digest size is 16 bytes.
  * @param  Timeout Timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASH_MD5_Accmlt_End(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout)
{
 800a6b4:	b513      	push	{r0, r1, r4, lr}
  return HASH_Start(hhash, pInBuffer, Size, pOutBuffer, Timeout, HASH_ALGOSELECTION_MD5);
 800a6b6:	2480      	movs	r4, #128	; 0x80
 800a6b8:	9401      	str	r4, [sp, #4]
 800a6ba:	9c04      	ldr	r4, [sp, #16]
 800a6bc:	9400      	str	r4, [sp, #0]
 800a6be:	f7ff ff69 	bl	800a594 <HASH_Start>
}
 800a6c2:	b002      	add	sp, #8
 800a6c4:	bd10      	pop	{r4, pc}

0800a6c6 <HAL_HASH_MD5_Start>:
 800a6c6:	f7ff bff5 	b.w	800a6b4 <HAL_HASH_MD5_Accmlt_End>

0800a6ca <HAL_HASH_SHA1_Accmlt_End>:
  * @param  pOutBuffer pointer to the computed digest. Digest size is 20 bytes.
  * @param  Timeout Timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASH_SHA1_Accmlt_End(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout)
{
 800a6ca:	b513      	push	{r0, r1, r4, lr}
  return HASH_Start(hhash, pInBuffer, Size, pOutBuffer, Timeout, HASH_ALGOSELECTION_SHA1);
 800a6cc:	2400      	movs	r4, #0
 800a6ce:	9401      	str	r4, [sp, #4]
 800a6d0:	9c04      	ldr	r4, [sp, #16]
 800a6d2:	9400      	str	r4, [sp, #0]
 800a6d4:	f7ff ff5e 	bl	800a594 <HASH_Start>
}
 800a6d8:	b002      	add	sp, #8
 800a6da:	bd10      	pop	{r4, pc}

0800a6dc <HAL_HASH_SHA1_Start>:
 800a6dc:	f7ff bff5 	b.w	800a6ca <HAL_HASH_SHA1_Accmlt_End>

0800a6e0 <HASH_Accumulate>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Accumulate(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint32_t Algorithm)
{
 800a6e0:	b538      	push	{r3, r4, r5, lr}
  uint8_t *pInBuffer_tmp;   /* input data address, input parameter of HASH_WriteData()         */
  uint32_t Size_tmp;  /* input data size (in bytes), input parameter of HASH_WriteData() */
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 800a6e2:	f890 5035 	ldrb.w	r5, [r0, #53]	; 0x35
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Accumulate(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint32_t Algorithm)
{
 800a6e6:	4604      	mov	r4, r0
  uint8_t *pInBuffer_tmp;   /* input data address, input parameter of HASH_WriteData()         */
  uint32_t Size_tmp;  /* input data size (in bytes), input parameter of HASH_WriteData() */
  HAL_HASH_StateTypeDef State_tmp = hhash->State;

  /* Make sure the input buffer size (in bytes) is a multiple of 4 */
  if ((Size % 4U) != 0U)
 800a6e8:	0790      	lsls	r0, r2, #30
  */
HAL_StatusTypeDef HASH_Accumulate(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint32_t Algorithm)
{
  uint8_t *pInBuffer_tmp;   /* input data address, input parameter of HASH_WriteData()         */
  uint32_t Size_tmp;  /* input data size (in bytes), input parameter of HASH_WriteData() */
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 800a6ea:	b2ed      	uxtb	r5, r5

  /* Make sure the input buffer size (in bytes) is a multiple of 4 */
  if ((Size % 4U) != 0U)
 800a6ec:	d13d      	bne.n	800a76a <HASH_Accumulate+0x8a>
  {
    return  HAL_ERROR;
  }

  /* Initiate HASH processing in case of start or resumption */
if((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 800a6ee:	2d01      	cmp	r5, #1
 800a6f0:	d001      	beq.n	800a6f6 <HASH_Accumulate+0x16>
 800a6f2:	2d08      	cmp	r5, #8
 800a6f4:	d13b      	bne.n	800a76e <HASH_Accumulate+0x8e>
  {
    /* Check input parameters */
    if ((pInBuffer == NULL) || (Size == 0U))
 800a6f6:	b101      	cbz	r1, 800a6fa <HASH_Accumulate+0x1a>
 800a6f8:	b91a      	cbnz	r2, 800a702 <HASH_Accumulate+0x22>
    {
      hhash->State = HAL_HASH_STATE_READY;
 800a6fa:	2001      	movs	r0, #1
 800a6fc:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
      return  HAL_ERROR;
 800a700:	bd38      	pop	{r3, r4, r5, pc}
    }

     /* Process Locked */
    __HAL_LOCK(hhash);
 800a702:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 800a706:	2801      	cmp	r0, #1
 800a708:	d031      	beq.n	800a76e <HASH_Accumulate+0x8e>
 800a70a:	2001      	movs	r0, #1
 800a70c:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34

    /* If resuming the HASH processing */
    if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 800a710:	f894 0035 	ldrb.w	r0, [r4, #53]	; 0x35
 800a714:	2808      	cmp	r0, #8
 800a716:	f04f 0002 	mov.w	r0, #2
    {
      /* Change the HASH state */
      hhash->State = HAL_HASH_STATE_BUSY;
 800a71a:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35

     /* Process Locked */
    __HAL_LOCK(hhash);

    /* If resuming the HASH processing */
    if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 800a71e:	d102      	bne.n	800a726 <HASH_Accumulate+0x46>
      hhash->State = HAL_HASH_STATE_BUSY;

      /* Since this is resumption, pInBuffer_tmp and Size_tmp are not set
         to the API input parameters but to those saved beforehand by HASH_WriteData()
         when the processing was suspended */
      pInBuffer_tmp = hhash->pHashInBuffPtr;  /* pInBuffer_tmp is set to the input data address */
 800a720:	68e1      	ldr	r1, [r4, #12]
      Size_tmp = hhash->HashInCount;          /* Size_tmp contains the input data size in bytes */
 800a722:	6a22      	ldr	r2, [r4, #32]
 800a724:	e010      	b.n	800a748 <HASH_Accumulate+0x68>
         input parameters of HASH_WriteData() */
      pInBuffer_tmp = pInBuffer;    /* pInBuffer_tmp is set to the input data address */
      Size_tmp = Size;              /* Size_tmp contains the input data size in bytes */

      /* Check if initialization phase has already be performed */
      if(hhash->Phase == HAL_HASH_PHASE_READY)
 800a726:	f894 002d 	ldrb.w	r0, [r4, #45]	; 0x2d
 800a72a:	2801      	cmp	r0, #1
 800a72c:	d109      	bne.n	800a742 <HASH_Accumulate+0x62>
      {
        /* Select the HASH algorithm, clear HMAC mode and long key selection bit, reset the HASH processor core */
        MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);
 800a72e:	4d11      	ldr	r5, [pc, #68]	; (800a774 <HASH_Accumulate+0x94>)
 800a730:	6828      	ldr	r0, [r5, #0]
 800a732:	f420 20a0 	bic.w	r0, r0, #327680	; 0x50000
 800a736:	f020 00c4 	bic.w	r0, r0, #196	; 0xc4
 800a73a:	f040 0004 	orr.w	r0, r0, #4
 800a73e:	4318      	orrs	r0, r3
 800a740:	6028      	str	r0, [r5, #0]
      }

      /* Set the phase */
      hhash->Phase = HAL_HASH_PHASE_PROCESS;
 800a742:	2302      	movs	r3, #2
 800a744:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d

    }

    /* Write input buffer in Data register */
    hhash->Status = HASH_WriteData(hhash, pInBuffer_tmp, Size_tmp);
 800a748:	4620      	mov	r0, r4
 800a74a:	f7ff fcbf 	bl	800a0cc <HASH_WriteData>
 800a74e:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
    if (hhash->Status != HAL_OK)
 800a752:	b968      	cbnz	r0, 800a770 <HASH_Accumulate+0x90>
    {
      return hhash->Status;
    }

    /* If the process has not been suspended, move the state to Ready */
    if (hhash->State != HAL_HASH_STATE_SUSPENDED)
 800a754:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 800a758:	2b08      	cmp	r3, #8
    {
      /* Change the HASH state */
      hhash->State = HAL_HASH_STATE_READY;
 800a75a:	bf1c      	itt	ne
 800a75c:	2301      	movne	r3, #1
 800a75e:	f884 3035 	strbne.w	r3, [r4, #53]	; 0x35
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hhash);
 800a762:	2300      	movs	r3, #0
 800a764:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800a768:	bd38      	pop	{r3, r4, r5, pc}
  HAL_HASH_StateTypeDef State_tmp = hhash->State;

  /* Make sure the input buffer size (in bytes) is a multiple of 4 */
  if ((Size % 4U) != 0U)
  {
    return  HAL_ERROR;
 800a76a:	2001      	movs	r0, #1
 800a76c:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_OK;

  }
  else
  {
    return HAL_BUSY;
 800a76e:	2002      	movs	r0, #2
  }


}
 800a770:	bd38      	pop	{r3, r4, r5, pc}
 800a772:	bf00      	nop
 800a774:	50060400 	.word	0x50060400

0800a778 <HAL_HASH_MD5_Accmlt>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASH_MD5_Accmlt(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
  return  HASH_Accumulate(hhash, pInBuffer, Size,HASH_ALGOSELECTION_MD5);
 800a778:	2380      	movs	r3, #128	; 0x80
 800a77a:	f7ff bfb1 	b.w	800a6e0 <HASH_Accumulate>

0800a77e <HAL_HASH_SHA1_Accmlt>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASH_SHA1_Accmlt(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
  return  HASH_Accumulate(hhash, pInBuffer, Size,HASH_ALGOSELECTION_SHA1);
 800a77e:	2300      	movs	r3, #0
 800a780:	f7ff bfae 	b.w	800a6e0 <HASH_Accumulate>

0800a784 <HASH_Accumulate_IT>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Accumulate_IT(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint32_t Algorithm)
{
 800a784:	b537      	push	{r0, r1, r2, r4, r5, lr}
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 800a786:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
  __IO uint32_t inputaddr = (uint32_t) pInBuffer;
 800a78a:	9101      	str	r1, [sp, #4]
  uint32_t SizeVar = Size;

  /* Make sure the input buffer size (in bytes) is a multiple of 4 */
  if ((Size % 4U) != 0U)
 800a78c:	0795      	lsls	r5, r2, #30
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Accumulate_IT(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint32_t Algorithm)
{
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 800a78e:	b2e4      	uxtb	r4, r4
  __IO uint32_t inputaddr = (uint32_t) pInBuffer;
  uint32_t SizeVar = Size;

  /* Make sure the input buffer size (in bytes) is a multiple of 4 */
  if ((Size % 4U) != 0U)
 800a790:	d153      	bne.n	800a83a <HASH_Accumulate_IT+0xb6>
  {
    return  HAL_ERROR;
  }

  /* Initiate HASH processing in case of start or resumption */
  if((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 800a792:	2c01      	cmp	r4, #1
 800a794:	d001      	beq.n	800a79a <HASH_Accumulate_IT+0x16>
 800a796:	2c08      	cmp	r4, #8
 800a798:	d151      	bne.n	800a83e <HASH_Accumulate_IT+0xba>
  {
    /* Check input parameters */
    if ((pInBuffer == NULL) || (Size == 0U))
 800a79a:	b101      	cbz	r1, 800a79e <HASH_Accumulate_IT+0x1a>
 800a79c:	b91a      	cbnz	r2, 800a7a6 <HASH_Accumulate_IT+0x22>
    {
      hhash->State = HAL_HASH_STATE_READY;
 800a79e:	2301      	movs	r3, #1
 800a7a0:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
 800a7a4:	e047      	b.n	800a836 <HASH_Accumulate_IT+0xb2>
      return  HAL_ERROR;
    }

     /* Process Locked */
    __HAL_LOCK(hhash);
 800a7a6:	f890 1034 	ldrb.w	r1, [r0, #52]	; 0x34
 800a7aa:	2901      	cmp	r1, #1
 800a7ac:	d047      	beq.n	800a83e <HASH_Accumulate_IT+0xba>
 800a7ae:	2101      	movs	r1, #1
 800a7b0:	f880 1034 	strb.w	r1, [r0, #52]	; 0x34

    /* If resuming the HASH processing */
    if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 800a7b4:	f890 1035 	ldrb.w	r1, [r0, #53]	; 0x35
 800a7b8:	4c22      	ldr	r4, [pc, #136]	; (800a844 <HASH_Accumulate_IT+0xc0>)
 800a7ba:	2908      	cmp	r1, #8
 800a7bc:	f04f 0102 	mov.w	r1, #2
    {
      /* Change the HASH state */
      hhash->State = HAL_HASH_STATE_BUSY;
 800a7c0:	f880 1035 	strb.w	r1, [r0, #53]	; 0x35

     /* Process Locked */
    __HAL_LOCK(hhash);

    /* If resuming the HASH processing */
    if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 800a7c4:	d02e      	beq.n	800a824 <HASH_Accumulate_IT+0xa0>
    {
      /* Change the HASH state */
      hhash->State = HAL_HASH_STATE_BUSY;

      /* Check if initialization phase has already be performed */
      if(hhash->Phase == HAL_HASH_PHASE_READY)
 800a7c6:	f890 502d 	ldrb.w	r5, [r0, #45]	; 0x2d
 800a7ca:	2d01      	cmp	r5, #1
 800a7cc:	d10a      	bne.n	800a7e4 <HASH_Accumulate_IT+0x60>
      {
        /* Select the HASH algorithm, clear HMAC mode and long key selection bit, reset the HASH processor core */
        MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);
 800a7ce:	6821      	ldr	r1, [r4, #0]
 800a7d0:	f421 21a0 	bic.w	r1, r1, #327680	; 0x50000
 800a7d4:	f021 01c4 	bic.w	r1, r1, #196	; 0xc4
 800a7d8:	f041 0104 	orr.w	r1, r1, #4
 800a7dc:	4319      	orrs	r1, r3
 800a7de:	6021      	str	r1, [r4, #0]
        hhash->HashITCounter = 1;
 800a7e0:	6245      	str	r5, [r0, #36]	; 0x24
 800a7e2:	e001      	b.n	800a7e8 <HASH_Accumulate_IT+0x64>
      }
      else
      {
         hhash->HashITCounter = 3; /* 'cruise-speed' reached during a previous buffer processing */
 800a7e4:	2303      	movs	r3, #3
 800a7e6:	6243      	str	r3, [r0, #36]	; 0x24
      }

      /* Set the phase */
      hhash->Phase = HAL_HASH_PHASE_PROCESS;
 800a7e8:	2302      	movs	r3, #2

      /* If DINIS is equal to 0 (for example if an incomplete block has been previously
       fed to the Peripheral), the DINIE interruption won't be triggered when DINIE is set.
       Therefore, first words are manually entered until DINIS raises, or until there
       is not more data to enter. */
      while((!(__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))) && (SizeVar > 0U))
 800a7ea:	4916      	ldr	r1, [pc, #88]	; (800a844 <HASH_Accumulate_IT+0xc0>)
      {
         hhash->HashITCounter = 3; /* 'cruise-speed' reached during a previous buffer processing */
      }

      /* Set the phase */
      hhash->Phase = HAL_HASH_PHASE_PROCESS;
 800a7ec:	f880 302d 	strb.w	r3, [r0, #45]	; 0x2d

      /* If DINIS is equal to 0 (for example if an incomplete block has been previously
       fed to the Peripheral), the DINIE interruption won't be triggered when DINIE is set.
       Therefore, first words are manually entered until DINIS raises, or until there
       is not more data to enter. */
      while((!(__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))) && (SizeVar > 0U))
 800a7f0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a7f2:	07dd      	lsls	r5, r3, #31
 800a7f4:	d408      	bmi.n	800a808 <HASH_Accumulate_IT+0x84>
 800a7f6:	b13a      	cbz	r2, 800a808 <HASH_Accumulate_IT+0x84>
      {

        /* Write input data 4 bytes at a time */
        HASH->DIN = *(uint32_t*)inputaddr;
 800a7f8:	9b01      	ldr	r3, [sp, #4]
 800a7fa:	681b      	ldr	r3, [r3, #0]
 800a7fc:	604b      	str	r3, [r1, #4]
        inputaddr+=4U;
 800a7fe:	9b01      	ldr	r3, [sp, #4]
 800a800:	3304      	adds	r3, #4
 800a802:	9301      	str	r3, [sp, #4]
        SizeVar-=4U;
 800a804:	3a04      	subs	r2, #4
 800a806:	e7f3      	b.n	800a7f0 <HASH_Accumulate_IT+0x6c>
      }

      /* If DINIS is still not set or if all the data have been fed, stop here */
      if ((!(__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))) || (SizeVar == 0U))
 800a808:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a80a:	07db      	lsls	r3, r3, #31
 800a80c:	d500      	bpl.n	800a810 <HASH_Accumulate_IT+0x8c>
 800a80e:	b932      	cbnz	r2, 800a81e <HASH_Accumulate_IT+0x9a>
      {
        /* Change the HASH state */
        hhash->State = HAL_HASH_STATE_READY;
 800a810:	2301      	movs	r3, #1
 800a812:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35

        /* Process Unlock */
        __HAL_UNLOCK(hhash);
 800a816:	2300      	movs	r3, #0
 800a818:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
 800a81c:	e00b      	b.n	800a836 <HASH_Accumulate_IT+0xb2>
        /* Return function status */
        return HAL_OK;
      }

      /* otherwise, carry on in interrupt-mode */
      hhash->HashInCount = SizeVar;               /* Counter used to keep track of number of data
 800a81e:	6202      	str	r2, [r0, #32]
                                                  to be fed to the Peripheral */
      hhash->pHashInBuffPtr = (uint8_t *)inputaddr;       /* Points at data which will be fed to the Peripheral at
 800a820:	9b01      	ldr	r3, [sp, #4]
 800a822:	60c3      	str	r3, [r0, #12]
        correct location. */

    }

    /* Set multi buffers accumulation flag */
    hhash->Accumulation = 1U;
 800a824:	2301      	movs	r3, #1
 800a826:	6403      	str	r3, [r0, #64]	; 0x40

    /* Process Unlock */
    __HAL_UNLOCK(hhash);

    /* Enable Data Input interrupt */
    __HAL_HASH_ENABLE_IT(HASH_IT_DINI);
 800a828:	6a22      	ldr	r2, [r4, #32]

    /* Set multi buffers accumulation flag */
    hhash->Accumulation = 1U;

    /* Process Unlock */
    __HAL_UNLOCK(hhash);
 800a82a:	2300      	movs	r3, #0

    /* Enable Data Input interrupt */
    __HAL_HASH_ENABLE_IT(HASH_IT_DINI);
 800a82c:	f042 0201 	orr.w	r2, r2, #1

    /* Set multi buffers accumulation flag */
    hhash->Accumulation = 1U;

    /* Process Unlock */
    __HAL_UNLOCK(hhash);
 800a830:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34

    /* Enable Data Input interrupt */
    __HAL_HASH_ENABLE_IT(HASH_IT_DINI);
 800a834:	6222      	str	r2, [r4, #32]

    /* Return function status */
    return HAL_OK;
 800a836:	4618      	mov	r0, r3
 800a838:	e002      	b.n	800a840 <HASH_Accumulate_IT+0xbc>
  uint32_t SizeVar = Size;

  /* Make sure the input buffer size (in bytes) is a multiple of 4 */
  if ((Size % 4U) != 0U)
  {
    return  HAL_ERROR;
 800a83a:	2001      	movs	r0, #1
 800a83c:	e000      	b.n	800a840 <HASH_Accumulate_IT+0xbc>
    return HAL_OK;

  }
  else
  {
    return HAL_BUSY;
 800a83e:	2002      	movs	r0, #2
  }

}
 800a840:	b003      	add	sp, #12
 800a842:	bd30      	pop	{r4, r5, pc}
 800a844:	50060400 	.word	0x50060400

0800a848 <HAL_HASH_MD5_Accmlt_IT>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASH_MD5_Accmlt_IT(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
  return  HASH_Accumulate_IT(hhash, pInBuffer, Size,HASH_ALGOSELECTION_MD5);
 800a848:	2380      	movs	r3, #128	; 0x80
 800a84a:	f7ff bf9b 	b.w	800a784 <HASH_Accumulate_IT>

0800a84e <HAL_HASH_SHA1_Accmlt_IT>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASH_SHA1_Accmlt_IT(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
  return  HASH_Accumulate_IT(hhash, pInBuffer, Size,HASH_ALGOSELECTION_SHA1);
 800a84e:	2300      	movs	r3, #0
 800a850:	f7ff bf98 	b.w	800a784 <HASH_Accumulate_IT>

0800a854 <HASH_Start_IT>:
  * @param  pOutBuffer pointer to the computed digest.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Start_IT(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Algorithm)
{
 800a854:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   HAL_HASH_StateTypeDef State_tmp = hhash->State;
 800a856:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
  __IO uint32_t inputaddr = (uint32_t) pInBuffer;
 800a85a:	9101      	str	r1, [sp, #4]
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Start_IT(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Algorithm)
{
   HAL_HASH_StateTypeDef State_tmp = hhash->State;
 800a85c:	b2e4      	uxtb	r4, r4
  uint32_t polling_step = 0U;
  uint32_t initialization_skipped = 0U;
  uint32_t SizeVar = Size;

  /* If State is ready or suspended, start or resume IT-based HASH processing */
if((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 800a85e:	2c01      	cmp	r4, #1
 800a860:	d002      	beq.n	800a868 <HASH_Start_IT+0x14>
 800a862:	2c08      	cmp	r4, #8
 800a864:	f040 8086 	bne.w	800a974 <HASH_Start_IT+0x120>
  {
    /* Check input parameters */
    if ((pInBuffer == NULL) || (Size == 0U) || (pOutBuffer == NULL))
 800a868:	b109      	cbz	r1, 800a86e <HASH_Start_IT+0x1a>
 800a86a:	b102      	cbz	r2, 800a86e <HASH_Start_IT+0x1a>
 800a86c:	b91b      	cbnz	r3, 800a876 <HASH_Start_IT+0x22>
    {
      hhash->State = HAL_HASH_STATE_READY;
 800a86e:	2201      	movs	r2, #1
 800a870:	f880 2035 	strb.w	r2, [r0, #53]	; 0x35
 800a874:	e07c      	b.n	800a970 <HASH_Start_IT+0x11c>
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(hhash);
 800a876:	f890 4034 	ldrb.w	r4, [r0, #52]	; 0x34
 800a87a:	2c01      	cmp	r4, #1
 800a87c:	f04f 0402 	mov.w	r4, #2
 800a880:	d07a      	beq.n	800a978 <HASH_Start_IT+0x124>

    /* Change the HASH state */
    hhash->State = HAL_HASH_STATE_BUSY;
 800a882:	f880 4035 	strb.w	r4, [r0, #53]	; 0x35

    /* Initialize IT counter */
    hhash->HashITCounter = 1;

    /* Check if initialization phase has already be performed */
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 800a886:	f890 402d 	ldrb.w	r4, [r0, #45]	; 0x2d
      hhash->State = HAL_HASH_STATE_READY;
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(hhash);
 800a88a:	2501      	movs	r5, #1

    /* Initialize IT counter */
    hhash->HashITCounter = 1;

    /* Check if initialization phase has already be performed */
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 800a88c:	42ac      	cmp	r4, r5
      hhash->State = HAL_HASH_STATE_READY;
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(hhash);
 800a88e:	f880 5034 	strb.w	r5, [r0, #52]	; 0x34

    /* Change the HASH state */
    hhash->State = HAL_HASH_STATE_BUSY;

    /* Initialize IT counter */
    hhash->HashITCounter = 1;
 800a892:	6245      	str	r5, [r0, #36]	; 0x24
 800a894:	4c3a      	ldr	r4, [pc, #232]	; (800a980 <HASH_Start_IT+0x12c>)

    /* Check if initialization phase has already be performed */
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 800a896:	d116      	bne.n	800a8c6 <HASH_Start_IT+0x72>
    {
      /* Select the HASH algorithm, clear HMAC mode and long key selection bit, reset the HASH processor core */
      MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);
 800a898:	6825      	ldr	r5, [r4, #0]
 800a89a:	9e08      	ldr	r6, [sp, #32]
 800a89c:	f425 25a0 	bic.w	r5, r5, #327680	; 0x50000
 800a8a0:	f025 05c4 	bic.w	r5, r5, #196	; 0xc4
 800a8a4:	f045 0504 	orr.w	r5, r5, #4
 800a8a8:	4335      	orrs	r5, r6
 800a8aa:	6025      	str	r5, [r4, #0]

      /* Configure the number of valid bits in last word of the message */
     __HAL_HASH_SET_NBVALIDBITS(SizeVar);
 800a8ac:	68a6      	ldr	r6, [r4, #8]
 800a8ae:	f002 0503 	and.w	r5, r2, #3
 800a8b2:	f026 061f 	bic.w	r6, r6, #31
 800a8b6:	ea46 05c5 	orr.w	r5, r6, r5, lsl #3
 800a8ba:	60a5      	str	r5, [r4, #8]
HAL_StatusTypeDef HASH_Start_IT(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Algorithm)
{
   HAL_HASH_StateTypeDef State_tmp = hhash->State;
  __IO uint32_t inputaddr = (uint32_t) pInBuffer;
  uint32_t polling_step = 0U;
  uint32_t initialization_skipped = 0U;
 800a8bc:	2600      	movs	r6, #0

      /* Configure the number of valid bits in last word of the message */
     __HAL_HASH_SET_NBVALIDBITS(SizeVar);


      hhash->HashInCount = SizeVar;            /* Counter used to keep track of number of data
 800a8be:	6202      	str	r2, [r0, #32]
                                                  to be fed to the Peripheral */
      hhash->pHashInBuffPtr = pInBuffer;       /* Points at data which will be fed to the Peripheral at
 800a8c0:	60c1      	str	r1, [r0, #12]
     /* In case of suspension, hhash->HashInCount and hhash->pHashInBuffPtr contain
        the information describing where the HASH process is stopped.
        These variables are used later on to resume the HASH processing at the
        correct location. */

      hhash->pHashOutBuffPtr = pOutBuffer;     /* Points at the computed digest */
 800a8c2:	6103      	str	r3, [r0, #16]
 800a8c4:	e000      	b.n	800a8c8 <HASH_Start_IT+0x74>
    }
    else
    {
      initialization_skipped = 1; /* info user later on in case of multi-buffer */
 800a8c6:	462e      	mov	r6, r5
    }

    /* Set the phase */
    hhash->Phase = HAL_HASH_PHASE_PROCESS;
 800a8c8:	2102      	movs	r1, #2

   /* If DINIS is equal to 0 (for example if an incomplete block has been previously
     fed to the Peripheral), the DINIE interruption won't be triggered when DINIE is set.
     Therefore, first words are manually entered until DINIS raises. */
    while((!(__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))) && (SizeVar > 3U))
 800a8ca:	4d2d      	ldr	r5, [pc, #180]	; (800a980 <HASH_Start_IT+0x12c>)
    {
      initialization_skipped = 1; /* info user later on in case of multi-buffer */
    }

    /* Set the phase */
    hhash->Phase = HAL_HASH_PHASE_PROCESS;
 800a8cc:	f880 102d 	strb.w	r1, [r0, #45]	; 0x2d
  */
HAL_StatusTypeDef HASH_Start_IT(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Algorithm)
{
   HAL_HASH_StateTypeDef State_tmp = hhash->State;
  __IO uint32_t inputaddr = (uint32_t) pInBuffer;
  uint32_t polling_step = 0U;
 800a8d0:	2100      	movs	r1, #0
    hhash->Phase = HAL_HASH_PHASE_PROCESS;

   /* If DINIS is equal to 0 (for example if an incomplete block has been previously
     fed to the Peripheral), the DINIE interruption won't be triggered when DINIE is set.
     Therefore, first words are manually entered until DINIS raises. */
    while((!(__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))) && (SizeVar > 3U))
 800a8d2:	6a67      	ldr	r7, [r4, #36]	; 0x24
 800a8d4:	07ff      	lsls	r7, r7, #31
 800a8d6:	d502      	bpl.n	800a8de <HASH_Start_IT+0x8a>
      HASH->DIN = *(uint32_t*)inputaddr;
      inputaddr+=4U;
      SizeVar-=4U;
    }

    if (polling_step == 1U)
 800a8d8:	2900      	cmp	r1, #0
 800a8da:	d042      	beq.n	800a962 <HASH_Start_IT+0x10e>
 800a8dc:	e00a      	b.n	800a8f4 <HASH_Start_IT+0xa0>
    hhash->Phase = HAL_HASH_PHASE_PROCESS;

   /* If DINIS is equal to 0 (for example if an incomplete block has been previously
     fed to the Peripheral), the DINIE interruption won't be triggered when DINIE is set.
     Therefore, first words are manually entered until DINIS raises. */
    while((!(__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))) && (SizeVar > 3U))
 800a8de:	2a03      	cmp	r2, #3
 800a8e0:	d9fa      	bls.n	800a8d8 <HASH_Start_IT+0x84>
    {
      polling_step = 1U; /* note that some words are entered before enabling the interrupt */

      /* Write input data 4 bytes at a time */
      HASH->DIN = *(uint32_t*)inputaddr;
 800a8e2:	9901      	ldr	r1, [sp, #4]
 800a8e4:	6809      	ldr	r1, [r1, #0]
 800a8e6:	6069      	str	r1, [r5, #4]
      inputaddr+=4U;
 800a8e8:	9901      	ldr	r1, [sp, #4]
 800a8ea:	3104      	adds	r1, #4
 800a8ec:	9101      	str	r1, [sp, #4]
      SizeVar-=4U;
 800a8ee:	3a04      	subs	r2, #4
   /* If DINIS is equal to 0 (for example if an incomplete block has been previously
     fed to the Peripheral), the DINIE interruption won't be triggered when DINIE is set.
     Therefore, first words are manually entered until DINIS raises. */
    while((!(__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))) && (SizeVar > 3U))
    {
      polling_step = 1U; /* note that some words are entered before enabling the interrupt */
 800a8f0:	2101      	movs	r1, #1
 800a8f2:	e7ee      	b.n	800a8d2 <HASH_Start_IT+0x7e>
      SizeVar-=4U;
    }

    if (polling_step == 1U)
    {
      if (SizeVar == 0U)
 800a8f4:	b952      	cbnz	r2, 800a90c <HASH_Start_IT+0xb8>
      {
        /* If all the data have been entered at this point, it only remains to
         read the digest */
        hhash->pHashOutBuffPtr = pOutBuffer;     /* Points at the computed digest */
 800a8f6:	6103      	str	r3, [r0, #16]

        /* Start the Digest calculation */
         __HAL_HASH_START_DIGEST();
 800a8f8:	68a3      	ldr	r3, [r4, #8]
 800a8fa:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800a8fe:	60a3      	str	r3, [r4, #8]
        /* Process Unlock */
        __HAL_UNLOCK(hhash);

        /* Enable Interrupts */
        __HAL_HASH_ENABLE_IT(HASH_IT_DCI);
 800a900:	6a23      	ldr	r3, [r4, #32]
        hhash->pHashOutBuffPtr = pOutBuffer;     /* Points at the computed digest */

        /* Start the Digest calculation */
         __HAL_HASH_START_DIGEST();
        /* Process Unlock */
        __HAL_UNLOCK(hhash);
 800a902:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34

        /* Enable Interrupts */
        __HAL_HASH_ENABLE_IT(HASH_IT_DCI);
 800a906:	f043 0302 	orr.w	r3, r3, #2
 800a90a:	e030      	b.n	800a96e <HASH_Start_IT+0x11a>

        /* Return function status */
        return HAL_OK;
      }
      else if (__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))
 800a90c:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800a90e:	4d1c      	ldr	r5, [pc, #112]	; (800a980 <HASH_Start_IT+0x12c>)
 800a910:	f011 0101 	ands.w	r1, r1, #1
 800a914:	f002 0703 	and.w	r7, r2, #3
 800a918:	d00d      	beq.n	800a936 <HASH_Start_IT+0xe2>
      {
        /* It remains data to enter and the Peripheral is ready to trigger DINIE,
           carry on as usual.
           Update HashInCount and pHashInBuffPtr accordingly. */
        hhash->HashInCount = SizeVar;
 800a91a:	6202      	str	r2, [r0, #32]
        hhash->pHashInBuffPtr = (uint8_t *)inputaddr;
 800a91c:	9a01      	ldr	r2, [sp, #4]
        __HAL_HASH_SET_NBVALIDBITS(SizeVar);  /* Update the configuration of the number of valid bits in last word of the message */
 800a91e:	68a9      	ldr	r1, [r5, #8]
      {
        /* It remains data to enter and the Peripheral is ready to trigger DINIE,
           carry on as usual.
           Update HashInCount and pHashInBuffPtr accordingly. */
        hhash->HashInCount = SizeVar;
        hhash->pHashInBuffPtr = (uint8_t *)inputaddr;
 800a920:	60c2      	str	r2, [r0, #12]
        __HAL_HASH_SET_NBVALIDBITS(SizeVar);  /* Update the configuration of the number of valid bits in last word of the message */
 800a922:	f021 011f 	bic.w	r1, r1, #31
 800a926:	ea41 02c7 	orr.w	r2, r1, r7, lsl #3
 800a92a:	60aa      	str	r2, [r5, #8]
        hhash->pHashOutBuffPtr = pOutBuffer;  /* Points at the computed digest */
 800a92c:	6103      	str	r3, [r0, #16]
        if (initialization_skipped == 1U)
 800a92e:	b1c6      	cbz	r6, 800a962 <HASH_Start_IT+0x10e>
        {
          hhash->HashITCounter = 3; /* 'cruise-speed' reached during a previous buffer processing */
 800a930:	2303      	movs	r3, #3
 800a932:	6243      	str	r3, [r0, #36]	; 0x24
 800a934:	e015      	b.n	800a962 <HASH_Start_IT+0x10e>
      }
      else
      {
        /* DINIS is not set but it remains a few data to enter (not enough for a full word).
           Manually enter the last bytes before enabling DCIE. */
        __HAL_HASH_SET_NBVALIDBITS(SizeVar);
 800a936:	68aa      	ldr	r2, [r5, #8]
 800a938:	f022 021f 	bic.w	r2, r2, #31
 800a93c:	ea42 02c7 	orr.w	r2, r2, r7, lsl #3
 800a940:	60aa      	str	r2, [r5, #8]
        HASH->DIN = *(uint32_t*)inputaddr;
 800a942:	9a01      	ldr	r2, [sp, #4]
 800a944:	6812      	ldr	r2, [r2, #0]
 800a946:	606a      	str	r2, [r5, #4]

         /* Start the Digest calculation */
        hhash->pHashOutBuffPtr = pOutBuffer;     /* Points at the computed digest */
 800a948:	6103      	str	r3, [r0, #16]
         __HAL_HASH_START_DIGEST();
 800a94a:	68ab      	ldr	r3, [r5, #8]
 800a94c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800a950:	60ab      	str	r3, [r5, #8]
        /* Process Unlock */
        __HAL_UNLOCK(hhash);

        /* Enable Interrupts */
        __HAL_HASH_ENABLE_IT(HASH_IT_DCI);
 800a952:	6a2b      	ldr	r3, [r5, #32]

         /* Start the Digest calculation */
        hhash->pHashOutBuffPtr = pOutBuffer;     /* Points at the computed digest */
         __HAL_HASH_START_DIGEST();
        /* Process Unlock */
        __HAL_UNLOCK(hhash);
 800a954:	f880 1034 	strb.w	r1, [r0, #52]	; 0x34

        /* Enable Interrupts */
        __HAL_HASH_ENABLE_IT(HASH_IT_DCI);
 800a958:	f043 0302 	orr.w	r3, r3, #2
 800a95c:	622b      	str	r3, [r5, #32]

        /* Return function status */
        return HAL_OK;
 800a95e:	4608      	mov	r0, r1
 800a960:	e00b      	b.n	800a97a <HASH_Start_IT+0x126>

    /* Process Unlock */
    __HAL_UNLOCK(hhash);

    /* Enable Interrupts */
    __HAL_HASH_ENABLE_IT(HASH_IT_DINI|HASH_IT_DCI);
 800a962:	6a23      	ldr	r3, [r4, #32]
      }
    } /*  if (polling_step == 1) */


    /* Process Unlock */
    __HAL_UNLOCK(hhash);
 800a964:	2200      	movs	r2, #0
 800a966:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34

    /* Enable Interrupts */
    __HAL_HASH_ENABLE_IT(HASH_IT_DINI|HASH_IT_DCI);
 800a96a:	f043 0303 	orr.w	r3, r3, #3
 800a96e:	6223      	str	r3, [r4, #32]

    /* Return function status */
    return HAL_OK;
 800a970:	4610      	mov	r0, r2
 800a972:	e002      	b.n	800a97a <HASH_Start_IT+0x126>
  }
  else
  {
    return HAL_BUSY;
 800a974:	2002      	movs	r0, #2
 800a976:	e000      	b.n	800a97a <HASH_Start_IT+0x126>
 800a978:	4620      	mov	r0, r4
  }

}
 800a97a:	b003      	add	sp, #12
 800a97c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a97e:	bf00      	nop
 800a980:	50060400 	.word	0x50060400

0800a984 <HAL_HASH_MD5_Accmlt_End_IT>:
  * @param  Size length of the input buffer in bytes.
  * @param  pOutBuffer pointer to the computed digest. Digest size is 16 bytes.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASH_MD5_Accmlt_End_IT(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer)
{
 800a984:	b513      	push	{r0, r1, r4, lr}
  return HASH_Start_IT(hhash, pInBuffer, Size, pOutBuffer,HASH_ALGOSELECTION_MD5);
 800a986:	2480      	movs	r4, #128	; 0x80
 800a988:	9400      	str	r4, [sp, #0]
 800a98a:	f7ff ff63 	bl	800a854 <HASH_Start_IT>
}
 800a98e:	b002      	add	sp, #8
 800a990:	bd10      	pop	{r4, pc}

0800a992 <HAL_HASH_MD5_Start_IT>:
 800a992:	f7ff bff7 	b.w	800a984 <HAL_HASH_MD5_Accmlt_End_IT>

0800a996 <HAL_HASH_SHA1_Accmlt_End_IT>:
  * @param  Size length of the input buffer in bytes.
  * @param  pOutBuffer pointer to the computed digest. Digest size is 20 bytes.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASH_SHA1_Accmlt_End_IT(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer)
{
 800a996:	b513      	push	{r0, r1, r4, lr}
  return HASH_Start_IT(hhash, pInBuffer, Size, pOutBuffer,HASH_ALGOSELECTION_SHA1);
 800a998:	2400      	movs	r4, #0
 800a99a:	9400      	str	r4, [sp, #0]
 800a99c:	f7ff ff5a 	bl	800a854 <HASH_Start_IT>
}
 800a9a0:	b002      	add	sp, #8
 800a9a2:	bd10      	pop	{r4, pc}

0800a9a4 <HAL_HASH_SHA1_Start_IT>:
 800a9a4:	f7ff bff7 	b.w	800a996 <HAL_HASH_SHA1_Accmlt_End_IT>

0800a9a8 <HASH_Finish>:
  * @param  pOutBuffer pointer to the computed digest.
  * @param  Timeout Timeout value.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Finish(HASH_HandleTypeDef *hhash, uint8_t* pOutBuffer, uint32_t Timeout)
{
 800a9a8:	b570      	push	{r4, r5, r6, lr}

  if(hhash->State == HAL_HASH_STATE_READY)
 800a9aa:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
 800a9ae:	b2e4      	uxtb	r4, r4
 800a9b0:	2c01      	cmp	r4, #1
  * @param  pOutBuffer pointer to the computed digest.
  * @param  Timeout Timeout value.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Finish(HASH_HandleTypeDef *hhash, uint8_t* pOutBuffer, uint32_t Timeout)
{
 800a9b2:	4605      	mov	r5, r0
 800a9b4:	460e      	mov	r6, r1
 800a9b6:	4613      	mov	r3, r2

  if(hhash->State == HAL_HASH_STATE_READY)
 800a9b8:	d133      	bne.n	800aa22 <HASH_Finish+0x7a>
  {
    /* Check parameter */
    if (pOutBuffer == NULL)
 800a9ba:	2900      	cmp	r1, #0
 800a9bc:	d036      	beq.n	800aa2c <HASH_Finish+0x84>
    {
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(hhash);
 800a9be:	f890 2034 	ldrb.w	r2, [r0, #52]	; 0x34
 800a9c2:	2a01      	cmp	r2, #1
 800a9c4:	f04f 0102 	mov.w	r1, #2
 800a9c8:	d02d      	beq.n	800aa26 <HASH_Finish+0x7e>
 800a9ca:	f880 4034 	strb.w	r4, [r0, #52]	; 0x34

    /* Change the HASH state to busy */
    hhash->State = HAL_HASH_STATE_BUSY;
 800a9ce:	f880 1035 	strb.w	r1, [r0, #53]	; 0x35

    /* Wait for DCIS flag to be set */
    if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
 800a9d2:	2200      	movs	r2, #0
 800a9d4:	f7ff fc1e 	bl	800a214 <HASH_WaitOnFlagUntilTimeout>
 800a9d8:	4604      	mov	r4, r0
 800a9da:	bb30      	cbnz	r0, 800aa2a <HASH_Finish+0x82>
    {
      return HAL_TIMEOUT;
    }

    /* Read the message digest */
    HASH_GetDigest(pOutBuffer, HASH_DIGEST_LENGTH());
 800a9dc:	4b14      	ldr	r3, [pc, #80]	; (800aa30 <HASH_Finish+0x88>)
 800a9de:	4a15      	ldr	r2, [pc, #84]	; (800aa34 <HASH_Finish+0x8c>)
 800a9e0:	6819      	ldr	r1, [r3, #0]
 800a9e2:	400a      	ands	r2, r1
 800a9e4:	b172      	cbz	r2, 800aa04 <HASH_Finish+0x5c>
 800a9e6:	6819      	ldr	r1, [r3, #0]
 800a9e8:	4a12      	ldr	r2, [pc, #72]	; (800aa34 <HASH_Finish+0x8c>)
 800a9ea:	400a      	ands	r2, r1
 800a9ec:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
 800a9f0:	d00a      	beq.n	800aa08 <HASH_Finish+0x60>
 800a9f2:	681a      	ldr	r2, [r3, #0]
 800a9f4:	4b0f      	ldr	r3, [pc, #60]	; (800aa34 <HASH_Finish+0x8c>)
 800a9f6:	490f      	ldr	r1, [pc, #60]	; (800aa34 <HASH_Finish+0x8c>)
 800a9f8:	4013      	ands	r3, r2
 800a9fa:	428b      	cmp	r3, r1
 800a9fc:	bf0c      	ite	eq
 800a9fe:	2120      	moveq	r1, #32
 800aa00:	2110      	movne	r1, #16
 800aa02:	e002      	b.n	800aa0a <HASH_Finish+0x62>
 800aa04:	2114      	movs	r1, #20
 800aa06:	e000      	b.n	800aa0a <HASH_Finish+0x62>
 800aa08:	211c      	movs	r1, #28
 800aa0a:	4630      	mov	r0, r6
 800aa0c:	f7ff fba0 	bl	800a150 <HASH_GetDigest>

    /* Change the HASH state to ready */
    hhash->State = HAL_HASH_STATE_READY;
 800aa10:	2301      	movs	r3, #1
 800aa12:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35

    /* Reset HASH state machine */
    hhash->Phase = HAL_HASH_PHASE_READY;
 800aa16:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d

    /* Process UnLock */
    __HAL_UNLOCK(hhash);
 800aa1a:	2300      	movs	r3, #0
 800aa1c:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34

    /* Return function status */
    return HAL_OK;
 800aa20:	e004      	b.n	800aa2c <HASH_Finish+0x84>

  }
  else
  {
    return HAL_BUSY;
 800aa22:	2402      	movs	r4, #2
 800aa24:	e002      	b.n	800aa2c <HASH_Finish+0x84>
 800aa26:	460c      	mov	r4, r1
 800aa28:	e000      	b.n	800aa2c <HASH_Finish+0x84>
    hhash->State = HAL_HASH_STATE_BUSY;

    /* Wait for DCIS flag to be set */
    if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
    {
      return HAL_TIMEOUT;
 800aa2a:	2403      	movs	r4, #3
  else
  {
    return HAL_BUSY;
  }

}
 800aa2c:	4620      	mov	r0, r4
 800aa2e:	bd70      	pop	{r4, r5, r6, pc}
 800aa30:	50060400 	.word	0x50060400
 800aa34:	00040080 	.word	0x00040080

0800aa38 <HMAC_Start>:
  * @param  Timeout Timeout value.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HMAC_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout, uint32_t Algorithm)
{
 800aa38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800aa3a:	469e      	mov	lr, r3
    HAL_HASH_StateTypeDef State_tmp = hhash->State;
 800aa3c:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
  * @param  Timeout Timeout value.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HMAC_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout, uint32_t Algorithm)
{
 800aa40:	f8dd c01c 	ldr.w	ip, [sp, #28]
    HAL_HASH_StateTypeDef State_tmp = hhash->State;
 800aa44:	b2db      	uxtb	r3, r3

   /* If State is ready or suspended, start or resume polling-based HASH processing */
if((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 800aa46:	2b01      	cmp	r3, #1
  * @param  Timeout Timeout value.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HMAC_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout, uint32_t Algorithm)
{
 800aa48:	4604      	mov	r4, r0
    HAL_HASH_StateTypeDef State_tmp = hhash->State;

   /* If State is ready or suspended, start or resume polling-based HASH processing */
if((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 800aa4a:	d002      	beq.n	800aa52 <HMAC_Start+0x1a>
 800aa4c:	2b08      	cmp	r3, #8
 800aa4e:	f040 80ed 	bne.w	800ac2c <HMAC_Start+0x1f4>
  {
    /* Check input parameters */
    if ((pInBuffer == NULL) || /*(Size == 0U) ||*/ (hhash->Init.pKey == NULL) || (hhash->Init.KeySize == 0U) || (pOutBuffer == NULL))
 800aa52:	b131      	cbz	r1, 800aa62 <HMAC_Start+0x2a>
 800aa54:	68a3      	ldr	r3, [r4, #8]
 800aa56:	b123      	cbz	r3, 800aa62 <HMAC_Start+0x2a>
 800aa58:	6866      	ldr	r6, [r4, #4]
 800aa5a:	b116      	cbz	r6, 800aa62 <HMAC_Start+0x2a>
 800aa5c:	f1be 0f00 	cmp.w	lr, #0
 800aa60:	d103      	bne.n	800aa6a <HMAC_Start+0x32>
    {
      hhash->State = HAL_HASH_STATE_READY;
 800aa62:	2001      	movs	r0, #1
 800aa64:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
      return  HAL_ERROR;
 800aa68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }

    /* Process Locked */
    __HAL_LOCK(hhash);
 800aa6a:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 800aa6e:	2801      	cmp	r0, #1
 800aa70:	f04f 0002 	mov.w	r0, #2
 800aa74:	f000 80db 	beq.w	800ac2e <HMAC_Start+0x1f6>

    /* Change the HASH state */
    hhash->State = HAL_HASH_STATE_BUSY;
 800aa78:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35

    /* Check if initialization phase has already be performed */
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 800aa7c:	f894 002d 	ldrb.w	r0, [r4, #45]	; 0x2d
      hhash->State = HAL_HASH_STATE_READY;
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(hhash);
 800aa80:	2501      	movs	r5, #1

    /* Change the HASH state */
    hhash->State = HAL_HASH_STATE_BUSY;

    /* Check if initialization phase has already be performed */
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 800aa82:	42a8      	cmp	r0, r5
      hhash->State = HAL_HASH_STATE_READY;
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(hhash);
 800aa84:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34

    /* Change the HASH state */
    hhash->State = HAL_HASH_STATE_BUSY;

    /* Check if initialization phase has already be performed */
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 800aa88:	d122      	bne.n	800aad0 <HMAC_Start+0x98>
 800aa8a:	4f69      	ldr	r7, [pc, #420]	; (800ac30 <HMAC_Start+0x1f8>)
    {
      /* Check if key size is larger than 64 bytes, accordingly set LKEY and the other setting bits */
      if(hhash->Init.KeySize > 64U)
 800aa8c:	2e40      	cmp	r6, #64	; 0x40
      {
        MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_ALGOMODE_HMAC | HASH_HMAC_KEYTYPE_LONGKEY | HASH_CR_INIT);
 800aa8e:	683d      	ldr	r5, [r7, #0]

    /* Check if initialization phase has already be performed */
    if(hhash->Phase == HAL_HASH_PHASE_READY)
    {
      /* Check if key size is larger than 64 bytes, accordingly set LKEY and the other setting bits */
      if(hhash->Init.KeySize > 64U)
 800aa90:	d90b      	bls.n	800aaaa <HMAC_Start+0x72>
      {
        MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_ALGOMODE_HMAC | HASH_HMAC_KEYTYPE_LONGKEY | HASH_CR_INIT);
 800aa92:	f425 20a0 	bic.w	r0, r5, #327680	; 0x50000
 800aa96:	f020 00c4 	bic.w	r0, r0, #196	; 0xc4
 800aa9a:	f440 3080 	orr.w	r0, r0, #65536	; 0x10000
 800aa9e:	f040 0044 	orr.w	r0, r0, #68	; 0x44
 800aaa2:	ea40 000c 	orr.w	r0, r0, ip
 800aaa6:	6038      	str	r0, [r7, #0]
 800aaa8:	e008      	b.n	800aabc <HMAC_Start+0x84>
      }
      else
      {
        MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_ALGOMODE_HMAC | HASH_CR_INIT);
 800aaaa:	f425 25a0 	bic.w	r5, r5, #327680	; 0x50000
 800aaae:	f025 05c4 	bic.w	r5, r5, #196	; 0xc4
 800aab2:	f045 0544 	orr.w	r5, r5, #68	; 0x44
 800aab6:	ea45 050c 	orr.w	r5, r5, ip
 800aaba:	603d      	str	r5, [r7, #0]
      }
      /* Set the phase to Step 1 */
      hhash->Phase = HAL_HASH_PHASE_HMAC_STEP_1;
 800aabc:	2003      	movs	r0, #3
      /* Resort to hhash internal fields to feed the Peripheral.
         Parameters will be updated in case of suspension to contain the proper
         information at resumption time. */
      hhash->pHashOutBuffPtr  = pOutBuffer;            /* Output digest address                                              */
      hhash->pHashInBuffPtr   = pInBuffer;             /* Input data address, HMAC_Processing input parameter for Step 2     */
      hhash->HashInCount      = Size;                  /* Input data size, HMAC_Processing input parameter for Step 2        */
 800aabe:	6222      	str	r2, [r4, #32]
      else
      {
        MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_ALGOMODE_HMAC | HASH_CR_INIT);
      }
      /* Set the phase to Step 1 */
      hhash->Phase = HAL_HASH_PHASE_HMAC_STEP_1;
 800aac0:	f884 002d 	strb.w	r0, [r4, #45]	; 0x2d
      /* Resort to hhash internal fields to feed the Peripheral.
         Parameters will be updated in case of suspension to contain the proper
         information at resumption time. */
      hhash->pHashOutBuffPtr  = pOutBuffer;            /* Output digest address                                              */
 800aac4:	f8c4 e010 	str.w	lr, [r4, #16]
      hhash->pHashInBuffPtr   = pInBuffer;             /* Input data address, HMAC_Processing input parameter for Step 2     */
 800aac8:	60e1      	str	r1, [r4, #12]
      hhash->HashInCount      = Size;                  /* Input data size, HMAC_Processing input parameter for Step 2        */
      hhash->HashBuffSize     = Size;                  /* Store the input buffer size for the whole HMAC process             */
 800aaca:	61e2      	str	r2, [r4, #28]
      hhash->pHashKeyBuffPtr  = hhash->Init.pKey;      /* Key address, HMAC_Processing input parameter for Step 1 and Step 3 */
 800aacc:	6163      	str	r3, [r4, #20]
      hhash->HashKeyCount     = hhash->Init.KeySize;   /* Key size, HMAC_Processing input parameter for Step 1 and Step 3    */
 800aace:	62a6      	str	r6, [r4, #40]	; 0x28
  * @retval HAL status
  */
static HAL_StatusTypeDef HMAC_Processing(HASH_HandleTypeDef *hhash, uint32_t Timeout)
{
  /* Ensure first that Phase is correct */
  if ((hhash->Phase != HAL_HASH_PHASE_HMAC_STEP_1) && (hhash->Phase != HAL_HASH_PHASE_HMAC_STEP_2) && (hhash->Phase != HAL_HASH_PHASE_HMAC_STEP_3))
 800aad0:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
 800aad4:	1eda      	subs	r2, r3, #3
 800aad6:	2a02      	cmp	r2, #2
 800aad8:	d906      	bls.n	800aae8 <HMAC_Start+0xb0>
  {
    /* Change the HASH state */
    hhash->State = HAL_HASH_STATE_READY;
 800aada:	2001      	movs	r0, #1

    /* Process Unlock */
    __HAL_UNLOCK(hhash);
 800aadc:	2300      	movs	r3, #0
{
  /* Ensure first that Phase is correct */
  if ((hhash->Phase != HAL_HASH_PHASE_HMAC_STEP_1) && (hhash->Phase != HAL_HASH_PHASE_HMAC_STEP_2) && (hhash->Phase != HAL_HASH_PHASE_HMAC_STEP_3))
  {
    /* Change the HASH state */
    hhash->State = HAL_HASH_STATE_READY;
 800aade:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35

    /* Process Unlock */
    __HAL_UNLOCK(hhash);
 800aae2:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800aae6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    /* Return function status */
    return HAL_ERROR;
  }

  /* HMAC Step 1 processing */
  if (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_1)
 800aae8:	2b03      	cmp	r3, #3
 800aaea:	d127      	bne.n	800ab3c <HMAC_Start+0x104>
  {
    /************************** STEP 1 ******************************************/
    /* Configure the Number of valid bits in last word of the message */
    __HAL_HASH_SET_NBVALIDBITS(hhash->Init.KeySize);
 800aaec:	4d50      	ldr	r5, [pc, #320]	; (800ac30 <HMAC_Start+0x1f8>)

    /* Write input buffer in Data register */
    hhash->Status = HASH_WriteData(hhash, hhash->pHashKeyBuffPtr, hhash->HashKeyCount);
 800aaee:	6961      	ldr	r1, [r4, #20]
  /* HMAC Step 1 processing */
  if (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_1)
  {
    /************************** STEP 1 ******************************************/
    /* Configure the Number of valid bits in last word of the message */
    __HAL_HASH_SET_NBVALIDBITS(hhash->Init.KeySize);
 800aaf0:	68ab      	ldr	r3, [r5, #8]
 800aaf2:	f006 0603 	and.w	r6, r6, #3
 800aaf6:	f023 031f 	bic.w	r3, r3, #31
 800aafa:	ea43 06c6 	orr.w	r6, r3, r6, lsl #3
 800aafe:	60ae      	str	r6, [r5, #8]

    /* Write input buffer in Data register */
    hhash->Status = HASH_WriteData(hhash, hhash->pHashKeyBuffPtr, hhash->HashKeyCount);
 800ab00:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800ab02:	4620      	mov	r0, r4
 800ab04:	f7ff fae2 	bl	800a0cc <HASH_WriteData>
 800ab08:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
    if (hhash->Status != HAL_OK)
 800ab0c:	2800      	cmp	r0, #0
 800ab0e:	f040 808e 	bne.w	800ac2e <HMAC_Start+0x1f6>
    {
      return hhash->Status;
    }

    /* Check whether or not key entering process has been suspended */
    if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 800ab12:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 800ab16:	2b08      	cmp	r3, #8
 800ab18:	f000 8084 	beq.w	800ac24 <HMAC_Start+0x1ec>
      /* Stop right there and return function status */
      return HAL_OK;
    }

    /* No processing suspension at this point: set DCAL bit. */
    __HAL_HASH_START_DIGEST();
 800ab1c:	68ab      	ldr	r3, [r5, #8]
 800ab1e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800ab22:	60ab      	str	r3, [r5, #8]

    /* Wait for BUSY flag to be cleared */
    if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_BUSY, SET, Timeout) != HAL_OK)
 800ab24:	9b06      	ldr	r3, [sp, #24]
 800ab26:	2201      	movs	r2, #1
 800ab28:	2108      	movs	r1, #8
 800ab2a:	4620      	mov	r0, r4
 800ab2c:	f7ff fb72 	bl	800a214 <HASH_WaitOnFlagUntilTimeout>
 800ab30:	b108      	cbz	r0, 800ab36 <HMAC_Start+0xfe>
    {
      return HAL_TIMEOUT;
 800ab32:	2003      	movs	r0, #3
 800ab34:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }

    /* Move from Step 1 to Step 2 */
    hhash->Phase = HAL_HASH_PHASE_HMAC_STEP_2;
 800ab36:	2304      	movs	r3, #4
 800ab38:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
  /* HMAC Step 2 processing.
     After phase check, HMAC_Processing() may
     - directly start up from this point in resumption case
       if the same Step 2 processing was suspended previously
    - or fall through from the Step 1 processing carried out hereabove */
  if (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_2)
 800ab3c:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
 800ab40:	2b04      	cmp	r3, #4
 800ab42:	d129      	bne.n	800ab98 <HMAC_Start+0x160>
  {
    /************************** STEP 2 ******************************************/
    /* Configure the Number of valid bits in last word of the message */
    __HAL_HASH_SET_NBVALIDBITS(hhash->HashBuffSize);
 800ab44:	4d3a      	ldr	r5, [pc, #232]	; (800ac30 <HMAC_Start+0x1f8>)
 800ab46:	69e2      	ldr	r2, [r4, #28]
 800ab48:	68ab      	ldr	r3, [r5, #8]

    /* Write input buffer in Data register */
    hhash->Status = HASH_WriteData(hhash, hhash->pHashInBuffPtr, hhash->HashInCount);
 800ab4a:	68e1      	ldr	r1, [r4, #12]
    - or fall through from the Step 1 processing carried out hereabove */
  if (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_2)
  {
    /************************** STEP 2 ******************************************/
    /* Configure the Number of valid bits in last word of the message */
    __HAL_HASH_SET_NBVALIDBITS(hhash->HashBuffSize);
 800ab4c:	f002 0203 	and.w	r2, r2, #3
 800ab50:	f023 031f 	bic.w	r3, r3, #31
 800ab54:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 800ab58:	60ab      	str	r3, [r5, #8]

    /* Write input buffer in Data register */
    hhash->Status = HASH_WriteData(hhash, hhash->pHashInBuffPtr, hhash->HashInCount);
 800ab5a:	6a22      	ldr	r2, [r4, #32]
 800ab5c:	4620      	mov	r0, r4
 800ab5e:	f7ff fab5 	bl	800a0cc <HASH_WriteData>
 800ab62:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
    if (hhash->Status != HAL_OK)
 800ab66:	2800      	cmp	r0, #0
 800ab68:	d161      	bne.n	800ac2e <HMAC_Start+0x1f6>
    {
      return hhash->Status;
    }

    /* Check whether or not data entering process has been suspended */
    if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 800ab6a:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 800ab6e:	2b08      	cmp	r3, #8
 800ab70:	d058      	beq.n	800ac24 <HMAC_Start+0x1ec>
      /* Stop right there and return function status */
      return HAL_OK;
    }

    /* No processing suspension at this point: set DCAL bit. */
    __HAL_HASH_START_DIGEST();
 800ab72:	68ab      	ldr	r3, [r5, #8]
 800ab74:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800ab78:	60ab      	str	r3, [r5, #8]

    /* Wait for BUSY flag to be cleared */
    if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_BUSY, SET, Timeout) != HAL_OK)
 800ab7a:	9b06      	ldr	r3, [sp, #24]
 800ab7c:	2201      	movs	r2, #1
 800ab7e:	2108      	movs	r1, #8
 800ab80:	4620      	mov	r0, r4
 800ab82:	f7ff fb47 	bl	800a214 <HASH_WaitOnFlagUntilTimeout>
 800ab86:	2800      	cmp	r0, #0
 800ab88:	d1d3      	bne.n	800ab32 <HMAC_Start+0xfa>
    {
      return HAL_TIMEOUT;
    }

    /* Move from Step 2 to Step 3 */
    hhash->Phase = HAL_HASH_PHASE_HMAC_STEP_3;
 800ab8a:	2305      	movs	r3, #5
 800ab8c:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
    /* In case Step 1 phase was suspended then resumed,
       set again Key input buffers and size before moving to
       next step */
    hhash->pHashKeyBuffPtr = hhash->Init.pKey;
 800ab90:	68a3      	ldr	r3, [r4, #8]
 800ab92:	6163      	str	r3, [r4, #20]
    hhash->HashKeyCount    = hhash->Init.KeySize;
 800ab94:	6863      	ldr	r3, [r4, #4]
 800ab96:	62a3      	str	r3, [r4, #40]	; 0x28
 /* HMAC Step 3 processing.
     After phase check, HMAC_Processing() may
     - directly start up from this point in resumption case
       if the same Step 3 processing was suspended previously
    - or fall through from the Step 2 processing carried out hereabove */
  if (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_3)
 800ab98:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
 800ab9c:	2b05      	cmp	r3, #5
 800ab9e:	d13e      	bne.n	800ac1e <HMAC_Start+0x1e6>
  {
    /************************** STEP 3 ******************************************/
    /* Configure the Number of valid bits in last word of the message */
    __HAL_HASH_SET_NBVALIDBITS(hhash->Init.KeySize);
 800aba0:	4d23      	ldr	r5, [pc, #140]	; (800ac30 <HMAC_Start+0x1f8>)
 800aba2:	6862      	ldr	r2, [r4, #4]
 800aba4:	68ab      	ldr	r3, [r5, #8]

    /* Write input buffer in Data register */
    hhash->Status = HASH_WriteData(hhash, hhash->pHashKeyBuffPtr, hhash->HashKeyCount);
 800aba6:	6961      	ldr	r1, [r4, #20]
    - or fall through from the Step 2 processing carried out hereabove */
  if (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_3)
  {
    /************************** STEP 3 ******************************************/
    /* Configure the Number of valid bits in last word of the message */
    __HAL_HASH_SET_NBVALIDBITS(hhash->Init.KeySize);
 800aba8:	f002 0203 	and.w	r2, r2, #3
 800abac:	f023 031f 	bic.w	r3, r3, #31
 800abb0:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 800abb4:	60ab      	str	r3, [r5, #8]

    /* Write input buffer in Data register */
    hhash->Status = HASH_WriteData(hhash, hhash->pHashKeyBuffPtr, hhash->HashKeyCount);
 800abb6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800abb8:	4620      	mov	r0, r4
 800abba:	f7ff fa87 	bl	800a0cc <HASH_WriteData>
 800abbe:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
    if (hhash->Status != HAL_OK)
 800abc2:	2800      	cmp	r0, #0
 800abc4:	d133      	bne.n	800ac2e <HMAC_Start+0x1f6>
    {
      return hhash->Status;
    }

    /* Check whether or not key entering process has been suspended */
    if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 800abc6:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 800abca:	2b08      	cmp	r3, #8
 800abcc:	d02a      	beq.n	800ac24 <HMAC_Start+0x1ec>
      /* Stop right there and return function status */
      return HAL_OK;
    }

    /* No processing suspension at this point: start the Digest calculation. */
    __HAL_HASH_START_DIGEST();
 800abce:	68ab      	ldr	r3, [r5, #8]
 800abd0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800abd4:	60ab      	str	r3, [r5, #8]

    /* Wait for DCIS flag to be set */
     if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
 800abd6:	4602      	mov	r2, r0
 800abd8:	9b06      	ldr	r3, [sp, #24]
 800abda:	2102      	movs	r1, #2
 800abdc:	4620      	mov	r0, r4
 800abde:	f7ff fb19 	bl	800a214 <HASH_WaitOnFlagUntilTimeout>
 800abe2:	2800      	cmp	r0, #0
 800abe4:	d1a5      	bne.n	800ab32 <HMAC_Start+0xfa>
    {
      return HAL_TIMEOUT;
    }

    /* Read the message digest */
    HASH_GetDigest(hhash->pHashOutBuffPtr, HASH_DIGEST_LENGTH());
 800abe6:	682a      	ldr	r2, [r5, #0]
 800abe8:	4b12      	ldr	r3, [pc, #72]	; (800ac34 <HMAC_Start+0x1fc>)
 800abea:	6920      	ldr	r0, [r4, #16]
 800abec:	4013      	ands	r3, r2
 800abee:	b173      	cbz	r3, 800ac0e <HMAC_Start+0x1d6>
 800abf0:	682a      	ldr	r2, [r5, #0]
 800abf2:	4b10      	ldr	r3, [pc, #64]	; (800ac34 <HMAC_Start+0x1fc>)
 800abf4:	4013      	ands	r3, r2
 800abf6:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800abfa:	d00a      	beq.n	800ac12 <HMAC_Start+0x1da>
 800abfc:	682a      	ldr	r2, [r5, #0]
 800abfe:	4b0d      	ldr	r3, [pc, #52]	; (800ac34 <HMAC_Start+0x1fc>)
 800ac00:	490c      	ldr	r1, [pc, #48]	; (800ac34 <HMAC_Start+0x1fc>)
 800ac02:	4013      	ands	r3, r2
 800ac04:	428b      	cmp	r3, r1
 800ac06:	bf0c      	ite	eq
 800ac08:	2120      	moveq	r1, #32
 800ac0a:	2110      	movne	r1, #16
 800ac0c:	e002      	b.n	800ac14 <HMAC_Start+0x1dc>
 800ac0e:	2114      	movs	r1, #20
 800ac10:	e000      	b.n	800ac14 <HMAC_Start+0x1dc>
 800ac12:	211c      	movs	r1, #28
 800ac14:	f7ff fa9c 	bl	800a150 <HASH_GetDigest>

    /* Reset HASH state machine */
    hhash->Phase = HAL_HASH_PHASE_READY;
 800ac18:	2301      	movs	r3, #1
 800ac1a:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
  }

   /* Change the HASH state */
   hhash->State = HAL_HASH_STATE_READY;
 800ac1e:	2301      	movs	r3, #1
 800ac20:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

   /* Process Unlock */
   __HAL_UNLOCK(hhash);
 800ac24:	2000      	movs	r0, #0
 800ac26:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
 800ac2a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HMAC_Processing(hhash, Timeout);

  }
  else
  {
    return HAL_BUSY;
 800ac2c:	2002      	movs	r0, #2
  }
}
 800ac2e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ac30:	50060400 	.word	0x50060400
 800ac34:	00040080 	.word	0x00040080

0800ac38 <OSPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart : Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef OSPI_WaitFlagStateUntilTimeout(OSPI_HandleTypeDef *hospi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
 800ac38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800ac3c:	9d06      	ldr	r5, [sp, #24]
 800ac3e:	4604      	mov	r4, r0
 800ac40:	460f      	mov	r7, r1
 800ac42:	4616      	mov	r6, r2
 800ac44:	4698      	mov	r8, r3
  /* Wait until flag is in expected state */
  while((__HAL_OSPI_GET_FLAG(hospi, Flag)) != State)
 800ac46:	6821      	ldr	r1, [r4, #0]
 800ac48:	6a0a      	ldr	r2, [r1, #32]
 800ac4a:	423a      	tst	r2, r7
 800ac4c:	bf14      	ite	ne
 800ac4e:	2201      	movne	r2, #1
 800ac50:	2200      	moveq	r2, #0
 800ac52:	42b2      	cmp	r2, r6
 800ac54:	d013      	beq.n	800ac7e <OSPI_WaitFlagStateUntilTimeout+0x46>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800ac56:	1c6b      	adds	r3, r5, #1
 800ac58:	d0f6      	beq.n	800ac48 <OSPI_WaitFlagStateUntilTimeout+0x10>
    {
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800ac5a:	f7fc f9d7 	bl	800700c <HAL_GetTick>
 800ac5e:	ebc8 0000 	rsb	r0, r8, r0
 800ac62:	4285      	cmp	r5, r0
 800ac64:	d301      	bcc.n	800ac6a <OSPI_WaitFlagStateUntilTimeout+0x32>
 800ac66:	2d00      	cmp	r5, #0
 800ac68:	d1ed      	bne.n	800ac46 <OSPI_WaitFlagStateUntilTimeout+0xe>
      {
        hospi->State     = HAL_OSPI_STATE_ERROR;
 800ac6a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800ac6e:	6463      	str	r3, [r4, #68]	; 0x44
        hospi->ErrorCode |= HAL_OSPI_ERROR_TIMEOUT;
 800ac70:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800ac72:	f043 0301 	orr.w	r3, r3, #1
 800ac76:	64a3      	str	r3, [r4, #72]	; 0x48
 800ac78:	2001      	movs	r0, #1
 800ac7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
 800ac7e:	2000      	movs	r0, #0
}
 800ac80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800ac84 <HAL_OSPI_MspInit>:
  * @brief  Initialize the OSPI MSP.
  * @param  hospi : OSPI handle
  * @retval None
  */
__weak void HAL_OSPI_MspInit(OSPI_HandleTypeDef *hospi)
{
 800ac84:	4770      	bx	lr
	...

0800ac88 <HAL_OSPI_Init>:
  *         in the OSPI_InitTypeDef and initialize the associated handle.
  * @param  hospi : OSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_Init (OSPI_HandleTypeDef *hospi)
{
 800ac88:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800ac8a:	4604      	mov	r4, r0
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tickstart = HAL_GetTick();
 800ac8c:	f7fc f9be 	bl	800700c <HAL_GetTick>
 800ac90:	4607      	mov	r7, r0

  /* Check the OSPI handle allocation */
  if (hospi == NULL)
 800ac92:	2c00      	cmp	r4, #0
 800ac94:	d05c      	beq.n	800ad50 <HAL_OSPI_Init+0xc8>
#if   defined (OCTOSPI_DCR3_MAXTRAN)
    assert_param(IS_OSPI_MAXTRAN        (hospi->Init.MaxTran));
#endif

    /* Initialize error code */
    hospi->ErrorCode = HAL_OSPI_ERROR_NONE;
 800ac96:	2000      	movs	r0, #0
 800ac98:	64a0      	str	r0, [r4, #72]	; 0x48

    /* Check if the state is the reset state */
    if (hospi->State == HAL_OSPI_STATE_RESET)
 800ac9a:	6c66      	ldr	r6, [r4, #68]	; 0x44
 800ac9c:	2e00      	cmp	r6, #0
 800ac9e:	d158      	bne.n	800ad52 <HAL_OSPI_Init+0xca>

      /* Init the low level hardware */
      hospi->MspInitCallback(hospi);
#else
      /* Initialization of the low level hardware */
      HAL_OSPI_MspInit(hospi);
 800aca0:	4620      	mov	r0, r4
 800aca2:	f7ff ffef 	bl	800ac84 <HAL_OSPI_MspInit>

      /* Configure the default timeout for the OSPI memory access */
      (void)HAL_OSPI_SetTimeout(hospi, HAL_OSPI_TIMEOUT_DEFAULT_VALUE);

      /* Configure memory type, device size, chip select high time, delay block bypass, free running clock, clock mode */
      MODIFY_REG(hospi->Instance->DCR1,
 800aca6:	68e0      	ldr	r0, [r4, #12]
 800aca8:	6b21      	ldr	r1, [r4, #48]	; 0x30
 800acaa:	6825      	ldr	r5, [r4, #0]
 800acac:	4301      	orrs	r1, r0
 800acae:	69e0      	ldr	r0, [r4, #28]
 800acb0:	68ab      	ldr	r3, [r5, #8]
 800acb2:	4308      	orrs	r0, r1
 800acb4:	4928      	ldr	r1, [pc, #160]	; (800ad58 <HAL_OSPI_Init+0xd0>)
 800acb6:	4019      	ands	r1, r3
 800acb8:	4301      	orrs	r1, r0
 800acba:	6920      	ldr	r0, [r4, #16]
#if   defined (OCTOSPI_DCR3_MAXTRAN)
      /* Configure chip select boundary and maximun transfer */
      hospi->Instance->DCR3 = ((hospi->Init.ChipSelectBoundary << OCTOSPI_DCR3_CSBOUND_Pos) | (hospi->Init.MaxTran << OCTOSPI_DCR3_MAXTRAN_Pos));
#else
      /* Configure chip select boundary */
      hospi->Instance->DCR3 = (hospi->Init.ChipSelectBoundary << OCTOSPI_DCR3_CSBOUND_Pos);
 800acbc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c

      /* Configure the default timeout for the OSPI memory access */
      (void)HAL_OSPI_SetTimeout(hospi, HAL_OSPI_TIMEOUT_DEFAULT_VALUE);

      /* Configure memory type, device size, chip select high time, delay block bypass, free running clock, clock mode */
      MODIFY_REG(hospi->Instance->DCR1,
 800acbe:	3801      	subs	r0, #1
 800acc0:	ea41 4000 	orr.w	r0, r1, r0, lsl #16
 800acc4:	6961      	ldr	r1, [r4, #20]
 800acc6:	3901      	subs	r1, #1
  * @param  Timeout : Timeout for the memory access.
  * @retval None
  */
HAL_StatusTypeDef HAL_OSPI_SetTimeout(OSPI_HandleTypeDef *hospi, uint32_t Timeout)
{
  hospi->Timeout = Timeout;
 800acc8:	f241 3288 	movw	r2, #5000	; 0x1388

      /* Configure the default timeout for the OSPI memory access */
      (void)HAL_OSPI_SetTimeout(hospi, HAL_OSPI_TIMEOUT_DEFAULT_VALUE);

      /* Configure memory type, device size, chip select high time, delay block bypass, free running clock, clock mode */
      MODIFY_REG(hospi->Instance->DCR1,
 800accc:	ea40 2101 	orr.w	r1, r0, r1, lsl #8
#if   defined (OCTOSPI_DCR3_MAXTRAN)
      /* Configure chip select boundary and maximun transfer */
      hospi->Instance->DCR3 = ((hospi->Init.ChipSelectBoundary << OCTOSPI_DCR3_CSBOUND_Pos) | (hospi->Init.MaxTran << OCTOSPI_DCR3_MAXTRAN_Pos));
#else
      /* Configure chip select boundary */
      hospi->Instance->DCR3 = (hospi->Init.ChipSelectBoundary << OCTOSPI_DCR3_CSBOUND_Pos);
 800acd0:	041b      	lsls	r3, r3, #16
  * @param  Timeout : Timeout for the memory access.
  * @retval None
  */
HAL_StatusTypeDef HAL_OSPI_SetTimeout(OSPI_HandleTypeDef *hospi, uint32_t Timeout)
{
  hospi->Timeout = Timeout;
 800acd2:	64e2      	str	r2, [r4, #76]	; 0x4c

      /* Configure the default timeout for the OSPI memory access */
      (void)HAL_OSPI_SetTimeout(hospi, HAL_OSPI_TIMEOUT_DEFAULT_VALUE);

      /* Configure memory type, device size, chip select high time, delay block bypass, free running clock, clock mode */
      MODIFY_REG(hospi->Instance->DCR1,
 800acd4:	60a9      	str	r1, [r5, #8]
#if   defined (OCTOSPI_DCR3_MAXTRAN)
      /* Configure chip select boundary and maximun transfer */
      hospi->Instance->DCR3 = ((hospi->Init.ChipSelectBoundary << OCTOSPI_DCR3_CSBOUND_Pos) | (hospi->Init.MaxTran << OCTOSPI_DCR3_MAXTRAN_Pos));
#else
      /* Configure chip select boundary */
      hospi->Instance->DCR3 = (hospi->Init.ChipSelectBoundary << OCTOSPI_DCR3_CSBOUND_Pos);
 800acd6:	612b      	str	r3, [r5, #16]
      /* Configure refresh */
      hospi->Instance->DCR4 = hospi->Init.Refresh;
#endif

      /* Configure FIFO threshold */
      MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FTHRES, ((hospi->Init.FifoThreshold - 1U) << OCTOSPI_CR_FTHRES_Pos));
 800acd8:	6829      	ldr	r1, [r5, #0]
 800acda:	6863      	ldr	r3, [r4, #4]
 800acdc:	f421 51f8 	bic.w	r1, r1, #7936	; 0x1f00
 800ace0:	3b01      	subs	r3, #1
 800ace2:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
 800ace6:	6029      	str	r1, [r5, #0]

      /* Wait till busy flag is reset */
      status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);
 800ace8:	463b      	mov	r3, r7
 800acea:	9200      	str	r2, [sp, #0]
 800acec:	2120      	movs	r1, #32
 800acee:	4632      	mov	r2, r6
 800acf0:	4620      	mov	r0, r4
 800acf2:	f7ff ffa1 	bl	800ac38 <OSPI_WaitFlagStateUntilTimeout>

      if (status == HAL_OK)
 800acf6:	2800      	cmp	r0, #0
 800acf8:	d12b      	bne.n	800ad52 <HAL_OSPI_Init+0xca>
      {
        /* Configure clock prescaler */
        MODIFY_REG(hospi->Instance->DCR2, OCTOSPI_DCR2_PRESCALER, ((hospi->Init.ClockPrescaler - 1U) << OCTOSPI_DCR2_PRESCALER_Pos));
 800acfa:	6823      	ldr	r3, [r4, #0]
 800acfc:	6a21      	ldr	r1, [r4, #32]
 800acfe:	68da      	ldr	r2, [r3, #12]

        /* Configure Dual Quad mode */
        MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_DQM, hospi->Init.DualQuad);

        /* Configure sample shifting and delay hold quarter cycle */
        MODIFY_REG(hospi->Instance->TCR, (OCTOSPI_TCR_SSHIFT | OCTOSPI_TCR_DHQC), (hospi->Init.SampleShifting | hospi->Init.DelayHoldQuarterCycle));
 800ad00:	6a65      	ldr	r5, [r4, #36]	; 0x24
      status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);

      if (status == HAL_OK)
      {
        /* Configure clock prescaler */
        MODIFY_REG(hospi->Instance->DCR2, OCTOSPI_DCR2_PRESCALER, ((hospi->Init.ClockPrescaler - 1U) << OCTOSPI_DCR2_PRESCALER_Pos));
 800ad02:	3901      	subs	r1, #1
 800ad04:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 800ad08:	430a      	orrs	r2, r1
 800ad0a:	60da      	str	r2, [r3, #12]

        /* Configure Dual Quad mode */
        MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_DQM, hospi->Init.DualQuad);
 800ad0c:	681a      	ldr	r2, [r3, #0]
 800ad0e:	f022 0140 	bic.w	r1, r2, #64	; 0x40
 800ad12:	68a2      	ldr	r2, [r4, #8]
 800ad14:	430a      	orrs	r2, r1
 800ad16:	601a      	str	r2, [r3, #0]

        /* Configure sample shifting and delay hold quarter cycle */
        MODIFY_REG(hospi->Instance->TCR, (OCTOSPI_TCR_SSHIFT | OCTOSPI_TCR_DHQC), (hospi->Init.SampleShifting | hospi->Init.DelayHoldQuarterCycle));
 800ad18:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
 800ad1c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800ad1e:	f022 42a0 	bic.w	r2, r2, #1342177280	; 0x50000000
 800ad22:	4329      	orrs	r1, r5
 800ad24:	430a      	orrs	r2, r1
 800ad26:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108

        /* Enable OctoSPI */
        __HAL_OSPI_ENABLE(hospi);
 800ad2a:	681a      	ldr	r2, [r3, #0]
 800ad2c:	f042 0201 	orr.w	r2, r2, #1
 800ad30:	601a      	str	r2, [r3, #0]

        /* Enable free running clock if needed : must be done after OSPI enable */
        if (hospi->Init.FreeRunningClock == HAL_OSPI_FREERUNCLK_ENABLE)
 800ad32:	69a2      	ldr	r2, [r4, #24]
 800ad34:	2a02      	cmp	r2, #2
        {
          SET_BIT(hospi->Instance->DCR1, OCTOSPI_DCR1_FRCK);
 800ad36:	bf02      	ittt	eq
 800ad38:	689a      	ldreq	r2, [r3, #8]
 800ad3a:	f042 0202 	orreq.w	r2, r2, #2
 800ad3e:	609a      	streq	r2, [r3, #8]
        }

        /* Initialize the OSPI state */
        if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
 800ad40:	68e3      	ldr	r3, [r4, #12]
 800ad42:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
        {
          hospi->State = HAL_OSPI_STATE_HYPERBUS_INIT;
 800ad46:	bf0c      	ite	eq
 800ad48:	2301      	moveq	r3, #1
        }
        else
        {
          hospi->State = HAL_OSPI_STATE_READY;
 800ad4a:	2302      	movne	r3, #2
 800ad4c:	6463      	str	r3, [r4, #68]	; 0x44
 800ad4e:	e000      	b.n	800ad52 <HAL_OSPI_Init+0xca>
  uint32_t tickstart = HAL_GetTick();

  /* Check the OSPI handle allocation */
  if (hospi == NULL)
  {
    status = HAL_ERROR;
 800ad50:	2001      	movs	r0, #1
    }
  }

  /* Return function status */
  return status;
}
 800ad52:	b003      	add	sp, #12
 800ad54:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800ad56:	bf00      	nop
 800ad58:	f8e0f8f4 	.word	0xf8e0f8f4

0800ad5c <HAL_OSPI_Command>:
  * @param  cmd     : structure that contains the command configuration information
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_Command(OSPI_HandleTypeDef *hospi, OSPI_RegularCmdTypeDef *cmd, uint32_t Timeout)
{
 800ad5c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ad60:	4605      	mov	r5, r0
 800ad62:	460c      	mov	r4, r1
 800ad64:	4691      	mov	r9, r2
  HAL_StatusTypeDef status;
  uint32_t state;
  uint32_t tickstart = HAL_GetTick();
 800ad66:	f7fc f951 	bl	800700c <HAL_GetTick>

  assert_param(IS_OSPI_DQS_MODE (cmd->DQSMode));
  assert_param(IS_OSPI_SIOO_MODE(cmd->SIOOMode));

  /* Check the state of the driver */
  state = hospi->State;
 800ad6a:	6c6b      	ldr	r3, [r5, #68]	; 0x44
  if (((state == HAL_OSPI_STATE_READY)         && (hospi->Init.MemoryType != HAL_OSPI_MEMTYPE_HYPERBUS)) ||
 800ad6c:	2b02      	cmp	r3, #2
  */
HAL_StatusTypeDef HAL_OSPI_Command(OSPI_HandleTypeDef *hospi, OSPI_RegularCmdTypeDef *cmd, uint32_t Timeout)
{
  HAL_StatusTypeDef status;
  uint32_t state;
  uint32_t tickstart = HAL_GetTick();
 800ad6e:	4680      	mov	r8, r0
  assert_param(IS_OSPI_DQS_MODE (cmd->DQSMode));
  assert_param(IS_OSPI_SIOO_MODE(cmd->SIOOMode));

  /* Check the state of the driver */
  state = hospi->State;
  if (((state == HAL_OSPI_STATE_READY)         && (hospi->Init.MemoryType != HAL_OSPI_MEMTYPE_HYPERBUS)) ||
 800ad70:	d104      	bne.n	800ad7c <HAL_OSPI_Command+0x20>
 800ad72:	68eb      	ldr	r3, [r5, #12]
 800ad74:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 800ad78:	d10c      	bne.n	800ad94 <HAL_OSPI_Command+0x38>
 800ad7a:	e0f5      	b.n	800af68 <HAL_OSPI_Command+0x20c>
 800ad7c:	2b14      	cmp	r3, #20
 800ad7e:	d102      	bne.n	800ad86 <HAL_OSPI_Command+0x2a>
      ((state == HAL_OSPI_STATE_READ_CMD_CFG)  && (cmd->OperationType == HAL_OSPI_OPTYPE_WRITE_CFG))     ||
 800ad80:	6823      	ldr	r3, [r4, #0]
 800ad82:	2b02      	cmp	r3, #2
 800ad84:	e004      	b.n	800ad90 <HAL_OSPI_Command+0x34>
 800ad86:	2b24      	cmp	r3, #36	; 0x24
 800ad88:	f040 80ee 	bne.w	800af68 <HAL_OSPI_Command+0x20c>
      ((state == HAL_OSPI_STATE_WRITE_CMD_CFG) && (cmd->OperationType == HAL_OSPI_OPTYPE_READ_CFG)))
 800ad8c:	6823      	ldr	r3, [r4, #0]
 800ad8e:	2b01      	cmp	r3, #1
 800ad90:	f040 80ea 	bne.w	800af68 <HAL_OSPI_Command+0x20c>
  {
    /* Wait till busy flag is reset */
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, Timeout);
 800ad94:	f8cd 9000 	str.w	r9, [sp]
 800ad98:	4643      	mov	r3, r8
 800ad9a:	2200      	movs	r2, #0
 800ad9c:	2120      	movs	r1, #32
 800ad9e:	4628      	mov	r0, r5
 800ada0:	f7ff ff4a 	bl	800ac38 <OSPI_WaitFlagStateUntilTimeout>

    if (status == HAL_OK)
 800ada4:	2800      	cmp	r0, #0
 800ada6:	f040 8100 	bne.w	800afaa <HAL_OSPI_Command+0x24e>
{
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t *ccr_reg, *tcr_reg, *ir_reg, *abr_reg;

  /* Re-initialize the value of the functional mode */
  MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, 0U);
 800adaa:	682a      	ldr	r2, [r5, #0]
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, Timeout);

    if (status == HAL_OK)
    {
      /* Initialize error code */
      hospi->ErrorCode = HAL_OSPI_ERROR_NONE;
 800adac:	64a8      	str	r0, [r5, #72]	; 0x48
{
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t *ccr_reg, *tcr_reg, *ir_reg, *abr_reg;

  /* Re-initialize the value of the functional mode */
  MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, 0U);
 800adae:	6813      	ldr	r3, [r2, #0]
 800adb0:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 800adb4:	6013      	str	r3, [r2, #0]

  /* Configure the flash ID */
  if (hospi->Init.DualQuad == HAL_OSPI_DUALQUAD_DISABLE)
 800adb6:	68ab      	ldr	r3, [r5, #8]
 800adb8:	b92b      	cbnz	r3, 800adc6 <HAL_OSPI_Command+0x6a>
  {
    MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FSEL, cmd->FlashId);
 800adba:	6813      	ldr	r3, [r2, #0]
 800adbc:	f023 0180 	bic.w	r1, r3, #128	; 0x80
 800adc0:	6863      	ldr	r3, [r4, #4]
 800adc2:	430b      	orrs	r3, r1
 800adc4:	6013      	str	r3, [r2, #0]
  }

  if (cmd->OperationType == HAL_OSPI_OPTYPE_WRITE_CFG)
 800adc6:	6823      	ldr	r3, [r4, #0]
    ir_reg  = &(hospi->Instance->IR);
    abr_reg = &(hospi->Instance->ABR);
  }

  /* Configure the CCR register with DQS and SIOO modes */
  *ccr_reg = (cmd->DQSMode | cmd->SIOOMode);
 800adc8:	6ca7      	ldr	r7, [r4, #72]	; 0x48
 800adca:	6ce6      	ldr	r6, [r4, #76]	; 0x4c
  if (hospi->Init.DualQuad == HAL_OSPI_DUALQUAD_DISABLE)
  {
    MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FSEL, cmd->FlashId);
  }

  if (cmd->OperationType == HAL_OSPI_OPTYPE_WRITE_CFG)
 800adcc:	2b02      	cmp	r3, #2
  {
    ccr_reg = &(hospi->Instance->WCCR);
 800adce:	bf0c      	ite	eq
 800add0:	f502 73c0 	addeq.w	r3, r2, #384	; 0x180
    ir_reg  = &(hospi->Instance->WIR);
    abr_reg = &(hospi->Instance->WABR);
  }
  else
  {
    ccr_reg = &(hospi->Instance->CCR);
 800add4:	f502 7380 	addne.w	r3, r2, #256	; 0x100
    ir_reg  = &(hospi->Instance->IR);
    abr_reg = &(hospi->Instance->ABR);
  }

  /* Configure the CCR register with DQS and SIOO modes */
  *ccr_reg = (cmd->DQSMode | cmd->SIOOMode);
 800add8:	ea46 0607 	orr.w	r6, r6, r7
 800addc:	601e      	str	r6, [r3, #0]

  if (cmd->AlternateBytesMode != HAL_OSPI_ALTERNATE_BYTES_NONE)
 800adde:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  }

  if (cmd->OperationType == HAL_OSPI_OPTYPE_WRITE_CFG)
  {
    ccr_reg = &(hospi->Instance->WCCR);
    tcr_reg = &(hospi->Instance->WTCR);
 800ade0:	bf03      	ittte	eq
 800ade2:	f502 7ec4 	addeq.w	lr, r2, #392	; 0x188
    ir_reg  = &(hospi->Instance->WIR);
 800ade6:	f502 71c8 	addeq.w	r1, r2, #400	; 0x190
    abr_reg = &(hospi->Instance->WABR);
 800adea:	f502 7cd0 	addeq.w	ip, r2, #416	; 0x1a0
  }
  else
  {
    ccr_reg = &(hospi->Instance->CCR);
    tcr_reg = &(hospi->Instance->TCR);
 800adee:	f502 7e84 	addne.w	lr, r2, #264	; 0x108
    ir_reg  = &(hospi->Instance->IR);
 800adf2:	bf1c      	itt	ne
 800adf4:	f502 7188 	addne.w	r1, r2, #272	; 0x110
    abr_reg = &(hospi->Instance->ABR);
 800adf8:	f502 7c90 	addne.w	ip, r2, #288	; 0x120
  }

  /* Configure the CCR register with DQS and SIOO modes */
  *ccr_reg = (cmd->DQSMode | cmd->SIOOMode);

  if (cmd->AlternateBytesMode != HAL_OSPI_ALTERNATE_BYTES_NONE)
 800adfc:	b176      	cbz	r6, 800ae1c <HAL_OSPI_Command+0xc0>
  {
    /* Configure the ABR register with alternate bytes value */
    *abr_reg = cmd->AlternateBytes;
 800adfe:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 800ae00:	f8cc 6000 	str.w	r6, [ip]

    /* Configure the CCR register with alternate bytes communication parameters */
    MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ABMODE | OCTOSPI_CCR_ABDTR | OCTOSPI_CCR_ABSIZE),
 800ae04:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 800ae06:	6b66      	ldr	r6, [r4, #52]	; 0x34
 800ae08:	f8d3 c000 	ldr.w	ip, [r3]
 800ae0c:	433e      	orrs	r6, r7
 800ae0e:	6b27      	ldr	r7, [r4, #48]	; 0x30
 800ae10:	f42c 1c7c 	bic.w	ip, ip, #4128768	; 0x3f0000
 800ae14:	433e      	orrs	r6, r7
 800ae16:	ea46 060c 	orr.w	r6, r6, ip
 800ae1a:	601e      	str	r6, [r3, #0]
                           (cmd->AlternateBytesMode | cmd->AlternateBytesDtrMode | cmd->AlternateBytesSize));
  }

  /* Configure the TCR register with the number of dummy cycles */
  MODIFY_REG((*tcr_reg), OCTOSPI_TCR_DCYC, cmd->DummyCycles);
 800ae1c:	f8de 6000 	ldr.w	r6, [lr]
 800ae20:	f026 071f 	bic.w	r7, r6, #31
 800ae24:	6c66      	ldr	r6, [r4, #68]	; 0x44
 800ae26:	433e      	orrs	r6, r7
 800ae28:	f8ce 6000 	str.w	r6, [lr]

  if (cmd->DataMode != HAL_OSPI_DATA_NONE)
 800ae2c:	f8d4 c038 	ldr.w	ip, [r4, #56]	; 0x38
 800ae30:	f1bc 0f00 	cmp.w	ip, #0
 800ae34:	d004      	beq.n	800ae40 <HAL_OSPI_Command+0xe4>
  {
    if (cmd->OperationType == HAL_OSPI_OPTYPE_COMMON_CFG)
 800ae36:	6826      	ldr	r6, [r4, #0]
 800ae38:	b916      	cbnz	r6, 800ae40 <HAL_OSPI_Command+0xe4>
    {
      /* Configure the DLR register with the number of data */
      hospi->Instance->DLR = (cmd->NbData - 1U);
 800ae3a:	6be6      	ldr	r6, [r4, #60]	; 0x3c
 800ae3c:	3e01      	subs	r6, #1
 800ae3e:	6416      	str	r6, [r2, #64]	; 0x40
    }
  }

  if (cmd->InstructionMode != HAL_OSPI_INSTRUCTION_NONE)
 800ae40:	68e7      	ldr	r7, [r4, #12]
 800ae42:	69e6      	ldr	r6, [r4, #28]
 800ae44:	2f00      	cmp	r7, #0
 800ae46:	d06a      	beq.n	800af1e <HAL_OSPI_Command+0x1c2>
 800ae48:	f8d4 b014 	ldr.w	fp, [r4, #20]
 800ae4c:	f8d4 a010 	ldr.w	sl, [r4, #16]
  {
    if (cmd->AddressMode != HAL_OSPI_ADDRESS_NONE)
 800ae50:	2e00      	cmp	r6, #0
 800ae52:	d038      	beq.n	800aec6 <HAL_OSPI_Command+0x16a>
      if (cmd->DataMode != HAL_OSPI_DATA_NONE)
      {
        /* ---- Command with instruction, address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE  | OCTOSPI_CCR_IDTR  | OCTOSPI_CCR_ISIZE  |
 800ae54:	f8d3 e000 	ldr.w	lr, [r3]

  if (cmd->InstructionMode != HAL_OSPI_INSTRUCTION_NONE)
  {
    if (cmd->AddressMode != HAL_OSPI_ADDRESS_NONE)
    {
      if (cmd->DataMode != HAL_OSPI_DATA_NONE)
 800ae58:	f1bc 0f00 	cmp.w	ip, #0
 800ae5c:	d013      	beq.n	800ae86 <HAL_OSPI_Command+0x12a>
      {
        /* ---- Command with instruction, address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE  | OCTOSPI_CCR_IDTR  | OCTOSPI_CCR_ISIZE  |
 800ae5e:	ea4c 0707 	orr.w	r7, ip, r7
 800ae62:	433e      	orrs	r6, r7
 800ae64:	ea46 0b0b 	orr.w	fp, r6, fp
 800ae68:	6a67      	ldr	r7, [r4, #36]	; 0x24
 800ae6a:	6a26      	ldr	r6, [r4, #32]
 800ae6c:	ea4b 0a0a 	orr.w	sl, fp, sl
 800ae70:	ea4a 0707 	orr.w	r7, sl, r7
 800ae74:	4337      	orrs	r7, r6
 800ae76:	6c26      	ldr	r6, [r4, #64]	; 0x40
 800ae78:	433e      	orrs	r6, r7
 800ae7a:	4f4d      	ldr	r7, [pc, #308]	; (800afb0 <HAL_OSPI_Command+0x254>)
 800ae7c:	ea0e 0707 	and.w	r7, lr, r7
 800ae80:	4337      	orrs	r7, r6
 800ae82:	601f      	str	r7, [r3, #0]
 800ae84:	e01c      	b.n	800aec0 <HAL_OSPI_Command+0x164>
      else
      {
        /* ---- Command with instruction and address ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE  | OCTOSPI_CCR_IDTR  | OCTOSPI_CCR_ISIZE  |
 800ae86:	4337      	orrs	r7, r6
 800ae88:	ea47 0b0b 	orr.w	fp, r7, fp
 800ae8c:	6a66      	ldr	r6, [r4, #36]	; 0x24
 800ae8e:	ea4b 0a0a 	orr.w	sl, fp, sl
 800ae92:	ea4a 0a06 	orr.w	sl, sl, r6
 800ae96:	6a26      	ldr	r6, [r4, #32]
 800ae98:	f42e 5e7c 	bic.w	lr, lr, #16128	; 0x3f00
 800ae9c:	ea4a 0606 	orr.w	r6, sl, r6
 800aea0:	f02e 0e3f 	bic.w	lr, lr, #63	; 0x3f
 800aea4:	ea46 060e 	orr.w	r6, r6, lr
 800aea8:	601e      	str	r6, [r3, #0]
                                OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE),
                               (cmd->InstructionMode | cmd->InstructionDtrMode | cmd->InstructionSize |
                                cmd->AddressMode     | cmd->AddressDtrMode     | cmd->AddressSize));

        /* The DHQC bit is linked with DDTR bit which should be activated */
        if ((hospi->Init.DelayHoldQuarterCycle == HAL_OSPI_DHQC_ENABLE) &&
 800aeaa:	6aae      	ldr	r6, [r5, #40]	; 0x28
 800aeac:	f1b6 5f80 	cmp.w	r6, #268435456	; 0x10000000
 800aeb0:	d106      	bne.n	800aec0 <HAL_OSPI_Command+0x164>
 800aeb2:	6966      	ldr	r6, [r4, #20]
 800aeb4:	2e08      	cmp	r6, #8
            (cmd->InstructionDtrMode == HAL_OSPI_INSTRUCTION_DTR_ENABLE))
        {
          MODIFY_REG((*ccr_reg), OCTOSPI_CCR_DDTR, HAL_OSPI_DATA_DTR_ENABLE);
 800aeb6:	bf02      	ittt	eq
 800aeb8:	681e      	ldreq	r6, [r3, #0]
 800aeba:	f046 6600 	orreq.w	r6, r6, #134217728	; 0x8000000
 800aebe:	601e      	streq	r6, [r3, #0]
        }
      }

      /* Configure the IR register with the instruction value */
      *ir_reg = cmd->Instruction;
 800aec0:	68a3      	ldr	r3, [r4, #8]
 800aec2:	600b      	str	r3, [r1, #0]
 800aec4:	e04b      	b.n	800af5e <HAL_OSPI_Command+0x202>
      /* Configure the AR register with the address value */
      hospi->Instance->AR = cmd->Address;
    }
    else
    {
      if (cmd->DataMode != HAL_OSPI_DATA_NONE)
 800aec6:	f1bc 0f00 	cmp.w	ip, #0
 800aeca:	d010      	beq.n	800aeee <HAL_OSPI_Command+0x192>
      {
        /* ---- Command with instruction and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE | OCTOSPI_CCR_IDTR | OCTOSPI_CCR_ISIZE |
 800aecc:	ea4c 0707 	orr.w	r7, ip, r7
 800aed0:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800aed2:	681e      	ldr	r6, [r3, #0]
 800aed4:	ea47 0b0b 	orr.w	fp, r7, fp
 800aed8:	ea4b 0a0a 	orr.w	sl, fp, sl
 800aedc:	ea4a 0a02 	orr.w	sl, sl, r2
 800aee0:	f026 6270 	bic.w	r2, r6, #251658240	; 0xf000000
 800aee4:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 800aee8:	ea4a 0202 	orr.w	r2, sl, r2
 800aeec:	e013      	b.n	800af16 <HAL_OSPI_Command+0x1ba>
      else
      {
        /* ---- Command with only instruction ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE | OCTOSPI_CCR_IDTR | OCTOSPI_CCR_ISIZE),
 800aeee:	681a      	ldr	r2, [r3, #0]
 800aef0:	ea47 070b 	orr.w	r7, r7, fp
 800aef4:	ea47 0a0a 	orr.w	sl, r7, sl
 800aef8:	f022 073f 	bic.w	r7, r2, #63	; 0x3f
 800aefc:	ea4a 0707 	orr.w	r7, sl, r7
 800af00:	601f      	str	r7, [r3, #0]
                               (cmd->InstructionMode | cmd->InstructionDtrMode | cmd->InstructionSize));

        /* The DHQC bit is linked with DDTR bit which should be activated */
        if ((hospi->Init.DelayHoldQuarterCycle == HAL_OSPI_DHQC_ENABLE) &&
 800af02:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 800af04:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
 800af08:	d106      	bne.n	800af18 <HAL_OSPI_Command+0x1bc>
 800af0a:	6962      	ldr	r2, [r4, #20]
 800af0c:	2a08      	cmp	r2, #8
 800af0e:	d103      	bne.n	800af18 <HAL_OSPI_Command+0x1bc>
            (cmd->InstructionDtrMode == HAL_OSPI_INSTRUCTION_DTR_ENABLE))
        {
          MODIFY_REG((*ccr_reg), OCTOSPI_CCR_DDTR, HAL_OSPI_DATA_DTR_ENABLE);
 800af10:	681a      	ldr	r2, [r3, #0]
 800af12:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 800af16:	601a      	str	r2, [r3, #0]
        }
      }

      /* Configure the IR register with the instruction value */
      *ir_reg = cmd->Instruction;
 800af18:	68a3      	ldr	r3, [r4, #8]
 800af1a:	600b      	str	r3, [r1, #0]
 800af1c:	e028      	b.n	800af70 <HAL_OSPI_Command+0x214>

    }
  }
  else
  {
    if (cmd->AddressMode != HAL_OSPI_ADDRESS_NONE)
 800af1e:	b30e      	cbz	r6, 800af64 <HAL_OSPI_Command+0x208>
 800af20:	6a67      	ldr	r7, [r4, #36]	; 0x24
 800af22:	6a21      	ldr	r1, [r4, #32]
      if (cmd->DataMode != HAL_OSPI_DATA_NONE)
      {
        /* ---- Command with address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE |
 800af24:	f8d3 e000 	ldr.w	lr, [r3]
  }
  else
  {
    if (cmd->AddressMode != HAL_OSPI_ADDRESS_NONE)
    {
      if (cmd->DataMode != HAL_OSPI_DATA_NONE)
 800af28:	f1bc 0f00 	cmp.w	ip, #0
 800af2c:	d010      	beq.n	800af50 <HAL_OSPI_Command+0x1f4>
      {
        /* ---- Command with address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE |
 800af2e:	ea4c 0c06 	orr.w	ip, ip, r6
 800af32:	ea4c 0c07 	orr.w	ip, ip, r7
 800af36:	ea4c 0c01 	orr.w	ip, ip, r1
 800af3a:	6c21      	ldr	r1, [r4, #64]	; 0x40
 800af3c:	f02e 6e70 	bic.w	lr, lr, #251658240	; 0xf000000
 800af40:	ea4c 0101 	orr.w	r1, ip, r1
 800af44:	f42e 5e7c 	bic.w	lr, lr, #16128	; 0x3f00
 800af48:	ea41 010e 	orr.w	r1, r1, lr
 800af4c:	6019      	str	r1, [r3, #0]
 800af4e:	e006      	b.n	800af5e <HAL_OSPI_Command+0x202>
      else
      {
        /* ---- Command with only address ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE),
 800af50:	4337      	orrs	r7, r6
 800af52:	430f      	orrs	r7, r1
 800af54:	f42e 5e7c 	bic.w	lr, lr, #16128	; 0x3f00
 800af58:	ea47 070e 	orr.w	r7, r7, lr
 800af5c:	601f      	str	r7, [r3, #0]
                               (cmd->AddressMode | cmd->AddressDtrMode | cmd->AddressSize));
      }

      /* Configure the AR register with the instruction value */
      hospi->Instance->AR = cmd->Address;
 800af5e:	69a3      	ldr	r3, [r4, #24]
 800af60:	6493      	str	r3, [r2, #72]	; 0x48
 800af62:	e005      	b.n	800af70 <HAL_OSPI_Command+0x214>
    }
    else
    {
      /* ---- Invalid command configuration (no instruction, no address) ---- */
      status = HAL_ERROR;
      hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
 800af64:	2308      	movs	r3, #8
 800af66:	e000      	b.n	800af6a <HAL_OSPI_Command+0x20e>
    }
  }
  else
  {
    status = HAL_ERROR;
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 800af68:	2310      	movs	r3, #16
 800af6a:	64ab      	str	r3, [r5, #72]	; 0x48
      }
    }
  }
  else
  {
    status = HAL_ERROR;
 800af6c:	2001      	movs	r0, #1
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
  }

  /* Return function status */
  return status;
 800af6e:	e01c      	b.n	800afaa <HAL_OSPI_Command+0x24e>
      /* Configure the registers */
      status = OSPI_ConfigCmd(hospi, cmd);

      if (status == HAL_OK)
      {
        if (cmd->DataMode == HAL_OSPI_DATA_NONE)
 800af70:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800af72:	b95b      	cbnz	r3, 800af8c <HAL_OSPI_Command+0x230>
        {
          /* When there is no data phase, the transfer start as soon as the configuration is done
             so wait until TC flag is set to go back in idle state */
          status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_TC, SET, tickstart, Timeout);
 800af74:	4643      	mov	r3, r8
 800af76:	2201      	movs	r2, #1
 800af78:	f8cd 9000 	str.w	r9, [sp]
 800af7c:	2102      	movs	r1, #2
 800af7e:	4628      	mov	r0, r5
 800af80:	f7ff fe5a 	bl	800ac38 <OSPI_WaitFlagStateUntilTimeout>

          __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
 800af84:	682b      	ldr	r3, [r5, #0]
 800af86:	2202      	movs	r2, #2
 800af88:	625a      	str	r2, [r3, #36]	; 0x24
 800af8a:	e00e      	b.n	800afaa <HAL_OSPI_Command+0x24e>
        }
        else
        {
          /* Update the state */
          if (cmd->OperationType == HAL_OSPI_OPTYPE_COMMON_CFG)
 800af8c:	6823      	ldr	r3, [r4, #0]
 800af8e:	b143      	cbz	r3, 800afa2 <HAL_OSPI_Command+0x246>
          {
            hospi->State = HAL_OSPI_STATE_CMD_CFG;
          }
          else if (cmd->OperationType == HAL_OSPI_OPTYPE_READ_CFG)
 800af90:	2b01      	cmp	r3, #1
          {
            if (hospi->State == HAL_OSPI_STATE_WRITE_CMD_CFG)
 800af92:	6c6b      	ldr	r3, [r5, #68]	; 0x44
          /* Update the state */
          if (cmd->OperationType == HAL_OSPI_OPTYPE_COMMON_CFG)
          {
            hospi->State = HAL_OSPI_STATE_CMD_CFG;
          }
          else if (cmd->OperationType == HAL_OSPI_OPTYPE_READ_CFG)
 800af94:	d103      	bne.n	800af9e <HAL_OSPI_Command+0x242>
          {
            if (hospi->State == HAL_OSPI_STATE_WRITE_CMD_CFG)
 800af96:	2b24      	cmp	r3, #36	; 0x24
 800af98:	d003      	beq.n	800afa2 <HAL_OSPI_Command+0x246>
            {
              hospi->State = HAL_OSPI_STATE_CMD_CFG;
            }
            else
            {
              hospi->State = HAL_OSPI_STATE_READ_CMD_CFG;
 800af9a:	2314      	movs	r3, #20
 800af9c:	e004      	b.n	800afa8 <HAL_OSPI_Command+0x24c>
            }
          }
          else
          {
            if (hospi->State == HAL_OSPI_STATE_READ_CMD_CFG)
 800af9e:	2b14      	cmp	r3, #20
 800afa0:	d101      	bne.n	800afa6 <HAL_OSPI_Command+0x24a>
            {
              hospi->State = HAL_OSPI_STATE_CMD_CFG;
 800afa2:	2304      	movs	r3, #4
 800afa4:	e000      	b.n	800afa8 <HAL_OSPI_Command+0x24c>
            }
            else
            {
              hospi->State = HAL_OSPI_STATE_WRITE_CMD_CFG;
 800afa6:	2324      	movs	r3, #36	; 0x24
 800afa8:	646b      	str	r3, [r5, #68]	; 0x44
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
  }

  /* Return function status */
  return status;
}
 800afaa:	b003      	add	sp, #12
 800afac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800afb0:	f0ffc0c0 	.word	0xf0ffc0c0

0800afb4 <HAL_OSPI_Receive>:
  * @param  Timeout : Timeout duration
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_Receive(OSPI_HandleTypeDef *hospi, uint8_t *pData, uint32_t Timeout)
{
 800afb4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 800afb8:	4604      	mov	r4, r0
 800afba:	4688      	mov	r8, r1
 800afbc:	4617      	mov	r7, r2
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
 800afbe:	f7fc f825 	bl	800700c <HAL_GetTick>
  __IO uint32_t *data_reg = &hospi->Instance->DR;
 800afc2:	6825      	ldr	r5, [r4, #0]
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_Receive(OSPI_HandleTypeDef *hospi, uint8_t *pData, uint32_t Timeout)
{
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
 800afc4:	4606      	mov	r6, r0
  __IO uint32_t *data_reg = &hospi->Instance->DR;
  uint32_t addr_reg = hospi->Instance->AR;
 800afc6:	6caa      	ldr	r2, [r5, #72]	; 0x48
  uint32_t ir_reg = hospi->Instance->IR;
 800afc8:	f8d5 1110 	ldr.w	r1, [r5, #272]	; 0x110

  /* Check the data pointer allocation */
  if (pData == NULL)
 800afcc:	f1b8 0f00 	cmp.w	r8, #0
 800afd0:	d101      	bne.n	800afd6 <HAL_OSPI_Receive+0x22>
  {
    status = HAL_ERROR;
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
 800afd2:	2308      	movs	r3, #8
 800afd4:	e033      	b.n	800b03e <HAL_OSPI_Receive+0x8a>
  }
  else
  {
    /* Check the state */
    if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
 800afd6:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800afd8:	2b04      	cmp	r3, #4
 800afda:	d12f      	bne.n	800b03c <HAL_OSPI_Receive+0x88>
    {
      /* Configure counters and size */
      hospi->XferCount = READ_REG(hospi->Instance->DLR) + 1U;
 800afdc:	6c2b      	ldr	r3, [r5, #64]	; 0x40
      hospi->XferSize  = hospi->XferCount;
      hospi->pBuffPtr  = pData;
 800afde:	f8c4 8034 	str.w	r8, [r4, #52]	; 0x34
  {
    /* Check the state */
    if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
    {
      /* Configure counters and size */
      hospi->XferCount = READ_REG(hospi->Instance->DLR) + 1U;
 800afe2:	3301      	adds	r3, #1
 800afe4:	63e3      	str	r3, [r4, #60]	; 0x3c
      hospi->XferSize  = hospi->XferCount;
 800afe6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800afe8:	63a3      	str	r3, [r4, #56]	; 0x38
      hospi->pBuffPtr  = pData;

      /* Configure CR register with functional mode as indirect read */
      MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, OSPI_FUNCTIONAL_MODE_INDIRECT_READ);
 800afea:	682b      	ldr	r3, [r5, #0]
 800afec:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 800aff0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800aff4:	602b      	str	r3, [r5, #0]

      /* Trig the transfer by re-writing address or instruction register */
      if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
 800aff6:	68e3      	ldr	r3, [r4, #12]
 800aff8:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 800affc:	d004      	beq.n	800b008 <HAL_OSPI_Receive+0x54>
      {
        WRITE_REG(hospi->Instance->AR, addr_reg);
      }
      else
      {
        if (READ_BIT(hospi->Instance->CCR, OCTOSPI_CCR_ADMODE) != HAL_OSPI_ADDRESS_NONE)
 800affe:	f8d5 3100 	ldr.w	r3, [r5, #256]	; 0x100
 800b002:	f413 6fe0 	tst.w	r3, #1792	; 0x700
 800b006:	d001      	beq.n	800b00c <HAL_OSPI_Receive+0x58>
        {
          WRITE_REG(hospi->Instance->AR, addr_reg);
 800b008:	64aa      	str	r2, [r5, #72]	; 0x48
 800b00a:	e001      	b.n	800b010 <HAL_OSPI_Receive+0x5c>
        }
        else
        {
          WRITE_REG(hospi->Instance->IR, ir_reg);
 800b00c:	f8c5 1110 	str.w	r1, [r5, #272]	; 0x110
      }

      do
      {
        /* Wait till fifo threshold or transfer complete flags are set to read received data */
        status = OSPI_WaitFlagStateUntilTimeout(hospi, (HAL_OSPI_FLAG_FT | HAL_OSPI_FLAG_TC), SET, tickstart, Timeout);
 800b010:	9700      	str	r7, [sp, #0]
 800b012:	4633      	mov	r3, r6
 800b014:	2201      	movs	r2, #1
 800b016:	2106      	movs	r1, #6
 800b018:	4620      	mov	r0, r4
 800b01a:	f7ff fe0d 	bl	800ac38 <OSPI_WaitFlagStateUntilTimeout>

        if (status != HAL_OK)
 800b01e:	b9e8      	cbnz	r0, 800b05c <HAL_OSPI_Receive+0xa8>
        {
          break;
        }

        *hospi->pBuffPtr = *((__IO uint8_t *)data_reg);
 800b020:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800b022:	f895 2050 	ldrb.w	r2, [r5, #80]	; 0x50
 800b026:	701a      	strb	r2, [r3, #0]
        hospi->pBuffPtr++;
 800b028:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800b02a:	3301      	adds	r3, #1
 800b02c:	6363      	str	r3, [r4, #52]	; 0x34
        hospi->XferCount--;
 800b02e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800b030:	3b01      	subs	r3, #1
 800b032:	63e3      	str	r3, [r4, #60]	; 0x3c
      } while(hospi->XferCount > 0U);
 800b034:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800b036:	2b00      	cmp	r3, #0
 800b038:	d1ea      	bne.n	800b010 <HAL_OSPI_Receive+0x5c>
 800b03a:	e003      	b.n	800b044 <HAL_OSPI_Receive+0x90>
      }
    }
    else
    {
      status = HAL_ERROR;
      hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 800b03c:	2310      	movs	r3, #16
 800b03e:	64a3      	str	r3, [r4, #72]	; 0x48
        }
      }
    }
    else
    {
      status = HAL_ERROR;
 800b040:	2001      	movs	r0, #1
 800b042:	e00b      	b.n	800b05c <HAL_OSPI_Receive+0xa8>
      } while(hospi->XferCount > 0U);

      if (status == HAL_OK)
      {
        /* Wait till transfer complete flag is set to go back in idle state */
        status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_TC, SET, tickstart, Timeout);
 800b044:	9700      	str	r7, [sp, #0]
 800b046:	4633      	mov	r3, r6
 800b048:	2201      	movs	r2, #1
 800b04a:	2102      	movs	r1, #2
 800b04c:	4620      	mov	r0, r4
 800b04e:	f7ff fdf3 	bl	800ac38 <OSPI_WaitFlagStateUntilTimeout>

        if (status == HAL_OK)
 800b052:	b918      	cbnz	r0, 800b05c <HAL_OSPI_Receive+0xa8>
        {
          /* Clear transfer complete flag */
          __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
 800b054:	6822      	ldr	r2, [r4, #0]
 800b056:	2302      	movs	r3, #2
 800b058:	6253      	str	r3, [r2, #36]	; 0x24

          /* Update state */
          hospi->State = HAL_OSPI_STATE_READY;
 800b05a:	6463      	str	r3, [r4, #68]	; 0x44
    }
  }

  /* Return function status */
  return status;
}
 800b05c:	b002      	add	sp, #8
 800b05e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800b062 <HAL_OSPI_AutoPolling>:
  * @note   This function is used only in Automatic Polling Mode
  * @note   This function should not be used when the memory is in octal mode (see Errata Sheet)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_AutoPolling(OSPI_HandleTypeDef *hospi, OSPI_AutoPollingTypeDef *cfg, uint32_t Timeout)
{
 800b062:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 800b066:	4604      	mov	r4, r0
 800b068:	460d      	mov	r5, r1
 800b06a:	4617      	mov	r7, r2
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
 800b06c:	f7fb ffce 	bl	800700c <HAL_GetTick>
  uint32_t addr_reg = hospi->Instance->AR;
 800b070:	6823      	ldr	r3, [r4, #0]
 800b072:	f8d3 8048 	ldr.w	r8, [r3, #72]	; 0x48
  uint32_t ir_reg = hospi->Instance->IR;
 800b076:	f8d3 9110 	ldr.w	r9, [r3, #272]	; 0x110
  assert_param(IS_OSPI_AUTOMATIC_STOP   (cfg->AutomaticStop));
  assert_param(IS_OSPI_INTERVAL         (cfg->Interval));
  assert_param(IS_OSPI_STATUS_BYTES_SIZE(dlr_reg+1U));

  /* Check the state */
  if ((hospi->State == HAL_OSPI_STATE_CMD_CFG) && (cfg->AutomaticStop == HAL_OSPI_AUTOMATIC_STOP_ENABLE))
 800b07a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800b07c:	2b04      	cmp	r3, #4
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_AutoPolling(OSPI_HandleTypeDef *hospi, OSPI_AutoPollingTypeDef *cfg, uint32_t Timeout)
{
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
 800b07e:	4606      	mov	r6, r0
  assert_param(IS_OSPI_AUTOMATIC_STOP   (cfg->AutomaticStop));
  assert_param(IS_OSPI_INTERVAL         (cfg->Interval));
  assert_param(IS_OSPI_STATUS_BYTES_SIZE(dlr_reg+1U));

  /* Check the state */
  if ((hospi->State == HAL_OSPI_STATE_CMD_CFG) && (cfg->AutomaticStop == HAL_OSPI_AUTOMATIC_STOP_ENABLE))
 800b080:	d13c      	bne.n	800b0fc <HAL_OSPI_AutoPolling+0x9a>
 800b082:	68eb      	ldr	r3, [r5, #12]
 800b084:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800b088:	d138      	bne.n	800b0fc <HAL_OSPI_AutoPolling+0x9a>
  {
    /* Wait till busy flag is reset */
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, Timeout);
 800b08a:	4603      	mov	r3, r0
 800b08c:	9700      	str	r7, [sp, #0]
 800b08e:	2200      	movs	r2, #0
 800b090:	2120      	movs	r1, #32
 800b092:	4620      	mov	r0, r4
 800b094:	f7ff fdd0 	bl	800ac38 <OSPI_WaitFlagStateUntilTimeout>

    if (status == HAL_OK)
 800b098:	2800      	cmp	r0, #0
 800b09a:	d132      	bne.n	800b102 <HAL_OSPI_AutoPolling+0xa0>
    {
      /* Configure registers */
      WRITE_REG (hospi->Instance->PSMAR, cfg->Match);
 800b09c:	6823      	ldr	r3, [r4, #0]
 800b09e:	682a      	ldr	r2, [r5, #0]
 800b0a0:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
      WRITE_REG (hospi->Instance->PSMKR, cfg->Mask);
 800b0a4:	686a      	ldr	r2, [r5, #4]
 800b0a6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
      WRITE_REG (hospi->Instance->PIR,   cfg->Interval);
 800b0aa:	692a      	ldr	r2, [r5, #16]
 800b0ac:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
      MODIFY_REG(hospi->Instance->CR,    (OCTOSPI_CR_PMM | OCTOSPI_CR_APMS | OCTOSPI_CR_FMODE),
 800b0b0:	68a8      	ldr	r0, [r5, #8]
 800b0b2:	68e9      	ldr	r1, [r5, #12]
 800b0b4:	681a      	ldr	r2, [r3, #0]
 800b0b6:	4301      	orrs	r1, r0
 800b0b8:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
 800b0bc:	f022 5243 	bic.w	r2, r2, #817889280	; 0x30c00000
 800b0c0:	430a      	orrs	r2, r1
 800b0c2:	601a      	str	r2, [r3, #0]
                 (cfg->MatchMode | cfg->AutomaticStop | OSPI_FUNCTIONAL_MODE_AUTO_POLLING));

      /* Trig the transfer by re-writing address or instruction register */
      if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
 800b0c4:	68e2      	ldr	r2, [r4, #12]
 800b0c6:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
 800b0ca:	d004      	beq.n	800b0d6 <HAL_OSPI_AutoPolling+0x74>
      {
        WRITE_REG(hospi->Instance->AR, addr_reg);
      }
      else
      {
        if (READ_BIT(hospi->Instance->CCR, OCTOSPI_CCR_ADMODE) != HAL_OSPI_ADDRESS_NONE)
 800b0cc:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 800b0d0:	f412 6fe0 	tst.w	r2, #1792	; 0x700
 800b0d4:	d002      	beq.n	800b0dc <HAL_OSPI_AutoPolling+0x7a>
        {
          WRITE_REG(hospi->Instance->AR, addr_reg);
 800b0d6:	f8c3 8048 	str.w	r8, [r3, #72]	; 0x48
 800b0da:	e001      	b.n	800b0e0 <HAL_OSPI_AutoPolling+0x7e>
        }
        else
        {
          WRITE_REG(hospi->Instance->IR, ir_reg);
 800b0dc:	f8c3 9110 	str.w	r9, [r3, #272]	; 0x110
        }
      }

      /* Wait till status match flag is set to go back in idle state */
      status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_SM, SET, tickstart, Timeout);
 800b0e0:	9700      	str	r7, [sp, #0]
 800b0e2:	4633      	mov	r3, r6
 800b0e4:	2201      	movs	r2, #1
 800b0e6:	2108      	movs	r1, #8
 800b0e8:	4620      	mov	r0, r4
 800b0ea:	f7ff fda5 	bl	800ac38 <OSPI_WaitFlagStateUntilTimeout>

      if (status == HAL_OK)
 800b0ee:	b940      	cbnz	r0, 800b102 <HAL_OSPI_AutoPolling+0xa0>
      {
        /* Clear status match flag */
        __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_SM);
 800b0f0:	6823      	ldr	r3, [r4, #0]
 800b0f2:	2208      	movs	r2, #8
 800b0f4:	625a      	str	r2, [r3, #36]	; 0x24

        /* Update state */
        hospi->State = HAL_OSPI_STATE_READY;
 800b0f6:	2302      	movs	r3, #2
 800b0f8:	6463      	str	r3, [r4, #68]	; 0x44
 800b0fa:	e002      	b.n	800b102 <HAL_OSPI_AutoPolling+0xa0>
    }
  }
  else
  {
    status = HAL_ERROR;
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 800b0fc:	2310      	movs	r3, #16
 800b0fe:	64a3      	str	r3, [r4, #72]	; 0x48
      }
    }
  }
  else
  {
    status = HAL_ERROR;
 800b100:	2001      	movs	r0, #1
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
  }

  /* Return function status */
  return status;
}
 800b102:	b003      	add	sp, #12
 800b104:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0800b108 <HAL_OSPI_AutoPolling_IT>:
  * @note   This function is used only in Automatic Polling Mode
  * @note   This function should not be used when the memory is in octal mode (see Errata Sheet)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_AutoPolling_IT(OSPI_HandleTypeDef *hospi, OSPI_AutoPollingTypeDef *cfg)
{
 800b108:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800b10a:	4604      	mov	r4, r0
 800b10c:	460f      	mov	r7, r1
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
 800b10e:	f7fb ff7d 	bl	800700c <HAL_GetTick>
  uint32_t addr_reg = hospi->Instance->AR;
 800b112:	6822      	ldr	r2, [r4, #0]
 800b114:	6c95      	ldr	r5, [r2, #72]	; 0x48
  uint32_t ir_reg = hospi->Instance->IR;
 800b116:	f8d2 6110 	ldr.w	r6, [r2, #272]	; 0x110
  assert_param(IS_OSPI_AUTOMATIC_STOP   (cfg->AutomaticStop));
  assert_param(IS_OSPI_INTERVAL         (cfg->Interval));
  assert_param(IS_OSPI_STATUS_BYTES_SIZE(dlr_reg+1U));

  /* Check the state */
  if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
 800b11a:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800b11c:	2a04      	cmp	r2, #4
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_AutoPolling_IT(OSPI_HandleTypeDef *hospi, OSPI_AutoPollingTypeDef *cfg)
{
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
 800b11e:	4603      	mov	r3, r0
  assert_param(IS_OSPI_AUTOMATIC_STOP   (cfg->AutomaticStop));
  assert_param(IS_OSPI_INTERVAL         (cfg->Interval));
  assert_param(IS_OSPI_STATUS_BYTES_SIZE(dlr_reg+1U));

  /* Check the state */
  if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
 800b120:	d133      	bne.n	800b18a <HAL_OSPI_AutoPolling_IT+0x82>
  {
    /* Wait till busy flag is reset */
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);
 800b122:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 800b124:	9200      	str	r2, [sp, #0]
 800b126:	2120      	movs	r1, #32
 800b128:	2200      	movs	r2, #0
 800b12a:	4620      	mov	r0, r4
 800b12c:	f7ff fd84 	bl	800ac38 <OSPI_WaitFlagStateUntilTimeout>

    if (status == HAL_OK)
 800b130:	bb70      	cbnz	r0, 800b190 <HAL_OSPI_AutoPolling_IT+0x88>
    {
      /* Configure registers */
      WRITE_REG (hospi->Instance->PSMAR, cfg->Match);
 800b132:	6823      	ldr	r3, [r4, #0]
 800b134:	683a      	ldr	r2, [r7, #0]
 800b136:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
      WRITE_REG (hospi->Instance->PSMKR, cfg->Mask);
 800b13a:	687a      	ldr	r2, [r7, #4]
 800b13c:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
      WRITE_REG (hospi->Instance->PIR,   cfg->Interval);
 800b140:	693a      	ldr	r2, [r7, #16]
 800b142:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
      MODIFY_REG(hospi->Instance->CR,    (OCTOSPI_CR_PMM | OCTOSPI_CR_APMS | OCTOSPI_CR_FMODE),
 800b146:	f8d7 e008 	ldr.w	lr, [r7, #8]
 800b14a:	68f9      	ldr	r1, [r7, #12]
 800b14c:	681a      	ldr	r2, [r3, #0]
 800b14e:	ea4e 0101 	orr.w	r1, lr, r1
 800b152:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
 800b156:	f022 5243 	bic.w	r2, r2, #817889280	; 0x30c00000
 800b15a:	430a      	orrs	r2, r1
 800b15c:	601a      	str	r2, [r3, #0]
                 (cfg->MatchMode | cfg->AutomaticStop | OSPI_FUNCTIONAL_MODE_AUTO_POLLING));

      /* Clear flags related to interrupt */
      __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TE | HAL_OSPI_FLAG_SM);
 800b15e:	2209      	movs	r2, #9
 800b160:	625a      	str	r2, [r3, #36]	; 0x24

      /* Update state */
      hospi->State = HAL_OSPI_STATE_BUSY_AUTO_POLLING;
 800b162:	2248      	movs	r2, #72	; 0x48
 800b164:	6462      	str	r2, [r4, #68]	; 0x44

      /* Enable the status match and transfer error interrupts */
      __HAL_OSPI_ENABLE_IT(hospi, HAL_OSPI_IT_SM | HAL_OSPI_IT_TE);
 800b166:	681a      	ldr	r2, [r3, #0]
 800b168:	f442 2210 	orr.w	r2, r2, #589824	; 0x90000
 800b16c:	601a      	str	r2, [r3, #0]

      /* Trig the transfer by re-writing address or instruction register */
      if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
 800b16e:	68e2      	ldr	r2, [r4, #12]
 800b170:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
 800b174:	d004      	beq.n	800b180 <HAL_OSPI_AutoPolling_IT+0x78>
      {
        WRITE_REG(hospi->Instance->AR, addr_reg);
      }
      else
      {
        if (READ_BIT(hospi->Instance->CCR, OCTOSPI_CCR_ADMODE) != HAL_OSPI_ADDRESS_NONE)
 800b176:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 800b17a:	f412 6fe0 	tst.w	r2, #1792	; 0x700
 800b17e:	d001      	beq.n	800b184 <HAL_OSPI_AutoPolling_IT+0x7c>
        {
          WRITE_REG(hospi->Instance->AR, addr_reg);
 800b180:	649d      	str	r5, [r3, #72]	; 0x48
 800b182:	e005      	b.n	800b190 <HAL_OSPI_AutoPolling_IT+0x88>
        }
        else
        {
          WRITE_REG(hospi->Instance->IR, ir_reg);
 800b184:	f8c3 6110 	str.w	r6, [r3, #272]	; 0x110
 800b188:	e002      	b.n	800b190 <HAL_OSPI_AutoPolling_IT+0x88>
    }
  }
  else
  {
    status = HAL_ERROR;
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 800b18a:	2310      	movs	r3, #16
 800b18c:	64a3      	str	r3, [r4, #72]	; 0x48
      }
    }
  }
  else
  {
    status = HAL_ERROR;
 800b18e:	2001      	movs	r0, #1
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
  }

  /* Return function status */
  return status;
}
 800b190:	b003      	add	sp, #12
 800b192:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800b194 <HAL_OSPI_MemoryMapped>:
  * @param  cfg   : structure that contains the memory mapped configuration information.
  * @note   This function is used only in Memory mapped Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_MemoryMapped(OSPI_HandleTypeDef *hospi, OSPI_MemoryMappedTypeDef *cfg)
{
 800b194:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800b196:	4604      	mov	r4, r0
 800b198:	460d      	mov	r5, r1
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
 800b19a:	f7fb ff37 	bl	800700c <HAL_GetTick>

  /* Check the parameters of the memory-mapped configuration structure */
  assert_param(IS_OSPI_TIMEOUT_ACTIVATION(cfg->TimeOutActivation));

  /* Check the state */
  if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
 800b19e:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800b1a0:	2a04      	cmp	r2, #4
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_MemoryMapped(OSPI_HandleTypeDef *hospi, OSPI_MemoryMappedTypeDef *cfg)
{
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
 800b1a2:	4603      	mov	r3, r0

  /* Check the parameters of the memory-mapped configuration structure */
  assert_param(IS_OSPI_TIMEOUT_ACTIVATION(cfg->TimeOutActivation));

  /* Check the state */
  if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
 800b1a4:	d120      	bne.n	800b1e8 <HAL_OSPI_MemoryMapped+0x54>
  {
    /* Wait till busy flag is reset */
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);
 800b1a6:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 800b1a8:	9200      	str	r2, [sp, #0]
 800b1aa:	2120      	movs	r1, #32
 800b1ac:	2200      	movs	r2, #0
 800b1ae:	4620      	mov	r0, r4
 800b1b0:	f7ff fd42 	bl	800ac38 <OSPI_WaitFlagStateUntilTimeout>

    if (status == HAL_OK)
 800b1b4:	b9d8      	cbnz	r0, 800b1ee <HAL_OSPI_MemoryMapped+0x5a>
    {
      /* Update state */
      hospi->State = HAL_OSPI_STATE_BUSY_MEM_MAPPED;

      if (cfg->TimeOutActivation == HAL_OSPI_TIMEOUT_COUNTER_ENABLE)
 800b1b6:	682a      	ldr	r2, [r5, #0]
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);

    if (status == HAL_OK)
    {
      /* Update state */
      hospi->State = HAL_OSPI_STATE_BUSY_MEM_MAPPED;
 800b1b8:	2388      	movs	r3, #136	; 0x88

      if (cfg->TimeOutActivation == HAL_OSPI_TIMEOUT_COUNTER_ENABLE)
 800b1ba:	2a08      	cmp	r2, #8
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);

    if (status == HAL_OK)
    {
      /* Update state */
      hospi->State = HAL_OSPI_STATE_BUSY_MEM_MAPPED;
 800b1bc:	6463      	str	r3, [r4, #68]	; 0x44
 800b1be:	6823      	ldr	r3, [r4, #0]

      if (cfg->TimeOutActivation == HAL_OSPI_TIMEOUT_COUNTER_ENABLE)
 800b1c0:	d108      	bne.n	800b1d4 <HAL_OSPI_MemoryMapped+0x40>
      {
        assert_param(IS_OSPI_TIMEOUT_PERIOD(cfg->TimeOutPeriod));

        /* Configure register */
        WRITE_REG(hospi->Instance->LPTR, cfg->TimeOutPeriod);
 800b1c2:	6869      	ldr	r1, [r5, #4]
 800b1c4:	f8c3 1130 	str.w	r1, [r3, #304]	; 0x130

        /* Clear flags related to interrupt */
        __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TO);
 800b1c8:	2110      	movs	r1, #16
 800b1ca:	6259      	str	r1, [r3, #36]	; 0x24

        /* Enable the timeout interrupt */
        __HAL_OSPI_ENABLE_IT(hospi, HAL_OSPI_IT_TO);
 800b1cc:	6819      	ldr	r1, [r3, #0]
 800b1ce:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800b1d2:	6019      	str	r1, [r3, #0]
      }

      /* Configure CR register with functional mode as memory-mapped */
      MODIFY_REG(hospi->Instance->CR, (OCTOSPI_CR_TCEN | OCTOSPI_CR_FMODE),
 800b1d4:	6819      	ldr	r1, [r3, #0]
 800b1d6:	f021 5140 	bic.w	r1, r1, #805306368	; 0x30000000
 800b1da:	f021 0108 	bic.w	r1, r1, #8
 800b1de:	f042 5240 	orr.w	r2, r2, #805306368	; 0x30000000
 800b1e2:	430a      	orrs	r2, r1
 800b1e4:	601a      	str	r2, [r3, #0]
 800b1e6:	e002      	b.n	800b1ee <HAL_OSPI_MemoryMapped+0x5a>
    }
  }
  else
  {
    status = HAL_ERROR;
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 800b1e8:	2310      	movs	r3, #16
 800b1ea:	64a3      	str	r3, [r4, #72]	; 0x48
                 (cfg->TimeOutActivation | OSPI_FUNCTIONAL_MODE_MEMORY_MAPPED));
    }
  }
  else
  {
    status = HAL_ERROR;
 800b1ec:	2001      	movs	r0, #1
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
  }

  /* Return function status */
  return status;
}
 800b1ee:	b003      	add	sp, #12
 800b1f0:	bd30      	pop	{r4, r5, pc}

0800b1f2 <HAL_OSPI_SetFifoThreshold>:
HAL_StatusTypeDef HAL_OSPI_SetFifoThreshold(OSPI_HandleTypeDef *hospi, uint32_t Threshold)
{
  HAL_StatusTypeDef status = HAL_OK;

  /* Check the state */
  if ((hospi->State & OSPI_BUSY_STATE_MASK) == 0U)
 800b1f2:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800b1f4:	f013 0308 	ands.w	r3, r3, #8
 800b1f8:	d10a      	bne.n	800b210 <HAL_OSPI_SetFifoThreshold+0x1e>
  {
    /* Synchronize initialization structure with the new fifo threshold value */
    hospi->Init.FifoThreshold = Threshold;
 800b1fa:	6041      	str	r1, [r0, #4]

    /* Configure new fifo threshold */
    MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FTHRES, ((hospi->Init.FifoThreshold-1U) << OCTOSPI_CR_FTHRES_Pos));
 800b1fc:	6800      	ldr	r0, [r0, #0]
 800b1fe:	6802      	ldr	r2, [r0, #0]
 800b200:	3901      	subs	r1, #1
 800b202:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
 800b206:	ea42 2101 	orr.w	r1, r2, r1, lsl #8
 800b20a:	6001      	str	r1, [r0, #0]
  * @param  Threshold : Threshold of the Fifo.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_SetFifoThreshold(OSPI_HandleTypeDef *hospi, uint32_t Threshold)
{
  HAL_StatusTypeDef status = HAL_OK;
 800b20c:	4618      	mov	r0, r3
 800b20e:	4770      	bx	lr

  }
  else
  {
    status = HAL_ERROR;
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 800b210:	2310      	movs	r3, #16
 800b212:	6483      	str	r3, [r0, #72]	; 0x48
    MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FTHRES, ((hospi->Init.FifoThreshold-1U) << OCTOSPI_CR_FTHRES_Pos));

  }
  else
  {
    status = HAL_ERROR;
 800b214:	2001      	movs	r0, #1
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
  }

  /* Return function status */
  return status;
}
 800b216:	4770      	bx	lr

0800b218 <HAL_OSPI_GetFifoThreshold>:
  * @param  hospi : OSPI handle.
  * @retval Fifo threshold
  */
uint32_t HAL_OSPI_GetFifoThreshold(OSPI_HandleTypeDef *hospi)
{
  return ((READ_BIT(hospi->Instance->CR, OCTOSPI_CR_FTHRES) >> OCTOSPI_CR_FTHRES_Pos) + 1U);
 800b218:	6803      	ldr	r3, [r0, #0]
 800b21a:	6818      	ldr	r0, [r3, #0]
 800b21c:	f3c0 2004 	ubfx	r0, r0, #8, #5
}
 800b220:	3001      	adds	r0, #1
 800b222:	4770      	bx	lr

0800b224 <HAL_OSPI_SetTimeout>:
  * @param  Timeout : Timeout for the memory access.
  * @retval None
  */
HAL_StatusTypeDef HAL_OSPI_SetTimeout(OSPI_HandleTypeDef *hospi, uint32_t Timeout)
{
  hospi->Timeout = Timeout;
 800b224:	64c1      	str	r1, [r0, #76]	; 0x4c
  return HAL_OK;
}
 800b226:	2000      	movs	r0, #0
 800b228:	4770      	bx	lr

0800b22a <HAL_OSPI_GetError>:
* @param  hospi : OSPI handle
* @retval OSPI Error Code
*/
uint32_t HAL_OSPI_GetError(OSPI_HandleTypeDef *hospi)
{
  return hospi->ErrorCode;
 800b22a:	6c80      	ldr	r0, [r0, #72]	; 0x48
}
 800b22c:	4770      	bx	lr

0800b22e <HAL_OSPI_GetState>:
  * @retval HAL state
  */
uint32_t HAL_OSPI_GetState(OSPI_HandleTypeDef *hospi)
{
  /* Return OSPI handle state */
  return hospi->State;
 800b22e:	6c40      	ldr	r0, [r0, #68]	; 0x44
}
 800b230:	4770      	bx	lr
	...

0800b234 <HAL_OSPIM_Config>:
  * @param  cfg     : Configuration of the IO Manager for the instance
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPIM_Config(OSPI_HandleTypeDef *hospi, OSPIM_CfgTypeDef *cfg, uint32_t Timeout)
{
 800b234:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    other_instance = 1U;
  }
  else
  {
    instance = 1U;
    other_instance = 0U;
 800b238:	4bb7      	ldr	r3, [pc, #732]	; (800b518 <HAL_OSPIM_Config+0x2e4>)
  assert_param(IS_OSPIM_IO_PORT(cfg->IOHighPort));
#if   defined (OCTOSPIM_CR_MUXEN)
  assert_param(IS_OSPIM_REQ2ACKTIME(cfg->Req2AckTime));
#endif

  if (hospi->Instance == OCTOSPI1)
 800b23a:	6802      	ldr	r2, [r0, #0]
    {
#if   defined (OCTOSPIM_CR_MUXEN)
      if ((OCTOSPIM->CR & OCTOSPIM_CR_MUXEN) == 0U)
      {
#endif
        value = (OCTOSPIM_PCR_CLKSRC | OCTOSPIM_PCR_DQSSRC | OCTOSPIM_PCR_NCSSRC | OCTOSPIM_PCR_IOLSRC_1 | OCTOSPIM_PCR_IOHSRC_1);
 800b23c:	f8df 92e4 	ldr.w	r9, [pc, #740]	; 800b524 <HAL_OSPIM_Config+0x2f0>
    other_instance = 1U;
  }
  else
  {
    instance = 1U;
    other_instance = 0U;
 800b240:	429a      	cmp	r2, r3
  }

  /**************** Get current configuration of the instances ****************/
  for (index = 0U; index < OSPI_NB_INSTANCE; index++)
 800b242:	f04f 0400 	mov.w	r4, #0
  * @param  cfg     : Configuration of the IO Manager for the instance
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPIM_Config(OSPI_HandleTypeDef *hospi, OSPIM_CfgTypeDef *cfg, uint32_t Timeout)
{
 800b246:	b08a      	sub	sp, #40	; 0x28
    other_instance = 1U;
  }
  else
  {
    instance = 1U;
    other_instance = 0U;
 800b248:	bf0b      	itete	eq
 800b24a:	2701      	moveq	r7, #1
 800b24c:	2700      	movne	r7, #0
 800b24e:	2500      	moveq	r5, #0
 800b250:	2501      	movne	r5, #1
 800b252:	ab01      	add	r3, sp, #4
    status = HAL_ERROR;
  }
  else
  {
    /* Initialize the structure */
    cfg->ClkPort    = 0U;
 800b254:	46a6      	mov	lr, r4
 800b256:	46a0      	mov	r8, r4
  }

  /**************** Get current configuration of the instances ****************/
  for (index = 0U; index < OSPI_NB_INSTANCE; index++)
  {
    if (OSPIM_GetConfig(index+1U, &(IOM_cfg[index])) != HAL_OK)
 800b258:	3401      	adds	r4, #1
 800b25a:	b2e4      	uxtb	r4, r4
    {
#if   defined (OCTOSPIM_CR_MUXEN)
      if ((OCTOSPIM->CR & OCTOSPIM_CR_MUXEN) == 0U)
      {
#endif
        value = (OCTOSPIM_PCR_CLKSRC | OCTOSPIM_PCR_DQSSRC | OCTOSPIM_PCR_NCSSRC | OCTOSPIM_PCR_IOLSRC_1 | OCTOSPIM_PCR_IOHSRC_1);
 800b25c:	2c02      	cmp	r4, #2
    status = HAL_ERROR;
  }
  else
  {
    /* Initialize the structure */
    cfg->ClkPort    = 0U;
 800b25e:	f843 ec04 	str.w	lr, [r3, #-4]
    cfg->DQSPort    = 0U;
 800b262:	f8c3 e000 	str.w	lr, [r3]
    cfg->NCSPort    = 0U;
 800b266:	f8c3 e004 	str.w	lr, [r3, #4]
    cfg->IOLowPort  = 0U;
 800b26a:	f8c3 e008 	str.w	lr, [r3, #8]
    {
#if   defined (OCTOSPIM_CR_MUXEN)
      if ((OCTOSPIM->CR & OCTOSPIM_CR_MUXEN) == 0U)
      {
#endif
        value = (OCTOSPIM_PCR_CLKSRC | OCTOSPIM_PCR_DQSSRC | OCTOSPIM_PCR_NCSSRC | OCTOSPIM_PCR_IOLSRC_1 | OCTOSPIM_PCR_IOHSRC_1);
 800b26e:	bf14      	ite	ne
 800b270:	2600      	movne	r6, #0
 800b272:	464e      	moveq	r6, r9
    /* Initialize the structure */
    cfg->ClkPort    = 0U;
    cfg->DQSPort    = 0U;
    cfg->NCSPort    = 0U;
    cfg->IOLowPort  = 0U;
    cfg->IOHighPort = 0U;
 800b274:	f8c3 800c 	str.w	r8, [r3, #12]
 800b278:	2001      	movs	r0, #1
    }

    /* Get the information about the instance */
    for (index = 0U; index < OSPI_IOM_NB_PORTS; index ++)
    {
      reg = OCTOSPIM->PCR[index];
 800b27a:	ea4f 0c80 	mov.w	ip, r0, lsl #2
 800b27e:	4aa7      	ldr	r2, [pc, #668]	; (800b51c <HAL_OSPIM_Config+0x2e8>)
 800b280:	f852 200c 	ldr.w	r2, [r2, ip]

      if ((reg & OCTOSPIM_PCR_CLKEN) != 0U)
 800b284:	f012 0f01 	tst.w	r2, #1
 800b288:	d006      	beq.n	800b298 <HAL_OSPIM_Config+0x64>
      {
        /* The clock is enabled on this port */
        if ((reg & OCTOSPIM_PCR_CLKSRC) == (value & OCTOSPIM_PCR_CLKSRC))
 800b28a:	ea82 0c06 	eor.w	ip, r2, r6
 800b28e:	f01c 0f02 	tst.w	ip, #2
        {
          /* The clock correspond to the instance passed as parameter */
          cfg->ClkPort = index+1U;
 800b292:	bf08      	it	eq
 800b294:	f843 0c04 	streq.w	r0, [r3, #-4]
        }
      }

      if ((reg & OCTOSPIM_PCR_DQSEN) != 0U)
 800b298:	f012 0f10 	tst.w	r2, #16
 800b29c:	d005      	beq.n	800b2aa <HAL_OSPIM_Config+0x76>
      {
        /* The DQS is enabled on this port */
        if ((reg & OCTOSPIM_PCR_DQSSRC) == (value & OCTOSPIM_PCR_DQSSRC))
 800b29e:	ea82 0c06 	eor.w	ip, r2, r6
 800b2a2:	f01c 0f20 	tst.w	ip, #32
        {
          /* The DQS correspond to the instance passed as parameter */
          cfg->DQSPort = index+1U;
 800b2a6:	bf08      	it	eq
 800b2a8:	6018      	streq	r0, [r3, #0]
        }
      }

      if ((reg & OCTOSPIM_PCR_NCSEN) != 0U)
 800b2aa:	f412 7f80 	tst.w	r2, #256	; 0x100
 800b2ae:	d005      	beq.n	800b2bc <HAL_OSPIM_Config+0x88>
      {
        /* The nCS is enabled on this port */
        if ((reg & OCTOSPIM_PCR_NCSSRC) == (value & OCTOSPIM_PCR_NCSSRC))
 800b2b0:	ea82 0c06 	eor.w	ip, r2, r6
 800b2b4:	f41c 7f00 	tst.w	ip, #512	; 0x200
        {
          /* The nCS correspond to the instance passed as parameter */
          cfg->NCSPort = index+1U;
 800b2b8:	bf08      	it	eq
 800b2ba:	6058      	streq	r0, [r3, #4]
        }
      }

      if ((reg & OCTOSPIM_PCR_IOLEN) != 0U)
 800b2bc:	f412 3f80 	tst.w	r2, #65536	; 0x10000
 800b2c0:	d00d      	beq.n	800b2de <HAL_OSPIM_Config+0xaa>
      {
        /* The IO Low is enabled on this port */
        if ((reg & OCTOSPIM_PCR_IOLSRC_1) == (value & OCTOSPIM_PCR_IOLSRC_1))
 800b2c2:	ea82 0c06 	eor.w	ip, r2, r6
 800b2c6:	f41c 2f80 	tst.w	ip, #262144	; 0x40000
 800b2ca:	d108      	bne.n	800b2de <HAL_OSPIM_Config+0xaa>
        {
          /* The IO Low correspond to the instance passed as parameter */
          if ((reg & OCTOSPIM_PCR_IOLSRC_0) == 0U)
 800b2cc:	f412 3f00 	tst.w	r2, #131072	; 0x20000
          {
            cfg->IOLowPort = (OCTOSPIM_PCR_IOLEN | (index+1U));
 800b2d0:	bf0c      	ite	eq
 800b2d2:	f440 3c80 	orreq.w	ip, r0, #65536	; 0x10000
          }
          else
          {
            cfg->IOLowPort = (OCTOSPIM_PCR_IOHEN | (index+1U));
 800b2d6:	f040 7c80 	orrne.w	ip, r0, #16777216	; 0x1000000
 800b2da:	f8c3 c008 	str.w	ip, [r3, #8]
          }
        }
      }

      if ((reg & OCTOSPIM_PCR_IOHEN) != 0U)
 800b2de:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
 800b2e2:	d00b      	beq.n	800b2fc <HAL_OSPIM_Config+0xc8>
      {
        /* The IO High is enabled on this port */
        if ((reg & OCTOSPIM_PCR_IOHSRC_1) == (value & OCTOSPIM_PCR_IOHSRC_1))
 800b2e4:	ea82 0c06 	eor.w	ip, r2, r6
 800b2e8:	f01c 6f80 	tst.w	ip, #67108864	; 0x4000000
 800b2ec:	d106      	bne.n	800b2fc <HAL_OSPIM_Config+0xc8>
        {
          /* The IO High correspond to the instance passed as parameter */
          if ((reg & OCTOSPIM_PCR_IOHSRC_0) == 0U)
 800b2ee:	0192      	lsls	r2, r2, #6
          {
            cfg->IOHighPort = (OCTOSPIM_PCR_IOLEN | (index+1U));
 800b2f0:	bf54      	ite	pl
 800b2f2:	f440 3280 	orrpl.w	r2, r0, #65536	; 0x10000
          }
          else
          {
            cfg->IOHighPort = (OCTOSPIM_PCR_IOHEN | (index+1U));
 800b2f6:	f040 7280 	orrmi.w	r2, r0, #16777216	; 0x1000000
 800b2fa:	60da      	str	r2, [r3, #12]
 800b2fc:	3001      	adds	r0, #1
      }
#endif
    }

    /* Get the information about the instance */
    for (index = 0U; index < OSPI_IOM_NB_PORTS; index ++)
 800b2fe:	2803      	cmp	r0, #3
 800b300:	d1bb      	bne.n	800b27a <HAL_OSPIM_Config+0x46>
    instance = 1U;
    other_instance = 0U;
  }

  /**************** Get current configuration of the instances ****************/
  for (index = 0U; index < OSPI_NB_INSTANCE; index++)
 800b302:	2c02      	cmp	r4, #2
 800b304:	f103 0314 	add.w	r3, r3, #20
 800b308:	d1a6      	bne.n	800b258 <HAL_OSPIM_Config+0x24>
  }

  if (status == HAL_OK)
  {
    /********** Disable both OctoSPI to configure OctoSPI IO Manager **********/
    if ((OCTOSPI1->CR & OCTOSPI_CR_EN) != 0U)
 800b30a:	4b83      	ldr	r3, [pc, #524]	; (800b518 <HAL_OSPIM_Config+0x2e4>)
 800b30c:	4883      	ldr	r0, [pc, #524]	; (800b51c <HAL_OSPIM_Config+0x2e8>)
 800b30e:	681c      	ldr	r4, [r3, #0]
 800b310:	f014 0401 	ands.w	r4, r4, #1
    {
      CLEAR_BIT(OCTOSPI1->CR, OCTOSPI_CR_EN);
 800b314:	bf1e      	ittt	ne
 800b316:	681a      	ldrne	r2, [r3, #0]
 800b318:	f022 0201 	bicne.w	r2, r2, #1
 800b31c:	601a      	strne	r2, [r3, #0]
      ospi_enabled |= 0x1U;
    }
    if ((OCTOSPI2->CR & OCTOSPI_CR_EN) != 0U)
 800b31e:	4b80      	ldr	r3, [pc, #512]	; (800b520 <HAL_OSPIM_Config+0x2ec>)
 800b320:	681a      	ldr	r2, [r3, #0]
  {
    /********** Disable both OctoSPI to configure OctoSPI IO Manager **********/
    if ((OCTOSPI1->CR & OCTOSPI_CR_EN) != 0U)
    {
      CLEAR_BIT(OCTOSPI1->CR, OCTOSPI_CR_EN);
      ospi_enabled |= 0x1U;
 800b322:	bf18      	it	ne
 800b324:	2401      	movne	r4, #1
    }
    if ((OCTOSPI2->CR & OCTOSPI_CR_EN) != 0U)
 800b326:	07d6      	lsls	r6, r2, #31
    {
      CLEAR_BIT(OCTOSPI2->CR, OCTOSPI_CR_EN);
 800b328:	bf42      	ittt	mi
 800b32a:	681a      	ldrmi	r2, [r3, #0]
 800b32c:	f022 0201 	bicmi.w	r2, r2, #1
 800b330:	601a      	strmi	r2, [r3, #0]
      ospi_enabled |= 0x2U;
    }

    /***************** Deactivation of previous configuration *****************/
    CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[instance].NCSPort-1U)], OCTOSPIM_PCR_NCSEN);
 800b332:	aa0a      	add	r2, sp, #40	; 0x28
 800b334:	f04f 0314 	mov.w	r3, #20
 800b338:	fb03 2305 	mla	r3, r3, r5, r2
      ospi_enabled |= 0x1U;
    }
    if ((OCTOSPI2->CR & OCTOSPI_CR_EN) != 0U)
    {
      CLEAR_BIT(OCTOSPI2->CR, OCTOSPI_CR_EN);
      ospi_enabled |= 0x2U;
 800b33c:	bf48      	it	mi
 800b33e:	f044 0402 	orrmi.w	r4, r4, #2
 800b342:	f853 6c20 	ldr.w	r6, [r3, #-32]
    }

    /***************** Deactivation of previous configuration *****************/
    CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[instance].NCSPort-1U)], OCTOSPIM_PCR_NCSEN);
 800b346:	f850 2026 	ldr.w	r2, [r0, r6, lsl #2]
 800b34a:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800b34e:	f840 2026 	str.w	r2, [r0, r6, lsl #2]
      }
    }
    else
    {
#endif
      if (IOM_cfg[instance].ClkPort != 0U)
 800b352:	f853 2c28 	ldr.w	r2, [r3, #-40]
 800b356:	b382      	cbz	r2, 800b3ba <HAL_OSPIM_Config+0x186>
      {
        CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[instance].ClkPort-1U)], OCTOSPIM_PCR_CLKEN);
 800b358:	f850 6022 	ldr.w	r6, [r0, r2, lsl #2]
        if (IOM_cfg[instance].DQSPort != 0U)
 800b35c:	f853 3c24 	ldr.w	r3, [r3, #-36]
    else
    {
#endif
      if (IOM_cfg[instance].ClkPort != 0U)
      {
        CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[instance].ClkPort-1U)], OCTOSPIM_PCR_CLKEN);
 800b360:	f026 0601 	bic.w	r6, r6, #1
 800b364:	f840 6022 	str.w	r6, [r0, r2, lsl #2]
        if (IOM_cfg[instance].DQSPort != 0U)
 800b368:	b12b      	cbz	r3, 800b376 <HAL_OSPIM_Config+0x142>
        {
          CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[instance].DQSPort-1U)], OCTOSPIM_PCR_DQSEN);
 800b36a:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
 800b36e:	f022 0210 	bic.w	r2, r2, #16
 800b372:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
        }
        if (IOM_cfg[instance].IOLowPort != HAL_OSPIM_IOPORT_NONE)
 800b376:	2314      	movs	r3, #20
 800b378:	aa0a      	add	r2, sp, #40	; 0x28
 800b37a:	fb03 2305 	mla	r3, r3, r5, r2
 800b37e:	f853 3c1c 	ldr.w	r3, [r3, #-28]
 800b382:	b14b      	cbz	r3, 800b398 <HAL_OSPIM_Config+0x164>
 800b384:	3b01      	subs	r3, #1
 800b386:	f003 0301 	and.w	r3, r3, #1
 800b38a:	4a64      	ldr	r2, [pc, #400]	; (800b51c <HAL_OSPIM_Config+0x2e8>)
 800b38c:	009b      	lsls	r3, r3, #2
 800b38e:	441a      	add	r2, r3
        {
          CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[instance].IOLowPort-1U)& OSPI_IOM_PORT_MASK)], OCTOSPIM_PCR_IOLEN);
 800b390:	6853      	ldr	r3, [r2, #4]
 800b392:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800b396:	6053      	str	r3, [r2, #4]
        }
        if (IOM_cfg[instance].IOHighPort != HAL_OSPIM_IOPORT_NONE)
 800b398:	2314      	movs	r3, #20
 800b39a:	aa0a      	add	r2, sp, #40	; 0x28
 800b39c:	fb03 2305 	mla	r3, r3, r5, r2
 800b3a0:	f853 3c18 	ldr.w	r3, [r3, #-24]
 800b3a4:	b14b      	cbz	r3, 800b3ba <HAL_OSPIM_Config+0x186>
 800b3a6:	3b01      	subs	r3, #1
 800b3a8:	f003 0301 	and.w	r3, r3, #1
 800b3ac:	4a5b      	ldr	r2, [pc, #364]	; (800b51c <HAL_OSPIM_Config+0x2e8>)
 800b3ae:	009b      	lsls	r3, r3, #2
 800b3b0:	441a      	add	r2, r3
        {
          CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[instance].IOHighPort-1U)& OSPI_IOM_PORT_MASK)], OCTOSPIM_PCR_IOHEN);
 800b3b2:	6853      	ldr	r3, [r2, #4]
 800b3b4:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800b3b8:	6053      	str	r3, [r2, #4]
#if   defined (OCTOSPIM_CR_MUXEN)
    }
#endif

    /********************* Deactivation of other instance *********************/
    if ((cfg->ClkPort == IOM_cfg[other_instance].ClkPort) || (cfg->DQSPort == IOM_cfg[other_instance].DQSPort)     ||
 800b3ba:	ab0a      	add	r3, sp, #40	; 0x28
 800b3bc:	2614      	movs	r6, #20
 800b3be:	fb06 3607 	mla	r6, r6, r7, r3
 800b3c2:	f8d1 c000 	ldr.w	ip, [r1]
 800b3c6:	f856 9c28 	ldr.w	r9, [r6, #-40]
 800b3ca:	f8d1 e004 	ldr.w	lr, [r1, #4]
 800b3ce:	f8d1 8008 	ldr.w	r8, [r1, #8]
 800b3d2:	68ca      	ldr	r2, [r1, #12]
 800b3d4:	690b      	ldr	r3, [r1, #16]
 800b3d6:	45cc      	cmp	ip, r9
 800b3d8:	d00f      	beq.n	800b3fa <HAL_OSPIM_Config+0x1c6>
 800b3da:	f856 1c24 	ldr.w	r1, [r6, #-36]
 800b3de:	458e      	cmp	lr, r1
 800b3e0:	d00b      	beq.n	800b3fa <HAL_OSPIM_Config+0x1c6>
 800b3e2:	f856 1c20 	ldr.w	r1, [r6, #-32]
 800b3e6:	4588      	cmp	r8, r1
 800b3e8:	d007      	beq.n	800b3fa <HAL_OSPIM_Config+0x1c6>
        (cfg->NCSPort == IOM_cfg[other_instance].NCSPort) || (cfg->IOLowPort == IOM_cfg[other_instance].IOLowPort) ||
 800b3ea:	f856 1c1c 	ldr.w	r1, [r6, #-28]
 800b3ee:	428a      	cmp	r2, r1
 800b3f0:	d003      	beq.n	800b3fa <HAL_OSPIM_Config+0x1c6>
 800b3f2:	f856 1c18 	ldr.w	r1, [r6, #-24]
 800b3f6:	428b      	cmp	r3, r1
 800b3f8:	d13d      	bne.n	800b476 <HAL_OSPIM_Config+0x242>
        SET_BIT(OCTOSPIM->CR, OCTOSPIM_CR_MUXEN);
      }
      else
      {
#endif
        CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].ClkPort-1U)], OCTOSPIM_PCR_CLKEN);
 800b3fa:	f850 1029 	ldr.w	r1, [r0, r9, lsl #2]
 800b3fe:	f8df a11c 	ldr.w	sl, [pc, #284]	; 800b51c <HAL_OSPIM_Config+0x2e8>
 800b402:	f021 0101 	bic.w	r1, r1, #1
 800b406:	f840 1029 	str.w	r1, [r0, r9, lsl #2]
        if (IOM_cfg[other_instance].DQSPort != 0U)
 800b40a:	ae0a      	add	r6, sp, #40	; 0x28
 800b40c:	2114      	movs	r1, #20
 800b40e:	fb01 6607 	mla	r6, r1, r7, r6
 800b412:	f856 6c24 	ldr.w	r6, [r6, #-36]
 800b416:	b12e      	cbz	r6, 800b424 <HAL_OSPIM_Config+0x1f0>
        {
          CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].DQSPort-1U)], OCTOSPIM_PCR_DQSEN);
 800b418:	f85a 9026 	ldr.w	r9, [sl, r6, lsl #2]
 800b41c:	f029 0910 	bic.w	r9, r9, #16
 800b420:	f84a 9026 	str.w	r9, [sl, r6, lsl #2]
        }
        CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].NCSPort-1U)], OCTOSPIM_PCR_NCSEN);
 800b424:	ae0a      	add	r6, sp, #40	; 0x28
 800b426:	fb01 6107 	mla	r1, r1, r7, r6
 800b42a:	f851 9c20 	ldr.w	r9, [r1, #-32]
        if (IOM_cfg[other_instance].IOLowPort != HAL_OSPIM_IOPORT_NONE)
 800b42e:	f851 1c1c 	ldr.w	r1, [r1, #-28]
        CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].ClkPort-1U)], OCTOSPIM_PCR_CLKEN);
        if (IOM_cfg[other_instance].DQSPort != 0U)
        {
          CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].DQSPort-1U)], OCTOSPIM_PCR_DQSEN);
        }
        CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].NCSPort-1U)], OCTOSPIM_PCR_NCSEN);
 800b432:	f850 6029 	ldr.w	r6, [r0, r9, lsl #2]
 800b436:	f426 7680 	bic.w	r6, r6, #256	; 0x100
 800b43a:	f840 6029 	str.w	r6, [r0, r9, lsl #2]
        if (IOM_cfg[other_instance].IOLowPort != HAL_OSPIM_IOPORT_NONE)
 800b43e:	b149      	cbz	r1, 800b454 <HAL_OSPIM_Config+0x220>
 800b440:	3901      	subs	r1, #1
 800b442:	f001 0101 	and.w	r1, r1, #1
 800b446:	4e35      	ldr	r6, [pc, #212]	; (800b51c <HAL_OSPIM_Config+0x2e8>)
 800b448:	0089      	lsls	r1, r1, #2
 800b44a:	440e      	add	r6, r1
        {
          CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[other_instance].IOLowPort-1U)& OSPI_IOM_PORT_MASK)], OCTOSPIM_PCR_IOLEN);
 800b44c:	6871      	ldr	r1, [r6, #4]
 800b44e:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 800b452:	6071      	str	r1, [r6, #4]
        }
        if (IOM_cfg[other_instance].IOHighPort != HAL_OSPIM_IOPORT_NONE)
 800b454:	2114      	movs	r1, #20
 800b456:	ae0a      	add	r6, sp, #40	; 0x28
 800b458:	fb01 6707 	mla	r7, r1, r7, r6
 800b45c:	f857 1c18 	ldr.w	r1, [r7, #-24]
 800b460:	b149      	cbz	r1, 800b476 <HAL_OSPIM_Config+0x242>
 800b462:	3901      	subs	r1, #1
 800b464:	f001 0101 	and.w	r1, r1, #1
 800b468:	4e2c      	ldr	r6, [pc, #176]	; (800b51c <HAL_OSPIM_Config+0x2e8>)
 800b46a:	0089      	lsls	r1, r1, #2
 800b46c:	440e      	add	r6, r1
        {
          CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[other_instance].IOHighPort-1U)& OSPI_IOM_PORT_MASK)], OCTOSPIM_PCR_IOHEN);
 800b46e:	6871      	ldr	r1, [r6, #4]
 800b470:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
 800b474:	6071      	str	r1, [r6, #4]
      }
#endif
    }

    /******************** Activation of new configuration *********************/
    MODIFY_REG(OCTOSPIM->PCR[(cfg->NCSPort-1U)], (OCTOSPIM_PCR_NCSEN | OCTOSPIM_PCR_NCSSRC), (OCTOSPIM_PCR_NCSEN | (instance << OCTOSPIM_PCR_NCSSRC_Pos)));
 800b476:	f850 1028 	ldr.w	r1, [r0, r8, lsl #2]
 800b47a:	4e28      	ldr	r6, [pc, #160]	; (800b51c <HAL_OSPIM_Config+0x2e8>)
 800b47c:	f421 7140 	bic.w	r1, r1, #768	; 0x300
 800b480:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 800b484:	ea41 2145 	orr.w	r1, r1, r5, lsl #9
 800b488:	f840 1028 	str.w	r1, [r0, r8, lsl #2]
      }
    }
    else
    {
#endif
      MODIFY_REG(OCTOSPIM->PCR[(cfg->ClkPort-1U)], (OCTOSPIM_PCR_CLKEN | OCTOSPIM_PCR_CLKSRC), (OCTOSPIM_PCR_CLKEN | (instance << OCTOSPIM_PCR_CLKSRC_Pos)));
 800b48c:	f850 102c 	ldr.w	r1, [r0, ip, lsl #2]
 800b490:	f021 0103 	bic.w	r1, r1, #3
 800b494:	f041 0101 	orr.w	r1, r1, #1
 800b498:	ea41 0145 	orr.w	r1, r1, r5, lsl #1
 800b49c:	f840 102c 	str.w	r1, [r0, ip, lsl #2]
      if (cfg->DQSPort != 0U)
 800b4a0:	f1be 0f00 	cmp.w	lr, #0
 800b4a4:	d009      	beq.n	800b4ba <HAL_OSPIM_Config+0x286>
      {
        MODIFY_REG(OCTOSPIM->PCR[(cfg->DQSPort-1U)], (OCTOSPIM_PCR_DQSEN | OCTOSPIM_PCR_DQSSRC), (OCTOSPIM_PCR_DQSEN | (instance << OCTOSPIM_PCR_DQSSRC_Pos)));
 800b4a6:	f856 102e 	ldr.w	r1, [r6, lr, lsl #2]
 800b4aa:	f021 0130 	bic.w	r1, r1, #48	; 0x30
 800b4ae:	f041 0110 	orr.w	r1, r1, #16
 800b4b2:	ea41 1145 	orr.w	r1, r1, r5, lsl #5
 800b4b6:	f846 102e 	str.w	r1, [r6, lr, lsl #2]
      }

      if ((cfg->IOLowPort & OCTOSPIM_PCR_IOLEN) != 0U)
 800b4ba:	03d0      	lsls	r0, r2, #15
 800b4bc:	d50d      	bpl.n	800b4da <HAL_OSPIM_Config+0x2a6>
 800b4be:	3a01      	subs	r2, #1
 800b4c0:	f002 0201 	and.w	r2, r2, #1
 800b4c4:	4915      	ldr	r1, [pc, #84]	; (800b51c <HAL_OSPIM_Config+0x2e8>)
 800b4c6:	0092      	lsls	r2, r2, #2
 800b4c8:	4411      	add	r1, r2
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOLowPort-1U)& OSPI_IOM_PORT_MASK)], (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC),
 800b4ca:	684a      	ldr	r2, [r1, #4]
 800b4cc:	f422 22e0 	bic.w	r2, r2, #458752	; 0x70000
 800b4d0:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800b4d4:	ea42 4285 	orr.w	r2, r2, r5, lsl #18
 800b4d8:	e00d      	b.n	800b4f6 <HAL_OSPIM_Config+0x2c2>
                   (OCTOSPIM_PCR_IOLEN | (instance << (OCTOSPIM_PCR_IOLSRC_Pos+1U))));
      }
      else if (cfg->IOLowPort != HAL_OSPIM_IOPORT_NONE)
 800b4da:	b16a      	cbz	r2, 800b4f8 <HAL_OSPIM_Config+0x2c4>
 800b4dc:	3a01      	subs	r2, #1
 800b4de:	f002 0201 	and.w	r2, r2, #1
 800b4e2:	490e      	ldr	r1, [pc, #56]	; (800b51c <HAL_OSPIM_Config+0x2e8>)
 800b4e4:	0092      	lsls	r2, r2, #2
 800b4e6:	4411      	add	r1, r2
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOLowPort-1U)& OSPI_IOM_PORT_MASK)], (OCTOSPIM_PCR_IOHEN | OCTOSPIM_PCR_IOHSRC),
 800b4e8:	684a      	ldr	r2, [r1, #4]
 800b4ea:	f022 62e0 	bic.w	r2, r2, #117440512	; 0x7000000
 800b4ee:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800b4f2:	ea42 6285 	orr.w	r2, r2, r5, lsl #26
 800b4f6:	604a      	str	r2, [r1, #4]
      else
      {
         /* Nothing to do */
      }

      if ((cfg->IOHighPort & OCTOSPIM_PCR_IOLEN) != 0U)
 800b4f8:	03d9      	lsls	r1, r3, #15
 800b4fa:	d515      	bpl.n	800b528 <HAL_OSPIM_Config+0x2f4>
 800b4fc:	3b01      	subs	r3, #1
 800b4fe:	f003 0301 	and.w	r3, r3, #1
 800b502:	4a06      	ldr	r2, [pc, #24]	; (800b51c <HAL_OSPIM_Config+0x2e8>)
 800b504:	009b      	lsls	r3, r3, #2
 800b506:	441a      	add	r2, r3
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOHighPort-1U)& OSPI_IOM_PORT_MASK)], (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC),
 800b508:	6853      	ldr	r3, [r2, #4]
 800b50a:	f423 23e0 	bic.w	r3, r3, #458752	; 0x70000
 800b50e:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
 800b512:	ea43 4585 	orr.w	r5, r3, r5, lsl #18
 800b516:	e015      	b.n	800b544 <HAL_OSPIM_Config+0x310>
 800b518:	a0001000 	.word	0xa0001000
 800b51c:	50061c00 	.word	0x50061c00
 800b520:	a0001400 	.word	0xa0001400
 800b524:	04040222 	.word	0x04040222
                   (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC_0 | (instance << (OCTOSPIM_PCR_IOLSRC_Pos+1U))));
      }
      else if (cfg->IOHighPort != HAL_OSPIM_IOPORT_NONE)
 800b528:	b16b      	cbz	r3, 800b546 <HAL_OSPIM_Config+0x312>
 800b52a:	3b01      	subs	r3, #1
 800b52c:	f003 0301 	and.w	r3, r3, #1
 800b530:	4a0f      	ldr	r2, [pc, #60]	; (800b570 <HAL_OSPIM_Config+0x33c>)
 800b532:	009b      	lsls	r3, r3, #2
 800b534:	441a      	add	r2, r3
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOHighPort-1U)& OSPI_IOM_PORT_MASK)], (OCTOSPIM_PCR_IOHEN | OCTOSPIM_PCR_IOHSRC),
 800b536:	6853      	ldr	r3, [r2, #4]
 800b538:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 800b53c:	f043 7340 	orr.w	r3, r3, #50331648	; 0x3000000
 800b540:	ea43 6585 	orr.w	r5, r3, r5, lsl #26
 800b544:	6055      	str	r5, [r2, #4]
#if   defined (OCTOSPIM_CR_MUXEN)
    }
#endif

    /******* Re-enable both OctoSPI after configure OctoSPI IO Manager ********/
    if ((ospi_enabled & 0x1U) != 0U)
 800b546:	07e2      	lsls	r2, r4, #31
    {
      SET_BIT(OCTOSPI1->CR, OCTOSPI_CR_EN);
 800b548:	bf41      	itttt	mi
 800b54a:	4a0a      	ldrmi	r2, [pc, #40]	; (800b574 <HAL_OSPIM_Config+0x340>)
 800b54c:	6813      	ldrmi	r3, [r2, #0]
 800b54e:	f043 0301 	orrmi.w	r3, r3, #1
 800b552:	6013      	strmi	r3, [r2, #0]
    }
    if ((ospi_enabled & 0x2U) != 0U)
 800b554:	07a3      	lsls	r3, r4, #30
    {
      SET_BIT(OCTOSPI2->CR, OCTOSPI_CR_EN);
 800b556:	bf44      	itt	mi
 800b558:	4a07      	ldrmi	r2, [pc, #28]	; (800b578 <HAL_OSPIM_Config+0x344>)
 800b55a:	6813      	ldrmi	r3, [r2, #0]
    }
  }

  /* Return function status */
  return status;
}
 800b55c:	f04f 0000 	mov.w	r0, #0
    {
      SET_BIT(OCTOSPI1->CR, OCTOSPI_CR_EN);
    }
    if ((ospi_enabled & 0x2U) != 0U)
    {
      SET_BIT(OCTOSPI2->CR, OCTOSPI_CR_EN);
 800b560:	bf44      	itt	mi
 800b562:	f043 0301 	orrmi.w	r3, r3, #1
 800b566:	6013      	strmi	r3, [r2, #0]
    }
  }

  /* Return function status */
  return status;
}
 800b568:	b00a      	add	sp, #40	; 0x28
 800b56a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800b56e:	bf00      	nop
 800b570:	50061c00 	.word	0x50061c00
 800b574:	a0001000 	.word	0xa0001000
 800b578:	a0001400 	.word	0xa0001400

0800b57c <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
 800b57c:	b530      	push	{r4, r5, lr}
 800b57e:	9c03      	ldr	r4, [sp, #12]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2,
 800b580:	6805      	ldr	r5, [r0, #0]
 800b582:	4323      	orrs	r3, r4
 800b584:	0d64      	lsrs	r4, r4, #21
 800b586:	f404 6480 	and.w	r4, r4, #1024	; 0x400
 800b58a:	f044 747f 	orr.w	r4, r4, #66846720	; 0x3fc0000
 800b58e:	f444 3458 	orr.w	r4, r4, #221184	; 0x36000
 800b592:	6868      	ldr	r0, [r5, #4]
 800b594:	f3c1 0109 	ubfx	r1, r1, #0, #10
 800b598:	f444 747f 	orr.w	r4, r4, #1020	; 0x3fc
 800b59c:	430b      	orrs	r3, r1
 800b59e:	f044 0403 	orr.w	r4, r4, #3
 800b5a2:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 800b5a6:	ea20 0404 	bic.w	r4, r0, r4
 800b5aa:	4314      	orrs	r4, r2
 800b5ac:	606c      	str	r4, [r5, #4]
 800b5ae:	bd30      	pop	{r4, r5, pc}

0800b5b0 <I2C_IsAcknowledgeFailed>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 800b5b0:	6803      	ldr	r3, [r0, #0]
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 800b5b2:	b570      	push	{r4, r5, r6, lr}
 800b5b4:	4604      	mov	r4, r0
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 800b5b6:	6998      	ldr	r0, [r3, #24]
 800b5b8:	f010 0010 	ands.w	r0, r0, #16
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 800b5bc:	460d      	mov	r5, r1
 800b5be:	4616      	mov	r6, r2
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 800b5c0:	d10b      	bne.n	800b5da <I2C_IsAcknowledgeFailed+0x2a>
 800b5c2:	bd70      	pop	{r4, r5, r6, pc}
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 800b5c4:	6999      	ldr	r1, [r3, #24]
 800b5c6:	0688      	lsls	r0, r1, #26
 800b5c8:	d40d      	bmi.n	800b5e6 <I2C_IsAcknowledgeFailed+0x36>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
 800b5ca:	1c6a      	adds	r2, r5, #1
 800b5cc:	d0fa      	beq.n	800b5c4 <I2C_IsAcknowledgeFailed+0x14>
      {
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800b5ce:	f7fb fd1d 	bl	800700c <HAL_GetTick>
 800b5d2:	1b80      	subs	r0, r0, r6
 800b5d4:	4285      	cmp	r5, r0
 800b5d6:	d302      	bcc.n	800b5de <I2C_IsAcknowledgeFailed+0x2e>
 800b5d8:	b10d      	cbz	r5, 800b5de <I2C_IsAcknowledgeFailed+0x2e>
{
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 800b5da:	6823      	ldr	r3, [r4, #0]
 800b5dc:	e7f2      	b.n	800b5c4 <I2C_IsAcknowledgeFailed+0x14>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800b5de:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800b5e0:	f043 0320 	orr.w	r3, r3, #32
 800b5e4:	e016      	b.n	800b614 <I2C_IsAcknowledgeFailed+0x64>
        }
      }
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800b5e6:	2210      	movs	r2, #16
 800b5e8:	61da      	str	r2, [r3, #28]

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800b5ea:	2220      	movs	r2, #32
 800b5ec:	61da      	str	r2, [r3, #28]
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 800b5ee:	699a      	ldr	r2, [r3, #24]
 800b5f0:	0791      	lsls	r1, r2, #30
  {
    hi2c->Instance->TXDR = 0x00U;
 800b5f2:	bf44      	itt	mi
 800b5f4:	2200      	movmi	r2, #0
 800b5f6:	629a      	strmi	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 800b5f8:	699a      	ldr	r2, [r3, #24]
 800b5fa:	07d2      	lsls	r2, r2, #31
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 800b5fc:	bf5e      	ittt	pl
 800b5fe:	699a      	ldrpl	r2, [r3, #24]
 800b600:	f042 0201 	orrpl.w	r2, r2, #1
 800b604:	619a      	strpl	r2, [r3, #24]

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800b606:	6859      	ldr	r1, [r3, #4]
 800b608:	4a08      	ldr	r2, [pc, #32]	; (800b62c <I2C_IsAcknowledgeFailed+0x7c>)
 800b60a:	400a      	ands	r2, r1
 800b60c:	605a      	str	r2, [r3, #4]

    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 800b60e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800b610:	f043 0304 	orr.w	r3, r3, #4
 800b614:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 800b616:	2320      	movs	r3, #32
 800b618:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 800b61c:	2300      	movs	r3, #0
 800b61e:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800b622:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40

    return HAL_ERROR;
 800b626:	2001      	movs	r0, #1
  }
  return HAL_OK;
}
 800b628:	bd70      	pop	{r4, r5, r6, pc}
 800b62a:	bf00      	nop
 800b62c:	fe00e800 	.word	0xfe00e800

0800b630 <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 800b630:	b570      	push	{r4, r5, r6, lr}
 800b632:	4604      	mov	r4, r0
 800b634:	460d      	mov	r5, r1
 800b636:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 800b638:	6823      	ldr	r3, [r4, #0]
 800b63a:	699b      	ldr	r3, [r3, #24]
 800b63c:	069b      	lsls	r3, r3, #26
 800b63e:	d419      	bmi.n	800b674 <I2C_WaitOnSTOPFlagUntilTimeout+0x44>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 800b640:	4632      	mov	r2, r6
 800b642:	4629      	mov	r1, r5
 800b644:	4620      	mov	r0, r4
 800b646:	f7ff ffb3 	bl	800b5b0 <I2C_IsAcknowledgeFailed>
 800b64a:	b9a8      	cbnz	r0, 800b678 <I2C_WaitOnSTOPFlagUntilTimeout+0x48>
    {
      return HAL_ERROR;
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800b64c:	f7fb fcde 	bl	800700c <HAL_GetTick>
 800b650:	1b80      	subs	r0, r0, r6
 800b652:	4285      	cmp	r5, r0
 800b654:	d301      	bcc.n	800b65a <I2C_WaitOnSTOPFlagUntilTimeout+0x2a>
 800b656:	2d00      	cmp	r5, #0
 800b658:	d1ee      	bne.n	800b638 <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800b65a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800b65c:	f043 0320 	orr.w	r3, r3, #32
 800b660:	6463      	str	r3, [r4, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 800b662:	2320      	movs	r3, #32
 800b664:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
 800b668:	2300      	movs	r3, #0
 800b66a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 800b66e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 800b672:	e001      	b.n	800b678 <I2C_WaitOnSTOPFlagUntilTimeout+0x48>

      return HAL_ERROR;
    }
  }
  return HAL_OK;
 800b674:	2000      	movs	r0, #0
 800b676:	bd70      	pop	{r4, r5, r6, pc}
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
    {
      return HAL_ERROR;
 800b678:	2001      	movs	r0, #1

      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 800b67a:	bd70      	pop	{r4, r5, r6, pc}

0800b67c <I2C_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
                                                    uint32_t Timeout, uint32_t Tickstart)
{
 800b67c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b680:	9f06      	ldr	r7, [sp, #24]
 800b682:	4604      	mov	r4, r0
 800b684:	4688      	mov	r8, r1
 800b686:	4616      	mov	r6, r2
 800b688:	461d      	mov	r5, r3
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 800b68a:	6822      	ldr	r2, [r4, #0]
 800b68c:	6993      	ldr	r3, [r2, #24]
 800b68e:	ea38 0303 	bics.w	r3, r8, r3
 800b692:	bf0c      	ite	eq
 800b694:	2301      	moveq	r3, #1
 800b696:	2300      	movne	r3, #0
 800b698:	42b3      	cmp	r3, r6
 800b69a:	d117      	bne.n	800b6cc <I2C_WaitOnFlagUntilTimeout+0x50>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800b69c:	1c6b      	adds	r3, r5, #1
 800b69e:	d0f5      	beq.n	800b68c <I2C_WaitOnFlagUntilTimeout+0x10>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800b6a0:	f7fb fcb4 	bl	800700c <HAL_GetTick>
 800b6a4:	1bc0      	subs	r0, r0, r7
 800b6a6:	4285      	cmp	r5, r0
 800b6a8:	d301      	bcc.n	800b6ae <I2C_WaitOnFlagUntilTimeout+0x32>
 800b6aa:	2d00      	cmp	r5, #0
 800b6ac:	d1ed      	bne.n	800b68a <I2C_WaitOnFlagUntilTimeout+0xe>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800b6ae:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800b6b0:	f043 0320 	orr.w	r3, r3, #32
 800b6b4:	6463      	str	r3, [r4, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 800b6b6:	2320      	movs	r3, #32
 800b6b8:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
 800b6bc:	2300      	movs	r3, #0
 800b6be:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 800b6c2:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 800b6c6:	2001      	movs	r0, #1
 800b6c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        __HAL_UNLOCK(hi2c);
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
 800b6cc:	2000      	movs	r0, #0
}
 800b6ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800b6d2 <HAL_I2C_MspInit>:
 800b6d2:	4770      	bx	lr

0800b6d4 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 800b6d4:	b510      	push	{r4, lr}
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 800b6d6:	4604      	mov	r4, r0
 800b6d8:	2800      	cmp	r0, #0
 800b6da:	d04a      	beq.n	800b772 <HAL_I2C_Init+0x9e>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
 800b6dc:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 800b6e0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800b6e4:	b91b      	cbnz	r3, 800b6ee <HAL_I2C_Init+0x1a>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 800b6e6:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
 800b6ea:	f7ff fff2 	bl	800b6d2 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 800b6ee:	2324      	movs	r3, #36	; 0x24
 800b6f0:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 800b6f4:	6823      	ldr	r3, [r4, #0]
  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800b6f6:	68e1      	ldr	r1, [r4, #12]
  }

  hi2c->State = HAL_I2C_STATE_BUSY;

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 800b6f8:	681a      	ldr	r2, [r3, #0]
 800b6fa:	f022 0201 	bic.w	r2, r2, #1
 800b6fe:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 800b700:	6862      	ldr	r2, [r4, #4]
 800b702:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 800b706:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 800b708:	689a      	ldr	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800b70a:	2901      	cmp	r1, #1
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 800b70c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800b710:	609a      	str	r2, [r3, #8]
 800b712:	68a2      	ldr	r2, [r4, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800b714:	d103      	bne.n	800b71e <HAL_I2C_Init+0x4a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 800b716:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800b71a:	609a      	str	r2, [r3, #8]
 800b71c:	e007      	b.n	800b72e <HAL_I2C_Init+0x5a>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 800b71e:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 800b722:	2902      	cmp	r1, #2
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 800b724:	609a      	str	r2, [r3, #8]

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 800b726:	bf04      	itt	eq
 800b728:	f44f 6200 	moveq.w	r2, #2048	; 0x800
 800b72c:	605a      	streq	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 800b72e:	685a      	ldr	r2, [r3, #4]
  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 800b730:	6921      	ldr	r1, [r4, #16]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 800b732:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 800b736:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800b73a:	605a      	str	r2, [r3, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 800b73c:	68da      	ldr	r2, [r3, #12]
 800b73e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800b742:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 800b744:	6962      	ldr	r2, [r4, #20]
 800b746:	430a      	orrs	r2, r1
 800b748:	69a1      	ldr	r1, [r4, #24]
 800b74a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 800b74e:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 800b750:	69e1      	ldr	r1, [r4, #28]
 800b752:	6a22      	ldr	r2, [r4, #32]
 800b754:	430a      	orrs	r2, r1
 800b756:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 800b758:	681a      	ldr	r2, [r3, #0]
 800b75a:	f042 0201 	orr.w	r2, r2, #1
 800b75e:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800b760:	2000      	movs	r0, #0
  hi2c->State = HAL_I2C_STATE_READY;
 800b762:	2320      	movs	r3, #32
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800b764:	6460      	str	r0, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 800b766:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 800b76a:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 800b76c:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42

  return HAL_OK;
 800b770:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
  {
    return HAL_ERROR;
 800b772:	2001      	movs	r0, #1
  hi2c->State = HAL_I2C_STATE_READY;
  hi2c->PreviousState = I2C_STATE_NONE;
  hi2c->Mode = HAL_I2C_MODE_NONE;

  return HAL_OK;
}
 800b774:	bd10      	pop	{r4, pc}

0800b776 <HAL_I2C_MspDeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
{
 800b776:	4770      	bx	lr

0800b778 <HAL_I2C_Master_Transmit>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size,
                                          uint32_t Timeout)
{
 800b778:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 800b77c:	4699      	mov	r9, r3
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
 800b77e:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size,
                                          uint32_t Timeout)
{
 800b782:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
 800b784:	2b20      	cmp	r3, #32
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size,
                                          uint32_t Timeout)
{
 800b786:	4604      	mov	r4, r0
 800b788:	460f      	mov	r7, r1
 800b78a:	4692      	mov	sl, r2
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
 800b78c:	f040 8099 	bne.w	800b8c2 <HAL_I2C_Master_Transmit+0x14a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 800b790:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 800b794:	2b01      	cmp	r3, #1
 800b796:	f000 8094 	beq.w	800b8c2 <HAL_I2C_Master_Transmit+0x14a>
 800b79a:	f04f 0801 	mov.w	r8, #1
 800b79e:	f880 8040 	strb.w	r8, [r0, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 800b7a2:	f7fb fc33 	bl	800700c <HAL_GetTick>

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800b7a6:	2319      	movs	r3, #25
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 800b7a8:	4606      	mov	r6, r0

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800b7aa:	9000      	str	r0, [sp, #0]
 800b7ac:	4642      	mov	r2, r8
 800b7ae:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800b7b2:	4620      	mov	r0, r4
 800b7b4:	f7ff ff62 	bl	800b67c <I2C_WaitOnFlagUntilTimeout>
 800b7b8:	2800      	cmp	r0, #0
 800b7ba:	f040 8084 	bne.w	800b8c6 <HAL_I2C_Master_Transmit+0x14e>
    {
      return HAL_ERROR;
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 800b7be:	2321      	movs	r3, #33	; 0x21
 800b7c0:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 800b7c4:	2310      	movs	r3, #16
 800b7c6:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800b7ca:	6460      	str	r0, [r4, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
    hi2c->XferCount = Size;
 800b7cc:	f8a4 902a 	strh.w	r9, [r4, #42]	; 0x2a
    hi2c->XferISR   = NULL;

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800b7d0:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 800b7d2:	f8c4 a024 	str.w	sl, [r4, #36]	; 0x24
    hi2c->XferCount = Size;
    hi2c->XferISR   = NULL;

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800b7d6:	b29b      	uxth	r3, r3
 800b7d8:	2bff      	cmp	r3, #255	; 0xff
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
    hi2c->XferCount = Size;
    hi2c->XferISR   = NULL;
 800b7da:	6360      	str	r0, [r4, #52]	; 0x34
 800b7dc:	4b3c      	ldr	r3, [pc, #240]	; (800b8d0 <HAL_I2C_Master_Transmit+0x158>)

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800b7de:	d903      	bls.n	800b7e8 <HAL_I2C_Master_Transmit+0x70>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 800b7e0:	22ff      	movs	r2, #255	; 0xff
 800b7e2:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 800b7e4:	9300      	str	r3, [sp, #0]
 800b7e6:	e031      	b.n	800b84c <HAL_I2C_Master_Transmit+0xd4>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 800b7e8:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
 800b7ea:	9300      	str	r3, [sp, #0]
      hi2c->XferSize = MAX_NBYTE_SIZE;
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 800b7ec:	b292      	uxth	r2, r2
 800b7ee:	8522      	strh	r2, [r4, #40]	; 0x28
 800b7f0:	e033      	b.n	800b85a <HAL_I2C_Master_Transmit+0xe2>
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 800b7f2:	4632      	mov	r2, r6
 800b7f4:	4629      	mov	r1, r5
 800b7f6:	4620      	mov	r0, r4
 800b7f8:	f7ff feda 	bl	800b5b0 <I2C_IsAcknowledgeFailed>
 800b7fc:	2800      	cmp	r0, #0
 800b7fe:	d162      	bne.n	800b8c6 <HAL_I2C_Master_Transmit+0x14e>
    {
      return HAL_ERROR;
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800b800:	1c6a      	adds	r2, r5, #1
 800b802:	d136      	bne.n	800b872 <HAL_I2C_Master_Transmit+0xfa>
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 800b804:	6822      	ldr	r2, [r4, #0]
 800b806:	6993      	ldr	r3, [r2, #24]
 800b808:	079b      	lsls	r3, r3, #30
 800b80a:	d5f2      	bpl.n	800b7f2 <HAL_I2C_Master_Transmit+0x7a>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
      {
        return HAL_ERROR;
      }
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 800b80c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800b80e:	f813 1b01 	ldrb.w	r1, [r3], #1
 800b812:	6291      	str	r1, [r2, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 800b814:	6263      	str	r3, [r4, #36]	; 0x24

      hi2c->XferCount--;
 800b816:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 800b818:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;

      hi2c->XferCount--;
 800b81a:	3b01      	subs	r3, #1
 800b81c:	b29b      	uxth	r3, r3
 800b81e:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800b820:	8d63      	ldrh	r3, [r4, #42]	; 0x2a

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;

      hi2c->XferCount--;
      hi2c->XferSize--;
 800b822:	3a01      	subs	r2, #1
 800b824:	b292      	uxth	r2, r2

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800b826:	b29b      	uxth	r3, r3

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;

      hi2c->XferCount--;
      hi2c->XferSize--;
 800b828:	8522      	strh	r2, [r4, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800b82a:	b1eb      	cbz	r3, 800b868 <HAL_I2C_Master_Transmit+0xf0>
 800b82c:	b9e2      	cbnz	r2, 800b868 <HAL_I2C_Master_Transmit+0xf0>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 800b82e:	9600      	str	r6, [sp, #0]
 800b830:	462b      	mov	r3, r5
 800b832:	2180      	movs	r1, #128	; 0x80
 800b834:	4620      	mov	r0, r4
 800b836:	f7ff ff21 	bl	800b67c <I2C_WaitOnFlagUntilTimeout>
 800b83a:	2800      	cmp	r0, #0
 800b83c:	d143      	bne.n	800b8c6 <HAL_I2C_Master_Transmit+0x14e>
        {
          return HAL_ERROR;
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800b83e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800b840:	b29b      	uxth	r3, r3
 800b842:	2bff      	cmp	r3, #255	; 0xff
 800b844:	d905      	bls.n	800b852 <HAL_I2C_Master_Transmit+0xda>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 800b846:	22ff      	movs	r2, #255	; 0xff
 800b848:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 800b84a:	9000      	str	r0, [sp, #0]
 800b84c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800b850:	e006      	b.n	800b860 <HAL_I2C_Master_Transmit+0xe8>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 800b852:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 800b854:	9000      	str	r0, [sp, #0]
          hi2c->XferSize = MAX_NBYTE_SIZE;
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 800b856:	b292      	uxth	r2, r2
 800b858:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 800b85a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800b85e:	b2d2      	uxtb	r2, r2
 800b860:	4639      	mov	r1, r7
 800b862:	4620      	mov	r0, r4
 800b864:	f7ff fe8a 	bl	800b57c <I2C_TransferConfig>
    {
      hi2c->XferSize = hi2c->XferCount;
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
    }

    while (hi2c->XferCount > 0U)
 800b868:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800b86a:	b29b      	uxth	r3, r3
 800b86c:	2b00      	cmp	r3, #0
 800b86e:	d1c9      	bne.n	800b804 <HAL_I2C_Master_Transmit+0x8c>
 800b870:	e013      	b.n	800b89a <HAL_I2C_Master_Transmit+0x122>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800b872:	f7fb fbcb 	bl	800700c <HAL_GetTick>
 800b876:	1b80      	subs	r0, r0, r6
 800b878:	4285      	cmp	r5, r0
 800b87a:	d301      	bcc.n	800b880 <HAL_I2C_Master_Transmit+0x108>
 800b87c:	2d00      	cmp	r5, #0
 800b87e:	d1c1      	bne.n	800b804 <HAL_I2C_Master_Transmit+0x8c>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800b880:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800b882:	f043 0320 	orr.w	r3, r3, #32
 800b886:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 800b888:	2320      	movs	r3, #32
 800b88a:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 800b88e:	2300      	movs	r3, #0
 800b890:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 800b894:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 800b898:	e015      	b.n	800b8c6 <HAL_I2C_Master_Transmit+0x14e>
      }
    }

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800b89a:	4632      	mov	r2, r6
 800b89c:	4629      	mov	r1, r5
 800b89e:	4620      	mov	r0, r4
 800b8a0:	f7ff fec6 	bl	800b630 <I2C_WaitOnSTOPFlagUntilTimeout>
 800b8a4:	b978      	cbnz	r0, 800b8c6 <HAL_I2C_Master_Transmit+0x14e>
    {
      return HAL_ERROR;
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800b8a6:	6823      	ldr	r3, [r4, #0]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800b8a8:	4a0a      	ldr	r2, [pc, #40]	; (800b8d4 <HAL_I2C_Master_Transmit+0x15c>)
    {
      return HAL_ERROR;
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800b8aa:	2120      	movs	r1, #32
 800b8ac:	61d9      	str	r1, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800b8ae:	685d      	ldr	r5, [r3, #4]
 800b8b0:	402a      	ands	r2, r5
 800b8b2:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 800b8b4:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800b8b8:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 800b8bc:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);

    return HAL_OK;
 800b8c0:	e002      	b.n	800b8c8 <HAL_I2C_Master_Transmit+0x150>
  }
  else
  {
    return HAL_BUSY;
 800b8c2:	2002      	movs	r0, #2
 800b8c4:	e000      	b.n	800b8c8 <HAL_I2C_Master_Transmit+0x150>
    while (hi2c->XferCount > 0U)
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
      {
        return HAL_ERROR;
 800b8c6:	2001      	movs	r0, #1
  }
  else
  {
    return HAL_BUSY;
  }
}
 800b8c8:	b002      	add	sp, #8
 800b8ca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800b8ce:	bf00      	nop
 800b8d0:	80002000 	.word	0x80002000
 800b8d4:	fe00e800 	.word	0xfe00e800

0800b8d8 <HAL_I2C_Master_Receive>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size,
                                         uint32_t Timeout)
{
 800b8d8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 800b8dc:	4699      	mov	r9, r3
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
 800b8de:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size,
                                         uint32_t Timeout)
{
 800b8e2:	9e0a      	ldr	r6, [sp, #40]	; 0x28
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
 800b8e4:	2b20      	cmp	r3, #32
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size,
                                         uint32_t Timeout)
{
 800b8e6:	4604      	mov	r4, r0
 800b8e8:	460f      	mov	r7, r1
 800b8ea:	4692      	mov	sl, r2
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
 800b8ec:	f040 80ae 	bne.w	800ba4c <HAL_I2C_Master_Receive+0x174>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 800b8f0:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 800b8f4:	2b01      	cmp	r3, #1
 800b8f6:	f000 80a9 	beq.w	800ba4c <HAL_I2C_Master_Receive+0x174>
 800b8fa:	f04f 0801 	mov.w	r8, #1
 800b8fe:	f880 8040 	strb.w	r8, [r0, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 800b902:	f7fb fb83 	bl	800700c <HAL_GetTick>

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800b906:	2319      	movs	r3, #25
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 800b908:	4605      	mov	r5, r0

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800b90a:	9000      	str	r0, [sp, #0]
 800b90c:	4642      	mov	r2, r8
 800b90e:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800b912:	4620      	mov	r0, r4
 800b914:	f7ff feb2 	bl	800b67c <I2C_WaitOnFlagUntilTimeout>
 800b918:	2800      	cmp	r0, #0
 800b91a:	f040 8099 	bne.w	800ba50 <HAL_I2C_Master_Receive+0x178>
    {
      return HAL_ERROR;
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 800b91e:	2322      	movs	r3, #34	; 0x22
 800b920:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 800b924:	2310      	movs	r3, #16
 800b926:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800b92a:	6460      	str	r0, [r4, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
    hi2c->XferCount = Size;
 800b92c:	f8a4 902a 	strh.w	r9, [r4, #42]	; 0x2a
    hi2c->XferISR   = NULL;

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800b930:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 800b932:	f8c4 a024 	str.w	sl, [r4, #36]	; 0x24
    hi2c->XferCount = Size;
    hi2c->XferISR   = NULL;

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800b936:	b29b      	uxth	r3, r3
 800b938:	2bff      	cmp	r3, #255	; 0xff
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
    hi2c->XferCount = Size;
    hi2c->XferISR   = NULL;
 800b93a:	6360      	str	r0, [r4, #52]	; 0x34
 800b93c:	4b46      	ldr	r3, [pc, #280]	; (800ba58 <HAL_I2C_Master_Receive+0x180>)

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800b93e:	d903      	bls.n	800b948 <HAL_I2C_Master_Receive+0x70>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 800b940:	22ff      	movs	r2, #255	; 0xff
 800b942:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 800b944:	9300      	str	r3, [sp, #0]
 800b946:	e042      	b.n	800b9ce <HAL_I2C_Master_Receive+0xf6>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 800b948:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
 800b94a:	9300      	str	r3, [sp, #0]
      hi2c->XferSize = MAX_NBYTE_SIZE;
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 800b94c:	b292      	uxth	r2, r2
 800b94e:	8522      	strh	r2, [r4, #40]	; 0x28
 800b950:	e044      	b.n	800b9dc <HAL_I2C_Master_Receive+0x104>
        return HAL_ERROR;
      }
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800b952:	f7fb fb5b 	bl	800700c <HAL_GetTick>
 800b956:	1b40      	subs	r0, r0, r5
 800b958:	4286      	cmp	r6, r0
 800b95a:	d358      	bcc.n	800ba0e <HAL_I2C_Master_Receive+0x136>
 800b95c:	2e00      	cmp	r6, #0
 800b95e:	d056      	beq.n	800ba0e <HAL_I2C_Master_Receive+0x136>
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 800b960:	6823      	ldr	r3, [r4, #0]
 800b962:	699b      	ldr	r3, [r3, #24]
 800b964:	075b      	lsls	r3, r3, #29
 800b966:	d410      	bmi.n	800b98a <HAL_I2C_Master_Receive+0xb2>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 800b968:	462a      	mov	r2, r5
 800b96a:	4631      	mov	r1, r6
 800b96c:	4620      	mov	r0, r4
 800b96e:	f7ff fe1f 	bl	800b5b0 <I2C_IsAcknowledgeFailed>
 800b972:	2800      	cmp	r0, #0
 800b974:	d16c      	bne.n	800ba50 <HAL_I2C_Master_Receive+0x178>
    {
      return HAL_ERROR;
    }

    /* Check if a STOPF is detected */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
 800b976:	6823      	ldr	r3, [r4, #0]
 800b978:	699a      	ldr	r2, [r3, #24]
 800b97a:	0691      	lsls	r1, r2, #26
 800b97c:	d5e9      	bpl.n	800b952 <HAL_I2C_Master_Receive+0x7a>
    {
      /* Check if an RXNE is pending */
      /* Store Last receive data if any */
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && (hi2c->XferSize > 0U))
 800b97e:	699a      	ldr	r2, [r3, #24]
 800b980:	0752      	lsls	r2, r2, #29
 800b982:	d537      	bpl.n	800b9f4 <HAL_I2C_Master_Receive+0x11c>
 800b984:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 800b986:	2a00      	cmp	r2, #0
 800b988:	d034      	beq.n	800b9f4 <HAL_I2C_Master_Receive+0x11c>
      {
        return HAL_ERROR;
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 800b98a:	6822      	ldr	r2, [r4, #0]
 800b98c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800b98e:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800b990:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 800b992:	6a63      	ldr	r3, [r4, #36]	; 0x24

      hi2c->XferSize--;
 800b994:	8d22      	ldrh	r2, [r4, #40]	; 0x28

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 800b996:	3301      	adds	r3, #1
 800b998:	6263      	str	r3, [r4, #36]	; 0x24

      hi2c->XferSize--;
      hi2c->XferCount--;
 800b99a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800b99c:	3b01      	subs	r3, #1
 800b99e:	b29b      	uxth	r3, r3
 800b9a0:	8563      	strh	r3, [r4, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800b9a2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;

      hi2c->XferSize--;
 800b9a4:	3a01      	subs	r2, #1
 800b9a6:	b292      	uxth	r2, r2
      hi2c->XferCount--;

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800b9a8:	b29b      	uxth	r3, r3
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;

      hi2c->XferSize--;
 800b9aa:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800b9ac:	b1eb      	cbz	r3, 800b9ea <HAL_I2C_Master_Receive+0x112>
 800b9ae:	b9e2      	cbnz	r2, 800b9ea <HAL_I2C_Master_Receive+0x112>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 800b9b0:	9500      	str	r5, [sp, #0]
 800b9b2:	4633      	mov	r3, r6
 800b9b4:	2180      	movs	r1, #128	; 0x80
 800b9b6:	4620      	mov	r0, r4
 800b9b8:	f7ff fe60 	bl	800b67c <I2C_WaitOnFlagUntilTimeout>
 800b9bc:	2800      	cmp	r0, #0
 800b9be:	d147      	bne.n	800ba50 <HAL_I2C_Master_Receive+0x178>
        {
          return HAL_ERROR;
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800b9c0:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800b9c2:	b29b      	uxth	r3, r3
 800b9c4:	2bff      	cmp	r3, #255	; 0xff
 800b9c6:	d905      	bls.n	800b9d4 <HAL_I2C_Master_Receive+0xfc>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 800b9c8:	22ff      	movs	r2, #255	; 0xff
 800b9ca:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 800b9cc:	9000      	str	r0, [sp, #0]
 800b9ce:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800b9d2:	e006      	b.n	800b9e2 <HAL_I2C_Master_Receive+0x10a>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 800b9d4:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 800b9d6:	9000      	str	r0, [sp, #0]
          hi2c->XferSize = MAX_NBYTE_SIZE;
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 800b9d8:	b292      	uxth	r2, r2
 800b9da:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 800b9dc:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800b9e0:	b2d2      	uxtb	r2, r2
 800b9e2:	4639      	mov	r1, r7
 800b9e4:	4620      	mov	r0, r4
 800b9e6:	f7ff fdc9 	bl	800b57c <I2C_TransferConfig>
    {
      hi2c->XferSize = hi2c->XferCount;
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
    }

    while (hi2c->XferCount > 0U)
 800b9ea:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800b9ec:	b29b      	uxth	r3, r3
 800b9ee:	2b00      	cmp	r3, #0
 800b9f0:	d1b6      	bne.n	800b960 <HAL_I2C_Master_Receive+0x88>
 800b9f2:	e017      	b.n	800ba24 <HAL_I2C_Master_Receive+0x14c>
        return HAL_OK;
      }
      else
      {
        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800b9f4:	2120      	movs	r1, #32
 800b9f6:	61d9      	str	r1, [r3, #28]

        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
 800b9f8:	6858      	ldr	r0, [r3, #4]
 800b9fa:	4a18      	ldr	r2, [pc, #96]	; (800ba5c <HAL_I2C_Master_Receive+0x184>)
 800b9fc:	4002      	ands	r2, r0
 800b9fe:	605a      	str	r2, [r3, #4]

        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800ba00:	2300      	movs	r3, #0
 800ba02:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 800ba04:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 800ba08:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 800ba0c:	e007      	b.n	800ba1e <HAL_I2C_Master_Receive+0x146>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800ba0e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800ba10:	f043 0320 	orr.w	r3, r3, #32
 800ba14:	6463      	str	r3, [r4, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 800ba16:	2320      	movs	r3, #32
 800ba18:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 800ba1c:	2300      	movs	r3, #0
 800ba1e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 800ba22:	e015      	b.n	800ba50 <HAL_I2C_Master_Receive+0x178>
      }
    }

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800ba24:	462a      	mov	r2, r5
 800ba26:	4631      	mov	r1, r6
 800ba28:	4620      	mov	r0, r4
 800ba2a:	f7ff fe01 	bl	800b630 <I2C_WaitOnSTOPFlagUntilTimeout>
 800ba2e:	b978      	cbnz	r0, 800ba50 <HAL_I2C_Master_Receive+0x178>
    {
      return HAL_ERROR;
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800ba30:	6823      	ldr	r3, [r4, #0]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800ba32:	4a0a      	ldr	r2, [pc, #40]	; (800ba5c <HAL_I2C_Master_Receive+0x184>)
    {
      return HAL_ERROR;
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800ba34:	2120      	movs	r1, #32
 800ba36:	61d9      	str	r1, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 800ba38:	685d      	ldr	r5, [r3, #4]
 800ba3a:	402a      	ands	r2, r5
 800ba3c:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 800ba3e:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800ba42:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 800ba46:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);

    return HAL_OK;
 800ba4a:	e002      	b.n	800ba52 <HAL_I2C_Master_Receive+0x17a>
  }
  else
  {
    return HAL_BUSY;
 800ba4c:	2002      	movs	r0, #2
 800ba4e:	e000      	b.n	800ba52 <HAL_I2C_Master_Receive+0x17a>
    while (hi2c->XferCount > 0U)
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
      {
        return HAL_ERROR;
 800ba50:	2001      	movs	r0, #1
  }
  else
  {
    return HAL_BUSY;
  }
}
 800ba52:	b002      	add	sp, #8
 800ba54:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800ba58:	80002400 	.word	0x80002400
 800ba5c:	fe00e800 	.word	0xfe00e800

0800ba60 <SD_FindSCR>:
  * @param  hsd Pointer to SD handle
  * @param  pSCR pointer to the buffer that will contain the SCR value
  * @retval error state
  */
static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
 800ba60:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800ba64:	b087      	sub	sp, #28
 800ba66:	4604      	mov	r4, r0
 800ba68:	460d      	mov	r5, r1
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 800ba6a:	f7fb facf 	bl	800700c <HAL_GetTick>
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0UL, 0UL};
  uint32_t *scr = pSCR;

  /* Set Block Size To 8 Bytes */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
 800ba6e:	2108      	movs	r1, #8
  */
static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 800ba70:	4607      	mov	r7, r0
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0UL, 0UL};
  uint32_t *scr = pSCR;

  /* Set Block Size To 8 Bytes */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
 800ba72:	6820      	ldr	r0, [r4, #0]
 800ba74:	f001 f9a4 	bl	800cdc0 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800ba78:	2800      	cmp	r0, #0
 800ba7a:	d154      	bne.n	800bb26 <SD_FindSCR+0xc6>
  {
    return errorstate;
  }

  /* Send CMD55 APP_CMD with argument as card's RCA */
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)((hsd->SdCard.RelCardAdd) << 16U));
 800ba7c:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800ba7e:	6820      	ldr	r0, [r4, #0]
 800ba80:	0409      	lsls	r1, r1, #16
 800ba82:	f001 fad6 	bl	800d032 <SDMMC_CmdAppCommand>
  if(errorstate != HAL_SD_ERROR_NONE)
 800ba86:	2800      	cmp	r0, #0
 800ba88:	d14d      	bne.n	800bb26 <SD_FindSCR+0xc6>
  }

  config.DataTimeOut   = SDMMC_DATATIMEOUT;
  config.DataLength    = 8U;
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_8B;
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800ba8a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800ba8e:	f04f 0c30 	mov.w	ip, #48	; 0x30
 800ba92:	f04f 0e02 	mov.w	lr, #2
 800ba96:	2608      	movs	r6, #8
 800ba98:	e88d 5048 	stmia.w	sp, {r3, r6, ip, lr}
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800ba9c:	9004      	str	r0, [sp, #16]
  config.DPSM          = SDMMC_DPSM_ENABLE;
 800ba9e:	2301      	movs	r3, #1
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 800baa0:	4669      	mov	r1, sp
 800baa2:	6820      	ldr	r0, [r4, #0]
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
  config.DataLength    = 8U;
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_8B;
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
  config.DPSM          = SDMMC_DPSM_ENABLE;
 800baa4:	9305      	str	r3, [sp, #20]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 800baa6:	f001 f8af 	bl	800cc08 <SDMMC_ConfigData>

  /* Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
  errorstate = SDMMC_CmdSendSCR(hsd->Instance);
 800baaa:	6820      	ldr	r0, [r4, #0]
 800baac:	f001 fada 	bl	800d064 <SDMMC_CmdSendSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
 800bab0:	2800      	cmp	r0, #0
 800bab2:	d138      	bne.n	800bb26 <SD_FindSCR+0xc6>
 800bab4:	4606      	mov	r6, r0
 800bab6:	4680      	mov	r8, r0
 800bab8:	4681      	mov	r9, r0
  {
    return errorstate;
  }

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND | SDMMC_FLAG_DATAEND))
 800baba:	6822      	ldr	r2, [r4, #0]
 800babc:	6b51      	ldr	r1, [r2, #52]	; 0x34
 800babe:	f240 532a 	movw	r3, #1322	; 0x52a
 800bac2:	400b      	ands	r3, r1
 800bac4:	b9bb      	cbnz	r3, 800baf6 <SD_FindSCR+0x96>
  {
    if((!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOE)) && (index == 0U))
 800bac6:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800bac8:	0318      	lsls	r0, r3, #12
 800baca:	d40c      	bmi.n	800bae6 <SD_FindSCR+0x86>
 800bacc:	f1b9 0f00 	cmp.w	r9, #0
 800bad0:	d107      	bne.n	800bae2 <SD_FindSCR+0x82>
    {
      tempscr[0] = SDMMC_ReadFIFO(hsd->Instance);
 800bad2:	4610      	mov	r0, r2
 800bad4:	f001 f85c 	bl	800cb90 <SDMMC_ReadFIFO>
 800bad8:	4680      	mov	r8, r0
      tempscr[1] = SDMMC_ReadFIFO(hsd->Instance);
 800bada:	6820      	ldr	r0, [r4, #0]
 800badc:	f001 f858 	bl	800cb90 <SDMMC_ReadFIFO>
 800bae0:	4606      	mov	r6, r0
 800bae2:	f04f 0901 	mov.w	r9, #1
      index++;
    }


    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 800bae6:	f7fb fa91 	bl	800700c <HAL_GetTick>
 800baea:	1bc0      	subs	r0, r0, r7
 800baec:	3001      	adds	r0, #1
 800baee:	d1e4      	bne.n	800baba <SD_FindSCR+0x5a>
    {
      return HAL_SD_ERROR_TIMEOUT;
 800baf0:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800baf4:	e017      	b.n	800bb26 <SD_FindSCR+0xc6>
      return HAL_SD_ERROR_TIMEOUT;
    }
  }
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 800baf6:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800baf8:	0719      	lsls	r1, r3, #28
 800bafa:	d501      	bpl.n	800bb00 <SD_FindSCR+0xa0>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
 800bafc:	2008      	movs	r0, #8
 800bafe:	e009      	b.n	800bb14 <SD_FindSCR+0xb4>

    return HAL_SD_ERROR_DATA_TIMEOUT;
  }
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800bb00:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800bb02:	079b      	lsls	r3, r3, #30
 800bb04:	d501      	bpl.n	800bb0a <SD_FindSCR+0xaa>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
 800bb06:	2002      	movs	r0, #2
 800bb08:	e004      	b.n	800bb14 <SD_FindSCR+0xb4>

    return HAL_SD_ERROR_DATA_CRC_FAIL;
  }
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 800bb0a:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800bb0c:	f013 0020 	ands.w	r0, r3, #32
 800bb10:	d002      	beq.n	800bb18 <SD_FindSCR+0xb8>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
 800bb12:	2020      	movs	r0, #32
 800bb14:	6390      	str	r0, [r2, #56]	; 0x38

    return HAL_SD_ERROR_RX_OVERRUN;
 800bb16:	e006      	b.n	800bb26 <SD_FindSCR+0xc6>
  }
  else
  {
    /* No error flag set */
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800bb18:	4b04      	ldr	r3, [pc, #16]	; (800bb2c <SD_FindSCR+0xcc>)
 800bb1a:	6393      	str	r3, [r2, #56]	; 0x38
 800bb1c:	ba36      	rev	r6, r6
 800bb1e:	fa98 f388 	rev.w	r3, r8

    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8) |\
 800bb22:	602e      	str	r6, [r5, #0]
            ((tempscr[1] & SDMMC_16TO23BITS) >> 8) | ((tempscr[1] & SDMMC_24TO31BITS) >> 24));
    scr++;
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8) |\
 800bb24:	606b      	str	r3, [r5, #4]
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24));

  }

  return HAL_SD_ERROR_NONE;
}
 800bb26:	b007      	add	sp, #28
 800bb28:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800bb2c:	18000f3a 	.word	0x18000f3a

0800bb30 <SD_UltraHighSpeed>:
  *         of PLL to have SDMMCCK clock between 50 and 120 MHz
  * @param  hsd SD handle
  * @retval SD Card error state
  */
static uint32_t SD_UltraHighSpeed(SD_HandleTypeDef *hsd)
{
 800bb30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t errorstate = HAL_SD_ERROR_NONE;
  SDMMC_DataInitTypeDef sdmmc_datainitstructure;
  uint32_t SD_hs[16]  = {0};
 800bb34:	2440      	movs	r4, #64	; 0x40
  *         of PLL to have SDMMCCK clock between 50 and 120 MHz
  * @param  hsd SD handle
  * @retval SD Card error state
  */
static uint32_t SD_UltraHighSpeed(SD_HandleTypeDef *hsd)
{
 800bb36:	b096      	sub	sp, #88	; 0x58
 800bb38:	4606      	mov	r6, r0
  uint32_t errorstate = HAL_SD_ERROR_NONE;
  SDMMC_DataInitTypeDef sdmmc_datainitstructure;
  uint32_t SD_hs[16]  = {0};
 800bb3a:	4622      	mov	r2, r4
 800bb3c:	2100      	movs	r1, #0
 800bb3e:	a806      	add	r0, sp, #24
 800bb40:	f001 fcc1 	bl	800d4c6 <memset>
  uint32_t count, loop = 0 ;
  uint32_t Timeout = HAL_GetTick();
 800bb44:	f7fb fa62 	bl	800700c <HAL_GetTick>

  if(hsd->SdCard.CardSpeed == CARD_NORMAL_SPEED)
 800bb48:	6df3      	ldr	r3, [r6, #92]	; 0x5c
{
  uint32_t errorstate = HAL_SD_ERROR_NONE;
  SDMMC_DataInitTypeDef sdmmc_datainitstructure;
  uint32_t SD_hs[16]  = {0};
  uint32_t count, loop = 0 ;
  uint32_t Timeout = HAL_GetTick();
 800bb4a:	4607      	mov	r7, r0

  if(hsd->SdCard.CardSpeed == CARD_NORMAL_SPEED)
 800bb4c:	2b00      	cmp	r3, #0
 800bb4e:	d061      	beq.n	800bc14 <SD_UltraHighSpeed+0xe4>
  {
     /* Standard Speed Card <= 12.5Mhz  */
     return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
  }

  if((hsd->SdCard.CardSpeed == CARD_ULTRA_HIGH_SPEED) &&
 800bb50:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800bb54:	d161      	bne.n	800bc1a <SD_UltraHighSpeed+0xea>
 800bb56:	69b5      	ldr	r5, [r6, #24]
 800bb58:	2d01      	cmp	r5, #1
 800bb5a:	d15e      	bne.n	800bc1a <SD_UltraHighSpeed+0xea>
     (hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE))
  {
    /* Initialize the Data control register */
    hsd->Instance->DCTRL = 0;
 800bb5c:	6830      	ldr	r0, [r6, #0]
 800bb5e:	2300      	movs	r3, #0
 800bb60:	62c3      	str	r3, [r0, #44]	; 0x2c
    errorstate = SDMMC_CmdBlockLength(hsd->Instance, 64U);
 800bb62:	4621      	mov	r1, r4
 800bb64:	f001 f92c 	bl	800cdc0 <SDMMC_CmdBlockLength>

    if (errorstate != HAL_SD_ERROR_NONE)
 800bb68:	2800      	cmp	r0, #0
 800bb6a:	d158      	bne.n	800bc1e <SD_UltraHighSpeed+0xee>
    {
      return errorstate;
    }

    /* Configure the SD DPSM (Data Path State Machine) */
    sdmmc_datainitstructure.DataTimeOut   = SDMMC_DATATIMEOUT;
 800bb6c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    sdmmc_datainitstructure.DataLength    = 64U;
 800bb70:	e88d 0018 	stmia.w	sp, {r3, r4}
    sdmmc_datainitstructure.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B ;
 800bb74:	2360      	movs	r3, #96	; 0x60
 800bb76:	9302      	str	r3, [sp, #8]
    sdmmc_datainitstructure.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
    sdmmc_datainitstructure.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800bb78:	9004      	str	r0, [sp, #16]

    /* Configure the SD DPSM (Data Path State Machine) */
    sdmmc_datainitstructure.DataTimeOut   = SDMMC_DATATIMEOUT;
    sdmmc_datainitstructure.DataLength    = 64U;
    sdmmc_datainitstructure.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B ;
    sdmmc_datainitstructure.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800bb7a:	2302      	movs	r3, #2
    sdmmc_datainitstructure.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
    sdmmc_datainitstructure.DPSM          = SDMMC_DPSM_ENABLE;

    if ( SDMMC_ConfigData(hsd->Instance, &sdmmc_datainitstructure) != HAL_OK)
 800bb7c:	4669      	mov	r1, sp
 800bb7e:	6830      	ldr	r0, [r6, #0]

    /* Configure the SD DPSM (Data Path State Machine) */
    sdmmc_datainitstructure.DataTimeOut   = SDMMC_DATATIMEOUT;
    sdmmc_datainitstructure.DataLength    = 64U;
    sdmmc_datainitstructure.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B ;
    sdmmc_datainitstructure.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800bb80:	9303      	str	r3, [sp, #12]
    sdmmc_datainitstructure.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
    sdmmc_datainitstructure.DPSM          = SDMMC_DPSM_ENABLE;
 800bb82:	9505      	str	r5, [sp, #20]

    if ( SDMMC_ConfigData(hsd->Instance, &sdmmc_datainitstructure) != HAL_OK)
 800bb84:	f001 f840 	bl	800cc08 <SDMMC_ConfigData>
 800bb88:	2800      	cmp	r0, #0
 800bb8a:	d14a      	bne.n	800bc22 <SD_UltraHighSpeed+0xf2>
    {
      return (HAL_SD_ERROR_GENERAL_UNKNOWN_ERR);
    }

    errorstate = SDMMC_CmdSwitch(hsd->Instance, SDMMC_SDR104_SWITCH_PATTERN);
 800bb8c:	4929      	ldr	r1, [pc, #164]	; (800bc34 <SD_UltraHighSpeed+0x104>)
 800bb8e:	6830      	ldr	r0, [r6, #0]
 800bb90:	f001 facd 	bl	800d12e <SDMMC_CmdSwitch>
 800bb94:	4604      	mov	r4, r0
    if(errorstate != HAL_SD_ERROR_NONE)
 800bb96:	2800      	cmp	r0, #0
 800bb98:	d148      	bne.n	800bc2c <SD_UltraHighSpeed+0xfc>
    {
      return errorstate;
    }

    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND| SDMMC_FLAG_DATAEND ))
 800bb9a:	6833      	ldr	r3, [r6, #0]
 800bb9c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800bb9e:	f240 552a 	movw	r5, #1322	; 0x52a
 800bba2:	4015      	ands	r5, r2
 800bba4:	b9d5      	cbnz	r5, 800bbdc <SD_UltraHighSpeed+0xac>
    {
      if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
 800bba6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800bba8:	0418      	lsls	r0, r3, #16
 800bbaa:	d50b      	bpl.n	800bbc4 <SD_UltraHighSpeed+0x94>
 800bbac:	ab06      	add	r3, sp, #24
 800bbae:	eb03 1844 	add.w	r8, r3, r4, lsl #5
      {
        for (count = 0U; count < 8U; count++)
        {
          SD_hs[(8U*loop)+count]  = SDMMC_ReadFIFO(hsd->Instance);
 800bbb2:	6830      	ldr	r0, [r6, #0]
 800bbb4:	f000 ffec 	bl	800cb90 <SDMMC_ReadFIFO>
 800bbb8:	f848 0025 	str.w	r0, [r8, r5, lsl #2]

    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND| SDMMC_FLAG_DATAEND ))
    {
      if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
      {
        for (count = 0U; count < 8U; count++)
 800bbbc:	3501      	adds	r5, #1
 800bbbe:	2d08      	cmp	r5, #8
 800bbc0:	d1f7      	bne.n	800bbb2 <SD_UltraHighSpeed+0x82>
        {
          SD_hs[(8U*loop)+count]  = SDMMC_ReadFIFO(hsd->Instance);
        }
        loop ++;
 800bbc2:	3401      	adds	r4, #1
      }

      if((HAL_GetTick()-Timeout) >=  SDMMC_DATATIMEOUT)
 800bbc4:	f7fb fa22 	bl	800700c <HAL_GetTick>
 800bbc8:	1bc0      	subs	r0, r0, r7
 800bbca:	3001      	adds	r0, #1
 800bbcc:	d1e5      	bne.n	800bb9a <SD_UltraHighSpeed+0x6a>
      {
        hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
 800bbce:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
        hsd->State= HAL_SD_STATE_READY;
 800bbd2:	2301      	movs	r3, #1
        loop ++;
      }

      if((HAL_GetTick()-Timeout) >=  SDMMC_DATATIMEOUT)
      {
        hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
 800bbd4:	63b4      	str	r4, [r6, #56]	; 0x38
        hsd->State= HAL_SD_STATE_READY;
 800bbd6:	f886 3034 	strb.w	r3, [r6, #52]	; 0x34
        return HAL_SD_ERROR_TIMEOUT;
 800bbda:	e027      	b.n	800bc2c <SD_UltraHighSpeed+0xfc>
      }
    }

    if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 800bbdc:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800bbde:	0711      	lsls	r1, r2, #28
 800bbe0:	d502      	bpl.n	800bbe8 <SD_UltraHighSpeed+0xb8>
    {
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
 800bbe2:	2208      	movs	r2, #8
 800bbe4:	639a      	str	r2, [r3, #56]	; 0x38
 800bbe6:	e018      	b.n	800bc1a <SD_UltraHighSpeed+0xea>

      return errorstate;
    }
    else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800bbe8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800bbea:	0792      	lsls	r2, r2, #30
 800bbec:	d501      	bpl.n	800bbf2 <SD_UltraHighSpeed+0xc2>
    {
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
 800bbee:	2402      	movs	r4, #2
 800bbf0:	e004      	b.n	800bbfc <SD_UltraHighSpeed+0xcc>

      errorstate = SDMMC_ERROR_DATA_CRC_FAIL;

      return errorstate;
    }
    else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 800bbf2:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 800bbf4:	f014 0420 	ands.w	r4, r4, #32
 800bbf8:	d002      	beq.n	800bc00 <SD_UltraHighSpeed+0xd0>
    {
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
 800bbfa:	2420      	movs	r4, #32
 800bbfc:	639c      	str	r4, [r3, #56]	; 0x38

      errorstate = SDMMC_ERROR_RX_OVERRUN;

      return errorstate;
 800bbfe:	e015      	b.n	800bc2c <SD_UltraHighSpeed+0xfc>
    {
      /* No error flag set */
    }

    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800bc00:	4a0d      	ldr	r2, [pc, #52]	; (800bc38 <SD_UltraHighSpeed+0x108>)
 800bc02:	639a      	str	r2, [r3, #56]	; 0x38

    /* Test if the switch mode HS is ok */
    if ((((uint8_t*)SD_hs)[13] & 2U) != 2U)
 800bc04:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
 800bc08:	079b      	lsls	r3, r3, #30
 800bc0a:	d50d      	bpl.n	800bc28 <SD_UltraHighSpeed+0xf8>
    else
    {
#if defined (USE_HAL_SD_REGISTER_CALLBACKS) && (USE_HAL_SD_REGISTER_CALLBACKS == 1U)
      hsd->DriveTransceiver_1_8V_Callback(SET);
#else
      HAL_SDEx_DriveTransceiver_1_8V_Callback(SET);
 800bc0c:	2001      	movs	r0, #1
 800bc0e:	f7fb fa6d 	bl	80070ec <HAL_SDEx_DriveTransceiver_1_8V_Callback>
 800bc12:	e00b      	b.n	800bc2c <SD_UltraHighSpeed+0xfc>
  uint32_t Timeout = HAL_GetTick();

  if(hsd->SdCard.CardSpeed == CARD_NORMAL_SPEED)
  {
     /* Standard Speed Card <= 12.5Mhz  */
     return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 800bc14:	f04f 6480 	mov.w	r4, #67108864	; 0x4000000
 800bc18:	e008      	b.n	800bc2c <SD_UltraHighSpeed+0xfc>
  * @param  hsd SD handle
  * @retval SD Card error state
  */
static uint32_t SD_UltraHighSpeed(SD_HandleTypeDef *hsd)
{
  uint32_t errorstate = HAL_SD_ERROR_NONE;
 800bc1a:	2400      	movs	r4, #0
 800bc1c:	e006      	b.n	800bc2c <SD_UltraHighSpeed+0xfc>
 800bc1e:	4604      	mov	r4, r0
 800bc20:	e004      	b.n	800bc2c <SD_UltraHighSpeed+0xfc>
    sdmmc_datainitstructure.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
    sdmmc_datainitstructure.DPSM          = SDMMC_DPSM_ENABLE;

    if ( SDMMC_ConfigData(hsd->Instance, &sdmmc_datainitstructure) != HAL_OK)
    {
      return (HAL_SD_ERROR_GENERAL_UNKNOWN_ERR);
 800bc22:	f44f 3480 	mov.w	r4, #65536	; 0x10000
 800bc26:	e001      	b.n	800bc2c <SD_UltraHighSpeed+0xfc>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);

    /* Test if the switch mode HS is ok */
    if ((((uint8_t*)SD_hs)[13] & 2U) != 2U)
    {
      errorstate = SDMMC_ERROR_UNSUPPORTED_FEATURE;
 800bc28:	f04f 5480 	mov.w	r4, #268435456	; 0x10000000
#endif /* (DLYB_SDMMC1) || (DLYB_SDMMC2) */
    }
  }

  return errorstate;
}
 800bc2c:	4620      	mov	r0, r4
 800bc2e:	b016      	add	sp, #88	; 0x58
 800bc30:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800bc34:	80ff1f03 	.word	0x80ff1f03
 800bc38:	18000f3a 	.word	0x18000f3a

0800bc3c <HAL_SD_MspInit>:
 800bc3c:	4770      	bx	lr

0800bc3e <HAL_SD_MspDeInit>:
 800bc3e:	4770      	bx	lr

0800bc40 <HAL_SD_DeInit>:
  * @brief  De-Initializes the SD card.
  * @param  hsd Pointer to SD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_DeInit(SD_HandleTypeDef *hsd)
{
 800bc40:	b510      	push	{r4, lr}
  /* Check the SD handle allocation */
  if(hsd == NULL)
 800bc42:	4604      	mov	r4, r0
 800bc44:	b198      	cbz	r0, 800bc6e <HAL_SD_DeInit+0x2e>
  }

  /* Check the parameters */
  assert_param(IS_SDMMC_ALL_INSTANCE(hsd->Instance));

  hsd->State = HAL_SD_STATE_BUSY;
 800bc46:	2303      	movs	r3, #3
 800bc48:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  /* Desactivate the 1.8V Mode */
  if(hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE)
 800bc4c:	6983      	ldr	r3, [r0, #24]
 800bc4e:	2b01      	cmp	r3, #1
 800bc50:	d102      	bne.n	800bc58 <HAL_SD_DeInit+0x18>
    {
      hsd->DriveTransceiver_1_8V_Callback = HAL_SDEx_DriveTransceiver_1_8V_Callback;
    }
    hsd->DriveTransceiver_1_8V_Callback(RESET);
#else
    HAL_SDEx_DriveTransceiver_1_8V_Callback(RESET);
 800bc52:	2000      	movs	r0, #0
 800bc54:	f7fb fa4a 	bl	80070ec <HAL_SDEx_DriveTransceiver_1_8V_Callback>
  * @retval None
  */
static void SD_PowerOFF(SD_HandleTypeDef *hsd)
{
  /* Set Power State to OFF */
  (void)SDMMC_PowerState_OFF(hsd->Instance);
 800bc58:	6820      	ldr	r0, [r4, #0]
 800bc5a:	f000 ffb1 	bl	800cbc0 <SDMMC_PowerState_OFF>

  /* DeInit the low level hardware */
  hsd->MspDeInitCallback(hsd);
#else
  /* De-Initialize the MSP layer */
  HAL_SD_MspDeInit(hsd);
 800bc5e:	4620      	mov	r0, r4
 800bc60:	f7ff ffed 	bl	800bc3e <HAL_SD_MspDeInit>
#endif /* USE_HAL_SD_REGISTER_CALLBACKS */

  hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800bc64:	2000      	movs	r0, #0
 800bc66:	63a0      	str	r0, [r4, #56]	; 0x38
  hsd->State = HAL_SD_STATE_RESET;
 800bc68:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34

  return HAL_OK;
 800bc6c:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_SD_DeInit(SD_HandleTypeDef *hsd)
{
  /* Check the SD handle allocation */
  if(hsd == NULL)
  {
    return HAL_ERROR;
 800bc6e:	2001      	movs	r0, #1

  hsd->ErrorCode = HAL_SD_ERROR_NONE;
  hsd->State = HAL_SD_STATE_RESET;

  return HAL_OK;
}
 800bc70:	bd10      	pop	{r4, pc}
	...

0800bc74 <HAL_SD_ReadBlocks>:
  * @param  NumberOfBlocks Number of SD blocks to read
  * @param  Timeout Specify timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks, uint32_t Timeout)
{
 800bc74:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
 800bc78:	b086      	sub	sp, #24
 800bc7a:	4604      	mov	r4, r0
 800bc7c:	460f      	mov	r7, r1
 800bc7e:	4616      	mov	r6, r2
 800bc80:	4698      	mov	r8, r3
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 800bc82:	f7fb f9c3 	bl	800700c <HAL_GetTick>
 800bc86:	4681      	mov	r9, r0
  uint32_t count, data, dataremaining;
  uint32_t add = BlockAdd;
  uint8_t *tempbuff = pData;

  if(NULL == pData)
 800bc88:	b91f      	cbnz	r7, 800bc92 <HAL_SD_ReadBlocks+0x1e>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800bc8a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bc8c:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 800bc90:	e0c5      	b.n	800be1e <HAL_SD_ReadBlocks+0x1aa>
    return HAL_ERROR;
  }

  if(hsd->State == HAL_SD_STATE_READY)
 800bc92:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 800bc96:	b2c0      	uxtb	r0, r0
 800bc98:	2801      	cmp	r0, #1
 800bc9a:	f040 80bd 	bne.w	800be18 <HAL_SD_ReadBlocks+0x1a4>
  {
    hsd->ErrorCode = HAL_SD_ERROR_NONE;

    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800bc9e:	6d62      	ldr	r2, [r4, #84]	; 0x54
 800bca0:	eb06 0308 	add.w	r3, r6, r8
    return HAL_ERROR;
  }

  if(hsd->State == HAL_SD_STATE_READY)
  {
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800bca4:	2100      	movs	r1, #0

    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800bca6:	4293      	cmp	r3, r2
    return HAL_ERROR;
  }

  if(hsd->State == HAL_SD_STATE_READY)
  {
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800bca8:	63a1      	str	r1, [r4, #56]	; 0x38

    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800bcaa:	d904      	bls.n	800bcb6 <HAL_SD_ReadBlocks+0x42>
    {
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 800bcac:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bcae:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800bcb2:	63a3      	str	r3, [r4, #56]	; 0x38
      return HAL_ERROR;
 800bcb4:	e0b5      	b.n	800be22 <HAL_SD_ReadBlocks+0x1ae>
    }

    hsd->State = HAL_SD_STATE_BUSY;
 800bcb6:	2303      	movs	r3, #3
 800bcb8:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;

    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 800bcbc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    }

    hsd->State = HAL_SD_STATE_BUSY;

    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;
 800bcbe:	6820      	ldr	r0, [r4, #0]

    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 800bcc0:	2b01      	cmp	r3, #1
    {
      add *= 512U;
    }

    /* Configure the SD DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800bcc2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800bcc6:	9300      	str	r3, [sp, #0]
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
 800bcc8:	ea4f 2348 	mov.w	r3, r8, lsl #9
 800bccc:	9301      	str	r3, [sp, #4]
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 800bcce:	f04f 0390 	mov.w	r3, #144	; 0x90
    }

    hsd->State = HAL_SD_STATE_BUSY;

    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;
 800bcd2:	62c1      	str	r1, [r0, #44]	; 0x2c
    }

    /* Configure the SD DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 800bcd4:	9302      	str	r3, [sp, #8]
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800bcd6:	f04f 0502 	mov.w	r5, #2
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800bcda:	f04f 0300 	mov.w	r3, #0
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    config.DPSM          = SDMMC_DPSM_DISABLE;
#else
    config.DPSM          = SDMMC_DPSM_ENABLE;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 800bcde:	4669      	mov	r1, sp
    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;

    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
    {
      add *= 512U;
 800bce0:	bf18      	it	ne
 800bce2:	0276      	lslne	r6, r6, #9
    /* Configure the SD DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800bce4:	9304      	str	r3, [sp, #16]
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    config.DPSM          = SDMMC_DPSM_DISABLE;
 800bce6:	9305      	str	r3, [sp, #20]

    /* Configure the SD DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800bce8:	9503      	str	r5, [sp, #12]
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    config.DPSM          = SDMMC_DPSM_DISABLE;
#else
    config.DPSM          = SDMMC_DPSM_ENABLE;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 800bcea:	f000 ff8d 	bl	800cc08 <SDMMC_ConfigData>
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
 800bcee:	6820      	ldr	r0, [r4, #0]
 800bcf0:	68c3      	ldr	r3, [r0, #12]
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

    /* Read block(s) in polling mode */
    if(NumberOfBlocks > 1U)
 800bcf2:	f1b8 0f01 	cmp.w	r8, #1
#else
    config.DPSM          = SDMMC_DPSM_ENABLE;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
    (void)SDMMC_ConfigData(hsd->Instance, &config);
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
 800bcf6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800bcfa:	60c3      	str	r3, [r0, #12]
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

    /* Read block(s) in polling mode */
    if(NumberOfBlocks > 1U)
 800bcfc:	d904      	bls.n	800bd08 <HAL_SD_ReadBlocks+0x94>
    {
      hsd->Context = SD_CONTEXT_READ_MULTIPLE_BLOCK;
 800bcfe:	6325      	str	r5, [r4, #48]	; 0x30

      /* Read Multi Block command */
      errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
 800bd00:	4631      	mov	r1, r6
 800bd02:	f001 f88f 	bl	800ce24 <SDMMC_CmdReadMultiBlock>
 800bd06:	e004      	b.n	800bd12 <HAL_SD_ReadBlocks+0x9e>
    }
    else
    {
      hsd->Context = SD_CONTEXT_READ_SINGLE_BLOCK;
 800bd08:	2301      	movs	r3, #1
 800bd0a:	6323      	str	r3, [r4, #48]	; 0x30

      /* Read Single Block command */
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
 800bd0c:	4631      	mov	r1, r6
 800bd0e:	f001 f870 	bl	800cdf2 <SDMMC_CmdReadSingleBlock>
    }
    if(errorstate != HAL_SD_ERROR_NONE)
 800bd12:	2800      	cmp	r0, #0
 800bd14:	d144      	bne.n	800bda0 <HAL_SD_ReadBlocks+0x12c>
      hsd->Context = SD_CONTEXT_NONE;
      return HAL_ERROR;
    }

    /* Poll on SDMMC flags */
    dataremaining = config.DataLength;
 800bd16:	9d01      	ldr	r5, [sp, #4]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 800bd18:	6820      	ldr	r0, [r4, #0]
 800bd1a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800bd1c:	f413 7f95 	tst.w	r3, #298	; 0x12a
 800bd20:	d12e      	bne.n	800bd80 <HAL_SD_ReadBlocks+0x10c>
    {
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF) && (dataremaining > 0U))
 800bd22:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800bd24:	041a      	lsls	r2, r3, #16
 800bd26:	d516      	bpl.n	800bd56 <HAL_SD_ReadBlocks+0xe2>
 800bd28:	b1ad      	cbz	r5, 800bd56 <HAL_SD_ReadBlocks+0xe2>
 800bd2a:	1d3e      	adds	r6, r7, #4
 800bd2c:	f107 0b24 	add.w	fp, r7, #36	; 0x24
      {
        /* Read data from SDMMC Rx FIFO */
        for(count = 0U; count < 8U; count++)
        {
          data = SDMMC_ReadFIFO(hsd->Instance);
 800bd30:	6820      	ldr	r0, [r4, #0]
 800bd32:	f000 ff2d 	bl	800cb90 <SDMMC_ReadFIFO>
          *tempbuff = (uint8_t)(data & 0xFFU);
          tempbuff++;
          dataremaining--;
          *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
 800bd36:	0a03      	lsrs	r3, r0, #8
      {
        /* Read data from SDMMC Rx FIFO */
        for(count = 0U; count < 8U; count++)
        {
          data = SDMMC_ReadFIFO(hsd->Instance);
          *tempbuff = (uint8_t)(data & 0xFFU);
 800bd38:	f806 0c04 	strb.w	r0, [r6, #-4]
          tempbuff++;
          dataremaining--;
          *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
 800bd3c:	f806 3c03 	strb.w	r3, [r6, #-3]
          tempbuff++;
          dataremaining--;
          *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
 800bd40:	0c03      	lsrs	r3, r0, #16
          tempbuff++;
          dataremaining--;
          *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
 800bd42:	0e00      	lsrs	r0, r0, #24
          tempbuff++;
          dataremaining--;
          *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
          tempbuff++;
          dataremaining--;
          *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
 800bd44:	f806 3c02 	strb.w	r3, [r6, #-2]
          tempbuff++;
          dataremaining--;
          *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
 800bd48:	f806 0c01 	strb.w	r0, [r6, #-1]
 800bd4c:	3604      	adds	r6, #4
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
    {
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF) && (dataremaining > 0U))
      {
        /* Read data from SDMMC Rx FIFO */
        for(count = 0U; count < 8U; count++)
 800bd4e:	45b3      	cmp	fp, r6
 800bd50:	d1ee      	bne.n	800bd30 <HAL_SD_ReadBlocks+0xbc>
 800bd52:	3720      	adds	r7, #32
 800bd54:	3d20      	subs	r5, #32
          tempbuff++;
          dataremaining--;
        }
      }

      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
 800bd56:	f7fb f959 	bl	800700c <HAL_GetTick>
 800bd5a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800bd5c:	ebc9 0000 	rsb	r0, r9, r0
 800bd60:	4298      	cmp	r0, r3
 800bd62:	d3d9      	bcc.n	800bd18 <HAL_SD_ReadBlocks+0xa4>
      {
        /* Clear all the static flags */
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bd64:	6823      	ldr	r3, [r4, #0]
 800bd66:	4a30      	ldr	r2, [pc, #192]	; (800be28 <HAL_SD_ReadBlocks+0x1b4>)
 800bd68:	639a      	str	r2, [r3, #56]	; 0x38
        hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
 800bd6a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bd6c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800bd70:	63a3      	str	r3, [r4, #56]	; 0x38
        hsd->State= HAL_SD_STATE_READY;
 800bd72:	2301      	movs	r3, #1
 800bd74:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
 800bd78:	2300      	movs	r3, #0
 800bd7a:	6323      	str	r3, [r4, #48]	; 0x30
        return HAL_TIMEOUT;
 800bd7c:	2003      	movs	r0, #3
 800bd7e:	e050      	b.n	800be22 <HAL_SD_ReadBlocks+0x1ae>
      }
    }
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    __SDMMC_CMDTRANS_DISABLE( hsd->Instance);
 800bd80:	68c3      	ldr	r3, [r0, #12]
 800bd82:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800bd86:	60c3      	str	r3, [r0, #12]
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

    /* Send stop transmission command in case of multiblock read */
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 800bd88:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800bd8a:	05db      	lsls	r3, r3, #23
 800bd8c:	d50f      	bpl.n	800bdae <HAL_SD_ReadBlocks+0x13a>
 800bd8e:	f1b8 0f01 	cmp.w	r8, #1
 800bd92:	d90c      	bls.n	800bdae <HAL_SD_ReadBlocks+0x13a>
    {
      if(hsd->SdCard.CardType != CARD_SECURED)
 800bd94:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800bd96:	2b03      	cmp	r3, #3
 800bd98:	d009      	beq.n	800bdae <HAL_SD_ReadBlocks+0x13a>
      {
        /* Send stop transmission command */
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 800bd9a:	f001 f90b 	bl	800cfb4 <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
 800bd9e:	b130      	cbz	r0, 800bdae <HAL_SD_ReadBlocks+0x13a>
        {
          /* Clear all the static flags */
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bda0:	6823      	ldr	r3, [r4, #0]
 800bda2:	4a21      	ldr	r2, [pc, #132]	; (800be28 <HAL_SD_ReadBlocks+0x1b4>)
 800bda4:	639a      	str	r2, [r3, #56]	; 0x38
          hsd->ErrorCode |= errorstate;
 800bda6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bda8:	4318      	orrs	r0, r3
 800bdaa:	63a0      	str	r0, [r4, #56]	; 0x38
 800bdac:	e00a      	b.n	800bdc4 <HAL_SD_ReadBlocks+0x150>
        }
      }
    }

    /* Get error state */
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 800bdae:	6823      	ldr	r3, [r4, #0]
 800bdb0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800bdb2:	f012 0108 	ands.w	r1, r2, #8
 800bdb6:	d00b      	beq.n	800bdd0 <HAL_SD_ReadBlocks+0x15c>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bdb8:	4a1b      	ldr	r2, [pc, #108]	; (800be28 <HAL_SD_ReadBlocks+0x1b4>)
 800bdba:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
 800bdbc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bdbe:	f043 0308 	orr.w	r3, r3, #8
 800bdc2:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800bdc4:	2001      	movs	r0, #1
      hsd->Context = SD_CONTEXT_NONE;
 800bdc6:	2300      	movs	r3, #0
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
      hsd->State = HAL_SD_STATE_READY;
 800bdc8:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800bdcc:	6323      	str	r3, [r4, #48]	; 0x30
      return HAL_ERROR;
 800bdce:	e028      	b.n	800be22 <HAL_SD_ReadBlocks+0x1ae>
    }
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800bdd0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800bdd2:	f012 0202 	ands.w	r2, r2, #2
 800bdd6:	d00a      	beq.n	800bdee <HAL_SD_ReadBlocks+0x17a>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bdd8:	4a13      	ldr	r2, [pc, #76]	; (800be28 <HAL_SD_ReadBlocks+0x1b4>)
 800bdda:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 800bddc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800bdde:	2001      	movs	r0, #1
    }
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 800bde0:	f043 0302 	orr.w	r3, r3, #2
 800bde4:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800bde6:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800bdea:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
 800bdec:	e019      	b.n	800be22 <HAL_SD_ReadBlocks+0x1ae>
    }
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 800bdee:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800bdf0:	f010 0020 	ands.w	r0, r0, #32
 800bdf4:	d00a      	beq.n	800be0c <HAL_SD_ReadBlocks+0x198>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bdf6:	490c      	ldr	r1, [pc, #48]	; (800be28 <HAL_SD_ReadBlocks+0x1b4>)
 800bdf8:	6399      	str	r1, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
 800bdfa:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800bdfc:	2001      	movs	r0, #1
    }
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
 800bdfe:	f043 0320 	orr.w	r3, r3, #32
 800be02:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800be04:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800be08:	6322      	str	r2, [r4, #48]	; 0x30
      return HAL_ERROR;
 800be0a:	e00a      	b.n	800be22 <HAL_SD_ReadBlocks+0x1ae>
      }
    }
#endif /* !STM32L4P5xx && !STM32L4Q5xx && !STM32L4R5xx && !STM32L4R7xx && !STM32L4R9xx && !STM32L4S5xx && !STM32L4S7xx && !STM32L4S9xx */

    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800be0c:	4a07      	ldr	r2, [pc, #28]	; (800be2c <HAL_SD_ReadBlocks+0x1b8>)
 800be0e:	639a      	str	r2, [r3, #56]	; 0x38

    hsd->State = HAL_SD_STATE_READY;
 800be10:	2301      	movs	r3, #1
 800be12:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

    return HAL_OK;
 800be16:	e004      	b.n	800be22 <HAL_SD_ReadBlocks+0x1ae>
  }
  else
  {
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
 800be18:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800be1a:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800be1e:	63a3      	str	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
 800be20:	2001      	movs	r0, #1
  }
}
 800be22:	b006      	add	sp, #24
 800be24:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
 800be28:	1fe00fff 	.word	0x1fe00fff
 800be2c:	18000f3a 	.word	0x18000f3a

0800be30 <HAL_SD_WriteBlocks>:
  * @param  NumberOfBlocks Number of SD blocks to write
  * @param  Timeout Specify timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_WriteBlocks(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks, uint32_t Timeout)
{
 800be30:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800be34:	b088      	sub	sp, #32
 800be36:	4604      	mov	r4, r0
 800be38:	460e      	mov	r6, r1
 800be3a:	4691      	mov	r9, r2
 800be3c:	461f      	mov	r7, r3
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 800be3e:	f7fb f8e5 	bl	800700c <HAL_GetTick>
 800be42:	4680      	mov	r8, r0
  uint32_t count, data, dataremaining;
  uint32_t add = BlockAdd;
  uint8_t *tempbuff = pData;

  if(NULL == pData)
 800be44:	b91e      	cbnz	r6, 800be4e <HAL_SD_WriteBlocks+0x1e>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800be46:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800be48:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 800be4c:	e0b7      	b.n	800bfbe <HAL_SD_WriteBlocks+0x18e>
    return HAL_ERROR;
  }

  if(hsd->State == HAL_SD_STATE_READY)
 800be4e:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 800be52:	b2c0      	uxtb	r0, r0
 800be54:	2801      	cmp	r0, #1
 800be56:	f040 80af 	bne.w	800bfb8 <HAL_SD_WriteBlocks+0x188>
  {
    hsd->ErrorCode = HAL_SD_ERROR_NONE;

    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800be5a:	6d62      	ldr	r2, [r4, #84]	; 0x54
 800be5c:	eb09 0307 	add.w	r3, r9, r7
    return HAL_ERROR;
  }

  if(hsd->State == HAL_SD_STATE_READY)
  {
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800be60:	2100      	movs	r1, #0

    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800be62:	4293      	cmp	r3, r2
    return HAL_ERROR;
  }

  if(hsd->State == HAL_SD_STATE_READY)
  {
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800be64:	63a1      	str	r1, [r4, #56]	; 0x38

    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800be66:	d904      	bls.n	800be72 <HAL_SD_WriteBlocks+0x42>
    {
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 800be68:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800be6a:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800be6e:	63a3      	str	r3, [r4, #56]	; 0x38
      return HAL_ERROR;
 800be70:	e0a7      	b.n	800bfc2 <HAL_SD_WriteBlocks+0x192>
    }

    hsd->State = HAL_SD_STATE_BUSY;
 800be72:	2303      	movs	r3, #3
 800be74:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;

    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 800be78:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    }

    hsd->State = HAL_SD_STATE_BUSY;

    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;
 800be7a:	6820      	ldr	r0, [r4, #0]

    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 800be7c:	2b01      	cmp	r3, #1
    {
      add *= 512U;
    }

    /* Configure the SD DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800be7e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800be82:	9302      	str	r3, [sp, #8]
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
 800be84:	ea4f 2347 	mov.w	r3, r7, lsl #9
 800be88:	9303      	str	r3, [sp, #12]
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 800be8a:	f04f 0390 	mov.w	r3, #144	; 0x90
    }

    hsd->State = HAL_SD_STATE_BUSY;

    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;
 800be8e:	62c1      	str	r1, [r0, #44]	; 0x2c
    }

    /* Configure the SD DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 800be90:	9304      	str	r3, [sp, #16]
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    config.DPSM          = SDMMC_DPSM_DISABLE;
#else
    config.DPSM          = SDMMC_DPSM_ENABLE;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 800be92:	a902      	add	r1, sp, #8

    /* Configure the SD DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
 800be94:	f04f 0300 	mov.w	r3, #0
    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;

    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
    {
      add *= 512U;
 800be98:	bf18      	it	ne
 800be9a:	ea4f 2949 	movne.w	r9, r9, lsl #9

    /* Configure the SD DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
 800be9e:	9305      	str	r3, [sp, #20]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800bea0:	9306      	str	r3, [sp, #24]
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    config.DPSM          = SDMMC_DPSM_DISABLE;
 800bea2:	9307      	str	r3, [sp, #28]
#else
    config.DPSM          = SDMMC_DPSM_ENABLE;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 800bea4:	f000 feb0 	bl	800cc08 <SDMMC_ConfigData>
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
 800bea8:	6820      	ldr	r0, [r4, #0]
 800beaa:	68c3      	ldr	r3, [r0, #12]
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

    /* Write Blocks in Polling mode */
    if(NumberOfBlocks > 1U)
 800beac:	2f01      	cmp	r7, #1
#else
    config.DPSM          = SDMMC_DPSM_ENABLE;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
    (void)SDMMC_ConfigData(hsd->Instance, &config);
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
 800beae:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800beb2:	60c3      	str	r3, [r0, #12]
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

    /* Write Blocks in Polling mode */
    if(NumberOfBlocks > 1U)
 800beb4:	d905      	bls.n	800bec2 <HAL_SD_WriteBlocks+0x92>
    {
      hsd->Context = SD_CONTEXT_WRITE_MULTIPLE_BLOCK;
 800beb6:	2320      	movs	r3, #32
 800beb8:	6323      	str	r3, [r4, #48]	; 0x30

      /* Write Multi Block command */
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
 800beba:	4649      	mov	r1, r9
 800bebc:	f000 ffe4 	bl	800ce88 <SDMMC_CmdWriteMultiBlock>
 800bec0:	e004      	b.n	800becc <HAL_SD_WriteBlocks+0x9c>
    }
    else
    {
      hsd->Context = SD_CONTEXT_WRITE_SINGLE_BLOCK;
 800bec2:	2310      	movs	r3, #16
 800bec4:	6323      	str	r3, [r4, #48]	; 0x30

      /* Write Single Block command */
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
 800bec6:	4649      	mov	r1, r9
 800bec8:	f000 ffc5 	bl	800ce56 <SDMMC_CmdWriteSingleBlock>
    }
    if(errorstate != HAL_SD_ERROR_NONE)
 800becc:	2800      	cmp	r0, #0
 800bece:	d137      	bne.n	800bf40 <HAL_SD_WriteBlocks+0x110>
      hsd->Context = SD_CONTEXT_NONE;
      return HAL_ERROR;
    }

    /* Write block(s) in polling mode */
    dataremaining = config.DataLength;
 800bed0:	9d03      	ldr	r5, [sp, #12]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 800bed2:	6820      	ldr	r0, [r4, #0]
 800bed4:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800bed6:	f413 7f8d 	tst.w	r3, #282	; 0x11a
 800beda:	d122      	bne.n	800bf22 <HAL_SD_WriteBlocks+0xf2>
    {
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE) && (dataremaining > 0U))
 800bedc:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800bede:	045a      	lsls	r2, r3, #17
 800bee0:	d50c      	bpl.n	800befc <HAL_SD_WriteBlocks+0xcc>
 800bee2:	b15d      	cbz	r5, 800befc <HAL_SD_WriteBlocks+0xcc>
 800bee4:	f106 0a20 	add.w	sl, r6, #32
          tempbuff++;
          dataremaining--;
          data |= ((uint32_t)(*tempbuff) << 16U);
          tempbuff++;
          dataremaining--;
          data |= ((uint32_t)(*tempbuff) << 24U);
 800bee8:	f856 3b04 	ldr.w	r3, [r6], #4
          tempbuff++;
          dataremaining--;
          (void)SDMMC_WriteFIFO(hsd->Instance, &data);
 800beec:	6820      	ldr	r0, [r4, #0]
          tempbuff++;
          dataremaining--;
          data |= ((uint32_t)(*tempbuff) << 16U);
          tempbuff++;
          dataremaining--;
          data |= ((uint32_t)(*tempbuff) << 24U);
 800beee:	9301      	str	r3, [sp, #4]
          tempbuff++;
          dataremaining--;
          (void)SDMMC_WriteFIFO(hsd->Instance, &data);
 800bef0:	a901      	add	r1, sp, #4
 800bef2:	f000 fe50 	bl	800cb96 <SDMMC_WriteFIFO>
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
    {
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE) && (dataremaining > 0U))
      {
        /* Write data to SDMMC Tx FIFO */
        for(count = 0U; count < 8U; count++)
 800bef6:	45b2      	cmp	sl, r6
 800bef8:	d1f6      	bne.n	800bee8 <HAL_SD_WriteBlocks+0xb8>
 800befa:	3d20      	subs	r5, #32
          dataremaining--;
          (void)SDMMC_WriteFIFO(hsd->Instance, &data);
        }
      }

      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
 800befc:	f7fb f886 	bl	800700c <HAL_GetTick>
 800bf00:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800bf02:	ebc8 0000 	rsb	r0, r8, r0
 800bf06:	4298      	cmp	r0, r3
 800bf08:	d3e3      	bcc.n	800bed2 <HAL_SD_WriteBlocks+0xa2>
      {
        /* Clear all the static flags */
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bf0a:	6823      	ldr	r3, [r4, #0]
 800bf0c:	4a2e      	ldr	r2, [pc, #184]	; (800bfc8 <HAL_SD_WriteBlocks+0x198>)
 800bf0e:	639a      	str	r2, [r3, #56]	; 0x38
        hsd->ErrorCode |= errorstate;
 800bf10:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bf12:	63a3      	str	r3, [r4, #56]	; 0x38
        hsd->State = HAL_SD_STATE_READY;
 800bf14:	2301      	movs	r3, #1
 800bf16:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
 800bf1a:	2300      	movs	r3, #0
 800bf1c:	6323      	str	r3, [r4, #48]	; 0x30
        return HAL_TIMEOUT;
 800bf1e:	2003      	movs	r0, #3
 800bf20:	e04f      	b.n	800bfc2 <HAL_SD_WriteBlocks+0x192>
      }
    }
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    __SDMMC_CMDTRANS_DISABLE( hsd->Instance);
 800bf22:	68c3      	ldr	r3, [r0, #12]
 800bf24:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800bf28:	60c3      	str	r3, [r0, #12]
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

    /* Send stop transmission command in case of multiblock write */
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 800bf2a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800bf2c:	05db      	lsls	r3, r3, #23
 800bf2e:	d50e      	bpl.n	800bf4e <HAL_SD_WriteBlocks+0x11e>
 800bf30:	2f01      	cmp	r7, #1
 800bf32:	d90c      	bls.n	800bf4e <HAL_SD_WriteBlocks+0x11e>
    {
      if(hsd->SdCard.CardType != CARD_SECURED)
 800bf34:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800bf36:	2b03      	cmp	r3, #3
 800bf38:	d009      	beq.n	800bf4e <HAL_SD_WriteBlocks+0x11e>
      {
        /* Send stop transmission command */
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 800bf3a:	f001 f83b 	bl	800cfb4 <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
 800bf3e:	b130      	cbz	r0, 800bf4e <HAL_SD_WriteBlocks+0x11e>
        {
          /* Clear all the static flags */
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bf40:	6823      	ldr	r3, [r4, #0]
 800bf42:	4a21      	ldr	r2, [pc, #132]	; (800bfc8 <HAL_SD_WriteBlocks+0x198>)
 800bf44:	639a      	str	r2, [r3, #56]	; 0x38
          hsd->ErrorCode |= errorstate;
 800bf46:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bf48:	4318      	orrs	r0, r3
 800bf4a:	63a0      	str	r0, [r4, #56]	; 0x38
 800bf4c:	e00a      	b.n	800bf64 <HAL_SD_WriteBlocks+0x134>
        }
      }
    }

    /* Get error state */
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 800bf4e:	6823      	ldr	r3, [r4, #0]
 800bf50:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800bf52:	f012 0108 	ands.w	r1, r2, #8
 800bf56:	d00b      	beq.n	800bf70 <HAL_SD_WriteBlocks+0x140>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bf58:	4a1b      	ldr	r2, [pc, #108]	; (800bfc8 <HAL_SD_WriteBlocks+0x198>)
 800bf5a:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
 800bf5c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bf5e:	f043 0308 	orr.w	r3, r3, #8
 800bf62:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800bf64:	2001      	movs	r0, #1
      hsd->Context = SD_CONTEXT_NONE;
 800bf66:	2300      	movs	r3, #0
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
      hsd->State = HAL_SD_STATE_READY;
 800bf68:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800bf6c:	6323      	str	r3, [r4, #48]	; 0x30
      return HAL_ERROR;
 800bf6e:	e028      	b.n	800bfc2 <HAL_SD_WriteBlocks+0x192>
    }
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800bf70:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800bf72:	f012 0202 	ands.w	r2, r2, #2
 800bf76:	d00a      	beq.n	800bf8e <HAL_SD_WriteBlocks+0x15e>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bf78:	4a13      	ldr	r2, [pc, #76]	; (800bfc8 <HAL_SD_WriteBlocks+0x198>)
 800bf7a:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 800bf7c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800bf7e:	2001      	movs	r0, #1
    }
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 800bf80:	f043 0302 	orr.w	r3, r3, #2
 800bf84:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800bf86:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800bf8a:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
 800bf8c:	e019      	b.n	800bfc2 <HAL_SD_WriteBlocks+0x192>
    }
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR))
 800bf8e:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800bf90:	f010 0010 	ands.w	r0, r0, #16
 800bf94:	d00a      	beq.n	800bfac <HAL_SD_WriteBlocks+0x17c>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800bf96:	490c      	ldr	r1, [pc, #48]	; (800bfc8 <HAL_SD_WriteBlocks+0x198>)
 800bf98:	6399      	str	r1, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
 800bf9a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800bf9c:	2001      	movs	r0, #1
    }
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR))
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
 800bf9e:	f043 0310 	orr.w	r3, r3, #16
 800bfa2:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800bfa4:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800bfa8:	6322      	str	r2, [r4, #48]	; 0x30
      return HAL_ERROR;
 800bfaa:	e00a      	b.n	800bfc2 <HAL_SD_WriteBlocks+0x192>
    {
      /* Nothing to do */
    }

    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800bfac:	4a07      	ldr	r2, [pc, #28]	; (800bfcc <HAL_SD_WriteBlocks+0x19c>)
 800bfae:	639a      	str	r2, [r3, #56]	; 0x38

    hsd->State = HAL_SD_STATE_READY;
 800bfb0:	2301      	movs	r3, #1
 800bfb2:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

    return HAL_OK;
 800bfb6:	e004      	b.n	800bfc2 <HAL_SD_WriteBlocks+0x192>
  }
  else
  {
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
 800bfb8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bfba:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800bfbe:	63a3      	str	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
 800bfc0:	2001      	movs	r0, #1
  }
}
 800bfc2:	b008      	add	sp, #32
 800bfc4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800bfc8:	1fe00fff 	.word	0x1fe00fff
 800bfcc:	18000f3a 	.word	0x18000f3a

0800bfd0 <HAL_SD_GetState>:
  * @param hsd Pointer to sd handle
  * @retval HAL state
  */
HAL_SD_StateTypeDef HAL_SD_GetState(SD_HandleTypeDef *hsd)
{
  return hsd->State;
 800bfd0:	f890 0034 	ldrb.w	r0, [r0, #52]	; 0x34
}
 800bfd4:	4770      	bx	lr

0800bfd6 <HAL_SD_GetError>:
  *              the configuration information.
* @retval SD Error Code
*/
uint32_t HAL_SD_GetError(SD_HandleTypeDef *hsd)
{
  return hsd->ErrorCode;
 800bfd6:	6b80      	ldr	r0, [r0, #56]	; 0x38
}
 800bfd8:	4770      	bx	lr

0800bfda <HAL_SD_TxCpltCallback>:
 800bfda:	4770      	bx	lr

0800bfdc <HAL_SD_RxCpltCallback>:
 800bfdc:	4770      	bx	lr

0800bfde <HAL_SD_ErrorCallback>:
 800bfde:	4770      	bx	lr

0800bfe0 <HAL_SD_AbortCallback>:
  * @brief SD Abort callbacks
  * @param hsd Pointer SD handle
  * @retval None
  */
__weak void HAL_SD_AbortCallback(SD_HandleTypeDef *hsd)
{
 800bfe0:	4770      	bx	lr
	...

0800bfe4 <HAL_SD_GetCardCSD>:
  *         contains all CSD register parameters
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_GetCardCSD(SD_HandleTypeDef *hsd, HAL_SD_CardCSDTypeDef *pCSD)
{
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
 800bfe4:	6e03      	ldr	r3, [r0, #96]	; 0x60
 800bfe6:	0f9b      	lsrs	r3, r3, #30
 800bfe8:	700b      	strb	r3, [r1, #0]

  pCSD->SysSpecVersion = (uint8_t)((hsd->CSD[0] & 0x3C000000U) >> 26U);
 800bfea:	6e03      	ldr	r3, [r0, #96]	; 0x60
 800bfec:	f3c3 6383 	ubfx	r3, r3, #26, #4
 800bff0:	704b      	strb	r3, [r1, #1]

  pCSD->Reserved1 = (uint8_t)((hsd->CSD[0] & 0x03000000U) >> 24U);
 800bff2:	f890 3063 	ldrb.w	r3, [r0, #99]	; 0x63
 800bff6:	f003 0303 	and.w	r3, r3, #3
 800bffa:	708b      	strb	r3, [r1, #2]

  pCSD->TAAC = (uint8_t)((hsd->CSD[0] & 0x00FF0000U) >> 16U);
 800bffc:	f890 3062 	ldrb.w	r3, [r0, #98]	; 0x62
 800c000:	70cb      	strb	r3, [r1, #3]

  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
 800c002:	f890 3061 	ldrb.w	r3, [r0, #97]	; 0x61
 800c006:	710b      	strb	r3, [r1, #4]

  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
 800c008:	f890 3060 	ldrb.w	r3, [r0, #96]	; 0x60
 800c00c:	714b      	strb	r3, [r1, #5]

  pCSD->CardComdClasses = (uint16_t)((hsd->CSD[1] & 0xFFF00000U) >> 20U);
 800c00e:	6e43      	ldr	r3, [r0, #100]	; 0x64
 800c010:	0d1a      	lsrs	r2, r3, #20

  pCSD->RdBlockLen = (uint8_t)((hsd->CSD[1] & 0x000F0000U) >> 16U);
 800c012:	f3c3 4303 	ubfx	r3, r3, #16, #4

  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);

  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);

  pCSD->CardComdClasses = (uint16_t)((hsd->CSD[1] & 0xFFF00000U) >> 20U);
 800c016:	80ca      	strh	r2, [r1, #6]

  pCSD->RdBlockLen = (uint8_t)((hsd->CSD[1] & 0x000F0000U) >> 16U);
 800c018:	720b      	strb	r3, [r1, #8]

  pCSD->PartBlockRead   = (uint8_t)((hsd->CSD[1] & 0x00008000U) >> 15U);
 800c01a:	6e43      	ldr	r3, [r0, #100]	; 0x64
 800c01c:	f3c3 33c0 	ubfx	r3, r3, #15, #1
 800c020:	724b      	strb	r3, [r1, #9]

  pCSD->WrBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00004000U) >> 14U);
 800c022:	6e43      	ldr	r3, [r0, #100]	; 0x64
 800c024:	f3c3 3380 	ubfx	r3, r3, #14, #1
 800c028:	728b      	strb	r3, [r1, #10]

  pCSD->RdBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00002000U) >> 13U);
 800c02a:	6e43      	ldr	r3, [r0, #100]	; 0x64
 800c02c:	f3c3 3340 	ubfx	r3, r3, #13, #1
 800c030:	72cb      	strb	r3, [r1, #11]

  pCSD->DSRImpl = (uint8_t)((hsd->CSD[1] & 0x00001000U) >> 12U);
 800c032:	6e43      	ldr	r3, [r0, #100]	; 0x64
 800c034:	f3c3 3300 	ubfx	r3, r3, #12, #1
 800c038:	730b      	strb	r3, [r1, #12]

  pCSD->Reserved2 = 0U; /*!< Reserved */
 800c03a:	2300      	movs	r3, #0
 800c03c:	734b      	strb	r3, [r1, #13]

  if(hsd->SdCard.CardType == CARD_SDSC)
 800c03e:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
  * @param  pCSD Pointer to a HAL_SD_CardCSDTypeDef structure that
  *         contains all CSD register parameters
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_GetCardCSD(SD_HandleTypeDef *hsd, HAL_SD_CardCSDTypeDef *pCSD)
{
 800c040:	b510      	push	{r4, lr}

  pCSD->DSRImpl = (uint8_t)((hsd->CSD[1] & 0x00001000U) >> 12U);

  pCSD->Reserved2 = 0U; /*!< Reserved */

  if(hsd->SdCard.CardType == CARD_SDSC)
 800c042:	2b00      	cmp	r3, #0
 800c044:	d134      	bne.n	800c0b0 <HAL_SD_GetCardCSD+0xcc>
  {
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
 800c046:	6e43      	ldr	r3, [r0, #100]	; 0x64
 800c048:	6e82      	ldr	r2, [r0, #104]	; 0x68
 800c04a:	009c      	lsls	r4, r3, #2
 800c04c:	f640 73fc 	movw	r3, #4092	; 0xffc
 800c050:	4023      	ands	r3, r4
 800c052:	ea43 7392 	orr.w	r3, r3, r2, lsr #30

    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
 800c056:	f3c2 62c2 	ubfx	r2, r2, #27, #3

  pCSD->Reserved2 = 0U; /*!< Reserved */

  if(hsd->SdCard.CardType == CARD_SDSC)
  {
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
 800c05a:	610b      	str	r3, [r1, #16]

    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
 800c05c:	750a      	strb	r2, [r1, #20]

    pCSD->MaxRdCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x07000000U) >> 24U);
 800c05e:	f890 306b 	ldrb.w	r3, [r0, #107]	; 0x6b
 800c062:	f003 0307 	and.w	r3, r3, #7
 800c066:	754b      	strb	r3, [r1, #21]

    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x00E00000U) >> 21U);
 800c068:	6e83      	ldr	r3, [r0, #104]	; 0x68
 800c06a:	f3c3 5342 	ubfx	r3, r3, #21, #3
 800c06e:	758b      	strb	r3, [r1, #22]

    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
 800c070:	6e83      	ldr	r3, [r0, #104]	; 0x68
 800c072:	f3c3 4382 	ubfx	r3, r3, #18, #3
 800c076:	75cb      	strb	r3, [r1, #23]

    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
 800c078:	6e83      	ldr	r3, [r0, #104]	; 0x68
 800c07a:	f3c3 33c2 	ubfx	r3, r3, #15, #3
 800c07e:	760b      	strb	r3, [r1, #24]

    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
 800c080:	690b      	ldr	r3, [r1, #16]
 800c082:	1c5a      	adds	r2, r3, #1
 800c084:	64c2      	str	r2, [r0, #76]	; 0x4c
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
 800c086:	7e0b      	ldrb	r3, [r1, #24]
 800c088:	f003 0307 	and.w	r3, r3, #7
 800c08c:	2401      	movs	r4, #1
 800c08e:	3302      	adds	r3, #2
 800c090:	fa04 f303 	lsl.w	r3, r4, r3
 800c094:	4353      	muls	r3, r2
 800c096:	64c3      	str	r3, [r0, #76]	; 0x4c
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
 800c098:	7a0a      	ldrb	r2, [r1, #8]
 800c09a:	f002 020f 	and.w	r2, r2, #15
 800c09e:	fa04 f202 	lsl.w	r2, r4, r2
 800c0a2:	6502      	str	r2, [r0, #80]	; 0x50

    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U);
 800c0a4:	0a52      	lsrs	r2, r2, #9
 800c0a6:	4353      	muls	r3, r2
 800c0a8:	6543      	str	r3, [r0, #84]	; 0x54
    hsd->SdCard.LogBlockSize = 512U;
 800c0aa:	f44f 7300 	mov.w	r3, #512	; 0x200
 800c0ae:	e011      	b.n	800c0d4 <HAL_SD_GetCardCSD+0xf0>
  }
  else if(hsd->SdCard.CardType == CARD_SDHC_SDXC)
 800c0b0:	2b01      	cmp	r3, #1
 800c0b2:	d160      	bne.n	800c176 <HAL_SD_GetCardCSD+0x192>
  {
    /* Byte 7 */
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
 800c0b4:	6e43      	ldr	r3, [r0, #100]	; 0x64
 800c0b6:	f8b0 206a 	ldrh.w	r2, [r0, #106]	; 0x6a
 800c0ba:	041b      	lsls	r3, r3, #16
 800c0bc:	f403 137c 	and.w	r3, r3, #4128768	; 0x3f0000
 800c0c0:	4313      	orrs	r3, r2
 800c0c2:	610b      	str	r3, [r1, #16]

    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
 800c0c4:	690b      	ldr	r3, [r1, #16]
 800c0c6:	3301      	adds	r3, #1
 800c0c8:	029b      	lsls	r3, r3, #10
 800c0ca:	64c3      	str	r3, [r0, #76]	; 0x4c
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr;
 800c0cc:	6543      	str	r3, [r0, #84]	; 0x54
    hsd->SdCard.BlockSize = 512U;
 800c0ce:	f44f 7300 	mov.w	r3, #512	; 0x200
 800c0d2:	6503      	str	r3, [r0, #80]	; 0x50
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize;
 800c0d4:	6583      	str	r3, [r0, #88]	; 0x58
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
    hsd->State = HAL_SD_STATE_READY;
    return HAL_ERROR;
  }

  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
 800c0d6:	6e83      	ldr	r3, [r0, #104]	; 0x68
 800c0d8:	f3c3 3380 	ubfx	r3, r3, #14, #1
 800c0dc:	764b      	strb	r3, [r1, #25]

  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
 800c0de:	6e83      	ldr	r3, [r0, #104]	; 0x68
 800c0e0:	f3c3 13c6 	ubfx	r3, r3, #7, #7
 800c0e4:	768b      	strb	r3, [r1, #26]

  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
 800c0e6:	6e83      	ldr	r3, [r0, #104]	; 0x68
 800c0e8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800c0ec:	76cb      	strb	r3, [r1, #27]

  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
 800c0ee:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 800c0f0:	0fdb      	lsrs	r3, r3, #31
 800c0f2:	770b      	strb	r3, [r1, #28]

  pCSD->ManDeflECC = (uint8_t)((hsd->CSD[3] & 0x60000000U) >> 29U);
 800c0f4:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 800c0f6:	f3c3 7341 	ubfx	r3, r3, #29, #2
 800c0fa:	774b      	strb	r3, [r1, #29]

  pCSD->WrSpeedFact = (uint8_t)((hsd->CSD[3] & 0x1C000000U) >> 26U);
 800c0fc:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 800c0fe:	f3c3 6382 	ubfx	r3, r3, #26, #3
 800c102:	778b      	strb	r3, [r1, #30]

  pCSD->MaxWrBlockLen= (uint8_t)((hsd->CSD[3] & 0x03C00000U) >> 22U);
 800c104:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 800c106:	f3c3 5383 	ubfx	r3, r3, #22, #4
 800c10a:	77cb      	strb	r3, [r1, #31]

  pCSD->WriteBlockPaPartial = (uint8_t)((hsd->CSD[3] & 0x00200000U) >> 21U);
 800c10c:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 800c10e:	f3c3 5340 	ubfx	r3, r3, #21, #1
 800c112:	f881 3020 	strb.w	r3, [r1, #32]

  pCSD->Reserved3 = 0;
 800c116:	2300      	movs	r3, #0
 800c118:	f881 3021 	strb.w	r3, [r1, #33]	; 0x21

  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
 800c11c:	f8b0 206e 	ldrh.w	r2, [r0, #110]	; 0x6e
 800c120:	f002 0201 	and.w	r2, r2, #1
 800c124:	f881 2022 	strb.w	r2, [r1, #34]	; 0x22

  pCSD->FileFormatGroup = (uint8_t)((hsd->CSD[3] & 0x00008000U) >> 15U);
 800c128:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 800c12a:	f3c2 32c0 	ubfx	r2, r2, #15, #1
 800c12e:	f881 2023 	strb.w	r2, [r1, #35]	; 0x23

  pCSD->CopyFlag = (uint8_t)((hsd->CSD[3] & 0x00004000U) >> 14U);
 800c132:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 800c134:	f3c2 3280 	ubfx	r2, r2, #14, #1
 800c138:	f881 2024 	strb.w	r2, [r1, #36]	; 0x24

  pCSD->PermWrProtect = (uint8_t)((hsd->CSD[3] & 0x00002000U) >> 13U);
 800c13c:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 800c13e:	f3c2 3240 	ubfx	r2, r2, #13, #1
 800c142:	f881 2025 	strb.w	r2, [r1, #37]	; 0x25

  pCSD->TempWrProtect = (uint8_t)((hsd->CSD[3] & 0x00001000U) >> 12U);
 800c146:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 800c148:	f3c2 3200 	ubfx	r2, r2, #12, #1
 800c14c:	f881 2026 	strb.w	r2, [r1, #38]	; 0x26

  pCSD->FileFormat = (uint8_t)((hsd->CSD[3] & 0x00000C00U) >> 10U);
 800c150:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 800c152:	f3c2 2281 	ubfx	r2, r2, #10, #2
 800c156:	f881 2027 	strb.w	r2, [r1, #39]	; 0x27

  pCSD->ECC= (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
 800c15a:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 800c15c:	f3c2 2201 	ubfx	r2, r2, #8, #2
 800c160:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28

  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
 800c164:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 800c166:	f3c2 0246 	ubfx	r2, r2, #1, #7
 800c16a:	f881 2029 	strb.w	r2, [r1, #41]	; 0x29

  pCSD->Reserved4 = 1;
 800c16e:	2201      	movs	r2, #1
 800c170:	f881 202a 	strb.w	r2, [r1, #42]	; 0x2a
 800c174:	e009      	b.n	800c18a <HAL_SD_GetCardCSD+0x1a6>
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize;
  }
  else
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800c176:	6803      	ldr	r3, [r0, #0]
 800c178:	4a05      	ldr	r2, [pc, #20]	; (800c190 <HAL_SD_GetCardCSD+0x1ac>)
 800c17a:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800c17c:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800c17e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800c182:	6383      	str	r3, [r0, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800c184:	2301      	movs	r3, #1
 800c186:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34

  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);

  pCSD->Reserved4 = 1;

  return HAL_OK;
 800c18a:	4618      	mov	r0, r3
}
 800c18c:	bd10      	pop	{r4, pc}
 800c18e:	bf00      	nop
 800c190:	1fe00fff 	.word	0x1fe00fff

0800c194 <HAL_SD_InitCard>:
  * @note   This function initializes the SD card. It could be used when a card
            re-initialization is needed.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_InitCard(SD_HandleTypeDef *hsd)
{
 800c194:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c196:	b099      	sub	sp, #100	; 0x64
  HAL_StatusTypeDef status;
  SD_InitTypeDef Init;
  uint32_t sdmmc_clk;

  /* Default SDMMC peripheral configuration for SD card initialization */
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
 800c198:	2300      	movs	r3, #0
  * @note   This function initializes the SD card. It could be used when a card
            re-initialization is needed.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_InitCard(SD_HandleTypeDef *hsd)
{
 800c19a:	4604      	mov	r4, r0
  Init.ClockPowerSave      = SDMMC_CLOCK_POWER_SAVE_DISABLE;
  Init.BusWide             = SDMMC_BUS_WIDE_1B;
  Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;

  /* Init Clock should be less or equal to 400Khz*/
  sdmmc_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC1);
 800c19c:	f44f 2000 	mov.w	r0, #524288	; 0x80000
  HAL_StatusTypeDef status;
  SD_InitTypeDef Init;
  uint32_t sdmmc_clk;

  /* Default SDMMC peripheral configuration for SD card initialization */
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
 800c1a0:	9307      	str	r3, [sp, #28]
#if !defined(STM32L4P5xx) && !defined(STM32L4Q5xx) && !defined(STM32L4R5xx) && !defined(STM32L4R7xx) && !defined(STM32L4R9xx) && !defined(STM32L4S5xx) && !defined(STM32L4S7xx) && !defined(STM32L4S9xx)
  Init.ClockBypass         = SDMMC_CLOCK_BYPASS_DISABLE;
#endif /* !STM32L4P5xx && !STM32L4Q5xx && !STM32L4R5xx && !STM32L4R7xx && !STM32L4R9xx && !STM32L4S5xx && !STM32L4S7xx && !STM32L4S9xx */
  Init.ClockPowerSave      = SDMMC_CLOCK_POWER_SAVE_DISABLE;
 800c1a2:	9308      	str	r3, [sp, #32]
  Init.BusWide             = SDMMC_BUS_WIDE_1B;
 800c1a4:	9309      	str	r3, [sp, #36]	; 0x24
  Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
 800c1a6:	930a      	str	r3, [sp, #40]	; 0x28

  /* Init Clock should be less or equal to 400Khz*/
  sdmmc_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC1);
 800c1a8:	f7fd fae2 	bl	8009770 <HAL_RCCEx_GetPeriphCLKFreq>
  if (sdmmc_clk == 0U)
 800c1ac:	4606      	mov	r6, r0
 800c1ae:	b928      	cbnz	r0, 800c1bc <HAL_SD_InitCard+0x28>
  {
      hsd->State = HAL_SD_STATE_READY;
 800c1b0:	2001      	movs	r0, #1
 800c1b2:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
      hsd->ErrorCode = SDMMC_ERROR_INVALID_PARAMETER;
 800c1b6:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800c1ba:	e0d4      	b.n	800c366 <HAL_SD_InitCard+0x1d2>
#else
  Init.ClockDiv = sdmmc_clk / (2U * SD_INIT_FREQ);
#endif

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  Init.Transceiver = hsd->Init.Transceiver;
 800c1bc:	69a3      	ldr	r3, [r4, #24]
 800c1be:	6827      	ldr	r7, [r4, #0]
 800c1c0:	930c      	str	r3, [sp, #48]	; 0x30
  if(hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE)
 800c1c2:	2b01      	cmp	r3, #1
  {
    /* Set Transceiver polarity */
    hsd->Instance->POWER |= SDMMC_POWER_DIRPOL;
 800c1c4:	bf08      	it	eq
 800c1c6:	683b      	ldreq	r3, [r7, #0]
      return HAL_ERROR;
  }
#if !defined(STM32L4P5xx) && !defined(STM32L4Q5xx) && !defined(STM32L4R5xx) && !defined(STM32L4R7xx) && !defined(STM32L4R9xx) && !defined(STM32L4S5xx) && !defined(STM32L4S7xx) && !defined(STM32L4S9xx)
  Init.ClockDiv = ((sdmmc_clk / SD_INIT_FREQ) - 2U);
#else
  Init.ClockDiv = sdmmc_clk / (2U * SD_INIT_FREQ);
 800c1c8:	4d9e      	ldr	r5, [pc, #632]	; (800c444 <HAL_SD_InitCard+0x2b0>)
 800c1ca:	fbb0 f5f5 	udiv	r5, r0, r5
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  Init.Transceiver = hsd->Init.Transceiver;
  if(hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE)
  {
    /* Set Transceiver polarity */
    hsd->Instance->POWER |= SDMMC_POWER_DIRPOL;
 800c1ce:	bf04      	itt	eq
 800c1d0:	f043 0310 	orreq.w	r3, r3, #16
 800c1d4:	603b      	streq	r3, [r7, #0]
  }
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

  /* Initialize SDMMC peripheral interface with default configuration */
  status = SDMMC_Init(hsd->Instance, Init);
 800c1d6:	950b      	str	r5, [sp, #44]	; 0x2c
 800c1d8:	ab0a      	add	r3, sp, #40	; 0x28
 800c1da:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800c1de:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 800c1e2:	ab07      	add	r3, sp, #28
 800c1e4:	cb0e      	ldmia	r3, {r1, r2, r3}
 800c1e6:	4638      	mov	r0, r7
 800c1e8:	f000 fcb8 	bl	800cb5c <SDMMC_Init>
  if(status != HAL_OK)
 800c1ec:	b108      	cbz	r0, 800c1f2 <HAL_SD_InitCard+0x5e>
  {
    return HAL_ERROR;
 800c1ee:	2001      	movs	r0, #1
 800c1f0:	e125      	b.n	800c43e <HAL_SD_InitCard+0x2aa>
  /* Disable SDMMC Clock */
  __HAL_SD_DISABLE(hsd);
#endif /* !STM32L4P5xx && !STM32L4Q5xx && !STM32L4R5xx && !STM32L4R7xx && !STM32L4R9xx && !STM32L4S5xx && !STM32L4S7xx && !STM32L4S9xx */

  /* Set Power State to ON */
  status = SDMMC_PowerState_ON(hsd->Instance);
 800c1f2:	6820      	ldr	r0, [r4, #0]
 800c1f4:	f000 fcd4 	bl	800cba0 <SDMMC_PowerState_ON>
  if(status != HAL_OK)
 800c1f8:	4607      	mov	r7, r0
 800c1fa:	2800      	cmp	r0, #0
 800c1fc:	d1f7      	bne.n	800c1ee <HAL_SD_InitCard+0x5a>
#if !defined(STM32L4P5xx) && !defined(STM32L4Q5xx) && !defined(STM32L4R5xx) && !defined(STM32L4R7xx) && !defined(STM32L4R9xx) && !defined(STM32L4S5xx) && !defined(STM32L4S7xx) && !defined(STM32L4S9xx)
  sdmmc_clk = sdmmc_clk/(Init.ClockDiv + 2U);
#else
  sdmmc_clk = sdmmc_clk/(2U*Init.ClockDiv);
#endif
  HAL_Delay(1U+ (74U*1000U/(sdmmc_clk)));
 800c1fe:	006d      	lsls	r5, r5, #1
 800c200:	4891      	ldr	r0, [pc, #580]	; (800c448 <HAL_SD_InitCard+0x2b4>)
 800c202:	fbb6 f5f5 	udiv	r5, r6, r5
 800c206:	fbb0 f0f5 	udiv	r0, r0, r5
 800c20a:	3001      	adds	r0, #1
 800c20c:	f7f7 fb4a 	bl	80038a4 <HAL_Delay>
  * @param  hsd Pointer to SD handle
  * @retval error state
  */
static uint32_t SD_PowerON(SD_HandleTypeDef *hsd)
{
  __IO uint32_t count = 0U;
 800c210:	9706      	str	r7, [sp, #24]
  uint32_t response = 0U, validvoltage = 0U;
  uint32_t errorstate;
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  uint32_t tickstart = HAL_GetTick();
 800c212:	f7fa fefb 	bl	800700c <HAL_GetTick>
 800c216:	4606      	mov	r6, r0
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

  /* CMD0: GO_IDLE_STATE */
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 800c218:	6820      	ldr	r0, [r4, #0]
 800c21a:	f000 fd15 	bl	800cc48 <SDMMC_CmdGoIdleState>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c21e:	4605      	mov	r5, r0
 800c220:	2800      	cmp	r0, #0
 800c222:	f040 80a2 	bne.w	800c36a <HAL_SD_InitCard+0x1d6>
  {
    return errorstate;
  }

  /* CMD8: SEND_IF_COND: Command available only on V2.0 cards */
  errorstate = SDMMC_CmdOperCond(hsd->Instance);
 800c226:	6820      	ldr	r0, [r4, #0]
 800c228:	f001 f900 	bl	800d42c <SDMMC_CmdOperCond>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c22c:	b128      	cbz	r0, 800c23a <HAL_SD_InitCard+0xa6>
  {
    hsd->SdCard.CardVersion = CARD_V1_X;
 800c22e:	6425      	str	r5, [r4, #64]	; 0x40
    /* CMD0: GO_IDLE_STATE */
    errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 800c230:	6820      	ldr	r0, [r4, #0]
 800c232:	f000 fd09 	bl	800cc48 <SDMMC_CmdGoIdleState>
    if(errorstate != HAL_SD_ERROR_NONE)
 800c236:	b110      	cbz	r0, 800c23e <HAL_SD_InitCard+0xaa>
 800c238:	e097      	b.n	800c36a <HAL_SD_InitCard+0x1d6>
    }

  }
  else
  {
    hsd->SdCard.CardVersion = CARD_V2_X;
 800c23a:	2301      	movs	r3, #1
 800c23c:	6423      	str	r3, [r4, #64]	; 0x40
  }

  if( hsd->SdCard.CardVersion == CARD_V2_X)
 800c23e:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800c240:	2b01      	cmp	r3, #1
 800c242:	d004      	beq.n	800c24e <HAL_SD_InitCard+0xba>
  * @note   This function initializes the SD card. It could be used when a card
            re-initialization is needed.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_InitCard(SD_HandleTypeDef *hsd)
{
 800c244:	2500      	movs	r5, #0
 800c246:	4628      	mov	r0, r5
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
    }
  }
  /* SD CARD */
  /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 800c248:	f64f 77fe 	movw	r7, #65534	; 0xfffe
 800c24c:	e01d      	b.n	800c28a <HAL_SD_InitCard+0xf6>
  }

  if( hsd->SdCard.CardVersion == CARD_V2_X)
  {
    /* SEND CMD55 APP_CMD with RCA as 0 */
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 800c24e:	2100      	movs	r1, #0
 800c250:	6820      	ldr	r0, [r4, #0]
 800c252:	f000 feee 	bl	800d032 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 800c256:	2800      	cmp	r0, #0
 800c258:	d0f4      	beq.n	800c244 <HAL_SD_InitCard+0xb0>
    {
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800c25a:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 800c25e:	e084      	b.n	800c36a <HAL_SD_InitCard+0x1d6>
    }
  }
  /* SD CARD */
  /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 800c260:	b9b5      	cbnz	r5, 800c290 <HAL_SD_InitCard+0xfc>
  {
    /* SEND CMD55 APP_CMD with RCA as 0 */
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 800c262:	4629      	mov	r1, r5
 800c264:	6820      	ldr	r0, [r4, #0]
 800c266:	f000 fee4 	bl	800d032 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 800c26a:	2800      	cmp	r0, #0
 800c26c:	d17d      	bne.n	800c36a <HAL_SD_InitCard+0x1d6>
    {
      return errorstate;
    }

    /* Send CMD41 */
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
 800c26e:	4977      	ldr	r1, [pc, #476]	; (800c44c <HAL_SD_InitCard+0x2b8>)
 800c270:	6820      	ldr	r0, [r4, #0]
 800c272:	f001 f825 	bl	800d2c0 <SDMMC_CmdAppOperCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 800c276:	2800      	cmp	r0, #0
 800c278:	d1ef      	bne.n	800c25a <HAL_SD_InitCard+0xc6>
    {
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
    }

    /* Get command response */
    response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800c27a:	4629      	mov	r1, r5
 800c27c:	6820      	ldr	r0, [r4, #0]
 800c27e:	f000 fcc0 	bl	800cc02 <SDMMC_GetResponse>

    /* Get operating voltage*/
    validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);

    count++;
 800c282:	9b06      	ldr	r3, [sp, #24]
 800c284:	3301      	adds	r3, #1

    /* Get command response */
    response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);

    /* Get operating voltage*/
    validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
 800c286:	0fc5      	lsrs	r5, r0, #31

    count++;
 800c288:	9306      	str	r3, [sp, #24]
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
    }
  }
  /* SD CARD */
  /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 800c28a:	9b06      	ldr	r3, [sp, #24]
 800c28c:	42bb      	cmp	r3, r7
 800c28e:	d9e7      	bls.n	800c260 <HAL_SD_InitCard+0xcc>
    validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);

    count++;
  }

  if(count >= SDMMC_MAX_VOLT_TRIAL)
 800c290:	9a06      	ldr	r2, [sp, #24]
 800c292:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 800c296:	429a      	cmp	r2, r3
 800c298:	d902      	bls.n	800c2a0 <HAL_SD_InitCard+0x10c>
  {
    return HAL_SD_ERROR_INVALID_VOLTRANGE;
 800c29a:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
 800c29e:	e064      	b.n	800c36a <HAL_SD_InitCard+0x1d6>
  }

  if((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
 800c2a0:	f010 4380 	ands.w	r3, r0, #1073741824	; 0x40000000
 800c2a4:	d042      	beq.n	800c32c <HAL_SD_InitCard+0x198>
  {
    hsd->SdCard.CardType = CARD_SDHC_SDXC;
 800c2a6:	2301      	movs	r3, #1
 800c2a8:	63e3      	str	r3, [r4, #60]	; 0x3c
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    if(hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE)
 800c2aa:	69a3      	ldr	r3, [r4, #24]
 800c2ac:	2b01      	cmp	r3, #1
 800c2ae:	d13e      	bne.n	800c32e <HAL_SD_InitCard+0x19a>
    {
      if((response & SD_SWITCH_1_8V_CAPACITY) == SD_SWITCH_1_8V_CAPACITY)
 800c2b0:	01c7      	lsls	r7, r0, #7
 800c2b2:	d53c      	bpl.n	800c32e <HAL_SD_InitCard+0x19a>
      {
        hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;

        /* Start switching procedue */
        hsd->Instance->POWER |= SDMMC_POWER_VSWITCHEN;
 800c2b4:	6820      	ldr	r0, [r4, #0]
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    if(hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE)
    {
      if((response & SD_SWITCH_1_8V_CAPACITY) == SD_SWITCH_1_8V_CAPACITY)
      {
        hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
 800c2b6:	f44f 7300 	mov.w	r3, #512	; 0x200
 800c2ba:	65e3      	str	r3, [r4, #92]	; 0x5c

        /* Start switching procedue */
        hsd->Instance->POWER |= SDMMC_POWER_VSWITCHEN;
 800c2bc:	6803      	ldr	r3, [r0, #0]
 800c2be:	f043 0308 	orr.w	r3, r3, #8
 800c2c2:	6003      	str	r3, [r0, #0]

        /* Send CMD11 to switch 1.8V mode */
        errorstate = SDMMC_CmdVoltageSwitch(hsd->Instance);
 800c2c4:	f000 ff4e 	bl	800d164 <SDMMC_CmdVoltageSwitch>
        if(errorstate != HAL_SD_ERROR_NONE)
 800c2c8:	2800      	cmp	r0, #0
 800c2ca:	d14e      	bne.n	800c36a <HAL_SD_InitCard+0x1d6>
        {
          return errorstate;
        }

        /* Check to CKSTOP */
        while(( hsd->Instance->STA & SDMMC_FLAG_CKSTOP) != SDMMC_FLAG_CKSTOP)
 800c2cc:	6823      	ldr	r3, [r4, #0]
 800c2ce:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c2d0:	0155      	lsls	r5, r2, #5
 800c2d2:	d407      	bmi.n	800c2e4 <HAL_SD_InitCard+0x150>
        {
          if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 800c2d4:	f7fa fe9a 	bl	800700c <HAL_GetTick>
 800c2d8:	1b80      	subs	r0, r0, r6
 800c2da:	3001      	adds	r0, #1
 800c2dc:	d1f6      	bne.n	800c2cc <HAL_SD_InitCard+0x138>
          {
            return HAL_SD_ERROR_TIMEOUT;
 800c2de:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800c2e2:	e042      	b.n	800c36a <HAL_SD_InitCard+0x1d6>
          }
        }

        /* Clear CKSTOP Flag */
        hsd->Instance->ICR = SDMMC_FLAG_CKSTOP;
 800c2e4:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 800c2e8:	639a      	str	r2, [r3, #56]	; 0x38

        /* Check to BusyD0 */
        if(( hsd->Instance->STA & SDMMC_FLAG_BUSYD0) != SDMMC_FLAG_BUSYD0)
 800c2ea:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800c2ec:	02d8      	lsls	r0, r3, #11
 800c2ee:	d5b4      	bpl.n	800c25a <HAL_SD_InitCard+0xc6>
        {
          /* Enable Transceiver Switch PIN */
#if defined (USE_HAL_SD_REGISTER_CALLBACKS) && (USE_HAL_SD_REGISTER_CALLBACKS == 1U)
          hsd->DriveTransceiver_1_8V_Callback(SET);
#else
          HAL_SDEx_DriveTransceiver_1_8V_Callback(SET);
 800c2f0:	2001      	movs	r0, #1
 800c2f2:	f7fa fefb 	bl	80070ec <HAL_SDEx_DriveTransceiver_1_8V_Callback>
#endif

          /* Switch ready */
          hsd->Instance->POWER |= SDMMC_POWER_VSWITCH;
 800c2f6:	6822      	ldr	r2, [r4, #0]
 800c2f8:	6813      	ldr	r3, [r2, #0]
 800c2fa:	f043 0304 	orr.w	r3, r3, #4
 800c2fe:	6013      	str	r3, [r2, #0]

          /* Check VSWEND Flag */
          while(( hsd->Instance->STA & SDMMC_FLAG_VSWEND) != SDMMC_FLAG_VSWEND)
 800c300:	6823      	ldr	r3, [r4, #0]
 800c302:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c304:	0191      	lsls	r1, r2, #6
 800c306:	d405      	bmi.n	800c314 <HAL_SD_InitCard+0x180>
          {
            if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 800c308:	f7fa fe80 	bl	800700c <HAL_GetTick>
 800c30c:	1b80      	subs	r0, r0, r6
 800c30e:	3001      	adds	r0, #1
 800c310:	d1f6      	bne.n	800c300 <HAL_SD_InitCard+0x16c>
 800c312:	e7e4      	b.n	800c2de <HAL_SD_InitCard+0x14a>
              return HAL_SD_ERROR_TIMEOUT;
            }
          }

          /* Clear VSWEND Flag */
          hsd->Instance->ICR = SDMMC_FLAG_VSWEND;
 800c314:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 800c318:	639a      	str	r2, [r3, #56]	; 0x38

          /* Check BusyD0 status */
          if(( hsd->Instance->STA & SDMMC_FLAG_BUSYD0) == SDMMC_FLAG_BUSYD0)
 800c31a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c31c:	02d2      	lsls	r2, r2, #11
 800c31e:	d4bc      	bmi.n	800c29a <HAL_SD_InitCard+0x106>
            return HAL_SD_ERROR_INVALID_VOLTRANGE;
          }
          /* Switch to 1.8V OK */

          /* Disable VSWITCH FLAG from SDMMC Peripheral */
          hsd->Instance->POWER = 0x13U;
 800c320:	2213      	movs	r2, #19
 800c322:	601a      	str	r2, [r3, #0]

          /* Clean Status flags */
          hsd->Instance->ICR = 0xFFFFFFFFU;
 800c324:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800c328:	639a      	str	r2, [r3, #56]	; 0x38
 800c32a:	e000      	b.n	800c32e <HAL_SD_InitCard+0x19a>
    }
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
  }
  else
  {
    hsd->SdCard.CardType = CARD_SDSC;
 800c32c:	63e3      	str	r3, [r4, #60]	; 0x3c
  */
static uint32_t SD_InitCard(SD_HandleTypeDef *hsd)
{
  HAL_SD_CardCSDTypeDef CSD;
  uint32_t errorstate;
  uint16_t sd_rca = 1U;
 800c32e:	2301      	movs	r3, #1

  /* Check the power State */
  if(SDMMC_GetPowerState(hsd->Instance) == 0U)
 800c330:	6820      	ldr	r0, [r4, #0]
  */
static uint32_t SD_InitCard(SD_HandleTypeDef *hsd)
{
  HAL_SD_CardCSDTypeDef CSD;
  uint32_t errorstate;
  uint16_t sd_rca = 1U;
 800c332:	f8ad 3016 	strh.w	r3, [sp, #22]

  /* Check the power State */
  if(SDMMC_GetPowerState(hsd->Instance) == 0U)
 800c336:	f000 fc49 	bl	800cbcc <SDMMC_GetPowerState>
 800c33a:	2800      	cmp	r0, #0
 800c33c:	d06c      	beq.n	800c418 <HAL_SD_InitCard+0x284>
  {
    /* Power off */
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
  }

  if(hsd->SdCard.CardType != CARD_SECURED)
 800c33e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800c340:	2b03      	cmp	r3, #3
 800c342:	d11a      	bne.n	800c37a <HAL_SD_InitCard+0x1e6>
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
    }
  }

  if(hsd->SdCard.CardType != CARD_SECURED)
 800c344:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800c346:	2b03      	cmp	r3, #3
 800c348:	d031      	beq.n	800c3ae <HAL_SD_InitCard+0x21a>
  {
    /* Send CMD3 SET_REL_ADDR with argument 0 */
    /* SD Card publishes its RCA. */
    errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
 800c34a:	f10d 0116 	add.w	r1, sp, #22
 800c34e:	6820      	ldr	r0, [r4, #0]
 800c350:	f001 f824 	bl	800d39c <SDMMC_CmdSetRelAdd>
    if(errorstate != HAL_SD_ERROR_NONE)
 800c354:	b358      	cbz	r0, 800c3ae <HAL_SD_InitCard+0x21a>
    /* Get the SD card RCA */
    hsd->SdCard.RelCardAdd = sd_rca;

    /* Send CMD9 SEND_CSD with argument as card's RCA */
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
    if(errorstate != HAL_SD_ERROR_NONE)
 800c356:	4605      	mov	r5, r0
    return HAL_ERROR;
  }

  /* Card initialization */
  errorstate = SD_InitCard(hsd);
  if(errorstate != HAL_SD_ERROR_NONE)
 800c358:	2800      	cmp	r0, #0
 800c35a:	d060      	beq.n	800c41e <HAL_SD_InitCard+0x28a>
  {
    hsd->State = HAL_SD_STATE_READY;
 800c35c:	2001      	movs	r0, #1
 800c35e:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
 800c362:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c364:	432b      	orrs	r3, r5
 800c366:	63a3      	str	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
 800c368:	e069      	b.n	800c43e <HAL_SD_InitCard+0x2aa>

  /* Identify card operating voltage */
  errorstate = SD_PowerON(hsd);
  if(errorstate != HAL_SD_ERROR_NONE)
  {
    hsd->State = HAL_SD_STATE_READY;
 800c36a:	2501      	movs	r5, #1
 800c36c:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
 800c370:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c372:	4318      	orrs	r0, r3
 800c374:	63a0      	str	r0, [r4, #56]	; 0x38
    return HAL_ERROR;
 800c376:	4628      	mov	r0, r5
 800c378:	e061      	b.n	800c43e <HAL_SD_InitCard+0x2aa>
  }

  if(hsd->SdCard.CardType != CARD_SECURED)
  {
    /* Send CMD2 ALL_SEND_CID */
    errorstate = SDMMC_CmdSendCID(hsd->Instance);
 800c37a:	6820      	ldr	r0, [r4, #0]
 800c37c:	f000 ff4e 	bl	800d21c <SDMMC_CmdSendCID>
    if(errorstate != HAL_SD_ERROR_NONE)
 800c380:	2800      	cmp	r0, #0
 800c382:	d1e8      	bne.n	800c356 <HAL_SD_InitCard+0x1c2>
      return errorstate;
    }
    else
    {
      /* Get Card identification number data */
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800c384:	4601      	mov	r1, r0
 800c386:	6820      	ldr	r0, [r4, #0]
 800c388:	f000 fc3b 	bl	800cc02 <SDMMC_GetResponse>
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800c38c:	2104      	movs	r1, #4
      return errorstate;
    }
    else
    {
      /* Get Card identification number data */
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800c38e:	6720      	str	r0, [r4, #112]	; 0x70
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800c390:	6820      	ldr	r0, [r4, #0]
 800c392:	f000 fc36 	bl	800cc02 <SDMMC_GetResponse>
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800c396:	2108      	movs	r1, #8
    }
    else
    {
      /* Get Card identification number data */
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800c398:	6760      	str	r0, [r4, #116]	; 0x74
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800c39a:	6820      	ldr	r0, [r4, #0]
 800c39c:	f000 fc31 	bl	800cc02 <SDMMC_GetResponse>
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 800c3a0:	210c      	movs	r1, #12
    else
    {
      /* Get Card identification number data */
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800c3a2:	67a0      	str	r0, [r4, #120]	; 0x78
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 800c3a4:	6820      	ldr	r0, [r4, #0]
 800c3a6:	f000 fc2c 	bl	800cc02 <SDMMC_GetResponse>
 800c3aa:	67e0      	str	r0, [r4, #124]	; 0x7c
 800c3ac:	e7ca      	b.n	800c344 <HAL_SD_InitCard+0x1b0>
    if(errorstate != HAL_SD_ERROR_NONE)
    {
      return errorstate;
    }
  }
  if(hsd->SdCard.CardType != CARD_SECURED)
 800c3ae:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800c3b0:	2b03      	cmp	r3, #3
 800c3b2:	d01c      	beq.n	800c3ee <HAL_SD_InitCard+0x25a>
  {
    /* Get the SD card RCA */
    hsd->SdCard.RelCardAdd = sd_rca;
 800c3b4:	f8bd 1016 	ldrh.w	r1, [sp, #22]
 800c3b8:	64a1      	str	r1, [r4, #72]	; 0x48

    /* Send CMD9 SEND_CSD with argument as card's RCA */
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800c3ba:	6820      	ldr	r0, [r4, #0]
 800c3bc:	0409      	lsls	r1, r1, #16
 800c3be:	f000 ff43 	bl	800d248 <SDMMC_CmdSendCSD>
    if(errorstate != HAL_SD_ERROR_NONE)
 800c3c2:	2800      	cmp	r0, #0
 800c3c4:	d1c7      	bne.n	800c356 <HAL_SD_InitCard+0x1c2>
      return errorstate;
    }
    else
    {
      /* Get Card Specific Data */
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800c3c6:	4601      	mov	r1, r0
 800c3c8:	6820      	ldr	r0, [r4, #0]
 800c3ca:	f000 fc1a 	bl	800cc02 <SDMMC_GetResponse>
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800c3ce:	2104      	movs	r1, #4
      return errorstate;
    }
    else
    {
      /* Get Card Specific Data */
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800c3d0:	6620      	str	r0, [r4, #96]	; 0x60
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800c3d2:	6820      	ldr	r0, [r4, #0]
 800c3d4:	f000 fc15 	bl	800cc02 <SDMMC_GetResponse>
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800c3d8:	2108      	movs	r1, #8
    }
    else
    {
      /* Get Card Specific Data */
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800c3da:	6660      	str	r0, [r4, #100]	; 0x64
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800c3dc:	6820      	ldr	r0, [r4, #0]
 800c3de:	f000 fc10 	bl	800cc02 <SDMMC_GetResponse>
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 800c3e2:	210c      	movs	r1, #12
    else
    {
      /* Get Card Specific Data */
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800c3e4:	66a0      	str	r0, [r4, #104]	; 0x68
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 800c3e6:	6820      	ldr	r0, [r4, #0]
 800c3e8:	f000 fc0b 	bl	800cc02 <SDMMC_GetResponse>
 800c3ec:	66e0      	str	r0, [r4, #108]	; 0x6c
    }
  }

  /* Get the Card Class */
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
 800c3ee:	2104      	movs	r1, #4
 800c3f0:	6820      	ldr	r0, [r4, #0]
 800c3f2:	f000 fc06 	bl	800cc02 <SDMMC_GetResponse>
 800c3f6:	0d00      	lsrs	r0, r0, #20
 800c3f8:	6460      	str	r0, [r4, #68]	; 0x44

  /* Get CSD parameters */
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
 800c3fa:	a90d      	add	r1, sp, #52	; 0x34
 800c3fc:	4620      	mov	r0, r4
 800c3fe:	f7ff fdf1 	bl	800bfe4 <HAL_SD_GetCardCSD>
 800c402:	4603      	mov	r3, r0
 800c404:	b928      	cbnz	r0, 800c412 <HAL_SD_InitCard+0x27e>
  {
    return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
  }

  /* Select the Card */
  errorstate = SDMMC_CmdSelDesel(hsd->Instance, (uint32_t)(((uint32_t)hsd->SdCard.RelCardAdd) << 16U));
 800c406:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 800c408:	6820      	ldr	r0, [r4, #0]
 800c40a:	0412      	lsls	r2, r2, #16
 800c40c:	f000 fdf8 	bl	800d000 <SDMMC_CmdSelDesel>
 800c410:	e7a1      	b.n	800c356 <HAL_SD_InitCard+0x1c2>
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);

  /* Get CSD parameters */
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
  {
    return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800c412:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 800c416:	e7a1      	b.n	800c35c <HAL_SD_InitCard+0x1c8>

  /* Check the power State */
  if(SDMMC_GetPowerState(hsd->Instance) == 0U)
  {
    /* Power off */
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 800c418:	f04f 6580 	mov.w	r5, #67108864	; 0x4000000
 800c41c:	e79e      	b.n	800c35c <HAL_SD_InitCard+0x1c8>
    hsd->ErrorCode |= errorstate;
    return HAL_ERROR;
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 800c41e:	f44f 7100 	mov.w	r1, #512	; 0x200
 800c422:	6820      	ldr	r0, [r4, #0]
 800c424:	f000 fccc 	bl	800cdc0 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c428:	2800      	cmp	r0, #0
 800c42a:	d0a4      	beq.n	800c376 <HAL_SD_InitCard+0x1e2>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800c42c:	6823      	ldr	r3, [r4, #0]
 800c42e:	4a08      	ldr	r2, [pc, #32]	; (800c450 <HAL_SD_InitCard+0x2bc>)
 800c430:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
 800c432:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c434:	4318      	orrs	r0, r3
 800c436:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800c438:	2001      	movs	r0, #1
 800c43a:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    return HAL_ERROR;
  }

  return HAL_OK;
}
 800c43e:	b019      	add	sp, #100	; 0x64
 800c440:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800c442:	bf00      	nop
 800c444:	000c3500 	.word	0x000c3500
 800c448:	00012110 	.word	0x00012110
 800c44c:	c1100000 	.word	0xc1100000
 800c450:	1fe00fff 	.word	0x1fe00fff

0800c454 <HAL_SD_GetCardStatus>:
  * @param  pStatus Pointer to the HAL_SD_CardStatusTypeDef structure that
  *         will contain the SD card status information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_GetCardStatus(SD_HandleTypeDef *hsd, HAL_SD_CardStatusTypeDef *pStatus)
{
 800c454:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c458:	b096      	sub	sp, #88	; 0x58
 800c45a:	4604      	mov	r4, r0
 800c45c:	460d      	mov	r5, r1
  */
static uint32_t SD_SendSDStatus(SD_HandleTypeDef *hsd, uint32_t *pSDstatus)
{
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 800c45e:	f7fa fdd5 	bl	800700c <HAL_GetTick>
  uint32_t count;
  uint32_t *pData = pSDstatus;

  /* Check SD response */
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800c462:	2100      	movs	r1, #0
  */
static uint32_t SD_SendSDStatus(SD_HandleTypeDef *hsd, uint32_t *pSDstatus)
{
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 800c464:	4607      	mov	r7, r0
  uint32_t count;
  uint32_t *pData = pSDstatus;

  /* Check SD response */
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800c466:	6820      	ldr	r0, [r4, #0]
 800c468:	f000 fbcb 	bl	800cc02 <SDMMC_GetResponse>
 800c46c:	0183      	lsls	r3, r0, #6
 800c46e:	d455      	bmi.n	800c51c <HAL_SD_GetCardStatus+0xc8>
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
  }

  /* Set block size for card if it is not equal to current block size for card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 64U);
 800c470:	2140      	movs	r1, #64	; 0x40
 800c472:	6820      	ldr	r0, [r4, #0]
 800c474:	f000 fca4 	bl	800cdc0 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c478:	b9b8      	cbnz	r0, 800c4aa <HAL_SD_GetCardStatus+0x56>
    hsd->ErrorCode |= HAL_SD_ERROR_NONE;
    return errorstate;
  }

  /* Send CMD55 */
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800c47a:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800c47c:	6820      	ldr	r0, [r4, #0]
 800c47e:	0409      	lsls	r1, r1, #16
 800c480:	f000 fdd7 	bl	800d032 <SDMMC_CmdAppCommand>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c484:	b988      	cbnz	r0, 800c4aa <HAL_SD_GetCardStatus+0x56>

  /* Configure the SD DPSM (Data Path State Machine) */
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
  config.DataLength    = 64U;
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B;
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800c486:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800c48a:	2240      	movs	r2, #64	; 0x40
 800c48c:	2360      	movs	r3, #96	; 0x60
 800c48e:	2602      	movs	r6, #2
 800c490:	e88d 004e 	stmia.w	sp, {r1, r2, r3, r6}
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800c494:	9004      	str	r0, [sp, #16]
  config.DPSM          = SDMMC_DPSM_ENABLE;
 800c496:	2301      	movs	r3, #1
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 800c498:	4669      	mov	r1, sp
 800c49a:	6820      	ldr	r0, [r4, #0]
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
  config.DataLength    = 64U;
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B;
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
  config.DPSM          = SDMMC_DPSM_ENABLE;
 800c49c:	9305      	str	r3, [sp, #20]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 800c49e:	f000 fbb3 	bl	800cc08 <SDMMC_ConfigData>

  /* Send ACMD13 (SD_APP_STAUS)  with argument as card's RCA */
  errorstate = SDMMC_CmdStatusRegister(hsd->Instance);
 800c4a2:	6820      	ldr	r0, [r4, #0]
 800c4a4:	f000 fe2a 	bl	800d0fc <SDMMC_CmdStatusRegister>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c4a8:	b120      	cbz	r0, 800c4b4 <HAL_SD_GetCardStatus+0x60>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_NONE;
 800c4aa:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c4ac:	63a3      	str	r3, [r4, #56]	; 0x38
  uint32_t sd_status[16];
  uint32_t errorstate;
  HAL_StatusTypeDef status = HAL_OK;

  errorstate = SD_SendSDStatus(hsd, sd_status);
  if(errorstate != HAL_SD_ERROR_NONE)
 800c4ae:	2800      	cmp	r0, #0
 800c4b0:	d046      	beq.n	800c540 <HAL_SD_GetCardStatus+0xec>
 800c4b2:	e03b      	b.n	800c52c <HAL_SD_GetCardStatus+0xd8>
  config.DPSM          = SDMMC_DPSM_ENABLE;
  (void)SDMMC_ConfigData(hsd->Instance, &config);

  /* Send ACMD13 (SD_APP_STAUS)  with argument as card's RCA */
  errorstate = SDMMC_CmdStatusRegister(hsd->Instance);
  if(errorstate != HAL_SD_ERROR_NONE)
 800c4b4:	ae06      	add	r6, sp, #24
    return errorstate;
  }

  /* Get status data */
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 800c4b6:	6823      	ldr	r3, [r4, #0]
 800c4b8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c4ba:	f412 7f95 	tst.w	r2, #298	; 0x12a
 800c4be:	d113      	bne.n	800c4e8 <HAL_SD_GetCardStatus+0x94>
#else
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND))
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
  {
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
 800c4c0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800c4c2:	041b      	lsls	r3, r3, #16
 800c4c4:	d508      	bpl.n	800c4d8 <HAL_SD_GetCardStatus+0x84>
 800c4c6:	f106 0820 	add.w	r8, r6, #32
    {
      for(count = 0U; count < 8U; count++)
      {
        *pData = SDMMC_ReadFIFO(hsd->Instance);
 800c4ca:	6820      	ldr	r0, [r4, #0]
 800c4cc:	f000 fb60 	bl	800cb90 <SDMMC_ReadFIFO>
 800c4d0:	f846 0b04 	str.w	r0, [r6], #4
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND))
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
  {
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
    {
      for(count = 0U; count < 8U; count++)
 800c4d4:	4546      	cmp	r6, r8
 800c4d6:	d1f8      	bne.n	800c4ca <HAL_SD_GetCardStatus+0x76>
        *pData = SDMMC_ReadFIFO(hsd->Instance);
        pData++;
      }
    }

    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 800c4d8:	f7fa fd98 	bl	800700c <HAL_GetTick>
 800c4dc:	1bc0      	subs	r0, r0, r7
 800c4de:	3001      	adds	r0, #1
 800c4e0:	d1e9      	bne.n	800c4b6 <HAL_SD_GetCardStatus+0x62>
    {
      return HAL_SD_ERROR_TIMEOUT;
 800c4e2:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800c4e6:	e021      	b.n	800c52c <HAL_SD_GetCardStatus+0xd8>
    }
  }

  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 800c4e8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c4ea:	0710      	lsls	r0, r2, #28
 800c4ec:	d419      	bmi.n	800c522 <HAL_SD_GetCardStatus+0xce>
  {
    return HAL_SD_ERROR_DATA_TIMEOUT;
  }
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800c4ee:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c4f0:	0791      	lsls	r1, r2, #30
 800c4f2:	d418      	bmi.n	800c526 <HAL_SD_GetCardStatus+0xd2>
  {
    return HAL_SD_ERROR_DATA_CRC_FAIL;
  }
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 800c4f4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800c4f6:	069a      	lsls	r2, r3, #26
 800c4f8:	d417      	bmi.n	800c52a <HAL_SD_GetCardStatus+0xd6>
  {
    /* Nothing to do */
  }

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DPSMACT)))
 800c4fa:	6820      	ldr	r0, [r4, #0]
 800c4fc:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800c4fe:	04db      	lsls	r3, r3, #19
 800c500:	d509      	bpl.n	800c516 <HAL_SD_GetCardStatus+0xc2>
#else
  while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXDAVL)))
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
  {
    *pData = SDMMC_ReadFIFO(hsd->Instance);
 800c502:	f000 fb45 	bl	800cb90 <SDMMC_ReadFIFO>
 800c506:	f846 0b04 	str.w	r0, [r6], #4
    pData++;

    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 800c50a:	f7fa fd7f 	bl	800700c <HAL_GetTick>
 800c50e:	1bc0      	subs	r0, r0, r7
 800c510:	3001      	adds	r0, #1
 800c512:	d1f2      	bne.n	800c4fa <HAL_SD_GetCardStatus+0xa6>
 800c514:	e7e5      	b.n	800c4e2 <HAL_SD_GetCardStatus+0x8e>
      return HAL_SD_ERROR_TIMEOUT;
    }
  }

  /* Clear all the static status flags*/
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800c516:	4b2b      	ldr	r3, [pc, #172]	; (800c5c4 <HAL_SD_GetCardStatus+0x170>)
 800c518:	6383      	str	r3, [r0, #56]	; 0x38
 800c51a:	e011      	b.n	800c540 <HAL_SD_GetCardStatus+0xec>
  uint32_t *pData = pSDstatus;

  /* Check SD response */
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 800c51c:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800c520:	e004      	b.n	800c52c <HAL_SD_GetCardStatus+0xd8>
    }
  }

  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
  {
    return HAL_SD_ERROR_DATA_TIMEOUT;
 800c522:	2008      	movs	r0, #8
 800c524:	e002      	b.n	800c52c <HAL_SD_GetCardStatus+0xd8>
  }
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
  {
    return HAL_SD_ERROR_DATA_CRC_FAIL;
 800c526:	2002      	movs	r0, #2
 800c528:	e000      	b.n	800c52c <HAL_SD_GetCardStatus+0xd8>
  }
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
  {
    return HAL_SD_ERROR_RX_OVERRUN;
 800c52a:	2020      	movs	r0, #32

  errorstate = SD_SendSDStatus(hsd, sd_status);
  if(errorstate != HAL_SD_ERROR_NONE)
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800c52c:	6823      	ldr	r3, [r4, #0]
 800c52e:	4a26      	ldr	r2, [pc, #152]	; (800c5c8 <HAL_SD_GetCardStatus+0x174>)
 800c530:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
 800c532:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800c534:	2501      	movs	r5, #1
  errorstate = SD_SendSDStatus(hsd, sd_status);
  if(errorstate != HAL_SD_ERROR_NONE)
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
    hsd->ErrorCode |= errorstate;
 800c536:	4318      	orrs	r0, r3
 800c538:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800c53a:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
 800c53e:	e030      	b.n	800c5a2 <HAL_SD_GetCardStatus+0x14e>
    status = HAL_ERROR;
  }
  else
  {
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
 800c540:	9a06      	ldr	r2, [sp, #24]
 800c542:	f3c2 1381 	ubfx	r3, r2, #6, #2
 800c546:	702b      	strb	r3, [r5, #0]

    pStatus->SecuredMode = (uint8_t)((sd_status[0] & 0x20U) >> 5U);
 800c548:	f3c2 1340 	ubfx	r3, r2, #5, #1
 800c54c:	706b      	strb	r3, [r5, #1]

    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
 800c54e:	0a13      	lsrs	r3, r2, #8
 800c550:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 800c554:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800c558:	b29b      	uxth	r3, r3
 800c55a:	806b      	strh	r3, [r5, #2]
 800c55c:	9b07      	ldr	r3, [sp, #28]
 800c55e:	ba1b      	rev	r3, r3

    pStatus->ProtectedAreaSize = (((sd_status[1] & 0xFFU) << 24U)    | ((sd_status[1] & 0xFF00U) << 8U) |
 800c560:	606b      	str	r3, [r5, #4]
                                  ((sd_status[1] & 0xFF0000U) >> 8U) | ((sd_status[1] & 0xFF000000U) >> 24U));

    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
 800c562:	9b08      	ldr	r3, [sp, #32]
 800c564:	b2da      	uxtb	r2, r3
 800c566:	722a      	strb	r2, [r5, #8]

    pStatus->PerformanceMove = (uint8_t)((sd_status[2] & 0xFF00U) >> 8U);
 800c568:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800c56c:	726a      	strb	r2, [r5, #9]

    pStatus->AllocationUnitSize = (uint8_t)((sd_status[2] & 0xF00000U) >> 20U);
 800c56e:	f3c3 5203 	ubfx	r2, r3, #20, #4
 800c572:	72aa      	strb	r2, [r5, #10]

    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
 800c574:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800c576:	0c1b      	lsrs	r3, r3, #16
 800c578:	b2d1      	uxtb	r1, r2
 800c57a:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 800c57e:	430b      	orrs	r3, r1
 800c580:	81ab      	strh	r3, [r5, #12]

    pStatus->EraseTimeout = (uint8_t)((sd_status[3] & 0xFC00U) >> 10U);
 800c582:	f3c2 2385 	ubfx	r3, r2, #10, #6
 800c586:	73ab      	strb	r3, [r5, #14]

    pStatus->EraseOffset = (uint8_t)((sd_status[3] & 0x0300U) >> 8U);
 800c588:	f3c2 2301 	ubfx	r3, r2, #8, #2
 800c58c:	73eb      	strb	r3, [r5, #15]

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    pStatus->UhsSpeedGrade = (uint8_t)((sd_status[3] & 0x00F0U) >> 4U);
 800c58e:	f3c2 1303 	ubfx	r3, r2, #4, #4
 800c592:	742b      	strb	r3, [r5, #16]
    pStatus->UhsAllocationUnitSize = (uint8_t)(sd_status[3] & 0x000FU) ;
 800c594:	f002 020f 	and.w	r2, r2, #15
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
 800c598:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b

    pStatus->EraseOffset = (uint8_t)((sd_status[3] & 0x0300U) >> 8U);

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
    pStatus->UhsSpeedGrade = (uint8_t)((sd_status[3] & 0x00F0U) >> 4U);
    pStatus->UhsAllocationUnitSize = (uint8_t)(sd_status[3] & 0x000FU) ;
 800c59c:	746a      	strb	r2, [r5, #17]
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
 800c59e:	74ab      	strb	r3, [r5, #18]
  */
HAL_StatusTypeDef HAL_SD_GetCardStatus(SD_HandleTypeDef *hsd, HAL_SD_CardStatusTypeDef *pStatus)
{
  uint32_t sd_status[16];
  uint32_t errorstate;
  HAL_StatusTypeDef status = HAL_OK;
 800c5a0:	2500      	movs	r5, #0
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
#endif
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 800c5a2:	f44f 7100 	mov.w	r1, #512	; 0x200
 800c5a6:	6820      	ldr	r0, [r4, #0]
 800c5a8:	f000 fc0a 	bl	800cdc0 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c5ac:	b130      	cbz	r0, 800c5bc <HAL_SD_GetCardStatus+0x168>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800c5ae:	6823      	ldr	r3, [r4, #0]
 800c5b0:	4a05      	ldr	r2, [pc, #20]	; (800c5c8 <HAL_SD_GetCardStatus+0x174>)
 800c5b2:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode = errorstate;
    hsd->State = HAL_SD_STATE_READY;
 800c5b4:	2501      	movs	r5, #1
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
  if(errorstate != HAL_SD_ERROR_NONE)
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
    hsd->ErrorCode = errorstate;
 800c5b6:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800c5b8:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
    status = HAL_ERROR;
  }

  return status;
}
 800c5bc:	4628      	mov	r0, r5
 800c5be:	b016      	add	sp, #88	; 0x58
 800c5c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c5c4:	18000f3a 	.word	0x18000f3a
 800c5c8:	1fe00fff 	.word	0x1fe00fff

0800c5cc <HAL_SD_GetCardInfo>:
  *         will contain the SD card status information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_GetCardInfo(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypeDef *pCardInfo)
{
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
 800c5cc:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 800c5ce:	600b      	str	r3, [r1, #0]
  pCardInfo->CardVersion  = (uint32_t)(hsd->SdCard.CardVersion);
 800c5d0:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800c5d2:	604b      	str	r3, [r1, #4]
  pCardInfo->Class        = (uint32_t)(hsd->SdCard.Class);
 800c5d4:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800c5d6:	608b      	str	r3, [r1, #8]
  pCardInfo->RelCardAdd   = (uint32_t)(hsd->SdCard.RelCardAdd);
 800c5d8:	6c83      	ldr	r3, [r0, #72]	; 0x48
 800c5da:	60cb      	str	r3, [r1, #12]
  pCardInfo->BlockNbr     = (uint32_t)(hsd->SdCard.BlockNbr);
 800c5dc:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 800c5de:	610b      	str	r3, [r1, #16]
  pCardInfo->BlockSize    = (uint32_t)(hsd->SdCard.BlockSize);
 800c5e0:	6d03      	ldr	r3, [r0, #80]	; 0x50
 800c5e2:	614b      	str	r3, [r1, #20]
  pCardInfo->LogBlockNbr  = (uint32_t)(hsd->SdCard.LogBlockNbr);
 800c5e4:	6d43      	ldr	r3, [r0, #84]	; 0x54
 800c5e6:	618b      	str	r3, [r1, #24]
  pCardInfo->LogBlockSize = (uint32_t)(hsd->SdCard.LogBlockSize);
 800c5e8:	6d83      	ldr	r3, [r0, #88]	; 0x58
 800c5ea:	61cb      	str	r3, [r1, #28]

  return HAL_OK;
}
 800c5ec:	2000      	movs	r0, #0
 800c5ee:	4770      	bx	lr

0800c5f0 <HAL_SD_ConfigWideBusOperation>:
  *            @arg SDMMC_BUS_WIDE_4B: 4-bit data transfer
  *            @arg SDMMC_BUS_WIDE_1B: 1-bit data transfer
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_ConfigWideBusOperation(SD_HandleTypeDef *hsd, uint32_t WideMode)
{
 800c5f0:	b530      	push	{r4, r5, lr}

  /* Check the parameters */
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));

  /* Change State */
  hsd->State = HAL_SD_STATE_BUSY;
 800c5f2:	2303      	movs	r3, #3
 800c5f4:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34

  if(hsd->SdCard.CardType != CARD_SECURED)
 800c5f8:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 800c5fa:	2b03      	cmp	r3, #3
  *            @arg SDMMC_BUS_WIDE_4B: 4-bit data transfer
  *            @arg SDMMC_BUS_WIDE_1B: 1-bit data transfer
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_ConfigWideBusOperation(SD_HandleTypeDef *hsd, uint32_t WideMode)
{
 800c5fc:	b08b      	sub	sp, #44	; 0x2c
 800c5fe:	4604      	mov	r4, r0
 800c600:	460d      	mov	r5, r1
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));

  /* Change State */
  hsd->State = HAL_SD_STATE_BUSY;

  if(hsd->SdCard.CardType != CARD_SECURED)
 800c602:	d045      	beq.n	800c690 <HAL_SD_ConfigWideBusOperation+0xa0>
  {
    if(WideMode == SDMMC_BUS_WIDE_8B)
 800c604:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 800c608:	d042      	beq.n	800c690 <HAL_SD_ConfigWideBusOperation+0xa0>
    {
      hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
    }
    else if(WideMode == SDMMC_BUS_WIDE_4B)
 800c60a:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
 800c60e:	d117      	bne.n	800c640 <HAL_SD_ConfigWideBusOperation+0x50>
  * @param  hsd pointer to SD handle
  * @retval error state
  */
static uint32_t SD_WideBus_Enable(SD_HandleTypeDef *hsd)
{
  uint32_t scr[2U] = {0UL, 0UL};
 800c610:	2100      	movs	r1, #0
  uint32_t errorstate;

  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800c612:	6800      	ldr	r0, [r0, #0]
  * @param  hsd pointer to SD handle
  * @retval error state
  */
static uint32_t SD_WideBus_Enable(SD_HandleTypeDef *hsd)
{
  uint32_t scr[2U] = {0UL, 0UL};
 800c614:	9104      	str	r1, [sp, #16]
 800c616:	9105      	str	r1, [sp, #20]
  uint32_t errorstate;

  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800c618:	f000 faf3 	bl	800cc02 <SDMMC_GetResponse>
 800c61c:	0180      	lsls	r0, r0, #6
 800c61e:	d42a      	bmi.n	800c676 <HAL_SD_ConfigWideBusOperation+0x86>
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
  }

  /* Get SCR Register */
  errorstate = SD_FindSCR(hsd, scr);
 800c620:	a904      	add	r1, sp, #16
 800c622:	4620      	mov	r0, r4
 800c624:	f7ff fa1c 	bl	800ba60 <SD_FindSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c628:	bb50      	cbnz	r0, 800c680 <HAL_SD_ConfigWideBusOperation+0x90>
  {
    return errorstate;
  }

  /* If requested card supports wide bus operation */
  if((scr[1U] & SDMMC_WIDE_BUS_SUPPORT) != SDMMC_ALLZERO)
 800c62a:	9b05      	ldr	r3, [sp, #20]
 800c62c:	0359      	lsls	r1, r3, #13
 800c62e:	d525      	bpl.n	800c67c <HAL_SD_ConfigWideBusOperation+0x8c>
  {
    /* Send CMD55 APP_CMD with argument as card's RCA.*/
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800c630:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800c632:	6820      	ldr	r0, [r4, #0]
 800c634:	0409      	lsls	r1, r1, #16
 800c636:	f000 fcfc 	bl	800d032 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 800c63a:	bb08      	cbnz	r0, 800c680 <HAL_SD_ConfigWideBusOperation+0x90>
    {
      return errorstate;
    }

    /* Send ACMD6 APP_CMD with argument as 2 for wide bus mode */
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 2U);
 800c63c:	2102      	movs	r1, #2
 800c63e:	e016      	b.n	800c66e <HAL_SD_ConfigWideBusOperation+0x7e>
    {
      errorstate = SD_WideBus_Enable(hsd);

      hsd->ErrorCode |= errorstate;
    }
    else if(WideMode == SDMMC_BUS_WIDE_1B)
 800c640:	bb11      	cbnz	r1, 800c688 <HAL_SD_ConfigWideBusOperation+0x98>
static uint32_t SD_WideBus_Disable(SD_HandleTypeDef *hsd)
{
  uint32_t scr[2U] = {0UL, 0UL};
  uint32_t errorstate;

  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800c642:	6800      	ldr	r0, [r0, #0]
  * @param  hsd Pointer to SD handle
  * @retval error state
  */
static uint32_t SD_WideBus_Disable(SD_HandleTypeDef *hsd)
{
  uint32_t scr[2U] = {0UL, 0UL};
 800c644:	9104      	str	r1, [sp, #16]
 800c646:	9105      	str	r1, [sp, #20]
  uint32_t errorstate;

  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800c648:	f000 fadb 	bl	800cc02 <SDMMC_GetResponse>
 800c64c:	0182      	lsls	r2, r0, #6
 800c64e:	d412      	bmi.n	800c676 <HAL_SD_ConfigWideBusOperation+0x86>
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
  }

  /* Get SCR Register */
  errorstate = SD_FindSCR(hsd, scr);
 800c650:	a904      	add	r1, sp, #16
 800c652:	4620      	mov	r0, r4
 800c654:	f7ff fa04 	bl	800ba60 <SD_FindSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c658:	b990      	cbnz	r0, 800c680 <HAL_SD_ConfigWideBusOperation+0x90>
  {
    return errorstate;
  }

  /* If requested card supports 1 bit mode operation */
  if((scr[1U] & SDMMC_SINGLE_BUS_SUPPORT) != SDMMC_ALLZERO)
 800c65a:	9b05      	ldr	r3, [sp, #20]
 800c65c:	03db      	lsls	r3, r3, #15
 800c65e:	d50d      	bpl.n	800c67c <HAL_SD_ConfigWideBusOperation+0x8c>
  {
    /* Send CMD55 APP_CMD with argument as card's RCA */
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800c660:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800c662:	6820      	ldr	r0, [r4, #0]
 800c664:	0409      	lsls	r1, r1, #16
 800c666:	f000 fce4 	bl	800d032 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 800c66a:	b948      	cbnz	r0, 800c680 <HAL_SD_ConfigWideBusOperation+0x90>
    {
      return errorstate;
    }

    /* Send ACMD6 APP_CMD with argument as 0 for single bus mode */
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 0U);
 800c66c:	4629      	mov	r1, r5
 800c66e:	6820      	ldr	r0, [r4, #0]
 800c670:	f000 fd76 	bl	800d160 <SDMMC_CmdBusWidth>
 800c674:	e004      	b.n	800c680 <HAL_SD_ConfigWideBusOperation+0x90>
  uint32_t scr[2U] = {0UL, 0UL};
  uint32_t errorstate;

  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 800c676:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800c67a:	e001      	b.n	800c680 <HAL_SD_ConfigWideBusOperation+0x90>

    return HAL_SD_ERROR_NONE;
  }
  else
  {
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 800c67c:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
    }
    else if(WideMode == SDMMC_BUS_WIDE_1B)
    {
      errorstate = SD_WideBus_Disable(hsd);

      hsd->ErrorCode |= errorstate;
 800c680:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c682:	4318      	orrs	r0, r3
 800c684:	63a0      	str	r0, [r4, #56]	; 0x38
 800c686:	e007      	b.n	800c698 <HAL_SD_ConfigWideBusOperation+0xa8>
    }
    else
    {
      /* WideMode is not a valid argument*/
      hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800c688:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800c68a:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 800c68e:	e002      	b.n	800c696 <HAL_SD_ConfigWideBusOperation+0xa6>
    }
  }
  else
  {
    /* MMC Card does not support this feature */
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800c690:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c692:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800c696:	63a3      	str	r3, [r4, #56]	; 0x38
  }

  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
 800c698:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c69a:	b11b      	cbz	r3, 800c6a4 <HAL_SD_ConfigWideBusOperation+0xb4>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800c69c:	6823      	ldr	r3, [r4, #0]
 800c69e:	4a2f      	ldr	r2, [pc, #188]	; (800c75c <HAL_SD_ConfigWideBusOperation+0x16c>)
 800c6a0:	639a      	str	r2, [r3, #56]	; 0x38
 800c6a2:	e047      	b.n	800c734 <HAL_SD_ConfigWideBusOperation+0x144>
    status = HAL_ERROR;
  }
  else
  {
    sdmmc_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC1);
 800c6a4:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800c6a8:	f7fd f862 	bl	8009770 <HAL_RCCEx_GetPeriphCLKFreq>
    if (sdmmc_clk != 0U)
 800c6ac:	2800      	cmp	r0, #0
 800c6ae:	d03d      	beq.n	800c72c <HAL_SD_ConfigWideBusOperation+0x13c>
    {
      /* Configure the SDMMC peripheral */
      Init.ClockEdge           = hsd->Init.ClockEdge;
 800c6b0:	6863      	ldr	r3, [r4, #4]
 800c6b2:	9304      	str	r3, [sp, #16]
#if !defined(STM32L4P5xx) && !defined(STM32L4Q5xx) && !defined(STM32L4R5xx) && !defined(STM32L4R7xx) && !defined(STM32L4R9xx) && !defined(STM32L4S5xx) && !defined(STM32L4S7xx) && !defined(STM32L4S9xx)
      Init.ClockBypass         = hsd->Init.ClockBypass;
#endif /* !STM32L4P5xx && !STM32L4Q5xx && !STM32L4R5xx && !STM32L4R7xx && !STM32L4R9xx && !STM32L4S5xx && !STM32L4S7xx && !STM32L4S9xx */
      Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
 800c6b4:	68a3      	ldr	r3, [r4, #8]
 800c6b6:	9305      	str	r3, [sp, #20]
      Init.BusWide             = WideMode;
      Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
 800c6b8:	6923      	ldr	r3, [r4, #16]
 800c6ba:	9307      	str	r3, [sp, #28]

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
      /* Check if user Clock div < Normal speed 25Mhz, no change in Clockdiv */
      if (hsd->Init.ClockDiv >= (sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ)))
 800c6bc:	6963      	ldr	r3, [r4, #20]
 800c6be:	4928      	ldr	r1, [pc, #160]	; (800c760 <HAL_SD_ConfigWideBusOperation+0x170>)
 800c6c0:	fbb0 f2f1 	udiv	r2, r0, r1
 800c6c4:	4293      	cmp	r3, r2
      Init.ClockEdge           = hsd->Init.ClockEdge;
#if !defined(STM32L4P5xx) && !defined(STM32L4Q5xx) && !defined(STM32L4R5xx) && !defined(STM32L4R7xx) && !defined(STM32L4R9xx) && !defined(STM32L4S5xx) && !defined(STM32L4S7xx) && !defined(STM32L4S9xx)
      Init.ClockBypass         = hsd->Init.ClockBypass;
#endif /* !STM32L4P5xx && !STM32L4Q5xx && !STM32L4R5xx && !STM32L4R7xx && !STM32L4R9xx && !STM32L4S5xx && !STM32L4S7xx && !STM32L4S9xx */
      Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
      Init.BusWide             = WideMode;
 800c6c6:	9506      	str	r5, [sp, #24]
      Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
      /* Check if user Clock div < Normal speed 25Mhz, no change in Clockdiv */
      if (hsd->Init.ClockDiv >= (sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ)))
 800c6c8:	d221      	bcs.n	800c70e <HAL_SD_ConfigWideBusOperation+0x11e>
      {
        Init.ClockDiv = hsd->Init.ClockDiv;
      }
      else if (hsd->SdCard.CardSpeed == CARD_ULTRA_HIGH_SPEED)
 800c6ca:	6de5      	ldr	r5, [r4, #92]	; 0x5c
 800c6cc:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
 800c6d0:	d01d      	beq.n	800c70e <HAL_SD_ConfigWideBusOperation+0x11e>
      {
        /* UltraHigh speed SD card,user Clock div */
        Init.ClockDiv = hsd->Init.ClockDiv;
      }
      else if (hsd->SdCard.CardSpeed == CARD_HIGH_SPEED)
 800c6d2:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 800c6d6:	d10e      	bne.n	800c6f6 <HAL_SD_ConfigWideBusOperation+0x106>
      {
        /* High speed SD card, Max Frequency = 50Mhz */
        if (hsd->Init.ClockDiv == 0U)
 800c6d8:	b91b      	cbnz	r3, 800c6e2 <HAL_SD_ConfigWideBusOperation+0xf2>
        {
          if (sdmmc_clk > SD_HIGH_SPEED_FREQ)
 800c6da:	4288      	cmp	r0, r1
 800c6dc:	d806      	bhi.n	800c6ec <HAL_SD_ConfigWideBusOperation+0xfc>
          {
            Init.ClockDiv = sdmmc_clk / (2U * SD_HIGH_SPEED_FREQ);
          }
          else
          {
            Init.ClockDiv = hsd->Init.ClockDiv;
 800c6de:	2300      	movs	r3, #0
 800c6e0:	e015      	b.n	800c70e <HAL_SD_ConfigWideBusOperation+0x11e>
          }
        }
        else
        {
          if ((sdmmc_clk/(2U * hsd->Init.ClockDiv)) > SD_HIGH_SPEED_FREQ)
 800c6e2:	005a      	lsls	r2, r3, #1
 800c6e4:	fbb0 f2f2 	udiv	r2, r0, r2
 800c6e8:	428a      	cmp	r2, r1
 800c6ea:	d910      	bls.n	800c70e <HAL_SD_ConfigWideBusOperation+0x11e>
          {
            Init.ClockDiv = sdmmc_clk / (2U * SD_HIGH_SPEED_FREQ);
 800c6ec:	4b1d      	ldr	r3, [pc, #116]	; (800c764 <HAL_SD_ConfigWideBusOperation+0x174>)
 800c6ee:	fbb0 f0f3 	udiv	r0, r0, r3
 800c6f2:	9008      	str	r0, [sp, #32]
 800c6f4:	e00c      	b.n	800c710 <HAL_SD_ConfigWideBusOperation+0x120>
 800c6f6:	491c      	ldr	r1, [pc, #112]	; (800c768 <HAL_SD_ConfigWideBusOperation+0x178>)
        }
      }
      else
      {
        /* No High speed SD card, Max Frequency = 25Mhz */
        if (hsd->Init.ClockDiv == 0U)
 800c6f8:	b91b      	cbnz	r3, 800c702 <HAL_SD_ConfigWideBusOperation+0x112>
        {
          if (sdmmc_clk > SD_NORMAL_SPEED_FREQ)
 800c6fa:	4288      	cmp	r0, r1
 800c6fc:	d9ef      	bls.n	800c6de <HAL_SD_ConfigWideBusOperation+0xee>
          {
            Init.ClockDiv = sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ);
 800c6fe:	9208      	str	r2, [sp, #32]
 800c700:	e006      	b.n	800c710 <HAL_SD_ConfigWideBusOperation+0x120>
            Init.ClockDiv = hsd->Init.ClockDiv;
          }
        }
        else
        {
          if ((sdmmc_clk/(2U * hsd->Init.ClockDiv)) > SD_NORMAL_SPEED_FREQ)
 800c702:	005d      	lsls	r5, r3, #1
 800c704:	fbb0 f0f5 	udiv	r0, r0, r5
          {
            Init.ClockDiv = sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ);
 800c708:	4288      	cmp	r0, r1
 800c70a:	bf88      	it	hi
 800c70c:	4613      	movhi	r3, r2
 800c70e:	9308      	str	r3, [sp, #32]
            Init.ClockDiv = hsd->Init.ClockDiv;
          }
        }
      }

      Init.Transceiver = hsd->Init.Transceiver;
 800c710:	69a3      	ldr	r3, [r4, #24]
 800c712:	9309      	str	r3, [sp, #36]	; 0x24
      {
        Init.ClockDiv = hsd->Init.ClockDiv;
      }
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

      (void)SDMMC_Init(hsd->Instance, Init);
 800c714:	ab0a      	add	r3, sp, #40	; 0x28
 800c716:	e913 0007 	ldmdb	r3, {r0, r1, r2}
 800c71a:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 800c71e:	ab04      	add	r3, sp, #16
 800c720:	cb0e      	ldmia	r3, {r1, r2, r3}
 800c722:	6820      	ldr	r0, [r4, #0]
 800c724:	f000 fa1a 	bl	800cb5c <SDMMC_Init>
HAL_StatusTypeDef HAL_SD_ConfigWideBusOperation(SD_HandleTypeDef *hsd, uint32_t WideMode)
{
  SDMMC_InitTypeDef Init;
  uint32_t errorstate;
  uint32_t sdmmc_clk;
  HAL_StatusTypeDef status = HAL_OK;
 800c728:	2500      	movs	r5, #0
 800c72a:	e004      	b.n	800c736 <HAL_SD_ConfigWideBusOperation+0x146>

      (void)SDMMC_Init(hsd->Instance, Init);
    }
    else
    {
      hsd->ErrorCode |= SDMMC_ERROR_INVALID_PARAMETER;
 800c72c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c72e:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 800c732:	63a3      	str	r3, [r4, #56]	; 0x38
      status = HAL_ERROR;
 800c734:	2501      	movs	r5, #1
    }
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 800c736:	f44f 7100 	mov.w	r1, #512	; 0x200
 800c73a:	6820      	ldr	r0, [r4, #0]
 800c73c:	f000 fb40 	bl	800cdc0 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c740:	b130      	cbz	r0, 800c750 <HAL_SD_ConfigWideBusOperation+0x160>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800c742:	6823      	ldr	r3, [r4, #0]
 800c744:	4a05      	ldr	r2, [pc, #20]	; (800c75c <HAL_SD_ConfigWideBusOperation+0x16c>)
 800c746:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
 800c748:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c74a:	4318      	orrs	r0, r3
 800c74c:	63a0      	str	r0, [r4, #56]	; 0x38
    status = HAL_ERROR;
 800c74e:	2501      	movs	r5, #1
  }

  /* Change State */
  hsd->State = HAL_SD_STATE_READY;
 800c750:	2301      	movs	r3, #1

  return status;
}
 800c752:	4628      	mov	r0, r5
    hsd->ErrorCode |= errorstate;
    status = HAL_ERROR;
  }

  /* Change State */
  hsd->State = HAL_SD_STATE_READY;
 800c754:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

  return status;
}
 800c758:	b00b      	add	sp, #44	; 0x2c
 800c75a:	bd30      	pop	{r4, r5, pc}
 800c75c:	1fe00fff 	.word	0x1fe00fff
 800c760:	02faf080 	.word	0x02faf080
 800c764:	05f5e100 	.word	0x05f5e100
 800c768:	017d7840 	.word	0x017d7840

0800c76c <HAL_SD_GetCardState>:
  {
    return HAL_SD_ERROR_PARAM;
  }

  /* Send Status command */
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800c76c:	6c81      	ldr	r1, [r0, #72]	; 0x48
  * @brief  Gets the current sd card data state.
  * @param  hsd pointer to SD handle
  * @retval Card state
  */
HAL_SD_CardStateTypeDef HAL_SD_GetCardState(SD_HandleTypeDef *hsd)
{
 800c76e:	b510      	push	{r4, lr}
  {
    return HAL_SD_ERROR_PARAM;
  }

  /* Send Status command */
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800c770:	0409      	lsls	r1, r1, #16
  * @brief  Gets the current sd card data state.
  * @param  hsd pointer to SD handle
  * @retval Card state
  */
HAL_SD_CardStateTypeDef HAL_SD_GetCardState(SD_HandleTypeDef *hsd)
{
 800c772:	4604      	mov	r4, r0
  {
    return HAL_SD_ERROR_PARAM;
  }

  /* Send Status command */
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800c774:	6800      	ldr	r0, [r0, #0]
 800c776:	f000 fca8 	bl	800d0ca <SDMMC_CmdSendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c77a:	4601      	mov	r1, r0
 800c77c:	b918      	cbnz	r0, 800c786 <HAL_SD_GetCardState+0x1a>
  {
    return errorstate;
  }

  /* Get SD card status */
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800c77e:	6820      	ldr	r0, [r4, #0]
 800c780:	f000 fa3f 	bl	800cc02 <SDMMC_GetResponse>
 800c784:	e003      	b.n	800c78e <HAL_SD_GetCardState+0x22>
  uint32_t resp1 = 0;

  errorstate = SD_SendStatus(hsd, &resp1);
  if(errorstate != HAL_SD_ERROR_NONE)
  {
    hsd->ErrorCode |= errorstate;
 800c786:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800c788:	4301      	orrs	r1, r0
 800c78a:	63a1      	str	r1, [r4, #56]	; 0x38
  */
HAL_SD_CardStateTypeDef HAL_SD_GetCardState(SD_HandleTypeDef *hsd)
{
  uint32_t cardstate;
  uint32_t errorstate;
  uint32_t resp1 = 0;
 800c78c:	2000      	movs	r0, #0
    hsd->ErrorCode |= errorstate;
  }

  cardstate = ((resp1 >> 9U) & 0x0FU);

  return (HAL_SD_CardStateTypeDef)cardstate;
 800c78e:	f3c0 2043 	ubfx	r0, r0, #9, #4
}
 800c792:	bd10      	pop	{r4, pc}

0800c794 <HAL_SD_Init>:
            SD_HandleTypeDef and create the associated handle.
  * @param  hsd Pointer to the SD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_Init(SD_HandleTypeDef *hsd)
{
 800c794:	b570      	push	{r4, r5, r6, lr}
  uint32_t speedgrade, unitsize;
  uint32_t tickstart;
#endif

  /* Check the SD handle allocation */
  if(hsd == NULL)
 800c796:	4604      	mov	r4, r0
            SD_HandleTypeDef and create the associated handle.
  * @param  hsd Pointer to the SD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_Init(SD_HandleTypeDef *hsd)
{
 800c798:	b086      	sub	sp, #24
  uint32_t speedgrade, unitsize;
  uint32_t tickstart;
#endif

  /* Check the SD handle allocation */
  if(hsd == NULL)
 800c79a:	b908      	cbnz	r0, 800c7a0 <HAL_SD_Init+0xc>
  {
    return HAL_ERROR;
 800c79c:	2501      	movs	r5, #1
 800c79e:	e04c      	b.n	800c83a <HAL_SD_Init+0xa6>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
  assert_param(IS_SDMMC_BUS_WIDE(hsd->Init.BusWide));
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
  assert_param(IS_SDMMC_CLKDIV(hsd->Init.ClockDiv));

  if(hsd->State == HAL_SD_STATE_RESET)
 800c7a0:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 800c7a4:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800c7a8:	b913      	cbnz	r3, 800c7b0 <HAL_SD_Init+0x1c>
  {
    /* Allocate lock resource and initialize it */
    hsd->Lock = HAL_UNLOCKED;
 800c7aa:	7702      	strb	r2, [r0, #28]

    /* Init the low level hardware */
    hsd->MspInitCallback(hsd);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_SD_MspInit(hsd);
 800c7ac:	f7ff fa46 	bl	800bc3c <HAL_SD_MspInit>
#endif /* USE_HAL_SD_REGISTER_CALLBACKS */
  }

  hsd->State = HAL_SD_STATE_BUSY;
 800c7b0:	2303      	movs	r3, #3
 800c7b2:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

  /* Initialize the Card parameters */
  if (HAL_SD_InitCard(hsd) != HAL_OK)
 800c7b6:	4620      	mov	r0, r4
 800c7b8:	f7ff fcec 	bl	800c194 <HAL_SD_InitCard>
 800c7bc:	2800      	cmp	r0, #0
 800c7be:	d1ed      	bne.n	800c79c <HAL_SD_Init+0x8>
  {
    return HAL_ERROR;
  }

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  if( HAL_SD_GetCardStatus(hsd, &CardStatus) != HAL_OK)
 800c7c0:	a901      	add	r1, sp, #4
 800c7c2:	4620      	mov	r0, r4
 800c7c4:	f7ff fe46 	bl	800c454 <HAL_SD_GetCardStatus>
 800c7c8:	2800      	cmp	r0, #0
 800c7ca:	d1e7      	bne.n	800c79c <HAL_SD_Init+0x8>
    return HAL_ERROR;
  }
  /* Get Initial Card Speed from Card Status*/
  speedgrade = CardStatus.UhsSpeedGrade;
  unitsize = CardStatus.UhsAllocationUnitSize;
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
 800c7cc:	6be1      	ldr	r1, [r4, #60]	; 0x3c
  if( HAL_SD_GetCardStatus(hsd, &CardStatus) != HAL_OK)
  {
    return HAL_ERROR;
  }
  /* Get Initial Card Speed from Card Status*/
  speedgrade = CardStatus.UhsSpeedGrade;
 800c7ce:	f89d 2014 	ldrb.w	r2, [sp, #20]
  unitsize = CardStatus.UhsAllocationUnitSize;
 800c7d2:	f89d 3015 	ldrb.w	r3, [sp, #21]
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
 800c7d6:	2901      	cmp	r1, #1
  if( HAL_SD_GetCardStatus(hsd, &CardStatus) != HAL_OK)
  {
    return HAL_ERROR;
  }
  /* Get Initial Card Speed from Card Status*/
  speedgrade = CardStatus.UhsSpeedGrade;
 800c7d8:	b2d2      	uxtb	r2, r2
  unitsize = CardStatus.UhsAllocationUnitSize;
 800c7da:	b2db      	uxtb	r3, r3
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
 800c7dc:	d108      	bne.n	800c7f0 <HAL_SD_Init+0x5c>
 800c7de:	b902      	cbnz	r2, 800c7e2 <HAL_SD_Init+0x4e>
 800c7e0:	b113      	cbz	r3, 800c7e8 <HAL_SD_Init+0x54>
  {
    hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
 800c7e2:	f44f 7300 	mov.w	r3, #512	; 0x200
 800c7e6:	e001      	b.n	800c7ec <HAL_SD_Init+0x58>
  }
  else
  {
    if (hsd->SdCard.CardType == CARD_SDHC_SDXC)
    {
      hsd->SdCard.CardSpeed  = CARD_HIGH_SPEED;
 800c7e8:	f44f 7380 	mov.w	r3, #256	; 0x100
 800c7ec:	65e3      	str	r3, [r4, #92]	; 0x5c
 800c7ee:	e000      	b.n	800c7f2 <HAL_SD_Init+0x5e>
    }
    else
    {
      hsd->SdCard.CardSpeed  = CARD_NORMAL_SPEED;
 800c7f0:	65e0      	str	r0, [r4, #92]	; 0x5c
    }

  }
  /* Configure the bus wide */
  if(HAL_SD_ConfigWideBusOperation(hsd, hsd->Init.BusWide) != HAL_OK)
 800c7f2:	68e1      	ldr	r1, [r4, #12]
 800c7f4:	4620      	mov	r0, r4
 800c7f6:	f7ff fefb 	bl	800c5f0 <HAL_SD_ConfigWideBusOperation>
 800c7fa:	4605      	mov	r5, r0
 800c7fc:	2800      	cmp	r0, #0
 800c7fe:	d1cd      	bne.n	800c79c <HAL_SD_Init+0x8>
  {
    return HAL_ERROR;
  }

  /* Verify that SD card is ready to use after Initialization */
  tickstart = HAL_GetTick();
 800c800:	f7fa fc04 	bl	800700c <HAL_GetTick>
 800c804:	4606      	mov	r6, r0
  while((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
 800c806:	4620      	mov	r0, r4
 800c808:	f7ff ffb0 	bl	800c76c <HAL_SD_GetCardState>
 800c80c:	2804      	cmp	r0, #4
 800c80e:	d00e      	beq.n	800c82e <HAL_SD_Init+0x9a>
  {
    if((HAL_GetTick()-tickstart) >=  SDMMC_DATATIMEOUT)
 800c810:	f7fa fbfc 	bl	800700c <HAL_GetTick>
 800c814:	1b80      	subs	r0, r0, r6
 800c816:	3001      	adds	r0, #1
 800c818:	d1f5      	bne.n	800c806 <HAL_SD_Init+0x72>
    {
      hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
 800c81a:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 800c81e:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State= HAL_SD_STATE_READY;
 800c820:	2301      	movs	r3, #1
 800c822:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800c826:	2300      	movs	r3, #0
 800c828:	6323      	str	r3, [r4, #48]	; 0x30
      return HAL_TIMEOUT;
 800c82a:	2503      	movs	r5, #3
 800c82c:	e005      	b.n	800c83a <HAL_SD_Init+0xa6>
    }
  }
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

  /* Initialize the error code */
  hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800c82e:	2300      	movs	r3, #0
 800c830:	63a3      	str	r3, [r4, #56]	; 0x38

  /* Initialize the SD operation */
  hsd->Context = SD_CONTEXT_NONE;
 800c832:	6323      	str	r3, [r4, #48]	; 0x30

  /* Initialize the SD state */
  hsd->State = HAL_SD_STATE_READY;
 800c834:	2301      	movs	r3, #1
 800c836:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

  return HAL_OK;
}
 800c83a:	4628      	mov	r0, r5
 800c83c:	b006      	add	sp, #24
 800c83e:	bd70      	pop	{r4, r5, r6, pc}

0800c840 <SD_HighSpeed>:
  *         of PLL to have SDMMCCK clock between 50 and 120 MHz
  * @param  hsd SD handle
  * @retval SD Card error state
  */
uint32_t SD_HighSpeed(SD_HandleTypeDef *hsd)
{
 800c840:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t errorstate = HAL_SD_ERROR_NONE;
  SDMMC_DataInitTypeDef sdmmc_datainitstructure;
  uint32_t SD_hs[16]  = {0};
 800c844:	2440      	movs	r4, #64	; 0x40
  *         of PLL to have SDMMCCK clock between 50 and 120 MHz
  * @param  hsd SD handle
  * @retval SD Card error state
  */
uint32_t SD_HighSpeed(SD_HandleTypeDef *hsd)
{
 800c846:	b096      	sub	sp, #88	; 0x58
 800c848:	4606      	mov	r6, r0
  uint32_t errorstate = HAL_SD_ERROR_NONE;
  SDMMC_DataInitTypeDef sdmmc_datainitstructure;
  uint32_t SD_hs[16]  = {0};
 800c84a:	4622      	mov	r2, r4
 800c84c:	2100      	movs	r1, #0
 800c84e:	a806      	add	r0, sp, #24
 800c850:	f000 fe39 	bl	800d4c6 <memset>
  uint32_t count, loop = 0 ;
  uint32_t Timeout = HAL_GetTick();
 800c854:	f7fa fbda 	bl	800700c <HAL_GetTick>

  if(hsd->SdCard.CardSpeed == CARD_NORMAL_SPEED)
 800c858:	6df3      	ldr	r3, [r6, #92]	; 0x5c
{
  uint32_t errorstate = HAL_SD_ERROR_NONE;
  SDMMC_DataInitTypeDef sdmmc_datainitstructure;
  uint32_t SD_hs[16]  = {0};
  uint32_t count, loop = 0 ;
  uint32_t Timeout = HAL_GetTick();
 800c85a:	4607      	mov	r7, r0

  if(hsd->SdCard.CardSpeed == CARD_NORMAL_SPEED)
 800c85c:	2b00      	cmp	r3, #0
 800c85e:	d05e      	beq.n	800c91e <SD_HighSpeed+0xde>
  {
     /* Standard Speed Card <= 12.5Mhz  */
     return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
  }

  if(hsd->SdCard.CardSpeed == CARD_HIGH_SPEED)
 800c860:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800c864:	d145      	bne.n	800c8f2 <SD_HighSpeed+0xb2>
  {
    /* Initialize the Data control register */
    hsd->Instance->DCTRL = 0;
 800c866:	6830      	ldr	r0, [r6, #0]
 800c868:	2300      	movs	r3, #0
 800c86a:	62c3      	str	r3, [r0, #44]	; 0x2c
    errorstate = SDMMC_CmdBlockLength(hsd->Instance, 64U);
 800c86c:	4621      	mov	r1, r4
 800c86e:	f000 faa7 	bl	800cdc0 <SDMMC_CmdBlockLength>

    if (errorstate != HAL_SD_ERROR_NONE)
 800c872:	2800      	cmp	r0, #0
 800c874:	d158      	bne.n	800c928 <SD_HighSpeed+0xe8>
    {
      return errorstate;
    }

    /* Configure the SD DPSM (Data Path State Machine) */
    sdmmc_datainitstructure.DataTimeOut   = SDMMC_DATATIMEOUT;
 800c876:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    sdmmc_datainitstructure.DataLength    = 64U;
 800c87a:	e88d 0018 	stmia.w	sp, {r3, r4}
    sdmmc_datainitstructure.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B ;
 800c87e:	2360      	movs	r3, #96	; 0x60
 800c880:	9302      	str	r3, [sp, #8]
    sdmmc_datainitstructure.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800c882:	2302      	movs	r3, #2
 800c884:	9303      	str	r3, [sp, #12]
    sdmmc_datainitstructure.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800c886:	9004      	str	r0, [sp, #16]
    sdmmc_datainitstructure.DPSM          = SDMMC_DPSM_ENABLE;
 800c888:	2301      	movs	r3, #1

    if ( SDMMC_ConfigData(hsd->Instance, &sdmmc_datainitstructure) != HAL_OK)
 800c88a:	4669      	mov	r1, sp
 800c88c:	6830      	ldr	r0, [r6, #0]
    sdmmc_datainitstructure.DataTimeOut   = SDMMC_DATATIMEOUT;
    sdmmc_datainitstructure.DataLength    = 64U;
    sdmmc_datainitstructure.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B ;
    sdmmc_datainitstructure.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
    sdmmc_datainitstructure.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
    sdmmc_datainitstructure.DPSM          = SDMMC_DPSM_ENABLE;
 800c88e:	9305      	str	r3, [sp, #20]

    if ( SDMMC_ConfigData(hsd->Instance, &sdmmc_datainitstructure) != HAL_OK)
 800c890:	f000 f9ba 	bl	800cc08 <SDMMC_ConfigData>
 800c894:	2800      	cmp	r0, #0
 800c896:	d145      	bne.n	800c924 <SD_HighSpeed+0xe4>
    {
      return (HAL_SD_ERROR_GENERAL_UNKNOWN_ERR);
    }


    errorstate = SDMMC_CmdSwitch(hsd->Instance,SDMMC_SDR25_SWITCH_PATTERN);
 800c898:	4925      	ldr	r1, [pc, #148]	; (800c930 <SD_HighSpeed+0xf0>)
 800c89a:	6830      	ldr	r0, [r6, #0]
 800c89c:	f000 fc47 	bl	800d12e <SDMMC_CmdSwitch>
    if(errorstate != HAL_SD_ERROR_NONE)
 800c8a0:	2800      	cmp	r0, #0
 800c8a2:	d141      	bne.n	800c928 <SD_HighSpeed+0xe8>
 800c8a4:	4604      	mov	r4, r0
    {
      return errorstate;
    }

    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND| SDMMC_FLAG_DATAEND ))
 800c8a6:	6833      	ldr	r3, [r6, #0]
 800c8a8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c8aa:	f240 552a 	movw	r5, #1322	; 0x52a
 800c8ae:	4015      	ands	r5, r2
 800c8b0:	b9d5      	cbnz	r5, 800c8e8 <SD_HighSpeed+0xa8>
    {
      if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
 800c8b2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800c8b4:	041b      	lsls	r3, r3, #16
 800c8b6:	d50b      	bpl.n	800c8d0 <SD_HighSpeed+0x90>
 800c8b8:	ab06      	add	r3, sp, #24
 800c8ba:	eb03 1844 	add.w	r8, r3, r4, lsl #5
      {
        for (count = 0U; count < 8U; count++)
        {
          SD_hs[(8U*loop)+count]  = SDMMC_ReadFIFO(hsd->Instance);
 800c8be:	6830      	ldr	r0, [r6, #0]
 800c8c0:	f000 f966 	bl	800cb90 <SDMMC_ReadFIFO>
 800c8c4:	f848 0025 	str.w	r0, [r8, r5, lsl #2]

    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND| SDMMC_FLAG_DATAEND ))
    {
      if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
      {
        for (count = 0U; count < 8U; count++)
 800c8c8:	3501      	adds	r5, #1
 800c8ca:	2d08      	cmp	r5, #8
 800c8cc:	d1f7      	bne.n	800c8be <SD_HighSpeed+0x7e>
        {
          SD_hs[(8U*loop)+count]  = SDMMC_ReadFIFO(hsd->Instance);
        }
        loop ++;
 800c8ce:	3401      	adds	r4, #1
      }

      if((HAL_GetTick()-Timeout) >=  SDMMC_DATATIMEOUT)
 800c8d0:	f7fa fb9c 	bl	800700c <HAL_GetTick>
 800c8d4:	1bc0      	subs	r0, r0, r7
 800c8d6:	3001      	adds	r0, #1
 800c8d8:	d1e5      	bne.n	800c8a6 <SD_HighSpeed+0x66>
      {
        hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
 800c8da:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
        hsd->State= HAL_SD_STATE_READY;
 800c8de:	2301      	movs	r3, #1
        loop ++;
      }

      if((HAL_GetTick()-Timeout) >=  SDMMC_DATATIMEOUT)
      {
        hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
 800c8e0:	63b0      	str	r0, [r6, #56]	; 0x38
        hsd->State= HAL_SD_STATE_READY;
 800c8e2:	f886 3034 	strb.w	r3, [r6, #52]	; 0x34
        return HAL_SD_ERROR_TIMEOUT;
 800c8e6:	e01f      	b.n	800c928 <SD_HighSpeed+0xe8>
      }
    }

    if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 800c8e8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c8ea:	0710      	lsls	r0, r2, #28
 800c8ec:	d503      	bpl.n	800c8f6 <SD_HighSpeed+0xb6>
    {
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
 800c8ee:	2208      	movs	r2, #8
 800c8f0:	639a      	str	r2, [r3, #56]	; 0x38

      return errorstate;
 800c8f2:	2000      	movs	r0, #0
 800c8f4:	e018      	b.n	800c928 <SD_HighSpeed+0xe8>
    }
    else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800c8f6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c8f8:	0791      	lsls	r1, r2, #30
 800c8fa:	d501      	bpl.n	800c900 <SD_HighSpeed+0xc0>
    {
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
 800c8fc:	2002      	movs	r0, #2
 800c8fe:	e003      	b.n	800c908 <SD_HighSpeed+0xc8>

      errorstate = SDMMC_ERROR_DATA_CRC_FAIL;

      return errorstate;
    }
    else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 800c900:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c902:	0692      	lsls	r2, r2, #26
 800c904:	d502      	bpl.n	800c90c <SD_HighSpeed+0xcc>
    {
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
 800c906:	2020      	movs	r0, #32
 800c908:	6398      	str	r0, [r3, #56]	; 0x38

      errorstate = SDMMC_ERROR_RX_OVERRUN;

      return errorstate;
 800c90a:	e00d      	b.n	800c928 <SD_HighSpeed+0xe8>
    {
      /* No error flag set */
    }

    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800c90c:	4a09      	ldr	r2, [pc, #36]	; (800c934 <SD_HighSpeed+0xf4>)
 800c90e:	639a      	str	r2, [r3, #56]	; 0x38

    /* Test if the switch mode HS is ok */
    if ((((uint8_t*)SD_hs)[13] & 2U) != 2U)
 800c910:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
 800c914:	079b      	lsls	r3, r3, #30
 800c916:	d4ec      	bmi.n	800c8f2 <SD_HighSpeed+0xb2>
    {
      errorstate = SDMMC_ERROR_UNSUPPORTED_FEATURE;
 800c918:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 800c91c:	e004      	b.n	800c928 <SD_HighSpeed+0xe8>
  uint32_t Timeout = HAL_GetTick();

  if(hsd->SdCard.CardSpeed == CARD_NORMAL_SPEED)
  {
     /* Standard Speed Card <= 12.5Mhz  */
     return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 800c91e:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 800c922:	e001      	b.n	800c928 <SD_HighSpeed+0xe8>
    sdmmc_datainitstructure.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
    sdmmc_datainitstructure.DPSM          = SDMMC_DPSM_ENABLE;

    if ( SDMMC_ConfigData(hsd->Instance, &sdmmc_datainitstructure) != HAL_OK)
    {
      return (HAL_SD_ERROR_GENERAL_UNKNOWN_ERR);
 800c924:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    }

  }

  return errorstate;
}
 800c928:	b016      	add	sp, #88	; 0x58
 800c92a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c92e:	bf00      	nop
 800c930:	80ffff01 	.word	0x80ffff01
 800c934:	18000f3a 	.word	0x18000f3a

0800c938 <HAL_SD_ConfigSpeedBusOperation>:
  *            @arg SDMMC_SPEED_MODE_ULTRA: Ultra high speed mode
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_SD_ConfigSpeedBusOperation(SD_HandleTypeDef *hsd, uint32_t SpeedMode)
{
 800c938:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  HAL_StatusTypeDef status = HAL_OK;

  /* Check the parameters */
  assert_param(IS_SDMMC_SPEED_MODE(SpeedMode));
  /* Change State */
  hsd->State = HAL_SD_STATE_BUSY;
 800c93c:	2303      	movs	r3, #3
 800c93e:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34

  if(hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE)
 800c942:	6983      	ldr	r3, [r0, #24]
 800c944:	2b01      	cmp	r3, #1
  *            @arg SDMMC_SPEED_MODE_ULTRA: Ultra high speed mode
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_SD_ConfigSpeedBusOperation(SD_HandleTypeDef *hsd, uint32_t SpeedMode)
{
 800c946:	b096      	sub	sp, #88	; 0x58
 800c948:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_SDMMC_SPEED_MODE(SpeedMode));
  /* Change State */
  hsd->State = HAL_SD_STATE_BUSY;

  if(hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE)
 800c94a:	f040 80ae 	bne.w	800caaa <HAL_SD_ConfigSpeedBusOperation+0x172>
  {
    switch (SpeedMode)
 800c94e:	2904      	cmp	r1, #4
 800c950:	f200 80ce 	bhi.w	800caf0 <HAL_SD_ConfigSpeedBusOperation+0x1b8>
 800c954:	e8df f011 	tbh	[pc, r1, lsl #1]
 800c958:	00d20005 	.word	0x00d20005
 800c95c:	001b00ba 	.word	0x001b00ba
 800c960:	002c      	.short	0x002c
    {
      case SDMMC_SPEED_MODE_AUTO:
      {
        if ((hsd->SdCard.CardSpeed  == CARD_ULTRA_HIGH_SPEED) ||
 800c962:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 800c964:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800c968:	d002      	beq.n	800c970 <HAL_SD_ConfigSpeedBusOperation+0x38>
 800c96a:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 800c96c:	2a01      	cmp	r2, #1
 800c96e:	d10b      	bne.n	800c988 <HAL_SD_ConfigSpeedBusOperation+0x50>
            (hsd->SdCard.CardType == CARD_SDHC_SDXC))
        {
          hsd->Instance->CLKCR |= 0x00100000U;
 800c970:	6822      	ldr	r2, [r4, #0]
 800c972:	6853      	ldr	r3, [r2, #4]
 800c974:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800c978:	6053      	str	r3, [r2, #4]
          /* Enable Ultra High Speed */
          if (SD_UltraHighSpeed(hsd) != HAL_SD_ERROR_NONE)
 800c97a:	4620      	mov	r0, r4
 800c97c:	f7ff f8d8 	bl	800bb30 <SD_UltraHighSpeed>
 800c980:	2800      	cmp	r0, #0
 800c982:	f000 80bb 	beq.w	800cafc <HAL_SD_ConfigSpeedBusOperation+0x1c4>
 800c986:	e0ab      	b.n	800cae0 <HAL_SD_ConfigSpeedBusOperation+0x1a8>
              hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
              status = HAL_ERROR;
            }
          }
        }
        else if (hsd->SdCard.CardSpeed  == CARD_HIGH_SPEED)
 800c988:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800c98c:	e09c      	b.n	800cac8 <HAL_SD_ConfigSpeedBusOperation+0x190>
        break;
      }

      case SDMMC_SPEED_MODE_ULTRA:
      {
        if ((hsd->SdCard.CardSpeed  == CARD_ULTRA_HIGH_SPEED) ||
 800c98e:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 800c990:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800c994:	d003      	beq.n	800c99e <HAL_SD_ConfigSpeedBusOperation+0x66>
 800c996:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 800c998:	2b01      	cmp	r3, #1
 800c99a:	f040 80a5 	bne.w	800cae8 <HAL_SD_ConfigSpeedBusOperation+0x1b0>
            (hsd->SdCard.CardType == CARD_SDHC_SDXC))
        {
          hsd->Instance->CLKCR |= 0x00100000U;
 800c99e:	6822      	ldr	r2, [r4, #0]
 800c9a0:	6853      	ldr	r3, [r2, #4]
 800c9a2:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800c9a6:	6053      	str	r3, [r2, #4]
          /* Enable UltraHigh Speed */
          if (SD_UltraHighSpeed(hsd) != HAL_SD_ERROR_NONE)
 800c9a8:	4620      	mov	r0, r4
 800c9aa:	f7ff f8c1 	bl	800bb30 <SD_UltraHighSpeed>
 800c9ae:	e09a      	b.n	800cae6 <HAL_SD_ConfigSpeedBusOperation+0x1ae>
        break;
      }

      case SDMMC_SPEED_MODE_DDR:
      {
        if ((hsd->SdCard.CardSpeed  == CARD_ULTRA_HIGH_SPEED) ||
 800c9b0:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 800c9b2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800c9b6:	d003      	beq.n	800c9c0 <HAL_SD_ConfigSpeedBusOperation+0x88>
 800c9b8:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 800c9ba:	2b01      	cmp	r3, #1
 800c9bc:	f040 8094 	bne.w	800cae8 <HAL_SD_ConfigSpeedBusOperation+0x1b0>
            (hsd->SdCard.CardType == CARD_SDHC_SDXC))
        {
          hsd->Instance->CLKCR |= 0x00100000U;
 800c9c0:	6822      	ldr	r2, [r4, #0]
 800c9c2:	6853      	ldr	r3, [r2, #4]
  */
static uint32_t SD_DDR_Mode(SD_HandleTypeDef *hsd)
{
  uint32_t errorstate = HAL_SD_ERROR_NONE;
  SDMMC_DataInitTypeDef sdmmc_datainitstructure;
  uint32_t SD_hs[16]  = {0};
 800c9c4:	2540      	movs	r5, #64	; 0x40
      case SDMMC_SPEED_MODE_DDR:
      {
        if ((hsd->SdCard.CardSpeed  == CARD_ULTRA_HIGH_SPEED) ||
            (hsd->SdCard.CardType == CARD_SDHC_SDXC))
        {
          hsd->Instance->CLKCR |= 0x00100000U;
 800c9c6:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800c9ca:	6053      	str	r3, [r2, #4]
  */
static uint32_t SD_DDR_Mode(SD_HandleTypeDef *hsd)
{
  uint32_t errorstate = HAL_SD_ERROR_NONE;
  SDMMC_DataInitTypeDef sdmmc_datainitstructure;
  uint32_t SD_hs[16]  = {0};
 800c9cc:	2100      	movs	r1, #0
 800c9ce:	462a      	mov	r2, r5
 800c9d0:	a806      	add	r0, sp, #24
 800c9d2:	f000 fd78 	bl	800d4c6 <memset>
  uint32_t count, loop = 0 ;
  uint32_t Timeout = HAL_GetTick();
 800c9d6:	f7fa fb19 	bl	800700c <HAL_GetTick>

  if(hsd->SdCard.CardSpeed == CARD_NORMAL_SPEED)
 800c9da:	6de3      	ldr	r3, [r4, #92]	; 0x5c
{
  uint32_t errorstate = HAL_SD_ERROR_NONE;
  SDMMC_DataInitTypeDef sdmmc_datainitstructure;
  uint32_t SD_hs[16]  = {0};
  uint32_t count, loop = 0 ;
  uint32_t Timeout = HAL_GetTick();
 800c9dc:	4607      	mov	r7, r0

  if(hsd->SdCard.CardSpeed == CARD_NORMAL_SPEED)
 800c9de:	2b00      	cmp	r3, #0
 800c9e0:	f000 8082 	beq.w	800cae8 <HAL_SD_ConfigSpeedBusOperation+0x1b0>
  {
     /* Standard Speed Card <= 12.5Mhz  */
     return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
  }

  if((hsd->SdCard.CardSpeed == CARD_ULTRA_HIGH_SPEED) &&
 800c9e4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800c9e8:	f040 8088 	bne.w	800cafc <HAL_SD_ConfigSpeedBusOperation+0x1c4>
 800c9ec:	69a6      	ldr	r6, [r4, #24]
 800c9ee:	2e01      	cmp	r6, #1
 800c9f0:	f040 8084 	bne.w	800cafc <HAL_SD_ConfigSpeedBusOperation+0x1c4>
     (hsd->Init.Transceiver == SDMMC_TRANSCEIVER_ENABLE))
  {
    /* Initialize the Data control register */
    hsd->Instance->DCTRL = 0;
 800c9f4:	6820      	ldr	r0, [r4, #0]
 800c9f6:	2300      	movs	r3, #0
 800c9f8:	62c3      	str	r3, [r0, #44]	; 0x2c
    errorstate = SDMMC_CmdBlockLength(hsd->Instance, 64U);
 800c9fa:	4629      	mov	r1, r5
 800c9fc:	f000 f9e0 	bl	800cdc0 <SDMMC_CmdBlockLength>

    if (errorstate != HAL_SD_ERROR_NONE)
 800ca00:	2800      	cmp	r0, #0
 800ca02:	d170      	bne.n	800cae6 <HAL_SD_ConfigSpeedBusOperation+0x1ae>
    {
      return errorstate;
    }

    /* Configure the SD DPSM (Data Path State Machine) */
    sdmmc_datainitstructure.DataTimeOut   = SDMMC_DATATIMEOUT;
 800ca04:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    sdmmc_datainitstructure.DataLength    = 64U;
 800ca08:	e88d 0028 	stmia.w	sp, {r3, r5}
    sdmmc_datainitstructure.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B ;
 800ca0c:	2360      	movs	r3, #96	; 0x60
 800ca0e:	9302      	str	r3, [sp, #8]
    sdmmc_datainitstructure.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
    sdmmc_datainitstructure.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800ca10:	9004      	str	r0, [sp, #16]

    /* Configure the SD DPSM (Data Path State Machine) */
    sdmmc_datainitstructure.DataTimeOut   = SDMMC_DATATIMEOUT;
    sdmmc_datainitstructure.DataLength    = 64U;
    sdmmc_datainitstructure.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B ;
    sdmmc_datainitstructure.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800ca12:	2302      	movs	r3, #2
    sdmmc_datainitstructure.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
    sdmmc_datainitstructure.DPSM          = SDMMC_DPSM_ENABLE;

    if ( SDMMC_ConfigData(hsd->Instance, &sdmmc_datainitstructure) != HAL_OK)
 800ca14:	4669      	mov	r1, sp
 800ca16:	6820      	ldr	r0, [r4, #0]

    /* Configure the SD DPSM (Data Path State Machine) */
    sdmmc_datainitstructure.DataTimeOut   = SDMMC_DATATIMEOUT;
    sdmmc_datainitstructure.DataLength    = 64U;
    sdmmc_datainitstructure.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B ;
    sdmmc_datainitstructure.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800ca18:	9303      	str	r3, [sp, #12]
    sdmmc_datainitstructure.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
    sdmmc_datainitstructure.DPSM          = SDMMC_DPSM_ENABLE;
 800ca1a:	9605      	str	r6, [sp, #20]

    if ( SDMMC_ConfigData(hsd->Instance, &sdmmc_datainitstructure) != HAL_OK)
 800ca1c:	f000 f8f4 	bl	800cc08 <SDMMC_ConfigData>
 800ca20:	2800      	cmp	r0, #0
 800ca22:	d161      	bne.n	800cae8 <HAL_SD_ConfigSpeedBusOperation+0x1b0>
    {
      return (HAL_SD_ERROR_GENERAL_UNKNOWN_ERR);
    }

    errorstate = SDMMC_CmdSwitch(hsd->Instance, SDMMC_DDR50_SWITCH_PATTERN);
 800ca24:	494a      	ldr	r1, [pc, #296]	; (800cb50 <HAL_SD_ConfigSpeedBusOperation+0x218>)
 800ca26:	6820      	ldr	r0, [r4, #0]
 800ca28:	f000 fb81 	bl	800d12e <SDMMC_CmdSwitch>
    if(errorstate != HAL_SD_ERROR_NONE)
 800ca2c:	2800      	cmp	r0, #0
 800ca2e:	d15a      	bne.n	800cae6 <HAL_SD_ConfigSpeedBusOperation+0x1ae>
 800ca30:	4605      	mov	r5, r0
    {
      return errorstate;
    }

    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND| SDMMC_FLAG_DATAEND ))
 800ca32:	6823      	ldr	r3, [r4, #0]
 800ca34:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800ca36:	f240 562a 	movw	r6, #1322	; 0x52a
 800ca3a:	4016      	ands	r6, r2
 800ca3c:	b9d6      	cbnz	r6, 800ca74 <HAL_SD_ConfigSpeedBusOperation+0x13c>
    {
      if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
 800ca3e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ca40:	041b      	lsls	r3, r3, #16
 800ca42:	d50b      	bpl.n	800ca5c <HAL_SD_ConfigSpeedBusOperation+0x124>
 800ca44:	ab06      	add	r3, sp, #24
 800ca46:	eb03 1845 	add.w	r8, r3, r5, lsl #5
      {
        for (count = 0U; count < 8U; count++)
        {
          SD_hs[(8U*loop)+count]  = SDMMC_ReadFIFO(hsd->Instance);
 800ca4a:	6820      	ldr	r0, [r4, #0]
 800ca4c:	f000 f8a0 	bl	800cb90 <SDMMC_ReadFIFO>
 800ca50:	f848 0026 	str.w	r0, [r8, r6, lsl #2]

    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND| SDMMC_FLAG_DATAEND ))
    {
      if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
      {
        for (count = 0U; count < 8U; count++)
 800ca54:	3601      	adds	r6, #1
 800ca56:	2e08      	cmp	r6, #8
 800ca58:	d1f7      	bne.n	800ca4a <HAL_SD_ConfigSpeedBusOperation+0x112>
        {
          SD_hs[(8U*loop)+count]  = SDMMC_ReadFIFO(hsd->Instance);
        }
        loop ++;
 800ca5a:	3501      	adds	r5, #1
      }

      if((HAL_GetTick()-Timeout) >=  SDMMC_DATATIMEOUT)
 800ca5c:	f7fa fad6 	bl	800700c <HAL_GetTick>
 800ca60:	1bc0      	subs	r0, r0, r7
 800ca62:	3001      	adds	r0, #1
 800ca64:	d1e5      	bne.n	800ca32 <HAL_SD_ConfigSpeedBusOperation+0xfa>
      {
        hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
 800ca66:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 800ca6a:	63a3      	str	r3, [r4, #56]	; 0x38
        hsd->State= HAL_SD_STATE_READY;
 800ca6c:	2301      	movs	r3, #1
 800ca6e:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800ca72:	e039      	b.n	800cae8 <HAL_SD_ConfigSpeedBusOperation+0x1b0>
        return HAL_SD_ERROR_TIMEOUT;
      }
    }

    if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 800ca74:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800ca76:	0710      	lsls	r0, r2, #28
 800ca78:	d502      	bpl.n	800ca80 <HAL_SD_ConfigSpeedBusOperation+0x148>
    {
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
 800ca7a:	2208      	movs	r2, #8
 800ca7c:	639a      	str	r2, [r3, #56]	; 0x38
 800ca7e:	e03d      	b.n	800cafc <HAL_SD_ConfigSpeedBusOperation+0x1c4>

      return errorstate;
    }
    else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800ca80:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800ca82:	0791      	lsls	r1, r2, #30
 800ca84:	d501      	bpl.n	800ca8a <HAL_SD_ConfigSpeedBusOperation+0x152>
    {
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
 800ca86:	2202      	movs	r2, #2
 800ca88:	e003      	b.n	800ca92 <HAL_SD_ConfigSpeedBusOperation+0x15a>

      errorstate = SDMMC_ERROR_DATA_CRC_FAIL;

      return errorstate;
    }
    else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 800ca8a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800ca8c:	0692      	lsls	r2, r2, #26
 800ca8e:	d502      	bpl.n	800ca96 <HAL_SD_ConfigSpeedBusOperation+0x15e>
    {
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
 800ca90:	2220      	movs	r2, #32
 800ca92:	639a      	str	r2, [r3, #56]	; 0x38
 800ca94:	e028      	b.n	800cae8 <HAL_SD_ConfigSpeedBusOperation+0x1b0>
    {
      /* No error flag set */
    }

    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800ca96:	4a2f      	ldr	r2, [pc, #188]	; (800cb54 <HAL_SD_ConfigSpeedBusOperation+0x21c>)
 800ca98:	639a      	str	r2, [r3, #56]	; 0x38

    /* Test if the switch mode  is ok */
    if ((((uint8_t*)SD_hs)[13] & 2U) != 2U)
 800ca9a:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
 800ca9e:	079b      	lsls	r3, r3, #30
 800caa0:	d522      	bpl.n	800cae8 <HAL_SD_ConfigSpeedBusOperation+0x1b0>
    else
    {
#if defined (USE_HAL_SD_REGISTER_CALLBACKS) && (USE_HAL_SD_REGISTER_CALLBACKS == 1U)
      hsd->DriveTransceiver_1_8V_Callback(SET);
#else
      HAL_SDEx_DriveTransceiver_1_8V_Callback(SET);
 800caa2:	2001      	movs	r0, #1
 800caa4:	f7fa fb22 	bl	80070ec <HAL_SDEx_DriveTransceiver_1_8V_Callback>
 800caa8:	e028      	b.n	800cafc <HAL_SD_ConfigSpeedBusOperation+0x1c4>
        break;
    }
  }
  else
  {
    switch (SpeedMode)
 800caaa:	2901      	cmp	r1, #1
 800caac:	d026      	beq.n	800cafc <HAL_SD_ConfigSpeedBusOperation+0x1c4>
 800caae:	d302      	bcc.n	800cab6 <HAL_SD_ConfigSpeedBusOperation+0x17e>
 800cab0:	2902      	cmp	r1, #2
 800cab2:	d00b      	beq.n	800cacc <HAL_SD_ConfigSpeedBusOperation+0x194>
 800cab4:	e01c      	b.n	800caf0 <HAL_SD_ConfigSpeedBusOperation+0x1b8>
    {
      case SDMMC_SPEED_MODE_AUTO:
      {
        if ((hsd->SdCard.CardSpeed  == CARD_ULTRA_HIGH_SPEED) ||
 800cab6:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 800cab8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800cabc:	d010      	beq.n	800cae0 <HAL_SD_ConfigSpeedBusOperation+0x1a8>
 800cabe:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800cac2:	d00d      	beq.n	800cae0 <HAL_SD_ConfigSpeedBusOperation+0x1a8>
            (hsd->SdCard.CardSpeed  == CARD_HIGH_SPEED) ||
 800cac4:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 800cac6:	2b01      	cmp	r3, #1
 800cac8:	d118      	bne.n	800cafc <HAL_SD_ConfigSpeedBusOperation+0x1c4>
 800caca:	e009      	b.n	800cae0 <HAL_SD_ConfigSpeedBusOperation+0x1a8>
        break;
      }

      case SDMMC_SPEED_MODE_HIGH:
      {
        if ((hsd->SdCard.CardSpeed  == CARD_ULTRA_HIGH_SPEED) ||
 800cacc:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800cace:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800cad2:	d005      	beq.n	800cae0 <HAL_SD_ConfigSpeedBusOperation+0x1a8>
 800cad4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800cad8:	d002      	beq.n	800cae0 <HAL_SD_ConfigSpeedBusOperation+0x1a8>
            (hsd->SdCard.CardSpeed  == CARD_HIGH_SPEED) ||
 800cada:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800cadc:	2b01      	cmp	r3, #1
 800cade:	d103      	bne.n	800cae8 <HAL_SD_ConfigSpeedBusOperation+0x1b0>
            (hsd->SdCard.CardType == CARD_SDHC_SDXC))
        {
          /* Enable High Speed */
          if (SD_HighSpeed(hsd) != HAL_SD_ERROR_NONE)
 800cae0:	4620      	mov	r0, r4
 800cae2:	f7ff fead 	bl	800c840 <SD_HighSpeed>
 800cae6:	b148      	cbz	r0, 800cafc <HAL_SD_ConfigSpeedBusOperation+0x1c4>
            status = HAL_ERROR;
          }
        }
        else
        {
          hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800cae8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800caea:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800caee:	e002      	b.n	800caf6 <HAL_SD_ConfigSpeedBusOperation+0x1be>
      case SDMMC_SPEED_MODE_DEFAULT:
        break;

      case SDMMC_SPEED_MODE_ULTRA: /*not valid without transceiver*/
      default:
        hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800caf0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800caf2:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 800caf6:	63a3      	str	r3, [r4, #56]	; 0x38
        status = HAL_ERROR;
 800caf8:	2501      	movs	r5, #1
        break;
 800cafa:	e000      	b.n	800cafe <HAL_SD_ConfigSpeedBusOperation+0x1c6>

HAL_StatusTypeDef HAL_SD_ConfigSpeedBusOperation(SD_HandleTypeDef *hsd, uint32_t SpeedMode)
{
  uint32_t tickstart;
  uint32_t errorstate;
  HAL_StatusTypeDef status = HAL_OK;
 800cafc:	2500      	movs	r5, #0
        break;
    }
  }

  /* Verify that SD card is ready to use after Speed mode switch*/
  tickstart = HAL_GetTick();
 800cafe:	f7fa fa85 	bl	800700c <HAL_GetTick>
 800cb02:	4606      	mov	r6, r0
  while ((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
 800cb04:	4620      	mov	r0, r4
 800cb06:	f7ff fe31 	bl	800c76c <HAL_SD_GetCardState>
 800cb0a:	2804      	cmp	r0, #4
 800cb0c:	d00c      	beq.n	800cb28 <HAL_SD_ConfigSpeedBusOperation+0x1f0>
  {
    if ((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 800cb0e:	f7fa fa7d 	bl	800700c <HAL_GetTick>
 800cb12:	1b80      	subs	r0, r0, r6
 800cb14:	3001      	adds	r0, #1
 800cb16:	d1f5      	bne.n	800cb04 <HAL_SD_ConfigSpeedBusOperation+0x1cc>
    {
      hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
 800cb18:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 800cb1c:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800cb1e:	2301      	movs	r3, #1
 800cb20:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      return HAL_TIMEOUT;
 800cb24:	2003      	movs	r0, #3
 800cb26:	e010      	b.n	800cb4a <HAL_SD_ConfigSpeedBusOperation+0x212>
    }
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 800cb28:	f44f 7100 	mov.w	r1, #512	; 0x200
 800cb2c:	6820      	ldr	r0, [r4, #0]
 800cb2e:	f000 f947 	bl	800cdc0 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800cb32:	b130      	cbz	r0, 800cb42 <HAL_SD_ConfigSpeedBusOperation+0x20a>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cb34:	6823      	ldr	r3, [r4, #0]
 800cb36:	4a08      	ldr	r2, [pc, #32]	; (800cb58 <HAL_SD_ConfigSpeedBusOperation+0x220>)
 800cb38:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
 800cb3a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800cb3c:	4318      	orrs	r0, r3
 800cb3e:	63a0      	str	r0, [r4, #56]	; 0x38
    status = HAL_ERROR;
 800cb40:	2501      	movs	r5, #1
  }

  /* Change State */
  hsd->State = HAL_SD_STATE_READY;
 800cb42:	2301      	movs	r3, #1
 800cb44:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  return status;
 800cb48:	4628      	mov	r0, r5
}
 800cb4a:	b016      	add	sp, #88	; 0x58
 800cb4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800cb50:	80ffff04 	.word	0x80ffff04
 800cb54:	18000f3a 	.word	0x18000f3a
 800cb58:	1fe00fff 	.word	0x1fe00fff

0800cb5c <SDMMC_Init>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Init SDMMC initialization structure
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_Init(SDMMC_TypeDef *SDMMCx, SDMMC_InitTypeDef Init)
{
 800cb5c:	b084      	sub	sp, #16
 800cb5e:	b510      	push	{r4, lr}
 800cb60:	ac03      	add	r4, sp, #12
 800cb62:	e884 000e 	stmia.w	r4, {r1, r2, r3}
             Init.HardwareFlowControl |\
             Init.ClockDiv
             );

  /* Write to SDMMC CLKCR */
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
 800cb66:	9b04      	ldr	r3, [sp, #16]
 800cb68:	9a03      	ldr	r2, [sp, #12]
 800cb6a:	6841      	ldr	r1, [r0, #4]
 800cb6c:	431a      	orrs	r2, r3
 800cb6e:	9b05      	ldr	r3, [sp, #20]
 800cb70:	431a      	orrs	r2, r3
 800cb72:	9b06      	ldr	r3, [sp, #24]
 800cb74:	431a      	orrs	r2, r3
 800cb76:	9b07      	ldr	r3, [sp, #28]

  return HAL_OK;
}
 800cb78:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
             Init.HardwareFlowControl |\
             Init.ClockDiv
             );

  /* Write to SDMMC CLKCR */
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
 800cb7c:	431a      	orrs	r2, r3
 800cb7e:	4b03      	ldr	r3, [pc, #12]	; (800cb8c <SDMMC_Init+0x30>)
 800cb80:	400b      	ands	r3, r1
 800cb82:	4313      	orrs	r3, r2
 800cb84:	6043      	str	r3, [r0, #4]

  return HAL_OK;
}
 800cb86:	b004      	add	sp, #16
 800cb88:	2000      	movs	r0, #0
 800cb8a:	4770      	bx	lr
 800cb8c:	ffc02c00 	.word	0xffc02c00

0800cb90 <SDMMC_ReadFIFO>:
 800cb90:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 800cb94:	4770      	bx	lr

0800cb96 <SDMMC_WriteFIFO>:
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_WriteFIFO(SDMMC_TypeDef *SDMMCx, uint32_t *pWriteData)
{
  /* Write data to FIFO */
  SDMMCx->FIFO = *pWriteData;
 800cb96:	680b      	ldr	r3, [r1, #0]
 800cb98:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80

  return HAL_OK;
}
 800cb9c:	2000      	movs	r0, #0
 800cb9e:	4770      	bx	lr

0800cba0 <SDMMC_PowerState_ON>:
  * @brief  Set SDMMC Power state to ON.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_PowerState_ON(SDMMC_TypeDef *SDMMCx)
{
 800cba0:	b508      	push	{r3, lr}
  /* Set power state to ON */
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  SDMMCx->POWER |= SDMMC_POWER_PWRCTRL;
 800cba2:	6803      	ldr	r3, [r0, #0]
 800cba4:	f043 0303 	orr.w	r3, r3, #3
 800cba8:	6003      	str	r3, [r0, #0]
  SDMMCx->POWER = SDMMC_POWER_PWRCTRL;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

  /* 1ms: required power up waiting time before starting the SD initialization
  sequence */
  HAL_Delay(2);
 800cbaa:	2002      	movs	r0, #2
 800cbac:	f7f6 fe7a 	bl	80038a4 <HAL_Delay>

  return HAL_OK;
}
 800cbb0:	2000      	movs	r0, #0
 800cbb2:	bd08      	pop	{r3, pc}

0800cbb4 <SDMMC_PowerState_Cycle>:
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_PowerState_Cycle(SDMMC_TypeDef *SDMMCx)
{
  /* Set power state to Power Cycle*/
  SDMMCx->POWER |= SDMMC_POWER_PWRCTRL_1;
 800cbb4:	6803      	ldr	r3, [r0, #0]
 800cbb6:	f043 0302 	orr.w	r3, r3, #2
 800cbba:	6003      	str	r3, [r0, #0]

  return HAL_OK;
}
 800cbbc:	2000      	movs	r0, #0
 800cbbe:	4770      	bx	lr

0800cbc0 <SDMMC_PowerState_OFF>:
  */
HAL_StatusTypeDef SDMMC_PowerState_OFF(SDMMC_TypeDef *SDMMCx)
{
  /* Set power state to OFF */
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  SDMMCx->POWER &= ~(SDMMC_POWER_PWRCTRL);
 800cbc0:	6803      	ldr	r3, [r0, #0]
 800cbc2:	f023 0303 	bic.w	r3, r3, #3
 800cbc6:	6003      	str	r3, [r0, #0]
#else
  SDMMCx->POWER = (uint32_t)0x00000000;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

  return HAL_OK;
}
 800cbc8:	2000      	movs	r0, #0
 800cbca:	4770      	bx	lr

0800cbcc <SDMMC_GetPowerState>:
  *            - 0x02: Power UP
  *            - 0x03: Power ON
  */
uint32_t SDMMC_GetPowerState(SDMMC_TypeDef *SDMMCx)
{
  return (SDMMCx->POWER & SDMMC_POWER_PWRCTRL);
 800cbcc:	6800      	ldr	r0, [r0, #0]
}
 800cbce:	f000 0003 	and.w	r0, r0, #3
 800cbd2:	4770      	bx	lr

0800cbd4 <SDMMC_SendCommand>:
  assert_param(IS_SDMMC_RESPONSE(Command->Response));
  assert_param(IS_SDMMC_WAIT(Command->WaitForInterrupt));
  assert_param(IS_SDMMC_CPSM(Command->CPSM));

  /* Set the SDMMC Argument value */
  SDMMCx->ARG = Command->Argument;
 800cbd4:	680b      	ldr	r3, [r1, #0]
                       Command->Response         |\
                       Command->WaitForInterrupt |\
                       Command->CPSM);

  /* Write to SDMMC CMD register */
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800cbd6:	684a      	ldr	r2, [r1, #4]
  * @param  Command pointer to a SDMMC_CmdInitTypeDef structure that contains
  *         the configuration information for the SDMMC command
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_SendCommand(SDMMC_TypeDef *SDMMCx, SDMMC_CmdInitTypeDef *Command)
{
 800cbd8:	b510      	push	{r4, lr}
  assert_param(IS_SDMMC_RESPONSE(Command->Response));
  assert_param(IS_SDMMC_WAIT(Command->WaitForInterrupt));
  assert_param(IS_SDMMC_CPSM(Command->CPSM));

  /* Set the SDMMC Argument value */
  SDMMCx->ARG = Command->Argument;
 800cbda:	6083      	str	r3, [r0, #8]
                       Command->Response         |\
                       Command->WaitForInterrupt |\
                       Command->CPSM);

  /* Write to SDMMC CMD register */
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800cbdc:	688b      	ldr	r3, [r1, #8]
 800cbde:	68c4      	ldr	r4, [r0, #12]
 800cbe0:	431a      	orrs	r2, r3
 800cbe2:	68cb      	ldr	r3, [r1, #12]
 800cbe4:	4313      	orrs	r3, r2
 800cbe6:	690a      	ldr	r2, [r1, #16]
 800cbe8:	431a      	orrs	r2, r3
 800cbea:	4b03      	ldr	r3, [pc, #12]	; (800cbf8 <SDMMC_SendCommand+0x24>)
 800cbec:	4023      	ands	r3, r4
 800cbee:	4313      	orrs	r3, r2
 800cbf0:	60c3      	str	r3, [r0, #12]

  return HAL_OK;
}
 800cbf2:	2000      	movs	r0, #0
 800cbf4:	bd10      	pop	{r4, pc}
 800cbf6:	bf00      	nop
 800cbf8:	fffee0c0 	.word	0xfffee0c0

0800cbfc <SDMMC_GetCommandResponse>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval Command index of the last command response received
  */
uint8_t SDMMC_GetCommandResponse(SDMMC_TypeDef *SDMMCx)
{
  return (uint8_t)(SDMMCx->RESPCMD);
 800cbfc:	6900      	ldr	r0, [r0, #16]
}
 800cbfe:	b2c0      	uxtb	r0, r0
 800cc00:	4770      	bx	lr

0800cc02 <SDMMC_GetResponse>:

  /* Check the parameters */
  assert_param(IS_SDMMC_RESP(Response));

  /* Get the response */
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;
 800cc02:	3014      	adds	r0, #20

  return (*(__IO uint32_t *) tmp);
 800cc04:	5840      	ldr	r0, [r0, r1]
}
 800cc06:	4770      	bx	lr

0800cc08 <SDMMC_ConfigData>:
  * @param  Data : pointer to a SDMMC_DataInitTypeDef structure
  *         that contains the configuration information for the SDMMC data.
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_ConfigData(SDMMC_TypeDef *SDMMCx, SDMMC_DataInitTypeDef* Data)
{
 800cc08:	b510      	push	{r4, lr}
                       Data->TransferDir   |\
                       Data->TransferMode  |\
                       Data->DPSM);

  /* Write to SDMMC DCTRL */
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 800cc0a:	68ca      	ldr	r2, [r1, #12]
 800cc0c:	688c      	ldr	r4, [r1, #8]
  assert_param(IS_SDMMC_TRANSFER_DIR(Data->TransferDir));
  assert_param(IS_SDMMC_TRANSFER_MODE(Data->TransferMode));
  assert_param(IS_SDMMC_DPSM(Data->DPSM));

  /* Set the SDMMC Data TimeOut value */
  SDMMCx->DTIMER = Data->DataTimeOut;
 800cc0e:	680b      	ldr	r3, [r1, #0]
 800cc10:	6243      	str	r3, [r0, #36]	; 0x24
                       Data->TransferDir   |\
                       Data->TransferMode  |\
                       Data->DPSM);

  /* Write to SDMMC DCTRL */
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 800cc12:	4314      	orrs	r4, r2

  /* Set the SDMMC Data TimeOut value */
  SDMMCx->DTIMER = Data->DataTimeOut;

  /* Set the SDMMC DataLength value */
  SDMMCx->DLEN = Data->DataLength;
 800cc14:	684b      	ldr	r3, [r1, #4]
                       Data->TransferDir   |\
                       Data->TransferMode  |\
                       Data->DPSM);

  /* Write to SDMMC DCTRL */
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 800cc16:	690a      	ldr	r2, [r1, #16]

  /* Set the SDMMC Data TimeOut value */
  SDMMCx->DTIMER = Data->DataTimeOut;

  /* Set the SDMMC DataLength value */
  SDMMCx->DLEN = Data->DataLength;
 800cc18:	6283      	str	r3, [r0, #40]	; 0x28
                       Data->TransferDir   |\
                       Data->TransferMode  |\
                       Data->DPSM);

  /* Write to SDMMC DCTRL */
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 800cc1a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800cc1c:	4314      	orrs	r4, r2
 800cc1e:	694a      	ldr	r2, [r1, #20]
 800cc20:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 800cc24:	4322      	orrs	r2, r4
 800cc26:	4313      	orrs	r3, r2
 800cc28:	62c3      	str	r3, [r0, #44]	; 0x2c

  return HAL_OK;

}
 800cc2a:	2000      	movs	r0, #0
 800cc2c:	bd10      	pop	{r4, pc}

0800cc2e <SDMMC_GetDataCounter>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval Number of remaining data bytes to be transferred
  */
uint32_t SDMMC_GetDataCounter(SDMMC_TypeDef *SDMMCx)
{
  return (SDMMCx->DCOUNT);
 800cc2e:	6b00      	ldr	r0, [r0, #48]	; 0x30
}
 800cc30:	4770      	bx	lr

0800cc32 <SDMMC_GetFIFOCount>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval Data received
  */
uint32_t SDMMC_GetFIFOCount(SDMMC_TypeDef *SDMMCx)
{
  return (SDMMCx->FIFO);
 800cc32:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
}
 800cc36:	4770      	bx	lr

0800cc38 <SDMMC_SetSDMMCReadWaitMode>:
{
  /* Check the parameters */
  assert_param(IS_SDMMC_READWAIT_MODE(SDMMC_ReadWaitMode));

  /* Set SDMMC read wait mode */
  MODIFY_REG(SDMMCx->DCTRL, SDMMC_DCTRL_RWMOD, SDMMC_ReadWaitMode);
 800cc38:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800cc3a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800cc3e:	4319      	orrs	r1, r3
 800cc40:	62c1      	str	r1, [r0, #44]	; 0x2c

  return HAL_OK;
}
 800cc42:	2000      	movs	r0, #0
 800cc44:	4770      	bx	lr
	...

0800cc48 <SDMMC_CmdGoIdleState>:
  * @brief  Send the Go Idle State command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdGoIdleState(SDMMC_TypeDef *SDMMCx)
{
 800cc48:	b510      	push	{r4, lr}
 800cc4a:	b086      	sub	sp, #24
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0U;
 800cc4c:	2300      	movs	r3, #0
 800cc4e:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_GO_IDLE_STATE;
 800cc50:	9302      	str	r3, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_NO;
 800cc52:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cc54:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cc56:	a901      	add	r1, sp, #4

  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_GO_IDLE_STATE;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_NO;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800cc58:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800cc5c:	9305      	str	r3, [sp, #20]
  * @brief  Send the Go Idle State command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdGoIdleState(SDMMC_TypeDef *SDMMCx)
{
 800cc5e:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_GO_IDLE_STATE;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_NO;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cc60:	f7ff ffb8 	bl	800cbd4 <SDMMC_SendCommand>
  */
static uint32_t SDMMC_GetCmdError(SDMMC_TypeDef *SDMMCx)
{
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800cc64:	4b0b      	ldr	r3, [pc, #44]	; (800cc94 <SDMMC_CmdGoIdleState+0x4c>)
 800cc66:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
 800cc6a:	681b      	ldr	r3, [r3, #0]
 800cc6c:	fbb3 f2f2 	udiv	r2, r3, r2
 800cc70:	f241 3388 	movw	r3, #5000	; 0x1388
 800cc74:	4353      	muls	r3, r2

  do
  {
    if (count-- == 0U)
 800cc76:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800cc7a:	d306      	bcc.n	800cc8a <SDMMC_CmdGoIdleState+0x42>
    {
      return SDMMC_ERROR_TIMEOUT;
    }

  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDSENT));
 800cc7c:	6b62      	ldr	r2, [r4, #52]	; 0x34
 800cc7e:	0612      	lsls	r2, r2, #24
 800cc80:	d5f9      	bpl.n	800cc76 <SDMMC_CmdGoIdleState+0x2e>

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800cc82:	4b05      	ldr	r3, [pc, #20]	; (800cc98 <SDMMC_CmdGoIdleState+0x50>)
 800cc84:	63a3      	str	r3, [r4, #56]	; 0x38

  return SDMMC_ERROR_NONE;
 800cc86:	2000      	movs	r0, #0
 800cc88:	e001      	b.n	800cc8e <SDMMC_CmdGoIdleState+0x46>

  do
  {
    if (count-- == 0U)
    {
      return SDMMC_ERROR_TIMEOUT;
 800cc8a:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdError(SDMMCx);

  return errorstate;
}
 800cc8e:	b006      	add	sp, #24
 800cc90:	bd10      	pop	{r4, pc}
 800cc92:	bf00      	nop
 800cc94:	20000448 	.word	0x20000448
 800cc98:	002000c5 	.word	0x002000c5

0800cc9c <SDMMC_GetCmdResp1>:
  uint32_t response_r1;
  uint32_t sta_reg;

  /* 8 is the number of required instructions cycles for the below loop statement.
  The Timeout is expressed in ms */
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800cc9c:	4b44      	ldr	r3, [pc, #272]	; (800cdb0 <SDMMC_GetCmdResp1+0x114>)
  * @param  hsd SD handle
  * @param  SD_CMD The sent command index
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp1(SDMMC_TypeDef *SDMMCx, uint8_t SD_CMD, uint32_t Timeout)
{
 800cc9e:	b510      	push	{r4, lr}
  uint32_t response_r1;
  uint32_t sta_reg;

  /* 8 is the number of required instructions cycles for the below loop statement.
  The Timeout is expressed in ms */
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800cca0:	681b      	ldr	r3, [r3, #0]
 800cca2:	f44f 54fa 	mov.w	r4, #8000	; 0x1f40
 800cca6:	fbb3 f3f4 	udiv	r3, r3, r4
 800ccaa:	435a      	muls	r2, r3

  do
  {
    if (count-- == 0U)
 800ccac:	2a00      	cmp	r2, #0
 800ccae:	d048      	beq.n	800cd42 <SDMMC_GetCmdResp1+0xa6>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
 800ccb0:	6b44      	ldr	r4, [r0, #52]	; 0x34
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800ccb2:	4b40      	ldr	r3, [pc, #256]	; (800cdb4 <SDMMC_GetCmdResp1+0x118>)
 800ccb4:	4023      	ands	r3, r4
 800ccb6:	b90b      	cbnz	r3, 800ccbc <SDMMC_GetCmdResp1+0x20>
 800ccb8:	3a01      	subs	r2, #1
 800ccba:	e7f7      	b.n	800ccac <SDMMC_GetCmdResp1+0x10>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800ccbc:	04a4      	lsls	r4, r4, #18
 800ccbe:	d4fb      	bmi.n	800ccb8 <SDMMC_GetCmdResp1+0x1c>
#else
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800ccc0:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800ccc2:	075b      	lsls	r3, r3, #29
 800ccc4:	d501      	bpl.n	800ccca <SDMMC_GetCmdResp1+0x2e>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800ccc6:	2304      	movs	r3, #4
 800ccc8:	e003      	b.n	800ccd2 <SDMMC_GetCmdResp1+0x36>

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800ccca:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800cccc:	07dc      	lsls	r4, r3, #31
 800ccce:	d503      	bpl.n	800ccd8 <SDMMC_GetCmdResp1+0x3c>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800ccd0:	2301      	movs	r3, #1
 800ccd2:	6383      	str	r3, [r0, #56]	; 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
 800ccd4:	4618      	mov	r0, r3
 800ccd6:	bd10      	pop	{r4, pc}
  {
    /* Nothing to do */
  }

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800ccd8:	4b37      	ldr	r3, [pc, #220]	; (800cdb8 <SDMMC_GetCmdResp1+0x11c>)
 800ccda:	6383      	str	r3, [r0, #56]	; 0x38
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval Command index of the last command response received
  */
uint8_t SDMMC_GetCommandResponse(SDMMC_TypeDef *SDMMCx)
{
  return (uint8_t)(SDMMCx->RESPCMD);
 800ccdc:	6903      	ldr	r3, [r0, #16]

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);

  /* Check response received is of desired command */
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800ccde:	b2db      	uxtb	r3, r3
 800cce0:	4299      	cmp	r1, r3
 800cce2:	d131      	bne.n	800cd48 <SDMMC_GetCmdResp1+0xac>
  assert_param(IS_SDMMC_RESP(Response));

  /* Get the response */
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;

  return (*(__IO uint32_t *) tmp);
 800cce4:	6943      	ldr	r3, [r0, #20]
  }

  /* We have received response, retrieve it for analysis  */
  response_r1 = SDMMC_GetResponse(SDMMCx, SDMMC_RESP1);

  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 800cce6:	4835      	ldr	r0, [pc, #212]	; (800cdbc <SDMMC_GetCmdResp1+0x120>)
 800cce8:	4018      	ands	r0, r3
 800ccea:	2800      	cmp	r0, #0
 800ccec:	d05e      	beq.n	800cdac <SDMMC_GetCmdResp1+0x110>
  {
    return SDMMC_ERROR_NONE;
  }
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 800ccee:	2b00      	cmp	r3, #0
 800ccf0:	db2c      	blt.n	800cd4c <SDMMC_GetCmdResp1+0xb0>
  {
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
  }
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 800ccf2:	005a      	lsls	r2, r3, #1
 800ccf4:	d42d      	bmi.n	800cd52 <SDMMC_GetCmdResp1+0xb6>
  {
    return SDMMC_ERROR_ADDR_MISALIGNED;
  }
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 800ccf6:	009c      	lsls	r4, r3, #2
 800ccf8:	d42d      	bmi.n	800cd56 <SDMMC_GetCmdResp1+0xba>
  {
    return SDMMC_ERROR_BLOCK_LEN_ERR;
  }
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 800ccfa:	00d9      	lsls	r1, r3, #3
 800ccfc:	d42d      	bmi.n	800cd5a <SDMMC_GetCmdResp1+0xbe>
  {
    return SDMMC_ERROR_ERASE_SEQ_ERR;
  }
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 800ccfe:	011a      	lsls	r2, r3, #4
 800cd00:	d42e      	bmi.n	800cd60 <SDMMC_GetCmdResp1+0xc4>
  {
    return SDMMC_ERROR_BAD_ERASE_PARAM;
  }
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 800cd02:	015c      	lsls	r4, r3, #5
 800cd04:	d42f      	bmi.n	800cd66 <SDMMC_GetCmdResp1+0xca>
  {
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
  }
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 800cd06:	01d9      	lsls	r1, r3, #7
 800cd08:	d430      	bmi.n	800cd6c <SDMMC_GetCmdResp1+0xd0>
  {
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 800cd0a:	021a      	lsls	r2, r3, #8
 800cd0c:	d431      	bmi.n	800cd72 <SDMMC_GetCmdResp1+0xd6>
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 800cd0e:	025c      	lsls	r4, r3, #9
 800cd10:	d432      	bmi.n	800cd78 <SDMMC_GetCmdResp1+0xdc>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 800cd12:	0299      	lsls	r1, r3, #10
 800cd14:	d433      	bmi.n	800cd7e <SDMMC_GetCmdResp1+0xe2>
  {
    return SDMMC_ERROR_CARD_ECC_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 800cd16:	02da      	lsls	r2, r3, #11
 800cd18:	d434      	bmi.n	800cd84 <SDMMC_GetCmdResp1+0xe8>
  {
    return SDMMC_ERROR_CC_ERR;
  }
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 800cd1a:	035c      	lsls	r4, r3, #13
 800cd1c:	d435      	bmi.n	800cd8a <SDMMC_GetCmdResp1+0xee>
  {
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
  }
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 800cd1e:	0399      	lsls	r1, r3, #14
 800cd20:	d436      	bmi.n	800cd90 <SDMMC_GetCmdResp1+0xf4>
  {
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
  }
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 800cd22:	03da      	lsls	r2, r3, #15
 800cd24:	d437      	bmi.n	800cd96 <SDMMC_GetCmdResp1+0xfa>
  {
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
  }
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 800cd26:	041c      	lsls	r4, r3, #16
 800cd28:	d438      	bmi.n	800cd9c <SDMMC_GetCmdResp1+0x100>
  {
    return SDMMC_ERROR_WP_ERASE_SKIP;
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 800cd2a:	0459      	lsls	r1, r3, #17
 800cd2c:	d439      	bmi.n	800cda2 <SDMMC_GetCmdResp1+0x106>
  {
    return SDMMC_ERROR_CARD_ECC_DISABLED;
  }
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 800cd2e:	049a      	lsls	r2, r3, #18
 800cd30:	d43a      	bmi.n	800cda8 <SDMMC_GetCmdResp1+0x10c>
  {
    return SDMMC_ERROR_ERASE_RESET;
  }
  else if((response_r1 & SDMMC_OCR_AKE_SEQ_ERROR) == SDMMC_OCR_AKE_SEQ_ERROR)
  {
    return SDMMC_ERROR_AKE_SEQ_ERR;
 800cd32:	f013 0f08 	tst.w	r3, #8
 800cd36:	bf0c      	ite	eq
 800cd38:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
 800cd3c:	f44f 0000 	movne.w	r0, #8388608	; 0x800000
 800cd40:	bd10      	pop	{r4, pc}

  do
  {
    if (count-- == 0U)
    {
      return SDMMC_ERROR_TIMEOUT;
 800cd42:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800cd46:	bd10      	pop	{r4, pc}
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);

  /* Check response received is of desired command */
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
  {
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800cd48:	2001      	movs	r0, #1
 800cd4a:	bd10      	pop	{r4, pc}
  {
    return SDMMC_ERROR_NONE;
  }
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
  {
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 800cd4c:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 800cd50:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
  {
    return SDMMC_ERROR_ADDR_MISALIGNED;
 800cd52:	2040      	movs	r0, #64	; 0x40
 800cd54:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
  {
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 800cd56:	2080      	movs	r0, #128	; 0x80
 800cd58:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
  {
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 800cd5a:	f44f 7080 	mov.w	r0, #256	; 0x100
 800cd5e:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
  {
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 800cd60:	f44f 7000 	mov.w	r0, #512	; 0x200
 800cd64:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
  {
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 800cd66:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800cd6a:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
  {
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 800cd6c:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800cd70:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
 800cd72:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800cd76:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
 800cd78:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 800cd7c:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
  {
    return SDMMC_ERROR_CARD_ECC_FAILED;
 800cd7e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800cd82:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
  {
    return SDMMC_ERROR_CC_ERR;
 800cd84:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800cd88:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
  {
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 800cd8a:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800cd8e:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
  {
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 800cd90:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800cd94:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
  {
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 800cd96:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800cd9a:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
  {
    return SDMMC_ERROR_WP_ERASE_SKIP;
 800cd9c:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800cda0:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
  {
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 800cda2:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 800cda6:	bd10      	pop	{r4, pc}
  }
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
  {
    return SDMMC_ERROR_ERASE_RESET;
 800cda8:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
  }
}
 800cdac:	bd10      	pop	{r4, pc}
 800cdae:	bf00      	nop
 800cdb0:	20000448 	.word	0x20000448
 800cdb4:	00200045 	.word	0x00200045
 800cdb8:	002000c5 	.word	0x002000c5
 800cdbc:	fdffe008 	.word	0xfdffe008

0800cdc0 <SDMMC_CmdBlockLength>:
  * @brief  Send the Data Block Lenght command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdBlockLength(SDMMC_TypeDef *SDMMCx, uint32_t BlockSize)
{
 800cdc0:	b530      	push	{r4, r5, lr}
 800cdc2:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)BlockSize;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_BLOCKLEN;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800cdc4:	f44f 7380 	mov.w	r3, #256	; 0x100
 800cdc8:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cdca:	2300      	movs	r3, #0
  * @brief  Send the Data Block Lenght command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdBlockLength(SDMMC_TypeDef *SDMMCx, uint32_t BlockSize)
{
 800cdcc:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)BlockSize;
 800cdce:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_BLOCKLEN;
 800cdd0:	2410      	movs	r4, #16
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cdd2:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cdd4:	a901      	add	r1, sp, #4
  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)BlockSize;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_BLOCKLEN;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800cdd6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800cdda:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)BlockSize;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_BLOCKLEN;
 800cddc:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cdde:	f7ff fef9 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SET_BLOCKLEN, SDMMC_CMDTIMEOUT);
 800cde2:	f241 3288 	movw	r2, #5000	; 0x1388
 800cde6:	4621      	mov	r1, r4
 800cde8:	4628      	mov	r0, r5
 800cdea:	f7ff ff57 	bl	800cc9c <SDMMC_GetCmdResp1>

  return errorstate;
}
 800cdee:	b007      	add	sp, #28
 800cdf0:	bd30      	pop	{r4, r5, pc}

0800cdf2 <SDMMC_CmdReadSingleBlock>:
  * @brief  Send the Read Single Block command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdReadSingleBlock(SDMMC_TypeDef *SDMMCx, uint32_t ReadAdd)
{
 800cdf2:	b530      	push	{r4, r5, lr}
 800cdf4:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_SINGLE_BLOCK;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800cdf6:	f44f 7380 	mov.w	r3, #256	; 0x100
 800cdfa:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cdfc:	2300      	movs	r3, #0
  * @brief  Send the Read Single Block command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdReadSingleBlock(SDMMC_TypeDef *SDMMCx, uint32_t ReadAdd)
{
 800cdfe:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
 800ce00:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_SINGLE_BLOCK;
 800ce02:	2411      	movs	r4, #17
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800ce04:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800ce06:	a901      	add	r1, sp, #4
  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_SINGLE_BLOCK;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800ce08:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800ce0c:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_SINGLE_BLOCK;
 800ce0e:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800ce10:	f7ff fee0 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
 800ce14:	f241 3288 	movw	r2, #5000	; 0x1388
 800ce18:	4621      	mov	r1, r4
 800ce1a:	4628      	mov	r0, r5
 800ce1c:	f7ff ff3e 	bl	800cc9c <SDMMC_GetCmdResp1>

  return errorstate;
}
 800ce20:	b007      	add	sp, #28
 800ce22:	bd30      	pop	{r4, r5, pc}

0800ce24 <SDMMC_CmdReadMultiBlock>:
  * @brief  Send the Read Multi Block command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdReadMultiBlock(SDMMC_TypeDef *SDMMCx, uint32_t ReadAdd)
{
 800ce24:	b530      	push	{r4, r5, lr}
 800ce26:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_MULT_BLOCK;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800ce28:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ce2c:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800ce2e:	2300      	movs	r3, #0
  * @brief  Send the Read Multi Block command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdReadMultiBlock(SDMMC_TypeDef *SDMMCx, uint32_t ReadAdd)
{
 800ce30:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
 800ce32:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_MULT_BLOCK;
 800ce34:	2412      	movs	r4, #18
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800ce36:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800ce38:	a901      	add	r1, sp, #4
  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_MULT_BLOCK;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800ce3a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800ce3e:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_MULT_BLOCK;
 800ce40:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800ce42:	f7ff fec7 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_MULT_BLOCK, SDMMC_CMDTIMEOUT);
 800ce46:	f241 3288 	movw	r2, #5000	; 0x1388
 800ce4a:	4621      	mov	r1, r4
 800ce4c:	4628      	mov	r0, r5
 800ce4e:	f7ff ff25 	bl	800cc9c <SDMMC_GetCmdResp1>

  return errorstate;
}
 800ce52:	b007      	add	sp, #28
 800ce54:	bd30      	pop	{r4, r5, pc}

0800ce56 <SDMMC_CmdWriteSingleBlock>:
  * @brief  Send the Write Single Block command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdWriteSingleBlock(SDMMC_TypeDef *SDMMCx, uint32_t WriteAdd)
{
 800ce56:	b530      	push	{r4, r5, lr}
 800ce58:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_SINGLE_BLOCK;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800ce5a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ce5e:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800ce60:	2300      	movs	r3, #0
  * @brief  Send the Write Single Block command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdWriteSingleBlock(SDMMC_TypeDef *SDMMCx, uint32_t WriteAdd)
{
 800ce62:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
 800ce64:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_SINGLE_BLOCK;
 800ce66:	2418      	movs	r4, #24
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800ce68:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800ce6a:	a901      	add	r1, sp, #4
  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_SINGLE_BLOCK;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800ce6c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800ce70:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_SINGLE_BLOCK;
 800ce72:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800ce74:	f7ff feae 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
 800ce78:	f241 3288 	movw	r2, #5000	; 0x1388
 800ce7c:	4621      	mov	r1, r4
 800ce7e:	4628      	mov	r0, r5
 800ce80:	f7ff ff0c 	bl	800cc9c <SDMMC_GetCmdResp1>

  return errorstate;
}
 800ce84:	b007      	add	sp, #28
 800ce86:	bd30      	pop	{r4, r5, pc}

0800ce88 <SDMMC_CmdWriteMultiBlock>:
  * @brief  Send the Write Multi Block command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdWriteMultiBlock(SDMMC_TypeDef *SDMMCx, uint32_t WriteAdd)
{
 800ce88:	b530      	push	{r4, r5, lr}
 800ce8a:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_MULT_BLOCK;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800ce8c:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ce90:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800ce92:	2300      	movs	r3, #0
  * @brief  Send the Write Multi Block command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdWriteMultiBlock(SDMMC_TypeDef *SDMMCx, uint32_t WriteAdd)
{
 800ce94:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
 800ce96:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_MULT_BLOCK;
 800ce98:	2419      	movs	r4, #25
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800ce9a:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800ce9c:	a901      	add	r1, sp, #4
  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_MULT_BLOCK;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800ce9e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800cea2:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_MULT_BLOCK;
 800cea4:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cea6:	f7ff fe95 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_MULT_BLOCK, SDMMC_CMDTIMEOUT);
 800ceaa:	f241 3288 	movw	r2, #5000	; 0x1388
 800ceae:	4621      	mov	r1, r4
 800ceb0:	4628      	mov	r0, r5
 800ceb2:	f7ff fef3 	bl	800cc9c <SDMMC_GetCmdResp1>

  return errorstate;
}
 800ceb6:	b007      	add	sp, #28
 800ceb8:	bd30      	pop	{r4, r5, pc}

0800ceba <SDMMC_CmdSDEraseStartAdd>:
  * @brief  Send the Start Address Erase command for SD and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSDEraseStartAdd(SDMMC_TypeDef *SDMMCx, uint32_t StartAdd)
{
 800ceba:	b530      	push	{r4, r5, lr}
 800cebc:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)StartAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_ERASE_GRP_START;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800cebe:	f44f 7380 	mov.w	r3, #256	; 0x100
 800cec2:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cec4:	2300      	movs	r3, #0
  * @brief  Send the Start Address Erase command for SD and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSDEraseStartAdd(SDMMC_TypeDef *SDMMCx, uint32_t StartAdd)
{
 800cec6:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)StartAdd;
 800cec8:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_ERASE_GRP_START;
 800ceca:	2420      	movs	r4, #32
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cecc:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cece:	a901      	add	r1, sp, #4
  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)StartAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_ERASE_GRP_START;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800ced0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800ced4:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)StartAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_ERASE_GRP_START;
 800ced6:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800ced8:	f7ff fe7c 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_ERASE_GRP_START, SDMMC_CMDTIMEOUT);
 800cedc:	f241 3288 	movw	r2, #5000	; 0x1388
 800cee0:	4621      	mov	r1, r4
 800cee2:	4628      	mov	r0, r5
 800cee4:	f7ff feda 	bl	800cc9c <SDMMC_GetCmdResp1>

  return errorstate;
}
 800cee8:	b007      	add	sp, #28
 800ceea:	bd30      	pop	{r4, r5, pc}

0800ceec <SDMMC_CmdSDEraseEndAdd>:
  * @brief  Send the End Address Erase command for SD and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSDEraseEndAdd(SDMMC_TypeDef *SDMMCx, uint32_t EndAdd)
{
 800ceec:	b530      	push	{r4, r5, lr}
 800ceee:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)EndAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_ERASE_GRP_END;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800cef0:	f44f 7380 	mov.w	r3, #256	; 0x100
 800cef4:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cef6:	2300      	movs	r3, #0
  * @brief  Send the End Address Erase command for SD and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSDEraseEndAdd(SDMMC_TypeDef *SDMMCx, uint32_t EndAdd)
{
 800cef8:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)EndAdd;
 800cefa:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_ERASE_GRP_END;
 800cefc:	2421      	movs	r4, #33	; 0x21
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cefe:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cf00:	a901      	add	r1, sp, #4
  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)EndAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_ERASE_GRP_END;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800cf02:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800cf06:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)EndAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_ERASE_GRP_END;
 800cf08:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cf0a:	f7ff fe63 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_ERASE_GRP_END, SDMMC_CMDTIMEOUT);
 800cf0e:	f241 3288 	movw	r2, #5000	; 0x1388
 800cf12:	4621      	mov	r1, r4
 800cf14:	4628      	mov	r0, r5
 800cf16:	f7ff fec1 	bl	800cc9c <SDMMC_GetCmdResp1>

  return errorstate;
}
 800cf1a:	b007      	add	sp, #28
 800cf1c:	bd30      	pop	{r4, r5, pc}

0800cf1e <SDMMC_CmdEraseStartAdd>:
  * @brief  Send the Start Address Erase command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdEraseStartAdd(SDMMC_TypeDef *SDMMCx, uint32_t StartAdd)
{
 800cf1e:	b530      	push	{r4, r5, lr}
 800cf20:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)StartAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE_GRP_START;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800cf22:	f44f 7380 	mov.w	r3, #256	; 0x100
 800cf26:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cf28:	2300      	movs	r3, #0
  * @brief  Send the Start Address Erase command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdEraseStartAdd(SDMMC_TypeDef *SDMMCx, uint32_t StartAdd)
{
 800cf2a:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)StartAdd;
 800cf2c:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE_GRP_START;
 800cf2e:	2423      	movs	r4, #35	; 0x23
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cf30:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cf32:	a901      	add	r1, sp, #4
  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)StartAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE_GRP_START;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800cf34:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800cf38:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)StartAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE_GRP_START;
 800cf3a:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cf3c:	f7ff fe4a 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_ERASE_GRP_START, SDMMC_CMDTIMEOUT);
 800cf40:	f241 3288 	movw	r2, #5000	; 0x1388
 800cf44:	4621      	mov	r1, r4
 800cf46:	4628      	mov	r0, r5
 800cf48:	f7ff fea8 	bl	800cc9c <SDMMC_GetCmdResp1>

  return errorstate;
}
 800cf4c:	b007      	add	sp, #28
 800cf4e:	bd30      	pop	{r4, r5, pc}

0800cf50 <SDMMC_CmdEraseEndAdd>:
  * @brief  Send the End Address Erase command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdEraseEndAdd(SDMMC_TypeDef *SDMMCx, uint32_t EndAdd)
{
 800cf50:	b530      	push	{r4, r5, lr}
 800cf52:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)EndAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE_GRP_END;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800cf54:	f44f 7380 	mov.w	r3, #256	; 0x100
 800cf58:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cf5a:	2300      	movs	r3, #0
  * @brief  Send the End Address Erase command and check the response
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdEraseEndAdd(SDMMC_TypeDef *SDMMCx, uint32_t EndAdd)
{
 800cf5c:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)EndAdd;
 800cf5e:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE_GRP_END;
 800cf60:	2424      	movs	r4, #36	; 0x24
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cf62:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cf64:	a901      	add	r1, sp, #4
  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)EndAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE_GRP_END;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800cf66:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800cf6a:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)EndAdd;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE_GRP_END;
 800cf6c:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cf6e:	f7ff fe31 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_ERASE_GRP_END, SDMMC_CMDTIMEOUT);
 800cf72:	f241 3288 	movw	r2, #5000	; 0x1388
 800cf76:	4621      	mov	r1, r4
 800cf78:	4628      	mov	r0, r5
 800cf7a:	f7ff fe8f 	bl	800cc9c <SDMMC_GetCmdResp1>

  return errorstate;
}
 800cf7e:	b007      	add	sp, #28
 800cf80:	bd30      	pop	{r4, r5, pc}

0800cf82 <SDMMC_CmdErase>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  EraseType Type of erase to be performed
  * @retval HAL status
  */
uint32_t SDMMC_CmdErase(SDMMC_TypeDef *SDMMCx, uint32_t EraseType)
{
 800cf82:	b530      	push	{r4, r5, lr}
 800cf84:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = EraseType;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800cf86:	f44f 7380 	mov.w	r3, #256	; 0x100
 800cf8a:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cf8c:	2300      	movs	r3, #0
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  EraseType Type of erase to be performed
  * @retval HAL status
  */
uint32_t SDMMC_CmdErase(SDMMC_TypeDef *SDMMCx, uint32_t EraseType)
{
 800cf8e:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = EraseType;
 800cf90:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE;
 800cf92:	2426      	movs	r4, #38	; 0x26
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cf94:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cf96:	a901      	add	r1, sp, #4
  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = EraseType;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800cf98:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800cf9c:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = EraseType;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE;
 800cf9e:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cfa0:	f7ff fe18 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_ERASE, SDMMC_MAXERASETIMEOUT);
 800cfa4:	f24f 6218 	movw	r2, #63000	; 0xf618
 800cfa8:	4621      	mov	r1, r4
 800cfaa:	4628      	mov	r0, r5
 800cfac:	f7ff fe76 	bl	800cc9c <SDMMC_GetCmdResp1>

  return errorstate;
}
 800cfb0:	b007      	add	sp, #28
 800cfb2:	bd30      	pop	{r4, r5, pc}

0800cfb4 <SDMMC_CmdStopTransfer>:
  * @brief  Send the Stop Transfer command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdStopTransfer(SDMMC_TypeDef *SDMMCx)
{
 800cfb4:	b530      	push	{r4, r5, lr}
 800cfb6:	b087      	sub	sp, #28
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD12 STOP_TRANSMISSION  */
  sdmmc_cmdinit.Argument         = 0U;
 800cfb8:	2300      	movs	r3, #0
 800cfba:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800cfbc:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800cfbe:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800cfc2:	9305      	str	r3, [sp, #20]

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
 800cfc4:	68c3      	ldr	r3, [r0, #12]
 800cfc6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800cfca:	60c3      	str	r3, [r0, #12]
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
 800cfcc:	68c3      	ldr	r3, [r0, #12]
 800cfce:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  * @brief  Send the Stop Transfer command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdStopTransfer(SDMMC_TypeDef *SDMMCx)
{
 800cfd2:	4604      	mov	r4, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD12 STOP_TRANSMISSION  */
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
 800cfd4:	250c      	movs	r5, #12
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800cfd6:	f44f 7280 	mov.w	r2, #256	; 0x100
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
 800cfda:	60c3      	str	r3, [r0, #12]
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cfdc:	a901      	add	r1, sp, #4
  uint32_t errorstate;

  /* Send CMD12 STOP_TRANSMISSION  */
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800cfde:	9203      	str	r2, [sp, #12]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD12 STOP_TRANSMISSION  */
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
 800cfe0:	9502      	str	r5, [sp, #8]
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800cfe2:	f7ff fdf7 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_STOP_TRANSMISSION, SDMMC_STOPTRANSFERTIMEOUT);
 800cfe6:	4a05      	ldr	r2, [pc, #20]	; (800cffc <SDMMC_CmdStopTransfer+0x48>)
 800cfe8:	4629      	mov	r1, r5
 800cfea:	4620      	mov	r0, r4
 800cfec:	f7ff fe56 	bl	800cc9c <SDMMC_GetCmdResp1>

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
 800cff0:	68e3      	ldr	r3, [r4, #12]
 800cff2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800cff6:	60e3      	str	r3, [r4, #12]
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */

  return errorstate;
}
 800cff8:	b007      	add	sp, #28
 800cffa:	bd30      	pop	{r4, r5, pc}
 800cffc:	05f5e100 	.word	0x05f5e100

0800d000 <SDMMC_CmdSelDesel>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  addr Address of the card to be selected
  * @retval HAL status
  */
uint32_t SDMMC_CmdSelDesel(SDMMC_TypeDef *SDMMCx, uint64_t Addr)
{
 800d000:	b530      	push	{r4, r5, lr}
 800d002:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Send CMD7 SDMMC_SEL_DESEL_CARD */
  sdmmc_cmdinit.Argument         = (uint32_t)Addr;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d004:	f44f 7380 	mov.w	r3, #256	; 0x100
 800d008:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d00a:	2300      	movs	r3, #0
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  addr Address of the card to be selected
  * @retval HAL status
  */
uint32_t SDMMC_CmdSelDesel(SDMMC_TypeDef *SDMMCx, uint64_t Addr)
{
 800d00c:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD7 SDMMC_SEL_DESEL_CARD */
  sdmmc_cmdinit.Argument         = (uint32_t)Addr;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
 800d00e:	2407      	movs	r4, #7
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d010:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d012:	a901      	add	r1, sp, #4
  /* Send CMD7 SDMMC_SEL_DESEL_CARD */
  sdmmc_cmdinit.Argument         = (uint32_t)Addr;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d014:	f44f 5380 	mov.w	r3, #4096	; 0x1000
{
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD7 SDMMC_SEL_DESEL_CARD */
  sdmmc_cmdinit.Argument         = (uint32_t)Addr;
 800d018:	9201      	str	r2, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d01a:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD7 SDMMC_SEL_DESEL_CARD */
  sdmmc_cmdinit.Argument         = (uint32_t)Addr;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
 800d01c:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d01e:	f7ff fdd9 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEL_DESEL_CARD, SDMMC_CMDTIMEOUT);
 800d022:	f241 3288 	movw	r2, #5000	; 0x1388
 800d026:	4621      	mov	r1, r4
 800d028:	4628      	mov	r0, r5
 800d02a:	f7ff fe37 	bl	800cc9c <SDMMC_GetCmdResp1>

  return errorstate;
}
 800d02e:	b007      	add	sp, #28
 800d030:	bd30      	pop	{r4, r5, pc}

0800d032 <SDMMC_CmdAppCommand>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Argument Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdAppCommand(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d032:	b530      	push	{r4, r5, lr}
 800d034:	b087      	sub	sp, #28
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = (uint32_t)Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_CMD;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d036:	f44f 7380 	mov.w	r3, #256	; 0x100
 800d03a:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d03c:	2300      	movs	r3, #0
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Argument Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdAppCommand(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d03e:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = (uint32_t)Argument;
 800d040:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_CMD;
 800d042:	2437      	movs	r4, #55	; 0x37
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d044:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d046:	a901      	add	r1, sp, #4

  sdmmc_cmdinit.Argument         = (uint32_t)Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_CMD;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d048:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800d04c:	9305      	str	r3, [sp, #20]
{
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = (uint32_t)Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_CMD;
 800d04e:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d050:	f7ff fdc0 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  /* If there is a HAL_ERROR, it is a MMC card, else
  it is a SD card: SD card 2.0 (voltage range mismatch)
     or SD card 1.x */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_APP_CMD, SDMMC_CMDTIMEOUT);
 800d054:	f241 3288 	movw	r2, #5000	; 0x1388
 800d058:	4621      	mov	r1, r4
 800d05a:	4628      	mov	r0, r5
 800d05c:	f7ff fe1e 	bl	800cc9c <SDMMC_GetCmdResp1>

  return errorstate;
}
 800d060:	b007      	add	sp, #28
 800d062:	bd30      	pop	{r4, r5, pc}

0800d064 <SDMMC_CmdSendSCR>:
  * @brief  Send the Send SCR command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendSCR(SDMMC_TypeDef *SDMMCx)
{
 800d064:	b530      	push	{r4, r5, lr}
 800d066:	b087      	sub	sp, #28
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD51 SD_APP_SEND_SCR */
  sdmmc_cmdinit.Argument         = 0U;
 800d068:	2300      	movs	r3, #0
  * @brief  Send the Send SCR command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendSCR(SDMMC_TypeDef *SDMMCx)
{
 800d06a:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD51 SD_APP_SEND_SCR */
  sdmmc_cmdinit.Argument         = 0U;
 800d06c:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
 800d06e:	2433      	movs	r4, #51	; 0x33
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d070:	f44f 7280 	mov.w	r2, #256	; 0x100
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d074:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d076:	a901      	add	r1, sp, #4
  /* Send CMD51 SD_APP_SEND_SCR */
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d078:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  uint32_t errorstate;

  /* Send CMD51 SD_APP_SEND_SCR */
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d07c:	9203      	str	r2, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d07e:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD51 SD_APP_SEND_SCR */
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
 800d080:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d082:	f7ff fda7 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_APP_SEND_SCR, SDMMC_CMDTIMEOUT);
 800d086:	f241 3288 	movw	r2, #5000	; 0x1388
 800d08a:	4621      	mov	r1, r4
 800d08c:	4628      	mov	r0, r5
 800d08e:	f7ff fe05 	bl	800cc9c <SDMMC_GetCmdResp1>

  return errorstate;
}
 800d092:	b007      	add	sp, #28
 800d094:	bd30      	pop	{r4, r5, pc}

0800d096 <SDMMC_CmdSetRelAddMmc>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  RCA Card RCA
  * @retval HAL status
  */
uint32_t SDMMC_CmdSetRelAddMmc(SDMMC_TypeDef *SDMMCx, uint16_t RCA)
{
 800d096:	b530      	push	{r4, r5, lr}
 800d098:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = ((uint32_t)RCA << 16U);
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d09a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800d09e:	9303      	str	r3, [sp, #12]
{
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = ((uint32_t)RCA << 16U);
 800d0a0:	0409      	lsls	r1, r1, #16
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d0a2:	2300      	movs	r3, #0
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  RCA Card RCA
  * @retval HAL status
  */
uint32_t SDMMC_CmdSetRelAddMmc(SDMMC_TypeDef *SDMMCx, uint16_t RCA)
{
 800d0a4:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = ((uint32_t)RCA << 16U);
 800d0a6:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
 800d0a8:	2403      	movs	r4, #3
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d0aa:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d0ac:	a901      	add	r1, sp, #4
  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = ((uint32_t)RCA << 16U);
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d0ae:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800d0b2:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = ((uint32_t)RCA << 16U);
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
 800d0b4:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d0b6:	f7ff fd8d 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SET_REL_ADDR, SDMMC_CMDTIMEOUT);
 800d0ba:	f241 3288 	movw	r2, #5000	; 0x1388
 800d0be:	4621      	mov	r1, r4
 800d0c0:	4628      	mov	r0, r5
 800d0c2:	f7ff fdeb 	bl	800cc9c <SDMMC_GetCmdResp1>

  return errorstate;
}
 800d0c6:	b007      	add	sp, #28
 800d0c8:	bd30      	pop	{r4, r5, pc}

0800d0ca <SDMMC_CmdSendStatus>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Argument Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendStatus(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d0ca:	b530      	push	{r4, r5, lr}
 800d0cc:	b087      	sub	sp, #28
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_STATUS;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d0ce:	f44f 7380 	mov.w	r3, #256	; 0x100
 800d0d2:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d0d4:	2300      	movs	r3, #0
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Argument Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendStatus(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d0d6:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = Argument;
 800d0d8:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_STATUS;
 800d0da:	240d      	movs	r4, #13
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d0dc:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d0de:	a901      	add	r1, sp, #4

  sdmmc_cmdinit.Argument         = Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_STATUS;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d0e0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800d0e4:	9305      	str	r3, [sp, #20]
{
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_STATUS;
 800d0e6:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d0e8:	f7ff fd74 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEND_STATUS, SDMMC_CMDTIMEOUT);
 800d0ec:	f241 3288 	movw	r2, #5000	; 0x1388
 800d0f0:	4621      	mov	r1, r4
 800d0f2:	4628      	mov	r0, r5
 800d0f4:	f7ff fdd2 	bl	800cc9c <SDMMC_GetCmdResp1>

  return errorstate;
}
 800d0f8:	b007      	add	sp, #28
 800d0fa:	bd30      	pop	{r4, r5, pc}

0800d0fc <SDMMC_CmdStatusRegister>:
  * @brief  Send the Status register command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdStatusRegister(SDMMC_TypeDef *SDMMCx)
{
 800d0fc:	b530      	push	{r4, r5, lr}
 800d0fe:	b087      	sub	sp, #28
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0U;
 800d100:	2300      	movs	r3, #0
  * @brief  Send the Status register command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdStatusRegister(SDMMC_TypeDef *SDMMCx)
{
 800d102:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0U;
 800d104:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_STATUS;
 800d106:	240d      	movs	r4, #13
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d108:	f44f 7280 	mov.w	r2, #256	; 0x100
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d10c:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d10e:	a901      	add	r1, sp, #4

  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_STATUS;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d110:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_STATUS;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d114:	9203      	str	r2, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d116:	9305      	str	r3, [sp, #20]
{
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_STATUS;
 800d118:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d11a:	f7ff fd5b 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_APP_STATUS, SDMMC_CMDTIMEOUT);
 800d11e:	f241 3288 	movw	r2, #5000	; 0x1388
 800d122:	4621      	mov	r1, r4
 800d124:	4628      	mov	r0, r5
 800d126:	f7ff fdb9 	bl	800cc9c <SDMMC_GetCmdResp1>

  return errorstate;
}
 800d12a:	b007      	add	sp, #28
 800d12c:	bd30      	pop	{r4, r5, pc}

0800d12e <SDMMC_CmdSwitch>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @parame Argument: Argument used for the command
  * @retval HAL status
  */
uint32_t SDMMC_CmdSwitch(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d12e:	b530      	push	{r4, r5, lr}
 800d130:	b087      	sub	sp, #28

  /* Send CMD6 to activate SDR50 Mode and Power Limit 1.44W */
  /* CMD Response: R1 */
  sdmmc_cmdinit.Argument         = Argument; /* SDMMC_SDR25_SWITCH_PATTERN;*/
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SWITCH;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d132:	f44f 7380 	mov.w	r3, #256	; 0x100
 800d136:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d138:	2300      	movs	r3, #0
  * @param  SDMMCx Pointer to SDMMC register base
  * @parame Argument: Argument used for the command
  * @retval HAL status
  */
uint32_t SDMMC_CmdSwitch(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d13a:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD6 to activate SDR50 Mode and Power Limit 1.44W */
  /* CMD Response: R1 */
  sdmmc_cmdinit.Argument         = Argument; /* SDMMC_SDR25_SWITCH_PATTERN;*/
 800d13c:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SWITCH;
 800d13e:	2406      	movs	r4, #6
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d140:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d142:	a901      	add	r1, sp, #4
  /* CMD Response: R1 */
  sdmmc_cmdinit.Argument         = Argument; /* SDMMC_SDR25_SWITCH_PATTERN;*/
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SWITCH;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d144:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800d148:	9305      	str	r3, [sp, #20]
  uint32_t errorstate;

  /* Send CMD6 to activate SDR50 Mode and Power Limit 1.44W */
  /* CMD Response: R1 */
  sdmmc_cmdinit.Argument         = Argument; /* SDMMC_SDR25_SWITCH_PATTERN;*/
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SWITCH;
 800d14a:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d14c:	f7ff fd42 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_HS_SWITCH, SDMMC_CMDTIMEOUT);
 800d150:	f241 3288 	movw	r2, #5000	; 0x1388
 800d154:	4621      	mov	r1, r4
 800d156:	4628      	mov	r0, r5
 800d158:	f7ff fda0 	bl	800cc9c <SDMMC_GetCmdResp1>

  return errorstate;
}
 800d15c:	b007      	add	sp, #28
 800d15e:	bd30      	pop	{r4, r5, pc}

0800d160 <SDMMC_CmdBusWidth>:
 800d160:	f7ff bfe5 	b.w	800d12e <SDMMC_CmdSwitch>

0800d164 <SDMMC_CmdVoltageSwitch>:
  *         condition register (OCR)
  * @param  None
  * @retval HAL status
  */
uint32_t SDMMC_CmdVoltageSwitch(SDMMC_TypeDef *SDMMCx)
{
 800d164:	b530      	push	{r4, r5, lr}
 800d166:	b087      	sub	sp, #28
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0x00000000;
 800d168:	2300      	movs	r3, #0
  *         condition register (OCR)
  * @param  None
  * @retval HAL status
  */
uint32_t SDMMC_CmdVoltageSwitch(SDMMC_TypeDef *SDMMCx)
{
 800d16a:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0x00000000;
 800d16c:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_VOLTAGE_SWITCH;
 800d16e:	240b      	movs	r4, #11
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d170:	f44f 7280 	mov.w	r2, #256	; 0x100
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d174:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d176:	a901      	add	r1, sp, #4

  sdmmc_cmdinit.Argument         = 0x00000000;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_VOLTAGE_SWITCH;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d178:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0x00000000;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_VOLTAGE_SWITCH;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d17c:	9203      	str	r2, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d17e:	9305      	str	r3, [sp, #20]
{
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0x00000000;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_VOLTAGE_SWITCH;
 800d180:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d182:	f7ff fd27 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_VOLTAGE_SWITCH, SDMMC_CMDTIMEOUT);
 800d186:	f241 3288 	movw	r2, #5000	; 0x1388
 800d18a:	4621      	mov	r1, r4
 800d18c:	4628      	mov	r0, r5
 800d18e:	f7ff fd85 	bl	800cc9c <SDMMC_GetCmdResp1>

  return errorstate;
}
 800d192:	b007      	add	sp, #28
 800d194:	bd30      	pop	{r4, r5, pc}

0800d196 <SDMMC_CmdSendEXTCSD>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Argument Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendEXTCSD(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d196:	b530      	push	{r4, r5, lr}
 800d198:	b087      	sub	sp, #28
  uint32_t errorstate;

  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d19a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800d19e:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d1a0:	2300      	movs	r3, #0
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Argument Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendEXTCSD(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d1a2:	4605      	mov	r5, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
 800d1a4:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
 800d1a6:	2408      	movs	r4, #8
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d1a8:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d1aa:	a901      	add	r1, sp, #4
  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d1ac:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800d1b0:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
 800d1b2:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d1b4:	f7ff fd0e 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_HS_SEND_EXT_CSD,SDMMC_CMDTIMEOUT);
 800d1b8:	f241 3288 	movw	r2, #5000	; 0x1388
 800d1bc:	4621      	mov	r1, r4
 800d1be:	4628      	mov	r0, r5
 800d1c0:	f7ff fd6c 	bl	800cc9c <SDMMC_GetCmdResp1>

  return errorstate;
}
 800d1c4:	b007      	add	sp, #28
 800d1c6:	bd30      	pop	{r4, r5, pc}

0800d1c8 <SDMMC_GetCmdResp2>:
uint32_t SDMMC_GetCmdResp2(SDMMC_TypeDef *SDMMCx)
{
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800d1c8:	4b12      	ldr	r3, [pc, #72]	; (800d214 <SDMMC_GetCmdResp2+0x4c>)
 800d1ca:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
 800d1ce:	681b      	ldr	r3, [r3, #0]
 800d1d0:	fbb3 f1f1 	udiv	r1, r3, r1
 800d1d4:	f241 3388 	movw	r3, #5000	; 0x1388
  * @brief  Checks for error conditions for R2 (CID or CSD) response.
  * @param  hsd SD handle
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp2(SDMMC_TypeDef *SDMMCx)
{
 800d1d8:	4602      	mov	r2, r0
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800d1da:	434b      	muls	r3, r1

  do
  {
    if (count-- == 0U)
 800d1dc:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800d1e0:	d315      	bcc.n	800d20e <SDMMC_GetCmdResp2+0x46>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
 800d1e2:	6b51      	ldr	r1, [r2, #52]	; 0x34
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800d1e4:	f011 0f45 	tst.w	r1, #69	; 0x45
 800d1e8:	d0f8      	beq.n	800d1dc <SDMMC_GetCmdResp2+0x14>
    if (count-- == 0U)
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 800d1ea:	0489      	lsls	r1, r1, #18
 800d1ec:	d4f6      	bmi.n	800d1dc <SDMMC_GetCmdResp2+0x14>
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800d1ee:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800d1f0:	075b      	lsls	r3, r3, #29
 800d1f2:	d501      	bpl.n	800d1f8 <SDMMC_GetCmdResp2+0x30>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800d1f4:	2304      	movs	r3, #4
 800d1f6:	e004      	b.n	800d202 <SDMMC_GetCmdResp2+0x3a>

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800d1f8:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800d1fa:	f013 0001 	ands.w	r0, r3, #1
 800d1fe:	d003      	beq.n	800d208 <SDMMC_GetCmdResp2+0x40>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800d200:	2301      	movs	r3, #1
 800d202:	6393      	str	r3, [r2, #56]	; 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
 800d204:	4618      	mov	r0, r3
 800d206:	4770      	bx	lr
  }
  else
  {
    /* No error flag set */
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800d208:	4b03      	ldr	r3, [pc, #12]	; (800d218 <SDMMC_GetCmdResp2+0x50>)
 800d20a:	6393      	str	r3, [r2, #56]	; 0x38
 800d20c:	4770      	bx	lr

  do
  {
    if (count-- == 0U)
    {
      return SDMMC_ERROR_TIMEOUT;
 800d20e:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
  }

  return SDMMC_ERROR_NONE;
}
 800d212:	4770      	bx	lr
 800d214:	20000448 	.word	0x20000448
 800d218:	002000c5 	.word	0x002000c5

0800d21c <SDMMC_CmdSendCID>:
  * @brief  Send the Send CID command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendCID(SDMMC_TypeDef *SDMMCx)
{
 800d21c:	b510      	push	{r4, lr}
 800d21e:	b086      	sub	sp, #24
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD2 ALL_SEND_CID */
  sdmmc_cmdinit.Argument         = 0U;
 800d220:	2300      	movs	r3, #0
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
 800d222:	2202      	movs	r2, #2
  * @brief  Send the Send CID command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendCID(SDMMC_TypeDef *SDMMCx)
{
 800d224:	4604      	mov	r4, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD2 ALL_SEND_CID */
  sdmmc_cmdinit.Argument         = 0U;
 800d226:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
 800d228:	9202      	str	r2, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d22a:	9304      	str	r3, [sp, #16]
  uint32_t errorstate;

  /* Send CMD2 ALL_SEND_CID */
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
 800d22c:	f44f 7240 	mov.w	r2, #768	; 0x300
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d230:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d234:	a901      	add	r1, sp, #4
  uint32_t errorstate;

  /* Send CMD2 ALL_SEND_CID */
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
 800d236:	9203      	str	r2, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d238:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d23a:	f7ff fccb 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
 800d23e:	4620      	mov	r0, r4
 800d240:	f7ff ffc2 	bl	800d1c8 <SDMMC_GetCmdResp2>

  return errorstate;
}
 800d244:	b006      	add	sp, #24
 800d246:	bd10      	pop	{r4, pc}

0800d248 <SDMMC_CmdSendCSD>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Argument Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendCSD(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d248:	b510      	push	{r4, lr}
 800d24a:	b086      	sub	sp, #24
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_CSD;
 800d24c:	2309      	movs	r3, #9
 800d24e:	9302      	str	r3, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
 800d250:	f44f 7340 	mov.w	r3, #768	; 0x300
 800d254:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d256:	2300      	movs	r3, #0
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Argument Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendCSD(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d258:	4604      	mov	r4, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
 800d25a:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_CSD;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d25c:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d25e:	a901      	add	r1, sp, #4
  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_CSD;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d260:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800d264:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d266:	f7ff fcb5 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
 800d26a:	4620      	mov	r0, r4
 800d26c:	f7ff ffac 	bl	800d1c8 <SDMMC_GetCmdResp2>

  return errorstate;
}
 800d270:	b006      	add	sp, #24
 800d272:	bd10      	pop	{r4, pc}

0800d274 <SDMMC_GetCmdResp3>:
uint32_t SDMMC_GetCmdResp3(SDMMC_TypeDef *SDMMCx)
{
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800d274:	4b10      	ldr	r3, [pc, #64]	; (800d2b8 <SDMMC_GetCmdResp3+0x44>)
 800d276:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
 800d27a:	681b      	ldr	r3, [r3, #0]
 800d27c:	fbb3 f1f1 	udiv	r1, r3, r1
 800d280:	f241 3388 	movw	r3, #5000	; 0x1388
  * @brief  Checks for error conditions for R3 (OCR) response.
  * @param  hsd SD handle
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp3(SDMMC_TypeDef *SDMMCx)
{
 800d284:	4602      	mov	r2, r0
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800d286:	434b      	muls	r3, r1

  do
  {
    if (count-- == 0U)
 800d288:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800d28c:	d310      	bcc.n	800d2b0 <SDMMC_GetCmdResp3+0x3c>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
 800d28e:	6b51      	ldr	r1, [r2, #52]	; 0x34
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800d290:	f011 0f45 	tst.w	r1, #69	; 0x45
 800d294:	d0f8      	beq.n	800d288 <SDMMC_GetCmdResp3+0x14>
    if (count-- == 0U)
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 800d296:	0489      	lsls	r1, r1, #18
 800d298:	d4f6      	bmi.n	800d288 <SDMMC_GetCmdResp3+0x14>
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800d29a:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800d29c:	f013 0004 	ands.w	r0, r3, #4
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800d2a0:	bf17      	itett	ne
 800d2a2:	2304      	movne	r3, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }
  else
  {
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800d2a4:	4b05      	ldreq	r3, [pc, #20]	; (800d2bc <SDMMC_GetCmdResp3+0x48>)
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800d2a6:	6393      	strne	r3, [r2, #56]	; 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800d2a8:	4618      	movne	r0, r3
  }
  else
  {
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800d2aa:	bf08      	it	eq
 800d2ac:	6393      	streq	r3, [r2, #56]	; 0x38
 800d2ae:	4770      	bx	lr

  do
  {
    if (count-- == 0U)
    {
      return SDMMC_ERROR_TIMEOUT;
 800d2b0:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
  }

  return SDMMC_ERROR_NONE;
}
 800d2b4:	4770      	bx	lr
 800d2b6:	bf00      	nop
 800d2b8:	20000448 	.word	0x20000448
 800d2bc:	002000c5 	.word	0x002000c5

0800d2c0 <SDMMC_CmdAppOperCommand>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Argument Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdAppOperCommand(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d2c0:	b510      	push	{r4, lr}
 800d2c2:	b086      	sub	sp, #24
#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  sdmmc_cmdinit.Argument         = Argument;
#else
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | Argument;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_OP_COND;
 800d2c4:	2329      	movs	r3, #41	; 0x29
 800d2c6:	9302      	str	r3, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d2c8:	f44f 7380 	mov.w	r3, #256	; 0x100
 800d2cc:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d2ce:	2300      	movs	r3, #0
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  Argument Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdAppOperCommand(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d2d0:	4604      	mov	r4, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

#if defined(STM32L4P5xx) || defined(STM32L4Q5xx) || defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  sdmmc_cmdinit.Argument         = Argument;
 800d2d2:	9101      	str	r1, [sp, #4]
#else
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | Argument;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_OP_COND;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d2d4:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d2d6:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | Argument;
#endif /* STM32L4P5xx || STM32L4Q5xx || STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_OP_COND;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d2d8:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800d2dc:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d2de:	f7ff fc79 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp3(SDMMCx);
 800d2e2:	4620      	mov	r0, r4
 800d2e4:	f7ff ffc6 	bl	800d274 <SDMMC_GetCmdResp3>

  return errorstate;
}
 800d2e8:	b006      	add	sp, #24
 800d2ea:	bd10      	pop	{r4, pc}

0800d2ec <SDMMC_CmdOpCondition>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @parame Argument: Argument used for the command
  * @retval HAL status
  */
uint32_t SDMMC_CmdOpCondition(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d2ec:	b510      	push	{r4, lr}
 800d2ee:	b086      	sub	sp, #24
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_OP_COND;
 800d2f0:	2301      	movs	r3, #1
 800d2f2:	9302      	str	r3, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d2f4:	f44f 7380 	mov.w	r3, #256	; 0x100
 800d2f8:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d2fa:	2300      	movs	r3, #0
  * @param  SDMMCx Pointer to SDMMC register base
  * @parame Argument: Argument used for the command
  * @retval HAL status
  */
uint32_t SDMMC_CmdOpCondition(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
 800d2fc:	4604      	mov	r4, r0
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = Argument;
 800d2fe:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_OP_COND;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d300:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d302:	a901      	add	r1, sp, #4

  sdmmc_cmdinit.Argument         = Argument;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_OP_COND;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d304:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800d308:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d30a:	f7ff fc63 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp3(SDMMCx);
 800d30e:	4620      	mov	r0, r4
 800d310:	f7ff ffb0 	bl	800d274 <SDMMC_GetCmdResp3>

  return errorstate;
}
 800d314:	b006      	add	sp, #24
 800d316:	bd10      	pop	{r4, pc}

0800d318 <SDMMC_GetCmdResp6>:
  uint32_t response_r1;
  uint32_t sta_reg;

  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800d318:	4b1e      	ldr	r3, [pc, #120]	; (800d394 <SDMMC_GetCmdResp6+0x7c>)
  * @param  pRCA Pointer to the variable that will contain the SD card relative
  *         address RCA
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp6(SDMMC_TypeDef *SDMMCx, uint8_t SD_CMD, uint16_t *pRCA)
{
 800d31a:	b510      	push	{r4, lr}
  uint32_t response_r1;
  uint32_t sta_reg;

  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800d31c:	681b      	ldr	r3, [r3, #0]
 800d31e:	f44f 54fa 	mov.w	r4, #8000	; 0x1f40
 800d322:	fbb3 f4f4 	udiv	r4, r3, r4
 800d326:	f241 3388 	movw	r3, #5000	; 0x1388
 800d32a:	4363      	muls	r3, r4

  do
  {
    if (count-- == 0U)
 800d32c:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800d330:	d328      	bcc.n	800d384 <SDMMC_GetCmdResp6+0x6c>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
 800d332:	6b44      	ldr	r4, [r0, #52]	; 0x34
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800d334:	f014 0f45 	tst.w	r4, #69	; 0x45
 800d338:	d0f8      	beq.n	800d32c <SDMMC_GetCmdResp6+0x14>
    if (count-- == 0U)
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 800d33a:	04a4      	lsls	r4, r4, #18
 800d33c:	d4f6      	bmi.n	800d32c <SDMMC_GetCmdResp6+0x14>
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800d33e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800d340:	075b      	lsls	r3, r3, #29
 800d342:	d501      	bpl.n	800d348 <SDMMC_GetCmdResp6+0x30>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800d344:	2304      	movs	r3, #4
 800d346:	e003      	b.n	800d350 <SDMMC_GetCmdResp6+0x38>

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800d348:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800d34a:	07dc      	lsls	r4, r3, #31
 800d34c:	d503      	bpl.n	800d356 <SDMMC_GetCmdResp6+0x3e>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800d34e:	2301      	movs	r3, #1
 800d350:	6383      	str	r3, [r0, #56]	; 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
 800d352:	4618      	mov	r0, r3
 800d354:	bd10      	pop	{r4, pc}
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval Command index of the last command response received
  */
uint8_t SDMMC_GetCommandResponse(SDMMC_TypeDef *SDMMCx)
{
  return (uint8_t)(SDMMCx->RESPCMD);
 800d356:	6903      	ldr	r3, [r0, #16]
  {
    /* Nothing to do */
  }

  /* Check response received is of desired command */
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800d358:	b2db      	uxtb	r3, r3
 800d35a:	4299      	cmp	r1, r3
 800d35c:	d115      	bne.n	800d38a <SDMMC_GetCmdResp6+0x72>
  {
    return SDMMC_ERROR_CMD_CRC_FAIL;
  }

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800d35e:	4b0e      	ldr	r3, [pc, #56]	; (800d398 <SDMMC_GetCmdResp6+0x80>)
 800d360:	6383      	str	r3, [r0, #56]	; 0x38
  assert_param(IS_SDMMC_RESP(Response));

  /* Get the response */
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;

  return (*(__IO uint32_t *) tmp);
 800d362:	6943      	ldr	r3, [r0, #20]
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);

  /* We have received response, retrieve it.  */
  response_r1 = SDMMC_GetResponse(SDMMCx, SDMMC_RESP1);

  if((response_r1 & (SDMMC_R6_GENERAL_UNKNOWN_ERROR | SDMMC_R6_ILLEGAL_CMD | SDMMC_R6_COM_CRC_FAILED)) == SDMMC_ALLZERO)
 800d364:	f413 4060 	ands.w	r0, r3, #57344	; 0xe000
 800d368:	d102      	bne.n	800d370 <SDMMC_GetCmdResp6+0x58>
  {
    *pRCA = (uint16_t) (response_r1 >> 16);
 800d36a:	0c1b      	lsrs	r3, r3, #16
 800d36c:	8013      	strh	r3, [r2, #0]
 800d36e:	bd10      	pop	{r4, pc}

    return SDMMC_ERROR_NONE;
  }
  else if((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
 800d370:	045a      	lsls	r2, r3, #17
 800d372:	d40c      	bmi.n	800d38e <SDMMC_GetCmdResp6+0x76>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
  }
  else if((response_r1 & SDMMC_R6_COM_CRC_FAILED) == SDMMC_R6_COM_CRC_FAILED)
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
 800d374:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 800d378:	bf0c      	ite	eq
 800d37a:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
 800d37e:	f44f 5080 	movne.w	r0, #4096	; 0x1000
 800d382:	bd10      	pop	{r4, pc}

  do
  {
    if (count-- == 0U)
    {
      return SDMMC_ERROR_TIMEOUT;
 800d384:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800d388:	bd10      	pop	{r4, pc}
  }

  /* Check response received is of desired command */
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
  {
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800d38a:	2001      	movs	r0, #1
 800d38c:	bd10      	pop	{r4, pc}

    return SDMMC_ERROR_NONE;
  }
  else if((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
 800d38e:	f44f 5000 	mov.w	r0, #8192	; 0x2000
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
  }
}
 800d392:	bd10      	pop	{r4, pc}
 800d394:	20000448 	.word	0x20000448
 800d398:	002000c5 	.word	0x002000c5

0800d39c <SDMMC_CmdSetRelAdd>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  pRCA Card RCA
  * @retval HAL status
  */
uint32_t SDMMC_CmdSetRelAdd(SDMMC_TypeDef *SDMMCx, uint16_t *pRCA)
{
 800d39c:	b570      	push	{r4, r5, r6, lr}
 800d39e:	b086      	sub	sp, #24
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = 0U;
 800d3a0:	2300      	movs	r3, #0
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  pRCA Card RCA
  * @retval HAL status
  */
uint32_t SDMMC_CmdSetRelAdd(SDMMC_TypeDef *SDMMCx, uint16_t *pRCA)
{
 800d3a2:	4605      	mov	r5, r0
 800d3a4:	460e      	mov	r6, r1
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = 0U;
 800d3a6:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
 800d3a8:	2403      	movs	r4, #3
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d3aa:	f44f 7280 	mov.w	r2, #256	; 0x100
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d3ae:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d3b0:	a901      	add	r1, sp, #4
  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d3b2:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  uint32_t errorstate;

  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d3b6:	9203      	str	r2, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d3b8:	9305      	str	r3, [sp, #20]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = 0U;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
 800d3ba:	9402      	str	r4, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d3bc:	f7ff fc0a 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp6(SDMMCx, SDMMC_CMD_SET_REL_ADDR, pRCA);
 800d3c0:	4632      	mov	r2, r6
 800d3c2:	4621      	mov	r1, r4
 800d3c4:	4628      	mov	r0, r5
 800d3c6:	f7ff ffa7 	bl	800d318 <SDMMC_GetCmdResp6>

  return errorstate;
}
 800d3ca:	b006      	add	sp, #24
 800d3cc:	bd70      	pop	{r4, r5, r6, pc}
	...

0800d3d0 <SDMMC_GetCmdResp7>:
uint32_t SDMMC_GetCmdResp7(SDMMC_TypeDef *SDMMCx)
{
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800d3d0:	4b15      	ldr	r3, [pc, #84]	; (800d428 <SDMMC_GetCmdResp7+0x58>)
 800d3d2:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
 800d3d6:	681b      	ldr	r3, [r3, #0]
 800d3d8:	fbb3 f1f1 	udiv	r1, r3, r1
 800d3dc:	f241 3388 	movw	r3, #5000	; 0x1388
  * @brief  Checks for error conditions for R7 response.
  * @param  hsd SD handle
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp7(SDMMC_TypeDef *SDMMCx)
{
 800d3e0:	4602      	mov	r2, r0
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800d3e2:	434b      	muls	r3, r1

  do
  {
    if (count-- == 0U)
 800d3e4:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800d3e8:	d31a      	bcc.n	800d420 <SDMMC_GetCmdResp7+0x50>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
 800d3ea:	6b51      	ldr	r1, [r2, #52]	; 0x34
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800d3ec:	f011 0f45 	tst.w	r1, #69	; 0x45
 800d3f0:	d0f8      	beq.n	800d3e4 <SDMMC_GetCmdResp7+0x14>
    if (count-- == 0U)
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 800d3f2:	0489      	lsls	r1, r1, #18
 800d3f4:	d4f6      	bmi.n	800d3e4 <SDMMC_GetCmdResp7+0x14>
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800d3f6:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800d3f8:	075b      	lsls	r3, r3, #29
 800d3fa:	d501      	bpl.n	800d400 <SDMMC_GetCmdResp7+0x30>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800d3fc:	2304      	movs	r3, #4
 800d3fe:	e004      	b.n	800d40a <SDMMC_GetCmdResp7+0x3a>

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }

  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800d400:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800d402:	f013 0101 	ands.w	r1, r3, #1
 800d406:	d003      	beq.n	800d410 <SDMMC_GetCmdResp7+0x40>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800d408:	2301      	movs	r3, #1
 800d40a:	6393      	str	r3, [r2, #56]	; 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
 800d40c:	4618      	mov	r0, r3
 800d40e:	4770      	bx	lr
  else
  {
    /* Nothing to do */
  }

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDREND))
 800d410:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800d412:	f013 0040 	ands.w	r0, r3, #64	; 0x40
 800d416:	d005      	beq.n	800d424 <SDMMC_GetCmdResp7+0x54>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
 800d418:	2340      	movs	r3, #64	; 0x40
 800d41a:	6393      	str	r3, [r2, #56]	; 0x38
 800d41c:	4608      	mov	r0, r1
 800d41e:	4770      	bx	lr

  do
  {
    if (count-- == 0U)
    {
      return SDMMC_ERROR_TIMEOUT;
 800d420:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
  }

  return SDMMC_ERROR_NONE;

}
 800d424:	4770      	bx	lr
 800d426:	bf00      	nop
 800d428:	20000448 	.word	0x20000448

0800d42c <SDMMC_CmdOperCond>:
  * @brief  Send the Operating Condition command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdOperCond(SDMMC_TypeDef *SDMMCx)
{
 800d42c:	b510      	push	{r4, lr}
 800d42e:	b086      	sub	sp, #24
  /* Send CMD8 to verify SD card interface operating condition */
  /* Argument: - [31:12]: Reserved (shall be set to '0')
  - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
  - [7:0]: Check Pattern (recommended 0xAA) */
  /* CMD Response: R7 */
  sdmmc_cmdinit.Argument         = SDMMC_CHECK_PATTERN;
 800d430:	f44f 73d5 	mov.w	r3, #426	; 0x1aa
 800d434:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
 800d436:	2308      	movs	r3, #8
 800d438:	9302      	str	r3, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800d43a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800d43e:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d440:	2300      	movs	r3, #0
  * @brief  Send the Operating Condition command and check the response.
  * @param  SDMMCx Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdOperCond(SDMMC_TypeDef *SDMMCx)
{
 800d442:	4604      	mov	r4, r0
  - [7:0]: Check Pattern (recommended 0xAA) */
  /* CMD Response: R7 */
  sdmmc_cmdinit.Argument         = SDMMC_CHECK_PATTERN;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800d444:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d446:	a901      	add	r1, sp, #4
  /* CMD Response: R7 */
  sdmmc_cmdinit.Argument         = SDMMC_CHECK_PATTERN;
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800d448:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800d44c:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800d44e:	f7ff fbc1 	bl	800cbd4 <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp7(SDMMCx);
 800d452:	4620      	mov	r0, r4
 800d454:	f7ff ffbc 	bl	800d3d0 <SDMMC_GetCmdResp7>

  return errorstate;
}
 800d458:	b006      	add	sp, #24
 800d45a:	bd10      	pop	{r4, pc}

0800d45c <memcmp>:
 800d45c:	b510      	push	{r4, lr}
 800d45e:	3901      	subs	r1, #1
 800d460:	4402      	add	r2, r0
 800d462:	4290      	cmp	r0, r2
 800d464:	d007      	beq.n	800d476 <memcmp+0x1a>
 800d466:	f810 3b01 	ldrb.w	r3, [r0], #1
 800d46a:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 800d46e:	42a3      	cmp	r3, r4
 800d470:	d0f7      	beq.n	800d462 <memcmp+0x6>
 800d472:	1b18      	subs	r0, r3, r4
 800d474:	bd10      	pop	{r4, pc}
 800d476:	2000      	movs	r0, #0
 800d478:	bd10      	pop	{r4, pc}

0800d47a <memcpy>:
 800d47a:	b510      	push	{r4, lr}
 800d47c:	1e43      	subs	r3, r0, #1
 800d47e:	440a      	add	r2, r1
 800d480:	4291      	cmp	r1, r2
 800d482:	d004      	beq.n	800d48e <memcpy+0x14>
 800d484:	f811 4b01 	ldrb.w	r4, [r1], #1
 800d488:	f803 4f01 	strb.w	r4, [r3, #1]!
 800d48c:	e7f8      	b.n	800d480 <memcpy+0x6>
 800d48e:	bd10      	pop	{r4, pc}

0800d490 <memmove>:
 800d490:	4288      	cmp	r0, r1
 800d492:	b510      	push	{r4, lr}
 800d494:	eb01 0302 	add.w	r3, r1, r2
 800d498:	d801      	bhi.n	800d49e <memmove+0xe>
 800d49a:	1e42      	subs	r2, r0, #1
 800d49c:	e00b      	b.n	800d4b6 <memmove+0x26>
 800d49e:	4298      	cmp	r0, r3
 800d4a0:	d2fb      	bcs.n	800d49a <memmove+0xa>
 800d4a2:	1881      	adds	r1, r0, r2
 800d4a4:	1ad2      	subs	r2, r2, r3
 800d4a6:	42d3      	cmn	r3, r2
 800d4a8:	d004      	beq.n	800d4b4 <memmove+0x24>
 800d4aa:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 800d4ae:	f801 4d01 	strb.w	r4, [r1, #-1]!
 800d4b2:	e7f8      	b.n	800d4a6 <memmove+0x16>
 800d4b4:	bd10      	pop	{r4, pc}
 800d4b6:	4299      	cmp	r1, r3
 800d4b8:	d004      	beq.n	800d4c4 <memmove+0x34>
 800d4ba:	f811 4b01 	ldrb.w	r4, [r1], #1
 800d4be:	f802 4f01 	strb.w	r4, [r2, #1]!
 800d4c2:	e7f8      	b.n	800d4b6 <memmove+0x26>
 800d4c4:	bd10      	pop	{r4, pc}

0800d4c6 <memset>:
 800d4c6:	4402      	add	r2, r0
 800d4c8:	4603      	mov	r3, r0
 800d4ca:	4293      	cmp	r3, r2
 800d4cc:	d002      	beq.n	800d4d4 <memset+0xe>
 800d4ce:	f803 1b01 	strb.w	r1, [r3], #1
 800d4d2:	e7fa      	b.n	800d4ca <memset+0x4>
 800d4d4:	4770      	bx	lr
	...

0800d4d8 <setjmp>:
 800d4d8:	46ec      	mov	ip, sp
 800d4da:	e8a0 5ff0 	stmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
 800d4de:	f04f 0000 	mov.w	r0, #0
 800d4e2:	4770      	bx	lr

0800d4e4 <longjmp>:
 800d4e4:	e8b0 5ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
 800d4e8:	46e5      	mov	sp, ip
 800d4ea:	0008      	movs	r0, r1
 800d4ec:	bf08      	it	eq
 800d4ee:	2001      	moveq	r0, #1
 800d4f0:	4770      	bx	lr
 800d4f2:	bf00      	nop

0800d4f4 <strlcpy>:
 800d4f4:	b510      	push	{r4, lr}
 800d4f6:	460b      	mov	r3, r1
 800d4f8:	b152      	cbz	r2, 800d510 <strlcpy+0x1c>
 800d4fa:	3a01      	subs	r2, #1
 800d4fc:	d006      	beq.n	800d50c <strlcpy+0x18>
 800d4fe:	f813 4b01 	ldrb.w	r4, [r3], #1
 800d502:	f800 4b01 	strb.w	r4, [r0], #1
 800d506:	2c00      	cmp	r4, #0
 800d508:	d1f7      	bne.n	800d4fa <strlcpy+0x6>
 800d50a:	e005      	b.n	800d518 <strlcpy+0x24>
 800d50c:	2200      	movs	r2, #0
 800d50e:	7002      	strb	r2, [r0, #0]
 800d510:	f813 2b01 	ldrb.w	r2, [r3], #1
 800d514:	2a00      	cmp	r2, #0
 800d516:	d1fb      	bne.n	800d510 <strlcpy+0x1c>
 800d518:	1a58      	subs	r0, r3, r1
 800d51a:	3801      	subs	r0, #1
 800d51c:	bd10      	pop	{r4, pc}

0800d51e <strlen>:
 800d51e:	4603      	mov	r3, r0
 800d520:	f813 2b01 	ldrb.w	r2, [r3], #1
 800d524:	2a00      	cmp	r2, #0
 800d526:	d1fb      	bne.n	800d520 <strlen+0x2>
 800d528:	1a18      	subs	r0, r3, r0
 800d52a:	3801      	subs	r0, #1
 800d52c:	4770      	bx	lr
	...

0800d530 <__flash_page_erase_veneer>:
 800d530:	b401      	push	{r0}
 800d532:	4802      	ldr	r0, [pc, #8]	; (800d53c <__flash_page_erase_veneer+0xc>)
 800d534:	4684      	mov	ip, r0
 800d536:	bc01      	pop	{r0}
 800d538:	4760      	bx	ip
 800d53a:	bf00      	nop
 800d53c:	20000095 	.word	0x20000095

0800d540 <__flash_burn_veneer>:
 800d540:	b401      	push	{r0}
 800d542:	4802      	ldr	r0, [pc, #8]	; (800d54c <__flash_burn_veneer+0xc>)
 800d544:	4684      	mov	ip, r0
 800d546:	bc01      	pop	{r0}
 800d548:	4760      	bx	ip
 800d54a:	bf00      	nop
 800d54c:	20000001 	.word	0x20000001
 800d550:	65737361 	.word	0x65737361
 800d554:	69007472 	.word	0x69007472
 800d558:	6e6f636e 	.word	0x6e6f636e
 800d55c:	00          	.byte	0x00
 800d55d:	44          	.byte	0x44
 800d55e:	6569      	.short	0x6569
 800d560:	4644203a 	.word	0x4644203a
 800d564:	69440055 	.word	0x69440055
 800d568:	44203a65 	.word	0x44203a65
 800d56c:	676e776f 	.word	0x676e776f
 800d570:	65646172 	.word	0x65646172
 800d574:	65694400 	.word	0x65694400
 800d578:	6c42203a 	.word	0x6c42203a
 800d57c:	696b6e61 	.word	0x696b6e61
 800d580:	44006873 	.word	0x44006873
 800d584:	203a6569 	.word	0x203a6569
 800d588:	63697242 	.word	0x63697242
 800d58c:	6f42006b 	.word	0x6f42006b
 800d590:	4432746f 	.word	0x4432746f
 800d594:	4c005546 	.word	0x4c005546
 800d598:	0052      	.short	0x0052
 800d59a:	6e65      	.short	0x6e65
 800d59c:	5f726574 	.word	0x5f726574
 800d5a0:	28756664 	.word	0x28756664
 800d5a4:	0a0d0029 	.word	0x0a0d0029
 800d5a8:	346b4d0a 	.word	0x346b4d0a
 800d5ac:	6f6f4220 	.word	0x6f6f4220
 800d5b0:	616f6c74 	.word	0x616f6c74
 800d5b4:	3a726564 	.word	0x3a726564
 800d5b8:	45530020 	.word	0x45530020
 800d5bc:	65732031 	.word	0x65732031
 800d5c0:	3a707574 	.word	0x3a707574
 800d5c4:	6f640020 	.word	0x6f640020
 800d5c8:	5300656e 	.word	0x5300656e
 800d5cc:	73203245 	.word	0x73203245
 800d5d0:	70757465 	.word	0x70757465
 800d5d4:	5600203a 	.word	0x5600203a
 800d5d8:	66697265 	.word	0x66697265
 800d5dc:	00203a79 	.word	0x00203a79
 800d5e0:	00000150 	.word	0x00000150
 800d5e4:	00000001 	.word	0x00000001
 800d5e8:	00000000 	.word	0x00000000
 800d5ec:	00000001 	.word	0x00000001
 800d5f0:	00000000 	.word	0x00000000

0800d5f4 <before_show>:
 800d5f4:	227f0021 00210700                                !.."..

0800d5fa <setup.9057>:
 800d5fa:	227f0021 262e0707                                !.."..

0800d600 <animate.9058>:
 800d600:	0700262e ff000707 0020ae2f                       .&....../

0800d609 <reset_commands>:
 800d609:	400020ae c83fa8a1 12da00d3 f1d980d5     . .@..?.........
 800d619:	ff8130db 148da6a4 3a007faf                       .0.......

0800d622 <screen_verify>:
 800d622:	003a007f c0c08083 c003e006 006f8081     ..:...........o.
 800d632:	fefcf095 0103071f fc808081 010100fc     ................
 800d642:	fe7f0f03 006bc0f8 3f1f0788 c0e0f07c     ......k....?|...
 800d652:	898104c1 e0c0c080 0f3f7ff8 82007001     ..........?..p..
 800d662:	03070101 5c010182 04f88100 00f88300     .......\........
 800d672:	84400480 80c00080 80864003 40400000     ..@......@....@@
 800d682:	810004d8 830803f0 04c00010 00c08600     ................
 800d692:	d8404000 c0820003 83400380 03800080     .@@.......@.....
 800d6a2:	c0808240 01880042 06181806 040f0001     @...B...........
 800d6b2:	00138312 8100091f 8200031f 01031f01     ................
 800d6c2:	47000083 84828803 8100047f 8100031f     ...G............
 800d6d2:	8300041f 0347001f 7f848288 0022007f     ......G.......".
	...

0800d6e3 <screen_corrupt>:
 800d6e3:	003b007f c0878003 60604040 c0044040     ..;.....@@``@@..
 800d6f3:	006c8081 1cf8c087 01010306 0f83000b     ..l.............
 800d703:	006bc0ff 00ffff83 00038004 c0868004     ..k.............
 800d713:	1e3870e0 81006c07 81030301 82030801     .p8..l..........
 800d723:	005d0101 8804f881 00000886 03d84040     ..].........@@..
 800d733:	80c08200 808a4003 4040c000 00804080     .....@....@@.@..
 800d743:	830004c0 040000c0 00808440 400380c0     ........@......@
 800d753:	80008083 80874004 88080800 00433048     .....@......H0C.
 800d763:	00091f81 00031f81 00061f81 00001f8f     ................
 800d773:	001f0007 0f08100f 0e000f10 09841103     ................
 800d783:	061f001f 040f8100 00138412 007f1b00     ................
 800d793:	7f000026                                         &..

0800d796 <screen_devmode>:
 800d796:	0037007f 2090b085 001040f0 05e08082     ..7.... .@......
 800d7a6:	f0f884f0 004d80e0 70e08088 e6ce8c18     ......M....p....
 800d7b6:	81fe05f6 86fe04fc 0000019b 000e0101     ................
 800d7c6:	fff3b18f f3e3f3ff f3e3e3ff b1f3f7ff     ................
 800d7d6:	1f82004b 82ff0f7f 00111f7f ff05fc81     K...............
 800d7e6:	f180fc87 fec0e1ff f881ff05 0182004c     ............L...
 800d7f6:	82070903 00150103 030f0181 00330181     ..............3.
 800d806:	0803f881 00e01084 84400400 80c00080     ..........@.....
 800d816:	80834003 40038000 00c08084 84400480     .@.....@......@.
 800d826:	80c00080 80814003 f8810003 f081000b     .....@..........
 800d836:	30830804 0004c000 8000c083 80844004     ...0.........@..
 800d846:	03f04000 00008340 88400480 40c00080     .@..@.....@....@
 800d856:	80408040 f8810003 1f81001b 08841003     @.@.............
 800d866:	030e0007 1f098411 00041f00 47001f83     ...............G
 800d876:	84848803 040f007f 00138312 8100081f     ................
 800d886:	81000b1b 8310040f 030f000c 1f088410     ................
 800d896:	12040900 00000c84 8310030f 040f0008     ................
 800d8a6:	000f8810 0700001f 00031f00 007f1b81     ................
 800d8b6:	7f000010                                         ...

0800d8b9 <screen_downgrade>:
 800d8b9:	0036007f 80c0c085 c0038000 c084e005     ..6.............
 800d8c9:	6f8080c0 8f3f0600 0101113b 0101f9f8     ...o..?.;.......
 800d8d9:	ff1f0703 6dc0f8fe 70208600 e3e0f0f8     .......m.. p....
 800d8e9:	c089c304 7cf0e0e0 010f1f7f 01090071     .......|....q...
 800d8f9:	f881005a 10840803 048000e0 00808340     Z...........@...
 800d909:	840004c0 80c000c0 80834003 40038000     .........@.....@
 800d919:	00c08085 400380c0 00008083 80834004     .......@.....@..
 800d929:	40038000 00f88084 87400480 08080080     ...@......@.....
 800d939:	3c304888 031f8100 07088410 10040f00     .H0<............
 800d949:	0f000f8a 100f0810 041f000f 001f8300     ................
 800d959:	84880347 1f007f84 0e810006 09841103     G...............
 800d969:	030f001f 1f088410 12040f00 00001384     ................
 800d979:	22007f1b 007f0000                                ..."..

0800d97f <screen_logout>:
 800d97f:	0038007f 00778007 03fffe82 04f10301     ..8...w.........
 800d98f:	ffff89f0 f0f8fcfe 6b80c0e0 7f3f8200     ...........k..?.
 800d99f:	c703c003 07038781 3f7fff88 03070f1f     ...........?....
 800d9af:	52007f01 06f88100 04808100 00808340     ...R........@...
 800d9bf:	84400380 8000c080 80834004 0004c000     ..@......@......
 800d9cf:	4000c084 094003f0 03f88100 e0108408     ...@..@.........
 800d9df:	40048000 c0008084 83400380 04800080     ...@......@.....
 800d9ef:	34808140 051f8100 0f008210 0f831004     @..4............
 800d9ff:	88034700 007f8484 8310040f 030f000f     .G..............
 800da0f:	1f088510 030f0000 08088110 031f8100     ................
 800da1f:	07088410 10040f00 1f000f83 1f830004     ................
 800da2f:	12040f00 007f1381 7f00001b                       ...........

0800da3a <screen_se2_issue>:
 800da3a:	0038007f 00048081 04e0c082 c0e082f0     ..8.............
 800da4a:	80840072 05fe8783 0c0c82fc fe85fc05     r...............
 800da5a:	80818387 0103006a 03e78182 ffff867f     ....j...........
 800da6a:	ffff0000 ef857f03 010181c1 0182006c     ............l...
 800da7a:	82000e01 00630101 0004f881 f800f883     ......c.........
 800da8a:	88824804 89800600 88887000 00100808     .H.......p......
 800da9a:	838804f8 03300008 70888208 0f810057     ......0....pW...
 800daaa:	0f831004 10040800 06000f82 08008904     ................
 800daba:	11111010 051f000e 18008710 10111214     ................
 800daca:	2c007f10 007f0000                                ...,..

0800dad0 <screen_red_light>:
 800dad0:	0037007f 2090b085 001040f0 05e08082     ..7.... .@......
 800dae0:	f0f884f0 004d80e0 70e08088 e6ce8c18     ......M....p....
 800daf0:	81fe05f6 86fe04fc 0000019b 000e0101     ................
 800db00:	fff3b18f f3e3f3ff f3e3e3ff b1f3f7ff     ................
 800db10:	1f82004b 82ff0f7f 00111f7f ff05fc81     K...............
 800db20:	f180fc87 fec0e1ff f881ff05 0182004c     ............L...
 800db30:	82070903 00150103 030f0181 00300181     ..............0.
 800db40:	0803f881 00e01084 84400400 80c00080     ..........@.....
 800db50:	80834003 40038000 00c08084 84400480     .@.....@......@.
 800db60:	80c00080 80814003 f8810003 f081000b     .....@..........
 800db70:	30830804 40040000 c0008083 c0840004     ...0...@........
 800db80:	03f04000 83000340 03d84040 04808100     .@..@...@@......
 800db90:	00808440 400380c0 00038081 0014f881     @......@........
 800dba0:	10031f81 00070884 8411030e 1f001f09     ................
 800dbb0:	1f830004 88034700 007f8484 8312040f     .....G..........
 800dbc0:	081f0013 0b1b8100 040f8100 000c8310     ................
 800dbd0:	8411030e 0f001f09 08851003 0f00001f     ................
 800dbe0:	08811003 1f810004 0f810003 0f831004     ................
 800dbf0:	00041f00 00031f81 007f1b81 7f00000c              ...............

0800dbff <screen_upgrading>:
 800dbff:	0033007f 11e0e082 66800700 ffff8200     ..3........f....
 800dc0f:	80920006 e0f0e0c0 e0c080c0 7ffcf8f0     ................
 800dc1f:	1f0f1f3f 8d00661f 1000ffff 1f3e7c38     ?....f......8|>.
 800dc2f:	0303070f 830f0307 6d010307 54031b00     ...........m...T
 800dc3f:	04f88100 00f88400 400380c0 80008083     ...........@....
 800dc4f:	80854003 80c000c0 80834003 40040000     .@.......@.....@
 800dc5f:	80008083 80874003 400000f8 0003d840     .....@.....@@...
 800dc6f:	0380c082 00808340 82400380 0042c080     ....@.....@...B.
 800dc7f:	10040f81 7f000f84 83080304 03470007     ..............G.
 800dc8f:	7f848488 00061f00 11030e81 001f0984     ................
 800dc9f:	8210030f 00041f08 00031f81 00041f81     ................
 800dcaf:	47001f83 84828803 22007f7f 007f0000              ...G......."..

0800dcbd <screen_fatal>:
 800dcbd:	007f007f 0036007f 90fc9089 0090fc90     ......6.........
 800dccd:	4203fc40 f000048b 00c00000 fc4000f0     @..B..........@.
 800dcdd:	04814203 03840066 03030000 05078100     .B..f...........
 800dced:	04038900 03040302 7f070000 7f007f00     ................
 800dcfd:	00003900                                .9..

0800dd01 <screen_blankish>:
 800dd01:	007f007f 0034007f 000d8081 000d8081     ......4.........
 800dd11:	00628081 01030183 0183000b 000b0103     ..b.............
 800dd21:	01030183 007f007f 0034007f 39007f00              ..........4..

0800dd2e <screen_wiped>:
 800dd2e:	0039007f 00878004 f0f8f800 80030000     ..9.............
 800dd3e:	f089006f 073ffffc 00000103 00897f03     o.....?.........
 800dd4e:	0f070300 c0f8feff 0388006b f87f3f1f     ........k....?..
 800dd5e:	05e0e0f0 e0e087c0 1f3f7cf0 0900720f     .........|?..r..
 800dd6e:	88005a01 08888870 80001008 80834004     .Z..p........@..
 800dd7e:	40048000 80008083 80824003 810008f8     ...@.....@......
 800dd8e:	860004f8 400000f8 0003d840 0380c082     .......@@.......
 800dd9e:	00808340 83400480 03800080 f8808240     @.....@.....@...
 800ddae:	0888003b 11111010 040f000e 00138312     ;...............
 800ddbe:	8312040f 030f0013 1f088210 07860008     ................
 800ddce:	18070718 81000407 8200031f 0803047f     ................
 800ddde:	0f000783 13831204 10030f00 7f1f0882     ................
 800ddee:	00001e00                                ....

0800ddf2 <screen_replug>:
 800ddf2:	007f007f 002f007f 0804f881 8000f083     ....../.........
 800de02:	80844004 0380c000 00808440 0005f800     .@......@.......
 800de12:	0004c081 8000c083 80824003 880057c0     .........@...W..
 800de22:	0503011f 0f001009 13841204 03047f00     ................
 800de32:	00078408 10030f00 0f000083 08841003     ................
 800de42:	0347001f 7f848288 007f007f 002e007f     ..G.............
	...

0800de53 <screen_brick>:
 800de53:	007f007f 002b007f 8803f881 0000f085     ......+.........
 800de63:	400380c0 00008086 03d84040 04808100     ...@....@@......
 800de73:	00808a40 800000f8 80000040 80834004     @.......@....@..
 800de83:	40038000 50f88082 041f8100 000f8310     ...@...P........
 800de93:	8100091f 8100031f 8a10040f 021f0008     ................
 800dea3:	10080403 12040f00 0f001383 08821003     ................
 800deb3:	7f007f1f 2b007f00 007f0000                       .......+..

0800debd <screen_search>:
 800debd:	002b007f c0c08083 c003e006 000c8081     ..+.............
 800decd:	60e0e083 6003e006 60e0e085 005380c0     ...`...`...`..S.
 800dedd:	fffef886 0303071f 03008101 07038601     ................
 800deed:	f0fcffff ff840009 051f00ff 8930033f     ............?.0.
 800defd:	00001f3f fc060301 86004ff8 3f1f0f03     ?........O.....?
 800df0d:	f003787c f0f0e08c 7f7c7870 c0e1f7ff     |x......px|.....
 800df1d:	85000780 fc00ffff 86060afe 0000fefe     ................
 800df2d:	0060ffff 03030182 81000607 81031301     ..`.............
 800df3d:	88003f01 08888870 80001008 80834004     .?..p........@..
 800df4d:	40040000 c0008084 83400380 04800080     ...@......@.....
 800df5d:	00808440 400380f8 00008086 03d84040     @......@....@@..
 800df6d:	80c08200 80834003 40038000 42c08082     .....@.....@...B
 800df7d:	10088800 0e111110 12040f00 0e001383     ................
 800df8d:	09841103 061f001f 040f8100 00088310     ................
 800df9d:	8100041f 8100041f 8100031f 8300041f     ................
 800dfad:	0347001f 7f848788 38100000 83000410     ..G........8....
 800dfbd:	04103810 38108300 19007f10 007f0000              .8.....8......

0800dfcb <screen_mitm>:
 800dfcb:	007f007f 0043007f 0c30c083 01060073     ......C...0.s...
 800dfdb:	0c300084 06000403 7f007f01 39007f00     ..0............9
	...

0800dfed <screen_recovery>:
 800dfed:	0030007f c0c08084 83001080 0660e0e0     ..0...........`.
 800dffd:	856003e0 c060e0e0 07005480 c7c38cc0     ..`...`..T......
 800e00d:	feffdfcf e0f0f8fc 000880c0 00ffff84     ................
 800e01d:	033f051f 1f3f8930 03010000 50f8fc06     ..?.0.?........P
 800e02d:	83070700 03f7e7c7 3f7f87ff 03070f1f     ...........?....
 800e03d:	85000701 fc00ffff 86060afe 0000fefe     ................
 800e04d:	0057ffff 07070385 000f0103 03130181     ..W.............
 800e05d:	00420181 f8080889 00000808 400380c0     ..B............@
 800e06d:	80008083 80834004 40048000 c0008084     .....@.....@....
 800e07d:	84400380 f0400080 00094003 0804f081     ..@...@..@......
 800e08d:	00003083 80844004 0380c000 00808340     .0...@......@...
 800e09d:	82400380 0034f880 1f101088 00001010     ..@...4.........
 800e0ad:	8300041f 0409001f 000c8312 8312040f     ................
 800e0bd:	071f0013 030f8100 08088110 040f8100     ................
 800e0cd:	000c8310 8411030e 1f001f09 0f810006     ................
 800e0dd:	08821003 1b007f1f 007f0000                       ..........

0800e0e7 <screen_se1_issue>:
 800e0e7:	0038007f 00048081 04e0c082 c0e082f0     ..8.............
 800e0f7:	80840072 05fe8783 0c0c82fc fe85fc05     r...............
 800e107:	80818387 0103006a 03e78182 ffff867f     ....j...........
 800e117:	ffff0000 ef857f03 010181c1 0182006c     ............l...
 800e127:	82000e01 00630101 0004f881 0000f889     ......c.........
 800e137:	f80830c0 80060000 88700089 10080888     .0........p.....
 800e147:	8804f800 40000886 59f81020 040f8100     .......@ ..Y....
 800e157:	000f8310 83020303 0600021f 08008904     ................
 800e167:	11111010 051f000e 81000410 2e007f1f     ................
 800e177:	6f640000 72676e77 00656461 20676973     ..downgrade.sig 
 800e187:	6c696166 52415700 52203a4e 6c206465     fail.WARN: Red l
 800e197:	74686769 52415700 55203a4e 6769736e     ight.WARN: Unsig
 800e1a7:	2064656e 6d726966 65726177 6f6f4700     ned firmware.Goo
 800e1b7:	69662064 61776d72 63006572 7572726f     d firmware.corru
 800e1c7:	66207470 776d7269 00657261 66206f6e     pt firmware.no f
 800e1d7:	776d7269 00657261                       irmware.

0800e1df <approved_pubkeys>:
 800e1df:	2641cbb4 f36ce1f7 71b4f28f 0123fb1d     ..A&..l....q..#.
 800e1ef:	66d6760d 6ca38aa7 f6f9539b 0518587b     .v.f...l.S..{X..
 800e1ff:	e93b0b58 b89fc431 113c0444 470f0896     X.;.1...D.<....G
 800e20f:	37ed2581 4a9e237a 3818b7af da0438ba     .%.7z#.J...8.8..
 800e21f:	1dc8a2d6 df5e811c 6d290ca6 8d8f57b8     ......^...)m.W..
 800e22f:	9269295e c178d1ce 31d7207b b596a17b     ^)i...x.{ .1{...
 800e23f:	0c1bef3d c31a79aa c8c45845 ffeb2d8a     =....y..EX...-..
 800e24f:	01829bfe bc5e5f87 4fe5a596 9ffe68c7     ....._^....O.h..
 800e25f:	0166ef42 95cfc456 38f0b5f4 c5261164     B.f.V......8d.&.
 800e26f:	66c13999 14120632 689c254c bad38c35     .9.f2...L%.h5...
 800e27f:	8cde7824 6cdfab52 7809bfb8 3a63bb03     $x..R..l...x..c:
 800e28f:	0ed90111 8f737aa4 7f3b18bf c87b0af0     .....zs...;...{.
 800e29f:	56546067 c5ec0c82 0882bc1d ef39c116     g`TV..........9.
 800e2af:	32babff5 e35fce7c d7621e74 4cc5fce9     ...2|._.t.b....L
 800e2bf:	8d11e88a 13c2adc3 2a4f2992 a4f8d2ea     .........)O*....
 800e2cf:	fe7cd5c4 3b450512 07598954 88d7d6da     ..|...E;T.Y.....
 800e2df:	37cfb143 1f897cd2 f3acfe5b 95fc33ba     C..7.|..[....3..
 800e2ef:	dde7d981 14ef9525 bb97efdd a7d8f333     ....%.......3...
 800e2ff:	977a2b34 73aab3ba 32419de7 17a1fcd8     4+z....s..A2....
 800e30f:	fe0bb566 89214063 8e7b92c9 590bdf72     f...c@!...{.r..Y
	...
 800e35f:	20314553 666e6f63 66206769 006c6961     SE1 config fail.
 800e36f:	6c706572 72206775 69757165 00646572     replug required.
 800e37f:	72726f63 20747075 72696170 63657320     corrupt pair sec
 800e38f:	206b6d00 6c6c7566 73616600 72622074     .mk full.fast br
 800e39f:	08006b63 00000141 00000000 00000000     ck..A...........
 800e3af:	01ee0000 706f4323 67697279 32207468     ....#Copyright 2
 800e3bf:	2d383130 20796220 6e696f43 6574696b     018- by Coinkite
 800e3cf:	636e4920 6f6e002e 72657320 206b7700      Inc..no ser.wk 
 800e3df:	02006c66                                         fl.

0800e3e2 <config_2.9775>:
 800e3e2:	00001502 003c0000 01bc005c 01bc01fc     ......<.\.......
 800e3f2:	019c019c 03dc03d1 03dc03dc 03dc03dc     ................
 800e402:	01dc03dc 00e1003c                                ....<.

0800e408 <config_1.9774>:
 800e408:	006100e1 808f0000 438f808f 430080af     ..a........C...C
 800e418:	20834300 43c343c3 43c343c3 43c343c3     .C. .C.C.C.C.C.C
 800e428:	0000438f ffffffff 00000000 ffffffff     .C..............
	...
 800e440:	000000f0 00000000 00000000 00000001     ................
 800e450:	00000012 00000000 00000001 00000008     ................
 800e460:	00000200 00000002 00000000 00000001     ................
 800e470:	00000007                                ....

0800e474 <CSWTCH.23>:
 800e474:	0d0c0b09                                ....

0800e478 <version_string>:
 800e478:	2e302e33 69742030 323d656d 30323230     3.0.0 time=20220
 800e488:	2e373131 37333031 67203833 6d3d7469     117.103738 git=m
 800e498:	3840346b 34323038 0d003338 3130000a              k4@8802483....

0800e4a6 <hexmap>:
 800e4a6:	33323130 37363534 62613938 66656463     0123456789abcdef

0800e4b6 <CSWTCH.73>:
 800e4b6:	08020401                                ....

0800e4ba <CSWTCH.74>:
 800e4ba:	10101000 10101004 10101002 fc000008     ................
 800e4ca:	00020000 00000000 00030000 000a0000     ................
 800e4da:	00080000 00100000 53500000 204d4152     ..........PSRAM 
 800e4ea:	6c696166 52535000 616e203a 50006164     fail.PSR: nada.P
 800e4fa:	203a5253 65686321 50006b63 203a5253     SR: !check.PSR: 
 800e50a:	73726576 006e6f69 1f000000 00020000     version.........
 800e51a:	00010000 00030000 000c0000 00040000     ................
 800e52a:	00020000 00010000 00030000 000c0000     ................
 800e53a:	46440000 61702055 20657372 6c696166     ..DFU parse fail
 800e54a:	6f6f6700 69662064 61776d72 77006572     .good firmware.w
 800e55a:	676e6f72 726f7720 5300646c 72614344     rong world.SDCar
 800e56a:	00203a64 74696e69 69616620 7073006c     d: .init fail.sp
 800e57a:	00646565 65646977 69736200 003f657a     eed.wide.bsize?.
 800e58a:	66006b6f 206c6961 64616572 75664400     ok.fail read.Dfu
 800e59a:	66006553 646e756f 00204020 6f636552     Se.found @ .Reco
 800e5aa:	79726576 646f6d20 00002e65 20080000              very mode.....

0800e5b8 <curve_secp256k1>:
 800e5b8:	01002008 fffffc2f fffffffe ffffffff     . ../...........
 800e5c8:	ffffffff ffffffff ffffffff ffffffff     ................
 800e5d8:	ffffffff d0364141 bfd25e8c af48a03b     ....AA6..^..;.H.
 800e5e8:	baaedce6 fffffffe ffffffff ffffffff     ................
 800e5f8:	ffffffff 16f81798 59f2815b 2dce28d9     ........[..Y.(.-
 800e608:	029bfcdb ce870b07 55a06295 f9dcbbac     .........b.U....
 800e618:	79be667e fb10d4b8 9c47d08f a6855419     ~f.y......G..T..
 800e628:	fd17b448 0e1108a8 5da4fbfc 26a3c465     H..........]e..&
 800e638:	483ada77 00000007 00000000 00000000     w.:H............
	...
 800e65c:	080066d9 08005993 08005bbf 08005d85     .f...Y...[...]..

0800e66c <curve_secp256r1>:
 800e66c:	01002008 ffffffff ffffffff ffffffff     . ..............
	...
 800e688:	00000001 ffffffff fc632551 f3b9cac2     ........Q%c.....
 800e698:	a7179e84 bce6faad ffffffff ffffffff     ................
 800e6a8:	00000000 ffffffff d898c296 f4a13945     ............E9..
 800e6b8:	2deb33a0 77037d81 63a440f2 f8bce6e5     .3.-.}.w.@.c....
 800e6c8:	e12c4247 6b17d1f2 37bf51f5 cbb64068     GB,....k.Q.7h@..
 800e6d8:	6b315ece 2bce3357 7c0f9e16 8ee7eb4a     .^1kW3.+...|J...
 800e6e8:	fe1a7f9b 4fe342e2 27d2604b 3bce3c3e     .....B.OK`.'><.;
 800e6f8:	cc53b0f6 651d06b0 769886bc b3ebbd55     ..S....e...vU...
 800e708:	aa3a93e7 5ac635d8 08005ea1 08005993     ..:..5.Z.^...Y..
 800e718:	08005feb 08005bed                       ._...[..

0800e720 <AHBPrescTable>:
	...
 800e728:	04030201 09080706                       ........

0800e730 <APBPrescTable>:
 800e730:	00000000 04030201                       ........

0800e738 <MSIRangeTable>:
 800e738:	000186a0 00030d40 00061a80 000c3500     ....@........5..
 800e748:	000f4240 001e8480 003d0900 007a1200     @B........=...z.
 800e758:	00f42400 016e3600 01e84800 02dc6c00     .$...6n..H...l..
 800e768:	00006000 00000012 00000000 00000003     .`..............
 800e778:	00000004 00007021                                ....!p.

0800e77f <DEV_MANID>:
 800e77f:	00008000 00000000                                .....

Disassembly of section .relocate:

20000000 <flash_burn>:
//
    __attribute__((section(".ramfunc")))
    __attribute__((noinline))
    int
flash_burn(uint32_t address, uint64_t val)
{
20000000:	b530      	push	{r4, r5, lr}
    __attribute__((section(".ramfunc")))
    __attribute__((always_inline))
    static inline uint32_t
_flash_wait_done(void)
{
    while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) {
20000002:	4d22      	ldr	r5, [pc, #136]	; (2000008c <BL_SRAM_BASE+0x8c>)
20000004:	692c      	ldr	r4, [r5, #16]
20000006:	4921      	ldr	r1, [pc, #132]	; (2000008c <BL_SRAM_BASE+0x8c>)
20000008:	03e4      	lsls	r4, r4, #15
2000000a:	d4fb      	bmi.n	20000004 <flash_burn+0x4>
        // busy wait
    }

    uint32_t error = (FLASH->SR & FLASH_FLAG_SR_ERRORS);
2000000c:	690d      	ldr	r5, [r1, #16]
    if(error) {
2000000e:	4c20      	ldr	r4, [pc, #128]	; (20000090 <BL_SRAM_BASE+0x90>)
20000010:	402c      	ands	r4, r5
20000012:	b924      	cbnz	r4, 2000001e <flash_burn+0x1e>
        // Save an error code; somewhat random, depends on chip details
        return error;
    }

    // Check FLASH End of Operation flag
    if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP)) {
20000014:	690c      	ldr	r4, [r1, #16]
20000016:	07e4      	lsls	r4, r4, #31
        // Clear FLASH End of Operation pending bit
        __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
20000018:	bf44      	itt	mi
2000001a:	2401      	movmi	r4, #1
2000001c:	610c      	strmi	r4, [r1, #16]

    // just in case?
    _flash_wait_done();

    // clear any and all errors, including PEMPTY
    FLASH->SR = FLASH->SR & FLASH_FLAG_SR_ERRORS;
2000001e:	491b      	ldr	r1, [pc, #108]	; (2000008c <BL_SRAM_BASE+0x8c>)
20000020:	4c1b      	ldr	r4, [pc, #108]	; (20000090 <BL_SRAM_BASE+0x90>)
20000022:	690d      	ldr	r5, [r1, #16]
20000024:	402c      	ands	r4, r5
20000026:	610c      	str	r4, [r1, #16]

    // disable data cache
    __HAL_FLASH_DATA_CACHE_DISABLE();
20000028:	680c      	ldr	r4, [r1, #0]
2000002a:	f424 6480 	bic.w	r4, r4, #1024	; 0x400
2000002e:	600c      	str	r4, [r1, #0]

    // Program double-word (64-bit) at a specified address
    // see FLASH_Program_DoubleWord(Address, Data);

    // Set PG bit
    CLEAR_BIT(FLASH->CR, (FLASH_CR_PG | FLASH_CR_MER1 | FLASH_CR_PER | FLASH_CR_PNB));      // added
20000030:	694c      	ldr	r4, [r1, #20]
20000032:	f424 64ff 	bic.w	r4, r4, #2040	; 0x7f8
20000036:	f024 0407 	bic.w	r4, r4, #7
2000003a:	614c      	str	r4, [r1, #20]
    SET_BIT(FLASH->CR, FLASH_CR_PG);
2000003c:	694c      	ldr	r4, [r1, #20]
2000003e:	f044 0401 	orr.w	r4, r4, #1
20000042:	614c      	str	r4, [r1, #20]

    // Program a double word
    *(__IO uint32_t *)(address) = (uint32_t)val;
20000044:	6002      	str	r2, [r0, #0]
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__STATIC_FORCEINLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
20000046:	f3bf 8f6f 	isb	sy
    __ISB();                                        // instruction-order barrier
    *(__IO uint32_t *)(address+4) = (uint32_t)(val >> 32);
2000004a:	6043      	str	r3, [r0, #4]
    __attribute__((section(".ramfunc")))
    __attribute__((always_inline))
    static inline uint32_t
_flash_wait_done(void)
{
    while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) {
2000004c:	690a      	ldr	r2, [r1, #16]
2000004e:	4b0f      	ldr	r3, [pc, #60]	; (2000008c <BL_SRAM_BASE+0x8c>)
20000050:	03d0      	lsls	r0, r2, #15
20000052:	d4fb      	bmi.n	2000004c <flash_burn+0x4c>
        // busy wait
    }

    uint32_t error = (FLASH->SR & FLASH_FLAG_SR_ERRORS);
20000054:	691a      	ldr	r2, [r3, #16]
20000056:	480e      	ldr	r0, [pc, #56]	; (20000090 <BL_SRAM_BASE+0x90>)
20000058:	4010      	ands	r0, r2
    if(error) {
2000005a:	b9b0      	cbnz	r0, 2000008a <flash_burn+0x8a>
        // Save an error code; somewhat random, depends on chip details
        return error;
    }

    // Check FLASH End of Operation flag
    if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP)) {
2000005c:	691a      	ldr	r2, [r3, #16]
2000005e:	07d2      	lsls	r2, r2, #31
        // Clear FLASH End of Operation pending bit
        __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
20000060:	bf44      	itt	mi
20000062:	2201      	movmi	r2, #1
20000064:	611a      	strmi	r2, [r3, #16]

    rv = _flash_wait_done();
    if(rv) return rv;

    // If the program operation is completed, disable the PG or FSTPG Bit
    CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
20000066:	4b09      	ldr	r3, [pc, #36]	; (2000008c <BL_SRAM_BASE+0x8c>)
20000068:	695a      	ldr	r2, [r3, #20]
2000006a:	f022 0201 	bic.w	r2, r2, #1
2000006e:	615a      	str	r2, [r3, #20]

    // Flush the caches to be sure of data consistency, and reenable.
    __HAL_FLASH_DATA_CACHE_RESET();
20000070:	681a      	ldr	r2, [r3, #0]
20000072:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
20000076:	601a      	str	r2, [r3, #0]
20000078:	681a      	ldr	r2, [r3, #0]
2000007a:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
2000007e:	601a      	str	r2, [r3, #0]
    __HAL_FLASH_DATA_CACHE_ENABLE();
20000080:	681a      	ldr	r2, [r3, #0]
20000082:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
20000086:	601a      	str	r2, [r3, #0]

    return 0;
20000088:	2000      	movs	r0, #0
}
2000008a:	bd30      	pop	{r4, r5, pc}
2000008c:	40022000 	.word	0x40022000
20000090:	0002c3fa 	.word	0x0002c3fa

20000094 <flash_page_erase>:
//
    __attribute__((section(".ramfunc")))
    __attribute__((noinline))
    int
flash_page_erase(uint32_t address)
{
20000094:	0b00      	lsrs	r0, r0, #12
    uint32_t    page_num = (address & 0x7ffffff) / FLASH_PAGE_SIZE;
20000096:	f3c0 010e 	ubfx	r1, r0, #0, #15

    // protect ourselves!
    if(page_num < ((BL_FLASH_SIZE + BL_NVROM_SIZE) / FLASH_PAGE_SIZE)) {
2000009a:	291f      	cmp	r1, #31
//
    __attribute__((section(".ramfunc")))
    __attribute__((noinline))
    int
flash_page_erase(uint32_t address)
{
2000009c:	b510      	push	{r4, lr}
    uint32_t    page_num = (address & 0x7ffffff) / FLASH_PAGE_SIZE;

    // protect ourselves!
    if(page_num < ((BL_FLASH_SIZE + BL_NVROM_SIZE) / FLASH_PAGE_SIZE)) {
2000009e:	d95a      	bls.n	20000156 <flash_page_erase+0xc2>
    __attribute__((section(".ramfunc")))
    __attribute__((always_inline))
    static inline uint32_t
_flash_wait_done(void)
{
    while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) {
200000a0:	4c2e      	ldr	r4, [pc, #184]	; (2000015c <flash_page_erase+0xc8>)
        return 1;
    }

    // always operate on both banks.
    bool bank2 = (page_num >= 256);
    page_num &= 0xff;
200000a2:	b2c0      	uxtb	r0, r0
    __attribute__((section(".ramfunc")))
    __attribute__((always_inline))
    static inline uint32_t
_flash_wait_done(void)
{
    while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) {
200000a4:	6922      	ldr	r2, [r4, #16]
200000a6:	4b2d      	ldr	r3, [pc, #180]	; (2000015c <flash_page_erase+0xc8>)
200000a8:	03d2      	lsls	r2, r2, #15
200000aa:	d4fb      	bmi.n	200000a4 <flash_page_erase+0x10>
        // busy wait
    }

    uint32_t error = (FLASH->SR & FLASH_FLAG_SR_ERRORS);
200000ac:	691c      	ldr	r4, [r3, #16]
    if(error) {
200000ae:	4a2c      	ldr	r2, [pc, #176]	; (20000160 <flash_page_erase+0xcc>)
200000b0:	4022      	ands	r2, r4
200000b2:	b922      	cbnz	r2, 200000be <flash_page_erase+0x2a>
        // Save an error code; somewhat random, depends on chip details
        return error;
    }

    // Check FLASH End of Operation flag
    if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP)) {
200000b4:	691a      	ldr	r2, [r3, #16]
200000b6:	07d4      	lsls	r4, r2, #31
        // Clear FLASH End of Operation pending bit
        __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
200000b8:	bf44      	itt	mi
200000ba:	2201      	movmi	r2, #1
200000bc:	611a      	strmi	r2, [r3, #16]

    // just in case?
    _flash_wait_done();

    // clear any and all errors
    FLASH->SR = FLASH->SR & 0xffff;
200000be:	4b27      	ldr	r3, [pc, #156]	; (2000015c <flash_page_erase+0xc8>)
200000c0:	691a      	ldr	r2, [r3, #16]
200000c2:	b292      	uxth	r2, r2
200000c4:	611a      	str	r2, [r3, #16]

    // disable data cache
    __HAL_FLASH_DATA_CACHE_DISABLE();
200000c6:	681a      	ldr	r2, [r3, #0]
200000c8:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
200000cc:	601a      	str	r2, [r3, #0]

    // choose appropriate bank to work on.
    if(bank2) {
        SET_BIT(FLASH->CR, FLASH_CR_BKER);
200000ce:	695a      	ldr	r2, [r3, #20]

    // disable data cache
    __HAL_FLASH_DATA_CACHE_DISABLE();

    // choose appropriate bank to work on.
    if(bank2) {
200000d0:	29ff      	cmp	r1, #255	; 0xff
        SET_BIT(FLASH->CR, FLASH_CR_BKER);
200000d2:	bf8c      	ite	hi
200000d4:	f442 6200 	orrhi.w	r2, r2, #2048	; 0x800
    } else {
        CLEAR_BIT(FLASH->CR, FLASH_CR_BKER);
200000d8:	f422 6200 	bicls.w	r2, r2, #2048	; 0x800
200000dc:	615a      	str	r2, [r3, #20]
    }

    // Proceed to erase the page
    MODIFY_REG(FLASH->CR, FLASH_CR_PNB, (page_num << POSITION_VAL(FLASH_CR_PNB)));
200000de:	695a      	ldr	r2, [r3, #20]
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
200000e0:	f44f 63ff 	mov.w	r3, #2040	; 0x7f8
200000e4:	f422 62ff 	bic.w	r2, r2, #2040	; 0x7f8
200000e8:	fa93 f3a3 	rbit	r3, r3
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
200000ec:	b113      	cbz	r3, 200000f4 <flash_page_erase+0x60>
  {
    return 32U;
  }
  return __builtin_clz(value);
200000ee:	fab3 f383 	clz	r3, r3
200000f2:	e000      	b.n	200000f6 <flash_page_erase+0x62>
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
  {
    return 32U;
200000f4:	2320      	movs	r3, #32
200000f6:	fa00 f303 	lsl.w	r3, r0, r3
200000fa:	ea43 0002 	orr.w	r0, r3, r2
200000fe:	4b17      	ldr	r3, [pc, #92]	; (2000015c <flash_page_erase+0xc8>)
20000100:	6158      	str	r0, [r3, #20]
    SET_BIT(FLASH->CR, FLASH_CR_PER);
20000102:	695a      	ldr	r2, [r3, #20]
20000104:	f042 0202 	orr.w	r2, r2, #2
20000108:	615a      	str	r2, [r3, #20]
    SET_BIT(FLASH->CR, FLASH_CR_STRT);
2000010a:	695a      	ldr	r2, [r3, #20]
2000010c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
20000110:	615a      	str	r2, [r3, #20]
    __attribute__((section(".ramfunc")))
    __attribute__((always_inline))
    static inline uint32_t
_flash_wait_done(void)
{
    while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) {
20000112:	6919      	ldr	r1, [r3, #16]
20000114:	4a11      	ldr	r2, [pc, #68]	; (2000015c <flash_page_erase+0xc8>)
20000116:	03c9      	lsls	r1, r1, #15
20000118:	d4fb      	bmi.n	20000112 <flash_page_erase+0x7e>
        // busy wait
    }

    uint32_t error = (FLASH->SR & FLASH_FLAG_SR_ERRORS);
2000011a:	6911      	ldr	r1, [r2, #16]
    if(error) {
2000011c:	4b10      	ldr	r3, [pc, #64]	; (20000160 <flash_page_erase+0xcc>)
2000011e:	400b      	ands	r3, r1
20000120:	b923      	cbnz	r3, 2000012c <flash_page_erase+0x98>
        // Save an error code; somewhat random, depends on chip details
        return error;
    }

    // Check FLASH End of Operation flag
    if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP)) {
20000122:	6913      	ldr	r3, [r2, #16]
20000124:	07db      	lsls	r3, r3, #31
        // Clear FLASH End of Operation pending bit
        __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
20000126:	bf44      	itt	mi
20000128:	2301      	movmi	r3, #1
2000012a:	6113      	strmi	r3, [r2, #16]

    // Wait til done
    _flash_wait_done();

    // If the erase operation is completed, disable the PER Bit
    CLEAR_BIT(FLASH->CR, (FLASH_CR_PER | FLASH_CR_PNB));
2000012c:	4b0b      	ldr	r3, [pc, #44]	; (2000015c <flash_page_erase+0xc8>)
2000012e:	695a      	ldr	r2, [r3, #20]
20000130:	f422 62ff 	bic.w	r2, r2, #2040	; 0x7f8
20000134:	f022 0202 	bic.w	r2, r2, #2
20000138:	615a      	str	r2, [r3, #20]

    // Flush the caches to be sure of data consistency, and reenable.
    __HAL_FLASH_DATA_CACHE_RESET();
2000013a:	681a      	ldr	r2, [r3, #0]
2000013c:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
20000140:	601a      	str	r2, [r3, #0]
20000142:	681a      	ldr	r2, [r3, #0]
20000144:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
20000148:	601a      	str	r2, [r3, #0]
    __HAL_FLASH_DATA_CACHE_ENABLE();
2000014a:	681a      	ldr	r2, [r3, #0]
2000014c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
20000150:	601a      	str	r2, [r3, #0]

    return 0;
20000152:	2000      	movs	r0, #0
20000154:	bd10      	pop	{r4, pc}
{
    uint32_t    page_num = (address & 0x7ffffff) / FLASH_PAGE_SIZE;

    // protect ourselves!
    if(page_num < ((BL_FLASH_SIZE + BL_NVROM_SIZE) / FLASH_PAGE_SIZE)) {
        return 1;
20000156:	2001      	movs	r0, #1
    // Flush the caches to be sure of data consistency, and reenable.
    __HAL_FLASH_DATA_CACHE_RESET();
    __HAL_FLASH_DATA_CACHE_ENABLE();

    return 0;
}
20000158:	bd10      	pop	{r4, pc}
2000015a:	bf00      	nop
2000015c:	40022000 	.word	0x40022000
20000160:	0002c3fa 	.word	0x0002c3fa
